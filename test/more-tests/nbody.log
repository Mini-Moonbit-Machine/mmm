// [Asm] LoweringOrder: [0, 2, 1, 3]
// [Asm] LoweringOrder: [[1, 2], [3], [3], []]
// [Asm] LoweringOrder: HashMap::of([(b0, 0), (b1, 0), (b2, 1), (b3, 0)])
// [Asm] LoweringOrder: [b0, b1, b3, b2]
// [Asm] LoweringOrder: HashMap::of([(b0, 0), (b1, 1), (b2, 0), (b3, 2)])
// [Asm] pre_assigned_registers: Insn(iref=%15) -> v22, Mem(fref=f6, mref=m0) -> v5, BlockParam(bref=b3, bpref=$b.0) -> v26, Insn(iref=%9) -> fv16, Insn(iref=%16) -> v23, FnParam(fref=f6, fpref=$f.0) -> v2, FnParam(fref=f6, fpref=$f.2) -> v4, Insn(iref=%8) -> fv15, Insn(iref=%10) -> fv17, Insn(iref=%14) -> fv21, Self(fref=f6) -> v0, Insn(iref=%5) -> fv12, Insn(iref=%0) -> v6, Insn(iref=%4) -> fv11, FnParam(fref=f6, fpref=$f.1) -> fv3, Insn(iref=%3) -> fv10, Insn(iref=%18) -> v25, Insn(iref=%13) -> fv20, Insn(iref=%7) -> fv14, Insn(iref=%17) -> v24, Insn(iref=%2) -> fv9, Insn(iref=%1) -> v8, Insn(iref=%11) -> fv18, Insn(iref=%21) -> v7, Insn(iref=%6) -> fv13, Insn(iref=%12) -> fv19
// [Asm] succs: []
// [Asm] critical edges for b3: []
// [Asm] critical color seq for b3: []
// [Asm] succs: [3]
// [Asm] critical edges for b1: []
// [Asm] critical color seq for b1: []
// [Asm] skipping Op(ty=Double, op=Mul, args=[FnParam(fref=f6, fpref=$f.1), Insn(iref=%7)])
// [Asm] skipping Op(ty=Double, op=Mul, args=[FnParam(fref=f6, fpref=$f.1), Insn(iref=%6)])
// [Asm] skipping Op(ty=Double, op=Mul, args=[FnParam(fref=f6, fpref=$f.1), Insn(iref=%5)])
// [Asm] succs: [3]
// [Asm] critical edges for b2: []
// [Asm] critical color seq for b2: []
// [Asm] succs: [1, 2]
// [Asm] critical edges for b0: []
// [Asm] critical color seq for b0: []
// [Asm] skipping Op(ty=Bool, op=Le, args=[FnParam(fref=f6, fpref=$f.0), Int32(val=4)])
// [Asm] defs: []
// [Asm] live_set: [zero, a0, fa0, a1, s11]
// [Asm] defs: [v2]
// [Asm] live_set: [zero, fa0, a1, s11, v2]
// [Asm] move: v2 <- a0
// [Asm] defined: v2 is X
// [Asm] defs: [fv3]
// [Asm] live_set: [zero, a1, s11, fv3, v2]
// [Asm] move: fv3 <- fa0
// [Asm] defined: fv3 is F
// [Asm] defs: [v4]
// [Asm] live_set: [zero, v4, s11, fv3, v2]
// [Asm] move: v4 <- a1
// [Asm] defined: v4 is X
// [Asm] defs: [v44]
// [Asm] live_set: [zero, v4, s11, v44, fv3, v2]
// [Asm] defined: v44 is X
// [Asm] defs: []
// [Asm] live_set: [v4, s11, fv3, zero, v2]
// [Asm] defs: [a0]
// [Asm] live_set: [a0]
// [Asm] move: a0 <- zero
// [Asm] defined: a0 is X
// [Asm] defs: []
// [Asm] live_set: [a0]
// [Asm] defs: []
// [Asm] live_set: []
// [Asm] defs: [v26]
// [Asm] live_set: [v26, zero]
// [Asm] move: v26 <- zero
// [Asm] defined: v26 is X
// [Asm] skip edge 7 -> 2
// [Asm] defs: []
// [Asm] live_set: [v26, zero]
// [Asm] defs: [v7]
// [Asm] live_set: [v7, s11, zero, v4, fv3, v2]
// [Asm] defined: v7 is X
// [Asm] defs: [v41]
// [Asm] live_set: [v7, v41, s11, zero, v4, fv3, v2]
// [Asm] defined: v41 is X
// [Asm] defs: [v8]
// [Asm] live_set: [v7, s11, zero, v8, v4, fv3, v2]
// [Asm] defined: v8 is X
// [Asm] defs: [fv9]
// [Asm] live_set: [v7, s11, fv9, zero, v8, v4, fv3, v2]
// [Asm] defined: fv9 is F
// [Asm] defs: [fv10]
// [Asm] live_set: [fv10, v7, s11, fv9, zero, v8, v4, fv3, v2]
// [Asm] defined: fv10 is F
// [Asm] defs: [fv11]
// [Asm] live_set: [fv10, v7, s11, fv9, zero, fv11, v8, v4, fv3, v2]
// [Asm] defined: fv11 is F
// [Asm] defs: [fv12]
// [Asm] live_set: [fv10, v7, fv12, s11, fv9, zero, fv11, v8, v4, fv3, v2]
// [Asm] defined: fv12 is F
// [Asm] defs: [fv13]
// [Asm] live_set: [fv10, v7, fv12, s11, fv9, zero, fv11, fv13, v8, v4, fv3, v2]
// [Asm] defined: fv13 is F
// [Asm] defs: [fv14]
// [Asm] live_set: [fv10, v7, fv12, fv14, s11, fv9, zero, fv11, fv13, v8, v4, fv3, v2]
// [Asm] defined: fv14 is F
// [Asm] defs: [fv15]
// [Asm] live_set: [fv10, v7, fv12, fv14, s11, fv15, fv9, zero, fv11, fv13, v4, fv3, v2]
// [Asm] defined: fv15 is F
// [Asm] defs: [fv17]
// [Asm] live_set: [fv10, v7, fv12, fv14, s11, fv15, zero, fv11, fv13, v4, fv3, fv17, v2]
// [Asm] defined: fv17 is F
// [Asm] defs: [fv19]
// [Asm] live_set: [v7, fv19, fv12, fv14, s11, fv15, zero, fv11, fv13, v4, fv3, fv17, v2]
// [Asm] defined: fv19 is F
// [Asm] defs: [fv21]
// [Asm] live_set: [v2, v7, fv19, fv12, fv14, s11, fv15, zero, fv13, v4, fv3, fv17, fv21]
// [Asm] defined: fv21 is F
// [Asm] defs: [v5]
// [Asm] live_set: [v2, v5, v7, fv19, fv12, fv14, fv15, zero, fv13, v4, fv3, fv17, fv21]
// [Asm] defined: v5 is X
// [Asm] defs: [s11]
// [Asm] live_set: [v2, v5, v7, fv19, fv12, fv14, fv15, zero, fv13, v4, fv3, fv17, fv21]
// [Asm] defined: s11 is X
// [Asm] defs: []
// [Asm] live_set: [v2, v5, zero, v7, fv13, fv19, fv12, v4, fv14, fv15, fv3, fv21]
// [Asm] defs: []
// [Asm] live_set: [v5, zero, v7, fv13, v4, fv12, fv14, fv15, fv3, fv21, v2]
// [Asm] defs: []
// [Asm] live_set: [v5, zero, v7, fv13, v4, fv12, fv14, fv15, fv3, v2]
// [Asm] defs: []
// [Asm] live_set: [v5, zero, v7, fv13, v4, fv14, fv15, fv3, v2]
// [Asm] defs: []
// [Asm] live_set: [v5, zero, v7, v4, fv14, fv15, fv3, v2]
// [Asm] defs: []
// [Asm] live_set: [v5, zero, v7, v4, fv15, fv3, v2]
// [Asm] defs: []
// [Asm] live_set: [v7, v4, v5, zero, fv3, v2]
// [Asm] defs: [v29]
// [Asm] live_set: [v2, v4, v5, zero, fv3, v29]
// [Asm] defined: v29 is X
// [Asm] defs: []
// [Asm] live_set: [v4, zero, fv3, v2]
// [Asm] defs: [v24]
// [Asm] live_set: [v4, v24, zero, fv3]
// [Asm] defined: v24 is X
// [Asm] defs: []
// [Asm] live_set: [v4, v24, zero, fv3]
// [Asm] defs: [a0]
// [Asm] live_set: [v4, zero, a0, fv3]
// [Asm] move: a0 <- v24
// [Asm] defined: a0 is X
// [Asm] defs: [fa0]
// [Asm] live_set: [v4, zero, a0, fa0]
// [Asm] move: fa0 <- fv3
// [Asm] defined: fa0 is F
// [Asm] defs: [a1]
// [Asm] live_set: [a1, zero, a0, fa0]
// [Asm] move: a1 <- v4
// [Asm] defined: a1 is X
// [Asm] defs: [t0, t1, t2, t3, t4, a0, a1, a2, a3, a4, a5, a6, a7, t0, t1, ft0, ft1, ft2, ft3, ft4, ft5, ft6, ft7, ft8, ft9, ft10, fa0, fa1, fa2, fa3, fa4, fa5, fa6, fa7]
// [Asm] live_set: [zero, a0]
// [Asm] defined: t0 is X
// [Asm] defined: t1 is X
// [Asm] defined: t2 is X
// [Asm] defined: t3 is X
// [Asm] defined: t4 is X
// [Asm] defined: a0 is X
// [Asm] defined: a1 is X
// [Asm] defined: a2 is X
// [Asm] defined: a3 is X
// [Asm] defined: a4 is X
// [Asm] defined: a5 is X
// [Asm] defined: a6 is X
// [Asm] defined: a7 is X
// [Asm] defined: t0 is X
// [Asm] defined: t1 is X
// [Asm] defined: ft0 is F
// [Asm] defined: ft1 is F
// [Asm] defined: ft2 is F
// [Asm] defined: ft3 is F
// [Asm] defined: ft4 is F
// [Asm] defined: ft5 is F
// [Asm] defined: ft6 is F
// [Asm] defined: ft7 is F
// [Asm] defined: ft8 is F
// [Asm] defined: ft9 is F
// [Asm] defined: ft10 is F
// [Asm] defined: fa0 is F
// [Asm] defined: fa1 is F
// [Asm] defined: fa2 is F
// [Asm] defined: fa3 is F
// [Asm] defined: fa4 is F
// [Asm] defined: fa5 is F
// [Asm] defined: fa6 is F
// [Asm] defined: fa7 is F
// [Asm] defs: [v25]
// [Asm] live_set: [zero]
// [Asm] move: v25 <- a0
// [Asm] defined: v25 is X
// [Asm] defs: []
// [Asm] live_set: [zero]
// [Asm] defs: [v26]
// [Asm] live_set: [v26, zero]
// [Asm] move: v26 <- zero
// [Asm] defined: v26 is X
// [Asm] skip edge 7 -> 2
// [Asm] Label("update_axis.636") clobbered_x: @hashset.of([a2, a1, a3, a0])
// [Asm] Label("update_axis.636") clobbered_f: @hashset.of([fa7, fa5, fa2, fa3, fa4, fa6, fa0, fa1])
// [Asm] subst   li v44, 4 ->   li a2, 4
// [Asm] subst   blt v44, v2, .update_axis.636_2 ->   blt a2, a0, .update_axis.636_2
// [Asm] subst   mv a0, zero ->   mv a0, zero
// [Asm] subst   ret ->   ret
// [Asm] subst   mv v26, zero ->   mv a0, zero
// [Asm] subst   j .update_axis.636_3 ->   j .update_axis.636_3
// [Asm] subst   slliw v7, v2, 3 ->   slliw a2, a0, 3
// [Asm] subst   add v41, v4, v7 ->   add a3, a1, a2
// [Asm] subst   ld v8, 0(v41) ->   ld a3, 0(a3)
// [Asm] subst   fld fv9, 0(v8) ->   fld fa1, 0(a3)
// [Asm] subst   fld fv10, 8(v8) ->   fld fa2, 8(a3)
// [Asm] subst   fld fv11, 16(v8) ->   fld fa3, 16(a3)
// [Asm] subst   fld fv12, 24(v8) ->   fld fa4, 24(a3)
// [Asm] subst   fld fv13, 32(v8) ->   fld fa5, 32(a3)
// [Asm] subst   fld fv14, 40(v8) ->   fld fa6, 40(a3)
// [Asm] subst   fld fv15, 48(v8) ->   fld fa7, 48(a3)
// [Asm] subst   fmadd.d fv17, fv3, fv12, fv9 ->   fmadd.d fa1, fa0, fa4, fa1
// [Asm] subst   fmadd.d fv19, fv3, fv13, fv10 ->   fmadd.d fa2, fa0, fa5, fa2
// [Asm] subst   fmadd.d fv21, fv3, fv14, fv11 ->   fmadd.d fa3, fa0, fa6, fa3
// [Asm] subst   addi v5, s11, -56 ->   addi a3, s11, -56
// [Asm] subst   andi s11, v5, -8 ->   andi s11, a3, -8
// [Asm] subst   fsd fv17, 0(v5) ->   fsd fa1, 0(a3)
// [Asm] subst   fsd fv19, 8(v5) ->   fsd fa2, 8(a3)
// [Asm] subst   fsd fv21, 16(v5) ->   fsd fa3, 16(a3)
// [Asm] subst   fsd fv12, 24(v5) ->   fsd fa4, 24(a3)
// [Asm] subst   fsd fv13, 32(v5) ->   fsd fa5, 32(a3)
// [Asm] subst   fsd fv14, 40(v5) ->   fsd fa6, 40(a3)
// [Asm] subst   fsd fv15, 48(v5) ->   fsd fa7, 48(a3)
// [Asm] subst   add v29, v4, v7 ->   add a2, a1, a2
// [Asm] subst   sd v5, 0(v29) ->   sd a3, 0(a2)
// [Asm] subst   addi v24, v2, 1 ->   addi a0, a0, 1
// [Asm] subst   call update_axis.636 ->   call update_axis.636
// [Asm] subst   mv v26, zero ->   mv a0, zero
// [Asm] LoweringOrder: [0, 2, 1, 3]
// [Asm] LoweringOrder: [[1, 2], [3], [3], []]
// [Asm] LoweringOrder: HashMap::of([(b0, 0), (b1, 0), (b2, 1), (b3, 0)])
// [Asm] LoweringOrder: [b0, b1, b3, b2]
// [Asm] LoweringOrder: HashMap::of([(b0, 0), (b1, 1), (b2, 0), (b3, 2)])
// [Asm] pre_assigned_registers: Insn(iref=%15) -> fv31, Insn(iref=%41) -> v52, Insn(iref=%33) -> fv48, FnParam(fref=f4, fpref=$f.10) -> v12, FnParam(fref=f4, fpref=$f.7) -> fv9, Insn(iref=%8) -> fv24, Insn(iref=%10) -> fv26, Insn(iref=%27) -> fv43, Insn(iref=%14) -> fv30, Insn(iref=%25) -> fv41, Insn(iref=%39) -> fv50, Insn(iref=%4) -> fv20, Insn(iref=%49) -> v16, Insn(iref=%42) -> v53, FnParam(fref=f4, fpref=$f.9) -> fv11, FnParam(fref=f4, fpref=$f.6) -> fv8, FnParam(fref=f4, fpref=$f.2) -> v4, Insn(iref=%1) -> v17, Insn(iref=%11) -> fv27, Insn(iref=%26) -> fv42, Insn(iref=%6) -> fv22, Mem(fref=f4, mref=m0) -> v13, FnParam(fref=f4, fpref=$f.0) -> v2, FnParam(fref=f4, fpref=$f.8) -> fv10, Insn(iref=%28) -> fv44, BlockParam(bref=b3, bpref=$b.0) -> v55, FnParam(fref=f4, fpref=$f.3) -> fv5, Insn(iref=%9) -> fv25, Insn(iref=%16) -> fv32, Insn(iref=%24) -> fv40, FnParam(fref=f4, fpref=$f.4) -> fv6, Insn(iref=%29) -> v45, FnParam(fref=f4, fpref=$f.1) -> fv3, Insn(iref=%5) -> fv21, Insn(iref=%0) -> v15, Insn(iref=%19) -> fv35, Insn(iref=%3) -> fv19, Insn(iref=%18) -> fv34, Insn(iref=%13) -> fv29, FnParam(fref=f4, fpref=$f.5) -> fv7, Insn(iref=%7) -> fv23, Insn(iref=%22) -> fv38, Insn(iref=%17) -> fv33, Insn(iref=%23) -> fv39, Insn(iref=%48) -> v46, Insn(iref=%2) -> fv18, Insn(iref=%20) -> fv36, Insn(iref=%43) -> v54, Insn(iref=%30) -> v47, Mem(fref=f4, mref=m1) -> v14, Self(fref=f4) -> v0, Insn(iref=%21) -> fv37, Insn(iref=%36) -> fv49, Insn(iref=%40) -> v51, Insn(iref=%12) -> fv28
// [Asm] succs: []
// [Asm] critical edges for b3: []
// [Asm] critical color seq for b3: []
// [Asm] succs: [3]
// [Asm] critical edges for b1: []
// [Asm] critical color seq for b1: []
// [Asm] fuse raw offset and compute address
// [Asm] skipping ComputeAddress(ma=Offset(ty=Unit, val=Int64(val=0), offset=FnParam(fref=f4, fpref=$f.2), width=@64))
// [Asm] skipping Op(ty=Double, op=Mul, args=[Insn(iref=%11), Insn(iref=%11)])
// [Asm] skipping Op(ty=Double, op=Mul, args=[Insn(iref=%10), Insn(iref=%10)])
// [Asm] succs: [3]
// [Asm] critical edges for b2: []
// [Asm] critical color seq for b2: []
// [Asm] succs: [1, 2]
// [Asm] critical edges for b0: []
// [Asm] critical color seq for b0: []
// [Asm] skipping Op(ty=Bool, op=Le, args=[FnParam(fref=f4, fpref=$f.0), Int32(val=4)])
// [Asm] defs: [a0]
// [Asm] live_set: [a0]
// [Asm] move: a0 <- zero
// [Asm] defined: a0 is X
// [Asm] defs: []
// [Asm] live_set: [a0]
// [Asm] defs: []
// [Asm] live_set: []
// [Asm] defs: [v16]
// [Asm] live_set: [fv10, v16, v12, s11, fv5, zero, v4, fv3, fv8, fv6, fv9, fv11, fv7, v2]
// [Asm] defined: v16 is X
// [Asm] defs: [v91]
// [Asm] live_set: [fv10, v16, v91, v12, s11, fv5, zero, v4, fv3, fv8, fv6, fv9, fv11, fv7, v2]
// [Asm] defined: v91 is X
// [Asm] defs: [v17]
// [Asm] live_set: [fv10, v16, v12, s11, fv5, zero, v4, fv3, fv8, v17, fv6, fv9, fv11, fv7, v2]
// [Asm] defined: v17 is X
// [Asm] defs: [fv18]
// [Asm] live_set: [fv10, v16, v12, s11, fv5, zero, v4, fv3, fv8, v17, fv6, fv9, fv11, fv18, fv7, v2]
// [Asm] defined: fv18 is F
// [Asm] defs: [fv19]
// [Asm] live_set: [fv10, v16, fv19, v12, s11, fv5, zero, v4, fv3, fv8, v17, fv6, fv9, fv11, fv18, fv7, v2]
// [Asm] defined: fv19 is F
// [Asm] defs: [fv20]
// [Asm] live_set: [fv10, v16, fv20, fv19, v12, s11, fv5, zero, v4, fv3, fv8, v17, fv6, fv9, fv11, fv18, fv7, v2]
// [Asm] defined: fv20 is F
// [Asm] defs: [fv21]
// [Asm] live_set: [fv10, v16, fv20, fv19, v12, s11, fv5, zero, v4, fv3, fv21, fv8, v17, fv6, fv9, fv11, fv18, fv7, v2]
// [Asm] defined: fv21 is F
// [Asm] defs: [fv22]
// [Asm] live_set: [fv10, v16, fv20, fv19, v12, s11, fv5, fv22, zero, v4, fv3, fv21, fv8, v17, fv6, fv9, fv11, fv18, fv7, v2]
// [Asm] defined: fv22 is F
// [Asm] defs: [fv23]
// [Asm] live_set: [fv23, fv10, v16, fv20, fv19, v12, s11, fv5, fv22, zero, v4, fv3, fv21, fv8, v17, fv6, fv9, fv11, fv18, fv7, v2]
// [Asm] defined: fv23 is F
// [Asm] defs: [fv24]
// [Asm] live_set: [fv23, fv10, fv24, v16, fv20, fv19, v12, s11, fv5, fv22, zero, v4, fv3, fv21, fv8, fv6, fv9, fv11, fv18, fv7, v2]
// [Asm] defined: fv24 is F
// [Asm] defs: [fv25]
// [Asm] live_set: [fv23, fv10, fv24, v16, fv20, fv19, v12, s11, fv5, fv22, zero, fv25, v4, fv3, fv21, fv8, fv6, fv9, fv11, fv18, fv7, v2]
// [Asm] defined: fv25 is F
// [Asm] defs: [fv26]
// [Asm] live_set: [fv23, fv10, fv24, v16, fv20, fv19, v12, s11, fv5, fv22, zero, fv25, v4, fv3, fv21, fv8, fv6, fv26, fv9, fv11, fv18, fv7, v2]
// [Asm] defined: fv26 is F
// [Asm] defs: [fv27]
// [Asm] live_set: [fv23, fv10, fv24, v16, fv20, fv19, v12, s11, fv5, fv22, zero, fv25, v4, fv27, fv3, fv21, fv8, fv6, fv26, fv9, fv11, fv18, fv7, v2]
// [Asm] defined: fv27 is F
// [Asm] defs: [fv28]
// [Asm] live_set: [fv23, fv10, fv24, v16, fv20, fv19, v12, s11, fv5, fv22, zero, fv25, v4, fv27, fv3, fv21, fv8, fv6, fv26, fv9, fv28, fv11, fv18, fv7, v2]
// [Asm] defined: fv28 is F
// [Asm] defs: [fv30]
// [Asm] live_set: [fv23, fv10, fv24, v16, fv20, fv30, fv19, v12, s11, fv5, fv22, zero, fv25, v4, fv27, fv3, fv21, fv8, fv6, fv26, fv9, fv11, fv18, fv7, v2]
// [Asm] defined: fv30 is F
// [Asm] defs: [fv32]
// [Asm] live_set: [fv23, fv10, fv24, v16, fv20, fv19, v12, s11, fv5, fv22, zero, fv25, v4, fv27, fv3, fv21, fv32, fv8, fv6, fv26, fv9, fv11, fv18, fv7, v2]
// [Asm] defined: fv32 is F
// [Asm] defs: [fv33]
// [Asm] live_set: [fv23, fv10, fv24, v16, fv20, fv19, v12, s11, fv5, fv22, zero, fv25, v4, fv27, fv3, fv21, fv32, fv8, fv6, fv26, fv9, fv11, fv33, fv18, fv7, v2]
// [Asm] defined: fv33 is F
// [Asm] defs: [fv34]
// [Asm] live_set: [fv23, fv10, fv24, v16, fv20, fv19, v12, s11, fv5, fv22, zero, fv25, v4, fv27, fv3, fv21, fv8, fv6, fv26, fv9, fv11, fv34, fv18, fv7, v2]
// [Asm] defined: fv34 is F
// [Asm] defs: [fv35]
// [Asm] live_set: [fv23, fv10, fv24, v16, fv20, fv19, v12, s11, fv35, fv5, fv22, zero, fv25, v4, fv27, fv3, fv21, fv8, fv6, fv26, fv9, fv11, fv18, fv7, v2]
// [Asm] defined: fv35 is F
// [Asm] defs: [fv36]
// [Asm] live_set: [fv23, fv10, fv24, v16, fv20, fv19, v12, s11, fv35, fv5, fv22, zero, fv36, v4, fv27, fv3, fv21, fv8, fv6, fv26, fv9, fv11, fv18, fv7, v2]
// [Asm] defined: fv36 is F
// [Asm] defs: [fv37]
// [Asm] live_set: [fv23, fv10, fv24, v16, fv20, fv19, v12, s11, fv35, fv5, fv22, zero, v4, fv27, fv3, fv21, fv37, fv8, fv6, fv26, fv9, fv11, fv18, fv7, v2]
// [Asm] defined: fv37 is F
// [Asm] defs: [fv38]
// [Asm] live_set: [fv23, fv10, fv24, v16, fv20, fv19, v12, s11, fv35, fv38, fv5, fv22, zero, v4, fv27, fv3, fv21, fv37, fv8, fv6, fv26, fv9, fv11, fv18, fv7, v2]
// [Asm] defined: fv38 is F
// [Asm] defs: [fv39]
// [Asm] live_set: [fv23, fv10, fv24, v16, fv39, fv20, fv19, v12, s11, fv35, fv38, fv5, fv22, zero, v4, fv27, fv3, fv21, fv37, fv8, fv6, fv9, fv11, fv18, fv7, v2]
// [Asm] defined: fv39 is F
// [Asm] defs: [fv40]
// [Asm] live_set: [fv23, fv10, fv24, v16, fv20, fv19, v12, s11, fv35, fv40, fv38, fv5, fv22, zero, v4, fv27, fv3, fv21, fv37, fv8, fv6, fv9, fv11, fv18, fv7, v2]
// [Asm] defined: fv40 is F
// [Asm] defs: [fv41]
// [Asm] live_set: [fv23, fv10, fv24, v16, fv20, fv19, v12, s11, fv35, fv40, fv38, fv5, fv22, zero, fv41, v4, fv27, fv3, fv21, fv37, fv8, fv6, fv9, fv11, fv18, fv7, v2]
// [Asm] defined: fv41 is F
// [Asm] defs: [fv42]
// [Asm] live_set: [fv23, fv10, fv24, v16, fv20, fv19, v12, s11, fv35, fv40, fv38, fv5, fv22, zero, fv41, v4, fv3, fv21, fv37, fv8, fv6, fv9, fv11, fv42, fv18, fv7, v2]
// [Asm] defined: fv42 is F
// [Asm] defs: [fv43]
// [Asm] live_set: [fv23, fv10, fv24, v16, fv20, fv19, v12, s11, fv40, fv38, fv5, fv22, zero, fv41, v4, fv3, fv21, fv37, fv8, fv6, fv9, fv11, fv43, fv18, fv7, v2]
// [Asm] defined: fv43 is F
// [Asm] defs: [fv44]
// [Asm] live_set: [fv23, fv10, fv24, v16, fv20, fv19, v12, s11, fv40, fv38, fv5, fv22, zero, fv41, v4, fv3, fv21, fv37, fv8, fv6, fv9, fv11, fv43, fv18, fv44, fv7, v2]
// [Asm] defined: fv44 is F
// [Asm] defs: [v13]
// [Asm] live_set: [fv23, fv10, fv24, v16, v13, fv20, fv19, v12, fv40, fv38, fv5, fv22, zero, fv41, v4, fv3, fv21, fv37, fv8, fv6, fv9, fv11, fv43, fv18, fv44, fv7, v2]
// [Asm] defined: v13 is X
// [Asm] defs: [s11]
// [Asm] live_set: [fv23, fv10, fv24, v16, v13, fv20, fv19, v12, s11, fv40, fv38, fv5, fv22, zero, fv41, v4, fv3, fv21, fv37, fv8, fv6, fv9, fv11, fv43, fv18, fv44, fv7, v2]
// [Asm] defined: s11 is X
// [Asm] defs: []
// [Asm] live_set: [fv23, fv10, fv24, v16, v13, fv20, fv19, v12, s11, fv40, fv38, fv5, fv22, zero, fv41, v4, fv3, fv21, fv37, fv8, fv6, fv9, fv11, fv43, fv18, fv44, fv7, v2]
// [Asm] defs: []
// [Asm] live_set: [fv23, fv10, fv24, v16, v13, fv20, fv19, v12, s11, fv40, fv38, fv5, fv22, zero, fv41, v4, fv3, fv21, fv37, fv8, fv6, fv9, fv11, fv43, fv18, fv44, fv7, v2]
// [Asm] defs: []
// [Asm] live_set: [fv23, fv10, fv24, v16, v13, fv20, fv19, v12, s11, fv40, fv38, fv5, fv22, zero, fv41, v4, fv3, fv21, fv37, fv8, fv6, fv9, fv11, fv43, fv18, fv44, fv7, v2]
// [Asm] defs: []
// [Asm] live_set: [fv23, fv10, fv24, v16, v13, fv20, fv19, v12, s11, fv40, fv5, fv22, zero, fv41, v4, fv3, fv21, fv37, fv8, fv6, fv9, fv11, fv43, fv18, fv44, fv7, v2]
// [Asm] defs: []
// [Asm] live_set: [fv23, fv10, fv24, v16, v13, fv20, fv19, v12, s11, fv40, fv5, fv22, zero, v4, fv3, fv21, fv37, fv8, fv6, fv9, fv11, fv43, fv18, fv44, fv7, v2]
// [Asm] defs: []
// [Asm] live_set: [v2, fv37, fv24, fv23, fv10, v16, v13, fv8, fv20, fv19, v12, s11, fv6, fv40, fv9, fv5, fv22, zero, fv11, fv43, v4, fv18, fv3, fv7, fv21]
// [Asm] defs: []
// [Asm] live_set: [v2, fv37, fv24, fv23, fv10, v16, v13, fv8, fv20, fv19, v12, s11, fv6, fv40, fv9, fv5, fv22, zero, fv11, fv43, v4, fv18, fv3, fv7, fv21]
// [Asm] defs: [v63]
// [Asm] live_set: [v2, fv37, fv24, fv23, fv10, v16, v13, fv8, fv20, fv19, v12, s11, fv6, fv40, fv9, fv5, fv22, v63, zero, fv11, fv43, v4, fv18, fv3, fv7, fv21]
// [Asm] defined: v63 is X
// [Asm] defs: [v64]
// [Asm] live_set: [v2, fv37, fv24, fv23, fv10, v16, v13, fv8, fv20, fv19, v12, s11, fv6, v64, fv40, fv9, fv5, fv22, zero, fv11, fv43, v4, fv18, fv3, fv7, fv21]
// [Asm] defined: v64 is X
// [Asm] defs: []
// [Asm] live_set: [v2, fv37, fv24, fv23, fv10, v16, fv8, fv20, fv19, v12, s11, fv6, fv40, fv9, fv5, fv22, zero, fv11, fv43, v4, fv18, fv3, fv7, fv21]
// [Asm] defs: [fv48]
// [Asm] live_set: [fv10, fv24, fv23, v16, fv8, fv20, fv48, fv19, v12, s11, fv6, fv40, fv9, fv5, fv22, zero, fv11, fv43, v4, fv18, fv3, fv7, v2]
// [Asm] defined: fv48 is F
// [Asm] defs: [fv49]
// [Asm] live_set: [fv10, fv24, fv23, v16, fv8, fv20, fv48, fv19, v12, s11, fv6, fv9, fv5, zero, fv11, fv43, v4, fv49, fv18, fv3, fv7, v2]
// [Asm] defined: fv49 is F
// [Asm] defs: [fv50]
// [Asm] live_set: [fv10, fv24, v16, fv8, fv20, fv48, fv19, v12, s11, fv6, fv9, fv5, fv50, zero, fv11, v4, fv49, fv18, fv3, fv7, v2]
// [Asm] defined: fv50 is F
// [Asm] defs: [v14]
// [Asm] live_set: [fv10, fv24, v16, v14, fv8, fv20, fv48, fv19, v12, fv6, fv9, fv5, fv50, zero, fv11, v4, fv49, fv18, fv3, fv7, v2]
// [Asm] defined: v14 is X
// [Asm] defs: [s11]
// [Asm] live_set: [fv10, fv24, v16, v14, fv8, fv20, fv48, fv19, v12, fv6, fv9, fv5, fv50, zero, fv11, v4, fv49, fv18, fv3, fv7, v2]
// [Asm] defined: s11 is X
// [Asm] defs: []
// [Asm] live_set: [fv10, fv24, v16, v14, fv8, fv20, fv48, fv19, v12, fv6, fv9, fv5, fv50, zero, fv11, v4, fv49, fv3, fv7, v2]
// [Asm] defs: []
// [Asm] live_set: [fv10, fv24, v16, v14, fv8, fv20, fv48, v12, fv6, fv9, fv5, fv50, zero, fv11, v4, fv49, fv3, fv7, v2]
// [Asm] defs: []
// [Asm] live_set: [fv10, fv24, v16, v14, fv8, fv48, v12, fv6, fv9, fv5, fv50, zero, fv11, v4, fv49, fv3, fv7, v2]
// [Asm] defs: []
// [Asm] live_set: [fv10, fv24, v16, v14, fv8, v12, fv6, fv9, fv5, fv50, zero, fv11, v4, fv49, fv3, fv7, v2]
// [Asm] defs: []
// [Asm] live_set: [fv10, fv24, v16, v14, fv8, v12, fv6, fv9, fv5, fv50, zero, fv11, v4, fv3, fv7, v2]
// [Asm] defs: []
// [Asm] live_set: [fv10, fv24, v16, v14, fv8, v12, fv6, fv9, fv5, zero, fv11, v4, fv3, fv7, v2]
// [Asm] defs: []
// [Asm] live_set: [fv10, v14, v16, fv8, v12, fv6, fv9, fv5, zero, fv11, v4, fv3, fv7, v2]
// [Asm] defs: [v58]
// [Asm] live_set: [fv10, v14, v58, fv8, v12, fv6, fv9, fv5, zero, fv11, v4, fv3, fv7, v2]
// [Asm] defined: v58 is X
// [Asm] defs: []
// [Asm] live_set: [fv9, fv5, fv10, zero, fv11, fv8, v4, v12, fv6, fv3, fv7, v2]
// [Asm] defs: [v53]
// [Asm] live_set: [fv9, fv5, fv10, v53, zero, fv11, fv8, v4, v12, fv6, fv3, fv7]
// [Asm] defined: v53 is X
// [Asm] defs: []
// [Asm] live_set: [fv9, fv5, fv10, v53, zero, fv11, fv8, v4, v12, fv6, fv3, fv7]
// [Asm] defs: [a0]
// [Asm] live_set: [fv9, fv5, fv10, zero, a0, fv11, fv8, v4, v12, fv6, fv3, fv7]
// [Asm] move: a0 <- v53
// [Asm] defined: a0 is X
// [Asm] defs: [fa0]
// [Asm] live_set: [fv9, fv5, fv10, zero, a0, fv11, fa0, fv8, v4, v12, fv6, fv7]
// [Asm] move: fa0 <- fv3
// [Asm] defined: fa0 is F
// [Asm] defs: [a1]
// [Asm] live_set: [fv9, fv5, fv10, zero, a0, fv11, fa0, fv8, a1, v12, fv6, fv7]
// [Asm] move: a1 <- v4
// [Asm] defined: a1 is X
// [Asm] defs: [fa1]
// [Asm] live_set: [fv9, fv10, zero, a0, fv11, fa0, fv8, a1, v12, fv6, fa1, fv7]
// [Asm] move: fa1 <- fv5
// [Asm] defined: fa1 is F
// [Asm] defs: [fa2]
// [Asm] live_set: [fv9, fv10, fa2, zero, a0, fv11, fa0, fv8, a1, v12, fa1, fv7]
// [Asm] move: fa2 <- fv6
// [Asm] defined: fa2 is F
// [Asm] defs: [fa3]
// [Asm] live_set: [fv9, fv10, fa2, fa3, zero, a0, fv11, fa0, fv8, a1, v12, fa1]
// [Asm] move: fa3 <- fv7
// [Asm] defined: fa3 is F
// [Asm] defs: [fa4]
// [Asm] live_set: [fv9, fv10, fa2, fa3, fa4, zero, a0, fv11, fa0, a1, v12, fa1]
// [Asm] move: fa4 <- fv8
// [Asm] defined: fa4 is F
// [Asm] defs: [fa5]
// [Asm] live_set: [fv10, fa5, fa2, fa3, fa4, zero, a0, fv11, fa0, a1, v12, fa1]
// [Asm] move: fa5 <- fv9
// [Asm] defined: fa5 is F
// [Asm] defs: [fa6]
// [Asm] live_set: [fa5, fa2, fa3, fa4, zero, a0, fv11, fa6, fa0, a1, v12, fa1]
// [Asm] move: fa6 <- fv10
// [Asm] defined: fa6 is F
// [Asm] defs: [fa7]
// [Asm] live_set: [fa7, fa5, fa2, fa3, fa4, zero, a0, fa6, fa0, a1, v12, fa1]
// [Asm] move: fa7 <- fv11
// [Asm] defined: fa7 is F
// [Asm] defs: [a2]
// [Asm] live_set: [fa7, fa5, fa2, fa3, fa4, zero, a0, fa6, fa0, a2, a1, fa1]
// [Asm] move: a2 <- v12
// [Asm] defined: a2 is X
// [Asm] defs: [t0, t1, t2, t3, t4, a0, a1, a2, a3, a4, a5, a6, a7, t0, t1, ft0, ft1, ft2, ft3, ft4, ft5, ft6, ft7, ft8, ft9, ft10, fa0, fa1, fa2, fa3, fa4, fa5, fa6, fa7]
// [Asm] live_set: [zero, a0]
// [Asm] defined: t0 is X
// [Asm] defined: t1 is X
// [Asm] defined: t2 is X
// [Asm] defined: t3 is X
// [Asm] defined: t4 is X
// [Asm] defined: a0 is X
// [Asm] defined: a1 is X
// [Asm] defined: a2 is X
// [Asm] defined: a3 is X
// [Asm] defined: a4 is X
// [Asm] defined: a5 is X
// [Asm] defined: a6 is X
// [Asm] defined: a7 is X
// [Asm] defined: t0 is X
// [Asm] defined: t1 is X
// [Asm] defined: ft0 is F
// [Asm] defined: ft1 is F
// [Asm] defined: ft2 is F
// [Asm] defined: ft3 is F
// [Asm] defined: ft4 is F
// [Asm] defined: ft5 is F
// [Asm] defined: ft6 is F
// [Asm] defined: ft7 is F
// [Asm] defined: ft8 is F
// [Asm] defined: ft9 is F
// [Asm] defined: ft10 is F
// [Asm] defined: fa0 is F
// [Asm] defined: fa1 is F
// [Asm] defined: fa2 is F
// [Asm] defined: fa3 is F
// [Asm] defined: fa4 is F
// [Asm] defined: fa5 is F
// [Asm] defined: fa6 is F
// [Asm] defined: fa7 is F
// [Asm] defs: [v54]
// [Asm] live_set: [zero]
// [Asm] move: v54 <- a0
// [Asm] defined: v54 is X
// [Asm] defs: []
// [Asm] live_set: [zero]
// [Asm] defs: [v55]
// [Asm] live_set: [v55, zero]
// [Asm] move: v55 <- zero
// [Asm] defined: v55 is X
// [Asm] skip edge 28 -> 0
// [Asm] defs: [v55]
// [Asm] live_set: [v55, zero]
// [Asm] move: v55 <- zero
// [Asm] defined: v55 is X
// [Asm] skip edge 28 -> 0
// [Asm] defs: []
// [Asm] live_set: [v55, zero]
// [Asm] defs: []
// [Asm] live_set: [fa4, a0, a2, a1, s11, fa1, fa7, fa5, fa3, fa2, zero, fa6, fa0]
// [Asm] defs: [v2]
// [Asm] live_set: [fa4, a2, a1, s11, fa1, fa7, fa5, fa3, fa2, zero, fa6, fa0, v2]
// [Asm] move: v2 <- a0
// [Asm] defined: v2 is X
// [Asm] defs: [fv3]
// [Asm] live_set: [fa4, a2, a1, s11, fa1, fa7, fa5, fa3, fa2, zero, fa6, fv3, v2]
// [Asm] move: fv3 <- fa0
// [Asm] defined: fv3 is F
// [Asm] defs: [v4]
// [Asm] live_set: [fa4, a2, s11, fa1, fa7, fa5, fa3, fa2, zero, fa6, v4, fv3, v2]
// [Asm] move: v4 <- a1
// [Asm] defined: v4 is X
// [Asm] defs: [fv5]
// [Asm] live_set: [fa4, a2, s11, fv5, fa7, fa5, fa3, fa2, zero, fa6, v4, fv3, v2]
// [Asm] move: fv5 <- fa1
// [Asm] defined: fv5 is F
// [Asm] defs: [fv6]
// [Asm] live_set: [fa4, a2, s11, fv6, fv5, fa7, fa5, fa3, zero, fa6, v4, fv3, v2]
// [Asm] move: fv6 <- fa2
// [Asm] defined: fv6 is F
// [Asm] defs: [fv7]
// [Asm] live_set: [fa4, a2, s11, fv6, fv5, fa7, fa5, zero, fa6, v4, fv3, fv7, v2]
// [Asm] move: fv7 <- fa3
// [Asm] defined: fv7 is F
// [Asm] defs: [fv8]
// [Asm] live_set: [fv8, a2, s11, fv6, fv5, fa7, fa5, zero, fa6, v4, fv3, fv7, v2]
// [Asm] move: fv8 <- fa4
// [Asm] defined: fv8 is F
// [Asm] defs: [fv9]
// [Asm] live_set: [fv8, a2, s11, fv6, fv9, fv5, fa7, zero, fa6, v4, fv3, fv7, v2]
// [Asm] move: fv9 <- fa5
// [Asm] defined: fv9 is F
// [Asm] defs: [fv10]
// [Asm] live_set: [fv10, fv8, a2, s11, fv6, fv9, fv5, fa7, zero, v4, fv3, fv7, v2]
// [Asm] move: fv10 <- fa6
// [Asm] defined: fv10 is F
// [Asm] defs: [fv11]
// [Asm] live_set: [fv10, fv8, a2, s11, fv6, fv9, fv5, fv11, zero, v4, fv3, fv7, v2]
// [Asm] move: fv11 <- fa7
// [Asm] defined: fv11 is F
// [Asm] defs: [v12]
// [Asm] live_set: [fv10, fv8, v12, s11, fv6, fv9, fv5, fv11, zero, v4, fv3, fv7, v2]
// [Asm] move: v12 <- a2
// [Asm] defined: v12 is X
// [Asm] defs: [v94]
// [Asm] live_set: [fv10, fv8, v12, s11, fv6, fv9, fv5, v94, fv11, zero, v4, fv3, fv7, v2]
// [Asm] defined: v94 is X
// [Asm] defs: []
// [Asm] live_set: [v2, fv9, fv5, fv10, fv11, zero, fv8, v4, v12, s11, fv6, fv3, fv7]
// [Asm] Label("loop_j.635") clobbered_x: @hashset.of([a2, a1, a3, a5, a0, a4])
// [Asm] Label("loop_j.635") clobbered_f: @hashset.of([ft4, ft9, fa4, fs0, ft2, ft1, ft0, fa1, ft8, fs2, fa7, fa5, fa2, fa3, ft6, ft3, fa6, fa0, ft5, fs1, ft7])
// [Asm] subst   mv a0, zero ->   mv a0, zero
// [Asm] subst   ret ->   ret
// [Asm] subst   slliw v16, v2, 3 ->   slliw a3, a0, 3
// [Asm] subst   add v91, v12, v16 ->   add a4, a2, a3
// [Asm] subst   ld v17, 0(v91) ->   ld a4, 0(a4)
// [Asm] subst   fld fv18, 0(v17) ->   fld ft0, 0(a4)
// [Asm] subst   fld fv19, 8(v17) ->   fld ft1, 8(a4)
// [Asm] subst   fld fv20, 16(v17) ->   fld ft2, 16(a4)
// [Asm] subst   fld fv21, 24(v17) ->   fld ft3, 24(a4)
// [Asm] subst   fld fv22, 32(v17) ->   fld ft4, 32(a4)
// [Asm] subst   fld fv23, 40(v17) ->   fld ft5, 40(a4)
// [Asm] subst   fld fv24, 48(v17) ->   fld ft6, 48(a4)
// [Asm] subst   fsub.d fv25, fv6, fv18 ->   fsub.d ft7, fa2, ft0
// [Asm] subst   fsub.d fv26, fv7, fv19 ->   fsub.d ft8, fa3, ft1
// [Asm] subst   fsub.d fv27, fv8, fv20 ->   fsub.d ft9, fa4, ft2
// [Asm] subst   fmul.d fv28, fv25, fv25 ->   fmul.d fs0, ft7, ft7
// [Asm] subst   fmadd.d fv30, fv26, fv26, fv28 ->   fmadd.d fs0, ft8, ft8, fs0
// [Asm] subst   fmadd.d fv32, fv27, fv27, fv30 ->   fmadd.d fs0, ft9, ft9, fs0
// [Asm] subst   fsqrt.d fv33, fv32 ->   fsqrt.d fs1, fs0
// [Asm] subst   fmul.d fv34, fv32, fv33 ->   fmul.d fs0, fs0, fs1
// [Asm] subst   fdiv.d fv35, fv3, fv34 ->   fdiv.d fs0, fa0, fs0
// [Asm] subst   fmul.d fv36, fv25, fv24 ->   fmul.d ft7, ft7, ft6
// [Asm] subst   fmul.d fv37, fv36, fv35 ->   fmul.d ft7, ft7, fs0
// [Asm] subst   fsub.d fv38, fv9, fv37 ->   fsub.d fs1, fa5, ft7
// [Asm] subst   fmul.d fv39, fv26, fv24 ->   fmul.d ft8, ft8, ft6
// [Asm] subst   fmul.d fv40, fv39, fv35 ->   fmul.d ft8, ft8, fs0
// [Asm] subst   fsub.d fv41, fv10, fv40 ->   fsub.d fs2, fa6, ft8
// [Asm] subst   fmul.d fv42, fv27, fv24 ->   fmul.d ft9, ft9, ft6
// [Asm] subst   fmul.d fv43, fv42, fv35 ->   fmul.d ft9, ft9, fs0
// [Asm] subst   fsub.d fv44, fv11, fv43 ->   fsub.d fs0, fa7, ft9
// [Asm] subst   addi v13, s11, -56 ->   addi a4, s11, -56
// [Asm] subst   andi s11, v13, -8 ->   andi s11, a4, -8
// [Asm] subst   fsd fv6, 0(v13) ->   fsd fa2, 0(a4)
// [Asm] subst   fsd fv7, 8(v13) ->   fsd fa3, 8(a4)
// [Asm] subst   fsd fv8, 16(v13) ->   fsd fa4, 16(a4)
// [Asm] subst   fsd fv38, 24(v13) ->   fsd fs1, 24(a4)
// [Asm] subst   fsd fv41, 32(v13) ->   fsd fs2, 32(a4)
// [Asm] subst   fsd fv44, 40(v13) ->   fsd fs0, 40(a4)
// [Asm] subst   fsd fv5, 48(v13) ->   fsd fa1, 48(a4)
// [Asm] subst   slliw v63, v4, 3 ->   slliw a5, a1, 3
// [Asm] subst   add v64, v12, v63 ->   add a5, a2, a5
// [Asm] subst   sd v13, 0(v64) ->   sd a4, 0(a5)
// [Asm] subst   fsub.d fv48, fv21, fv37 ->   fsub.d ft3, ft3, ft7
// [Asm] subst   fsub.d fv49, fv22, fv40 ->   fsub.d ft4, ft4, ft8
// [Asm] subst   fsub.d fv50, fv23, fv43 ->   fsub.d ft5, ft5, ft9
// [Asm] subst   addi v14, s11, -56 ->   addi a4, s11, -56
// [Asm] subst   andi s11, v14, -8 ->   andi s11, a4, -8
// [Asm] subst   fsd fv18, 0(v14) ->   fsd ft0, 0(a4)
// [Asm] subst   fsd fv19, 8(v14) ->   fsd ft1, 8(a4)
// [Asm] subst   fsd fv20, 16(v14) ->   fsd ft2, 16(a4)
// [Asm] subst   fsd fv48, 24(v14) ->   fsd ft3, 24(a4)
// [Asm] subst   fsd fv49, 32(v14) ->   fsd ft4, 32(a4)
// [Asm] subst   fsd fv50, 40(v14) ->   fsd ft5, 40(a4)
// [Asm] subst   fsd fv24, 48(v14) ->   fsd ft6, 48(a4)
// [Asm] subst   add v58, v12, v16 ->   add a3, a2, a3
// [Asm] subst   sd v14, 0(v58) ->   sd a4, 0(a3)
// [Asm] subst   addi v53, v2, 1 ->   addi a0, a0, 1
// [Asm] subst   call loop_j.635 ->   call loop_j.635
// [Asm] subst   mv v55, zero ->   mv a0, zero
// [Asm] subst   mv v55, zero ->   mv a0, zero
// [Asm] subst   j .loop_j.635_3 ->   j .loop_j.635_3
// [Asm] subst   li v94, 4 ->   li a3, 4
// [Asm] subst   blt v94, v2, .loop_j.635_2 ->   blt a3, a0, .loop_j.635_2
// [Asm] LoweringOrder: [0]
// [Asm] LoweringOrder: [[]]
// [Asm] LoweringOrder: HashMap::of([(b0, 0)])
// [Asm] LoweringOrder: [b0]
// [Asm] LoweringOrder: HashMap::of([(b0, 0)])
// [Asm] pre_assigned_registers: Insn(iref=%15) -> v28, Insn(iref=%41) -> v52, Insn(iref=%33) -> fv45, Insn(iref=%8) -> v21, Insn(iref=%10) -> v23, Mem(fref=f8, mref=m5) -> v9, Insn(iref=%27) -> fv40, Insn(iref=%14) -> v27, Insn(iref=%25) -> fv38, Insn(iref=%39) -> fv50, Insn(iref=%4) -> fv17, Mem(fref=f8, mref=m8) -> v4, Insn(iref=%42) -> v53, Insn(iref=%44) -> v55, Insn(iref=%32) -> fv44, Mem(fref=f8, mref=m0) -> v6, Mem(fref=f8, mref=m7) -> v12, Insn(iref=%1) -> v14, Insn(iref=%11) -> v24, Insn(iref=%26) -> fv39, Mem(fref=f8, mref=m10) -> v8, Insn(iref=%6) -> v19, Insn(iref=%31) -> fv43, Insn(iref=%35) -> fv46, Insn(iref=%28) -> fv41, Insn(iref=%38) -> v49, Insn(iref=%46) -> fv57, Insn(iref=%9) -> v22, Insn(iref=%16) -> v29, Insn(iref=%24) -> fv37, Mem(fref=f8, mref=m6) -> v2, Insn(iref=%37) -> v48, Mem(fref=f8, mref=m4) -> v3, Insn(iref=%45) -> fv56, Insn(iref=%29) -> fv42, Insn(iref=%5) -> v18, Insn(iref=%47) -> v58, Insn(iref=%0) -> v13, Insn(iref=%19) -> fv32, Mem(fref=f8, mref=m1) -> v7, Insn(iref=%3) -> v16, Insn(iref=%18) -> fv31, Insn(iref=%13) -> v26, Insn(iref=%7) -> v20, Insn(iref=%22) -> fv35, Insn(iref=%17) -> v30, Insn(iref=%23) -> fv36, Insn(iref=%48) -> v59, Insn(iref=%2) -> v15, Insn(iref=%20) -> fv33, Insn(iref=%43) -> v54, Mem(fref=f8, mref=m9) -> v5, Mem(fref=f8, mref=m3) -> v11, Mem(fref=f8, mref=m2) -> v10, Insn(iref=%21) -> fv34, Self(fref=f8) -> v0, Insn(iref=%36) -> fv47, Insn(iref=%40) -> fv51, Insn(iref=%12) -> v25
// [Asm] succs: []
// [Asm] critical edges for b0: []
// [Asm] critical color seq for b0: []
// [Asm] skipping Load(ty=Double, ma=Field(ty=Double, val=Insn(iref=%17), index=5, width=@(@64, @(@64, @(@64, @(@64, @(@64, @(@64, @(@64, @32)))))))))
// [Asm] skipping Load(ty=Double, ma=Field(ty=Double, val=Insn(iref=%17), index=4, width=@(@64, @(@64, @(@64, @(@64, @(@64, @(@64, @(@64, @32)))))))))
// [Asm] skipping Load(ty=Double, ma=Field(ty=Double, val=Insn(iref=%17), index=3, width=@(@64, @(@64, @(@64, @(@64, @(@64, @(@64, @(@64, @32)))))))))
// [Asm] defs: []
// [Asm] live_set: [zero, s11]
// [Asm] defs: [v6]
// [Asm] live_set: [zero, v6]
// [Asm] defined: v6 is X
// [Asm] defs: [s11]
// [Asm] live_set: [zero, v6, s11]
// [Asm] defined: s11 is X
// [Asm] defs: [v149]
// [Asm] live_set: [zero, v6, s11, v149]
// [Asm] defined: v149 is X
// [Asm] defs: [fv150]
// [Asm] live_set: [fv150, zero, v6, s11]
// [Asm] defined: fv150 is F
// [Asm] defs: []
// [Asm] live_set: [zero, v6, s11]
// [Asm] defs: [v151]
// [Asm] live_set: [zero, v151, v6, s11]
// [Asm] defined: v151 is X
// [Asm] defs: [fv152]
// [Asm] live_set: [zero, v6, s11, fv152]
// [Asm] defined: fv152 is F
// [Asm] defs: []
// [Asm] live_set: [zero, v6, s11]
// [Asm] defs: [v153]
// [Asm] live_set: [v153, zero, v6, s11]
// [Asm] defined: v153 is X
// [Asm] defs: [fv154]
// [Asm] live_set: [fv154, zero, v6, s11]
// [Asm] defined: fv154 is F
// [Asm] defs: []
// [Asm] live_set: [zero, v6, s11]
// [Asm] defs: [v155]
// [Asm] live_set: [v155, zero, v6, s11]
// [Asm] defined: v155 is X
// [Asm] defs: [fv156]
// [Asm] live_set: [zero, fv156, v6, s11]
// [Asm] defined: fv156 is F
// [Asm] defs: []
// [Asm] live_set: [zero, v6, s11]
// [Asm] defs: [v157]
// [Asm] live_set: [zero, v157, v6, s11]
// [Asm] defined: v157 is X
// [Asm] defs: [fv158]
// [Asm] live_set: [zero, v6, s11, fv158]
// [Asm] defined: fv158 is F
// [Asm] defs: []
// [Asm] live_set: [zero, v6, s11]
// [Asm] defs: [v159]
// [Asm] live_set: [zero, v159, v6, s11]
// [Asm] defined: v159 is X
// [Asm] defs: [fv160]
// [Asm] live_set: [fv160, zero, v6, s11]
// [Asm] defined: fv160 is F
// [Asm] defs: []
// [Asm] live_set: [zero, v6, s11]
// [Asm] defs: [v161]
// [Asm] live_set: [v161, zero, v6, s11]
// [Asm] defined: v161 is X
// [Asm] defs: [fv162]
// [Asm] live_set: [zero, fv162, v6, s11]
// [Asm] defined: fv162 is F
// [Asm] defs: []
// [Asm] live_set: [zero, v6, s11]
// [Asm] defs: [v7]
// [Asm] live_set: [zero, v7, v6]
// [Asm] defined: v7 is X
// [Asm] defs: [s11]
// [Asm] live_set: [zero, v7, v6, s11]
// [Asm] defined: s11 is X
// [Asm] defs: [v134]
// [Asm] live_set: [zero, v7, v134, v6, s11]
// [Asm] defined: v134 is X
// [Asm] defs: [fv135]
// [Asm] live_set: [zero, v7, v6, s11, fv135]
// [Asm] defined: fv135 is F
// [Asm] defs: []
// [Asm] live_set: [zero, v7, v6, s11]
// [Asm] defs: [v136]
// [Asm] live_set: [zero, v7, v136, v6, s11]
// [Asm] defined: v136 is X
// [Asm] defs: [fv137]
// [Asm] live_set: [fv137, zero, v7, v6, s11]
// [Asm] defined: fv137 is F
// [Asm] defs: []
// [Asm] live_set: [zero, v7, v6, s11]
// [Asm] defs: [v138]
// [Asm] live_set: [zero, v7, v6, s11, v138]
// [Asm] defined: v138 is X
// [Asm] defs: [fv139]
// [Asm] live_set: [fv139, zero, v7, v6, s11]
// [Asm] defined: fv139 is F
// [Asm] defs: []
// [Asm] live_set: [zero, v7, v6, s11]
// [Asm] defs: [v140]
// [Asm] live_set: [zero, v7, v6, v140, s11]
// [Asm] defined: v140 is X
// [Asm] defs: [fv141]
// [Asm] live_set: [fv141, zero, v7, v6, s11]
// [Asm] defined: fv141 is F
// [Asm] defs: []
// [Asm] live_set: [zero, v7, v6, s11]
// [Asm] defs: [v142]
// [Asm] live_set: [v142, zero, v7, v6, s11]
// [Asm] defined: v142 is X
// [Asm] defs: [fv143]
// [Asm] live_set: [fv143, zero, v7, v6, s11]
// [Asm] defined: fv143 is F
// [Asm] defs: []
// [Asm] live_set: [zero, v7, v6, s11]
// [Asm] defs: [v144]
// [Asm] live_set: [zero, v7, v6, s11, v144]
// [Asm] defined: v144 is X
// [Asm] defs: [fv145]
// [Asm] live_set: [fv145, zero, v7, v6, s11]
// [Asm] defined: fv145 is F
// [Asm] defs: []
// [Asm] live_set: [zero, v7, v6, s11]
// [Asm] defs: [v146]
// [Asm] live_set: [v146, zero, v7, v6, s11]
// [Asm] defined: v146 is X
// [Asm] defs: [fv147]
// [Asm] live_set: [zero, v7, v6, s11, fv147]
// [Asm] defined: fv147 is F
// [Asm] defs: []
// [Asm] live_set: [zero, v7, v6, s11]
// [Asm] defs: [v10]
// [Asm] live_set: [v10, zero, v7, v6]
// [Asm] defined: v10 is X
// [Asm] defs: [s11]
// [Asm] live_set: [v10, zero, v7, v6, s11]
// [Asm] defined: s11 is X
// [Asm] defs: [v119]
// [Asm] live_set: [v10, zero, v119, v7, v6, s11]
// [Asm] defined: v119 is X
// [Asm] defs: [fv120]
// [Asm] live_set: [fv120, v10, zero, v7, v6, s11]
// [Asm] defined: fv120 is F
// [Asm] defs: []
// [Asm] live_set: [v10, zero, v7, v6, s11]
// [Asm] defs: [v121]
// [Asm] live_set: [v10, v121, zero, v7, v6, s11]
// [Asm] defined: v121 is X
// [Asm] defs: [fv122]
// [Asm] live_set: [v10, zero, v7, fv122, v6, s11]
// [Asm] defined: fv122 is F
// [Asm] defs: []
// [Asm] live_set: [v10, zero, v7, v6, s11]
// [Asm] defs: [v123]
// [Asm] live_set: [v10, zero, v123, v7, v6, s11]
// [Asm] defined: v123 is X
// [Asm] defs: [fv124]
// [Asm] live_set: [v10, zero, v7, fv124, v6, s11]
// [Asm] defined: fv124 is F
// [Asm] defs: []
// [Asm] live_set: [v10, zero, v7, v6, s11]
// [Asm] defs: [v125]
// [Asm] live_set: [v10, zero, v125, v7, v6, s11]
// [Asm] defined: v125 is X
// [Asm] defs: [fv126]
// [Asm] live_set: [v10, zero, v7, v6, s11, fv126]
// [Asm] defined: fv126 is F
// [Asm] defs: []
// [Asm] live_set: [v10, zero, v7, v6, s11]
// [Asm] defs: [v127]
// [Asm] live_set: [v10, v127, zero, v7, v6, s11]
// [Asm] defined: v127 is X
// [Asm] defs: [fv128]
// [Asm] live_set: [fv128, v10, zero, v7, v6, s11]
// [Asm] defined: fv128 is F
// [Asm] defs: []
// [Asm] live_set: [v10, zero, v7, v6, s11]
// [Asm] defs: [v129]
// [Asm] live_set: [v10, zero, v7, v6, s11, v129]
// [Asm] defined: v129 is X
// [Asm] defs: [fv130]
// [Asm] live_set: [fv130, v10, zero, v7, v6, s11]
// [Asm] defined: fv130 is F
// [Asm] defs: []
// [Asm] live_set: [v10, zero, v7, v6, s11]
// [Asm] defs: [v131]
// [Asm] live_set: [v10, zero, v7, v6, s11, v131]
// [Asm] defined: v131 is X
// [Asm] defs: [fv132]
// [Asm] live_set: [v10, zero, v7, fv132, v6, s11]
// [Asm] defined: fv132 is F
// [Asm] defs: []
// [Asm] live_set: [v10, zero, v7, v6, s11]
// [Asm] defs: [v11]
// [Asm] live_set: [v11, v10, zero, v7, v6]
// [Asm] defined: v11 is X
// [Asm] defs: [s11]
// [Asm] live_set: [v11, v10, zero, v7, v6, s11]
// [Asm] defined: s11 is X
// [Asm] defs: [v104]
// [Asm] live_set: [v11, v10, zero, v7, v104, v6, s11]
// [Asm] defined: v104 is X
// [Asm] defs: [fv105]
// [Asm] live_set: [v11, fv105, v10, zero, v7, v6, s11]
// [Asm] defined: fv105 is F
// [Asm] defs: []
// [Asm] live_set: [v11, v10, zero, v7, v6, s11]
// [Asm] defs: [v106]
// [Asm] live_set: [v11, v106, v10, zero, v7, v6, s11]
// [Asm] defined: v106 is X
// [Asm] defs: [fv107]
// [Asm] live_set: [v11, v10, zero, v7, v6, fv107, s11]
// [Asm] defined: fv107 is F
// [Asm] defs: []
// [Asm] live_set: [v11, v10, zero, v7, v6, s11]
// [Asm] defs: [v108]
// [Asm] live_set: [v11, v10, zero, v7, v6, v108, s11]
// [Asm] defined: v108 is X
// [Asm] defs: [fv109]
// [Asm] live_set: [v11, v10, zero, v7, fv109, v6, s11]
// [Asm] defined: fv109 is F
// [Asm] defs: []
// [Asm] live_set: [v11, v10, zero, v7, v6, s11]
// [Asm] defs: [v110]
// [Asm] live_set: [v11, v10, zero, v110, v7, v6, s11]
// [Asm] defined: v110 is X
// [Asm] defs: [fv111]
// [Asm] live_set: [v11, fv111, v10, zero, v7, v6, s11]
// [Asm] defined: fv111 is F
// [Asm] defs: []
// [Asm] live_set: [v11, v10, zero, v7, v6, s11]
// [Asm] defs: [v112]
// [Asm] live_set: [v11, v112, v10, zero, v7, v6, s11]
// [Asm] defined: v112 is X
// [Asm] defs: [fv113]
// [Asm] live_set: [v11, v10, zero, fv113, v7, v6, s11]
// [Asm] defined: fv113 is F
// [Asm] defs: []
// [Asm] live_set: [v11, v10, zero, v7, v6, s11]
// [Asm] defs: [v114]
// [Asm] live_set: [v11, v10, zero, v7, v114, v6, s11]
// [Asm] defined: v114 is X
// [Asm] defs: [fv115]
// [Asm] live_set: [v11, v10, zero, fv115, v7, v6, s11]
// [Asm] defined: fv115 is F
// [Asm] defs: []
// [Asm] live_set: [v11, v10, zero, v7, v6, s11]
// [Asm] defs: [v116]
// [Asm] live_set: [v11, v116, v10, zero, v7, v6, s11]
// [Asm] defined: v116 is X
// [Asm] defs: [fv117]
// [Asm] live_set: [v11, v10, zero, v7, v6, s11, fv117]
// [Asm] defined: fv117 is F
// [Asm] defs: []
// [Asm] live_set: [v11, v10, zero, v7, v6, s11]
// [Asm] defs: [fv17]
// [Asm] live_set: [v11, v10, zero, v7, v6, s11, fv17]
// [Asm] defined: fv17 is F
// [Asm] defs: [v3]
// [Asm] live_set: [v11, v10, zero, v7, v6, fv17, v3]
// [Asm] defined: v3 is X
// [Asm] defs: [s11]
// [Asm] live_set: [v11, v10, zero, v7, v6, s11, fv17, v3]
// [Asm] defined: s11 is X
// [Asm] defs: [fv101]
// [Asm] live_set: [v11, v10, zero, v7, fv101, v6, s11, fv17, v3]
// [Asm] defined: fv101 is F
// [Asm] defs: []
// [Asm] live_set: [v11, v10, zero, v7, fv101, v6, s11, fv17, v3]
// [Asm] defs: []
// [Asm] live_set: [v11, v10, zero, v7, fv101, v6, s11, fv17, v3]
// [Asm] defs: []
// [Asm] live_set: [v11, v10, zero, v7, fv101, v6, s11, fv17, v3]
// [Asm] defs: []
// [Asm] live_set: [v11, v10, zero, v7, fv101, v6, s11, fv17, v3]
// [Asm] defs: []
// [Asm] live_set: [v11, v10, zero, v7, fv101, v6, s11, fv17, v3]
// [Asm] defs: []
// [Asm] live_set: [v11, v10, zero, v7, v6, s11, fv17, v3]
// [Asm] defs: []
// [Asm] live_set: [v11, v10, zero, v7, v6, s11, v3]
// [Asm] defs: [v9]
// [Asm] live_set: [v11, v10, zero, v7, v6, v9, v3]
// [Asm] defined: v9 is X
// [Asm] defs: [s11]
// [Asm] live_set: [v11, v10, zero, v7, v6, s11, v9, v3]
// [Asm] defined: s11 is X
// [Asm] defs: [fv99]
// [Asm] live_set: [v11, v10, fv99, zero, v7, v6, s11, v9, v3]
// [Asm] defined: fv99 is F
// [Asm] defs: []
// [Asm] live_set: [v11, v10, fv99, zero, v7, v6, s11, v9, v3]
// [Asm] defs: []
// [Asm] live_set: [v11, v10, fv99, zero, v7, v6, s11, v9, v3]
// [Asm] defs: []
// [Asm] live_set: [v11, v10, fv99, zero, v7, v6, s11, v9, v3]
// [Asm] defs: []
// [Asm] live_set: [v11, v10, fv99, zero, v7, v6, s11, v9, v3]
// [Asm] defs: []
// [Asm] live_set: [v11, v10, fv99, zero, v7, v6, s11, v9, v3]
// [Asm] defs: []
// [Asm] live_set: [v11, v10, fv99, zero, v7, v6, s11, v9, v3]
// [Asm] defs: []
// [Asm] live_set: [v11, v10, zero, v7, v6, s11, v9, v3]
// [Asm] defs: [v2]
// [Asm] live_set: [v3, v11, v10, zero, v7, v6, v9, v2]
// [Asm] defined: v2 is X
// [Asm] defs: [s11]
// [Asm] live_set: [v3, v11, v10, zero, v7, v6, s11, v9, v2]
// [Asm] defined: s11 is X
// [Asm] defs: []
// [Asm] live_set: [v3, v11, v10, zero, v7, v6, s11, v9, v2]
// [Asm] defs: []
// [Asm] live_set: [v3, v11, v10, zero, v7, v6, s11, v9, v2]
// [Asm] defs: []
// [Asm] live_set: [v3, v11, v10, zero, v7, v6, s11, v9, v2]
// [Asm] defs: []
// [Asm] live_set: [v3, v11, v10, zero, v7, v6, s11, v9, v2]
// [Asm] defs: []
// [Asm] live_set: [v3, v11, v10, zero, v7, v6, s11, v2]
// [Asm] defs: []
// [Asm] live_set: [v11, v10, zero, v7, v6, s11, v2]
// [Asm] defs: []
// [Asm] live_set: [v11, v10, zero, v7, s11, v2]
// [Asm] defs: []
// [Asm] live_set: [v11, v10, zero, s11, v2]
// [Asm] defs: []
// [Asm] live_set: [v11, zero, s11, v2]
// [Asm] defs: []
// [Asm] live_set: [zero, s11, v2]
// [Asm] defs: [v12]
// [Asm] live_set: [zero, v12, v2]
// [Asm] defined: v12 is X
// [Asm] defs: [s11]
// [Asm] live_set: [zero, v12, s11, v2]
// [Asm] defined: s11 is X
// [Asm] defs: [v4]
// [Asm] live_set: [zero, v4, v12, v2]
// [Asm] defined: v4 is X
// [Asm] defs: [s11]
// [Asm] live_set: [zero, v4, v12, s11, v2]
// [Asm] defined: s11 is X
// [Asm] defs: [v5]
// [Asm] live_set: [v5, zero, v4, v12, v2]
// [Asm] defined: v5 is X
// [Asm] defs: [s11]
// [Asm] live_set: [v5, zero, v4, v12, s11, v2]
// [Asm] defined: s11 is X
// [Asm] defs: []
// [Asm] live_set: [v5, zero, v4, v12, s11, v2]
// [Asm] defs: [a0]
// [Asm] live_set: [v5, zero, a0, v4, v12, s11, v2]
// [Asm] move: a0 <- zero
// [Asm] defined: a0 is X
// [Asm] skip edge 40 -> 2
// [Asm] defs: [a1]
// [Asm] live_set: [v5, zero, a0, v4, a1, v12, s11, v2]
// [Asm] move: a1 <- v12
// [Asm] defined: a1 is X
// [Asm] skip edge 41 -> 37
// [Asm] defs: [a2]
// [Asm] live_set: [v5, zero, a0, v4, a2, a1, v12, s11, v2]
// [Asm] move: a2 <- v4
// [Asm] defined: a2 is X
// [Asm] skip edge 42 -> 38
// [Asm] defs: [a3]
// [Asm] live_set: [v5, zero, a0, v4, a2, a1, v12, s11, a3, v2]
// [Asm] move: a3 <- v5
// [Asm] defined: a3 is X
// [Asm] skip edge 43 -> 39
// [Asm] defs: [a4]
// [Asm] live_set: [v5, zero, a0, a4, v4, a2, a1, v12, s11, a3, v2]
// [Asm] move: a4 <- v2
// [Asm] defined: a4 is X
// [Asm] skip edge 44 -> 36
// [Asm] defs: [t0, t1, t2, t3, t4, a0, a1, a2, a3, a4, a5, a6, a7, t0, t1, ft0, ft1, ft2, ft3, ft4, ft5, ft6, ft7, ft8, ft9, ft10, fa0, fa1, fa2, fa3, fa4, fa5, fa6, fa7]
// [Asm] live_set: [v5, zero, a0, v4, s11, v12, v2]
// [Asm] defined: t0 is X
// [Asm] defined: t1 is X
// [Asm] defined: t2 is X
// [Asm] defined: t3 is X
// [Asm] defined: t4 is X
// [Asm] defined: a0 is X
// [Asm] defined: a1 is X
// [Asm] defined: a2 is X
// [Asm] defined: a3 is X
// [Asm] defined: a4 is X
// [Asm] defined: a5 is X
// [Asm] defined: a6 is X
// [Asm] defined: a7 is X
// [Asm] defined: t0 is X
// [Asm] defined: t1 is X
// [Asm] defined: ft0 is F
// [Asm] defined: ft1 is F
// [Asm] defined: ft2 is F
// [Asm] defined: ft3 is F
// [Asm] defined: ft4 is F
// [Asm] defined: ft5 is F
// [Asm] defined: ft6 is F
// [Asm] defined: ft7 is F
// [Asm] defined: ft8 is F
// [Asm] defined: ft9 is F
// [Asm] defined: ft10 is F
// [Asm] defined: fa0 is F
// [Asm] defined: fa1 is F
// [Asm] defined: fa2 is F
// [Asm] defined: fa3 is F
// [Asm] defined: fa4 is F
// [Asm] defined: fa5 is F
// [Asm] defined: fa6 is F
// [Asm] defined: fa7 is F
// [Asm] defs: [v29]
// [Asm] live_set: [v5, zero, v4, s11, v12, v2]
// [Asm] move: v29 <- a0
// [Asm] defined: v29 is X
// [Asm] defs: []
// [Asm] live_set: [v5, zero, v4, s11, v12, v2]
// [Asm] defs: [v30]
// [Asm] live_set: [v5, zero, v30, v4, s11, v12, v2]
// [Asm] defined: v30 is X
// [Asm] defs: [fv31]
// [Asm] live_set: [v5, fv31, zero, v30, v4, s11, v12, v2]
// [Asm] defined: fv31 is F
// [Asm] defs: [fv32]
// [Asm] live_set: [v5, fv32, fv31, zero, v30, v4, s11, v12, v2]
// [Asm] defined: fv32 is F
// [Asm] defs: [fv33]
// [Asm] live_set: [v5, fv32, fv31, zero, v30, fv33, v4, s11, v12, v2]
// [Asm] defined: fv33 is F
// [Asm] defs: [fv37]
// [Asm] live_set: [fv37, v5, fv32, fv31, zero, fv33, v4, s11, v12, v2]
// [Asm] defined: fv37 is F
// [Asm] defs: [fv38]
// [Asm] live_set: [fv37, v5, fv32, fv31, zero, fv33, v4, s11, fv38, v2]
// [Asm] defined: fv38 is F
// [Asm] defs: [fv39]
// [Asm] live_set: [fv37, v5, fv32, fv31, zero, fv39, fv33, v4, s11, fv38, v2]
// [Asm] defined: fv39 is F
// [Asm] defs: [fv40]
// [Asm] live_set: [fv37, v5, fv32, fv31, zero, fv39, fv33, v4, s11, fv40, v2]
// [Asm] defined: fv40 is F
// [Asm] defs: [fv41]
// [Asm] live_set: [fv37, v5, fv32, fv31, zero, fv39, fv41, fv33, v4, s11, v2]
// [Asm] defined: fv41 is F
// [Asm] defs: [fv42]
// [Asm] live_set: [fv37, v5, fv32, fv31, zero, fv39, fv41, fv42, fv33, s11, v2]
// [Asm] defined: fv42 is F
// [Asm] defs: [fv43]
// [Asm] live_set: [fv37, v5, fv32, fv31, zero, fv39, fv41, fv43, fv33, s11, v2]
// [Asm] defined: fv43 is F
// [Asm] defs: [fv44]
// [Asm] live_set: [fv37, v5, fv32, fv31, zero, fv39, fv41, fv33, s11, fv44, v2]
// [Asm] defined: fv44 is F
// [Asm] defs: [fv45]
// [Asm] live_set: [fv37, fv45, fv32, fv31, zero, fv39, fv41, fv33, s11, fv44, v2]
// [Asm] defined: fv45 is F
// [Asm] defs: [fv46]
// [Asm] live_set: [fv37, fv46, fv32, fv31, zero, fv41, fv33, s11, fv44, v2]
// [Asm] defined: fv46 is F
// [Asm] defs: [fv47]
// [Asm] live_set: [fv37, fv32, fv31, zero, fv41, fv33, fv47, s11, fv44, v2]
// [Asm] defined: fv47 is F
// [Asm] defs: [v8]
// [Asm] live_set: [fv37, fv32, fv31, zero, fv41, v8, fv33, fv47, fv44, v2]
// [Asm] defined: v8 is X
// [Asm] defs: [s11]
// [Asm] live_set: [fv37, fv32, fv31, zero, fv41, v8, fv33, fv47, fv44, v2]
// [Asm] defined: s11 is X
// [Asm] defs: []
// [Asm] live_set: [fv37, fv32, zero, fv41, v8, fv33, fv47, fv44, v2]
// [Asm] defs: []
// [Asm] live_set: [fv37, zero, fv41, v8, fv33, fv47, fv44, v2]
// [Asm] defs: []
// [Asm] live_set: [fv37, zero, fv41, v8, fv47, fv44, v2]
// [Asm] defs: []
// [Asm] live_set: [fv37, zero, v8, fv47, fv44, v2]
// [Asm] defs: []
// [Asm] live_set: [v8, fv37, fv47, zero, v2]
// [Asm] defs: []
// [Asm] live_set: [v8, fv37, zero, v2]
// [Asm] defs: []
// [Asm] live_set: [v8, zero, v2]
// [Asm] defs: []
// [Asm] live_set: [zero, v2]
// [Asm] defs: []
// [Asm] live_set: [zero, v2]
// [Asm] defs: [a0]
// [Asm] live_set: [zero, a0, v2]
// [Asm] move: a0 <- v2
// [Asm] defined: a0 is X
// [Asm] skip edge 40 -> 36
// [Asm] defs: [t0, t1, t2, t3, t4, a0, a1, a2, a3, a4, a5, a6, a7, t0, t1, ft0, ft1, ft2, ft3, ft4, ft5, ft6, ft7, ft8, ft9, ft10, fa0, fa1, fa2, fa3, fa4, fa5, fa6, fa7]
// [Asm] live_set: [fa0, zero, v2]
// [Asm] defined: t0 is X
// [Asm] defined: t1 is X
// [Asm] defined: t2 is X
// [Asm] defined: t3 is X
// [Asm] defined: t4 is X
// [Asm] defined: a0 is X
// [Asm] defined: a1 is X
// [Asm] defined: a2 is X
// [Asm] defined: a3 is X
// [Asm] defined: a4 is X
// [Asm] defined: a5 is X
// [Asm] defined: a6 is X
// [Asm] defined: a7 is X
// [Asm] defined: t0 is X
// [Asm] defined: t1 is X
// [Asm] defined: ft0 is F
// [Asm] defined: ft1 is F
// [Asm] defined: ft2 is F
// [Asm] defined: ft3 is F
// [Asm] defined: ft4 is F
// [Asm] defined: ft5 is F
// [Asm] defined: ft6 is F
// [Asm] defined: ft7 is F
// [Asm] defined: ft8 is F
// [Asm] defined: ft9 is F
// [Asm] defined: ft10 is F
// [Asm] defined: fa0 is F
// [Asm] defined: fa1 is F
// [Asm] defined: fa2 is F
// [Asm] defined: fa3 is F
// [Asm] defined: fa4 is F
// [Asm] defined: fa5 is F
// [Asm] defined: fa6 is F
// [Asm] defined: fa7 is F
// [Asm] defs: [fv50]
// [Asm] live_set: [fv50, zero, v2]
// [Asm] move: fv50 <- fa0
// [Asm] defined: fv50 is F
// [Asm] defs: []
// [Asm] live_set: [fv50, zero, v2]
// [Asm] defs: [v73]
// [Asm] live_set: [v73, fv50, zero, v2]
// [Asm] defined: v73 is X
// [Asm] defs: [fv74]
// [Asm] live_set: [fv50, zero, fv74, v2]
// [Asm] defined: fv74 is F
// [Asm] defs: [fv51]
// [Asm] live_set: [fv51, zero, v2]
// [Asm] defined: fv51 is F
// [Asm] defs: [v52]
// [Asm] live_set: [v52, zero, v2]
// [Asm] defined: v52 is X
// [Asm] defs: []
// [Asm] live_set: [v52, zero, v2]
// [Asm] defs: [a0]
// [Asm] live_set: [zero, a0, v2]
// [Asm] move: a0 <- v52
// [Asm] defined: a0 is X
// [Asm] defs: [t0, t1, t2, t3, t4, a0, a1, a2, a3, a4, a5, a6, a7, t0, t1, ft0, ft1, ft2, ft3, ft4, ft5, ft6, ft7, ft8, ft9, ft10, fa0, fa1, fa2, fa3, fa4, fa5, fa6, fa7]
// [Asm] live_set: [zero, a0, v2]
// [Asm] defined: t0 is X
// [Asm] defined: t1 is X
// [Asm] defined: t2 is X
// [Asm] defined: t3 is X
// [Asm] defined: t4 is X
// [Asm] defined: a0 is X
// [Asm] defined: a1 is X
// [Asm] defined: a2 is X
// [Asm] defined: a3 is X
// [Asm] defined: a4 is X
// [Asm] defined: a5 is X
// [Asm] defined: a6 is X
// [Asm] defined: a7 is X
// [Asm] defined: t0 is X
// [Asm] defined: t1 is X
// [Asm] defined: ft0 is F
// [Asm] defined: ft1 is F
// [Asm] defined: ft2 is F
// [Asm] defined: ft3 is F
// [Asm] defined: ft4 is F
// [Asm] defined: ft5 is F
// [Asm] defined: ft6 is F
// [Asm] defined: ft7 is F
// [Asm] defined: ft8 is F
// [Asm] defined: ft9 is F
// [Asm] defined: ft10 is F
// [Asm] defined: fa0 is F
// [Asm] defined: fa1 is F
// [Asm] defined: fa2 is F
// [Asm] defined: fa3 is F
// [Asm] defined: fa4 is F
// [Asm] defined: fa5 is F
// [Asm] defined: fa6 is F
// [Asm] defined: fa7 is F
// [Asm] defs: [v53]
// [Asm] live_set: [zero, v2]
// [Asm] move: v53 <- a0
// [Asm] defined: v53 is X
// [Asm] defs: []
// [Asm] live_set: [zero, v2]
// [Asm] defs: []
// [Asm] live_set: [zero, v2]
// [Asm] defs: [v68]
// [Asm] live_set: [zero, v68, v2]
// [Asm] defined: v68 is X
// [Asm] defs: [a0]
// [Asm] live_set: [zero, a0, v2]
// [Asm] move: a0 <- v68
// [Asm] defined: a0 is X
// [Asm] defs: [v69]
// [Asm] live_set: [v69, zero, a0, v2]
// [Asm] defined: v69 is X
// [Asm] defs: [a1]
// [Asm] live_set: [a1, zero, a0, v2]
// [Asm] move: a1 <- v69
// [Asm] defined: a1 is X
// [Asm] defs: [a2]
// [Asm] live_set: [a2, a1, zero, a0, v2]
// [Asm] move: a2 <- v2
// [Asm] defined: a2 is X
// [Asm] skip edge 42 -> 36
// [Asm] defs: [t0, t1, t2, t3, t4, a0, a1, a2, a3, a4, a5, a6, a7, t0, t1, ft0, ft1, ft2, ft3, ft4, ft5, ft6, ft7, ft8, ft9, ft10, fa0, fa1, fa2, fa3, fa4, fa5, fa6, fa7]
// [Asm] live_set: [zero, a0, v2]
// [Asm] defined: t0 is X
// [Asm] defined: t1 is X
// [Asm] defined: t2 is X
// [Asm] defined: t3 is X
// [Asm] defined: t4 is X
// [Asm] defined: a0 is X
// [Asm] defined: a1 is X
// [Asm] defined: a2 is X
// [Asm] defined: a3 is X
// [Asm] defined: a4 is X
// [Asm] defined: a5 is X
// [Asm] defined: a6 is X
// [Asm] defined: a7 is X
// [Asm] defined: t0 is X
// [Asm] defined: t1 is X
// [Asm] defined: ft0 is F
// [Asm] defined: ft1 is F
// [Asm] defined: ft2 is F
// [Asm] defined: ft3 is F
// [Asm] defined: ft4 is F
// [Asm] defined: ft5 is F
// [Asm] defined: ft6 is F
// [Asm] defined: ft7 is F
// [Asm] defined: ft8 is F
// [Asm] defined: ft9 is F
// [Asm] defined: ft10 is F
// [Asm] defined: fa0 is F
// [Asm] defined: fa1 is F
// [Asm] defined: fa2 is F
// [Asm] defined: fa3 is F
// [Asm] defined: fa4 is F
// [Asm] defined: fa5 is F
// [Asm] defined: fa6 is F
// [Asm] defined: fa7 is F
// [Asm] defs: [v54]
// [Asm] live_set: [zero, v2]
// [Asm] move: v54 <- a0
// [Asm] defined: v54 is X
// [Asm] defs: []
// [Asm] live_set: [zero, v2]
// [Asm] defs: []
// [Asm] live_set: [zero, v2]
// [Asm] defs: [v66]
// [Asm] live_set: [v66, zero, v2]
// [Asm] defined: v66 is X
// [Asm] defs: [a0]
// [Asm] live_set: [zero, a0, v2]
// [Asm] move: a0 <- v66
// [Asm] defined: a0 is X
// [Asm] defs: [t0, t1, t2, t3, t4, a0, a1, a2, a3, a4, a5, a6, a7, t0, t1, ft0, ft1, ft2, ft3, ft4, ft5, ft6, ft7, ft8, ft9, ft10, fa0, fa1, fa2, fa3, fa4, fa5, fa6, fa7]
// [Asm] live_set: [zero, a0, v2]
// [Asm] defined: t0 is X
// [Asm] defined: t1 is X
// [Asm] defined: t2 is X
// [Asm] defined: t3 is X
// [Asm] defined: t4 is X
// [Asm] defined: a0 is X
// [Asm] defined: a1 is X
// [Asm] defined: a2 is X
// [Asm] defined: a3 is X
// [Asm] defined: a4 is X
// [Asm] defined: a5 is X
// [Asm] defined: a6 is X
// [Asm] defined: a7 is X
// [Asm] defined: t0 is X
// [Asm] defined: t1 is X
// [Asm] defined: ft0 is F
// [Asm] defined: ft1 is F
// [Asm] defined: ft2 is F
// [Asm] defined: ft3 is F
// [Asm] defined: ft4 is F
// [Asm] defined: ft5 is F
// [Asm] defined: ft6 is F
// [Asm] defined: ft7 is F
// [Asm] defined: ft8 is F
// [Asm] defined: ft9 is F
// [Asm] defined: ft10 is F
// [Asm] defined: fa0 is F
// [Asm] defined: fa1 is F
// [Asm] defined: fa2 is F
// [Asm] defined: fa3 is F
// [Asm] defined: fa4 is F
// [Asm] defined: fa5 is F
// [Asm] defined: fa6 is F
// [Asm] defined: fa7 is F
// [Asm] defs: [v55]
// [Asm] live_set: [zero, v2]
// [Asm] move: v55 <- a0
// [Asm] defined: v55 is X
// [Asm] defs: []
// [Asm] live_set: [zero, v2]
// [Asm] defs: []
// [Asm] live_set: [zero, v2]
// [Asm] defs: [a0]
// [Asm] live_set: [zero, a0]
// [Asm] move: a0 <- v2
// [Asm] defined: a0 is X
// [Asm] defs: [t0, t1, t2, t3, t4, a0, a1, a2, a3, a4, a5, a6, a7, t0, t1, ft0, ft1, ft2, ft3, ft4, ft5, ft6, ft7, ft8, ft9, ft10, fa0, fa1, fa2, fa3, fa4, fa5, fa6, fa7]
// [Asm] live_set: [zero, fa0]
// [Asm] defined: t0 is X
// [Asm] defined: t1 is X
// [Asm] defined: t2 is X
// [Asm] defined: t3 is X
// [Asm] defined: t4 is X
// [Asm] defined: a0 is X
// [Asm] defined: a1 is X
// [Asm] defined: a2 is X
// [Asm] defined: a3 is X
// [Asm] defined: a4 is X
// [Asm] defined: a5 is X
// [Asm] defined: a6 is X
// [Asm] defined: a7 is X
// [Asm] defined: t0 is X
// [Asm] defined: t1 is X
// [Asm] defined: ft0 is F
// [Asm] defined: ft1 is F
// [Asm] defined: ft2 is F
// [Asm] defined: ft3 is F
// [Asm] defined: ft4 is F
// [Asm] defined: ft5 is F
// [Asm] defined: ft6 is F
// [Asm] defined: ft7 is F
// [Asm] defined: ft8 is F
// [Asm] defined: ft9 is F
// [Asm] defined: ft10 is F
// [Asm] defined: fa0 is F
// [Asm] defined: fa1 is F
// [Asm] defined: fa2 is F
// [Asm] defined: fa3 is F
// [Asm] defined: fa4 is F
// [Asm] defined: fa5 is F
// [Asm] defined: fa6 is F
// [Asm] defined: fa7 is F
// [Asm] defs: [fv56]
// [Asm] live_set: [fv56, zero]
// [Asm] move: fv56 <- fa0
// [Asm] defined: fv56 is F
// [Asm] defs: []
// [Asm] live_set: [fv56, zero]
// [Asm] defs: [v62]
// [Asm] live_set: [v62, fv56, zero]
// [Asm] defined: v62 is X
// [Asm] defs: [fv63]
// [Asm] live_set: [fv63, fv56, zero]
// [Asm] defined: fv63 is F
// [Asm] defs: [fv57]
// [Asm] live_set: [zero, fv57]
// [Asm] defined: fv57 is F
// [Asm] defs: [v58]
// [Asm] live_set: [v58, zero]
// [Asm] defined: v58 is X
// [Asm] defs: []
// [Asm] live_set: [v58, zero]
// [Asm] defs: [a0]
// [Asm] live_set: [zero, a0]
// [Asm] move: a0 <- v58
// [Asm] defined: a0 is X
// [Asm] defs: [t0, t1, t2, t3, t4, a0, a1, a2, a3, a4, a5, a6, a7, t0, t1, ft0, ft1, ft2, ft3, ft4, ft5, ft6, ft7, ft8, ft9, ft10, fa0, fa1, fa2, fa3, fa4, fa5, fa6, fa7]
// [Asm] live_set: [zero, a0]
// [Asm] defined: t0 is X
// [Asm] defined: t1 is X
// [Asm] defined: t2 is X
// [Asm] defined: t3 is X
// [Asm] defined: t4 is X
// [Asm] defined: a0 is X
// [Asm] defined: a1 is X
// [Asm] defined: a2 is X
// [Asm] defined: a3 is X
// [Asm] defined: a4 is X
// [Asm] defined: a5 is X
// [Asm] defined: a6 is X
// [Asm] defined: a7 is X
// [Asm] defined: t0 is X
// [Asm] defined: t1 is X
// [Asm] defined: ft0 is F
// [Asm] defined: ft1 is F
// [Asm] defined: ft2 is F
// [Asm] defined: ft3 is F
// [Asm] defined: ft4 is F
// [Asm] defined: ft5 is F
// [Asm] defined: ft6 is F
// [Asm] defined: ft7 is F
// [Asm] defined: ft8 is F
// [Asm] defined: ft9 is F
// [Asm] defined: ft10 is F
// [Asm] defined: fa0 is F
// [Asm] defined: fa1 is F
// [Asm] defined: fa2 is F
// [Asm] defined: fa3 is F
// [Asm] defined: fa4 is F
// [Asm] defined: fa5 is F
// [Asm] defined: fa6 is F
// [Asm] defined: fa7 is F
// [Asm] defs: [v59]
// [Asm] live_set: [zero]
// [Asm] move: v59 <- a0
// [Asm] defined: v59 is X
// [Asm] defs: []
// [Asm] live_set: [zero]
// [Asm] defs: [a0]
// [Asm] live_set: [a0]
// [Asm] move: a0 <- zero
// [Asm] defined: a0 is X
// [Asm] defs: []
// [Asm] live_set: [a0]
// [Asm] defs: []
// [Asm] live_set: []
// [Asm] Label("main.631") clobbered_x: @hashset.of([a5, a0, s1, a4, s2, a2, s0, a1, a3, s3])
// [Asm] Label("main.631") clobbered_f: @hashset.of([fa7, fa5, fa2, fa3, fa4, fa6, fa0, fa1])
// [Asm] subst   addi v6, s11, -56 ->   addi a0, s11, -56
// [Asm] subst   andi s11, v6, -8 ->   andi s11, a0, -8
// [Asm] subst   li v149, 4617136985637443884 ->   li a1, 4617136985637443884
// [Asm] subst   fmv.d.x fv150, v149 ->   fmv.d.x fa0, a1
// [Asm] subst   fsd fv150, 0(v6) ->   fsd fa0, 0(a0)
// [Asm] subst   li v151, -4615467600764216452 ->   li a1, -4615467600764216452
// [Asm] subst   fmv.d.x fv152, v151 ->   fmv.d.x fa0, a1
// [Asm] subst   fsd fv152, 8(v6) ->   fsd fa0, 8(a0)
// [Asm] subst   li v153, -4631240860977730576 ->   li a1, -4631240860977730576
// [Asm] subst   fmv.d.x fv154, v153 ->   fmv.d.x fa0, a1
// [Asm] subst   fsd fv154, 16(v6) ->   fsd fa0, 16(a0)
// [Asm] subst   li v155, 4603636522180398268 ->   li a1, 4603636522180398268
// [Asm] subst   fmv.d.x fv156, v155 ->   fmv.d.x fa0, a1
// [Asm] subst   fsd fv156, 24(v6) ->   fsd fa0, 24(a0)
// [Asm] subst   li v157, 4613514450253485211 ->   li a1, 4613514450253485211
// [Asm] subst   fmv.d.x fv158, v157 ->   fmv.d.x fa0, a1
// [Asm] subst   fsd fv158, 32(v6) ->   fsd fa0, 32(a0)
// [Asm] subst   li v159, -4640446117579192555 ->   li a1, -4640446117579192555
// [Asm] subst   fmv.d.x fv160, v159 ->   fmv.d.x fa0, a1
// [Asm] subst   fsd fv160, 40(v6) ->   fsd fa0, 40(a0)
// [Asm] subst   li v161, 4585593052079010776 ->   li a1, 4585593052079010776
// [Asm] subst   fmv.d.x fv162, v161 ->   fmv.d.x fa0, a1
// [Asm] subst   fsd fv162, 48(v6) ->   fsd fa0, 48(a0)
// [Asm] subst   addi v7, s11, -56 ->   addi a1, s11, -56
// [Asm] subst   andi s11, v7, -8 ->   andi s11, a1, -8
// [Asm] subst   li v134, 4620886515960171111 ->   li a2, 4620886515960171111
// [Asm] subst   fmv.d.x fv135, v134 ->   fmv.d.x fa0, a2
// [Asm] subst   fsd fv135, 0(v7) ->   fsd fa0, 0(a1)
// [Asm] subst   li v136, 4616330128746480048 ->   li a2, 4616330128746480048
// [Asm] subst   fmv.d.x fv137, v136 ->   fmv.d.x fa0, a2
// [Asm] subst   fsd fv137, 8(v7) ->   fsd fa0, 8(a1)
// [Asm] subst   li v138, -4622431185293064580 ->   li a2, -4622431185293064580
// [Asm] subst   fmv.d.x fv139, v138 ->   fmv.d.x fa0, a2
// [Asm] subst   fsd fv139, 16(v7) ->   fsd fa0, 16(a1)
// [Asm] subst   li v140, -4616141094713322430 ->   li a2, -4616141094713322430
// [Asm] subst   fmv.d.x fv141, v140 ->   fmv.d.x fa0, a2
// [Asm] subst   fsd fv141, 24(v7) ->   fsd fa0, 24(a1)
// [Asm] subst   li v142, 4610900871547424531 ->   li a2, 4610900871547424531
// [Asm] subst   fmv.d.x fv143, v142 ->   fmv.d.x fa0, a2
// [Asm] subst   fsd fv143, 32(v7) ->   fsd fa0, 32(a1)
// [Asm] subst   li v144, 4576002370458991342 ->   li a2, 4576002370458991342
// [Asm] subst   fmv.d.x fv145, v144 ->   fmv.d.x fa0, a2
// [Asm] subst   fsd fv145, 40(v7) ->   fsd fa0, 40(a1)
// [Asm] subst   li v146, 4577659745833829943 ->   li a2, 4577659745833829943
// [Asm] subst   fmv.d.x fv147, v146 ->   fmv.d.x fa0, a2
// [Asm] subst   fsd fv147, 48(v7) ->   fsd fa0, 48(a1)
// [Asm] subst   addi v10, s11, -56 ->   addi a2, s11, -56
// [Asm] subst   andi s11, v10, -8 ->   andi s11, a2, -8
// [Asm] subst   li v119, 4623448502799161807 ->   li a3, 4623448502799161807
// [Asm] subst   fmv.d.x fv120, v119 ->   fmv.d.x fa0, a3
// [Asm] subst   fsd fv120, 0(v10) ->   fsd fa0, 0(a2)
// [Asm] subst   li v121, -4598675596822288770 ->   li a3, -4598675596822288770
// [Asm] subst   fmv.d.x fv122, v121 ->   fmv.d.x fa0, a3
// [Asm] subst   fsd fv122, 8(v10) ->   fsd fa0, 8(a2)
// [Asm] subst   li v123, -4626158513131520603 ->   li a3, -4626158513131520603
// [Asm] subst   fmv.d.x fv124, v123 ->   fmv.d.x fa0, a3
// [Asm] subst   fsd fv124, 16(v10) ->   fsd fa0, 16(a2)
// [Asm] subst   li v125, 4607555276345777135 ->   li a3, 4607555276345777135
// [Asm] subst   fmv.d.x fv126, v125 ->   fmv.d.x fa0, a3
// [Asm] subst   fsd fv126, 24(v10) ->   fsd fa0, 24(a2)
// [Asm] subst   li v127, 4605999890795117509 ->   li a3, 4605999890795117509
// [Asm] subst   fmv.d.x fv128, v127 ->   fmv.d.x fa0, a3
// [Asm] subst   fsd fv128, 32(v10) ->   fsd fa0, 32(a2)
// [Asm] subst   li v129, -4645973824767902084 ->   li a3, -4645973824767902084
// [Asm] subst   fmv.d.x fv130, v129 ->   fmv.d.x fa0, a3
// [Asm] subst   fsd fv130, 40(v10) ->   fsd fa0, 40(a2)
// [Asm] subst   li v131, 4565592097032511155 ->   li a3, 4565592097032511155
// [Asm] subst   fmv.d.x fv132, v131 ->   fmv.d.x fa0, a3
// [Asm] subst   fsd fv132, 48(v10) ->   fsd fa0, 48(a2)
// [Asm] subst   addi v11, s11, -56 ->   addi a3, s11, -56
// [Asm] subst   andi s11, v11, -8 ->   andi s11, a3, -8
// [Asm] subst   li v104, 4624847617829197610 ->   li a4, 4624847617829197610
// [Asm] subst   fmv.d.x fv105, v104 ->   fmv.d.x fa0, a4
// [Asm] subst   fsd fv105, 0(v11) ->   fsd fa0, 0(a3)
// [Asm] subst   li v106, -4595383180696444384 ->   li a4, -4595383180696444384
// [Asm] subst   fmv.d.x fv107, v106 ->   fmv.d.x fa0, a4
// [Asm] subst   fsd fv107, 8(v11) ->   fsd fa0, 8(a3)
// [Asm] subst   li v108, 4595626498235032896 ->   li a4, 4595626498235032896
// [Asm] subst   fmv.d.x fv109, v108 ->   fmv.d.x fa0, a4
// [Asm] subst   fsd fv109, 16(v11) ->   fsd fa0, 16(a3)
// [Asm] subst   li v110, 4606994084859067466 ->   li a4, 4606994084859067466
// [Asm] subst   fmv.d.x fv111, v110 ->   fmv.d.x fa0, a4
// [Asm] subst   fsd fv111, 24(v11) ->   fsd fa0, 24(a3)
// [Asm] subst   li v112, 4603531791922690979 ->   li a4, 4603531791922690979
// [Asm] subst   fmv.d.x fv113, v112 ->   fmv.d.x fa0, a4
// [Asm] subst   fsd fv113, 32(v11) ->   fsd fa0, 32(a3)
// [Asm] subst   li v114, -4638202354754755082 ->   li a4, -4638202354754755082
// [Asm] subst   fmv.d.x fv115, v114 ->   fmv.d.x fa0, a4
// [Asm] subst   fsd fv115, 40(v11) ->   fsd fa0, 40(a3)
// [Asm] subst   li v116, 4566835785178257837 ->   li a4, 4566835785178257837
// [Asm] subst   fmv.d.x fv117, v116 ->   fmv.d.x fa0, a4
// [Asm] subst   fsd fv117, 48(v11) ->   fsd fa0, 48(a3)
// [Asm] subst   fld fv17, solar_mass.4, t5 ->   fld fa0, solar_mass.4, t5
// [Asm] subst   addi v3, s11, -56 ->   addi a4, s11, -56
// [Asm] subst   andi s11, v3, -8 ->   andi s11, a4, -8
// [Asm] subst   fmv.d.x fv101, zero ->   fmv.d.x fa1, zero
// [Asm] subst   fsd fv101, 0(v3) ->   fsd fa1, 0(a4)
// [Asm] subst   fsd fv101, 8(v3) ->   fsd fa1, 8(a4)
// [Asm] subst   fsd fv101, 16(v3) ->   fsd fa1, 16(a4)
// [Asm] subst   fsd fv101, 24(v3) ->   fsd fa1, 24(a4)
// [Asm] subst   fsd fv101, 32(v3) ->   fsd fa1, 32(a4)
// [Asm] subst   fsd fv101, 40(v3) ->   fsd fa1, 40(a4)
// [Asm] subst   fsd fv17, 48(v3) ->   fsd fa0, 48(a4)
// [Asm] subst   addi v9, s11, -56 ->   addi a5, s11, -56
// [Asm] subst   andi s11, v9, -8 ->   andi s11, a5, -8
// [Asm] subst   fmv.d.x fv99, zero ->   fmv.d.x fa0, zero
// [Asm] subst   fsd fv99, 0(v9) ->   fsd fa0, 0(a5)
// [Asm] subst   fsd fv99, 8(v9) ->   fsd fa0, 8(a5)
// [Asm] subst   fsd fv99, 16(v9) ->   fsd fa0, 16(a5)
// [Asm] subst   fsd fv99, 24(v9) ->   fsd fa0, 24(a5)
// [Asm] subst   fsd fv99, 32(v9) ->   fsd fa0, 32(a5)
// [Asm] subst   fsd fv99, 40(v9) ->   fsd fa0, 40(a5)
// [Asm] subst   fsd fv99, 48(v9) ->   fsd fa0, 48(a5)
// [Asm] subst   addi v2, s11, -40 ->   addi s0, s11, -40
// [Asm] subst   andi s11, v2, -8 ->   andi s11, s0, -8
// [Asm] subst   sd v9, 0(v2) ->   sd a5, 0(s0)
// [Asm] subst   sd v9, 8(v2) ->   sd a5, 8(s0)
// [Asm] subst   sd v9, 16(v2) ->   sd a5, 16(s0)
// [Asm] subst   sd v9, 24(v2) ->   sd a5, 24(s0)
// [Asm] subst   sd v9, 32(v2) ->   sd a5, 32(s0)
// [Asm] subst   sd v3, 0(v2) ->   sd a4, 0(s0)
// [Asm] subst   sd v6, 8(v2) ->   sd a0, 8(s0)
// [Asm] subst   sd v7, 16(v2) ->   sd a1, 16(s0)
// [Asm] subst   sd v10, 24(v2) ->   sd a2, 24(s0)
// [Asm] subst   sd v11, 32(v2) ->   sd a3, 32(s0)
// [Asm] subst   addi v12, s11, -8 ->   addi s1, s11, -8
// [Asm] subst   andi s11, v12, -8 ->   andi s11, s1, -8
// [Asm] subst   addi v4, s11, -8 ->   addi s2, s11, -8
// [Asm] subst   andi s11, v4, -8 ->   andi s11, s2, -8
// [Asm] subst   addi v5, s11, -8 ->   addi s3, s11, -8
// [Asm] subst   andi s11, v5, -8 ->   andi s11, s3, -8
// [Asm] subst   mv a0, zero ->   mv a0, zero
// [Asm] subst   mv a1, v12 ->   mv a1, s1
// [Asm] subst   mv a2, v4 ->   mv a2, s2
// [Asm] subst   mv a3, v5 ->   mv a3, s3
// [Asm] subst   mv a4, v2 ->   mv a4, s0
// [Asm] subst   call loop_i.632 ->   call loop_i.632
// [Asm] subst   ld v30, 0(v2) ->   ld a0, 0(s0)
// [Asm] subst   fld fv31, 0(v30) ->   fld fa0, 0(a0)
// [Asm] subst   fld fv32, 8(v30) ->   fld fa1, 8(a0)
// [Asm] subst   fld fv33, 16(v30) ->   fld fa2, 16(a0)
// [Asm] subst   fld fv37, 48(v30) ->   fld fa3, 48(a0)
// [Asm] subst   fld fv38, 0(v12) ->   fld fa4, 0(s1)
// [Asm] subst   fld fv39, solar_mass.4, t5 ->   fld fa5, solar_mass.4, t5
// [Asm] subst   fdiv.d fv40, fv38, fv39 ->   fdiv.d fa4, fa4, fa5
// [Asm] subst   fneg.d fv41, fv40 ->   fneg.d fa4, fa4
// [Asm] subst   fld fv42, 0(v4) ->   fld fa6, 0(s2)
// [Asm] subst   fdiv.d fv43, fv42, fv39 ->   fdiv.d fa6, fa6, fa5
// [Asm] subst   fneg.d fv44, fv43 ->   fneg.d fa6, fa6
// [Asm] subst   fld fv45, 0(v5) ->   fld fa7, 0(s3)
// [Asm] subst   fdiv.d fv46, fv45, fv39 ->   fdiv.d fa5, fa7, fa5
// [Asm] subst   fneg.d fv47, fv46 ->   fneg.d fa5, fa5
// [Asm] subst   addi v8, s11, -56 ->   addi a0, s11, -56
// [Asm] subst   andi s11, v8, -8 ->   andi s11, a0, -8
// [Asm] subst   fsd fv31, 0(v8) ->   fsd fa0, 0(a0)
// [Asm] subst   fsd fv32, 8(v8) ->   fsd fa1, 8(a0)
// [Asm] subst   fsd fv33, 16(v8) ->   fsd fa2, 16(a0)
// [Asm] subst   fsd fv41, 24(v8) ->   fsd fa4, 24(a0)
// [Asm] subst   fsd fv44, 32(v8) ->   fsd fa6, 32(a0)
// [Asm] subst   fsd fv47, 40(v8) ->   fsd fa5, 40(a0)
// [Asm] subst   fsd fv37, 48(v8) ->   fsd fa3, 48(a0)
// [Asm] subst   sd v8, 0(v2) ->   sd a0, 0(s0)
// [Asm] subst   mv a0, v2 ->   mv a0, s0
// [Asm] subst   call energy.628 ->   call energy.628
// [Asm] subst   li v73, 4741671816366391296 ->   li a0, 4741671816366391296
// [Asm] subst   fmv.d.x fv74, v73 ->   fmv.d.x fa1, a0
// [Asm] subst   fmul.d fv51, fv50, fv74 ->   fmul.d fa0, fa0, fa1
// [Asm] subst   fcvt.w.d v52, fv51, rtz ->   fcvt.w.d a0, fa0, rtz
// [Asm] subst   call minimbt_print_int ->   call minimbt_print_int
// [Asm] subst   li v68, 1 ->   li a0, 1
// [Asm] subst   li v69, 500000 ->   li a1, 500000
// [Asm] subst   mv a2, v2 ->   mv a2, s0
// [Asm] subst   call loop_i.633 ->   call loop_i.633
// [Asm] subst   li v66, 10 ->   li a0, 10
// [Asm] subst   call minimbt_print_char ->   call minimbt_print_char
// [Asm] subst   mv a0, v2 ->   mv a0, s0
// [Asm] subst   call energy.628 ->   call energy.628
// [Asm] subst   li v62, 4741671816366391296 ->   li a0, 4741671816366391296
// [Asm] subst   fmv.d.x fv63, v62 ->   fmv.d.x fa1, a0
// [Asm] subst   fmul.d fv57, fv56, fv63 ->   fmul.d fa0, fa0, fa1
// [Asm] subst   fcvt.w.d v58, fv57, rtz ->   fcvt.w.d a0, fa0, rtz
// [Asm] subst   call minimbt_print_int ->   call minimbt_print_int
// [Asm] subst   mv a0, zero ->   mv a0, zero
// [Asm] subst   ret ->   ret
// [Asm] LoweringOrder: [0, 2, 1, 3]
// [Asm] LoweringOrder: [[1, 2], [3], [3], []]
// [Asm] LoweringOrder: HashMap::of([(b0, 0), (b1, 0), (b2, 1), (b3, 0)])
// [Asm] LoweringOrder: [b0, b1, b3, b2]
// [Asm] LoweringOrder: HashMap::of([(b0, 0), (b1, 1), (b2, 0), (b3, 2)])
// [Asm] pre_assigned_registers: Insn(iref=%15) -> fv25, FnParam(fref=f0, fpref=$f.5) -> fv7, Insn(iref=%8) -> fv18, Insn(iref=%10) -> fv20, Insn(iref=%25) -> v10, Insn(iref=%14) -> fv24, Insn(iref=%4) -> fv14, Insn(iref=%1) -> v11, Insn(iref=%11) -> fv21, Insn(iref=%6) -> fv16, Self(fref=f0) -> v0, BlockParam(bref=b3, bpref=$b.0) -> v35, Insn(iref=%9) -> fv19, Insn(iref=%16) -> fv26, Insn(iref=%24) -> v34, FnParam(fref=f0, fpref=$f.3) -> fv5, FnParam(fref=f0, fpref=$f.0) -> v2, FnParam(fref=f0, fpref=$f.6) -> v8, Insn(iref=%5) -> fv15, Insn(iref=%0) -> v9, Insn(iref=%19) -> fv29, Insn(iref=%3) -> fv13, Insn(iref=%18) -> fv28, Insn(iref=%13) -> fv23, FnParam(fref=f0, fpref=$f.1) -> v3, FnParam(fref=f0, fpref=$f.2) -> fv4, Insn(iref=%7) -> fv17, Insn(iref=%22) -> v32, Insn(iref=%17) -> fv27, Insn(iref=%23) -> v33, Insn(iref=%2) -> fv12, FnParam(fref=f0, fpref=$f.4) -> fv6, Insn(iref=%20) -> fv30, Insn(iref=%21) -> fv31, Insn(iref=%12) -> fv22
// [Asm] succs: []
// [Asm] critical edges for b3: []
// [Asm] critical color seq for b3: []
// [Asm] succs: [3]
// [Asm] critical edges for b1: []
// [Asm] critical color seq for b1: []
// [Asm] skipping Op(ty=Double, op=Mul, args=[Insn(iref=%11), Insn(iref=%11)])
// [Asm] skipping Op(ty=Double, op=Mul, args=[Insn(iref=%10), Insn(iref=%10)])
// [Asm] skipping Load(ty=Double, ma=Field(ty=Double, val=Insn(iref=%1), index=5, width=@(@64, @(@64, @(@64, @(@64, @(@64, @(@64, @(@64, @32)))))))))
// [Asm] skipping Load(ty=Double, ma=Field(ty=Double, val=Insn(iref=%1), index=4, width=@(@64, @(@64, @(@64, @(@64, @(@64, @(@64, @(@64, @32)))))))))
// [Asm] skipping Load(ty=Double, ma=Field(ty=Double, val=Insn(iref=%1), index=3, width=@(@64, @(@64, @(@64, @(@64, @(@64, @(@64, @(@64, @32)))))))))
// [Asm] fuse raw offset and compute address
// [Asm] skipping ComputeAddress(ma=Offset(ty=Unit, val=Int64(val=0), offset=FnParam(fref=f0, fpref=$f.0), width=@64))
// [Asm] succs: [3]
// [Asm] critical edges for b2: []
// [Asm] critical color seq for b2: []
// [Asm] succs: [1, 2]
// [Asm] critical edges for b0: []
// [Asm] critical color seq for b0: []
// [Asm] skipping Op(ty=Bool, op=Le, args=[FnParam(fref=f0, fpref=$f.0), Int32(val=4)])
// [Asm] defs: [a0]
// [Asm] live_set: [a0]
// [Asm] move: a0 <- zero
// [Asm] defined: a0 is X
// [Asm] defs: []
// [Asm] live_set: [a0]
// [Asm] defs: []
// [Asm] live_set: []
// [Asm] defs: [v35]
// [Asm] live_set: [zero, v35]
// [Asm] move: v35 <- zero
// [Asm] defined: v35 is X
// [Asm] skip edge 2 -> 0
// [Asm] defs: []
// [Asm] live_set: [zero, v35]
// [Asm] defs: [v53]
// [Asm] live_set: [v2, fv5, v53, zero, v8, fv4, fv6, fv7, v3]
// [Asm] defined: v53 is X
// [Asm] defs: [v54]
// [Asm] live_set: [v2, fv5, zero, v8, fv4, fv6, v54, fv7, v3]
// [Asm] defined: v54 is X
// [Asm] defs: [v11]
// [Asm] live_set: [v2, fv5, v11, zero, v8, fv4, fv6, fv7, v3]
// [Asm] defined: v11 is X
// [Asm] defs: [fv12]
// [Asm] live_set: [v2, fv5, v11, zero, v8, fv12, fv4, fv6, fv7, v3]
// [Asm] defined: fv12 is F
// [Asm] defs: [fv13]
// [Asm] live_set: [v2, fv5, v11, zero, v8, fv13, fv12, fv4, fv6, fv7, v3]
// [Asm] defined: fv13 is F
// [Asm] defs: [fv14]
// [Asm] live_set: [v2, fv5, v11, zero, v8, fv13, fv12, fv4, fv14, fv6, fv7, v3]
// [Asm] defined: fv14 is F
// [Asm] defs: [fv18]
// [Asm] live_set: [v2, fv5, zero, v8, fv13, fv12, fv4, fv14, fv6, fv18, fv7, v3]
// [Asm] defined: fv18 is F
// [Asm] defs: [fv19]
// [Asm] live_set: [v2, fv5, zero, v8, fv13, fv19, fv4, fv14, fv6, fv18, fv7, v3]
// [Asm] defined: fv19 is F
// [Asm] defs: [fv20]
// [Asm] live_set: [v2, fv5, zero, v8, fv20, fv19, fv4, fv14, fv6, fv18, fv7, v3]
// [Asm] defined: fv20 is F
// [Asm] defs: [fv21]
// [Asm] live_set: [v3, v2, fv5, zero, v8, fv20, fv19, fv4, fv6, fv18, fv7, fv21]
// [Asm] defined: fv21 is F
// [Asm] defs: [fv22]
// [Asm] live_set: [v3, v2, fv5, fv22, zero, v8, fv20, fv4, fv6, fv18, fv7, fv21]
// [Asm] defined: fv22 is F
// [Asm] defs: [fv24]
// [Asm] live_set: [v3, v2, fv5, fv24, zero, v8, fv4, fv6, fv18, fv7, fv21]
// [Asm] defined: fv24 is F
// [Asm] defs: [fv26]
// [Asm] live_set: [v2, v3, fv5, zero, v8, fv4, fv6, fv18, fv26, fv7]
// [Asm] defined: fv26 is F
// [Asm] defs: [fv27]
// [Asm] live_set: [v2, v3, fv5, zero, v8, fv4, fv27, fv6, fv18, fv26, fv7]
// [Asm] defined: fv27 is F
// [Asm] defs: [fv28]
// [Asm] live_set: [v2, fv5, fv28, zero, v8, fv4, fv27, fv6, fv26, fv7, v3]
// [Asm] defined: fv28 is F
// [Asm] defs: [fv29]
// [Asm] live_set: [v2, fv5, fv28, zero, v8, fv29, fv4, fv27, fv6, fv7, v3]
// [Asm] defined: fv29 is F
// [Asm] defs: [fv30]
// [Asm] live_set: [v2, fv5, zero, v8, fv30, fv4, fv27, fv6, fv7, v3]
// [Asm] defined: fv30 is F
// [Asm] defs: [fv31]
// [Asm] live_set: [v2, fv5, fv31, zero, v8, fv4, fv6, fv7, v3]
// [Asm] defined: fv31 is F
// [Asm] defs: []
// [Asm] live_set: [v2, fv5, zero, v8, fv4, fv6, fv7, v3]
// [Asm] defs: [v33]
// [Asm] live_set: [fv5, zero, v8, fv4, fv6, v33, fv7, v3]
// [Asm] defined: v33 is X
// [Asm] defs: []
// [Asm] live_set: [fv5, zero, v8, fv4, fv6, v33, fv7, v3]
// [Asm] defs: [a0]
// [Asm] live_set: [fv5, a0, zero, v8, fv4, fv6, fv7, v3]
// [Asm] move: a0 <- v33
// [Asm] defined: a0 is X
// [Asm] defs: [a1]
// [Asm] live_set: [fv5, a0, zero, v8, a1, fv4, fv6, fv7]
// [Asm] move: a1 <- v3
// [Asm] defined: a1 is X
// [Asm] defs: [fa0]
// [Asm] live_set: [fv5, a0, zero, fa0, v8, a1, fv6, fv7]
// [Asm] move: fa0 <- fv4
// [Asm] defined: fa0 is F
// [Asm] defs: [fa1]
// [Asm] live_set: [a0, zero, fa0, v8, a1, fv6, fa1, fv7]
// [Asm] move: fa1 <- fv5
// [Asm] defined: fa1 is F
// [Asm] defs: [fa2]
// [Asm] live_set: [fa2, a0, zero, fa0, v8, a1, fa1, fv7]
// [Asm] move: fa2 <- fv6
// [Asm] defined: fa2 is F
// [Asm] defs: [fa3]
// [Asm] live_set: [fa2, fa3, a0, zero, fa0, v8, a1, fa1]
// [Asm] move: fa3 <- fv7
// [Asm] defined: fa3 is F
// [Asm] defs: [a2]
// [Asm] live_set: [fa2, fa3, a0, zero, fa0, a2, a1, fa1]
// [Asm] move: a2 <- v8
// [Asm] defined: a2 is X
// [Asm] defs: [t0, t1, t2, t3, t4, a0, a1, a2, a3, a4, a5, a6, a7, t0, t1, ft0, ft1, ft2, ft3, ft4, ft5, ft6, ft7, ft8, ft9, ft10, fa0, fa1, fa2, fa3, fa4, fa5, fa6, fa7]
// [Asm] live_set: [zero, a0]
// [Asm] defined: t0 is X
// [Asm] defined: t1 is X
// [Asm] defined: t2 is X
// [Asm] defined: t3 is X
// [Asm] defined: t4 is X
// [Asm] defined: a0 is X
// [Asm] defined: a1 is X
// [Asm] defined: a2 is X
// [Asm] defined: a3 is X
// [Asm] defined: a4 is X
// [Asm] defined: a5 is X
// [Asm] defined: a6 is X
// [Asm] defined: a7 is X
// [Asm] defined: t0 is X
// [Asm] defined: t1 is X
// [Asm] defined: ft0 is F
// [Asm] defined: ft1 is F
// [Asm] defined: ft2 is F
// [Asm] defined: ft3 is F
// [Asm] defined: ft4 is F
// [Asm] defined: ft5 is F
// [Asm] defined: ft6 is F
// [Asm] defined: ft7 is F
// [Asm] defined: ft8 is F
// [Asm] defined: ft9 is F
// [Asm] defined: ft10 is F
// [Asm] defined: fa0 is F
// [Asm] defined: fa1 is F
// [Asm] defined: fa2 is F
// [Asm] defined: fa3 is F
// [Asm] defined: fa4 is F
// [Asm] defined: fa5 is F
// [Asm] defined: fa6 is F
// [Asm] defined: fa7 is F
// [Asm] defs: [v34]
// [Asm] live_set: [zero]
// [Asm] move: v34 <- a0
// [Asm] defined: v34 is X
// [Asm] defs: []
// [Asm] live_set: [zero]
// [Asm] defs: [v35]
// [Asm] live_set: [zero, v35]
// [Asm] move: v35 <- zero
// [Asm] defined: v35 is X
// [Asm] skip edge 2 -> 0
// [Asm] defs: []
// [Asm] live_set: [fa3, fa2, zero, a0, fa0, a2, a1, fa1]
// [Asm] defs: [v2]
// [Asm] live_set: [fa3, fa2, zero, fa0, a2, a1, fa1, v2]
// [Asm] move: v2 <- a0
// [Asm] defined: v2 is X
// [Asm] defs: [v3]
// [Asm] live_set: [v2, fa3, fa2, zero, fa0, a2, fa1, v3]
// [Asm] move: v3 <- a1
// [Asm] defined: v3 is X
// [Asm] defs: [fv4]
// [Asm] live_set: [v2, fa3, fa2, zero, a2, fv4, fa1, v3]
// [Asm] move: fv4 <- fa0
// [Asm] defined: fv4 is F
// [Asm] defs: [fv5]
// [Asm] live_set: [v2, fv5, fa3, fa2, zero, a2, fv4, v3]
// [Asm] move: fv5 <- fa1
// [Asm] defined: fv5 is F
// [Asm] defs: [fv6]
// [Asm] live_set: [v2, fv5, fa3, zero, a2, fv4, fv6, v3]
// [Asm] move: fv6 <- fa2
// [Asm] defined: fv6 is F
// [Asm] defs: [fv7]
// [Asm] live_set: [v2, fv5, zero, a2, fv4, fv6, fv7, v3]
// [Asm] move: fv7 <- fa3
// [Asm] defined: fv7 is F
// [Asm] defs: [v8]
// [Asm] live_set: [v2, fv5, zero, v8, fv4, fv6, fv7, v3]
// [Asm] move: v8 <- a2
// [Asm] defined: v8 is X
// [Asm] defs: [v56]
// [Asm] live_set: [v2, fv5, v56, zero, v8, fv4, fv6, fv7, v3]
// [Asm] defined: v56 is X
// [Asm] defs: []
// [Asm] live_set: [v2, fv5, zero, v8, fv4, fv6, fv7, v3]
// [Asm] Label("loop_j.630") clobbered_x: @hashset.of([a2, a1, a3, a0])
// [Asm] Label("loop_j.630") clobbered_f: @hashset.of([fa7, fa5, fa2, fa3, fa4, fa6, fa0, fa1])
// [Asm] subst   mv a0, zero ->   mv a0, zero
// [Asm] subst   ret ->   ret
// [Asm] subst   mv v35, zero ->   mv a0, zero
// [Asm] subst   j .loop_j.630_3 ->   j .loop_j.630_3
// [Asm] subst   slliw v53, v2, 3 ->   slliw a3, a0, 3
// [Asm] subst   add v54, v8, v53 ->   add a3, a2, a3
// [Asm] subst   ld v11, 0(v54) ->   ld a3, 0(a3)
// [Asm] subst   fld fv12, 0(v11) ->   fld fa4, 0(a3)
// [Asm] subst   fld fv13, 8(v11) ->   fld fa5, 8(a3)
// [Asm] subst   fld fv14, 16(v11) ->   fld fa6, 16(a3)
// [Asm] subst   fld fv18, 48(v11) ->   fld fa7, 48(a3)
// [Asm] subst   fsub.d fv19, fv5, fv12 ->   fsub.d fa4, fa1, fa4
// [Asm] subst   fsub.d fv20, fv6, fv13 ->   fsub.d fa5, fa2, fa5
// [Asm] subst   fsub.d fv21, fv7, fv14 ->   fsub.d fa6, fa3, fa6
// [Asm] subst   fmul.d fv22, fv19, fv19 ->   fmul.d fa4, fa4, fa4
// [Asm] subst   fmadd.d fv24, fv20, fv20, fv22 ->   fmadd.d fa4, fa5, fa5, fa4
// [Asm] subst   fmadd.d fv26, fv21, fv21, fv24 ->   fmadd.d fa4, fa6, fa6, fa4
// [Asm] subst   fld fv27, 0(v3) ->   fld fa5, 0(a1)
// [Asm] subst   fmul.d fv28, fv4, fv18 ->   fmul.d fa6, fa0, fa7
// [Asm] subst   fsqrt.d fv29, fv26 ->   fsqrt.d fa4, fa4
// [Asm] subst   fdiv.d fv30, fv28, fv29 ->   fdiv.d fa4, fa6, fa4
// [Asm] subst   fsub.d fv31, fv27, fv30 ->   fsub.d fa4, fa5, fa4
// [Asm] subst   fsd fv31, 0(v3) ->   fsd fa4, 0(a1)
// [Asm] subst   addi v33, v2, 1 ->   addi a0, a0, 1
// [Asm] subst   call loop_j.630 ->   call loop_j.630
// [Asm] subst   mv v35, zero ->   mv a0, zero
// [Asm] subst   li v56, 4 ->   li a3, 4
// [Asm] subst   blt v56, v2, .loop_j.630_2 ->   blt a3, a0, .loop_j.630_2
// [Asm] LoweringOrder: [0, 2, 1, 3]
// [Asm] LoweringOrder: [[1, 2], [3], [3], []]
// [Asm] LoweringOrder: HashMap::of([(b0, 0), (b1, 0), (b2, 1), (b3, 0)])
// [Asm] LoweringOrder: [b0, b1, b3, b2]
// [Asm] LoweringOrder: HashMap::of([(b0, 0), (b1, 1), (b2, 0), (b3, 2)])
// [Asm] pre_assigned_registers: Insn(iref=%15) -> fv21, FnParam(fref=f1, fpref=$f.0) -> v2, BlockParam(bref=b3, bpref=$b.0) -> v29, Insn(iref=%9) -> fv15, Insn(iref=%16) -> fv22, Insn(iref=%8) -> fv14, Insn(iref=%10) -> fv16, Insn(iref=%14) -> fv20, Insn(iref=%5) -> fv11, Insn(iref=%0) -> v5, Insn(iref=%19) -> v25, Insn(iref=%4) -> fv10, Insn(iref=%3) -> fv9, Insn(iref=%18) -> v24, Insn(iref=%13) -> fv19, FnParam(fref=f1, fpref=$f.1) -> v3, Insn(iref=%7) -> fv13, FnParam(fref=f1, fpref=$f.2) -> v4, Insn(iref=%22) -> v28, Insn(iref=%23) -> v6, Insn(iref=%17) -> fv23, Insn(iref=%2) -> fv8, Insn(iref=%1) -> v7, Insn(iref=%20) -> v26, Insn(iref=%11) -> fv17, Self(fref=f1) -> v0, Insn(iref=%21) -> v27, Insn(iref=%6) -> fv12, Insn(iref=%12) -> fv18
// [Asm] succs: []
// [Asm] critical edges for b3: []
// [Asm] critical color seq for b3: []
// [Asm] succs: [3]
// [Asm] critical edges for b1: []
// [Asm] critical color seq for b1: []
// [Asm] skipping Op(ty=Double, op=Mul, args=[Insn(iref=%10), Insn(iref=%15)])
// [Asm] skipping Op(ty=Double, op=Mul, args=[Insn(iref=%7), Insn(iref=%7)])
// [Asm] skipping Op(ty=Double, op=Mul, args=[Insn(iref=%6), Insn(iref=%6)])
// [Asm] fuse raw offset and compute address
// [Asm] skipping ComputeAddress(ma=Offset(ty=Unit, val=Int64(val=0), offset=FnParam(fref=f1, fpref=$f.0), width=@64))
// [Asm] succs: [3]
// [Asm] critical edges for b2: []
// [Asm] critical color seq for b2: []
// [Asm] succs: [1, 2]
// [Asm] critical edges for b0: []
// [Asm] critical color seq for b0: []
// [Asm] skipping Op(ty=Bool, op=Le, args=[FnParam(fref=f1, fpref=$f.0), Int32(val=4)])
// [Asm] defs: [v49]
// [Asm] live_set: [v2, v49, zero, v4, v3]
// [Asm] defined: v49 is X
// [Asm] defs: [v50]
// [Asm] live_set: [v2, zero, v50, v4, v3]
// [Asm] defined: v50 is X
// [Asm] defs: [v7]
// [Asm] live_set: [v2, v7, zero, v4, v3]
// [Asm] defined: v7 is X
// [Asm] defs: [fv8]
// [Asm] live_set: [v2, fv8, v7, zero, v4, v3]
// [Asm] defined: fv8 is F
// [Asm] defs: [fv9]
// [Asm] live_set: [v2, fv8, v7, fv9, zero, v4, v3]
// [Asm] defined: fv9 is F
// [Asm] defs: [fv10]
// [Asm] live_set: [v2, fv10, fv8, v7, fv9, zero, v4, v3]
// [Asm] defined: fv10 is F
// [Asm] defs: [fv11]
// [Asm] live_set: [v2, fv10, fv8, v7, fv9, zero, fv11, v4, v3]
// [Asm] defined: fv11 is F
// [Asm] defs: [fv12]
// [Asm] live_set: [v2, fv10, fv8, v7, fv12, fv9, zero, fv11, v4, v3]
// [Asm] defined: fv12 is F
// [Asm] defs: [fv13]
// [Asm] live_set: [v2, fv10, fv8, v7, fv12, fv9, zero, fv11, fv13, v4, v3]
// [Asm] defined: fv13 is F
// [Asm] defs: [fv14]
// [Asm] live_set: [v2, fv10, fv8, fv12, fv14, fv9, zero, fv11, fv13, v4, v3]
// [Asm] defined: fv14 is F
// [Asm] defs: [fv15]
// [Asm] live_set: [v2, fv10, fv8, fv12, fv14, fv15, fv9, zero, fv11, fv13, v4, v3]
// [Asm] defined: fv15 is F
// [Asm] defs: [v38]
// [Asm] live_set: [v2, fv10, fv8, fv12, fv14, fv15, fv9, zero, fv11, fv13, v4, v38, v3]
// [Asm] defined: v38 is X
// [Asm] defs: [fv39]
// [Asm] live_set: [v2, fv10, fv39, fv8, fv12, fv14, fv15, fv9, zero, fv11, fv13, v4, v3]
// [Asm] defined: fv39 is F
// [Asm] defs: [fv16]
// [Asm] live_set: [v2, fv10, fv8, fv12, fv14, fv16, fv15, fv9, zero, fv11, fv13, v4, v3]
// [Asm] defined: fv16 is F
// [Asm] defs: [fv17]
// [Asm] live_set: [v3, fv9, fv10, zero, fv8, fv13, v4, fv12, fv14, fv16, fv15, fv17, v2]
// [Asm] defined: fv17 is F
// [Asm] defs: [fv19]
// [Asm] live_set: [v3, fv9, fv10, zero, fv8, fv13, fv19, v4, fv14, fv16, fv15, v2]
// [Asm] defined: fv19 is F
// [Asm] defs: [fv21]
// [Asm] live_set: [v3, fv9, fv10, zero, fv8, v4, fv14, fv16, fv15, fv21, v2]
// [Asm] defined: fv21 is F
// [Asm] defs: [fv23]
// [Asm] live_set: [v3, fv9, fv10, fv23, zero, fv8, v4, fv14, v2]
// [Asm] defined: fv23 is F
// [Asm] defs: []
// [Asm] live_set: [v3, fv9, fv10, zero, fv8, v4, fv14, v2]
// [Asm] defs: [v25]
// [Asm] live_set: [v3, fv9, v25, fv10, zero, fv8, v4, fv14, v2]
// [Asm] defined: v25 is X
// [Asm] defs: []
// [Asm] live_set: [v3, fv9, v25, fv10, zero, fv8, v4, fv14, v2]
// [Asm] defs: [a0]
// [Asm] live_set: [v3, fv9, fv10, zero, a0, fv8, v4, fv14, v2]
// [Asm] move: a0 <- v25
// [Asm] defined: a0 is X
// [Asm] defs: [a1]
// [Asm] live_set: [v3, fv9, fv10, zero, a0, fv8, v4, a1, fv14, v2]
// [Asm] move: a1 <- v3
// [Asm] defined: a1 is X
// [Asm] skip edge 10 -> 4
// [Asm] defs: [fa0]
// [Asm] live_set: [v3, fv9, fv10, zero, a0, fa0, fv8, v4, a1, v2]
// [Asm] move: fa0 <- fv14
// [Asm] defined: fa0 is F
// [Asm] defs: [fa1]
// [Asm] live_set: [v3, fv9, fv10, zero, a0, fa0, v4, a1, fa1, v2]
// [Asm] move: fa1 <- fv8
// [Asm] defined: fa1 is F
// [Asm] defs: [fa2]
// [Asm] live_set: [v3, fv10, fa2, zero, a0, fa0, v4, a1, fa1, v2]
// [Asm] move: fa2 <- fv9
// [Asm] defined: fa2 is F
// [Asm] defs: [fa3]
// [Asm] live_set: [v3, fa2, fa3, zero, a0, fa0, v4, a1, fa1, v2]
// [Asm] move: fa3 <- fv10
// [Asm] defined: fa3 is F
// [Asm] defs: [a2]
// [Asm] live_set: [v3, fa2, fa3, zero, a0, fa0, v4, a2, a1, fa1, v2]
// [Asm] move: a2 <- v4
// [Asm] defined: a2 is X
// [Asm] skip edge 11 -> 3
// [Asm] defs: [t0, t1, t2, t3, t4, a0, a1, a2, a3, a4, a5, a6, a7, t0, t1, ft0, ft1, ft2, ft3, ft4, ft5, ft6, ft7, ft8, ft9, ft10, fa0, fa1, fa2, fa3, fa4, fa5, fa6, fa7]
// [Asm] live_set: [v2, v4, zero, a0, v3]
// [Asm] defined: t0 is X
// [Asm] defined: t1 is X
// [Asm] defined: t2 is X
// [Asm] defined: t3 is X
// [Asm] defined: t4 is X
// [Asm] defined: a0 is X
// [Asm] defined: a1 is X
// [Asm] defined: a2 is X
// [Asm] defined: a3 is X
// [Asm] defined: a4 is X
// [Asm] defined: a5 is X
// [Asm] defined: a6 is X
// [Asm] defined: a7 is X
// [Asm] defined: t0 is X
// [Asm] defined: t1 is X
// [Asm] defined: ft0 is F
// [Asm] defined: ft1 is F
// [Asm] defined: ft2 is F
// [Asm] defined: ft3 is F
// [Asm] defined: ft4 is F
// [Asm] defined: ft5 is F
// [Asm] defined: ft6 is F
// [Asm] defined: ft7 is F
// [Asm] defined: ft8 is F
// [Asm] defined: ft9 is F
// [Asm] defined: ft10 is F
// [Asm] defined: fa0 is F
// [Asm] defined: fa1 is F
// [Asm] defined: fa2 is F
// [Asm] defined: fa3 is F
// [Asm] defined: fa4 is F
// [Asm] defined: fa5 is F
// [Asm] defined: fa6 is F
// [Asm] defined: fa7 is F
// [Asm] defs: [v26]
// [Asm] live_set: [v2, v4, zero, v3]
// [Asm] move: v26 <- a0
// [Asm] defined: v26 is X
// [Asm] defs: []
// [Asm] live_set: [v2, v4, zero, v3]
// [Asm] defs: [v27]
// [Asm] live_set: [v4, zero, v27, v3]
// [Asm] defined: v27 is X
// [Asm] defs: []
// [Asm] live_set: [v4, zero, v27, v3]
// [Asm] defs: [a0]
// [Asm] live_set: [v4, zero, a0, v3]
// [Asm] move: a0 <- v27
// [Asm] defined: a0 is X
// [Asm] defs: [a1]
// [Asm] live_set: [v4, a1, zero, a0]
// [Asm] move: a1 <- v3
// [Asm] defined: a1 is X
// [Asm] defs: [a2]
// [Asm] live_set: [a2, a1, zero, a0]
// [Asm] move: a2 <- v4
// [Asm] defined: a2 is X
// [Asm] defs: [t0, t1, t2, t3, t4, a0, a1, a2, a3, a4, a5, a6, a7, t0, t1, ft0, ft1, ft2, ft3, ft4, ft5, ft6, ft7, ft8, ft9, ft10, fa0, fa1, fa2, fa3, fa4, fa5, fa6, fa7]
// [Asm] live_set: [zero, a0]
// [Asm] defined: t0 is X
// [Asm] defined: t1 is X
// [Asm] defined: t2 is X
// [Asm] defined: t3 is X
// [Asm] defined: t4 is X
// [Asm] defined: a0 is X
// [Asm] defined: a1 is X
// [Asm] defined: a2 is X
// [Asm] defined: a3 is X
// [Asm] defined: a4 is X
// [Asm] defined: a5 is X
// [Asm] defined: a6 is X
// [Asm] defined: a7 is X
// [Asm] defined: t0 is X
// [Asm] defined: t1 is X
// [Asm] defined: ft0 is F
// [Asm] defined: ft1 is F
// [Asm] defined: ft2 is F
// [Asm] defined: ft3 is F
// [Asm] defined: ft4 is F
// [Asm] defined: ft5 is F
// [Asm] defined: ft6 is F
// [Asm] defined: ft7 is F
// [Asm] defined: ft8 is F
// [Asm] defined: ft9 is F
// [Asm] defined: ft10 is F
// [Asm] defined: fa0 is F
// [Asm] defined: fa1 is F
// [Asm] defined: fa2 is F
// [Asm] defined: fa3 is F
// [Asm] defined: fa4 is F
// [Asm] defined: fa5 is F
// [Asm] defined: fa6 is F
// [Asm] defined: fa7 is F
// [Asm] defs: [v28]
// [Asm] live_set: [zero]
// [Asm] move: v28 <- a0
// [Asm] defined: v28 is X
// [Asm] defs: []
// [Asm] live_set: [zero]
// [Asm] defs: [v29]
// [Asm] live_set: [v29, zero]
// [Asm] move: v29 <- zero
// [Asm] defined: v29 is X
// [Asm] skip edge 25 -> 2
// [Asm] defs: []
// [Asm] live_set: [a2, a1, zero, a0]
// [Asm] defs: [v2]
// [Asm] live_set: [a2, a1, zero, v2]
// [Asm] move: v2 <- a0
// [Asm] defined: v2 is X
// [Asm] defs: [v3]
// [Asm] live_set: [v3, a2, zero, v2]
// [Asm] move: v3 <- a1
// [Asm] defined: v3 is X
// [Asm] defs: [v4]
// [Asm] live_set: [v3, v4, zero, v2]
// [Asm] move: v4 <- a2
// [Asm] defined: v4 is X
// [Asm] defs: [v52]
// [Asm] live_set: [v3, v4, v52, zero, v2]
// [Asm] defined: v52 is X
// [Asm] defs: []
// [Asm] live_set: [v3, v4, zero, v2]
// [Asm] defs: [a0]
// [Asm] live_set: [a0]
// [Asm] move: a0 <- zero
// [Asm] defined: a0 is X
// [Asm] defs: []
// [Asm] live_set: [a0]
// [Asm] defs: []
// [Asm] live_set: []
// [Asm] defs: [v29]
// [Asm] live_set: [v29, zero]
// [Asm] move: v29 <- zero
// [Asm] defined: v29 is X
// [Asm] skip edge 25 -> 2
// [Asm] defs: []
// [Asm] live_set: [v29, zero]
// [Asm] Label("loop_i.629") clobbered_x: @hashset.of([s2, s0, a0, s1])
// [Asm] Label("loop_i.629") clobbered_f: @hashset.of([fa7, fa5, fa2, fa3, fa4, fa6, fa0, ft0, fa1])
// [Asm] subst   slliw v49, v2, 3 ->   slliw a0, s0, 3
// [Asm] subst   add v50, v4, v49 ->   add a0, s1, a0
// [Asm] subst   ld v7, 0(v50) ->   ld a0, 0(a0)
// [Asm] subst   fld fv8, 0(v7) ->   fld fa1, 0(a0)
// [Asm] subst   fld fv9, 8(v7) ->   fld fa2, 8(a0)
// [Asm] subst   fld fv10, 16(v7) ->   fld fa3, 16(a0)
// [Asm] subst   fld fv11, 24(v7) ->   fld fa0, 24(a0)
// [Asm] subst   fld fv12, 32(v7) ->   fld fa4, 32(a0)
// [Asm] subst   fld fv13, 40(v7) ->   fld fa5, 40(a0)
// [Asm] subst   fld fv14, 48(v7) ->   fld fa6, 48(a0)
// [Asm] subst   fld fv15, 0(v3) ->   fld fa7, 0(s2)
// [Asm] subst   li v38, 4602678819172646912 ->   li a0, 4602678819172646912
// [Asm] subst   fmv.d.x fv39, v38 ->   fmv.d.x ft0, a0
// [Asm] subst   fmul.d fv16, fv39, fv14 ->   fmul.d ft0, ft0, fa6
// [Asm] subst   fmul.d fv17, fv11, fv11 ->   fmul.d fa0, fa0, fa0
// [Asm] subst   fmadd.d fv19, fv12, fv12, fv17 ->   fmadd.d fa0, fa4, fa4, fa0
// [Asm] subst   fmadd.d fv21, fv13, fv13, fv19 ->   fmadd.d fa0, fa5, fa5, fa0
// [Asm] subst   fmadd.d fv23, fv16, fv21, fv15 ->   fmadd.d fa0, ft0, fa0, fa7
// [Asm] subst   fsd fv23, 0(v3) ->   fsd fa0, 0(s2)
// [Asm] subst   addi v25, v2, 1 ->   addi a0, s0, 1
// [Asm] subst   mv a1, v3 ->   mv a1, s2
// [Asm] subst   fmv.d fa0, fv14 ->   fmv.d fa0, fa6
// [Asm] subst   mv a2, v4 ->   mv a2, s1
// [Asm] subst   call loop_j.630 ->   call loop_j.630
// [Asm] subst   addi v27, v2, 1 ->   addi a0, s0, 1
// [Asm] subst   mv a1, v3 ->   mv a1, s2
// [Asm] subst   mv a2, v4 ->   mv a2, s1
// [Asm] subst   call loop_i.629 ->   call loop_i.629
// [Asm] subst   mv v29, zero ->   mv a0, zero
// [Asm] subst   mv v2, a0 ->   mv s0, a0
// [Asm] subst   mv v3, a1 ->   mv s2, a1
// [Asm] subst   mv v4, a2 ->   mv s1, a2
// [Asm] subst   li v52, 4 ->   li a0, 4
// [Asm] subst   blt v52, v2, .loop_i.629_2 ->   blt a0, s0, .loop_i.629_2
// [Asm] subst   mv a0, zero ->   mv a0, zero
// [Asm] subst   ret ->   ret
// [Asm] subst   mv v29, zero ->   mv a0, zero
// [Asm] subst   j .loop_i.629_3 ->   j .loop_i.629_3
// [Asm] LoweringOrder: [0, 2, 1, 3]
// [Asm] LoweringOrder: [[1, 2], [3], [3], []]
// [Asm] LoweringOrder: HashMap::of([(b0, 0), (b1, 0), (b2, 1), (b3, 0)])
// [Asm] LoweringOrder: [b0, b1, b3, b2]
// [Asm] LoweringOrder: HashMap::of([(b0, 0), (b1, 1), (b2, 0), (b3, 2)])
// [Asm] pre_assigned_registers: FnParam(fref=f5, fpref=$f.2) -> v4, BlockParam(bref=b3, bpref=$b.0) -> v19, Insn(iref=%9) -> v15, Insn(iref=%8) -> fv14, Insn(iref=%10) -> v16, Insn(iref=%5) -> fv11, Insn(iref=%0) -> v5, Insn(iref=%4) -> fv10, Insn(iref=%3) -> fv9, Insn(iref=%13) -> v6, FnParam(fref=f5, fpref=$f.0) -> v2, Self(fref=f5) -> v0, Insn(iref=%7) -> fv13, Insn(iref=%2) -> fv8, Insn(iref=%1) -> v7, Insn(iref=%11) -> v17, Insn(iref=%6) -> fv12, FnParam(fref=f5, fpref=$f.1) -> fv3, Insn(iref=%12) -> v18
// [Asm] succs: []
// [Asm] critical edges for b3: []
// [Asm] critical color seq for b3: []
// [Asm] succs: [3]
// [Asm] critical edges for b1: []
// [Asm] critical color seq for b1: []
// [Asm] fuse raw offset and compute address
// [Asm] skipping ComputeAddress(ma=Offset(ty=Unit, val=Int64(val=0), offset=FnParam(fref=f5, fpref=$f.0), width=@64))
// [Asm] succs: [3]
// [Asm] critical edges for b2: []
// [Asm] critical color seq for b2: []
// [Asm] succs: [1, 2]
// [Asm] critical edges for b0: []
// [Asm] critical color seq for b0: []
// [Asm] skipping Op(ty=Bool, op=Le, args=[FnParam(fref=f5, fpref=$f.0), Int32(val=4)])
// [Asm] defs: []
// [Asm] live_set: [a1, zero, a0, fa0]
// [Asm] defs: [v2]
// [Asm] live_set: [fa0, a1, zero, v2]
// [Asm] move: v2 <- a0
// [Asm] defined: v2 is X
// [Asm] defs: [fv3]
// [Asm] live_set: [a1, fv3, zero, v2]
// [Asm] move: fv3 <- fa0
// [Asm] defined: fv3 is F
// [Asm] defs: [v4]
// [Asm] live_set: [v4, fv3, zero, v2]
// [Asm] move: v4 <- a1
// [Asm] defined: v4 is X
// [Asm] defs: [v34]
// [Asm] live_set: [v2, v4, fv3, zero, v34]
// [Asm] defined: v34 is X
// [Asm] defs: []
// [Asm] live_set: [v4, fv3, zero, v2]
// [Asm] defs: [v31]
// [Asm] live_set: [v31, zero, v4, fv3, v2]
// [Asm] defined: v31 is X
// [Asm] defs: [v32]
// [Asm] live_set: [v32, zero, v4, fv3, v2]
// [Asm] defined: v32 is X
// [Asm] defs: [v7]
// [Asm] live_set: [v7, zero, v4, fv3, v2]
// [Asm] defined: v7 is X
// [Asm] defs: [fv8]
// [Asm] live_set: [fv8, v7, zero, v4, fv3, v2]
// [Asm] defined: fv8 is F
// [Asm] defs: [fv9]
// [Asm] live_set: [fv8, v7, fv9, zero, v4, fv3, v2]
// [Asm] defined: fv9 is F
// [Asm] defs: [fv10]
// [Asm] live_set: [fv10, fv8, v7, fv9, zero, v4, fv3, v2]
// [Asm] defined: fv10 is F
// [Asm] defs: [fv11]
// [Asm] live_set: [fv10, fv8, v7, fv9, zero, fv11, v4, fv3, v2]
// [Asm] defined: fv11 is F
// [Asm] defs: [fv12]
// [Asm] live_set: [fv10, fv8, v7, fv12, fv9, zero, fv11, v4, fv3, v2]
// [Asm] defined: fv12 is F
// [Asm] defs: [fv13]
// [Asm] live_set: [fv10, fv8, v7, fv12, fv9, zero, fv11, fv13, v4, fv3, v2]
// [Asm] defined: fv13 is F
// [Asm] defs: [fv14]
// [Asm] live_set: [fv10, fv8, fv12, fv14, fv9, zero, fv11, fv13, v4, fv3, v2]
// [Asm] defined: fv14 is F
// [Asm] defs: [v15]
// [Asm] live_set: [fv10, fv8, fv12, fv14, fv9, zero, fv11, fv13, v4, v15, fv3, v2]
// [Asm] defined: v15 is X
// [Asm] defs: []
// [Asm] live_set: [fv10, fv8, fv12, fv14, fv9, zero, fv11, fv13, v4, v15, fv3, v2]
// [Asm] defs: [a0]
// [Asm] live_set: [fv10, a0, fv8, fv12, fv14, fv9, zero, fv11, fv13, v4, fv3, v2]
// [Asm] move: a0 <- v15
// [Asm] defined: a0 is X
// [Asm] defs: [fa0]
// [Asm] live_set: [fv10, a0, fv8, fv12, fv14, fv9, zero, fv11, fv13, fa0, v4, fv3, v2]
// [Asm] move: fa0 <- fv3
// [Asm] defined: fa0 is F
// [Asm] skip edge 0 -> 1
// [Asm] defs: [a1]
// [Asm] live_set: [fv10, a0, fv8, fv12, a1, fv14, fv9, zero, fv11, fv13, fa0, v4, fv3, v2]
// [Asm] move: a1 <- v2
// [Asm] defined: a1 is X
// [Asm] skip edge 2 -> 1
// [Asm] defs: [fa1]
// [Asm] live_set: [fv10, a0, fv8, fv12, a1, fa1, fv9, zero, fv11, fv13, fa0, v4, fv3, v2]
// [Asm] move: fa1 <- fv14
// [Asm] defined: fa1 is F
// [Asm] defs: [fa2]
// [Asm] live_set: [fv10, a0, fv12, a1, fa1, fv9, fa2, zero, fv11, fv13, fa0, v4, fv3, v2]
// [Asm] move: fa2 <- fv8
// [Asm] defined: fa2 is F
// [Asm] defs: [fa3]
// [Asm] live_set: [fv10, a0, fv12, a1, fa1, fa2, fa3, zero, fv11, fv13, fa0, v4, fv3, v2]
// [Asm] move: fa3 <- fv9
// [Asm] defined: fa3 is F
// [Asm] defs: [fa4]
// [Asm] live_set: [fa4, a0, fv12, a1, fa1, fa2, fa3, zero, fv11, fv13, fa0, v4, fv3, v2]
// [Asm] move: fa4 <- fv10
// [Asm] defined: fa4 is F
// [Asm] defs: [fa5]
// [Asm] live_set: [fa4, a0, fv12, a1, fa1, fa5, fa2, fa3, zero, fa0, fv13, v4, fv3, v2]
// [Asm] move: fa5 <- fv11
// [Asm] defined: fa5 is F
// [Asm] defs: [fa6]
// [Asm] live_set: [fa4, a0, a1, fa1, fa5, fa2, fa3, zero, fa6, fa0, fv13, v4, fv3, v2]
// [Asm] move: fa6 <- fv12
// [Asm] defined: fa6 is F
// [Asm] defs: [fa7]
// [Asm] live_set: [fa4, a0, a1, fa1, fa7, fa5, fa2, fa3, zero, fa6, fa0, v4, fv3, v2]
// [Asm] move: fa7 <- fv13
// [Asm] defined: fa7 is F
// [Asm] defs: [a2]
// [Asm] live_set: [fa4, a0, a2, a1, fa1, fa7, fa5, fa2, fa3, zero, fa6, fa0, v4, fv3, v2]
// [Asm] move: a2 <- v4
// [Asm] defined: a2 is X
// [Asm] skip edge 10 -> 4
// [Asm] defs: [t0, t1, t2, t3, t4, a0, a1, a2, a3, a4, a5, a6, a7, t0, t1, ft0, ft1, ft2, ft3, ft4, ft5, ft6, ft7, ft8, ft9, ft10, fa0, fa1, fa2, fa3, fa4, fa5, fa6, fa7]
// [Asm] live_set: [v2, v4, zero, fv3, a0]
// [Asm] defined: t0 is X
// [Asm] defined: t1 is X
// [Asm] defined: t2 is X
// [Asm] defined: t3 is X
// [Asm] defined: t4 is X
// [Asm] defined: a0 is X
// [Asm] defined: a1 is X
// [Asm] defined: a2 is X
// [Asm] defined: a3 is X
// [Asm] defined: a4 is X
// [Asm] defined: a5 is X
// [Asm] defined: a6 is X
// [Asm] defined: a7 is X
// [Asm] defined: t0 is X
// [Asm] defined: t1 is X
// [Asm] defined: ft0 is F
// [Asm] defined: ft1 is F
// [Asm] defined: ft2 is F
// [Asm] defined: ft3 is F
// [Asm] defined: ft4 is F
// [Asm] defined: ft5 is F
// [Asm] defined: ft6 is F
// [Asm] defined: ft7 is F
// [Asm] defined: ft8 is F
// [Asm] defined: ft9 is F
// [Asm] defined: ft10 is F
// [Asm] defined: fa0 is F
// [Asm] defined: fa1 is F
// [Asm] defined: fa2 is F
// [Asm] defined: fa3 is F
// [Asm] defined: fa4 is F
// [Asm] defined: fa5 is F
// [Asm] defined: fa6 is F
// [Asm] defined: fa7 is F
// [Asm] defs: [v16]
// [Asm] live_set: [v4, zero, fv3, v2]
// [Asm] move: v16 <- a0
// [Asm] defined: v16 is X
// [Asm] defs: []
// [Asm] live_set: [v4, zero, fv3, v2]
// [Asm] defs: [v17]
// [Asm] live_set: [v4, v17, zero, fv3]
// [Asm] defined: v17 is X
// [Asm] defs: []
// [Asm] live_set: [v4, v17, zero, fv3]
// [Asm] defs: [a0]
// [Asm] live_set: [v4, zero, a0, fv3]
// [Asm] move: a0 <- v17
// [Asm] defined: a0 is X
// [Asm] defs: [fa0]
// [Asm] live_set: [v4, zero, a0, fa0]
// [Asm] move: fa0 <- fv3
// [Asm] defined: fa0 is F
// [Asm] defs: [a1]
// [Asm] live_set: [a1, zero, a0, fa0]
// [Asm] move: a1 <- v4
// [Asm] defined: a1 is X
// [Asm] defs: [t0, t1, t2, t3, t4, a0, a1, a2, a3, a4, a5, a6, a7, t0, t1, ft0, ft1, ft2, ft3, ft4, ft5, ft6, ft7, ft8, ft9, ft10, fa0, fa1, fa2, fa3, fa4, fa5, fa6, fa7]
// [Asm] live_set: [zero, a0]
// [Asm] defined: t0 is X
// [Asm] defined: t1 is X
// [Asm] defined: t2 is X
// [Asm] defined: t3 is X
// [Asm] defined: t4 is X
// [Asm] defined: a0 is X
// [Asm] defined: a1 is X
// [Asm] defined: a2 is X
// [Asm] defined: a3 is X
// [Asm] defined: a4 is X
// [Asm] defined: a5 is X
// [Asm] defined: a6 is X
// [Asm] defined: a7 is X
// [Asm] defined: t0 is X
// [Asm] defined: t1 is X
// [Asm] defined: ft0 is F
// [Asm] defined: ft1 is F
// [Asm] defined: ft2 is F
// [Asm] defined: ft3 is F
// [Asm] defined: ft4 is F
// [Asm] defined: ft5 is F
// [Asm] defined: ft6 is F
// [Asm] defined: ft7 is F
// [Asm] defined: ft8 is F
// [Asm] defined: ft9 is F
// [Asm] defined: ft10 is F
// [Asm] defined: fa0 is F
// [Asm] defined: fa1 is F
// [Asm] defined: fa2 is F
// [Asm] defined: fa3 is F
// [Asm] defined: fa4 is F
// [Asm] defined: fa5 is F
// [Asm] defined: fa6 is F
// [Asm] defined: fa7 is F
// [Asm] defs: [v18]
// [Asm] live_set: [zero]
// [Asm] move: v18 <- a0
// [Asm] defined: v18 is X
// [Asm] defs: []
// [Asm] live_set: [zero]
// [Asm] defs: [v19]
// [Asm] live_set: [v19, zero]
// [Asm] move: v19 <- zero
// [Asm] defined: v19 is X
// [Asm] skip edge 24 -> 3
// [Asm] defs: [v19]
// [Asm] live_set: [v19, zero]
// [Asm] move: v19 <- zero
// [Asm] defined: v19 is X
// [Asm] skip edge 24 -> 3
// [Asm] defs: []
// [Asm] live_set: [v19, zero]
// [Asm] defs: [a0]
// [Asm] live_set: [a0]
// [Asm] move: a0 <- zero
// [Asm] defined: a0 is X
// [Asm] defs: []
// [Asm] live_set: [a0]
// [Asm] defs: []
// [Asm] live_set: []
// [Asm] Label("loop_i.634") clobbered_x: @hashset.of([s0, a0, s1])
// [Asm] Label("loop_i.634") clobbered_f: @hashset.of([fa7, fa5, fa2, fa3, fs0, fa4, fa6, fa1])
// [Asm] subst   mv v2, a0 ->   mv s0, a0
// [Asm] subst   fmv.d fv3, fa0 ->   fmv.d fs0, fa0
// [Asm] subst   mv v4, a1 ->   mv s1, a1
// [Asm] subst   li v34, 4 ->   li a0, 4
// [Asm] subst   blt v34, v2, .loop_i.634_2 ->   blt a0, s0, .loop_i.634_2
// [Asm] subst   slliw v31, v2, 3 ->   slliw a0, s0, 3
// [Asm] subst   add v32, v4, v31 ->   add a0, s1, a0
// [Asm] subst   ld v7, 0(v32) ->   ld a0, 0(a0)
// [Asm] subst   fld fv8, 0(v7) ->   fld fa2, 0(a0)
// [Asm] subst   fld fv9, 8(v7) ->   fld fa3, 8(a0)
// [Asm] subst   fld fv10, 16(v7) ->   fld fa4, 16(a0)
// [Asm] subst   fld fv11, 24(v7) ->   fld fa5, 24(a0)
// [Asm] subst   fld fv12, 32(v7) ->   fld fa6, 32(a0)
// [Asm] subst   fld fv13, 40(v7) ->   fld fa7, 40(a0)
// [Asm] subst   fld fv14, 48(v7) ->   fld fa1, 48(a0)
// [Asm] subst   addi v15, v2, 1 ->   addi a0, s0, 1
// [Asm] subst   fmv.d fa0, fv3 ->   fmv.d fa0, fs0
// [Asm] subst   mv a1, v2 ->   mv a1, s0
// [Asm] subst   mv a2, v4 ->   mv a2, s1
// [Asm] subst   call loop_j.635 ->   call loop_j.635
// [Asm] subst   addi v17, v2, 1 ->   addi a0, s0, 1
// [Asm] subst   fmv.d fa0, fv3 ->   fmv.d fa0, fs0
// [Asm] subst   mv a1, v4 ->   mv a1, s1
// [Asm] subst   call loop_i.634 ->   call loop_i.634
// [Asm] subst   mv v19, zero ->   mv a0, zero
// [Asm] subst   mv v19, zero ->   mv a0, zero
// [Asm] subst   j .loop_i.634_3 ->   j .loop_i.634_3
// [Asm] subst   mv a0, zero ->   mv a0, zero
// [Asm] subst   ret ->   ret
// [Asm] LoweringOrder: [0]
// [Asm] LoweringOrder: [[]]
// [Asm] LoweringOrder: HashMap::of([(b0, 0)])
// [Asm] LoweringOrder: [b0]
// [Asm] LoweringOrder: HashMap::of([(b0, 0)])
// [Asm] pre_assigned_registers: Self(fref=f2) -> v0, Insn(iref=%1) -> v5, Mem(fref=f2, mref=m0) -> v3, FnParam(fref=f2, fpref=$f.0) -> v2, Insn(iref=%0) -> v4, Insn(iref=%2) -> fv6
// [Asm] succs: []
// [Asm] critical edges for b0: []
// [Asm] critical color seq for b0: []
// [Asm] defs: []
// [Asm] live_set: [s11, zero, a0]
// [Asm] defs: [v2]
// [Asm] live_set: [s11, zero, v2]
// [Asm] move: v2 <- a0
// [Asm] defined: v2 is X
// [Asm] defs: [v3]
// [Asm] live_set: [v2, zero, v3]
// [Asm] defined: v3 is X
// [Asm] defs: [s11]
// [Asm] live_set: [v2, zero, v3]
// [Asm] defined: s11 is X
// [Asm] defs: []
// [Asm] live_set: [v2, zero, v3]
// [Asm] defs: [a0]
// [Asm] live_set: [v2, a0, v3]
// [Asm] move: a0 <- zero
// [Asm] defined: a0 is X
// [Asm] defs: [a1]
// [Asm] live_set: [v2, a1, a0, v3]
// [Asm] move: a1 <- v3
// [Asm] defined: a1 is X
// [Asm] skip edge 5 -> 4
// [Asm] defs: [a2]
// [Asm] live_set: [a2, a1, a0, v3]
// [Asm] move: a2 <- v2
// [Asm] defined: a2 is X
// [Asm] defs: [t0, t1, t2, t3, t4, a0, a1, a2, a3, a4, a5, a6, a7, t0, t1, ft0, ft1, ft2, ft3, ft4, ft5, ft6, ft7, ft8, ft9, ft10, fa0, fa1, fa2, fa3, fa4, fa5, fa6, fa7]
// [Asm] live_set: [a0, v3]
// [Asm] defined: t0 is X
// [Asm] defined: t1 is X
// [Asm] defined: t2 is X
// [Asm] defined: t3 is X
// [Asm] defined: t4 is X
// [Asm] defined: a0 is X
// [Asm] defined: a1 is X
// [Asm] defined: a2 is X
// [Asm] defined: a3 is X
// [Asm] defined: a4 is X
// [Asm] defined: a5 is X
// [Asm] defined: a6 is X
// [Asm] defined: a7 is X
// [Asm] defined: t0 is X
// [Asm] defined: t1 is X
// [Asm] defined: ft0 is F
// [Asm] defined: ft1 is F
// [Asm] defined: ft2 is F
// [Asm] defined: ft3 is F
// [Asm] defined: ft4 is F
// [Asm] defined: ft5 is F
// [Asm] defined: ft6 is F
// [Asm] defined: ft7 is F
// [Asm] defined: ft8 is F
// [Asm] defined: ft9 is F
// [Asm] defined: ft10 is F
// [Asm] defined: fa0 is F
// [Asm] defined: fa1 is F
// [Asm] defined: fa2 is F
// [Asm] defined: fa3 is F
// [Asm] defined: fa4 is F
// [Asm] defined: fa5 is F
// [Asm] defined: fa6 is F
// [Asm] defined: fa7 is F
// [Asm] defs: [v5]
// [Asm] live_set: [v3]
// [Asm] move: v5 <- a0
// [Asm] defined: v5 is X
// [Asm] defs: []
// [Asm] live_set: [v3]
// [Asm] defs: [fv6]
// [Asm] live_set: [fv6]
// [Asm] defined: fv6 is F
// [Asm] defs: [fa0]
// [Asm] live_set: [fa0]
// [Asm] move: fa0 <- fv6
// [Asm] defined: fa0 is F
// [Asm] defs: []
// [Asm] live_set: [fa0]
// [Asm] defs: []
// [Asm] live_set: []
// [Asm] Label("energy.628") clobbered_x: @hashset.of([a2, s0, a0])
// [Asm] Label("energy.628") clobbered_f: @hashset.of([fa0])
// [Asm] subst   mv v2, a0 ->   mv a2, a0
// [Asm] subst   addi v3, s11, -8 ->   addi s0, s11, -8
// [Asm] subst   andi s11, v3, -8 ->   andi s11, s0, -8
// [Asm] subst   mv a0, zero ->   mv a0, zero
// [Asm] subst   mv a1, v3 ->   mv a1, s0
// [Asm] subst   call loop_i.629 ->   call loop_i.629
// [Asm] subst   fld fv6, 0(v3) ->   fld fa0, 0(s0)
// [Asm] subst   ret ->   ret
// [Asm] LoweringOrder: [0]
// [Asm] LoweringOrder: [[]]
// [Asm] LoweringOrder: HashMap::of([(b0, 0)])
// [Asm] LoweringOrder: [b0]
// [Asm] LoweringOrder: HashMap::of([(b0, 0)])
// [Asm] pre_assigned_registers: Self(fref=f18) -> v0, Insn(iref=%0) -> v2
// [Asm] LoweringOrder: [0, 2, 1, 3]
// [Asm] LoweringOrder: [[1, 2], [3], [3], []]
// [Asm] LoweringOrder: HashMap::of([(b0, 0), (b1, 0), (b2, 1), (b3, 0)])
// [Asm] LoweringOrder: [b0, b1, b3, b2]
// [Asm] LoweringOrder: HashMap::of([(b0, 0), (b1, 1), (b2, 0), (b3, 2)])
// [Asm] pre_assigned_registers: FnParam(fref=f3, fpref=$f.2) -> v4, Insn(iref=%15) -> fv23, FnParam(fref=f3, fpref=$f.4) -> v6, BlockParam(bref=b3, bpref=$b.0) -> v31, Insn(iref=%9) -> fv17, Insn(iref=%16) -> v24, Insn(iref=%8) -> fv16, Insn(iref=%10) -> fv18, FnParam(fref=f3, fpref=$f.3) -> v5, Insn(iref=%14) -> fv22, FnParam(fref=f3, fpref=$f.0) -> v2, Insn(iref=%5) -> fv13, Self(fref=f3) -> v0, Insn(iref=%0) -> v7, Insn(iref=%19) -> fv27, Insn(iref=%4) -> fv12, Insn(iref=%3) -> fv11, Insn(iref=%18) -> fv26, Insn(iref=%13) -> fv21, Insn(iref=%7) -> fv15, Insn(iref=%22) -> v30, Insn(iref=%23) -> v8, Insn(iref=%17) -> fv25, FnParam(fref=f3, fpref=$f.1) -> v3, Insn(iref=%2) -> fv10, Insn(iref=%1) -> v9, Insn(iref=%20) -> v28, Insn(iref=%11) -> fv19, Insn(iref=%21) -> v29, Insn(iref=%6) -> fv14, Insn(iref=%12) -> v20
// [Asm] succs: []
// [Asm] critical edges for b3: []
// [Asm] critical color seq for b3: []
// [Asm] succs: [3]
// [Asm] critical edges for b1: []
// [Asm] critical color seq for b1: []
// [Asm] skipping Op(ty=Double, op=Mul, args=[Insn(iref=%7), Insn(iref=%8)])
// [Asm] skipping Op(ty=Double, op=Mul, args=[Insn(iref=%6), Insn(iref=%8)])
// [Asm] skipping Op(ty=Double, op=Mul, args=[Insn(iref=%5), Insn(iref=%8)])
// [Asm] skipping Load(ty=Double, ma=Field(ty=Double, val=Insn(iref=%1), index=2, width=@(@64, @(@64, @(@64, @(@64, @(@64, @(@64, @(@64, @32)))))))))
// [Asm] skipping Load(ty=Double, ma=Field(ty=Double, val=Insn(iref=%1), index=1, width=@(@64, @(@64, @(@64, @(@64, @(@64, @(@64, @(@64, @32)))))))))
// [Asm] skipping Load(ty=Double, ma=Field(ty=Double, val=Insn(iref=%1), index=0, width=@(@64, @(@64, @(@64, @(@64, @(@64, @(@64, @(@64, @32)))))))))
// [Asm] fuse raw offset and compute address
// [Asm] skipping ComputeAddress(ma=Offset(ty=Unit, val=Int64(val=0), offset=FnParam(fref=f3, fpref=$f.0), width=@64))
// [Asm] succs: [3]
// [Asm] critical edges for b2: []
// [Asm] critical color seq for b2: []
// [Asm] succs: [1, 2]
// [Asm] critical edges for b0: []
// [Asm] critical color seq for b0: []
// [Asm] skipping Op(ty=Bool, op=Le, args=[FnParam(fref=f3, fpref=$f.0), Int32(val=4)])
// [Asm] defs: [a0]
// [Asm] live_set: [a0]
// [Asm] move: a0 <- zero
// [Asm] defined: a0 is X
// [Asm] defs: []
// [Asm] live_set: [a0]
// [Asm] defs: []
// [Asm] live_set: []
// [Asm] defs: []
// [Asm] live_set: [zero, a0, a4, a2, a1, a3]
// [Asm] defs: [v2]
// [Asm] live_set: [zero, a4, a2, a1, a3, v2]
// [Asm] move: v2 <- a0
// [Asm] defined: v2 is X
// [Asm] defs: [v3]
// [Asm] live_set: [v3, zero, a4, a2, a3, v2]
// [Asm] move: v3 <- a1
// [Asm] defined: v3 is X
// [Asm] defs: [v4]
// [Asm] live_set: [v3, zero, a4, v4, a3, v2]
// [Asm] move: v4 <- a2
// [Asm] defined: v4 is X
// [Asm] defs: [v5]
// [Asm] live_set: [v3, v5, zero, a4, v4, v2]
// [Asm] move: v5 <- a3
// [Asm] defined: v5 is X
// [Asm] defs: [v6]
// [Asm] live_set: [v3, v5, zero, v4, v6, v2]
// [Asm] move: v6 <- a4
// [Asm] defined: v6 is X
// [Asm] defs: [v47]
// [Asm] live_set: [v3, v5, zero, v4, v47, v6, v2]
// [Asm] defined: v47 is X
// [Asm] defs: []
// [Asm] live_set: [v2, v4, v5, v6, zero, v3]
// [Asm] defs: [v31]
// [Asm] live_set: [v31, zero]
// [Asm] move: v31 <- zero
// [Asm] defined: v31 is X
// [Asm] skip edge 12 -> 0
// [Asm] defs: []
// [Asm] live_set: [v31, zero]
// [Asm] defs: [v44]
// [Asm] live_set: [v3, v5, zero, v4, v6, v44, v2]
// [Asm] defined: v44 is X
// [Asm] defs: [v45]
// [Asm] live_set: [v3, v5, zero, v45, v4, v6, v2]
// [Asm] defined: v45 is X
// [Asm] defs: [v9]
// [Asm] live_set: [v3, v5, zero, v4, v6, v9, v2]
// [Asm] defined: v9 is X
// [Asm] defs: [fv13]
// [Asm] live_set: [v3, v5, zero, fv13, v4, v6, v9, v2]
// [Asm] defined: fv13 is F
// [Asm] defs: [fv14]
// [Asm] live_set: [v3, v5, zero, fv13, v4, v6, fv14, v9, v2]
// [Asm] defined: fv14 is F
// [Asm] defs: [fv15]
// [Asm] live_set: [v3, v5, zero, fv13, v4, v6, fv14, fv15, v9, v2]
// [Asm] defined: fv15 is F
// [Asm] defs: [fv16]
// [Asm] live_set: [v3, v5, zero, fv13, v4, v6, fv14, fv15, fv16, v2]
// [Asm] defined: fv16 is F
// [Asm] defs: [fv17]
// [Asm] live_set: [v3, v5, zero, fv13, v4, v6, fv14, fv15, fv16, fv17, v2]
// [Asm] defined: fv17 is F
// [Asm] defs: [fv19]
// [Asm] live_set: [v3, v5, zero, fv19, v4, v6, fv14, fv15, fv16, v2]
// [Asm] defined: fv19 is F
// [Asm] defs: []
// [Asm] live_set: [v3, v5, zero, v4, v6, fv14, fv15, fv16, v2]
// [Asm] defs: [fv21]
// [Asm] live_set: [v3, v5, zero, v4, v6, fv14, fv15, fv16, fv21, v2]
// [Asm] defined: fv21 is F
// [Asm] defs: [fv23]
// [Asm] live_set: [v3, fv23, v5, zero, v4, v6, fv15, fv16, v2]
// [Asm] defined: fv23 is F
// [Asm] defs: []
// [Asm] live_set: [v3, v5, zero, v4, v6, fv15, fv16, v2]
// [Asm] defs: [fv25]
// [Asm] live_set: [v3, v5, zero, fv25, v4, v6, fv15, fv16, v2]
// [Asm] defined: fv25 is F
// [Asm] defs: [fv27]
// [Asm] live_set: [v3, v5, zero, v4, v6, fv27, v2]
// [Asm] defined: fv27 is F
// [Asm] defs: []
// [Asm] live_set: [v2, v4, v6, v5, zero, v3]
// [Asm] defs: [v29]
// [Asm] live_set: [v4, v6, v5, zero, v29, v3]
// [Asm] defined: v29 is X
// [Asm] defs: []
// [Asm] live_set: [v4, v6, v5, zero, v29, v3]
// [Asm] defs: [a0]
// [Asm] live_set: [v4, v6, v5, zero, a0, v3]
// [Asm] move: a0 <- v29
// [Asm] defined: a0 is X
// [Asm] defs: [a1]
// [Asm] live_set: [v4, a1, v6, v5, zero, a0]
// [Asm] move: a1 <- v3
// [Asm] defined: a1 is X
// [Asm] defs: [a2]
// [Asm] live_set: [a2, a1, v6, v5, zero, a0]
// [Asm] move: a2 <- v4
// [Asm] defined: a2 is X
// [Asm] defs: [a3]
// [Asm] live_set: [a2, a1, v6, a3, zero, a0]
// [Asm] move: a3 <- v5
// [Asm] defined: a3 is X
// [Asm] defs: [a4]
// [Asm] live_set: [a2, a1, a3, zero, a0, a4]
// [Asm] move: a4 <- v6
// [Asm] defined: a4 is X
// [Asm] defs: [t0, t1, t2, t3, t4, a0, a1, a2, a3, a4, a5, a6, a7, t0, t1, ft0, ft1, ft2, ft3, ft4, ft5, ft6, ft7, ft8, ft9, ft10, fa0, fa1, fa2, fa3, fa4, fa5, fa6, fa7]
// [Asm] live_set: [zero, a0]
// [Asm] defined: t0 is X
// [Asm] defined: t1 is X
// [Asm] defined: t2 is X
// [Asm] defined: t3 is X
// [Asm] defined: t4 is X
// [Asm] defined: a0 is X
// [Asm] defined: a1 is X
// [Asm] defined: a2 is X
// [Asm] defined: a3 is X
// [Asm] defined: a4 is X
// [Asm] defined: a5 is X
// [Asm] defined: a6 is X
// [Asm] defined: a7 is X
// [Asm] defined: t0 is X
// [Asm] defined: t1 is X
// [Asm] defined: ft0 is F
// [Asm] defined: ft1 is F
// [Asm] defined: ft2 is F
// [Asm] defined: ft3 is F
// [Asm] defined: ft4 is F
// [Asm] defined: ft5 is F
// [Asm] defined: ft6 is F
// [Asm] defined: ft7 is F
// [Asm] defined: ft8 is F
// [Asm] defined: ft9 is F
// [Asm] defined: ft10 is F
// [Asm] defined: fa0 is F
// [Asm] defined: fa1 is F
// [Asm] defined: fa2 is F
// [Asm] defined: fa3 is F
// [Asm] defined: fa4 is F
// [Asm] defined: fa5 is F
// [Asm] defined: fa6 is F
// [Asm] defined: fa7 is F
// [Asm] defs: [v30]
// [Asm] live_set: [zero]
// [Asm] move: v30 <- a0
// [Asm] defined: v30 is X
// [Asm] defs: []
// [Asm] live_set: [zero]
// [Asm] defs: [v31]
// [Asm] live_set: [v31, zero]
// [Asm] move: v31 <- zero
// [Asm] defined: v31 is X
// [Asm] skip edge 12 -> 0
// [Asm] Label("loop_i.632") clobbered_x: @hashset.of([a2, a1, a3, a5, a0, a4])
// [Asm] Label("loop_i.632") clobbered_f: @hashset.of([fa0, fa3, fa2, fa1, fa4])
// [Asm] subst   slliw v44, v2, 3 ->   slliw a5, a0, 3
// [Asm] subst   add v45, v6, v44 ->   add a5, a4, a5
// [Asm] subst   ld v9, 0(v45) ->   ld a5, 0(a5)
// [Asm] subst   fld fv13, 24(v9) ->   fld fa0, 24(a5)
// [Asm] subst   fld fv14, 32(v9) ->   fld fa1, 32(a5)
// [Asm] subst   fld fv15, 40(v9) ->   fld fa2, 40(a5)
// [Asm] subst   fld fv16, 48(v9) ->   fld fa3, 48(a5)
// [Asm] subst   fld fv17, 0(v3) ->   fld fa4, 0(a1)
// [Asm] subst   fmadd.d fv19, fv13, fv16, fv17 ->   fmadd.d fa0, fa0, fa3, fa4
// [Asm] subst   fsd fv19, 0(v3) ->   fsd fa0, 0(a1)
// [Asm] subst   fld fv21, 0(v4) ->   fld fa0, 0(a2)
// [Asm] subst   fmadd.d fv23, fv14, fv16, fv21 ->   fmadd.d fa0, fa1, fa3, fa0
// [Asm] subst   fsd fv23, 0(v4) ->   fsd fa0, 0(a2)
// [Asm] subst   fld fv25, 0(v5) ->   fld fa0, 0(a3)
// [Asm] subst   fmadd.d fv27, fv15, fv16, fv25 ->   fmadd.d fa0, fa2, fa3, fa0
// [Asm] subst   fsd fv27, 0(v5) ->   fsd fa0, 0(a3)
// [Asm] subst   addi v29, v2, 1 ->   addi a0, a0, 1
// [Asm] subst   call loop_i.632 ->   call loop_i.632
// [Asm] subst   mv v31, zero ->   mv a0, zero
// [Asm] subst   li v47, 4 ->   li a5, 4
// [Asm] subst   blt v47, v2, .loop_i.632_2 ->   blt a5, a0, .loop_i.632_2
// [Asm] subst   mv v31, zero ->   mv a0, zero
// [Asm] subst   j .loop_i.632_3 ->   j .loop_i.632_3
// [Asm] subst   mv a0, zero ->   mv a0, zero
// [Asm] subst   ret ->   ret
// [Asm] LoweringOrder: [0, 2, 1, 3]
// [Asm] LoweringOrder: [[1, 2], [3], [3], []]
// [Asm] LoweringOrder: HashMap::of([(b0, 0), (b1, 0), (b2, 1), (b3, 0)])
// [Asm] LoweringOrder: [b0, b1, b3, b2]
// [Asm] LoweringOrder: HashMap::of([(b0, 0), (b1, 1), (b2, 0), (b3, 2)])
// [Asm] pre_assigned_registers: Insn(iref=%3) -> v8, FnParam(fref=f7, fpref=$f.1) -> v3, FnParam(fref=f7, fpref=$f.2) -> v4, Self(fref=f7) -> v0, FnParam(fref=f7, fpref=$f.0) -> v2, BlockParam(bref=b3, bpref=$b.0) -> v10, Insn(iref=%2) -> v7, Insn(iref=%1) -> v6, Insn(iref=%0) -> v5, Insn(iref=%4) -> v9
// [Asm] succs: []
// [Asm] critical edges for b3: []
// [Asm] critical color seq for b3: []
// [Asm] succs: [3]
// [Asm] critical edges for b1: []
// [Asm] critical color seq for b1: []
// [Asm] succs: [3]
// [Asm] critical edges for b2: []
// [Asm] critical color seq for b2: []
// [Asm] succs: [1, 2]
// [Asm] critical edges for b0: []
// [Asm] critical color seq for b0: []
// [Asm] skipping Op(ty=Bool, op=Le, args=[FnParam(fref=f7, fpref=$f.0), FnParam(fref=f7, fpref=$f.1)])
// [Asm] defs: []
// [Asm] live_set: [v3, zero, v4, v2]
// [Asm] defs: [a0]
// [Asm] live_set: [v3, zero, a0, v4, v2]
// [Asm] move: a0 <- zero
// [Asm] defined: a0 is X
// [Asm] skip edge 1 -> 0
// [Asm] defs: [v16]
// [Asm] live_set: [v3, v16, zero, a0, v4, v2]
// [Asm] defined: v16 is X
// [Asm] defs: [fv17]
// [Asm] live_set: [v3, zero, a0, v4, fv17, v2]
// [Asm] defined: fv17 is F
// [Asm] defs: [fa0]
// [Asm] live_set: [v3, zero, a0, fa0, v4, v2]
// [Asm] move: fa0 <- fv17
// [Asm] defined: fa0 is F
// [Asm] defs: [a1]
// [Asm] live_set: [v3, zero, a0, fa0, v4, a1, v2]
// [Asm] move: a1 <- v4
// [Asm] defined: a1 is X
// [Asm] skip edge 6 -> 3
// [Asm] defs: [t0, t1, t2, t3, t4, a0, a1, a2, a3, a4, a5, a6, a7, t0, t1, ft0, ft1, ft2, ft3, ft4, ft5, ft6, ft7, ft8, ft9, ft10, fa0, fa1, fa2, fa3, fa4, fa5, fa6, fa7]
// [Asm] live_set: [v3, zero, a0, v4, v2]
// [Asm] defined: t0 is X
// [Asm] defined: t1 is X
// [Asm] defined: t2 is X
// [Asm] defined: t3 is X
// [Asm] defined: t4 is X
// [Asm] defined: a0 is X
// [Asm] defined: a1 is X
// [Asm] defined: a2 is X
// [Asm] defined: a3 is X
// [Asm] defined: a4 is X
// [Asm] defined: a5 is X
// [Asm] defined: a6 is X
// [Asm] defined: a7 is X
// [Asm] defined: t0 is X
// [Asm] defined: t1 is X
// [Asm] defined: ft0 is F
// [Asm] defined: ft1 is F
// [Asm] defined: ft2 is F
// [Asm] defined: ft3 is F
// [Asm] defined: ft4 is F
// [Asm] defined: ft5 is F
// [Asm] defined: ft6 is F
// [Asm] defined: ft7 is F
// [Asm] defined: ft8 is F
// [Asm] defined: ft9 is F
// [Asm] defined: ft10 is F
// [Asm] defined: fa0 is F
// [Asm] defined: fa1 is F
// [Asm] defined: fa2 is F
// [Asm] defined: fa3 is F
// [Asm] defined: fa4 is F
// [Asm] defined: fa5 is F
// [Asm] defined: fa6 is F
// [Asm] defined: fa7 is F
// [Asm] defs: [v6]
// [Asm] live_set: [v3, zero, v4, v2]
// [Asm] move: v6 <- a0
// [Asm] defined: v6 is X
// [Asm] defs: []
// [Asm] live_set: [v3, zero, v4, v2]
// [Asm] defs: []
// [Asm] live_set: [v3, zero, v4, v2]
// [Asm] defs: [a0]
// [Asm] live_set: [v3, zero, a0, v4, v2]
// [Asm] move: a0 <- zero
// [Asm] defined: a0 is X
// [Asm] skip edge 1 -> 0
// [Asm] defs: [v13]
// [Asm] live_set: [v3, zero, a0, v13, v4, v2]
// [Asm] defined: v13 is X
// [Asm] defs: [fv14]
// [Asm] live_set: [v3, zero, a0, v4, fv14, v2]
// [Asm] defined: fv14 is F
// [Asm] defs: [fa0]
// [Asm] live_set: [v3, zero, a0, fa0, v4, v2]
// [Asm] move: fa0 <- fv14
// [Asm] defined: fa0 is F
// [Asm] defs: [a1]
// [Asm] live_set: [v3, zero, a0, fa0, v4, a1, v2]
// [Asm] move: a1 <- v4
// [Asm] defined: a1 is X
// [Asm] skip edge 6 -> 3
// [Asm] defs: [t0, t1, t2, t3, t4, a0, a1, a2, a3, a4, a5, a6, a7, t0, t1, ft0, ft1, ft2, ft3, ft4, ft5, ft6, ft7, ft8, ft9, ft10, fa0, fa1, fa2, fa3, fa4, fa5, fa6, fa7]
// [Asm] live_set: [v2, v4, zero, a0, v3]
// [Asm] defined: t0 is X
// [Asm] defined: t1 is X
// [Asm] defined: t2 is X
// [Asm] defined: t3 is X
// [Asm] defined: t4 is X
// [Asm] defined: a0 is X
// [Asm] defined: a1 is X
// [Asm] defined: a2 is X
// [Asm] defined: a3 is X
// [Asm] defined: a4 is X
// [Asm] defined: a5 is X
// [Asm] defined: a6 is X
// [Asm] defined: a7 is X
// [Asm] defined: t0 is X
// [Asm] defined: t1 is X
// [Asm] defined: ft0 is F
// [Asm] defined: ft1 is F
// [Asm] defined: ft2 is F
// [Asm] defined: ft3 is F
// [Asm] defined: ft4 is F
// [Asm] defined: ft5 is F
// [Asm] defined: ft6 is F
// [Asm] defined: ft7 is F
// [Asm] defined: ft8 is F
// [Asm] defined: ft9 is F
// [Asm] defined: ft10 is F
// [Asm] defined: fa0 is F
// [Asm] defined: fa1 is F
// [Asm] defined: fa2 is F
// [Asm] defined: fa3 is F
// [Asm] defined: fa4 is F
// [Asm] defined: fa5 is F
// [Asm] defined: fa6 is F
// [Asm] defined: fa7 is F
// [Asm] defs: [v7]
// [Asm] live_set: [v2, v4, zero, v3]
// [Asm] move: v7 <- a0
// [Asm] defined: v7 is X
// [Asm] defs: []
// [Asm] live_set: [v2, v4, zero, v3]
// [Asm] defs: [v8]
// [Asm] live_set: [v8, v4, zero, v3]
// [Asm] defined: v8 is X
// [Asm] defs: []
// [Asm] live_set: [v8, v4, zero, v3]
// [Asm] defs: [a0]
// [Asm] live_set: [v4, zero, a0, v3]
// [Asm] move: a0 <- v8
// [Asm] defined: a0 is X
// [Asm] defs: [a1]
// [Asm] live_set: [v4, a1, zero, a0]
// [Asm] move: a1 <- v3
// [Asm] defined: a1 is X
// [Asm] defs: [a2]
// [Asm] live_set: [a2, a1, zero, a0]
// [Asm] move: a2 <- v4
// [Asm] defined: a2 is X
// [Asm] defs: [t0, t1, t2, t3, t4, a0, a1, a2, a3, a4, a5, a6, a7, t0, t1, ft0, ft1, ft2, ft3, ft4, ft5, ft6, ft7, ft8, ft9, ft10, fa0, fa1, fa2, fa3, fa4, fa5, fa6, fa7]
// [Asm] live_set: [zero, a0]
// [Asm] defined: t0 is X
// [Asm] defined: t1 is X
// [Asm] defined: t2 is X
// [Asm] defined: t3 is X
// [Asm] defined: t4 is X
// [Asm] defined: a0 is X
// [Asm] defined: a1 is X
// [Asm] defined: a2 is X
// [Asm] defined: a3 is X
// [Asm] defined: a4 is X
// [Asm] defined: a5 is X
// [Asm] defined: a6 is X
// [Asm] defined: a7 is X
// [Asm] defined: t0 is X
// [Asm] defined: t1 is X
// [Asm] defined: ft0 is F
// [Asm] defined: ft1 is F
// [Asm] defined: ft2 is F
// [Asm] defined: ft3 is F
// [Asm] defined: ft4 is F
// [Asm] defined: ft5 is F
// [Asm] defined: ft6 is F
// [Asm] defined: ft7 is F
// [Asm] defined: ft8 is F
// [Asm] defined: ft9 is F
// [Asm] defined: ft10 is F
// [Asm] defined: fa0 is F
// [Asm] defined: fa1 is F
// [Asm] defined: fa2 is F
// [Asm] defined: fa3 is F
// [Asm] defined: fa4 is F
// [Asm] defined: fa5 is F
// [Asm] defined: fa6 is F
// [Asm] defined: fa7 is F
// [Asm] defs: [v9]
// [Asm] live_set: [zero]
// [Asm] move: v9 <- a0
// [Asm] defined: v9 is X
// [Asm] defs: []
// [Asm] live_set: [zero]
// [Asm] defs: [v10]
// [Asm] live_set: [v10, zero]
// [Asm] move: v10 <- zero
// [Asm] defined: v10 is X
// [Asm] skip edge 23 -> 0
// [Asm] defs: [a0]
// [Asm] live_set: [a0]
// [Asm] move: a0 <- zero
// [Asm] defined: a0 is X
// [Asm] defs: []
// [Asm] live_set: [a0]
// [Asm] defs: []
// [Asm] live_set: []
// [Asm] defs: []
// [Asm] live_set: [a2, a1, zero, a0]
// [Asm] defs: [v2]
// [Asm] live_set: [a2, a1, zero, v2]
// [Asm] move: v2 <- a0
// [Asm] defined: v2 is X
// [Asm] defs: [v3]
// [Asm] live_set: [v3, a2, zero, v2]
// [Asm] move: v3 <- a1
// [Asm] defined: v3 is X
// [Asm] defs: [v4]
// [Asm] live_set: [v3, v4, zero, v2]
// [Asm] move: v4 <- a2
// [Asm] defined: v4 is X
// [Asm] defs: []
// [Asm] live_set: [v3, v4, zero, v2]
// [Asm] defs: [v10]
// [Asm] live_set: [v10, zero]
// [Asm] move: v10 <- zero
// [Asm] defined: v10 is X
// [Asm] skip edge 23 -> 0
// [Asm] defs: []
// [Asm] live_set: [v10, zero]
// [Asm] Label("loop_i.633") clobbered_x: @hashset.of([s2, s0, a1, a0, s1])
// [Asm] Label("loop_i.633") clobbered_f: @hashset.of([fa0])
// [Asm] subst   mv a0, zero ->   mv a0, zero
// [Asm] subst   li v16, 4576918229304087675 ->   li a1, 4576918229304087675
// [Asm] subst   fmv.d.x fv17, v16 ->   fmv.d.x fa0, a1
// [Asm] subst   mv a1, v4 ->   mv a1, s1
// [Asm] subst   call loop_i.634 ->   call loop_i.634
// [Asm] subst   mv a0, zero ->   mv a0, zero
// [Asm] subst   li v13, 4576918229304087675 ->   li a1, 4576918229304087675
// [Asm] subst   fmv.d.x fv14, v13 ->   fmv.d.x fa0, a1
// [Asm] subst   mv a1, v4 ->   mv a1, s1
// [Asm] subst   call update_axis.636 ->   call update_axis.636
// [Asm] subst   addi v8, v2, 1 ->   addi a0, s2, 1
// [Asm] subst   mv a1, v3 ->   mv a1, s0
// [Asm] subst   mv a2, v4 ->   mv a2, s1
// [Asm] subst   call loop_i.633 ->   call loop_i.633
// [Asm] subst   mv v10, zero ->   mv a0, zero
// [Asm] subst   mv a0, zero ->   mv a0, zero
// [Asm] subst   ret ->   ret
// [Asm] subst   mv v2, a0 ->   mv s2, a0
// [Asm] subst   mv v3, a1 ->   mv s0, a1
// [Asm] subst   mv v4, a2 ->   mv s1, a2
// [Asm] subst   blt v3, v2, .loop_i.633_2 ->   blt s0, s2, .loop_i.633_2
// [Asm] subst   mv v10, zero ->   mv a0, zero
// [Asm] subst   j .loop_i.633_3 ->   j .loop_i.633_3
// [Asm] before colored: # leaf false
// [Asm] loop_i.634:
// [Asm] # block info: defs: [v4, fv3, v34, v2], uses: [v2, a1, a0, v34, fa0], upward_exposed: [a1, a0, fa0], params_defs: []
// [Asm] # live_in: [a1, a0, zero, fa0], live_out: [v4, fv3, zero, v2]
// [Asm] # block parameters: []
// [Asm] .loop_i.634_0:
// [Asm]   # save_ctx1  # live: [a1, zero, a0, fa0]
// [Asm]   mv v2, a0  # live: [fa0, a1, zero, v2]
// [Asm]   fmv.d fv3, fa0  # live: [a1, fv3, zero, v2]
// [Asm]   mv v4, a1  # live: [v4, fv3, zero, v2]
// [Asm] # control
// [Asm]   li v34, 4  # live: [v2, v4, fv3, zero, v34]
// [Asm]   blt v34, v2, .loop_i.634_2  # live: [v4, fv3, zero, v2]
// [Asm] 
// [Asm] # block info: defs: [fv10, t1, v16, v7, v32, fv12, ft0, ft1, a1, fv14, fa1, fa2, ft6, fa6, a4, a6, v19, ft10, ft5, ft7, ft4, ft9, a5, a0, fa4, fv8, ft2, a2, v17, a3, v31, ft8, fv9, fa7, t3, a7, t0, fa5, v18, fa3, fv11, ft3, fa0, fv13, t4, t2, v15], uses: [fv10, v7, v32, fv12, a1, fv14, fa1, fa2, zero, fa6, v4, fv3, fa4, a0, fv8, a2, v17, v31, fa7, fv9, fa5, fa3, fv11, fa0, fv13, v15, v2], upward_exposed: [v4, fv3, zero, v2], params_defs: []
// [Asm] # live_in: [v4, fv3, zero, v2], live_out: [v19, zero]
// [Asm] # block parameters: []
// [Asm] .loop_i.634_1:
// [Asm]   slliw v31, v2, 3  # live: [v31, zero, v4, fv3, v2]
// [Asm]   add v32, v4, v31  # live: [v32, zero, v4, fv3, v2]
// [Asm]   ld v7, 0(v32)  # live: [v7, zero, v4, fv3, v2]
// [Asm]   fld fv8, 0(v7)  # live: [fv8, v7, zero, v4, fv3, v2]
// [Asm]   fld fv9, 8(v7)  # live: [fv8, v7, fv9, zero, v4, fv3, v2]
// [Asm]   fld fv10, 16(v7)  # live: [fv10, fv8, v7, fv9, zero, v4, fv3, v2]
// [Asm]   fld fv11, 24(v7)  # live: [fv10, fv8, v7, fv9, zero, fv11, v4, fv3, v2]
// [Asm]   fld fv12, 32(v7)  # live: [fv10, fv8, v7, fv12, fv9, zero, fv11, v4, fv3, v2]
// [Asm]   fld fv13, 40(v7)  # live: [fv10, fv8, v7, fv12, fv9, zero, fv11, fv13, v4, fv3, v2]
// [Asm]   fld fv14, 48(v7)  # live: [fv10, fv8, fv12, fv14, fv9, zero, fv11, fv13, v4, fv3, v2]
// [Asm]   addi v15, v2, 1  # live: [fv10, fv8, fv12, fv14, fv9, zero, fv11, fv13, v4, v15, fv3, v2]
// [Asm]   # save_ctx2  # live: [fv10, fv8, fv12, fv14, fv9, zero, fv11, fv13, v4, v15, fv3, v2]
// [Asm]   mv a0, v15  # live: [fv10, a0, fv8, fv12, fv14, fv9, zero, fv11, fv13, v4, fv3, v2]
// [Asm]   fmv.d fa0, fv3  # live: [fv10, a0, fv8, fv12, fv14, fv9, zero, fv11, fv13, fa0, v4, fv3, v2]
// [Asm]   mv a1, v2  # live: [fv10, a0, fv8, fv12, a1, fv14, fv9, zero, fv11, fv13, fa0, v4, fv3, v2]
// [Asm]   fmv.d fa1, fv14  # live: [fv10, a0, fv8, fv12, a1, fa1, fv9, zero, fv11, fv13, fa0, v4, fv3, v2]
// [Asm]   fmv.d fa2, fv8  # live: [fv10, a0, fv12, a1, fa1, fv9, fa2, zero, fv11, fv13, fa0, v4, fv3, v2]
// [Asm]   fmv.d fa3, fv9  # live: [fv10, a0, fv12, a1, fa1, fa2, fa3, zero, fv11, fv13, fa0, v4, fv3, v2]
// [Asm]   fmv.d fa4, fv10  # live: [fa4, a0, fv12, a1, fa1, fa2, fa3, zero, fv11, fv13, fa0, v4, fv3, v2]
// [Asm]   fmv.d fa5, fv11  # live: [fa4, a0, fv12, a1, fa1, fa5, fa2, fa3, zero, fa0, fv13, v4, fv3, v2]
// [Asm]   fmv.d fa6, fv12  # live: [fa4, a0, a1, fa1, fa5, fa2, fa3, zero, fa6, fa0, fv13, v4, fv3, v2]
// [Asm]   fmv.d fa7, fv13  # live: [fa4, a0, a1, fa1, fa7, fa5, fa2, fa3, zero, fa6, fa0, v4, fv3, v2]
// [Asm]   mv a2, v4  # live: [fa4, a0, a2, a1, fa1, fa7, fa5, fa2, fa3, zero, fa6, fa0, v4, fv3, v2]
// [Asm]   call loop_j.635  # live: [v2, v4, zero, fv3, a0]
// [Asm]   mv v16, a0  # live: [v4, zero, fv3, v2]
// [Asm]   # restore_ctx2  # live: [v4, zero, fv3, v2]
// [Asm]   addi v17, v2, 1  # live: [v4, v17, zero, fv3]
// [Asm]   # save_ctx2  # live: [v4, v17, zero, fv3]
// [Asm]   mv a0, v17  # live: [v4, zero, a0, fv3]
// [Asm]   fmv.d fa0, fv3  # live: [v4, zero, a0, fa0]
// [Asm]   mv a1, v4  # live: [a1, zero, a0, fa0]
// [Asm]   call loop_i.634  # live: [zero, a0]
// [Asm]   mv v18, a0  # live: [zero]
// [Asm]   # restore_ctx2  # live: [zero]
// [Asm] # control
// [Asm]   mv v19, zero  # live: [v19, zero]
// [Asm] 
// [Asm] # block info: defs: [a0], uses: [zero, a0], upward_exposed: [zero], params_defs: [v19]
// [Asm] # live_in: [v19, zero], live_out: []
// [Asm] # block parameters: [v19]
// [Asm] .loop_i.634_3:
// [Asm] # control
// [Asm]   mv a0, zero  # live: [a0]
// [Asm]   # restore_ctx1  # live: [a0]
// [Asm]   ret  # live: []
// [Asm] 
// [Asm] # block info: defs: [v19], uses: [zero], upward_exposed: [zero], params_defs: []
// [Asm] # live_in: [zero], live_out: [v19, zero]
// [Asm] # block parameters: []
// [Asm] .loop_i.634_2:
// [Asm] # control
// [Asm]   mv v19, zero  # live: [v19, zero]
// [Asm]   j .loop_i.634_3  # live: [v19, zero]
// [Asm] 
// [Asm] # leaf false
// [Asm] loop_i.632:
// [Asm] # block info: defs: [v3, v4, v47, v6, v5, v2], uses: [a0, a4, a2, v47, a1, a3, v2], upward_exposed: [a2, a1, a3, a0, a4], params_defs: []
// [Asm] # live_in: [a0, zero, a4, a2, a1, a3], live_out: [v2, v5, zero, v4, v6, v3]
// [Asm] # block parameters: []
// [Asm] .loop_i.632_0:
// [Asm]   # save_ctx1  # live: [zero, a0, a4, a2, a1, a3]
// [Asm]   mv v2, a0  # live: [zero, a4, a2, a1, a3, v2]
// [Asm]   mv v3, a1  # live: [v3, zero, a4, a2, a3, v2]
// [Asm]   mv v4, a2  # live: [v3, zero, a4, v4, a3, v2]
// [Asm]   mv v5, a3  # live: [v3, v5, zero, a4, v4, v2]
// [Asm]   mv v6, a4  # live: [v3, v5, zero, v4, v6, v2]
// [Asm] # control
// [Asm]   li v47, 4  # live: [v3, v5, zero, v4, v47, v6, v2]
// [Asm]   blt v47, v2, .loop_i.632_2  # live: [v2, v4, v5, v6, zero, v3]
// [Asm] 
// [Asm] # block info: defs: [fv23, t1, fv19, ft0, ft1, a1, fv14, fv16, v44, fv15, fa1, fa2, fv25, v29, ft6, a4, fa6, a6, ft10, ft5, fv27, fv21, ft7, ft4, ft9, a5, a0, fa4, v30, ft2, a2, a3, v31, v9, ft8, t3, a7, fa7, t0, fa5, fa3, ft3, v45, fv13, fa0, t4, t2, fv17], uses: [v3, v2, fv23, v5, a0, fv19, a2, a1, fv14, a3, v44, fv15, fv16, v9, fv25, v29, zero, a4, v45, fv13, v4, v6, fv27, fv17, fv21], upward_exposed: [v3, v4, v6, v5, zero, v2], params_defs: []
// [Asm] # live_in: [v3, v5, zero, v4, v6, v2], live_out: [v31, zero]
// [Asm] # block parameters: []
// [Asm] .loop_i.632_1:
// [Asm]   slliw v44, v2, 3  # live: [v3, v5, zero, v4, v6, v44, v2]
// [Asm]   add v45, v6, v44  # live: [v3, v5, zero, v45, v4, v6, v2]
// [Asm]   ld v9, 0(v45)  # live: [v3, v5, zero, v4, v6, v9, v2]
// [Asm]   fld fv13, 24(v9)  # live: [v3, v5, zero, fv13, v4, v6, v9, v2]
// [Asm]   fld fv14, 32(v9)  # live: [v3, v5, zero, fv13, v4, v6, fv14, v9, v2]
// [Asm]   fld fv15, 40(v9)  # live: [v3, v5, zero, fv13, v4, v6, fv14, fv15, v9, v2]
// [Asm]   fld fv16, 48(v9)  # live: [v3, v5, zero, fv13, v4, v6, fv14, fv15, fv16, v2]
// [Asm]   fld fv17, 0(v3)  # live: [v3, v5, zero, fv13, v4, v6, fv14, fv15, fv16, fv17, v2]
// [Asm]   fmadd.d fv19, fv13, fv16, fv17  # live: [v3, v5, zero, fv19, v4, v6, fv14, fv15, fv16, v2]
// [Asm]   fsd fv19, 0(v3)  # live: [v3, v5, zero, v4, v6, fv14, fv15, fv16, v2]
// [Asm]   fld fv21, 0(v4)  # live: [v3, v5, zero, v4, v6, fv14, fv15, fv16, fv21, v2]
// [Asm]   fmadd.d fv23, fv14, fv16, fv21  # live: [v3, fv23, v5, zero, v4, v6, fv15, fv16, v2]
// [Asm]   fsd fv23, 0(v4)  # live: [v3, v5, zero, v4, v6, fv15, fv16, v2]
// [Asm]   fld fv25, 0(v5)  # live: [v3, v5, zero, fv25, v4, v6, fv15, fv16, v2]
// [Asm]   fmadd.d fv27, fv15, fv16, fv25  # live: [v3, v5, zero, v4, v6, fv27, v2]
// [Asm]   fsd fv27, 0(v5)  # live: [v2, v4, v6, v5, zero, v3]
// [Asm]   addi v29, v2, 1  # live: [v4, v6, v5, zero, v29, v3]
// [Asm]   # save_ctx2  # live: [v4, v6, v5, zero, v29, v3]
// [Asm]   mv a0, v29  # live: [v4, v6, v5, zero, a0, v3]
// [Asm]   mv a1, v3  # live: [v4, a1, v6, v5, zero, a0]
// [Asm]   mv a2, v4  # live: [a2, a1, v6, v5, zero, a0]
// [Asm]   mv a3, v5  # live: [a2, a1, v6, a3, zero, a0]
// [Asm]   mv a4, v6  # live: [a2, a1, a3, zero, a0, a4]
// [Asm]   call loop_i.632  # live: [zero, a0]
// [Asm]   mv v30, a0  # live: [zero]
// [Asm]   # restore_ctx2  # live: [zero]
// [Asm] # control
// [Asm]   mv v31, zero  # live: [v31, zero]
// [Asm] 
// [Asm] # block info: defs: [a0], uses: [zero, a0], upward_exposed: [zero], params_defs: [v31]
// [Asm] # live_in: [v31, zero], live_out: []
// [Asm] # block parameters: [v31]
// [Asm] .loop_i.632_3:
// [Asm] # control
// [Asm]   mv a0, zero  # live: [a0]
// [Asm]   # restore_ctx1  # live: [a0]
// [Asm]   ret  # live: []
// [Asm] 
// [Asm] # block info: defs: [v31], uses: [zero], upward_exposed: [zero], params_defs: []
// [Asm] # live_in: [zero], live_out: [v31, zero]
// [Asm] # block parameters: []
// [Asm] .loop_i.632_2:
// [Asm] # control
// [Asm]   mv v31, zero  # live: [v31, zero]
// [Asm]   j .loop_i.632_3  # live: [v31, zero]
// [Asm] 
// [Asm] # leaf false
// [Asm] loop_i.633:
// [Asm] # block info: defs: [v3, v4, v2], uses: [v2, a2, a1, a0, v3], upward_exposed: [a2, a1, a0], params_defs: []
// [Asm] # live_in: [a2, a1, a0, zero], live_out: [v3, v4, zero, v2]
// [Asm] # block parameters: []
// [Asm] .loop_i.633_0:
// [Asm]   # save_ctx1  # live: [a2, a1, zero, a0]
// [Asm]   mv v2, a0  # live: [a2, a1, zero, v2]
// [Asm]   mv v3, a1  # live: [v3, a2, zero, v2]
// [Asm]   mv v4, a2  # live: [v3, v4, zero, v2]
// [Asm] # control
// [Asm]   blt v3, v2, .loop_i.633_2  # live: [v3, v4, zero, v2]
// [Asm] 
// [Asm] # block info: defs: [t1, v16, v13, v7, ft0, ft1, a1, fv14, fa1, fa2, ft6, a4, fa6, v8, a6, ft10, ft5, v6, ft7, ft4, ft9, v10, a5, fa4, a0, ft2, a2, a3, v9, ft8, t3, a7, fa7, t0, fa5, fa3, ft3, fa0, t4, t2, fv17], uses: [v2, v16, a0, v13, a2, a1, fv14, zero, fa0, v8, v4, fv17, v3], upward_exposed: [v3, v4, zero, v2], params_defs: []
// [Asm] # live_in: [v2, v4, zero, v3], live_out: [v10, zero]
// [Asm] # block parameters: []
// [Asm] .loop_i.633_1:
// [Asm]   # save_ctx2  # live: [v3, zero, v4, v2]
// [Asm]   mv a0, zero  # live: [v3, zero, a0, v4, v2]
// [Asm]   li v16, 4576918229304087675  # live: [v3, v16, zero, a0, v4, v2]
// [Asm]   fmv.d.x fv17, v16  # live: [v3, zero, a0, v4, fv17, v2]
// [Asm]   fmv.d fa0, fv17  # live: [v3, zero, a0, fa0, v4, v2]
// [Asm]   mv a1, v4  # live: [v3, zero, a0, fa0, v4, a1, v2]
// [Asm]   call loop_i.634  # live: [v3, zero, a0, v4, v2]
// [Asm]   mv v6, a0  # live: [v3, zero, v4, v2]
// [Asm]   # restore_ctx2  # live: [v3, zero, v4, v2]
// [Asm]   # save_ctx2  # live: [v3, zero, v4, v2]
// [Asm]   mv a0, zero  # live: [v3, zero, a0, v4, v2]
// [Asm]   li v13, 4576918229304087675  # live: [v3, zero, a0, v13, v4, v2]
// [Asm]   fmv.d.x fv14, v13  # live: [v3, zero, a0, v4, fv14, v2]
// [Asm]   fmv.d fa0, fv14  # live: [v3, zero, a0, fa0, v4, v2]
// [Asm]   mv a1, v4  # live: [v3, zero, a0, fa0, v4, a1, v2]
// [Asm]   call update_axis.636  # live: [v2, v4, zero, a0, v3]
// [Asm]   mv v7, a0  # live: [v2, v4, zero, v3]
// [Asm]   # restore_ctx2  # live: [v2, v4, zero, v3]
// [Asm]   addi v8, v2, 1  # live: [v8, v4, zero, v3]
// [Asm]   # save_ctx2  # live: [v8, v4, zero, v3]
// [Asm]   mv a0, v8  # live: [v4, zero, a0, v3]
// [Asm]   mv a1, v3  # live: [v4, a1, zero, a0]
// [Asm]   mv a2, v4  # live: [a2, a1, zero, a0]
// [Asm]   call loop_i.633  # live: [zero, a0]
// [Asm]   mv v9, a0  # live: [zero]
// [Asm]   # restore_ctx2  # live: [zero]
// [Asm] # control
// [Asm]   mv v10, zero  # live: [v10, zero]
// [Asm] 
// [Asm] # block info: defs: [a0], uses: [zero, a0], upward_exposed: [zero], params_defs: [v10]
// [Asm] # live_in: [v10, zero], live_out: []
// [Asm] # block parameters: [v10]
// [Asm] .loop_i.633_3:
// [Asm] # control
// [Asm]   mv a0, zero  # live: [a0]
// [Asm]   # restore_ctx1  # live: [a0]
// [Asm]   ret  # live: []
// [Asm] 
// [Asm] # block info: defs: [v10], uses: [zero], upward_exposed: [zero], params_defs: []
// [Asm] # live_in: [zero], live_out: [v10, zero]
// [Asm] # block parameters: []
// [Asm] .loop_i.633_2:
// [Asm] # control
// [Asm]   mv v10, zero  # live: [v10, zero]
// [Asm]   j .loop_i.633_3  # live: [v10, zero]
// [Asm] 
// [Asm] # leaf false
// [Asm] loop_j.635:
// [Asm] # block info: defs: [fv5, fv9, fv10, v94, fv11, fv8, v4, v12, fv6, fv3, fv7, v2], uses: [fa7, v94, fa5, fa2, fa3, a0, fa4, fa6, fa0, a2, a1, fa1, v2], upward_exposed: [fa7, fa5, fa2, fa3, a0, fa4, fa6, fa0, a2, a1, fa1], params_defs: []
// [Asm] # live_in: [a0, fa4, a2, a1, s11, fa1, fa7, fa5, fa2, fa3, zero, fa6, fa0], live_out: [fv10, fv8, v12, s11, fv6, fv9, fv5, fv11, zero, v4, fv3, fv7, v2]
// [Asm] # block parameters: []
// [Asm] .loop_j.635_0:
// [Asm]   # save_ctx1  # live: [fa4, a0, a2, a1, s11, fa1, fa7, fa5, fa3, fa2, zero, fa6, fa0]
// [Asm]   mv v2, a0  # live: [fa4, a2, a1, s11, fa1, fa7, fa5, fa3, fa2, zero, fa6, fa0, v2]
// [Asm]   fmv.d fv3, fa0  # live: [fa4, a2, a1, s11, fa1, fa7, fa5, fa3, fa2, zero, fa6, fv3, v2]
// [Asm]   mv v4, a1  # live: [fa4, a2, s11, fa1, fa7, fa5, fa3, fa2, zero, fa6, v4, fv3, v2]
// [Asm]   fmv.d fv5, fa1  # live: [fa4, a2, s11, fv5, fa7, fa5, fa3, fa2, zero, fa6, v4, fv3, v2]
// [Asm]   fmv.d fv6, fa2  # live: [fa4, a2, s11, fv6, fv5, fa7, fa5, fa3, zero, fa6, v4, fv3, v2]
// [Asm]   fmv.d fv7, fa3  # live: [fa4, a2, s11, fv6, fv5, fa7, fa5, zero, fa6, v4, fv3, fv7, v2]
// [Asm]   fmv.d fv8, fa4  # live: [fv8, a2, s11, fv6, fv5, fa7, fa5, zero, fa6, v4, fv3, fv7, v2]
// [Asm]   fmv.d fv9, fa5  # live: [fv8, a2, s11, fv6, fv9, fv5, fa7, zero, fa6, v4, fv3, fv7, v2]
// [Asm]   fmv.d fv10, fa6  # live: [fv10, fv8, a2, s11, fv6, fv9, fv5, fa7, zero, v4, fv3, fv7, v2]
// [Asm]   fmv.d fv11, fa7  # live: [fv10, fv8, a2, s11, fv6, fv9, fv5, fv11, zero, v4, fv3, fv7, v2]
// [Asm]   mv v12, a2  # live: [fv10, fv8, v12, s11, fv6, fv9, fv5, fv11, zero, v4, fv3, fv7, v2]
// [Asm] # control
// [Asm]   li v94, 4  # live: [fv10, fv8, v12, s11, fv6, fv9, fv5, v94, fv11, zero, v4, fv3, fv7, v2]
// [Asm]   blt v94, v2, .loop_j.635_2  # live: [v2, fv9, fv5, fv10, fv11, zero, fv8, v4, v12, s11, fv6, fv3, fv7]
// [Asm] 
// [Asm] # block info: defs: [fv24, v58, v91, fv39, fv30, a1, s11, fv35, fa1, v64, fv38, v63, fa2, fv25, ft6, fv41, a4, fa6, a6, ft5, ft10, fv27, v54, fv37, ft4, ft9, fa4, ft2, v17, a3, fv50, fa7, a7, fv28, fa3, fv34, fv42, fv43, ft3, t2, fv18, v55, fv23, t1, v16, v14, v13, fv20, fv19, ft0, ft1, fv40, fv22, fv36, fv21, ft7, fv32, v53, a5, a0, fv48, a2, fv26, ft8, t3, t0, fa5, fv33, fa0, t4, fv49, fv44], uses: [fv24, v91, v58, fv39, fv30, a1, s11, fv35, v64, fa1, fv38, v63, fa2, fv25, fv41, fa6, fv27, fv3, fv37, fa4, v17, fv50, fa7, fv28, fa3, fv11, fv34, fv42, fv43, fv18, fv7, fv10, fv23, v16, v14, v13, fv20, fv19, v12, fv40, fv22, fv5, fv36, zero, v4, fv21, fv32, v53, a0, fv8, fv48, a2, fv6, fv26, fv9, fa5, fv33, fa0, fv49, fv44, v2], upward_exposed: [v2, fv9, fv5, fv10, fv11, zero, fv8, v4, v12, s11, fv6, fv3, fv7], params_defs: []
// [Asm] # live_in: [fv10, fv8, v12, s11, fv6, fv5, fv9, fv11, zero, v4, fv3, fv7, v2], live_out: [v55, zero]
// [Asm] # block parameters: []
// [Asm] .loop_j.635_1:
// [Asm]   slliw v16, v2, 3  # live: [fv10, v16, v12, s11, fv5, zero, v4, fv3, fv8, fv6, fv9, fv11, fv7, v2]
// [Asm]   add v91, v12, v16  # live: [fv10, v16, v91, v12, s11, fv5, zero, v4, fv3, fv8, fv6, fv9, fv11, fv7, v2]
// [Asm]   ld v17, 0(v91)  # live: [fv10, v16, v12, s11, fv5, zero, v4, fv3, fv8, v17, fv6, fv9, fv11, fv7, v2]
// [Asm]   fld fv18, 0(v17)  # live: [fv10, v16, v12, s11, fv5, zero, v4, fv3, fv8, v17, fv6, fv9, fv11, fv18, fv7, v2]
// [Asm]   fld fv19, 8(v17)  # live: [fv10, v16, fv19, v12, s11, fv5, zero, v4, fv3, fv8, v17, fv6, fv9, fv11, fv18, fv7, v2]
// [Asm]   fld fv20, 16(v17)  # live: [fv10, v16, fv20, fv19, v12, s11, fv5, zero, v4, fv3, fv8, v17, fv6, fv9, fv11, fv18, fv7, v2]
// [Asm]   fld fv21, 24(v17)  # live: [fv10, v16, fv20, fv19, v12, s11, fv5, zero, v4, fv3, fv21, fv8, v17, fv6, fv9, fv11, fv18, fv7, v2]
// [Asm]   fld fv22, 32(v17)  # live: [fv10, v16, fv20, fv19, v12, s11, fv5, fv22, zero, v4, fv3, fv21, fv8, v17, fv6, fv9, fv11, fv18, fv7, v2]
// [Asm]   fld fv23, 40(v17)  # live: [fv23, fv10, v16, fv20, fv19, v12, s11, fv5, fv22, zero, v4, fv3, fv21, fv8, v17, fv6, fv9, fv11, fv18, fv7, v2]
// [Asm]   fld fv24, 48(v17)  # live: [fv23, fv10, fv24, v16, fv20, fv19, v12, s11, fv5, fv22, zero, v4, fv3, fv21, fv8, fv6, fv9, fv11, fv18, fv7, v2]
// [Asm]   fsub.d fv25, fv6, fv18  # live: [fv23, fv10, fv24, v16, fv20, fv19, v12, s11, fv5, fv22, zero, fv25, v4, fv3, fv21, fv8, fv6, fv9, fv11, fv18, fv7, v2]
// [Asm]   fsub.d fv26, fv7, fv19  # live: [fv23, fv10, fv24, v16, fv20, fv19, v12, s11, fv5, fv22, zero, fv25, v4, fv3, fv21, fv8, fv6, fv26, fv9, fv11, fv18, fv7, v2]
// [Asm]   fsub.d fv27, fv8, fv20  # live: [fv23, fv10, fv24, v16, fv20, fv19, v12, s11, fv5, fv22, zero, fv25, v4, fv27, fv3, fv21, fv8, fv6, fv26, fv9, fv11, fv18, fv7, v2]
// [Asm]   fmul.d fv28, fv25, fv25  # live: [fv23, fv10, fv24, v16, fv20, fv19, v12, s11, fv5, fv22, zero, fv25, v4, fv27, fv3, fv21, fv8, fv6, fv26, fv9, fv28, fv11, fv18, fv7, v2]
// [Asm]   fmadd.d fv30, fv26, fv26, fv28  # live: [fv23, fv10, fv24, v16, fv20, fv30, fv19, v12, s11, fv5, fv22, zero, fv25, v4, fv27, fv3, fv21, fv8, fv6, fv26, fv9, fv11, fv18, fv7, v2]
// [Asm]   fmadd.d fv32, fv27, fv27, fv30  # live: [fv23, fv10, fv24, v16, fv20, fv19, v12, s11, fv5, fv22, zero, fv25, v4, fv27, fv3, fv21, fv32, fv8, fv6, fv26, fv9, fv11, fv18, fv7, v2]
// [Asm]   fsqrt.d fv33, fv32  # live: [fv23, fv10, fv24, v16, fv20, fv19, v12, s11, fv5, fv22, zero, fv25, v4, fv27, fv3, fv21, fv32, fv8, fv6, fv26, fv9, fv11, fv33, fv18, fv7, v2]
// [Asm]   fmul.d fv34, fv32, fv33  # live: [fv23, fv10, fv24, v16, fv20, fv19, v12, s11, fv5, fv22, zero, fv25, v4, fv27, fv3, fv21, fv8, fv6, fv26, fv9, fv11, fv34, fv18, fv7, v2]
// [Asm]   fdiv.d fv35, fv3, fv34  # live: [fv23, fv10, fv24, v16, fv20, fv19, v12, s11, fv35, fv5, fv22, zero, fv25, v4, fv27, fv3, fv21, fv8, fv6, fv26, fv9, fv11, fv18, fv7, v2]
// [Asm]   fmul.d fv36, fv25, fv24  # live: [fv23, fv10, fv24, v16, fv20, fv19, v12, s11, fv35, fv5, fv22, zero, fv36, v4, fv27, fv3, fv21, fv8, fv6, fv26, fv9, fv11, fv18, fv7, v2]
// [Asm]   fmul.d fv37, fv36, fv35  # live: [fv23, fv10, fv24, v16, fv20, fv19, v12, s11, fv35, fv5, fv22, zero, v4, fv27, fv3, fv21, fv37, fv8, fv6, fv26, fv9, fv11, fv18, fv7, v2]
// [Asm]   fsub.d fv38, fv9, fv37  # live: [fv23, fv10, fv24, v16, fv20, fv19, v12, s11, fv35, fv38, fv5, fv22, zero, v4, fv27, fv3, fv21, fv37, fv8, fv6, fv26, fv9, fv11, fv18, fv7, v2]
// [Asm]   fmul.d fv39, fv26, fv24  # live: [fv23, fv10, fv24, v16, fv39, fv20, fv19, v12, s11, fv35, fv38, fv5, fv22, zero, v4, fv27, fv3, fv21, fv37, fv8, fv6, fv9, fv11, fv18, fv7, v2]
// [Asm]   fmul.d fv40, fv39, fv35  # live: [fv23, fv10, fv24, v16, fv20, fv19, v12, s11, fv35, fv40, fv38, fv5, fv22, zero, v4, fv27, fv3, fv21, fv37, fv8, fv6, fv9, fv11, fv18, fv7, v2]
// [Asm]   fsub.d fv41, fv10, fv40  # live: [fv23, fv10, fv24, v16, fv20, fv19, v12, s11, fv35, fv40, fv38, fv5, fv22, zero, fv41, v4, fv27, fv3, fv21, fv37, fv8, fv6, fv9, fv11, fv18, fv7, v2]
// [Asm]   fmul.d fv42, fv27, fv24  # live: [fv23, fv10, fv24, v16, fv20, fv19, v12, s11, fv35, fv40, fv38, fv5, fv22, zero, fv41, v4, fv3, fv21, fv37, fv8, fv6, fv9, fv11, fv42, fv18, fv7, v2]
// [Asm]   fmul.d fv43, fv42, fv35  # live: [fv23, fv10, fv24, v16, fv20, fv19, v12, s11, fv40, fv38, fv5, fv22, zero, fv41, v4, fv3, fv21, fv37, fv8, fv6, fv9, fv11, fv43, fv18, fv7, v2]
// [Asm]   fsub.d fv44, fv11, fv43  # live: [fv23, fv10, fv24, v16, fv20, fv19, v12, s11, fv40, fv38, fv5, fv22, zero, fv41, v4, fv3, fv21, fv37, fv8, fv6, fv9, fv11, fv43, fv18, fv44, fv7, v2]
// [Asm]   addi v13, s11, -56  # live: [fv23, fv10, fv24, v16, v13, fv20, fv19, v12, fv40, fv38, fv5, fv22, zero, fv41, v4, fv3, fv21, fv37, fv8, fv6, fv9, fv11, fv43, fv18, fv44, fv7, v2]
// [Asm]   andi s11, v13, -8  # live: [fv23, fv10, fv24, v16, v13, fv20, fv19, v12, s11, fv40, fv38, fv5, fv22, zero, fv41, v4, fv3, fv21, fv37, fv8, fv6, fv9, fv11, fv43, fv18, fv44, fv7, v2]
// [Asm]   fsd fv6, 0(v13)  # live: [fv23, fv10, fv24, v16, v13, fv20, fv19, v12, s11, fv40, fv38, fv5, fv22, zero, fv41, v4, fv3, fv21, fv37, fv8, fv6, fv9, fv11, fv43, fv18, fv44, fv7, v2]
// [Asm]   fsd fv7, 8(v13)  # live: [fv23, fv10, fv24, v16, v13, fv20, fv19, v12, s11, fv40, fv38, fv5, fv22, zero, fv41, v4, fv3, fv21, fv37, fv8, fv6, fv9, fv11, fv43, fv18, fv44, fv7, v2]
// [Asm]   fsd fv8, 16(v13)  # live: [fv23, fv10, fv24, v16, v13, fv20, fv19, v12, s11, fv40, fv38, fv5, fv22, zero, fv41, v4, fv3, fv21, fv37, fv8, fv6, fv9, fv11, fv43, fv18, fv44, fv7, v2]
// [Asm]   fsd fv38, 24(v13)  # live: [fv23, fv10, fv24, v16, v13, fv20, fv19, v12, s11, fv40, fv5, fv22, zero, fv41, v4, fv3, fv21, fv37, fv8, fv6, fv9, fv11, fv43, fv18, fv44, fv7, v2]
// [Asm]   fsd fv41, 32(v13)  # live: [fv23, fv10, fv24, v16, v13, fv20, fv19, v12, s11, fv40, fv5, fv22, zero, v4, fv3, fv21, fv37, fv8, fv6, fv9, fv11, fv43, fv18, fv44, fv7, v2]
// [Asm]   fsd fv44, 40(v13)  # live: [v2, fv37, fv24, fv23, fv10, v16, v13, fv8, fv20, fv19, v12, s11, fv6, fv40, fv9, fv5, fv22, zero, fv11, fv43, v4, fv18, fv3, fv7, fv21]
// [Asm]   fsd fv5, 48(v13)  # live: [v2, fv37, fv24, fv23, fv10, v16, v13, fv8, fv20, fv19, v12, s11, fv6, fv40, fv9, fv5, fv22, zero, fv11, fv43, v4, fv18, fv3, fv7, fv21]
// [Asm]   slliw v63, v4, 3  # live: [v2, fv37, fv24, fv23, fv10, v16, v13, fv8, fv20, fv19, v12, s11, fv6, fv40, fv9, fv5, fv22, v63, zero, fv11, fv43, v4, fv18, fv3, fv7, fv21]
// [Asm]   add v64, v12, v63  # live: [v2, fv37, fv24, fv23, fv10, v16, v13, fv8, fv20, fv19, v12, s11, fv6, v64, fv40, fv9, fv5, fv22, zero, fv11, fv43, v4, fv18, fv3, fv7, fv21]
// [Asm]   sd v13, 0(v64)  # live: [v2, fv37, fv24, fv23, fv10, v16, fv8, fv20, fv19, v12, s11, fv6, fv40, fv9, fv5, fv22, zero, fv11, fv43, v4, fv18, fv3, fv7, fv21]
// [Asm]   fsub.d fv48, fv21, fv37  # live: [fv10, fv24, fv23, v16, fv8, fv20, fv48, fv19, v12, s11, fv6, fv40, fv9, fv5, fv22, zero, fv11, fv43, v4, fv18, fv3, fv7, v2]
// [Asm]   fsub.d fv49, fv22, fv40  # live: [fv10, fv24, fv23, v16, fv8, fv20, fv48, fv19, v12, s11, fv6, fv9, fv5, zero, fv11, fv43, v4, fv49, fv18, fv3, fv7, v2]
// [Asm]   fsub.d fv50, fv23, fv43  # live: [fv10, fv24, v16, fv8, fv20, fv48, fv19, v12, s11, fv6, fv9, fv5, fv50, zero, fv11, v4, fv49, fv18, fv3, fv7, v2]
// [Asm]   addi v14, s11, -56  # live: [fv10, fv24, v16, v14, fv8, fv20, fv48, fv19, v12, fv6, fv9, fv5, fv50, zero, fv11, v4, fv49, fv18, fv3, fv7, v2]
// [Asm]   andi s11, v14, -8  # live: [fv10, fv24, v16, v14, fv8, fv20, fv48, fv19, v12, fv6, fv9, fv5, fv50, zero, fv11, v4, fv49, fv18, fv3, fv7, v2]
// [Asm]   fsd fv18, 0(v14)  # live: [fv10, fv24, v16, v14, fv8, fv20, fv48, fv19, v12, fv6, fv9, fv5, fv50, zero, fv11, v4, fv49, fv3, fv7, v2]
// [Asm]   fsd fv19, 8(v14)  # live: [fv10, fv24, v16, v14, fv8, fv20, fv48, v12, fv6, fv9, fv5, fv50, zero, fv11, v4, fv49, fv3, fv7, v2]
// [Asm]   fsd fv20, 16(v14)  # live: [fv10, fv24, v16, v14, fv8, fv48, v12, fv6, fv9, fv5, fv50, zero, fv11, v4, fv49, fv3, fv7, v2]
// [Asm]   fsd fv48, 24(v14)  # live: [fv10, fv24, v16, v14, fv8, v12, fv6, fv9, fv5, fv50, zero, fv11, v4, fv49, fv3, fv7, v2]
// [Asm]   fsd fv49, 32(v14)  # live: [fv10, fv24, v16, v14, fv8, v12, fv6, fv9, fv5, fv50, zero, fv11, v4, fv3, fv7, v2]
// [Asm]   fsd fv50, 40(v14)  # live: [fv10, fv24, v16, v14, fv8, v12, fv6, fv9, fv5, zero, fv11, v4, fv3, fv7, v2]
// [Asm]   fsd fv24, 48(v14)  # live: [fv10, v14, v16, fv8, v12, fv6, fv9, fv5, zero, fv11, v4, fv3, fv7, v2]
// [Asm]   add v58, v12, v16  # live: [fv10, v14, v58, fv8, v12, fv6, fv9, fv5, zero, fv11, v4, fv3, fv7, v2]
// [Asm]   sd v14, 0(v58)  # live: [fv9, fv5, fv10, zero, fv11, fv8, v4, v12, fv6, fv3, fv7, v2]
// [Asm]   addi v53, v2, 1  # live: [fv9, fv5, fv10, v53, zero, fv11, fv8, v4, v12, fv6, fv3, fv7]
// [Asm]   # save_ctx2  # live: [fv9, fv5, fv10, v53, zero, fv11, fv8, v4, v12, fv6, fv3, fv7]
// [Asm]   mv a0, v53  # live: [fv9, fv5, fv10, zero, a0, fv11, fv8, v4, v12, fv6, fv3, fv7]
// [Asm]   fmv.d fa0, fv3  # live: [fv9, fv5, fv10, zero, a0, fv11, fa0, fv8, v4, v12, fv6, fv7]
// [Asm]   mv a1, v4  # live: [fv9, fv5, fv10, zero, a0, fv11, fa0, fv8, a1, v12, fv6, fv7]
// [Asm]   fmv.d fa1, fv5  # live: [fv9, fv10, zero, a0, fv11, fa0, fv8, a1, v12, fv6, fa1, fv7]
// [Asm]   fmv.d fa2, fv6  # live: [fv9, fv10, fa2, zero, a0, fv11, fa0, fv8, a1, v12, fa1, fv7]
// [Asm]   fmv.d fa3, fv7  # live: [fv9, fv10, fa2, fa3, zero, a0, fv11, fa0, fv8, a1, v12, fa1]
// [Asm]   fmv.d fa4, fv8  # live: [fv9, fv10, fa2, fa3, fa4, zero, a0, fv11, fa0, a1, v12, fa1]
// [Asm]   fmv.d fa5, fv9  # live: [fv10, fa5, fa2, fa3, fa4, zero, a0, fv11, fa0, a1, v12, fa1]
// [Asm]   fmv.d fa6, fv10  # live: [fa5, fa2, fa3, fa4, zero, a0, fv11, fa6, fa0, a1, v12, fa1]
// [Asm]   fmv.d fa7, fv11  # live: [fa7, fa5, fa2, fa3, fa4, zero, a0, fa6, fa0, a1, v12, fa1]
// [Asm]   mv a2, v12  # live: [fa7, fa5, fa2, fa3, fa4, zero, a0, fa6, fa0, a2, a1, fa1]
// [Asm]   call loop_j.635  # live: [zero, a0]
// [Asm]   mv v54, a0  # live: [zero]
// [Asm]   # restore_ctx2  # live: [zero]
// [Asm] # control
// [Asm]   mv v55, zero  # live: [v55, zero]
// [Asm] 
// [Asm] # block info: defs: [a0], uses: [zero, a0], upward_exposed: [zero], params_defs: [v55]
// [Asm] # live_in: [v55, zero], live_out: []
// [Asm] # block parameters: [v55]
// [Asm] .loop_j.635_3:
// [Asm] # control
// [Asm]   mv a0, zero  # live: [a0]
// [Asm]   # restore_ctx1  # live: [a0]
// [Asm]   ret  # live: []
// [Asm] 
// [Asm] # block info: defs: [v55], uses: [zero], upward_exposed: [zero], params_defs: []
// [Asm] # live_in: [zero], live_out: [v55, zero]
// [Asm] # block parameters: []
// [Asm] .loop_j.635_2:
// [Asm] # control
// [Asm]   mv v55, zero  # live: [v55, zero]
// [Asm]   j .loop_j.635_3  # live: [v55, zero]
// [Asm] 
// [Asm] # leaf false
// [Asm] loop_j.630:
// [Asm] # block info: defs: [v2, fv5, v56, v8, fv4, fv6, fv7, v3], uses: [v56, fa2, fa3, a0, fa0, a2, a1, fa1, v2], upward_exposed: [fa2, fa3, a0, fa0, a2, a1, fa1], params_defs: []
// [Asm] # live_in: [fa2, fa3, a0, zero, fa0, a2, a1, fa1], live_out: [v2, fv5, zero, v8, fv4, fv6, fv7, v3]
// [Asm] # block parameters: []
// [Asm] .loop_j.630_0:
// [Asm]   # save_ctx1  # live: [fa3, fa2, zero, a0, fa0, a2, a1, fa1]
// [Asm]   mv v2, a0  # live: [fa3, fa2, zero, fa0, a2, a1, fa1, v2]
// [Asm]   mv v3, a1  # live: [v2, fa3, fa2, zero, fa0, a2, fa1, v3]
// [Asm]   fmv.d fv4, fa0  # live: [v2, fa3, fa2, zero, a2, fv4, fa1, v3]
// [Asm]   fmv.d fv5, fa1  # live: [v2, fv5, fa3, fa2, zero, a2, fv4, v3]
// [Asm]   fmv.d fv6, fa2  # live: [v2, fv5, fa3, zero, a2, fv4, fv6, v3]
// [Asm]   fmv.d fv7, fa3  # live: [v2, fv5, zero, a2, fv4, fv6, fv7, v3]
// [Asm]   mv v8, a2  # live: [v2, fv5, zero, v8, fv4, fv6, fv7, v3]
// [Asm] # control
// [Asm]   li v56, 4  # live: [v2, fv5, v56, zero, v8, fv4, fv6, fv7, v3]
// [Asm]   blt v56, v2, .loop_j.630_2  # live: [v2, fv5, zero, v8, fv4, fv6, fv7, v3]
// [Asm] 
// [Asm] # block info: defs: [fv24, fv30, fv12, a1, v33, fa1, fa2, ft6, a4, fa6, a6, ft5, ft10, fv27, v54, ft4, ft9, fa4, ft2, a3, a7, fa7, fv28, fa3, ft3, fv29, t2, fv18, t1, fv20, fv19, ft0, ft1, fv14, fv22, v34, fv21, ft7, v11, v53, a5, a0, a2, fv26, ft8, t3, t0, fa5, fv31, fv13, fa0, v35, t4], uses: [v3, fv24, fv20, fv30, fv19, fv12, a1, fv14, v33, fa1, fv5, fv22, fa2, zero, v8, fv27, v54, fv21, v11, v53, a0, a2, fv4, fv6, fv26, fv28, fv31, fa3, fv13, fa0, fv29, fv18, fv7, v2], upward_exposed: [v2, fv5, zero, v8, fv4, fv6, fv7, v3], params_defs: []
// [Asm] # live_in: [v3, fv5, zero, v8, fv4, fv6, fv7, v2], live_out: [zero, v35]
// [Asm] # block parameters: []
// [Asm] .loop_j.630_1:
// [Asm]   slliw v53, v2, 3  # live: [v2, fv5, v53, zero, v8, fv4, fv6, fv7, v3]
// [Asm]   add v54, v8, v53  # live: [v2, fv5, zero, v8, fv4, fv6, v54, fv7, v3]
// [Asm]   ld v11, 0(v54)  # live: [v2, fv5, v11, zero, v8, fv4, fv6, fv7, v3]
// [Asm]   fld fv12, 0(v11)  # live: [v2, fv5, v11, zero, v8, fv12, fv4, fv6, fv7, v3]
// [Asm]   fld fv13, 8(v11)  # live: [v2, fv5, v11, zero, v8, fv13, fv12, fv4, fv6, fv7, v3]
// [Asm]   fld fv14, 16(v11)  # live: [v2, fv5, v11, zero, v8, fv13, fv12, fv4, fv14, fv6, fv7, v3]
// [Asm]   fld fv18, 48(v11)  # live: [v2, fv5, zero, v8, fv13, fv12, fv4, fv14, fv6, fv18, fv7, v3]
// [Asm]   fsub.d fv19, fv5, fv12  # live: [v2, fv5, zero, v8, fv13, fv19, fv4, fv14, fv6, fv18, fv7, v3]
// [Asm]   fsub.d fv20, fv6, fv13  # live: [v2, fv5, zero, v8, fv20, fv19, fv4, fv14, fv6, fv18, fv7, v3]
// [Asm]   fsub.d fv21, fv7, fv14  # live: [v3, v2, fv5, zero, v8, fv20, fv19, fv4, fv6, fv18, fv7, fv21]
// [Asm]   fmul.d fv22, fv19, fv19  # live: [v3, v2, fv5, fv22, zero, v8, fv20, fv4, fv6, fv18, fv7, fv21]
// [Asm]   fmadd.d fv24, fv20, fv20, fv22  # live: [v3, v2, fv5, fv24, zero, v8, fv4, fv6, fv18, fv7, fv21]
// [Asm]   fmadd.d fv26, fv21, fv21, fv24  # live: [v2, v3, fv5, zero, v8, fv4, fv6, fv18, fv26, fv7]
// [Asm]   fld fv27, 0(v3)  # live: [v2, v3, fv5, zero, v8, fv4, fv27, fv6, fv18, fv26, fv7]
// [Asm]   fmul.d fv28, fv4, fv18  # live: [v2, fv5, fv28, zero, v8, fv4, fv27, fv6, fv26, fv7, v3]
// [Asm]   fsqrt.d fv29, fv26  # live: [v2, fv5, fv28, zero, v8, fv29, fv4, fv27, fv6, fv7, v3]
// [Asm]   fdiv.d fv30, fv28, fv29  # live: [v2, fv5, zero, v8, fv30, fv4, fv27, fv6, fv7, v3]
// [Asm]   fsub.d fv31, fv27, fv30  # live: [v2, fv5, fv31, zero, v8, fv4, fv6, fv7, v3]
// [Asm]   fsd fv31, 0(v3)  # live: [v2, fv5, zero, v8, fv4, fv6, fv7, v3]
// [Asm]   addi v33, v2, 1  # live: [fv5, zero, v8, fv4, fv6, v33, fv7, v3]
// [Asm]   # save_ctx2  # live: [fv5, zero, v8, fv4, fv6, v33, fv7, v3]
// [Asm]   mv a0, v33  # live: [fv5, a0, zero, v8, fv4, fv6, fv7, v3]
// [Asm]   mv a1, v3  # live: [fv5, a0, zero, v8, a1, fv4, fv6, fv7]
// [Asm]   fmv.d fa0, fv4  # live: [fv5, a0, zero, fa0, v8, a1, fv6, fv7]
// [Asm]   fmv.d fa1, fv5  # live: [a0, zero, fa0, v8, a1, fv6, fa1, fv7]
// [Asm]   fmv.d fa2, fv6  # live: [fa2, a0, zero, fa0, v8, a1, fa1, fv7]
// [Asm]   fmv.d fa3, fv7  # live: [fa2, fa3, a0, zero, fa0, v8, a1, fa1]
// [Asm]   mv a2, v8  # live: [fa2, fa3, a0, zero, fa0, a2, a1, fa1]
// [Asm]   call loop_j.630  # live: [zero, a0]
// [Asm]   mv v34, a0  # live: [zero]
// [Asm]   # restore_ctx2  # live: [zero]
// [Asm] # control
// [Asm]   mv v35, zero  # live: [zero, v35]
// [Asm] 
// [Asm] # block info: defs: [a0], uses: [zero, a0], upward_exposed: [zero], params_defs: [v35]
// [Asm] # live_in: [zero, v35], live_out: []
// [Asm] # block parameters: [v35]
// [Asm] .loop_j.630_3:
// [Asm] # control
// [Asm]   mv a0, zero  # live: [a0]
// [Asm]   # restore_ctx1  # live: [a0]
// [Asm]   ret  # live: []
// [Asm] 
// [Asm] # block info: defs: [v35], uses: [zero], upward_exposed: [zero], params_defs: []
// [Asm] # live_in: [zero], live_out: [zero, v35]
// [Asm] # block parameters: []
// [Asm] .loop_j.630_2:
// [Asm] # control
// [Asm]   mv v35, zero  # live: [zero, v35]
// [Asm]   j .loop_j.630_3  # live: [zero, v35]
// [Asm] 
// [Asm] # leaf false
// [Asm] main.631:
// [Asm] # block info: defs: [v153, v58, v159, a1, s11, fv47, fa1, fv74, fv38, fv152, fv150, fa2, v151, a6, ft10, v59, v6, fv154, v62, ft4, v5, v10, ft9, fv143, v119, v123, v110, v157, a7, fv50, v146, fv43, fv156, fv132, fv124, v7, ft0, ft1, v108, v12, v106, v161, v29, v8, fv109, v66, v121, v53, fv56, v30, v114, fv101, a2, v9, fv57, ft8, fv51, t3, v112, fv137, fa5, fv31, fv162, t4, v131, fv117, fv44, v2, fv63, fv39, fv113, v73, fv120, fv128, fv145, fv99, ft6, a4, fa6, fv41, ft5, fv158, fv135, v144, v129, v54, fv147, fv37, v116, fv130, fv160, fa4, ft2, a3, v52, fa7, fv141, fa3, fv115, v68, fv42, ft3, v136, v104, t2, v140, fv17, fv126, v55, v3, fv111, fv105, t1, v69, v127, v134, fv107, v149, fv40, fv139, v142, fv122, v4, ft7, v155, v11, fv45, fv32, a5, v125, a0, v138, t0, fv46, fa0, fv33], uses: [v153, v58, v159, a1, s11, fv47, fv74, fv38, fv152, fv150, v151, v6, fv154, v62, v5, v10, fv143, v119, v123, v110, v157, fv50, v146, fv43, fv156, fv132, fv124, v7, v108, v12, v106, v161, zero, v8, fv109, v66, v121, fv56, v30, fv101, a2, v114, v9, fv57, fv51, fv137, v112, fv31, fv162, v131, fv117, fv44, v2, fv63, fv39, fv113, v73, fv120, fv128, fv145, fv99, a4, fv41, fv158, fv135, v144, v129, fv147, v116, fv37, fv130, fv160, v52, a3, fv141, fv115, v68, fv42, v104, v136, v140, fv126, fv17, v3, fv111, fv105, v69, v127, v134, fv107, v149, fv40, fv139, v142, fv122, v4, v155, v11, fv45, fv32, v125, a0, v138, fv46, fv33, fa0], upward_exposed: [s11, zero], params_defs: []
// [Asm] # live_in: [s11, zero], live_out: []
// [Asm] # block parameters: []
// [Asm] .main.631_0:
// [Asm]   # save_ctx1  # live: [zero, s11]
// [Asm]   addi v6, s11, -56  # live: [zero, v6]
// [Asm]   andi s11, v6, -8  # live: [zero, v6, s11]
// [Asm]   li v149, 4617136985637443884  # live: [zero, v6, s11, v149]
// [Asm]   fmv.d.x fv150, v149  # live: [fv150, zero, v6, s11]
// [Asm]   fsd fv150, 0(v6)  # live: [zero, v6, s11]
// [Asm]   li v151, -4615467600764216452  # live: [zero, v151, v6, s11]
// [Asm]   fmv.d.x fv152, v151  # live: [zero, v6, s11, fv152]
// [Asm]   fsd fv152, 8(v6)  # live: [zero, v6, s11]
// [Asm]   li v153, -4631240860977730576  # live: [v153, zero, v6, s11]
// [Asm]   fmv.d.x fv154, v153  # live: [fv154, zero, v6, s11]
// [Asm]   fsd fv154, 16(v6)  # live: [zero, v6, s11]
// [Asm]   li v155, 4603636522180398268  # live: [v155, zero, v6, s11]
// [Asm]   fmv.d.x fv156, v155  # live: [zero, fv156, v6, s11]
// [Asm]   fsd fv156, 24(v6)  # live: [zero, v6, s11]
// [Asm]   li v157, 4613514450253485211  # live: [zero, v157, v6, s11]
// [Asm]   fmv.d.x fv158, v157  # live: [zero, v6, s11, fv158]
// [Asm]   fsd fv158, 32(v6)  # live: [zero, v6, s11]
// [Asm]   li v159, -4640446117579192555  # live: [zero, v159, v6, s11]
// [Asm]   fmv.d.x fv160, v159  # live: [fv160, zero, v6, s11]
// [Asm]   fsd fv160, 40(v6)  # live: [zero, v6, s11]
// [Asm]   li v161, 4585593052079010776  # live: [v161, zero, v6, s11]
// [Asm]   fmv.d.x fv162, v161  # live: [zero, fv162, v6, s11]
// [Asm]   fsd fv162, 48(v6)  # live: [zero, v6, s11]
// [Asm]   addi v7, s11, -56  # live: [zero, v7, v6]
// [Asm]   andi s11, v7, -8  # live: [zero, v7, v6, s11]
// [Asm]   li v134, 4620886515960171111  # live: [zero, v7, v134, v6, s11]
// [Asm]   fmv.d.x fv135, v134  # live: [zero, v7, v6, s11, fv135]
// [Asm]   fsd fv135, 0(v7)  # live: [zero, v7, v6, s11]
// [Asm]   li v136, 4616330128746480048  # live: [zero, v7, v136, v6, s11]
// [Asm]   fmv.d.x fv137, v136  # live: [fv137, zero, v7, v6, s11]
// [Asm]   fsd fv137, 8(v7)  # live: [zero, v7, v6, s11]
// [Asm]   li v138, -4622431185293064580  # live: [zero, v7, v6, s11, v138]
// [Asm]   fmv.d.x fv139, v138  # live: [fv139, zero, v7, v6, s11]
// [Asm]   fsd fv139, 16(v7)  # live: [zero, v7, v6, s11]
// [Asm]   li v140, -4616141094713322430  # live: [zero, v7, v6, v140, s11]
// [Asm]   fmv.d.x fv141, v140  # live: [fv141, zero, v7, v6, s11]
// [Asm]   fsd fv141, 24(v7)  # live: [zero, v7, v6, s11]
// [Asm]   li v142, 4610900871547424531  # live: [v142, zero, v7, v6, s11]
// [Asm]   fmv.d.x fv143, v142  # live: [fv143, zero, v7, v6, s11]
// [Asm]   fsd fv143, 32(v7)  # live: [zero, v7, v6, s11]
// [Asm]   li v144, 4576002370458991342  # live: [zero, v7, v6, s11, v144]
// [Asm]   fmv.d.x fv145, v144  # live: [fv145, zero, v7, v6, s11]
// [Asm]   fsd fv145, 40(v7)  # live: [zero, v7, v6, s11]
// [Asm]   li v146, 4577659745833829943  # live: [v146, zero, v7, v6, s11]
// [Asm]   fmv.d.x fv147, v146  # live: [zero, v7, v6, s11, fv147]
// [Asm]   fsd fv147, 48(v7)  # live: [zero, v7, v6, s11]
// [Asm]   addi v10, s11, -56  # live: [v10, zero, v7, v6]
// [Asm]   andi s11, v10, -8  # live: [v10, zero, v7, v6, s11]
// [Asm]   li v119, 4623448502799161807  # live: [v10, zero, v119, v7, v6, s11]
// [Asm]   fmv.d.x fv120, v119  # live: [fv120, v10, zero, v7, v6, s11]
// [Asm]   fsd fv120, 0(v10)  # live: [v10, zero, v7, v6, s11]
// [Asm]   li v121, -4598675596822288770  # live: [v10, v121, zero, v7, v6, s11]
// [Asm]   fmv.d.x fv122, v121  # live: [v10, zero, v7, fv122, v6, s11]
// [Asm]   fsd fv122, 8(v10)  # live: [v10, zero, v7, v6, s11]
// [Asm]   li v123, -4626158513131520603  # live: [v10, zero, v123, v7, v6, s11]
// [Asm]   fmv.d.x fv124, v123  # live: [v10, zero, v7, fv124, v6, s11]
// [Asm]   fsd fv124, 16(v10)  # live: [v10, zero, v7, v6, s11]
// [Asm]   li v125, 4607555276345777135  # live: [v10, zero, v125, v7, v6, s11]
// [Asm]   fmv.d.x fv126, v125  # live: [v10, zero, v7, v6, s11, fv126]
// [Asm]   fsd fv126, 24(v10)  # live: [v10, zero, v7, v6, s11]
// [Asm]   li v127, 4605999890795117509  # live: [v10, v127, zero, v7, v6, s11]
// [Asm]   fmv.d.x fv128, v127  # live: [fv128, v10, zero, v7, v6, s11]
// [Asm]   fsd fv128, 32(v10)  # live: [v10, zero, v7, v6, s11]
// [Asm]   li v129, -4645973824767902084  # live: [v10, zero, v7, v6, s11, v129]
// [Asm]   fmv.d.x fv130, v129  # live: [fv130, v10, zero, v7, v6, s11]
// [Asm]   fsd fv130, 40(v10)  # live: [v10, zero, v7, v6, s11]
// [Asm]   li v131, 4565592097032511155  # live: [v10, zero, v7, v6, s11, v131]
// [Asm]   fmv.d.x fv132, v131  # live: [v10, zero, v7, fv132, v6, s11]
// [Asm]   fsd fv132, 48(v10)  # live: [v10, zero, v7, v6, s11]
// [Asm]   addi v11, s11, -56  # live: [v11, v10, zero, v7, v6]
// [Asm]   andi s11, v11, -8  # live: [v11, v10, zero, v7, v6, s11]
// [Asm]   li v104, 4624847617829197610  # live: [v11, v10, zero, v7, v104, v6, s11]
// [Asm]   fmv.d.x fv105, v104  # live: [v11, fv105, v10, zero, v7, v6, s11]
// [Asm]   fsd fv105, 0(v11)  # live: [v11, v10, zero, v7, v6, s11]
// [Asm]   li v106, -4595383180696444384  # live: [v11, v106, v10, zero, v7, v6, s11]
// [Asm]   fmv.d.x fv107, v106  # live: [v11, v10, zero, v7, v6, fv107, s11]
// [Asm]   fsd fv107, 8(v11)  # live: [v11, v10, zero, v7, v6, s11]
// [Asm]   li v108, 4595626498235032896  # live: [v11, v10, zero, v7, v6, v108, s11]
// [Asm]   fmv.d.x fv109, v108  # live: [v11, v10, zero, v7, fv109, v6, s11]
// [Asm]   fsd fv109, 16(v11)  # live: [v11, v10, zero, v7, v6, s11]
// [Asm]   li v110, 4606994084859067466  # live: [v11, v10, zero, v110, v7, v6, s11]
// [Asm]   fmv.d.x fv111, v110  # live: [v11, fv111, v10, zero, v7, v6, s11]
// [Asm]   fsd fv111, 24(v11)  # live: [v11, v10, zero, v7, v6, s11]
// [Asm]   li v112, 4603531791922690979  # live: [v11, v112, v10, zero, v7, v6, s11]
// [Asm]   fmv.d.x fv113, v112  # live: [v11, v10, zero, fv113, v7, v6, s11]
// [Asm]   fsd fv113, 32(v11)  # live: [v11, v10, zero, v7, v6, s11]
// [Asm]   li v114, -4638202354754755082  # live: [v11, v10, zero, v7, v114, v6, s11]
// [Asm]   fmv.d.x fv115, v114  # live: [v11, v10, zero, fv115, v7, v6, s11]
// [Asm]   fsd fv115, 40(v11)  # live: [v11, v10, zero, v7, v6, s11]
// [Asm]   li v116, 4566835785178257837  # live: [v11, v116, v10, zero, v7, v6, s11]
// [Asm]   fmv.d.x fv117, v116  # live: [v11, v10, zero, v7, v6, s11, fv117]
// [Asm]   fsd fv117, 48(v11)  # live: [v11, v10, zero, v7, v6, s11]
// [Asm]   fld fv17, solar_mass.4, t5  # live: [v11, v10, zero, v7, v6, s11, fv17]
// [Asm]   addi v3, s11, -56  # live: [v11, v10, zero, v7, v6, fv17, v3]
// [Asm]   andi s11, v3, -8  # live: [v11, v10, zero, v7, v6, s11, fv17, v3]
// [Asm]   fmv.d.x fv101, zero  # live: [v11, v10, zero, v7, fv101, v6, s11, fv17, v3]
// [Asm]   fsd fv101, 0(v3)  # live: [v11, v10, zero, v7, fv101, v6, s11, fv17, v3]
// [Asm]   fsd fv101, 8(v3)  # live: [v11, v10, zero, v7, fv101, v6, s11, fv17, v3]
// [Asm]   fsd fv101, 16(v3)  # live: [v11, v10, zero, v7, fv101, v6, s11, fv17, v3]
// [Asm]   fsd fv101, 24(v3)  # live: [v11, v10, zero, v7, fv101, v6, s11, fv17, v3]
// [Asm]   fsd fv101, 32(v3)  # live: [v11, v10, zero, v7, fv101, v6, s11, fv17, v3]
// [Asm]   fsd fv101, 40(v3)  # live: [v11, v10, zero, v7, v6, s11, fv17, v3]
// [Asm]   fsd fv17, 48(v3)  # live: [v11, v10, zero, v7, v6, s11, v3]
// [Asm]   addi v9, s11, -56  # live: [v11, v10, zero, v7, v6, v9, v3]
// [Asm]   andi s11, v9, -8  # live: [v11, v10, zero, v7, v6, s11, v9, v3]
// [Asm]   fmv.d.x fv99, zero  # live: [v11, v10, fv99, zero, v7, v6, s11, v9, v3]
// [Asm]   fsd fv99, 0(v9)  # live: [v11, v10, fv99, zero, v7, v6, s11, v9, v3]
// [Asm]   fsd fv99, 8(v9)  # live: [v11, v10, fv99, zero, v7, v6, s11, v9, v3]
// [Asm]   fsd fv99, 16(v9)  # live: [v11, v10, fv99, zero, v7, v6, s11, v9, v3]
// [Asm]   fsd fv99, 24(v9)  # live: [v11, v10, fv99, zero, v7, v6, s11, v9, v3]
// [Asm]   fsd fv99, 32(v9)  # live: [v11, v10, fv99, zero, v7, v6, s11, v9, v3]
// [Asm]   fsd fv99, 40(v9)  # live: [v11, v10, fv99, zero, v7, v6, s11, v9, v3]
// [Asm]   fsd fv99, 48(v9)  # live: [v11, v10, zero, v7, v6, s11, v9, v3]
// [Asm]   addi v2, s11, -40  # live: [v3, v11, v10, zero, v7, v6, v9, v2]
// [Asm]   andi s11, v2, -8  # live: [v3, v11, v10, zero, v7, v6, s11, v9, v2]
// [Asm]   sd v9, 0(v2)  # live: [v3, v11, v10, zero, v7, v6, s11, v9, v2]
// [Asm]   sd v9, 8(v2)  # live: [v3, v11, v10, zero, v7, v6, s11, v9, v2]
// [Asm]   sd v9, 16(v2)  # live: [v3, v11, v10, zero, v7, v6, s11, v9, v2]
// [Asm]   sd v9, 24(v2)  # live: [v3, v11, v10, zero, v7, v6, s11, v9, v2]
// [Asm]   sd v9, 32(v2)  # live: [v3, v11, v10, zero, v7, v6, s11, v2]
// [Asm]   sd v3, 0(v2)  # live: [v11, v10, zero, v7, v6, s11, v2]
// [Asm]   sd v6, 8(v2)  # live: [v11, v10, zero, v7, s11, v2]
// [Asm]   sd v7, 16(v2)  # live: [v11, v10, zero, s11, v2]
// [Asm]   sd v10, 24(v2)  # live: [v11, zero, s11, v2]
// [Asm]   sd v11, 32(v2)  # live: [zero, s11, v2]
// [Asm]   addi v12, s11, -8  # live: [zero, v12, v2]
// [Asm]   andi s11, v12, -8  # live: [zero, v12, s11, v2]
// [Asm]   addi v4, s11, -8  # live: [zero, v4, v12, v2]
// [Asm]   andi s11, v4, -8  # live: [zero, v4, v12, s11, v2]
// [Asm]   addi v5, s11, -8  # live: [v5, zero, v4, v12, v2]
// [Asm]   andi s11, v5, -8  # live: [v5, zero, v4, v12, s11, v2]
// [Asm]   # save_ctx2  # live: [v5, zero, v4, v12, s11, v2]
// [Asm]   mv a0, zero  # live: [v5, zero, a0, v4, v12, s11, v2]
// [Asm]   mv a1, v12  # live: [v5, zero, a0, v4, a1, v12, s11, v2]
// [Asm]   mv a2, v4  # live: [v5, zero, a0, v4, a2, a1, v12, s11, v2]
// [Asm]   mv a3, v5  # live: [v5, zero, a0, v4, a2, a1, v12, s11, a3, v2]
// [Asm]   mv a4, v2  # live: [v5, zero, a0, a4, v4, a2, a1, v12, s11, a3, v2]
// [Asm]   call loop_i.632  # live: [v5, zero, a0, v4, s11, v12, v2]
// [Asm]   mv v29, a0  # live: [v5, zero, v4, s11, v12, v2]
// [Asm]   # restore_ctx2  # live: [v5, zero, v4, s11, v12, v2]
// [Asm]   ld v30, 0(v2)  # live: [v5, zero, v30, v4, s11, v12, v2]
// [Asm]   fld fv31, 0(v30)  # live: [v5, fv31, zero, v30, v4, s11, v12, v2]
// [Asm]   fld fv32, 8(v30)  # live: [v5, fv32, fv31, zero, v30, v4, s11, v12, v2]
// [Asm]   fld fv33, 16(v30)  # live: [v5, fv32, fv31, zero, v30, fv33, v4, s11, v12, v2]
// [Asm]   fld fv37, 48(v30)  # live: [fv37, v5, fv32, fv31, zero, fv33, v4, s11, v12, v2]
// [Asm]   fld fv38, 0(v12)  # live: [fv37, v5, fv32, fv31, zero, fv33, v4, s11, fv38, v2]
// [Asm]   fld fv39, solar_mass.4, t5  # live: [fv37, v5, fv32, fv31, zero, fv39, fv33, v4, s11, fv38, v2]
// [Asm]   fdiv.d fv40, fv38, fv39  # live: [fv37, v5, fv32, fv31, zero, fv39, fv33, v4, s11, fv40, v2]
// [Asm]   fneg.d fv41, fv40  # live: [fv37, v5, fv32, fv31, zero, fv39, fv41, fv33, v4, s11, v2]
// [Asm]   fld fv42, 0(v4)  # live: [fv37, v5, fv32, fv31, zero, fv39, fv41, fv42, fv33, s11, v2]
// [Asm]   fdiv.d fv43, fv42, fv39  # live: [fv37, v5, fv32, fv31, zero, fv39, fv41, fv43, fv33, s11, v2]
// [Asm]   fneg.d fv44, fv43  # live: [fv37, v5, fv32, fv31, zero, fv39, fv41, fv33, s11, fv44, v2]
// [Asm]   fld fv45, 0(v5)  # live: [fv37, fv45, fv32, fv31, zero, fv39, fv41, fv33, s11, fv44, v2]
// [Asm]   fdiv.d fv46, fv45, fv39  # live: [fv37, fv46, fv32, fv31, zero, fv41, fv33, s11, fv44, v2]
// [Asm]   fneg.d fv47, fv46  # live: [fv37, fv32, fv31, zero, fv41, fv33, fv47, s11, fv44, v2]
// [Asm]   addi v8, s11, -56  # live: [fv37, fv32, fv31, zero, fv41, v8, fv33, fv47, fv44, v2]
// [Asm]   andi s11, v8, -8  # live: [fv37, fv32, fv31, zero, fv41, v8, fv33, fv47, fv44, v2]
// [Asm]   fsd fv31, 0(v8)  # live: [fv37, fv32, zero, fv41, v8, fv33, fv47, fv44, v2]
// [Asm]   fsd fv32, 8(v8)  # live: [fv37, zero, fv41, v8, fv33, fv47, fv44, v2]
// [Asm]   fsd fv33, 16(v8)  # live: [fv37, zero, fv41, v8, fv47, fv44, v2]
// [Asm]   fsd fv41, 24(v8)  # live: [fv37, zero, v8, fv47, fv44, v2]
// [Asm]   fsd fv44, 32(v8)  # live: [v8, fv37, fv47, zero, v2]
// [Asm]   fsd fv47, 40(v8)  # live: [v8, fv37, zero, v2]
// [Asm]   fsd fv37, 48(v8)  # live: [v8, zero, v2]
// [Asm]   sd v8, 0(v2)  # live: [zero, v2]
// [Asm]   # save_ctx2  # live: [zero, v2]
// [Asm]   mv a0, v2  # live: [zero, a0, v2]
// [Asm]   call energy.628  # live: [fa0, zero, v2]
// [Asm]   fmv.d fv50, fa0  # live: [fv50, zero, v2]
// [Asm]   # restore_ctx2  # live: [fv50, zero, v2]
// [Asm]   li v73, 4741671816366391296  # live: [v73, fv50, zero, v2]
// [Asm]   fmv.d.x fv74, v73  # live: [fv50, zero, fv74, v2]
// [Asm]   fmul.d fv51, fv50, fv74  # live: [fv51, zero, v2]
// [Asm]   fcvt.w.d v52, fv51, rtz  # live: [v52, zero, v2]
// [Asm]   # save_ctx2  # live: [v52, zero, v2]
// [Asm]   mv a0, v52  # live: [zero, a0, v2]
// [Asm]   call minimbt_print_int  # live: [zero, a0, v2]
// [Asm]   mv v53, a0  # live: [zero, v2]
// [Asm]   # restore_ctx2  # live: [zero, v2]
// [Asm]   # save_ctx2  # live: [zero, v2]
// [Asm]   li v68, 1  # live: [zero, v68, v2]
// [Asm]   mv a0, v68  # live: [zero, a0, v2]
// [Asm]   li v69, 500000  # live: [v69, zero, a0, v2]
// [Asm]   mv a1, v69  # live: [a1, zero, a0, v2]
// [Asm]   mv a2, v2  # live: [a2, a1, zero, a0, v2]
// [Asm]   call loop_i.633  # live: [zero, a0, v2]
// [Asm]   mv v54, a0  # live: [zero, v2]
// [Asm]   # restore_ctx2  # live: [zero, v2]
// [Asm]   # save_ctx2  # live: [zero, v2]
// [Asm]   li v66, 10  # live: [v66, zero, v2]
// [Asm]   mv a0, v66  # live: [zero, a0, v2]
// [Asm]   call minimbt_print_char  # live: [zero, a0, v2]
// [Asm]   mv v55, a0  # live: [zero, v2]
// [Asm]   # restore_ctx2  # live: [zero, v2]
// [Asm]   # save_ctx2  # live: [zero, v2]
// [Asm]   mv a0, v2  # live: [zero, a0]
// [Asm]   call energy.628  # live: [zero, fa0]
// [Asm]   fmv.d fv56, fa0  # live: [fv56, zero]
// [Asm]   # restore_ctx2  # live: [fv56, zero]
// [Asm]   li v62, 4741671816366391296  # live: [v62, fv56, zero]
// [Asm]   fmv.d.x fv63, v62  # live: [fv63, fv56, zero]
// [Asm]   fmul.d fv57, fv56, fv63  # live: [zero, fv57]
// [Asm]   fcvt.w.d v58, fv57, rtz  # live: [v58, zero]
// [Asm]   # save_ctx2  # live: [v58, zero]
// [Asm]   mv a0, v58  # live: [zero, a0]
// [Asm]   call minimbt_print_int  # live: [zero, a0]
// [Asm]   mv v59, a0  # live: [zero]
// [Asm]   # restore_ctx2  # live: [zero]
// [Asm] # control
// [Asm]   mv a0, zero  # live: [a0]
// [Asm]   # restore_ctx1  # live: [a0]
// [Asm]   ret  # live: []
// [Asm] 
// [Asm] # leaf false
// [Asm] loop_i.629:
// [Asm] # block info: defs: [v3, v4, v52, v2], uses: [a2, a1, v52, a0, v2], upward_exposed: [a2, a1, a0], params_defs: []
// [Asm] # live_in: [a2, a1, a0, zero], live_out: [v3, v4, zero, v2]
// [Asm] # block parameters: []
// [Asm] .loop_i.629_0:
// [Asm]   # save_ctx1  # live: [a2, a1, zero, a0]
// [Asm]   mv v2, a0  # live: [a2, a1, zero, v2]
// [Asm]   mv v3, a1  # live: [v3, a2, zero, v2]
// [Asm]   mv v4, a2  # live: [v3, v4, zero, v2]
// [Asm] # control
// [Asm]   li v52, 4  # live: [v3, v4, v52, zero, v2]
// [Asm]   blt v52, v2, .loop_i.629_2  # live: [v3, v4, zero, v2]
// [Asm] 
// [Asm] # block info: defs: [fv39, fv12, a1, fv15, v28, fa1, fa2, ft6, v50, a4, fa6, v27, a6, ft5, ft10, ft4, v49, ft9, fa4, ft2, a3, a7, fa7, fa3, fv11, ft3, t2, fv17, v25, fv10, fv23, t1, v26, v7, fv19, ft0, ft1, fv14, fv16, v29, fv21, ft7, a5, a0, fv8, a2, ft8, fv9, t3, t0, fa5, fa0, fv13, v38, t4], uses: [v2, v25, fv10, fv23, fv39, v7, fv19, fv12, a1, fv14, fv16, fv15, fa1, fa2, zero, v50, v27, v4, fv21, v49, a0, fv8, a2, fv9, fa3, fv11, fa0, fv13, v38, fv17, v3], upward_exposed: [v3, v4, zero, v2], params_defs: []
// [Asm] # live_in: [v2, v4, zero, v3], live_out: [v29, zero]
// [Asm] # block parameters: []
// [Asm] .loop_i.629_1:
// [Asm]   slliw v49, v2, 3  # live: [v2, v49, zero, v4, v3]
// [Asm]   add v50, v4, v49  # live: [v2, zero, v50, v4, v3]
// [Asm]   ld v7, 0(v50)  # live: [v2, v7, zero, v4, v3]
// [Asm]   fld fv8, 0(v7)  # live: [v2, fv8, v7, zero, v4, v3]
// [Asm]   fld fv9, 8(v7)  # live: [v2, fv8, v7, fv9, zero, v4, v3]
// [Asm]   fld fv10, 16(v7)  # live: [v2, fv10, fv8, v7, fv9, zero, v4, v3]
// [Asm]   fld fv11, 24(v7)  # live: [v2, fv10, fv8, v7, fv9, zero, fv11, v4, v3]
// [Asm]   fld fv12, 32(v7)  # live: [v2, fv10, fv8, v7, fv12, fv9, zero, fv11, v4, v3]
// [Asm]   fld fv13, 40(v7)  # live: [v2, fv10, fv8, v7, fv12, fv9, zero, fv11, fv13, v4, v3]
// [Asm]   fld fv14, 48(v7)  # live: [v2, fv10, fv8, fv12, fv14, fv9, zero, fv11, fv13, v4, v3]
// [Asm]   fld fv15, 0(v3)  # live: [v2, fv10, fv8, fv12, fv14, fv15, fv9, zero, fv11, fv13, v4, v3]
// [Asm]   li v38, 4602678819172646912  # live: [v2, fv10, fv8, fv12, fv14, fv15, fv9, zero, fv11, fv13, v4, v38, v3]
// [Asm]   fmv.d.x fv39, v38  # live: [v2, fv10, fv39, fv8, fv12, fv14, fv15, fv9, zero, fv11, fv13, v4, v3]
// [Asm]   fmul.d fv16, fv39, fv14  # live: [v2, fv10, fv8, fv12, fv14, fv16, fv15, fv9, zero, fv11, fv13, v4, v3]
// [Asm]   fmul.d fv17, fv11, fv11  # live: [v3, fv9, fv10, zero, fv8, fv13, v4, fv12, fv14, fv16, fv15, fv17, v2]
// [Asm]   fmadd.d fv19, fv12, fv12, fv17  # live: [v3, fv9, fv10, zero, fv8, fv13, fv19, v4, fv14, fv16, fv15, v2]
// [Asm]   fmadd.d fv21, fv13, fv13, fv19  # live: [v3, fv9, fv10, zero, fv8, v4, fv14, fv16, fv15, fv21, v2]
// [Asm]   fmadd.d fv23, fv16, fv21, fv15  # live: [v3, fv9, fv10, fv23, zero, fv8, v4, fv14, v2]
// [Asm]   fsd fv23, 0(v3)  # live: [v3, fv9, fv10, zero, fv8, v4, fv14, v2]
// [Asm]   addi v25, v2, 1  # live: [v3, fv9, v25, fv10, zero, fv8, v4, fv14, v2]
// [Asm]   # save_ctx2  # live: [v3, fv9, v25, fv10, zero, fv8, v4, fv14, v2]
// [Asm]   mv a0, v25  # live: [v3, fv9, fv10, zero, a0, fv8, v4, fv14, v2]
// [Asm]   mv a1, v3  # live: [v3, fv9, fv10, zero, a0, fv8, v4, a1, fv14, v2]
// [Asm]   fmv.d fa0, fv14  # live: [v3, fv9, fv10, zero, a0, fa0, fv8, v4, a1, v2]
// [Asm]   fmv.d fa1, fv8  # live: [v3, fv9, fv10, zero, a0, fa0, v4, a1, fa1, v2]
// [Asm]   fmv.d fa2, fv9  # live: [v3, fv10, fa2, zero, a0, fa0, v4, a1, fa1, v2]
// [Asm]   fmv.d fa3, fv10  # live: [v3, fa2, fa3, zero, a0, fa0, v4, a1, fa1, v2]
// [Asm]   mv a2, v4  # live: [v3, fa2, fa3, zero, a0, fa0, v4, a2, a1, fa1, v2]
// [Asm]   call loop_j.630  # live: [v2, v4, zero, a0, v3]
// [Asm]   mv v26, a0  # live: [v2, v4, zero, v3]
// [Asm]   # restore_ctx2  # live: [v2, v4, zero, v3]
// [Asm]   addi v27, v2, 1  # live: [v4, zero, v27, v3]
// [Asm]   # save_ctx2  # live: [v4, zero, v27, v3]
// [Asm]   mv a0, v27  # live: [v4, zero, a0, v3]
// [Asm]   mv a1, v3  # live: [v4, a1, zero, a0]
// [Asm]   mv a2, v4  # live: [a2, a1, zero, a0]
// [Asm]   call loop_i.629  # live: [zero, a0]
// [Asm]   mv v28, a0  # live: [zero]
// [Asm]   # restore_ctx2  # live: [zero]
// [Asm] # control
// [Asm]   mv v29, zero  # live: [v29, zero]
// [Asm] 
// [Asm] # block info: defs: [a0], uses: [zero, a0], upward_exposed: [zero], params_defs: [v29]
// [Asm] # live_in: [v29, zero], live_out: []
// [Asm] # block parameters: [v29]
// [Asm] .loop_i.629_3:
// [Asm] # control
// [Asm]   mv a0, zero  # live: [a0]
// [Asm]   # restore_ctx1  # live: [a0]
// [Asm]   ret  # live: []
// [Asm] 
// [Asm] # block info: defs: [v29], uses: [zero], upward_exposed: [zero], params_defs: []
// [Asm] # live_in: [zero], live_out: [v29, zero]
// [Asm] # block parameters: []
// [Asm] .loop_i.629_2:
// [Asm] # control
// [Asm]   mv v29, zero  # live: [v29, zero]
// [Asm]   j .loop_i.629_3  # live: [v29, zero]
// [Asm] 
// [Asm] # leaf false
// [Asm] energy.628:
// [Asm] # block info: defs: [v2, t1, ft0, ft1, a1, s11, fa1, fa2, ft6, a4, fa6, a6, ft5, ft10, ft7, ft4, v5, ft9, a5, a0, fa4, ft2, a2, a3, fv6, ft8, t3, a7, fa7, t0, fa5, fa3, ft3, fa0, t4, t2, v3], uses: [v3, a0, zero, fa0, a2, a1, s11, fv6, v2], upward_exposed: [s11, a0, zero], params_defs: []
// [Asm] # live_in: [s11, a0, zero], live_out: []
// [Asm] # block parameters: []
// [Asm] .energy.628_0:
// [Asm]   # save_ctx1  # live: [s11, zero, a0]
// [Asm]   mv v2, a0  # live: [s11, zero, v2]
// [Asm]   addi v3, s11, -8  # live: [v2, zero, v3]
// [Asm]   andi s11, v3, -8  # live: [v2, zero, v3]
// [Asm]   # save_ctx2  # live: [v2, zero, v3]
// [Asm]   mv a0, zero  # live: [v2, a0, v3]
// [Asm]   mv a1, v3  # live: [v2, a1, a0, v3]
// [Asm]   mv a2, v2  # live: [a2, a1, a0, v3]
// [Asm]   call loop_i.629  # live: [a0, v3]
// [Asm]   mv v5, a0  # live: [v3]
// [Asm]   # restore_ctx2  # live: [v3]
// [Asm]   fld fv6, 0(v3)  # live: [fv6]
// [Asm] # control
// [Asm]   fmv.d fa0, fv6  # live: [fa0]
// [Asm]   # restore_ctx1  # live: [fa0]
// [Asm]   ret  # live: []
// [Asm] 
// [Asm] # leaf false
// [Asm] minimbt_main:
// [Asm] # block info: defs: [t1, ft0, ft1, a1, s11, ra, fa1, fa2, ft6, a4, fa6, a6, ft5, ft10, ft7, ft4, ft9, a5, a0, fa4, ft2, a2, sp, a3, ft8, a7, t3, fa7, t0, fa5, fa3, ft3, fa0, t4, t2], uses: [sp, ra, s11, a0], upward_exposed: [ra, s11], params_defs: []
// [Asm] # live_in: [ra, s11], live_out: []
// [Asm] # block parameters: []
// [Asm] .minimbt_main_b0:
// [Asm]   addi sp, sp, -16  # live: [s11, ra]
// [Asm]   sd ra, 0(sp)  # live: [s11]
// [Asm]   sd s11, 8(sp)  # live: []
// [Asm]   la s11, large_heap_end  # live: []
// [Asm]   call main.631  # live: [a0]
// [Asm]   ld ra, 0(sp)  # live: [a0]
// [Asm]   ld s11, 8(sp)  # live: [a0]
// [Asm]   addi sp, sp, 16  # live: [a0]
// [Asm] # control
// [Asm]   ret  # live: []
// [Asm] 
// [Asm] # leaf false
// [Asm] update_axis.636:
// [Asm] # block info: defs: [v4, v44, fv3, v2], uses: [v2, a1, v44, a0, fa0], upward_exposed: [a1, a0, fa0], params_defs: []
// [Asm] # live_in: [a1, s11, a0, zero, fa0], live_out: [v4, s11, fv3, zero, v2]
// [Asm] # block parameters: []
// [Asm] .update_axis.636_0:
// [Asm]   # save_ctx1  # live: [zero, a0, fa0, a1, s11]
// [Asm]   mv v2, a0  # live: [zero, fa0, a1, s11, v2]
// [Asm]   fmv.d fv3, fa0  # live: [zero, a1, s11, fv3, v2]
// [Asm]   mv v4, a1  # live: [zero, v4, s11, fv3, v2]
// [Asm] # control
// [Asm]   li v44, 4  # live: [zero, v4, s11, v44, fv3, v2]
// [Asm]   blt v44, v2, .update_axis.636_2  # live: [v4, s11, fv3, zero, v2]
// [Asm] 
// [Asm] # block info: defs: [v25, fv10, t1, v26, v7, fv19, v41, fv12, ft0, ft1, a1, fv14, s11, fv15, fa1, fa2, v29, ft6, a4, fa6, v8, a6, ft10, ft5, fv21, ft7, ft4, v5, ft9, a5, a0, fa4, ft2, a2, v24, a3, ft8, t3, fv9, a7, fa7, t0, fa5, fa3, fv11, ft3, fv13, fa0, t4, t2, fv17], uses: [v2, fv10, v5, a0, v7, fv19, fv12, v41, a1, s11, v24, fv14, fv15, fv9, fv11, v29, zero, fv13, fa0, v8, v4, fv3, fv17, fv21], upward_exposed: [v4, s11, fv3, zero, v2], params_defs: []
// [Asm] # live_in: [v4, s11, fv3, zero, v2], live_out: [v26, zero]
// [Asm] # block parameters: []
// [Asm] .update_axis.636_1:
// [Asm]   slliw v7, v2, 3  # live: [v7, s11, zero, v4, fv3, v2]
// [Asm]   add v41, v4, v7  # live: [v7, v41, s11, zero, v4, fv3, v2]
// [Asm]   ld v8, 0(v41)  # live: [v7, s11, zero, v8, v4, fv3, v2]
// [Asm]   fld fv9, 0(v8)  # live: [v7, s11, fv9, zero, v8, v4, fv3, v2]
// [Asm]   fld fv10, 8(v8)  # live: [fv10, v7, s11, fv9, zero, v8, v4, fv3, v2]
// [Asm]   fld fv11, 16(v8)  # live: [fv10, v7, s11, fv9, zero, fv11, v8, v4, fv3, v2]
// [Asm]   fld fv12, 24(v8)  # live: [fv10, v7, fv12, s11, fv9, zero, fv11, v8, v4, fv3, v2]
// [Asm]   fld fv13, 32(v8)  # live: [fv10, v7, fv12, s11, fv9, zero, fv11, fv13, v8, v4, fv3, v2]
// [Asm]   fld fv14, 40(v8)  # live: [fv10, v7, fv12, fv14, s11, fv9, zero, fv11, fv13, v8, v4, fv3, v2]
// [Asm]   fld fv15, 48(v8)  # live: [fv10, v7, fv12, fv14, s11, fv15, fv9, zero, fv11, fv13, v4, fv3, v2]
// [Asm]   fmadd.d fv17, fv3, fv12, fv9  # live: [fv10, v7, fv12, fv14, s11, fv15, zero, fv11, fv13, v4, fv3, fv17, v2]
// [Asm]   fmadd.d fv19, fv3, fv13, fv10  # live: [v7, fv19, fv12, fv14, s11, fv15, zero, fv11, fv13, v4, fv3, fv17, v2]
// [Asm]   fmadd.d fv21, fv3, fv14, fv11  # live: [v2, v7, fv19, fv12, fv14, s11, fv15, zero, fv13, v4, fv3, fv17, fv21]
// [Asm]   addi v5, s11, -56  # live: [v2, v5, v7, fv19, fv12, fv14, fv15, zero, fv13, v4, fv3, fv17, fv21]
// [Asm]   andi s11, v5, -8  # live: [v2, v5, v7, fv19, fv12, fv14, fv15, zero, fv13, v4, fv3, fv17, fv21]
// [Asm]   fsd fv17, 0(v5)  # live: [v2, v5, zero, v7, fv13, fv19, fv12, v4, fv14, fv15, fv3, fv21]
// [Asm]   fsd fv19, 8(v5)  # live: [v5, zero, v7, fv13, v4, fv12, fv14, fv15, fv3, fv21, v2]
// [Asm]   fsd fv21, 16(v5)  # live: [v5, zero, v7, fv13, v4, fv12, fv14, fv15, fv3, v2]
// [Asm]   fsd fv12, 24(v5)  # live: [v5, zero, v7, fv13, v4, fv14, fv15, fv3, v2]
// [Asm]   fsd fv13, 32(v5)  # live: [v5, zero, v7, v4, fv14, fv15, fv3, v2]
// [Asm]   fsd fv14, 40(v5)  # live: [v5, zero, v7, v4, fv15, fv3, v2]
// [Asm]   fsd fv15, 48(v5)  # live: [v7, v4, v5, zero, fv3, v2]
// [Asm]   add v29, v4, v7  # live: [v2, v4, v5, zero, fv3, v29]
// [Asm]   sd v5, 0(v29)  # live: [v4, zero, fv3, v2]
// [Asm]   addi v24, v2, 1  # live: [v4, v24, zero, fv3]
// [Asm]   # save_ctx2  # live: [v4, v24, zero, fv3]
// [Asm]   mv a0, v24  # live: [v4, zero, a0, fv3]
// [Asm]   fmv.d fa0, fv3  # live: [v4, zero, a0, fa0]
// [Asm]   mv a1, v4  # live: [a1, zero, a0, fa0]
// [Asm]   call update_axis.636  # live: [zero, a0]
// [Asm]   mv v25, a0  # live: [zero]
// [Asm]   # restore_ctx2  # live: [zero]
// [Asm] # control
// [Asm]   mv v26, zero  # live: [v26, zero]
// [Asm] 
// [Asm] # block info: defs: [a0], uses: [zero, a0], upward_exposed: [zero], params_defs: [v26]
// [Asm] # live_in: [v26, zero], live_out: []
// [Asm] # block parameters: [v26]
// [Asm] .update_axis.636_3:
// [Asm] # control
// [Asm]   mv a0, zero  # live: [a0]
// [Asm]   # restore_ctx1  # live: [a0]
// [Asm]   ret  # live: []
// [Asm] 
// [Asm] # block info: defs: [v26], uses: [zero], upward_exposed: [zero], params_defs: []
// [Asm] # live_in: [zero], live_out: [v26, zero]
// [Asm] # block parameters: []
// [Asm] .update_axis.636_2:
// [Asm] # control
// [Asm]   mv v26, zero  # live: [v26, zero]
// [Asm]   j .update_axis.636_3  # live: [v26, zero]
// [Asm] 
// [Asm]   .p2align 3
// [Asm]   .rodata
// [Asm] solar_mass.4:
// [Asm]   .double 39.47841760435743
// [Asm]   .p2align 3
// [Asm]   .rodata
// [Asm] days_per_year.5:
// [Asm]   .double 365.24
// [Asm]   .p2align 2
// [Asm]   .bss
// [Asm] start:
// [Asm]   .zero 4
// [Asm]   .p2align 3
// [Asm]   .rodata
// [Asm] pi.1:
// [Asm]   .double 3.141592653589793
// [Asm]   .p2align 3
// [Asm]   .rodata
// [Asm] _2:
// [Asm]   .double 4
// [Asm]   .p2align 3
// [Asm]   .rodata
// [Asm] _3:
// [Asm]   .double 12.566370614359172
// [Asm] 
// [Main]   .option arch, +xtheadba, +xtheadfmemidx, +xtheadmemidx
// [Main]   .p2align 4
// [Main]   .bss
// [Main]   .type large_heap, @object
// [Main] large_heap:
// [Main]   .zero 1610612736
// [Main] large_heap_end:
// [Main] 
// [Main]   .p2align 4
// [Main]   .bss
// [Main]   .type large_stack, @object
// [Main] large_stack:
// [Main]   .zero 268435456
// [Main] large_stack_end:
// [Main] 
// [Main] __begin_text:
// [Main]   .p2align 2
// [Main]   .text
// [Main]   .globl loop_i.634
// [Main]   .type loop_i.634, @function
// [Main] # leaf false
// [Main] loop_i.634:
// [Main] .loop_i.634_0:
// [Main]   addi sp, sp, -32
// [Main]   sd ra, 0(sp)
// [Main]   sd s0, 8(sp)
// [Main]   sd s1, 16(sp)
// [Main]   fsd fs0, 24(sp)
// [Main]   mv s0, a0
// [Main]   fmv.d fs0, fa0
// [Main]   mv s1, a1
// [Main]   li a0, 4
// [Main]   blt a0, s0, .loop_i.634_2
// [Main] 
// [Main] .loop_i.634_1:
// [Main]   slliw a0, s0, 3
// [Main]   add a0, s1, a0
// [Main]   ld a0, 0(a0)
// [Main]   fld fa2, 0(a0)
// [Main]   fld fa3, 8(a0)
// [Main]   fld fa4, 16(a0)
// [Main]   fld fa5, 24(a0)
// [Main]   fld fa6, 32(a0)
// [Main]   fld fa7, 40(a0)
// [Main]   fld fa1, 48(a0)
// [Main]   addi a0, s0, 1
// [Main]   fmv.d fa0, fs0
// [Main]   mv a1, s0
// [Main]   mv a2, s1
// [Main]   call loop_j.635
// [Main]   addi a0, s0, 1
// [Main]   fmv.d fa0, fs0
// [Main]   mv a1, s1
// [Main]   call loop_i.634
// [Main]   mv a0, zero
// [Main] 
// [Main] .loop_i.634_3:
// [Main]   mv a0, zero
// [Main]   ld ra, 0(sp)
// [Main]   ld s0, 8(sp)
// [Main]   ld s1, 16(sp)
// [Main]   fld fs0, 24(sp)
// [Main]   addi sp, sp, 32
// [Main]   ret
// [Main] 
// [Main] .loop_i.634_2:
// [Main]   mv a0, zero
// [Main]   j .loop_i.634_3
// [Main] 
// [Main]   .p2align 2
// [Main]   .text
// [Main]   .globl loop_i.632
// [Main]   .type loop_i.632, @function
// [Main] # leaf false
// [Main] loop_i.632:
// [Main] .loop_i.632_0:
// [Main]   addi sp, sp, -16
// [Main]   sd ra, 0(sp)
// [Main]   li a5, 4
// [Main]   blt a5, a0, .loop_i.632_2
// [Main] 
// [Main] .loop_i.632_1:
// [Main]   slliw a5, a0, 3
// [Main]   add a5, a4, a5
// [Main]   ld a5, 0(a5)
// [Main]   fld fa0, 24(a5)
// [Main]   fld fa1, 32(a5)
// [Main]   fld fa2, 40(a5)
// [Main]   fld fa3, 48(a5)
// [Main]   fld fa4, 0(a1)
// [Main]   fmadd.d fa0, fa0, fa3, fa4
// [Main]   fsd fa0, 0(a1)
// [Main]   fld fa0, 0(a2)
// [Main]   fmadd.d fa0, fa1, fa3, fa0
// [Main]   fsd fa0, 0(a2)
// [Main]   fld fa0, 0(a3)
// [Main]   fmadd.d fa0, fa2, fa3, fa0
// [Main]   fsd fa0, 0(a3)
// [Main]   addi a0, a0, 1
// [Main]   call loop_i.632
// [Main]   mv a0, zero
// [Main] 
// [Main] .loop_i.632_3:
// [Main]   mv a0, zero
// [Main]   ld ra, 0(sp)
// [Main]   addi sp, sp, 16
// [Main]   ret
// [Main] 
// [Main] .loop_i.632_2:
// [Main]   mv a0, zero
// [Main]   j .loop_i.632_3
// [Main] 
// [Main]   .p2align 2
// [Main]   .text
// [Main]   .globl loop_i.633
// [Main]   .type loop_i.633, @function
// [Main] # leaf false
// [Main] loop_i.633:
// [Main] .loop_i.633_0:
// [Main]   addi sp, sp, -32
// [Main]   sd ra, 0(sp)
// [Main]   sd s0, 8(sp)
// [Main]   sd s1, 16(sp)
// [Main]   sd s2, 24(sp)
// [Main]   mv s2, a0
// [Main]   mv s0, a1
// [Main]   mv s1, a2
// [Main]   blt s0, s2, .loop_i.633_2
// [Main] 
// [Main] .loop_i.633_1:
// [Main]   mv a0, zero
// [Main]   li a1, 4576918229304087675
// [Main]   fmv.d.x fa0, a1
// [Main]   mv a1, s1
// [Main]   call loop_i.634
// [Main]   mv a0, zero
// [Main]   li a1, 4576918229304087675
// [Main]   fmv.d.x fa0, a1
// [Main]   mv a1, s1
// [Main]   call update_axis.636
// [Main]   addi a0, s2, 1
// [Main]   mv a1, s0
// [Main]   mv a2, s1
// [Main]   call loop_i.633
// [Main]   mv a0, zero
// [Main] 
// [Main] .loop_i.633_3:
// [Main]   mv a0, zero
// [Main]   ld ra, 0(sp)
// [Main]   ld s0, 8(sp)
// [Main]   ld s1, 16(sp)
// [Main]   ld s2, 24(sp)
// [Main]   addi sp, sp, 32
// [Main]   ret
// [Main] 
// [Main] .loop_i.633_2:
// [Main]   mv a0, zero
// [Main]   j .loop_i.633_3
// [Main] 
// [Main]   .p2align 2
// [Main]   .text
// [Main]   .globl loop_j.635
// [Main]   .type loop_j.635, @function
// [Main] # leaf false
// [Main] loop_j.635:
// [Main] .loop_j.635_0:
// [Main]   addi sp, sp, -32
// [Main]   sd ra, 0(sp)
// [Main]   fsd fs0, 8(sp)
// [Main]   fsd fs1, 16(sp)
// [Main]   fsd fs2, 24(sp)
// [Main]   li a3, 4
// [Main]   blt a3, a0, .loop_j.635_2
// [Main] 
// [Main] .loop_j.635_1:
// [Main]   slliw a3, a0, 3
// [Main]   add a4, a2, a3
// [Main]   ld a4, 0(a4)
// [Main]   fld ft0, 0(a4)
// [Main]   fld ft1, 8(a4)
// [Main]   fld ft2, 16(a4)
// [Main]   fld ft3, 24(a4)
// [Main]   fld ft4, 32(a4)
// [Main]   fld ft5, 40(a4)
// [Main]   fld ft6, 48(a4)
// [Main]   fsub.d ft7, fa2, ft0
// [Main]   fsub.d ft8, fa3, ft1
// [Main]   fsub.d ft9, fa4, ft2
// [Main]   fmul.d fs0, ft7, ft7
// [Main]   fmadd.d fs0, ft8, ft8, fs0
// [Main]   fmadd.d fs0, ft9, ft9, fs0
// [Main]   fsqrt.d fs1, fs0
// [Main]   fmul.d fs0, fs0, fs1
// [Main]   fdiv.d fs0, fa0, fs0
// [Main]   fmul.d ft7, ft7, ft6
// [Main]   fmul.d ft7, ft7, fs0
// [Main]   fsub.d fs1, fa5, ft7
// [Main]   fmul.d ft8, ft8, ft6
// [Main]   fmul.d ft8, ft8, fs0
// [Main]   fsub.d fs2, fa6, ft8
// [Main]   fmul.d ft9, ft9, ft6
// [Main]   fmul.d ft9, ft9, fs0
// [Main]   fsub.d fs0, fa7, ft9
// [Main]   addi a4, s11, -56
// [Main]   andi s11, a4, -8
// [Main]   fsd fa2, 0(a4)
// [Main]   fsd fa3, 8(a4)
// [Main]   fsd fa4, 16(a4)
// [Main]   fsd fs1, 24(a4)
// [Main]   fsd fs2, 32(a4)
// [Main]   fsd fs0, 40(a4)
// [Main]   fsd fa1, 48(a4)
// [Main]   slliw a5, a1, 3
// [Main]   add a5, a2, a5
// [Main]   sd a4, 0(a5)
// [Main]   fsub.d ft3, ft3, ft7
// [Main]   fsub.d ft4, ft4, ft8
// [Main]   fsub.d ft5, ft5, ft9
// [Main]   addi a4, s11, -56
// [Main]   andi s11, a4, -8
// [Main]   fsd ft0, 0(a4)
// [Main]   fsd ft1, 8(a4)
// [Main]   fsd ft2, 16(a4)
// [Main]   fsd ft3, 24(a4)
// [Main]   fsd ft4, 32(a4)
// [Main]   fsd ft5, 40(a4)
// [Main]   fsd ft6, 48(a4)
// [Main]   add a3, a2, a3
// [Main]   sd a4, 0(a3)
// [Main]   addi a0, a0, 1
// [Main]   call loop_j.635
// [Main]   mv a0, zero
// [Main] 
// [Main] .loop_j.635_3:
// [Main]   mv a0, zero
// [Main]   ld ra, 0(sp)
// [Main]   fld fs0, 8(sp)
// [Main]   fld fs1, 16(sp)
// [Main]   fld fs2, 24(sp)
// [Main]   addi sp, sp, 32
// [Main]   ret
// [Main] 
// [Main] .loop_j.635_2:
// [Main]   mv a0, zero
// [Main]   j .loop_j.635_3
// [Main] 
// [Main]   .p2align 2
// [Main]   .text
// [Main]   .globl loop_j.630
// [Main]   .type loop_j.630, @function
// [Main] # leaf false
// [Main] loop_j.630:
// [Main] .loop_j.630_0:
// [Main]   addi sp, sp, -16
// [Main]   sd ra, 0(sp)
// [Main]   li a3, 4
// [Main]   blt a3, a0, .loop_j.630_2
// [Main] 
// [Main] .loop_j.630_1:
// [Main]   slliw a3, a0, 3
// [Main]   add a3, a2, a3
// [Main]   ld a3, 0(a3)
// [Main]   fld fa4, 0(a3)
// [Main]   fld fa5, 8(a3)
// [Main]   fld fa6, 16(a3)
// [Main]   fld fa7, 48(a3)
// [Main]   fsub.d fa4, fa1, fa4
// [Main]   fsub.d fa5, fa2, fa5
// [Main]   fsub.d fa6, fa3, fa6
// [Main]   fmul.d fa4, fa4, fa4
// [Main]   fmadd.d fa4, fa5, fa5, fa4
// [Main]   fmadd.d fa4, fa6, fa6, fa4
// [Main]   fld fa5, 0(a1)
// [Main]   fmul.d fa6, fa0, fa7
// [Main]   fsqrt.d fa4, fa4
// [Main]   fdiv.d fa4, fa6, fa4
// [Main]   fsub.d fa4, fa5, fa4
// [Main]   fsd fa4, 0(a1)
// [Main]   addi a0, a0, 1
// [Main]   call loop_j.630
// [Main]   mv a0, zero
// [Main] 
// [Main] .loop_j.630_3:
// [Main]   mv a0, zero
// [Main]   ld ra, 0(sp)
// [Main]   addi sp, sp, 16
// [Main]   ret
// [Main] 
// [Main] .loop_j.630_2:
// [Main]   mv a0, zero
// [Main]   j .loop_j.630_3
// [Main] 
// [Main]   .p2align 2
// [Main]   .text
// [Main]   .globl main.631
// [Main]   .type main.631, @function
// [Main] # leaf false
// [Main] main.631:
// [Main] .main.631_0:
// [Main]   addi sp, sp, -48
// [Main]   sd ra, 0(sp)
// [Main]   sd s0, 8(sp)
// [Main]   sd s1, 16(sp)
// [Main]   sd s2, 24(sp)
// [Main]   sd s3, 32(sp)
// [Main]   addi a0, s11, -56
// [Main]   andi s11, a0, -8
// [Main]   li a1, 4617136985637443884
// [Main]   fmv.d.x fa0, a1
// [Main]   fsd fa0, 0(a0)
// [Main]   li a1, -4615467600764216452
// [Main]   fmv.d.x fa0, a1
// [Main]   fsd fa0, 8(a0)
// [Main]   li a1, -4631240860977730576
// [Main]   fmv.d.x fa0, a1
// [Main]   fsd fa0, 16(a0)
// [Main]   li a1, 4603636522180398268
// [Main]   fmv.d.x fa0, a1
// [Main]   fsd fa0, 24(a0)
// [Main]   li a1, 4613514450253485211
// [Main]   fmv.d.x fa0, a1
// [Main]   fsd fa0, 32(a0)
// [Main]   li a1, -4640446117579192555
// [Main]   fmv.d.x fa0, a1
// [Main]   fsd fa0, 40(a0)
// [Main]   li a1, 4585593052079010776
// [Main]   fmv.d.x fa0, a1
// [Main]   fsd fa0, 48(a0)
// [Main]   addi a1, s11, -56
// [Main]   andi s11, a1, -8
// [Main]   li a2, 4620886515960171111
// [Main]   fmv.d.x fa0, a2
// [Main]   fsd fa0, 0(a1)
// [Main]   li a2, 4616330128746480048
// [Main]   fmv.d.x fa0, a2
// [Main]   fsd fa0, 8(a1)
// [Main]   li a2, -4622431185293064580
// [Main]   fmv.d.x fa0, a2
// [Main]   fsd fa0, 16(a1)
// [Main]   li a2, -4616141094713322430
// [Main]   fmv.d.x fa0, a2
// [Main]   fsd fa0, 24(a1)
// [Main]   li a2, 4610900871547424531
// [Main]   fmv.d.x fa0, a2
// [Main]   fsd fa0, 32(a1)
// [Main]   li a2, 4576002370458991342
// [Main]   fmv.d.x fa0, a2
// [Main]   fsd fa0, 40(a1)
// [Main]   li a2, 4577659745833829943
// [Main]   fmv.d.x fa0, a2
// [Main]   fsd fa0, 48(a1)
// [Main]   addi a2, s11, -56
// [Main]   andi s11, a2, -8
// [Main]   li a3, 4623448502799161807
// [Main]   fmv.d.x fa0, a3
// [Main]   fsd fa0, 0(a2)
// [Main]   li a3, -4598675596822288770
// [Main]   fmv.d.x fa0, a3
// [Main]   fsd fa0, 8(a2)
// [Main]   li a3, -4626158513131520603
// [Main]   fmv.d.x fa0, a3
// [Main]   fsd fa0, 16(a2)
// [Main]   li a3, 4607555276345777135
// [Main]   fmv.d.x fa0, a3
// [Main]   fsd fa0, 24(a2)
// [Main]   li a3, 4605999890795117509
// [Main]   fmv.d.x fa0, a3
// [Main]   fsd fa0, 32(a2)
// [Main]   li a3, -4645973824767902084
// [Main]   fmv.d.x fa0, a3
// [Main]   fsd fa0, 40(a2)
// [Main]   li a3, 4565592097032511155
// [Main]   fmv.d.x fa0, a3
// [Main]   fsd fa0, 48(a2)
// [Main]   addi a3, s11, -56
// [Main]   andi s11, a3, -8
// [Main]   li a4, 4624847617829197610
// [Main]   fmv.d.x fa0, a4
// [Main]   fsd fa0, 0(a3)
// [Main]   li a4, -4595383180696444384
// [Main]   fmv.d.x fa0, a4
// [Main]   fsd fa0, 8(a3)
// [Main]   li a4, 4595626498235032896
// [Main]   fmv.d.x fa0, a4
// [Main]   fsd fa0, 16(a3)
// [Main]   li a4, 4606994084859067466
// [Main]   fmv.d.x fa0, a4
// [Main]   fsd fa0, 24(a3)
// [Main]   li a4, 4603531791922690979
// [Main]   fmv.d.x fa0, a4
// [Main]   fsd fa0, 32(a3)
// [Main]   li a4, -4638202354754755082
// [Main]   fmv.d.x fa0, a4
// [Main]   fsd fa0, 40(a3)
// [Main]   li a4, 4566835785178257837
// [Main]   fmv.d.x fa0, a4
// [Main]   fsd fa0, 48(a3)
// [Main]   fld fa0, solar_mass.4, t5
// [Main]   addi a4, s11, -56
// [Main]   andi s11, a4, -8
// [Main]   fmv.d.x fa1, zero
// [Main]   fsd fa1, 0(a4)
// [Main]   fsd fa1, 8(a4)
// [Main]   fsd fa1, 16(a4)
// [Main]   fsd fa1, 24(a4)
// [Main]   fsd fa1, 32(a4)
// [Main]   fsd fa1, 40(a4)
// [Main]   fsd fa0, 48(a4)
// [Main]   addi a5, s11, -56
// [Main]   andi s11, a5, -8
// [Main]   fmv.d.x fa0, zero
// [Main]   fsd fa0, 0(a5)
// [Main]   fsd fa0, 8(a5)
// [Main]   fsd fa0, 16(a5)
// [Main]   fsd fa0, 24(a5)
// [Main]   fsd fa0, 32(a5)
// [Main]   fsd fa0, 40(a5)
// [Main]   fsd fa0, 48(a5)
// [Main]   addi s0, s11, -40
// [Main]   andi s11, s0, -8
// [Main]   sd a5, 0(s0)
// [Main]   sd a5, 8(s0)
// [Main]   sd a5, 16(s0)
// [Main]   sd a5, 24(s0)
// [Main]   sd a5, 32(s0)
// [Main]   sd a4, 0(s0)
// [Main]   sd a0, 8(s0)
// [Main]   sd a1, 16(s0)
// [Main]   sd a2, 24(s0)
// [Main]   sd a3, 32(s0)
// [Main]   addi s1, s11, -8
// [Main]   andi s11, s1, -8
// [Main]   addi s2, s11, -8
// [Main]   andi s11, s2, -8
// [Main]   addi s3, s11, -8
// [Main]   andi s11, s3, -8
// [Main]   mv a0, zero
// [Main]   mv a1, s1
// [Main]   mv a2, s2
// [Main]   mv a3, s3
// [Main]   mv a4, s0
// [Main]   call loop_i.632
// [Main]   ld a0, 0(s0)
// [Main]   fld fa0, 0(a0)
// [Main]   fld fa1, 8(a0)
// [Main]   fld fa2, 16(a0)
// [Main]   fld fa3, 48(a0)
// [Main]   fld fa4, 0(s1)
// [Main]   fld fa5, solar_mass.4, t5
// [Main]   fdiv.d fa4, fa4, fa5
// [Main]   fneg.d fa4, fa4
// [Main]   fld fa6, 0(s2)
// [Main]   fdiv.d fa6, fa6, fa5
// [Main]   fneg.d fa6, fa6
// [Main]   fld fa7, 0(s3)
// [Main]   fdiv.d fa5, fa7, fa5
// [Main]   fneg.d fa5, fa5
// [Main]   addi a0, s11, -56
// [Main]   andi s11, a0, -8
// [Main]   fsd fa0, 0(a0)
// [Main]   fsd fa1, 8(a0)
// [Main]   fsd fa2, 16(a0)
// [Main]   fsd fa4, 24(a0)
// [Main]   fsd fa6, 32(a0)
// [Main]   fsd fa5, 40(a0)
// [Main]   fsd fa3, 48(a0)
// [Main]   sd a0, 0(s0)
// [Main]   mv a0, s0
// [Main]   call energy.628
// [Main]   li a0, 4741671816366391296
// [Main]   fmv.d.x fa1, a0
// [Main]   fmul.d fa0, fa0, fa1
// [Main]   fcvt.w.d a0, fa0, rtz
// [Main]   call minimbt_print_int
// [Main]   li a0, 1
// [Main]   li a1, 500000
// [Main]   mv a2, s0
// [Main]   call loop_i.633
// [Main]   li a0, 10
// [Main]   call minimbt_print_char
// [Main]   mv a0, s0
// [Main]   call energy.628
// [Main]   li a0, 4741671816366391296
// [Main]   fmv.d.x fa1, a0
// [Main]   fmul.d fa0, fa0, fa1
// [Main]   fcvt.w.d a0, fa0, rtz
// [Main]   call minimbt_print_int
// [Main]   mv a0, zero
// [Main]   ld ra, 0(sp)
// [Main]   ld s0, 8(sp)
// [Main]   ld s1, 16(sp)
// [Main]   ld s2, 24(sp)
// [Main]   ld s3, 32(sp)
// [Main]   addi sp, sp, 48
// [Main]   ret
// [Main] 
// [Main]   .p2align 2
// [Main]   .text
// [Main]   .globl loop_i.629
// [Main]   .type loop_i.629, @function
// [Main] # leaf false
// [Main] loop_i.629:
// [Main] .loop_i.629_0:
// [Main]   addi sp, sp, -32
// [Main]   sd ra, 0(sp)
// [Main]   sd s0, 8(sp)
// [Main]   sd s1, 16(sp)
// [Main]   sd s2, 24(sp)
// [Main]   mv s0, a0
// [Main]   mv s2, a1
// [Main]   mv s1, a2
// [Main]   li a0, 4
// [Main]   blt a0, s0, .loop_i.629_2
// [Main] 
// [Main] .loop_i.629_1:
// [Main]   slliw a0, s0, 3
// [Main]   add a0, s1, a0
// [Main]   ld a0, 0(a0)
// [Main]   fld fa1, 0(a0)
// [Main]   fld fa2, 8(a0)
// [Main]   fld fa3, 16(a0)
// [Main]   fld fa0, 24(a0)
// [Main]   fld fa4, 32(a0)
// [Main]   fld fa5, 40(a0)
// [Main]   fld fa6, 48(a0)
// [Main]   fld fa7, 0(s2)
// [Main]   li a0, 4602678819172646912
// [Main]   fmv.d.x ft0, a0
// [Main]   fmul.d ft0, ft0, fa6
// [Main]   fmul.d fa0, fa0, fa0
// [Main]   fmadd.d fa0, fa4, fa4, fa0
// [Main]   fmadd.d fa0, fa5, fa5, fa0
// [Main]   fmadd.d fa0, ft0, fa0, fa7
// [Main]   fsd fa0, 0(s2)
// [Main]   addi a0, s0, 1
// [Main]   mv a1, s2
// [Main]   fmv.d fa0, fa6
// [Main]   mv a2, s1
// [Main]   call loop_j.630
// [Main]   addi a0, s0, 1
// [Main]   mv a1, s2
// [Main]   mv a2, s1
// [Main]   call loop_i.629
// [Main]   mv a0, zero
// [Main] 
// [Main] .loop_i.629_3:
// [Main]   mv a0, zero
// [Main]   ld ra, 0(sp)
// [Main]   ld s0, 8(sp)
// [Main]   ld s1, 16(sp)
// [Main]   ld s2, 24(sp)
// [Main]   addi sp, sp, 32
// [Main]   ret
// [Main] 
// [Main] .loop_i.629_2:
// [Main]   mv a0, zero
// [Main]   j .loop_i.629_3
// [Main] 
// [Main]   .p2align 2
// [Main]   .text
// [Main]   .globl energy.628
// [Main]   .type energy.628, @function
// [Main] # leaf false
// [Main] energy.628:
// [Main] .energy.628_0:
// [Main]   addi sp, sp, -16
// [Main]   sd ra, 0(sp)
// [Main]   sd s0, 8(sp)
// [Main]   mv a2, a0
// [Main]   addi s0, s11, -8
// [Main]   andi s11, s0, -8
// [Main]   mv a0, zero
// [Main]   mv a1, s0
// [Main]   call loop_i.629
// [Main]   fld fa0, 0(s0)
// [Main]   ld ra, 0(sp)
// [Main]   ld s0, 8(sp)
// [Main]   addi sp, sp, 16
// [Main]   ret
// [Main] 
// [Main]   .p2align 2
// [Main]   .text
// [Main]   .globl minimbt_main
// [Main]   .type minimbt_main, @function
// [Main] # leaf false
// [Main] minimbt_main:
// [Main] .minimbt_main_b0:
// [Main]   addi sp, sp, -16
// [Main]   sd ra, 0(sp)
// [Main]   sd s11, 8(sp)
// [Main]   la s11, large_heap_end
// [Main]   call main.631
// [Main]   ld ra, 0(sp)
// [Main]   ld s11, 8(sp)
// [Main]   addi sp, sp, 16
// [Main]   ret
// [Main] 
// [Main]   .p2align 2
// [Main]   .text
// [Main]   .globl update_axis.636
// [Main]   .type update_axis.636, @function
// [Main] # leaf false
// [Main] update_axis.636:
// [Main] .update_axis.636_0:
// [Main]   addi sp, sp, -16
// [Main]   sd ra, 0(sp)
// [Main]   li a2, 4
// [Main]   blt a2, a0, .update_axis.636_2
// [Main] 
// [Main] .update_axis.636_1:
// [Main]   slliw a2, a0, 3
// [Main]   add a3, a1, a2
// [Main]   ld a3, 0(a3)
// [Main]   fld fa1, 0(a3)
// [Main]   fld fa2, 8(a3)
// [Main]   fld fa3, 16(a3)
// [Main]   fld fa4, 24(a3)
// [Main]   fld fa5, 32(a3)
// [Main]   fld fa6, 40(a3)
// [Main]   fld fa7, 48(a3)
// [Main]   fmadd.d fa1, fa0, fa4, fa1
// [Main]   fmadd.d fa2, fa0, fa5, fa2
// [Main]   fmadd.d fa3, fa0, fa6, fa3
// [Main]   addi a3, s11, -56
// [Main]   andi s11, a3, -8
// [Main]   fsd fa1, 0(a3)
// [Main]   fsd fa2, 8(a3)
// [Main]   fsd fa3, 16(a3)
// [Main]   fsd fa4, 24(a3)
// [Main]   fsd fa5, 32(a3)
// [Main]   fsd fa6, 40(a3)
// [Main]   fsd fa7, 48(a3)
// [Main]   add a2, a1, a2
// [Main]   sd a3, 0(a2)
// [Main]   addi a0, a0, 1
// [Main]   call update_axis.636
// [Main]   mv a0, zero
// [Main] 
// [Main] .update_axis.636_3:
// [Main]   mv a0, zero
// [Main]   ld ra, 0(sp)
// [Main]   addi sp, sp, 16
// [Main]   ret
// [Main] 
// [Main] .update_axis.636_2:
// [Main]   mv a0, zero
// [Main]   j .update_axis.636_3
// [Main] 
// [Main] __end_text:
// [Main]   .p2align 3
// [Main]   .rodata
// [Main]   .globl solar_mass.4
// [Main]   .type solar_mass.4, @object
// [Main] solar_mass.4:
// [Main]   .double 39.47841760435743
// [Main] 
// [Main]   .p2align 3
// [Main]   .rodata
// [Main]   .globl days_per_year.5
// [Main]   .type days_per_year.5, @object
// [Main] days_per_year.5:
// [Main]   .double 365.24
// [Main] 
// [Main]   .p2align 2
// [Main]   .bss
// [Main]   .globl start
// [Main]   .type start, @object
// [Main] start:
// [Main]   .zero 4
// [Main] 
// [Main]   .p2align 3
// [Main]   .rodata
// [Main]   .globl pi.1
// [Main]   .type pi.1, @object
// [Main] pi.1:
// [Main]   .double 3.141592653589793
// [Main] 
// [Main]   .p2align 3
// [Main]   .rodata
// [Main]   .globl _2
// [Main]   .type _2, @object
// [Main] _2:
// [Main]   .double 4
// [Main] 
// [Main]   .p2align 3
// [Main]   .rodata
// [Main]   .globl _3
// [Main]   .type _3, @object
// [Main] _3:
// [Main]   .double 12.566370614359172
// [Main] 
// [Main] 
// [Typer] resolve: Let(("pi", Double), Double(3.141592653589793), Let(("solar_mass", Double), Prim(Prim(Double(4), Var("pi"), Mul, kind=None), Var("pi"), Mul, kind=None), Let(("days_per_year", Double), Double(365.24), LetRec({tyvars: [], name: ("advance", Unit), args: [("bodies", Array[(Double, Double, Double, Double, Double, Double, Double)]), ("dt", Double)], body: Let(("n", Var(None)), Int(5), LetRec({tyvars: [], name: ("loop_i", Var(None)), args: [("i", Int)], body: Let(("_", Var(None)), If(LE(Var("i"), Prim(Var("n"), Int(1), Sub, kind=None)), Let(("b", Var(None)), Get(Var("bodies"), Var("i")), LetTuple([("bx", Var(None)), ("by", Var(None)), ("bz", Var(None)), ("bvx", Var(None)), ("bvy", Var(None)), ("bvz", Var(None)), ("bm", Var(None))], Var("b"), LetRec({tyvars: [], name: ("loop_j", Var(None)), args: [("j", Int)], body: Let(("_", Var(None)), If(LE(Var("j"), Prim(Var("n"), Int(1), Sub, kind=None)), Let(("b2", Var(None)), Get(Var("bodies"), Var("j")), LetTuple([("b2x", Var(None)), ("b2y", Var(None)), ("b2z", Var(None)), ("b2vx", Var(None)), ("b2vy", Var(None)), ("b2vz", Var(None)), ("b2m", Var(None))], Var("b2"), Let(("dx", Var(None)), Prim(Var("bx"), Var("b2x"), Sub, kind=None), Let(("dy", Var(None)), Prim(Var("by"), Var("b2y"), Sub, kind=None), Let(("dz", Var(None)), Prim(Var("bz"), Var("b2z"), Sub, kind=None), Let(("dist2", Var(None)), Prim(Prim(Prim(Var("dx"), Var("dx"), Mul, kind=None), Prim(Var("dy"), Var("dy"), Mul, kind=None), Add, kind=None), Prim(Var("dz"), Var("dz"), Mul, kind=None), Add, kind=None), Let(("mag", Var(None)), Prim(Var("dt"), Prim(Var("dist2"), App(Var("sqrt"), targs=None, [Var("dist2")]), Mul, kind=None), Div, kind=None), Let(("new_b", Var(None)), Tuple([Var("bx"), Var("by"), Var("bz"), Prim(Var("bvx"), Prim(Prim(Var("dx"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Prim(Var("bvy"), Prim(Prim(Var("dy"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Prim(Var("bvz"), Prim(Prim(Var("dz"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Var("bm")]), Let(("_", Var(None)), Put(Var("bodies"), Var("i"), Var("new_b")), Let(("new_b2", Var(None)), Tuple([Var("b2x"), Var("b2y"), Var("b2z"), Prim(Var("b2vx"), Prim(Prim(Var("dx"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Prim(Var("b2vy"), Prim(Prim(Var("dy"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Prim(Var("b2vz"), Prim(Prim(Var("dz"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Var("b2m")]), Let(("_", Var(None)), Put(Var("bodies"), Var("j"), Var("new_b2")), Let(("_", Var(None)), App(Var("loop_j"), targs=None, [Prim(Var("j"), Int(1), Add, kind=None)]), Unit)))))))))))), Unit), Unit)}, Let(("_", Var(None)), App(Var("loop_j"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Unit))))), Unit), Unit)}, Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Int(0)]), LetRec({tyvars: [], name: ("update_axis", Var(None)), args: [("i", Int)], body: Let(("_", Var(None)), If(LE(Var("i"), Prim(Var("n"), Int(1), Sub, kind=None)), Let(("b", Var(None)), Get(Var("bodies"), Var("i")), LetTuple([("bx", Var(None)), ("by", Var(None)), ("bz", Var(None)), ("bvx", Var(None)), ("bvy", Var(None)), ("bvz", Var(None)), ("bm", Var(None))], Var("b"), Let(("new_b", Var(None)), Tuple([Prim(Var("bx"), Prim(Var("dt"), Var("bvx"), Mul, kind=None), Add, kind=None), Prim(Var("by"), Prim(Var("dt"), Var("bvy"), Mul, kind=None), Add, kind=None), Prim(Var("bz"), Prim(Var("dt"), Var("bvz"), Mul, kind=None), Add, kind=None), Var("bvx"), Var("bvy"), Var("bvz"), Var("bm")]), Let(("_", Var(None)), Put(Var("bodies"), Var("i"), Var("new_b")), Let(("_", Var(None)), App(Var("update_axis"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Unit))))), Unit), Unit)}, Let(("_", Var(None)), App(Var("update_axis"), targs=None, [Int(0)]), Unit)))))}, LetRec({tyvars: [], name: ("energy", Double), args: [("bodies", Array[(Double, Double, Double, Double, Double, Double, Double)])], body: Let(("n", Var(None)), Int(5), Let(("e", Var(None)), Array(Int(1), Double(0)), LetRec({tyvars: [], name: ("loop_i", Var(None)), args: [("i", Int)], body: Let(("_", Var(None)), If(LE(Var("i"), Prim(Var("n"), Int(1), Sub, kind=None)), Let(("b", Var(None)), Get(Var("bodies"), Var("i")), LetTuple([("bx", Var(None)), ("by", Var(None)), ("bz", Var(None)), ("bvx", Var(None)), ("bvy", Var(None)), ("bvz", Var(None)), ("bm", Var(None))], Var("b"), Let(("_", Var(None)), Put(Var("e"), Int(0), Prim(Get(Var("e"), Int(0)), Prim(Prim(Double(0.5), Var("bm"), Mul, kind=None), Prim(Prim(Prim(Var("bvx"), Var("bvx"), Mul, kind=None), Prim(Var("bvy"), Var("bvy"), Mul, kind=None), Add, kind=None), Prim(Var("bvz"), Var("bvz"), Mul, kind=None), Add, kind=None), Mul, kind=None), Add, kind=None)), LetRec({tyvars: [], name: ("loop_j", Var(None)), args: [("j", Int)], body: Let(("_", Var(None)), If(LE(Var("j"), Prim(Var("n"), Int(1), Sub, kind=None)), Let(("b2", Var(None)), Get(Var("bodies"), Var("j")), LetTuple([("b2x", Var(None)), ("b2y", Var(None)), ("b2z", Var(None)), ("b2vx", Var(None)), ("b2vy", Var(None)), ("b2vz", Var(None)), ("b2m", Var(None))], Var("b2"), Let(("dx", Var(None)), Prim(Var("bx"), Var("b2x"), Sub, kind=None), Let(("dy", Var(None)), Prim(Var("by"), Var("b2y"), Sub, kind=None), Let(("dz", Var(None)), Prim(Var("bz"), Var("b2z"), Sub, kind=None), Let(("dist2", Var(None)), Prim(Prim(Prim(Var("dx"), Var("dx"), Mul, kind=None), Prim(Var("dy"), Var("dy"), Mul, kind=None), Add, kind=None), Prim(Var("dz"), Var("dz"), Mul, kind=None), Add, kind=None), Let(("_", Var(None)), Put(Var("e"), Int(0), Prim(Get(Var("e"), Int(0)), Prim(Prim(Var("bm"), Var("b2m"), Mul, kind=None), App(Var("sqrt"), targs=None, [Var("dist2")]), Div, kind=None), Sub, kind=None)), Let(("_", Var(None)), App(Var("loop_j"), targs=None, [Prim(Var("j"), Int(1), Add, kind=None)]), Unit)))))))), Unit), Unit)}, Let(("_", Var(None)), App(Var("loop_j"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Unit)))))), Unit), Unit)}, Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Int(0)]), Get(Var("e"), Int(0))))))}, LetRec({tyvars: [], name: ("offset_momentum", Unit), args: [("bodies", Array[(Double, Double, Double, Double, Double, Double, Double)])], body: Let(("n", Var(None)), Int(5), Let(("px", Var(None)), Array(Int(1), Double(0)), Let(("py", Var(None)), Array(Int(1), Double(0)), Let(("pz", Var(None)), Array(Int(1), Double(0)), LetRec({tyvars: [], name: ("loop_i", Var(None)), args: [("i", Int)], body: Let(("_", Var(None)), If(LE(Var("i"), Prim(Var("n"), Int(1), Sub, kind=None)), Let(("b", Var(None)), Get(Var("bodies"), Var("i")), LetTuple([("bx", Var(None)), ("by", Var(None)), ("bz", Var(None)), ("bvx", Var(None)), ("bvy", Var(None)), ("bvz", Var(None)), ("bm", Var(None))], Var("b"), Let(("_", Var(None)), Put(Var("px"), Int(0), Prim(Get(Var("px"), Int(0)), Prim(Var("bvx"), Var("bm"), Mul, kind=None), Add, kind=None)), Let(("_", Var(None)), Put(Var("py"), Int(0), Prim(Get(Var("py"), Int(0)), Prim(Var("bvy"), Var("bm"), Mul, kind=None), Add, kind=None)), Let(("_", Var(None)), Put(Var("pz"), Int(0), Prim(Get(Var("pz"), Int(0)), Prim(Var("bvz"), Var("bm"), Mul, kind=None), Add, kind=None)), Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Unit)))))), Unit), Unit)}, Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Int(0)]), Let(("b", Var(None)), Get(Var("bodies"), Int(0)), LetTuple([("bx", Var(None)), ("by", Var(None)), ("bz", Var(None)), ("bvx", Var(None)), ("bvy", Var(None)), ("bvz", Var(None)), ("bm", Var(None))], Var("b"), Let(("new_b", Var(None)), Tuple([Var("bx"), Var("by"), Var("bz"), Neg(Prim(Get(Var("px"), Int(0)), Var("solar_mass"), Div, kind=None), kind=None), Neg(Prim(Get(Var("py"), Int(0)), Var("solar_mass"), Div, kind=None), kind=None), Neg(Prim(Get(Var("pz"), Int(0)), Var("solar_mass"), Div, kind=None), kind=None), Var("bm")]), Let(("_", Var(None)), Put(Var("bodies"), Int(0), Var("new_b")), Unit))))))))))}, LetRec({tyvars: [], name: ("main", Var(None)), args: [], body: Let(("jupiter", Var(None)), Tuple([Double(4.841431442464721), Neg(Double(1.1603200440274284), kind=None), Neg(Double(0.10362204447112311), kind=None), Prim(Double(0.001660076642744037), Var("days_per_year"), Mul, kind=None), Prim(Double(0.007699011184197404), Var("days_per_year"), Mul, kind=None), Neg(Prim(Double(0.0000690460016972063), Var("days_per_year"), Mul, kind=None), kind=None), Prim(Double(0.0009547919384243266), Var("solar_mass"), Mul, kind=None)]), Let(("saturn", Var(None)), Tuple([Double(8.34336671824458), Double(4.124798564124305), Neg(Double(0.4035234171143214), kind=None), Neg(Prim(Double(0.002767425107268624), Var("days_per_year"), Mul, kind=None), kind=None), Prim(Double(0.004998528012349172), Var("days_per_year"), Mul, kind=None), Prim(Double(0.000023029345528229068), Var("days_per_year"), Mul, kind=None), Prim(Double(0.0002858859806661308), Var("solar_mass"), Mul, kind=None)]), Let(("uranus", Var(None)), Tuple([Double(12.894369562139131), Neg(Double(15.111151401698631), kind=None), Neg(Double(0.22330757889265587), kind=None), Prim(Double(0.002964601375647616), Var("days_per_year"), Mul, kind=None), Prim(Double(0.0023784717395948095), Var("days_per_year"), Mul, kind=None), Neg(Prim(Double(0.000029658956854023756), Var("days_per_year"), Mul, kind=None), kind=None), Prim(Double(0.00004366244043351563), Var("solar_mass"), Mul, kind=None)]), Let(("neptune", Var(None)), Tuple([Double(15.379697114850917), Neg(Double(25.919314609987964), kind=None), Double(0.17925877295037118), Prim(Double(0.0026806777249038932), Var("days_per_year"), Mul, kind=None), Prim(Double(0.001628241700382423), Var("days_per_year"), Mul, kind=None), Neg(Prim(Double(0.00009515922545197159), Var("days_per_year"), Mul, kind=None), kind=None), Prim(Double(0.00005151389020466116), Var("solar_mass"), Mul, kind=None)]), Let(("sun", Var(None)), Tuple([Double(0), Double(0), Double(0), Double(0), Double(0), Double(0), Var("solar_mass")]), Let(("bodies", Var(None)), Array(Int(5), Tuple([Double(0), Double(0), Double(0), Double(0), Double(0), Double(0), Double(0)])), Let(("_", Var(None)), Put(Var("bodies"), Int(0), Var("sun")), Let(("_", Var(None)), Put(Var("bodies"), Int(1), Var("jupiter")), Let(("_", Var(None)), Put(Var("bodies"), Int(2), Var("saturn")), Let(("_", Var(None)), Put(Var("bodies"), Int(3), Var("uranus")), Let(("_", Var(None)), Put(Var("bodies"), Int(4), Var("neptune")), Let(("_", Var(None)), App(Var("offset_momentum"), targs=None, [Var("bodies")]), Let(("_", Var(None)), App(Var("print_int"), targs=None, [App(Var("int_of_float"), targs=None, [Prim(App(Var("energy"), targs=None, [Var("bodies")]), Double(1000000000), Mul, kind=None)])]), Let(("iters", Var(None)), Int(500000), LetRec({tyvars: [], name: ("loop_i", Var(None)), args: [("i", Int)], body: Let(("_", Var(None)), If(LE(Var("i"), Var("iters")), Let(("_", Var(None)), App(Var("advance"), targs=None, [Var("bodies"), Double(0.01)]), Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Unit)), Unit), Unit)}, Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Int(1)]), Let(("_", Var(None)), App(Var("print_char"), targs=None, [Int(10)]), Let(("_", Var(None)), App(Var("print_int"), targs=None, [App(Var("int_of_float"), targs=None, [Prim(App(Var("energy"), targs=None, [Var("bodies")]), Double(1000000000), Mul, kind=None)])]), Unit))))))))))))))))))}, Unit)))))))
// [Typer] resolve: Double(3.141592653589793)
// [Typer] resolve: Let(("solar_mass", Double), Prim(Prim(Double(4), Var("pi"), Mul, kind=None), Var("pi"), Mul, kind=None), Let(("days_per_year", Double), Double(365.24), LetRec({tyvars: [], name: ("advance", Unit), args: [("bodies", Array[(Double, Double, Double, Double, Double, Double, Double)]), ("dt", Double)], body: Let(("n", Var(None)), Int(5), LetRec({tyvars: [], name: ("loop_i", Var(None)), args: [("i", Int)], body: Let(("_", Var(None)), If(LE(Var("i"), Prim(Var("n"), Int(1), Sub, kind=None)), Let(("b", Var(None)), Get(Var("bodies"), Var("i")), LetTuple([("bx", Var(None)), ("by", Var(None)), ("bz", Var(None)), ("bvx", Var(None)), ("bvy", Var(None)), ("bvz", Var(None)), ("bm", Var(None))], Var("b"), LetRec({tyvars: [], name: ("loop_j", Var(None)), args: [("j", Int)], body: Let(("_", Var(None)), If(LE(Var("j"), Prim(Var("n"), Int(1), Sub, kind=None)), Let(("b2", Var(None)), Get(Var("bodies"), Var("j")), LetTuple([("b2x", Var(None)), ("b2y", Var(None)), ("b2z", Var(None)), ("b2vx", Var(None)), ("b2vy", Var(None)), ("b2vz", Var(None)), ("b2m", Var(None))], Var("b2"), Let(("dx", Var(None)), Prim(Var("bx"), Var("b2x"), Sub, kind=None), Let(("dy", Var(None)), Prim(Var("by"), Var("b2y"), Sub, kind=None), Let(("dz", Var(None)), Prim(Var("bz"), Var("b2z"), Sub, kind=None), Let(("dist2", Var(None)), Prim(Prim(Prim(Var("dx"), Var("dx"), Mul, kind=None), Prim(Var("dy"), Var("dy"), Mul, kind=None), Add, kind=None), Prim(Var("dz"), Var("dz"), Mul, kind=None), Add, kind=None), Let(("mag", Var(None)), Prim(Var("dt"), Prim(Var("dist2"), App(Var("sqrt"), targs=None, [Var("dist2")]), Mul, kind=None), Div, kind=None), Let(("new_b", Var(None)), Tuple([Var("bx"), Var("by"), Var("bz"), Prim(Var("bvx"), Prim(Prim(Var("dx"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Prim(Var("bvy"), Prim(Prim(Var("dy"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Prim(Var("bvz"), Prim(Prim(Var("dz"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Var("bm")]), Let(("_", Var(None)), Put(Var("bodies"), Var("i"), Var("new_b")), Let(("new_b2", Var(None)), Tuple([Var("b2x"), Var("b2y"), Var("b2z"), Prim(Var("b2vx"), Prim(Prim(Var("dx"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Prim(Var("b2vy"), Prim(Prim(Var("dy"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Prim(Var("b2vz"), Prim(Prim(Var("dz"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Var("b2m")]), Let(("_", Var(None)), Put(Var("bodies"), Var("j"), Var("new_b2")), Let(("_", Var(None)), App(Var("loop_j"), targs=None, [Prim(Var("j"), Int(1), Add, kind=None)]), Unit)))))))))))), Unit), Unit)}, Let(("_", Var(None)), App(Var("loop_j"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Unit))))), Unit), Unit)}, Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Int(0)]), LetRec({tyvars: [], name: ("update_axis", Var(None)), args: [("i", Int)], body: Let(("_", Var(None)), If(LE(Var("i"), Prim(Var("n"), Int(1), Sub, kind=None)), Let(("b", Var(None)), Get(Var("bodies"), Var("i")), LetTuple([("bx", Var(None)), ("by", Var(None)), ("bz", Var(None)), ("bvx", Var(None)), ("bvy", Var(None)), ("bvz", Var(None)), ("bm", Var(None))], Var("b"), Let(("new_b", Var(None)), Tuple([Prim(Var("bx"), Prim(Var("dt"), Var("bvx"), Mul, kind=None), Add, kind=None), Prim(Var("by"), Prim(Var("dt"), Var("bvy"), Mul, kind=None), Add, kind=None), Prim(Var("bz"), Prim(Var("dt"), Var("bvz"), Mul, kind=None), Add, kind=None), Var("bvx"), Var("bvy"), Var("bvz"), Var("bm")]), Let(("_", Var(None)), Put(Var("bodies"), Var("i"), Var("new_b")), Let(("_", Var(None)), App(Var("update_axis"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Unit))))), Unit), Unit)}, Let(("_", Var(None)), App(Var("update_axis"), targs=None, [Int(0)]), Unit)))))}, LetRec({tyvars: [], name: ("energy", Double), args: [("bodies", Array[(Double, Double, Double, Double, Double, Double, Double)])], body: Let(("n", Var(None)), Int(5), Let(("e", Var(None)), Array(Int(1), Double(0)), LetRec({tyvars: [], name: ("loop_i", Var(None)), args: [("i", Int)], body: Let(("_", Var(None)), If(LE(Var("i"), Prim(Var("n"), Int(1), Sub, kind=None)), Let(("b", Var(None)), Get(Var("bodies"), Var("i")), LetTuple([("bx", Var(None)), ("by", Var(None)), ("bz", Var(None)), ("bvx", Var(None)), ("bvy", Var(None)), ("bvz", Var(None)), ("bm", Var(None))], Var("b"), Let(("_", Var(None)), Put(Var("e"), Int(0), Prim(Get(Var("e"), Int(0)), Prim(Prim(Double(0.5), Var("bm"), Mul, kind=None), Prim(Prim(Prim(Var("bvx"), Var("bvx"), Mul, kind=None), Prim(Var("bvy"), Var("bvy"), Mul, kind=None), Add, kind=None), Prim(Var("bvz"), Var("bvz"), Mul, kind=None), Add, kind=None), Mul, kind=None), Add, kind=None)), LetRec({tyvars: [], name: ("loop_j", Var(None)), args: [("j", Int)], body: Let(("_", Var(None)), If(LE(Var("j"), Prim(Var("n"), Int(1), Sub, kind=None)), Let(("b2", Var(None)), Get(Var("bodies"), Var("j")), LetTuple([("b2x", Var(None)), ("b2y", Var(None)), ("b2z", Var(None)), ("b2vx", Var(None)), ("b2vy", Var(None)), ("b2vz", Var(None)), ("b2m", Var(None))], Var("b2"), Let(("dx", Var(None)), Prim(Var("bx"), Var("b2x"), Sub, kind=None), Let(("dy", Var(None)), Prim(Var("by"), Var("b2y"), Sub, kind=None), Let(("dz", Var(None)), Prim(Var("bz"), Var("b2z"), Sub, kind=None), Let(("dist2", Var(None)), Prim(Prim(Prim(Var("dx"), Var("dx"), Mul, kind=None), Prim(Var("dy"), Var("dy"), Mul, kind=None), Add, kind=None), Prim(Var("dz"), Var("dz"), Mul, kind=None), Add, kind=None), Let(("_", Var(None)), Put(Var("e"), Int(0), Prim(Get(Var("e"), Int(0)), Prim(Prim(Var("bm"), Var("b2m"), Mul, kind=None), App(Var("sqrt"), targs=None, [Var("dist2")]), Div, kind=None), Sub, kind=None)), Let(("_", Var(None)), App(Var("loop_j"), targs=None, [Prim(Var("j"), Int(1), Add, kind=None)]), Unit)))))))), Unit), Unit)}, Let(("_", Var(None)), App(Var("loop_j"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Unit)))))), Unit), Unit)}, Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Int(0)]), Get(Var("e"), Int(0))))))}, LetRec({tyvars: [], name: ("offset_momentum", Unit), args: [("bodies", Array[(Double, Double, Double, Double, Double, Double, Double)])], body: Let(("n", Var(None)), Int(5), Let(("px", Var(None)), Array(Int(1), Double(0)), Let(("py", Var(None)), Array(Int(1), Double(0)), Let(("pz", Var(None)), Array(Int(1), Double(0)), LetRec({tyvars: [], name: ("loop_i", Var(None)), args: [("i", Int)], body: Let(("_", Var(None)), If(LE(Var("i"), Prim(Var("n"), Int(1), Sub, kind=None)), Let(("b", Var(None)), Get(Var("bodies"), Var("i")), LetTuple([("bx", Var(None)), ("by", Var(None)), ("bz", Var(None)), ("bvx", Var(None)), ("bvy", Var(None)), ("bvz", Var(None)), ("bm", Var(None))], Var("b"), Let(("_", Var(None)), Put(Var("px"), Int(0), Prim(Get(Var("px"), Int(0)), Prim(Var("bvx"), Var("bm"), Mul, kind=None), Add, kind=None)), Let(("_", Var(None)), Put(Var("py"), Int(0), Prim(Get(Var("py"), Int(0)), Prim(Var("bvy"), Var("bm"), Mul, kind=None), Add, kind=None)), Let(("_", Var(None)), Put(Var("pz"), Int(0), Prim(Get(Var("pz"), Int(0)), Prim(Var("bvz"), Var("bm"), Mul, kind=None), Add, kind=None)), Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Unit)))))), Unit), Unit)}, Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Int(0)]), Let(("b", Var(None)), Get(Var("bodies"), Int(0)), LetTuple([("bx", Var(None)), ("by", Var(None)), ("bz", Var(None)), ("bvx", Var(None)), ("bvy", Var(None)), ("bvz", Var(None)), ("bm", Var(None))], Var("b"), Let(("new_b", Var(None)), Tuple([Var("bx"), Var("by"), Var("bz"), Neg(Prim(Get(Var("px"), Int(0)), Var("solar_mass"), Div, kind=None), kind=None), Neg(Prim(Get(Var("py"), Int(0)), Var("solar_mass"), Div, kind=None), kind=None), Neg(Prim(Get(Var("pz"), Int(0)), Var("solar_mass"), Div, kind=None), kind=None), Var("bm")]), Let(("_", Var(None)), Put(Var("bodies"), Int(0), Var("new_b")), Unit))))))))))}, LetRec({tyvars: [], name: ("main", Var(None)), args: [], body: Let(("jupiter", Var(None)), Tuple([Double(4.841431442464721), Neg(Double(1.1603200440274284), kind=None), Neg(Double(0.10362204447112311), kind=None), Prim(Double(0.001660076642744037), Var("days_per_year"), Mul, kind=None), Prim(Double(0.007699011184197404), Var("days_per_year"), Mul, kind=None), Neg(Prim(Double(0.0000690460016972063), Var("days_per_year"), Mul, kind=None), kind=None), Prim(Double(0.0009547919384243266), Var("solar_mass"), Mul, kind=None)]), Let(("saturn", Var(None)), Tuple([Double(8.34336671824458), Double(4.124798564124305), Neg(Double(0.4035234171143214), kind=None), Neg(Prim(Double(0.002767425107268624), Var("days_per_year"), Mul, kind=None), kind=None), Prim(Double(0.004998528012349172), Var("days_per_year"), Mul, kind=None), Prim(Double(0.000023029345528229068), Var("days_per_year"), Mul, kind=None), Prim(Double(0.0002858859806661308), Var("solar_mass"), Mul, kind=None)]), Let(("uranus", Var(None)), Tuple([Double(12.894369562139131), Neg(Double(15.111151401698631), kind=None), Neg(Double(0.22330757889265587), kind=None), Prim(Double(0.002964601375647616), Var("days_per_year"), Mul, kind=None), Prim(Double(0.0023784717395948095), Var("days_per_year"), Mul, kind=None), Neg(Prim(Double(0.000029658956854023756), Var("days_per_year"), Mul, kind=None), kind=None), Prim(Double(0.00004366244043351563), Var("solar_mass"), Mul, kind=None)]), Let(("neptune", Var(None)), Tuple([Double(15.379697114850917), Neg(Double(25.919314609987964), kind=None), Double(0.17925877295037118), Prim(Double(0.0026806777249038932), Var("days_per_year"), Mul, kind=None), Prim(Double(0.001628241700382423), Var("days_per_year"), Mul, kind=None), Neg(Prim(Double(0.00009515922545197159), Var("days_per_year"), Mul, kind=None), kind=None), Prim(Double(0.00005151389020466116), Var("solar_mass"), Mul, kind=None)]), Let(("sun", Var(None)), Tuple([Double(0), Double(0), Double(0), Double(0), Double(0), Double(0), Var("solar_mass")]), Let(("bodies", Var(None)), Array(Int(5), Tuple([Double(0), Double(0), Double(0), Double(0), Double(0), Double(0), Double(0)])), Let(("_", Var(None)), Put(Var("bodies"), Int(0), Var("sun")), Let(("_", Var(None)), Put(Var("bodies"), Int(1), Var("jupiter")), Let(("_", Var(None)), Put(Var("bodies"), Int(2), Var("saturn")), Let(("_", Var(None)), Put(Var("bodies"), Int(3), Var("uranus")), Let(("_", Var(None)), Put(Var("bodies"), Int(4), Var("neptune")), Let(("_", Var(None)), App(Var("offset_momentum"), targs=None, [Var("bodies")]), Let(("_", Var(None)), App(Var("print_int"), targs=None, [App(Var("int_of_float"), targs=None, [Prim(App(Var("energy"), targs=None, [Var("bodies")]), Double(1000000000), Mul, kind=None)])]), Let(("iters", Var(None)), Int(500000), LetRec({tyvars: [], name: ("loop_i", Var(None)), args: [("i", Int)], body: Let(("_", Var(None)), If(LE(Var("i"), Var("iters")), Let(("_", Var(None)), App(Var("advance"), targs=None, [Var("bodies"), Double(0.01)]), Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Unit)), Unit), Unit)}, Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Int(1)]), Let(("_", Var(None)), App(Var("print_char"), targs=None, [Int(10)]), Let(("_", Var(None)), App(Var("print_int"), targs=None, [App(Var("int_of_float"), targs=None, [Prim(App(Var("energy"), targs=None, [Var("bodies")]), Double(1000000000), Mul, kind=None)])]), Unit))))))))))))))))))}, Unit))))))
// [Typer] resolve: Prim(Prim(Double(4), Var("pi"), Mul, kind=None), Var("pi"), Mul, kind=None)
// [Typer] resolve: Prim(Double(4), Var("pi"), Mul, kind=None)
// [Typer] resolve: Double(4)
// [Typer] resolve: Var("pi")
// [Typer] resolve: Var("pi")
// [Typer] resolve: Let(("days_per_year", Double), Double(365.24), LetRec({tyvars: [], name: ("advance", Unit), args: [("bodies", Array[(Double, Double, Double, Double, Double, Double, Double)]), ("dt", Double)], body: Let(("n", Var(None)), Int(5), LetRec({tyvars: [], name: ("loop_i", Var(None)), args: [("i", Int)], body: Let(("_", Var(None)), If(LE(Var("i"), Prim(Var("n"), Int(1), Sub, kind=None)), Let(("b", Var(None)), Get(Var("bodies"), Var("i")), LetTuple([("bx", Var(None)), ("by", Var(None)), ("bz", Var(None)), ("bvx", Var(None)), ("bvy", Var(None)), ("bvz", Var(None)), ("bm", Var(None))], Var("b"), LetRec({tyvars: [], name: ("loop_j", Var(None)), args: [("j", Int)], body: Let(("_", Var(None)), If(LE(Var("j"), Prim(Var("n"), Int(1), Sub, kind=None)), Let(("b2", Var(None)), Get(Var("bodies"), Var("j")), LetTuple([("b2x", Var(None)), ("b2y", Var(None)), ("b2z", Var(None)), ("b2vx", Var(None)), ("b2vy", Var(None)), ("b2vz", Var(None)), ("b2m", Var(None))], Var("b2"), Let(("dx", Var(None)), Prim(Var("bx"), Var("b2x"), Sub, kind=None), Let(("dy", Var(None)), Prim(Var("by"), Var("b2y"), Sub, kind=None), Let(("dz", Var(None)), Prim(Var("bz"), Var("b2z"), Sub, kind=None), Let(("dist2", Var(None)), Prim(Prim(Prim(Var("dx"), Var("dx"), Mul, kind=None), Prim(Var("dy"), Var("dy"), Mul, kind=None), Add, kind=None), Prim(Var("dz"), Var("dz"), Mul, kind=None), Add, kind=None), Let(("mag", Var(None)), Prim(Var("dt"), Prim(Var("dist2"), App(Var("sqrt"), targs=None, [Var("dist2")]), Mul, kind=None), Div, kind=None), Let(("new_b", Var(None)), Tuple([Var("bx"), Var("by"), Var("bz"), Prim(Var("bvx"), Prim(Prim(Var("dx"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Prim(Var("bvy"), Prim(Prim(Var("dy"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Prim(Var("bvz"), Prim(Prim(Var("dz"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Var("bm")]), Let(("_", Var(None)), Put(Var("bodies"), Var("i"), Var("new_b")), Let(("new_b2", Var(None)), Tuple([Var("b2x"), Var("b2y"), Var("b2z"), Prim(Var("b2vx"), Prim(Prim(Var("dx"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Prim(Var("b2vy"), Prim(Prim(Var("dy"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Prim(Var("b2vz"), Prim(Prim(Var("dz"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Var("b2m")]), Let(("_", Var(None)), Put(Var("bodies"), Var("j"), Var("new_b2")), Let(("_", Var(None)), App(Var("loop_j"), targs=None, [Prim(Var("j"), Int(1), Add, kind=None)]), Unit)))))))))))), Unit), Unit)}, Let(("_", Var(None)), App(Var("loop_j"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Unit))))), Unit), Unit)}, Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Int(0)]), LetRec({tyvars: [], name: ("update_axis", Var(None)), args: [("i", Int)], body: Let(("_", Var(None)), If(LE(Var("i"), Prim(Var("n"), Int(1), Sub, kind=None)), Let(("b", Var(None)), Get(Var("bodies"), Var("i")), LetTuple([("bx", Var(None)), ("by", Var(None)), ("bz", Var(None)), ("bvx", Var(None)), ("bvy", Var(None)), ("bvz", Var(None)), ("bm", Var(None))], Var("b"), Let(("new_b", Var(None)), Tuple([Prim(Var("bx"), Prim(Var("dt"), Var("bvx"), Mul, kind=None), Add, kind=None), Prim(Var("by"), Prim(Var("dt"), Var("bvy"), Mul, kind=None), Add, kind=None), Prim(Var("bz"), Prim(Var("dt"), Var("bvz"), Mul, kind=None), Add, kind=None), Var("bvx"), Var("bvy"), Var("bvz"), Var("bm")]), Let(("_", Var(None)), Put(Var("bodies"), Var("i"), Var("new_b")), Let(("_", Var(None)), App(Var("update_axis"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Unit))))), Unit), Unit)}, Let(("_", Var(None)), App(Var("update_axis"), targs=None, [Int(0)]), Unit)))))}, LetRec({tyvars: [], name: ("energy", Double), args: [("bodies", Array[(Double, Double, Double, Double, Double, Double, Double)])], body: Let(("n", Var(None)), Int(5), Let(("e", Var(None)), Array(Int(1), Double(0)), LetRec({tyvars: [], name: ("loop_i", Var(None)), args: [("i", Int)], body: Let(("_", Var(None)), If(LE(Var("i"), Prim(Var("n"), Int(1), Sub, kind=None)), Let(("b", Var(None)), Get(Var("bodies"), Var("i")), LetTuple([("bx", Var(None)), ("by", Var(None)), ("bz", Var(None)), ("bvx", Var(None)), ("bvy", Var(None)), ("bvz", Var(None)), ("bm", Var(None))], Var("b"), Let(("_", Var(None)), Put(Var("e"), Int(0), Prim(Get(Var("e"), Int(0)), Prim(Prim(Double(0.5), Var("bm"), Mul, kind=None), Prim(Prim(Prim(Var("bvx"), Var("bvx"), Mul, kind=None), Prim(Var("bvy"), Var("bvy"), Mul, kind=None), Add, kind=None), Prim(Var("bvz"), Var("bvz"), Mul, kind=None), Add, kind=None), Mul, kind=None), Add, kind=None)), LetRec({tyvars: [], name: ("loop_j", Var(None)), args: [("j", Int)], body: Let(("_", Var(None)), If(LE(Var("j"), Prim(Var("n"), Int(1), Sub, kind=None)), Let(("b2", Var(None)), Get(Var("bodies"), Var("j")), LetTuple([("b2x", Var(None)), ("b2y", Var(None)), ("b2z", Var(None)), ("b2vx", Var(None)), ("b2vy", Var(None)), ("b2vz", Var(None)), ("b2m", Var(None))], Var("b2"), Let(("dx", Var(None)), Prim(Var("bx"), Var("b2x"), Sub, kind=None), Let(("dy", Var(None)), Prim(Var("by"), Var("b2y"), Sub, kind=None), Let(("dz", Var(None)), Prim(Var("bz"), Var("b2z"), Sub, kind=None), Let(("dist2", Var(None)), Prim(Prim(Prim(Var("dx"), Var("dx"), Mul, kind=None), Prim(Var("dy"), Var("dy"), Mul, kind=None), Add, kind=None), Prim(Var("dz"), Var("dz"), Mul, kind=None), Add, kind=None), Let(("_", Var(None)), Put(Var("e"), Int(0), Prim(Get(Var("e"), Int(0)), Prim(Prim(Var("bm"), Var("b2m"), Mul, kind=None), App(Var("sqrt"), targs=None, [Var("dist2")]), Div, kind=None), Sub, kind=None)), Let(("_", Var(None)), App(Var("loop_j"), targs=None, [Prim(Var("j"), Int(1), Add, kind=None)]), Unit)))))))), Unit), Unit)}, Let(("_", Var(None)), App(Var("loop_j"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Unit)))))), Unit), Unit)}, Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Int(0)]), Get(Var("e"), Int(0))))))}, LetRec({tyvars: [], name: ("offset_momentum", Unit), args: [("bodies", Array[(Double, Double, Double, Double, Double, Double, Double)])], body: Let(("n", Var(None)), Int(5), Let(("px", Var(None)), Array(Int(1), Double(0)), Let(("py", Var(None)), Array(Int(1), Double(0)), Let(("pz", Var(None)), Array(Int(1), Double(0)), LetRec({tyvars: [], name: ("loop_i", Var(None)), args: [("i", Int)], body: Let(("_", Var(None)), If(LE(Var("i"), Prim(Var("n"), Int(1), Sub, kind=None)), Let(("b", Var(None)), Get(Var("bodies"), Var("i")), LetTuple([("bx", Var(None)), ("by", Var(None)), ("bz", Var(None)), ("bvx", Var(None)), ("bvy", Var(None)), ("bvz", Var(None)), ("bm", Var(None))], Var("b"), Let(("_", Var(None)), Put(Var("px"), Int(0), Prim(Get(Var("px"), Int(0)), Prim(Var("bvx"), Var("bm"), Mul, kind=None), Add, kind=None)), Let(("_", Var(None)), Put(Var("py"), Int(0), Prim(Get(Var("py"), Int(0)), Prim(Var("bvy"), Var("bm"), Mul, kind=None), Add, kind=None)), Let(("_", Var(None)), Put(Var("pz"), Int(0), Prim(Get(Var("pz"), Int(0)), Prim(Var("bvz"), Var("bm"), Mul, kind=None), Add, kind=None)), Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Unit)))))), Unit), Unit)}, Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Int(0)]), Let(("b", Var(None)), Get(Var("bodies"), Int(0)), LetTuple([("bx", Var(None)), ("by", Var(None)), ("bz", Var(None)), ("bvx", Var(None)), ("bvy", Var(None)), ("bvz", Var(None)), ("bm", Var(None))], Var("b"), Let(("new_b", Var(None)), Tuple([Var("bx"), Var("by"), Var("bz"), Neg(Prim(Get(Var("px"), Int(0)), Var("solar_mass"), Div, kind=None), kind=None), Neg(Prim(Get(Var("py"), Int(0)), Var("solar_mass"), Div, kind=None), kind=None), Neg(Prim(Get(Var("pz"), Int(0)), Var("solar_mass"), Div, kind=None), kind=None), Var("bm")]), Let(("_", Var(None)), Put(Var("bodies"), Int(0), Var("new_b")), Unit))))))))))}, LetRec({tyvars: [], name: ("main", Var(None)), args: [], body: Let(("jupiter", Var(None)), Tuple([Double(4.841431442464721), Neg(Double(1.1603200440274284), kind=None), Neg(Double(0.10362204447112311), kind=None), Prim(Double(0.001660076642744037), Var("days_per_year"), Mul, kind=None), Prim(Double(0.007699011184197404), Var("days_per_year"), Mul, kind=None), Neg(Prim(Double(0.0000690460016972063), Var("days_per_year"), Mul, kind=None), kind=None), Prim(Double(0.0009547919384243266), Var("solar_mass"), Mul, kind=None)]), Let(("saturn", Var(None)), Tuple([Double(8.34336671824458), Double(4.124798564124305), Neg(Double(0.4035234171143214), kind=None), Neg(Prim(Double(0.002767425107268624), Var("days_per_year"), Mul, kind=None), kind=None), Prim(Double(0.004998528012349172), Var("days_per_year"), Mul, kind=None), Prim(Double(0.000023029345528229068), Var("days_per_year"), Mul, kind=None), Prim(Double(0.0002858859806661308), Var("solar_mass"), Mul, kind=None)]), Let(("uranus", Var(None)), Tuple([Double(12.894369562139131), Neg(Double(15.111151401698631), kind=None), Neg(Double(0.22330757889265587), kind=None), Prim(Double(0.002964601375647616), Var("days_per_year"), Mul, kind=None), Prim(Double(0.0023784717395948095), Var("days_per_year"), Mul, kind=None), Neg(Prim(Double(0.000029658956854023756), Var("days_per_year"), Mul, kind=None), kind=None), Prim(Double(0.00004366244043351563), Var("solar_mass"), Mul, kind=None)]), Let(("neptune", Var(None)), Tuple([Double(15.379697114850917), Neg(Double(25.919314609987964), kind=None), Double(0.17925877295037118), Prim(Double(0.0026806777249038932), Var("days_per_year"), Mul, kind=None), Prim(Double(0.001628241700382423), Var("days_per_year"), Mul, kind=None), Neg(Prim(Double(0.00009515922545197159), Var("days_per_year"), Mul, kind=None), kind=None), Prim(Double(0.00005151389020466116), Var("solar_mass"), Mul, kind=None)]), Let(("sun", Var(None)), Tuple([Double(0), Double(0), Double(0), Double(0), Double(0), Double(0), Var("solar_mass")]), Let(("bodies", Var(None)), Array(Int(5), Tuple([Double(0), Double(0), Double(0), Double(0), Double(0), Double(0), Double(0)])), Let(("_", Var(None)), Put(Var("bodies"), Int(0), Var("sun")), Let(("_", Var(None)), Put(Var("bodies"), Int(1), Var("jupiter")), Let(("_", Var(None)), Put(Var("bodies"), Int(2), Var("saturn")), Let(("_", Var(None)), Put(Var("bodies"), Int(3), Var("uranus")), Let(("_", Var(None)), Put(Var("bodies"), Int(4), Var("neptune")), Let(("_", Var(None)), App(Var("offset_momentum"), targs=None, [Var("bodies")]), Let(("_", Var(None)), App(Var("print_int"), targs=None, [App(Var("int_of_float"), targs=None, [Prim(App(Var("energy"), targs=None, [Var("bodies")]), Double(1000000000), Mul, kind=None)])]), Let(("iters", Var(None)), Int(500000), LetRec({tyvars: [], name: ("loop_i", Var(None)), args: [("i", Int)], body: Let(("_", Var(None)), If(LE(Var("i"), Var("iters")), Let(("_", Var(None)), App(Var("advance"), targs=None, [Var("bodies"), Double(0.01)]), Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Unit)), Unit), Unit)}, Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Int(1)]), Let(("_", Var(None)), App(Var("print_char"), targs=None, [Int(10)]), Let(("_", Var(None)), App(Var("print_int"), targs=None, [App(Var("int_of_float"), targs=None, [Prim(App(Var("energy"), targs=None, [Var("bodies")]), Double(1000000000), Mul, kind=None)])]), Unit))))))))))))))))))}, Unit)))))
// [Typer] resolve: Double(365.24)
// [Typer] resolve: LetRec({tyvars: [], name: ("advance", Unit), args: [("bodies", Array[(Double, Double, Double, Double, Double, Double, Double)]), ("dt", Double)], body: Let(("n", Var(None)), Int(5), LetRec({tyvars: [], name: ("loop_i", Var(None)), args: [("i", Int)], body: Let(("_", Var(None)), If(LE(Var("i"), Prim(Var("n"), Int(1), Sub, kind=None)), Let(("b", Var(None)), Get(Var("bodies"), Var("i")), LetTuple([("bx", Var(None)), ("by", Var(None)), ("bz", Var(None)), ("bvx", Var(None)), ("bvy", Var(None)), ("bvz", Var(None)), ("bm", Var(None))], Var("b"), LetRec({tyvars: [], name: ("loop_j", Var(None)), args: [("j", Int)], body: Let(("_", Var(None)), If(LE(Var("j"), Prim(Var("n"), Int(1), Sub, kind=None)), Let(("b2", Var(None)), Get(Var("bodies"), Var("j")), LetTuple([("b2x", Var(None)), ("b2y", Var(None)), ("b2z", Var(None)), ("b2vx", Var(None)), ("b2vy", Var(None)), ("b2vz", Var(None)), ("b2m", Var(None))], Var("b2"), Let(("dx", Var(None)), Prim(Var("bx"), Var("b2x"), Sub, kind=None), Let(("dy", Var(None)), Prim(Var("by"), Var("b2y"), Sub, kind=None), Let(("dz", Var(None)), Prim(Var("bz"), Var("b2z"), Sub, kind=None), Let(("dist2", Var(None)), Prim(Prim(Prim(Var("dx"), Var("dx"), Mul, kind=None), Prim(Var("dy"), Var("dy"), Mul, kind=None), Add, kind=None), Prim(Var("dz"), Var("dz"), Mul, kind=None), Add, kind=None), Let(("mag", Var(None)), Prim(Var("dt"), Prim(Var("dist2"), App(Var("sqrt"), targs=None, [Var("dist2")]), Mul, kind=None), Div, kind=None), Let(("new_b", Var(None)), Tuple([Var("bx"), Var("by"), Var("bz"), Prim(Var("bvx"), Prim(Prim(Var("dx"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Prim(Var("bvy"), Prim(Prim(Var("dy"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Prim(Var("bvz"), Prim(Prim(Var("dz"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Var("bm")]), Let(("_", Var(None)), Put(Var("bodies"), Var("i"), Var("new_b")), Let(("new_b2", Var(None)), Tuple([Var("b2x"), Var("b2y"), Var("b2z"), Prim(Var("b2vx"), Prim(Prim(Var("dx"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Prim(Var("b2vy"), Prim(Prim(Var("dy"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Prim(Var("b2vz"), Prim(Prim(Var("dz"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Var("b2m")]), Let(("_", Var(None)), Put(Var("bodies"), Var("j"), Var("new_b2")), Let(("_", Var(None)), App(Var("loop_j"), targs=None, [Prim(Var("j"), Int(1), Add, kind=None)]), Unit)))))))))))), Unit), Unit)}, Let(("_", Var(None)), App(Var("loop_j"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Unit))))), Unit), Unit)}, Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Int(0)]), LetRec({tyvars: [], name: ("update_axis", Var(None)), args: [("i", Int)], body: Let(("_", Var(None)), If(LE(Var("i"), Prim(Var("n"), Int(1), Sub, kind=None)), Let(("b", Var(None)), Get(Var("bodies"), Var("i")), LetTuple([("bx", Var(None)), ("by", Var(None)), ("bz", Var(None)), ("bvx", Var(None)), ("bvy", Var(None)), ("bvz", Var(None)), ("bm", Var(None))], Var("b"), Let(("new_b", Var(None)), Tuple([Prim(Var("bx"), Prim(Var("dt"), Var("bvx"), Mul, kind=None), Add, kind=None), Prim(Var("by"), Prim(Var("dt"), Var("bvy"), Mul, kind=None), Add, kind=None), Prim(Var("bz"), Prim(Var("dt"), Var("bvz"), Mul, kind=None), Add, kind=None), Var("bvx"), Var("bvy"), Var("bvz"), Var("bm")]), Let(("_", Var(None)), Put(Var("bodies"), Var("i"), Var("new_b")), Let(("_", Var(None)), App(Var("update_axis"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Unit))))), Unit), Unit)}, Let(("_", Var(None)), App(Var("update_axis"), targs=None, [Int(0)]), Unit)))))}, LetRec({tyvars: [], name: ("energy", Double), args: [("bodies", Array[(Double, Double, Double, Double, Double, Double, Double)])], body: Let(("n", Var(None)), Int(5), Let(("e", Var(None)), Array(Int(1), Double(0)), LetRec({tyvars: [], name: ("loop_i", Var(None)), args: [("i", Int)], body: Let(("_", Var(None)), If(LE(Var("i"), Prim(Var("n"), Int(1), Sub, kind=None)), Let(("b", Var(None)), Get(Var("bodies"), Var("i")), LetTuple([("bx", Var(None)), ("by", Var(None)), ("bz", Var(None)), ("bvx", Var(None)), ("bvy", Var(None)), ("bvz", Var(None)), ("bm", Var(None))], Var("b"), Let(("_", Var(None)), Put(Var("e"), Int(0), Prim(Get(Var("e"), Int(0)), Prim(Prim(Double(0.5), Var("bm"), Mul, kind=None), Prim(Prim(Prim(Var("bvx"), Var("bvx"), Mul, kind=None), Prim(Var("bvy"), Var("bvy"), Mul, kind=None), Add, kind=None), Prim(Var("bvz"), Var("bvz"), Mul, kind=None), Add, kind=None), Mul, kind=None), Add, kind=None)), LetRec({tyvars: [], name: ("loop_j", Var(None)), args: [("j", Int)], body: Let(("_", Var(None)), If(LE(Var("j"), Prim(Var("n"), Int(1), Sub, kind=None)), Let(("b2", Var(None)), Get(Var("bodies"), Var("j")), LetTuple([("b2x", Var(None)), ("b2y", Var(None)), ("b2z", Var(None)), ("b2vx", Var(None)), ("b2vy", Var(None)), ("b2vz", Var(None)), ("b2m", Var(None))], Var("b2"), Let(("dx", Var(None)), Prim(Var("bx"), Var("b2x"), Sub, kind=None), Let(("dy", Var(None)), Prim(Var("by"), Var("b2y"), Sub, kind=None), Let(("dz", Var(None)), Prim(Var("bz"), Var("b2z"), Sub, kind=None), Let(("dist2", Var(None)), Prim(Prim(Prim(Var("dx"), Var("dx"), Mul, kind=None), Prim(Var("dy"), Var("dy"), Mul, kind=None), Add, kind=None), Prim(Var("dz"), Var("dz"), Mul, kind=None), Add, kind=None), Let(("_", Var(None)), Put(Var("e"), Int(0), Prim(Get(Var("e"), Int(0)), Prim(Prim(Var("bm"), Var("b2m"), Mul, kind=None), App(Var("sqrt"), targs=None, [Var("dist2")]), Div, kind=None), Sub, kind=None)), Let(("_", Var(None)), App(Var("loop_j"), targs=None, [Prim(Var("j"), Int(1), Add, kind=None)]), Unit)))))))), Unit), Unit)}, Let(("_", Var(None)), App(Var("loop_j"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Unit)))))), Unit), Unit)}, Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Int(0)]), Get(Var("e"), Int(0))))))}, LetRec({tyvars: [], name: ("offset_momentum", Unit), args: [("bodies", Array[(Double, Double, Double, Double, Double, Double, Double)])], body: Let(("n", Var(None)), Int(5), Let(("px", Var(None)), Array(Int(1), Double(0)), Let(("py", Var(None)), Array(Int(1), Double(0)), Let(("pz", Var(None)), Array(Int(1), Double(0)), LetRec({tyvars: [], name: ("loop_i", Var(None)), args: [("i", Int)], body: Let(("_", Var(None)), If(LE(Var("i"), Prim(Var("n"), Int(1), Sub, kind=None)), Let(("b", Var(None)), Get(Var("bodies"), Var("i")), LetTuple([("bx", Var(None)), ("by", Var(None)), ("bz", Var(None)), ("bvx", Var(None)), ("bvy", Var(None)), ("bvz", Var(None)), ("bm", Var(None))], Var("b"), Let(("_", Var(None)), Put(Var("px"), Int(0), Prim(Get(Var("px"), Int(0)), Prim(Var("bvx"), Var("bm"), Mul, kind=None), Add, kind=None)), Let(("_", Var(None)), Put(Var("py"), Int(0), Prim(Get(Var("py"), Int(0)), Prim(Var("bvy"), Var("bm"), Mul, kind=None), Add, kind=None)), Let(("_", Var(None)), Put(Var("pz"), Int(0), Prim(Get(Var("pz"), Int(0)), Prim(Var("bvz"), Var("bm"), Mul, kind=None), Add, kind=None)), Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Unit)))))), Unit), Unit)}, Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Int(0)]), Let(("b", Var(None)), Get(Var("bodies"), Int(0)), LetTuple([("bx", Var(None)), ("by", Var(None)), ("bz", Var(None)), ("bvx", Var(None)), ("bvy", Var(None)), ("bvz", Var(None)), ("bm", Var(None))], Var("b"), Let(("new_b", Var(None)), Tuple([Var("bx"), Var("by"), Var("bz"), Neg(Prim(Get(Var("px"), Int(0)), Var("solar_mass"), Div, kind=None), kind=None), Neg(Prim(Get(Var("py"), Int(0)), Var("solar_mass"), Div, kind=None), kind=None), Neg(Prim(Get(Var("pz"), Int(0)), Var("solar_mass"), Div, kind=None), kind=None), Var("bm")]), Let(("_", Var(None)), Put(Var("bodies"), Int(0), Var("new_b")), Unit))))))))))}, LetRec({tyvars: [], name: ("main", Var(None)), args: [], body: Let(("jupiter", Var(None)), Tuple([Double(4.841431442464721), Neg(Double(1.1603200440274284), kind=None), Neg(Double(0.10362204447112311), kind=None), Prim(Double(0.001660076642744037), Var("days_per_year"), Mul, kind=None), Prim(Double(0.007699011184197404), Var("days_per_year"), Mul, kind=None), Neg(Prim(Double(0.0000690460016972063), Var("days_per_year"), Mul, kind=None), kind=None), Prim(Double(0.0009547919384243266), Var("solar_mass"), Mul, kind=None)]), Let(("saturn", Var(None)), Tuple([Double(8.34336671824458), Double(4.124798564124305), Neg(Double(0.4035234171143214), kind=None), Neg(Prim(Double(0.002767425107268624), Var("days_per_year"), Mul, kind=None), kind=None), Prim(Double(0.004998528012349172), Var("days_per_year"), Mul, kind=None), Prim(Double(0.000023029345528229068), Var("days_per_year"), Mul, kind=None), Prim(Double(0.0002858859806661308), Var("solar_mass"), Mul, kind=None)]), Let(("uranus", Var(None)), Tuple([Double(12.894369562139131), Neg(Double(15.111151401698631), kind=None), Neg(Double(0.22330757889265587), kind=None), Prim(Double(0.002964601375647616), Var("days_per_year"), Mul, kind=None), Prim(Double(0.0023784717395948095), Var("days_per_year"), Mul, kind=None), Neg(Prim(Double(0.000029658956854023756), Var("days_per_year"), Mul, kind=None), kind=None), Prim(Double(0.00004366244043351563), Var("solar_mass"), Mul, kind=None)]), Let(("neptune", Var(None)), Tuple([Double(15.379697114850917), Neg(Double(25.919314609987964), kind=None), Double(0.17925877295037118), Prim(Double(0.0026806777249038932), Var("days_per_year"), Mul, kind=None), Prim(Double(0.001628241700382423), Var("days_per_year"), Mul, kind=None), Neg(Prim(Double(0.00009515922545197159), Var("days_per_year"), Mul, kind=None), kind=None), Prim(Double(0.00005151389020466116), Var("solar_mass"), Mul, kind=None)]), Let(("sun", Var(None)), Tuple([Double(0), Double(0), Double(0), Double(0), Double(0), Double(0), Var("solar_mass")]), Let(("bodies", Var(None)), Array(Int(5), Tuple([Double(0), Double(0), Double(0), Double(0), Double(0), Double(0), Double(0)])), Let(("_", Var(None)), Put(Var("bodies"), Int(0), Var("sun")), Let(("_", Var(None)), Put(Var("bodies"), Int(1), Var("jupiter")), Let(("_", Var(None)), Put(Var("bodies"), Int(2), Var("saturn")), Let(("_", Var(None)), Put(Var("bodies"), Int(3), Var("uranus")), Let(("_", Var(None)), Put(Var("bodies"), Int(4), Var("neptune")), Let(("_", Var(None)), App(Var("offset_momentum"), targs=None, [Var("bodies")]), Let(("_", Var(None)), App(Var("print_int"), targs=None, [App(Var("int_of_float"), targs=None, [Prim(App(Var("energy"), targs=None, [Var("bodies")]), Double(1000000000), Mul, kind=None)])]), Let(("iters", Var(None)), Int(500000), LetRec({tyvars: [], name: ("loop_i", Var(None)), args: [("i", Int)], body: Let(("_", Var(None)), If(LE(Var("i"), Var("iters")), Let(("_", Var(None)), App(Var("advance"), targs=None, [Var("bodies"), Double(0.01)]), Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Unit)), Unit), Unit)}, Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Int(1)]), Let(("_", Var(None)), App(Var("print_char"), targs=None, [Int(10)]), Let(("_", Var(None)), App(Var("print_int"), targs=None, [App(Var("int_of_float"), targs=None, [Prim(App(Var("energy"), targs=None, [Var("bodies")]), Double(1000000000), Mul, kind=None)])]), Unit))))))))))))))))))}, Unit))))
// [Typer] resolve: Let(("n", Var(None)), Int(5), LetRec({tyvars: [], name: ("loop_i", Var(None)), args: [("i", Int)], body: Let(("_", Var(None)), If(LE(Var("i"), Prim(Var("n"), Int(1), Sub, kind=None)), Let(("b", Var(None)), Get(Var("bodies"), Var("i")), LetTuple([("bx", Var(None)), ("by", Var(None)), ("bz", Var(None)), ("bvx", Var(None)), ("bvy", Var(None)), ("bvz", Var(None)), ("bm", Var(None))], Var("b"), LetRec({tyvars: [], name: ("loop_j", Var(None)), args: [("j", Int)], body: Let(("_", Var(None)), If(LE(Var("j"), Prim(Var("n"), Int(1), Sub, kind=None)), Let(("b2", Var(None)), Get(Var("bodies"), Var("j")), LetTuple([("b2x", Var(None)), ("b2y", Var(None)), ("b2z", Var(None)), ("b2vx", Var(None)), ("b2vy", Var(None)), ("b2vz", Var(None)), ("b2m", Var(None))], Var("b2"), Let(("dx", Var(None)), Prim(Var("bx"), Var("b2x"), Sub, kind=None), Let(("dy", Var(None)), Prim(Var("by"), Var("b2y"), Sub, kind=None), Let(("dz", Var(None)), Prim(Var("bz"), Var("b2z"), Sub, kind=None), Let(("dist2", Var(None)), Prim(Prim(Prim(Var("dx"), Var("dx"), Mul, kind=None), Prim(Var("dy"), Var("dy"), Mul, kind=None), Add, kind=None), Prim(Var("dz"), Var("dz"), Mul, kind=None), Add, kind=None), Let(("mag", Var(None)), Prim(Var("dt"), Prim(Var("dist2"), App(Var("sqrt"), targs=None, [Var("dist2")]), Mul, kind=None), Div, kind=None), Let(("new_b", Var(None)), Tuple([Var("bx"), Var("by"), Var("bz"), Prim(Var("bvx"), Prim(Prim(Var("dx"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Prim(Var("bvy"), Prim(Prim(Var("dy"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Prim(Var("bvz"), Prim(Prim(Var("dz"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Var("bm")]), Let(("_", Var(None)), Put(Var("bodies"), Var("i"), Var("new_b")), Let(("new_b2", Var(None)), Tuple([Var("b2x"), Var("b2y"), Var("b2z"), Prim(Var("b2vx"), Prim(Prim(Var("dx"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Prim(Var("b2vy"), Prim(Prim(Var("dy"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Prim(Var("b2vz"), Prim(Prim(Var("dz"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Var("b2m")]), Let(("_", Var(None)), Put(Var("bodies"), Var("j"), Var("new_b2")), Let(("_", Var(None)), App(Var("loop_j"), targs=None, [Prim(Var("j"), Int(1), Add, kind=None)]), Unit)))))))))))), Unit), Unit)}, Let(("_", Var(None)), App(Var("loop_j"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Unit))))), Unit), Unit)}, Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Int(0)]), LetRec({tyvars: [], name: ("update_axis", Var(None)), args: [("i", Int)], body: Let(("_", Var(None)), If(LE(Var("i"), Prim(Var("n"), Int(1), Sub, kind=None)), Let(("b", Var(None)), Get(Var("bodies"), Var("i")), LetTuple([("bx", Var(None)), ("by", Var(None)), ("bz", Var(None)), ("bvx", Var(None)), ("bvy", Var(None)), ("bvz", Var(None)), ("bm", Var(None))], Var("b"), Let(("new_b", Var(None)), Tuple([Prim(Var("bx"), Prim(Var("dt"), Var("bvx"), Mul, kind=None), Add, kind=None), Prim(Var("by"), Prim(Var("dt"), Var("bvy"), Mul, kind=None), Add, kind=None), Prim(Var("bz"), Prim(Var("dt"), Var("bvz"), Mul, kind=None), Add, kind=None), Var("bvx"), Var("bvy"), Var("bvz"), Var("bm")]), Let(("_", Var(None)), Put(Var("bodies"), Var("i"), Var("new_b")), Let(("_", Var(None)), App(Var("update_axis"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Unit))))), Unit), Unit)}, Let(("_", Var(None)), App(Var("update_axis"), targs=None, [Int(0)]), Unit)))))
// [Typer] resolve: Int(5)
// [Typer] resolve: LetRec({tyvars: [], name: ("loop_i", Var(None)), args: [("i", Int)], body: Let(("_", Var(None)), If(LE(Var("i"), Prim(Var("n"), Int(1), Sub, kind=None)), Let(("b", Var(None)), Get(Var("bodies"), Var("i")), LetTuple([("bx", Var(None)), ("by", Var(None)), ("bz", Var(None)), ("bvx", Var(None)), ("bvy", Var(None)), ("bvz", Var(None)), ("bm", Var(None))], Var("b"), LetRec({tyvars: [], name: ("loop_j", Var(None)), args: [("j", Int)], body: Let(("_", Var(None)), If(LE(Var("j"), Prim(Var("n"), Int(1), Sub, kind=None)), Let(("b2", Var(None)), Get(Var("bodies"), Var("j")), LetTuple([("b2x", Var(None)), ("b2y", Var(None)), ("b2z", Var(None)), ("b2vx", Var(None)), ("b2vy", Var(None)), ("b2vz", Var(None)), ("b2m", Var(None))], Var("b2"), Let(("dx", Var(None)), Prim(Var("bx"), Var("b2x"), Sub, kind=None), Let(("dy", Var(None)), Prim(Var("by"), Var("b2y"), Sub, kind=None), Let(("dz", Var(None)), Prim(Var("bz"), Var("b2z"), Sub, kind=None), Let(("dist2", Var(None)), Prim(Prim(Prim(Var("dx"), Var("dx"), Mul, kind=None), Prim(Var("dy"), Var("dy"), Mul, kind=None), Add, kind=None), Prim(Var("dz"), Var("dz"), Mul, kind=None), Add, kind=None), Let(("mag", Var(None)), Prim(Var("dt"), Prim(Var("dist2"), App(Var("sqrt"), targs=None, [Var("dist2")]), Mul, kind=None), Div, kind=None), Let(("new_b", Var(None)), Tuple([Var("bx"), Var("by"), Var("bz"), Prim(Var("bvx"), Prim(Prim(Var("dx"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Prim(Var("bvy"), Prim(Prim(Var("dy"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Prim(Var("bvz"), Prim(Prim(Var("dz"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Var("bm")]), Let(("_", Var(None)), Put(Var("bodies"), Var("i"), Var("new_b")), Let(("new_b2", Var(None)), Tuple([Var("b2x"), Var("b2y"), Var("b2z"), Prim(Var("b2vx"), Prim(Prim(Var("dx"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Prim(Var("b2vy"), Prim(Prim(Var("dy"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Prim(Var("b2vz"), Prim(Prim(Var("dz"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Var("b2m")]), Let(("_", Var(None)), Put(Var("bodies"), Var("j"), Var("new_b2")), Let(("_", Var(None)), App(Var("loop_j"), targs=None, [Prim(Var("j"), Int(1), Add, kind=None)]), Unit)))))))))))), Unit), Unit)}, Let(("_", Var(None)), App(Var("loop_j"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Unit))))), Unit), Unit)}, Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Int(0)]), LetRec({tyvars: [], name: ("update_axis", Var(None)), args: [("i", Int)], body: Let(("_", Var(None)), If(LE(Var("i"), Prim(Var("n"), Int(1), Sub, kind=None)), Let(("b", Var(None)), Get(Var("bodies"), Var("i")), LetTuple([("bx", Var(None)), ("by", Var(None)), ("bz", Var(None)), ("bvx", Var(None)), ("bvy", Var(None)), ("bvz", Var(None)), ("bm", Var(None))], Var("b"), Let(("new_b", Var(None)), Tuple([Prim(Var("bx"), Prim(Var("dt"), Var("bvx"), Mul, kind=None), Add, kind=None), Prim(Var("by"), Prim(Var("dt"), Var("bvy"), Mul, kind=None), Add, kind=None), Prim(Var("bz"), Prim(Var("dt"), Var("bvz"), Mul, kind=None), Add, kind=None), Var("bvx"), Var("bvy"), Var("bvz"), Var("bm")]), Let(("_", Var(None)), Put(Var("bodies"), Var("i"), Var("new_b")), Let(("_", Var(None)), App(Var("update_axis"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Unit))))), Unit), Unit)}, Let(("_", Var(None)), App(Var("update_axis"), targs=None, [Int(0)]), Unit))))
// [Typer] resolve: Let(("_", Var(None)), If(LE(Var("i"), Prim(Var("n"), Int(1), Sub, kind=None)), Let(("b", Var(None)), Get(Var("bodies"), Var("i")), LetTuple([("bx", Var(None)), ("by", Var(None)), ("bz", Var(None)), ("bvx", Var(None)), ("bvy", Var(None)), ("bvz", Var(None)), ("bm", Var(None))], Var("b"), LetRec({tyvars: [], name: ("loop_j", Var(None)), args: [("j", Int)], body: Let(("_", Var(None)), If(LE(Var("j"), Prim(Var("n"), Int(1), Sub, kind=None)), Let(("b2", Var(None)), Get(Var("bodies"), Var("j")), LetTuple([("b2x", Var(None)), ("b2y", Var(None)), ("b2z", Var(None)), ("b2vx", Var(None)), ("b2vy", Var(None)), ("b2vz", Var(None)), ("b2m", Var(None))], Var("b2"), Let(("dx", Var(None)), Prim(Var("bx"), Var("b2x"), Sub, kind=None), Let(("dy", Var(None)), Prim(Var("by"), Var("b2y"), Sub, kind=None), Let(("dz", Var(None)), Prim(Var("bz"), Var("b2z"), Sub, kind=None), Let(("dist2", Var(None)), Prim(Prim(Prim(Var("dx"), Var("dx"), Mul, kind=None), Prim(Var("dy"), Var("dy"), Mul, kind=None), Add, kind=None), Prim(Var("dz"), Var("dz"), Mul, kind=None), Add, kind=None), Let(("mag", Var(None)), Prim(Var("dt"), Prim(Var("dist2"), App(Var("sqrt"), targs=None, [Var("dist2")]), Mul, kind=None), Div, kind=None), Let(("new_b", Var(None)), Tuple([Var("bx"), Var("by"), Var("bz"), Prim(Var("bvx"), Prim(Prim(Var("dx"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Prim(Var("bvy"), Prim(Prim(Var("dy"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Prim(Var("bvz"), Prim(Prim(Var("dz"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Var("bm")]), Let(("_", Var(None)), Put(Var("bodies"), Var("i"), Var("new_b")), Let(("new_b2", Var(None)), Tuple([Var("b2x"), Var("b2y"), Var("b2z"), Prim(Var("b2vx"), Prim(Prim(Var("dx"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Prim(Var("b2vy"), Prim(Prim(Var("dy"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Prim(Var("b2vz"), Prim(Prim(Var("dz"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Var("b2m")]), Let(("_", Var(None)), Put(Var("bodies"), Var("j"), Var("new_b2")), Let(("_", Var(None)), App(Var("loop_j"), targs=None, [Prim(Var("j"), Int(1), Add, kind=None)]), Unit)))))))))))), Unit), Unit)}, Let(("_", Var(None)), App(Var("loop_j"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Unit))))), Unit), Unit)
// [Typer] resolve: If(LE(Var("i"), Prim(Var("n"), Int(1), Sub, kind=None)), Let(("b", Var(None)), Get(Var("bodies"), Var("i")), LetTuple([("bx", Var(None)), ("by", Var(None)), ("bz", Var(None)), ("bvx", Var(None)), ("bvy", Var(None)), ("bvz", Var(None)), ("bm", Var(None))], Var("b"), LetRec({tyvars: [], name: ("loop_j", Var(None)), args: [("j", Int)], body: Let(("_", Var(None)), If(LE(Var("j"), Prim(Var("n"), Int(1), Sub, kind=None)), Let(("b2", Var(None)), Get(Var("bodies"), Var("j")), LetTuple([("b2x", Var(None)), ("b2y", Var(None)), ("b2z", Var(None)), ("b2vx", Var(None)), ("b2vy", Var(None)), ("b2vz", Var(None)), ("b2m", Var(None))], Var("b2"), Let(("dx", Var(None)), Prim(Var("bx"), Var("b2x"), Sub, kind=None), Let(("dy", Var(None)), Prim(Var("by"), Var("b2y"), Sub, kind=None), Let(("dz", Var(None)), Prim(Var("bz"), Var("b2z"), Sub, kind=None), Let(("dist2", Var(None)), Prim(Prim(Prim(Var("dx"), Var("dx"), Mul, kind=None), Prim(Var("dy"), Var("dy"), Mul, kind=None), Add, kind=None), Prim(Var("dz"), Var("dz"), Mul, kind=None), Add, kind=None), Let(("mag", Var(None)), Prim(Var("dt"), Prim(Var("dist2"), App(Var("sqrt"), targs=None, [Var("dist2")]), Mul, kind=None), Div, kind=None), Let(("new_b", Var(None)), Tuple([Var("bx"), Var("by"), Var("bz"), Prim(Var("bvx"), Prim(Prim(Var("dx"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Prim(Var("bvy"), Prim(Prim(Var("dy"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Prim(Var("bvz"), Prim(Prim(Var("dz"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Var("bm")]), Let(("_", Var(None)), Put(Var("bodies"), Var("i"), Var("new_b")), Let(("new_b2", Var(None)), Tuple([Var("b2x"), Var("b2y"), Var("b2z"), Prim(Var("b2vx"), Prim(Prim(Var("dx"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Prim(Var("b2vy"), Prim(Prim(Var("dy"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Prim(Var("b2vz"), Prim(Prim(Var("dz"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Var("b2m")]), Let(("_", Var(None)), Put(Var("bodies"), Var("j"), Var("new_b2")), Let(("_", Var(None)), App(Var("loop_j"), targs=None, [Prim(Var("j"), Int(1), Add, kind=None)]), Unit)))))))))))), Unit), Unit)}, Let(("_", Var(None)), App(Var("loop_j"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Unit))))), Unit)
// [Typer] resolve: LE(Var("i"), Prim(Var("n"), Int(1), Sub, kind=None))
// [Typer] resolve: Var("i")
// [Typer] resolve: Prim(Var("n"), Int(1), Sub, kind=None)
// [Typer] resolve: Var("n")
// [Typer] resolve: Int(1)
// [Typer] resolve: Let(("b", Var(None)), Get(Var("bodies"), Var("i")), LetTuple([("bx", Var(None)), ("by", Var(None)), ("bz", Var(None)), ("bvx", Var(None)), ("bvy", Var(None)), ("bvz", Var(None)), ("bm", Var(None))], Var("b"), LetRec({tyvars: [], name: ("loop_j", Var(None)), args: [("j", Int)], body: Let(("_", Var(None)), If(LE(Var("j"), Prim(Var("n"), Int(1), Sub, kind=None)), Let(("b2", Var(None)), Get(Var("bodies"), Var("j")), LetTuple([("b2x", Var(None)), ("b2y", Var(None)), ("b2z", Var(None)), ("b2vx", Var(None)), ("b2vy", Var(None)), ("b2vz", Var(None)), ("b2m", Var(None))], Var("b2"), Let(("dx", Var(None)), Prim(Var("bx"), Var("b2x"), Sub, kind=None), Let(("dy", Var(None)), Prim(Var("by"), Var("b2y"), Sub, kind=None), Let(("dz", Var(None)), Prim(Var("bz"), Var("b2z"), Sub, kind=None), Let(("dist2", Var(None)), Prim(Prim(Prim(Var("dx"), Var("dx"), Mul, kind=None), Prim(Var("dy"), Var("dy"), Mul, kind=None), Add, kind=None), Prim(Var("dz"), Var("dz"), Mul, kind=None), Add, kind=None), Let(("mag", Var(None)), Prim(Var("dt"), Prim(Var("dist2"), App(Var("sqrt"), targs=None, [Var("dist2")]), Mul, kind=None), Div, kind=None), Let(("new_b", Var(None)), Tuple([Var("bx"), Var("by"), Var("bz"), Prim(Var("bvx"), Prim(Prim(Var("dx"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Prim(Var("bvy"), Prim(Prim(Var("dy"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Prim(Var("bvz"), Prim(Prim(Var("dz"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Var("bm")]), Let(("_", Var(None)), Put(Var("bodies"), Var("i"), Var("new_b")), Let(("new_b2", Var(None)), Tuple([Var("b2x"), Var("b2y"), Var("b2z"), Prim(Var("b2vx"), Prim(Prim(Var("dx"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Prim(Var("b2vy"), Prim(Prim(Var("dy"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Prim(Var("b2vz"), Prim(Prim(Var("dz"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Var("b2m")]), Let(("_", Var(None)), Put(Var("bodies"), Var("j"), Var("new_b2")), Let(("_", Var(None)), App(Var("loop_j"), targs=None, [Prim(Var("j"), Int(1), Add, kind=None)]), Unit)))))))))))), Unit), Unit)}, Let(("_", Var(None)), App(Var("loop_j"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Unit)))))
// [Typer] resolve: Get(Var("bodies"), Var("i"))
// [Typer] resolve: Var("bodies")
// [Typer] resolve: Var("i")
// [Typer] resolve: LetTuple([("bx", Var(None)), ("by", Var(None)), ("bz", Var(None)), ("bvx", Var(None)), ("bvy", Var(None)), ("bvz", Var(None)), ("bm", Var(None))], Var("b"), LetRec({tyvars: [], name: ("loop_j", Var(None)), args: [("j", Int)], body: Let(("_", Var(None)), If(LE(Var("j"), Prim(Var("n"), Int(1), Sub, kind=None)), Let(("b2", Var(None)), Get(Var("bodies"), Var("j")), LetTuple([("b2x", Var(None)), ("b2y", Var(None)), ("b2z", Var(None)), ("b2vx", Var(None)), ("b2vy", Var(None)), ("b2vz", Var(None)), ("b2m", Var(None))], Var("b2"), Let(("dx", Var(None)), Prim(Var("bx"), Var("b2x"), Sub, kind=None), Let(("dy", Var(None)), Prim(Var("by"), Var("b2y"), Sub, kind=None), Let(("dz", Var(None)), Prim(Var("bz"), Var("b2z"), Sub, kind=None), Let(("dist2", Var(None)), Prim(Prim(Prim(Var("dx"), Var("dx"), Mul, kind=None), Prim(Var("dy"), Var("dy"), Mul, kind=None), Add, kind=None), Prim(Var("dz"), Var("dz"), Mul, kind=None), Add, kind=None), Let(("mag", Var(None)), Prim(Var("dt"), Prim(Var("dist2"), App(Var("sqrt"), targs=None, [Var("dist2")]), Mul, kind=None), Div, kind=None), Let(("new_b", Var(None)), Tuple([Var("bx"), Var("by"), Var("bz"), Prim(Var("bvx"), Prim(Prim(Var("dx"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Prim(Var("bvy"), Prim(Prim(Var("dy"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Prim(Var("bvz"), Prim(Prim(Var("dz"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Var("bm")]), Let(("_", Var(None)), Put(Var("bodies"), Var("i"), Var("new_b")), Let(("new_b2", Var(None)), Tuple([Var("b2x"), Var("b2y"), Var("b2z"), Prim(Var("b2vx"), Prim(Prim(Var("dx"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Prim(Var("b2vy"), Prim(Prim(Var("dy"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Prim(Var("b2vz"), Prim(Prim(Var("dz"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Var("b2m")]), Let(("_", Var(None)), Put(Var("bodies"), Var("j"), Var("new_b2")), Let(("_", Var(None)), App(Var("loop_j"), targs=None, [Prim(Var("j"), Int(1), Add, kind=None)]), Unit)))))))))))), Unit), Unit)}, Let(("_", Var(None)), App(Var("loop_j"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Unit))))
// [Typer] resolve: Var("b")
// [Typer] resolve: LetRec({tyvars: [], name: ("loop_j", Var(None)), args: [("j", Int)], body: Let(("_", Var(None)), If(LE(Var("j"), Prim(Var("n"), Int(1), Sub, kind=None)), Let(("b2", Var(None)), Get(Var("bodies"), Var("j")), LetTuple([("b2x", Var(None)), ("b2y", Var(None)), ("b2z", Var(None)), ("b2vx", Var(None)), ("b2vy", Var(None)), ("b2vz", Var(None)), ("b2m", Var(None))], Var("b2"), Let(("dx", Var(None)), Prim(Var("bx"), Var("b2x"), Sub, kind=None), Let(("dy", Var(None)), Prim(Var("by"), Var("b2y"), Sub, kind=None), Let(("dz", Var(None)), Prim(Var("bz"), Var("b2z"), Sub, kind=None), Let(("dist2", Var(None)), Prim(Prim(Prim(Var("dx"), Var("dx"), Mul, kind=None), Prim(Var("dy"), Var("dy"), Mul, kind=None), Add, kind=None), Prim(Var("dz"), Var("dz"), Mul, kind=None), Add, kind=None), Let(("mag", Var(None)), Prim(Var("dt"), Prim(Var("dist2"), App(Var("sqrt"), targs=None, [Var("dist2")]), Mul, kind=None), Div, kind=None), Let(("new_b", Var(None)), Tuple([Var("bx"), Var("by"), Var("bz"), Prim(Var("bvx"), Prim(Prim(Var("dx"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Prim(Var("bvy"), Prim(Prim(Var("dy"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Prim(Var("bvz"), Prim(Prim(Var("dz"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Var("bm")]), Let(("_", Var(None)), Put(Var("bodies"), Var("i"), Var("new_b")), Let(("new_b2", Var(None)), Tuple([Var("b2x"), Var("b2y"), Var("b2z"), Prim(Var("b2vx"), Prim(Prim(Var("dx"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Prim(Var("b2vy"), Prim(Prim(Var("dy"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Prim(Var("b2vz"), Prim(Prim(Var("dz"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Var("b2m")]), Let(("_", Var(None)), Put(Var("bodies"), Var("j"), Var("new_b2")), Let(("_", Var(None)), App(Var("loop_j"), targs=None, [Prim(Var("j"), Int(1), Add, kind=None)]), Unit)))))))))))), Unit), Unit)}, Let(("_", Var(None)), App(Var("loop_j"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Unit)))
// [Typer] resolve: Let(("_", Var(None)), If(LE(Var("j"), Prim(Var("n"), Int(1), Sub, kind=None)), Let(("b2", Var(None)), Get(Var("bodies"), Var("j")), LetTuple([("b2x", Var(None)), ("b2y", Var(None)), ("b2z", Var(None)), ("b2vx", Var(None)), ("b2vy", Var(None)), ("b2vz", Var(None)), ("b2m", Var(None))], Var("b2"), Let(("dx", Var(None)), Prim(Var("bx"), Var("b2x"), Sub, kind=None), Let(("dy", Var(None)), Prim(Var("by"), Var("b2y"), Sub, kind=None), Let(("dz", Var(None)), Prim(Var("bz"), Var("b2z"), Sub, kind=None), Let(("dist2", Var(None)), Prim(Prim(Prim(Var("dx"), Var("dx"), Mul, kind=None), Prim(Var("dy"), Var("dy"), Mul, kind=None), Add, kind=None), Prim(Var("dz"), Var("dz"), Mul, kind=None), Add, kind=None), Let(("mag", Var(None)), Prim(Var("dt"), Prim(Var("dist2"), App(Var("sqrt"), targs=None, [Var("dist2")]), Mul, kind=None), Div, kind=None), Let(("new_b", Var(None)), Tuple([Var("bx"), Var("by"), Var("bz"), Prim(Var("bvx"), Prim(Prim(Var("dx"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Prim(Var("bvy"), Prim(Prim(Var("dy"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Prim(Var("bvz"), Prim(Prim(Var("dz"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Var("bm")]), Let(("_", Var(None)), Put(Var("bodies"), Var("i"), Var("new_b")), Let(("new_b2", Var(None)), Tuple([Var("b2x"), Var("b2y"), Var("b2z"), Prim(Var("b2vx"), Prim(Prim(Var("dx"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Prim(Var("b2vy"), Prim(Prim(Var("dy"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Prim(Var("b2vz"), Prim(Prim(Var("dz"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Var("b2m")]), Let(("_", Var(None)), Put(Var("bodies"), Var("j"), Var("new_b2")), Let(("_", Var(None)), App(Var("loop_j"), targs=None, [Prim(Var("j"), Int(1), Add, kind=None)]), Unit)))))))))))), Unit), Unit)
// [Typer] resolve: If(LE(Var("j"), Prim(Var("n"), Int(1), Sub, kind=None)), Let(("b2", Var(None)), Get(Var("bodies"), Var("j")), LetTuple([("b2x", Var(None)), ("b2y", Var(None)), ("b2z", Var(None)), ("b2vx", Var(None)), ("b2vy", Var(None)), ("b2vz", Var(None)), ("b2m", Var(None))], Var("b2"), Let(("dx", Var(None)), Prim(Var("bx"), Var("b2x"), Sub, kind=None), Let(("dy", Var(None)), Prim(Var("by"), Var("b2y"), Sub, kind=None), Let(("dz", Var(None)), Prim(Var("bz"), Var("b2z"), Sub, kind=None), Let(("dist2", Var(None)), Prim(Prim(Prim(Var("dx"), Var("dx"), Mul, kind=None), Prim(Var("dy"), Var("dy"), Mul, kind=None), Add, kind=None), Prim(Var("dz"), Var("dz"), Mul, kind=None), Add, kind=None), Let(("mag", Var(None)), Prim(Var("dt"), Prim(Var("dist2"), App(Var("sqrt"), targs=None, [Var("dist2")]), Mul, kind=None), Div, kind=None), Let(("new_b", Var(None)), Tuple([Var("bx"), Var("by"), Var("bz"), Prim(Var("bvx"), Prim(Prim(Var("dx"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Prim(Var("bvy"), Prim(Prim(Var("dy"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Prim(Var("bvz"), Prim(Prim(Var("dz"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Var("bm")]), Let(("_", Var(None)), Put(Var("bodies"), Var("i"), Var("new_b")), Let(("new_b2", Var(None)), Tuple([Var("b2x"), Var("b2y"), Var("b2z"), Prim(Var("b2vx"), Prim(Prim(Var("dx"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Prim(Var("b2vy"), Prim(Prim(Var("dy"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Prim(Var("b2vz"), Prim(Prim(Var("dz"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Var("b2m")]), Let(("_", Var(None)), Put(Var("bodies"), Var("j"), Var("new_b2")), Let(("_", Var(None)), App(Var("loop_j"), targs=None, [Prim(Var("j"), Int(1), Add, kind=None)]), Unit)))))))))))), Unit)
// [Typer] resolve: LE(Var("j"), Prim(Var("n"), Int(1), Sub, kind=None))
// [Typer] resolve: Var("j")
// [Typer] resolve: Prim(Var("n"), Int(1), Sub, kind=None)
// [Typer] resolve: Var("n")
// [Typer] resolve: Int(1)
// [Typer] resolve: Let(("b2", Var(None)), Get(Var("bodies"), Var("j")), LetTuple([("b2x", Var(None)), ("b2y", Var(None)), ("b2z", Var(None)), ("b2vx", Var(None)), ("b2vy", Var(None)), ("b2vz", Var(None)), ("b2m", Var(None))], Var("b2"), Let(("dx", Var(None)), Prim(Var("bx"), Var("b2x"), Sub, kind=None), Let(("dy", Var(None)), Prim(Var("by"), Var("b2y"), Sub, kind=None), Let(("dz", Var(None)), Prim(Var("bz"), Var("b2z"), Sub, kind=None), Let(("dist2", Var(None)), Prim(Prim(Prim(Var("dx"), Var("dx"), Mul, kind=None), Prim(Var("dy"), Var("dy"), Mul, kind=None), Add, kind=None), Prim(Var("dz"), Var("dz"), Mul, kind=None), Add, kind=None), Let(("mag", Var(None)), Prim(Var("dt"), Prim(Var("dist2"), App(Var("sqrt"), targs=None, [Var("dist2")]), Mul, kind=None), Div, kind=None), Let(("new_b", Var(None)), Tuple([Var("bx"), Var("by"), Var("bz"), Prim(Var("bvx"), Prim(Prim(Var("dx"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Prim(Var("bvy"), Prim(Prim(Var("dy"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Prim(Var("bvz"), Prim(Prim(Var("dz"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Var("bm")]), Let(("_", Var(None)), Put(Var("bodies"), Var("i"), Var("new_b")), Let(("new_b2", Var(None)), Tuple([Var("b2x"), Var("b2y"), Var("b2z"), Prim(Var("b2vx"), Prim(Prim(Var("dx"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Prim(Var("b2vy"), Prim(Prim(Var("dy"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Prim(Var("b2vz"), Prim(Prim(Var("dz"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Var("b2m")]), Let(("_", Var(None)), Put(Var("bodies"), Var("j"), Var("new_b2")), Let(("_", Var(None)), App(Var("loop_j"), targs=None, [Prim(Var("j"), Int(1), Add, kind=None)]), Unit))))))))))))
// [Typer] resolve: Get(Var("bodies"), Var("j"))
// [Typer] resolve: Var("bodies")
// [Typer] resolve: Var("j")
// [Typer] resolve: LetTuple([("b2x", Var(None)), ("b2y", Var(None)), ("b2z", Var(None)), ("b2vx", Var(None)), ("b2vy", Var(None)), ("b2vz", Var(None)), ("b2m", Var(None))], Var("b2"), Let(("dx", Var(None)), Prim(Var("bx"), Var("b2x"), Sub, kind=None), Let(("dy", Var(None)), Prim(Var("by"), Var("b2y"), Sub, kind=None), Let(("dz", Var(None)), Prim(Var("bz"), Var("b2z"), Sub, kind=None), Let(("dist2", Var(None)), Prim(Prim(Prim(Var("dx"), Var("dx"), Mul, kind=None), Prim(Var("dy"), Var("dy"), Mul, kind=None), Add, kind=None), Prim(Var("dz"), Var("dz"), Mul, kind=None), Add, kind=None), Let(("mag", Var(None)), Prim(Var("dt"), Prim(Var("dist2"), App(Var("sqrt"), targs=None, [Var("dist2")]), Mul, kind=None), Div, kind=None), Let(("new_b", Var(None)), Tuple([Var("bx"), Var("by"), Var("bz"), Prim(Var("bvx"), Prim(Prim(Var("dx"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Prim(Var("bvy"), Prim(Prim(Var("dy"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Prim(Var("bvz"), Prim(Prim(Var("dz"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Var("bm")]), Let(("_", Var(None)), Put(Var("bodies"), Var("i"), Var("new_b")), Let(("new_b2", Var(None)), Tuple([Var("b2x"), Var("b2y"), Var("b2z"), Prim(Var("b2vx"), Prim(Prim(Var("dx"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Prim(Var("b2vy"), Prim(Prim(Var("dy"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Prim(Var("b2vz"), Prim(Prim(Var("dz"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Var("b2m")]), Let(("_", Var(None)), Put(Var("bodies"), Var("j"), Var("new_b2")), Let(("_", Var(None)), App(Var("loop_j"), targs=None, [Prim(Var("j"), Int(1), Add, kind=None)]), Unit)))))))))))
// [Typer] resolve: Var("b2")
// [Typer] resolve: Let(("dx", Var(None)), Prim(Var("bx"), Var("b2x"), Sub, kind=None), Let(("dy", Var(None)), Prim(Var("by"), Var("b2y"), Sub, kind=None), Let(("dz", Var(None)), Prim(Var("bz"), Var("b2z"), Sub, kind=None), Let(("dist2", Var(None)), Prim(Prim(Prim(Var("dx"), Var("dx"), Mul, kind=None), Prim(Var("dy"), Var("dy"), Mul, kind=None), Add, kind=None), Prim(Var("dz"), Var("dz"), Mul, kind=None), Add, kind=None), Let(("mag", Var(None)), Prim(Var("dt"), Prim(Var("dist2"), App(Var("sqrt"), targs=None, [Var("dist2")]), Mul, kind=None), Div, kind=None), Let(("new_b", Var(None)), Tuple([Var("bx"), Var("by"), Var("bz"), Prim(Var("bvx"), Prim(Prim(Var("dx"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Prim(Var("bvy"), Prim(Prim(Var("dy"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Prim(Var("bvz"), Prim(Prim(Var("dz"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Var("bm")]), Let(("_", Var(None)), Put(Var("bodies"), Var("i"), Var("new_b")), Let(("new_b2", Var(None)), Tuple([Var("b2x"), Var("b2y"), Var("b2z"), Prim(Var("b2vx"), Prim(Prim(Var("dx"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Prim(Var("b2vy"), Prim(Prim(Var("dy"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Prim(Var("b2vz"), Prim(Prim(Var("dz"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Var("b2m")]), Let(("_", Var(None)), Put(Var("bodies"), Var("j"), Var("new_b2")), Let(("_", Var(None)), App(Var("loop_j"), targs=None, [Prim(Var("j"), Int(1), Add, kind=None)]), Unit))))))))))
// [Typer] resolve: Prim(Var("bx"), Var("b2x"), Sub, kind=None)
// [Typer] resolve: Var("bx")
// [Typer] resolve: Var("b2x")
// [Typer] resolve: Let(("dy", Var(None)), Prim(Var("by"), Var("b2y"), Sub, kind=None), Let(("dz", Var(None)), Prim(Var("bz"), Var("b2z"), Sub, kind=None), Let(("dist2", Var(None)), Prim(Prim(Prim(Var("dx"), Var("dx"), Mul, kind=None), Prim(Var("dy"), Var("dy"), Mul, kind=None), Add, kind=None), Prim(Var("dz"), Var("dz"), Mul, kind=None), Add, kind=None), Let(("mag", Var(None)), Prim(Var("dt"), Prim(Var("dist2"), App(Var("sqrt"), targs=None, [Var("dist2")]), Mul, kind=None), Div, kind=None), Let(("new_b", Var(None)), Tuple([Var("bx"), Var("by"), Var("bz"), Prim(Var("bvx"), Prim(Prim(Var("dx"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Prim(Var("bvy"), Prim(Prim(Var("dy"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Prim(Var("bvz"), Prim(Prim(Var("dz"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Var("bm")]), Let(("_", Var(None)), Put(Var("bodies"), Var("i"), Var("new_b")), Let(("new_b2", Var(None)), Tuple([Var("b2x"), Var("b2y"), Var("b2z"), Prim(Var("b2vx"), Prim(Prim(Var("dx"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Prim(Var("b2vy"), Prim(Prim(Var("dy"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Prim(Var("b2vz"), Prim(Prim(Var("dz"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Var("b2m")]), Let(("_", Var(None)), Put(Var("bodies"), Var("j"), Var("new_b2")), Let(("_", Var(None)), App(Var("loop_j"), targs=None, [Prim(Var("j"), Int(1), Add, kind=None)]), Unit)))))))))
// [Typer] resolve: Prim(Var("by"), Var("b2y"), Sub, kind=None)
// [Typer] resolve: Var("by")
// [Typer] resolve: Var("b2y")
// [Typer] resolve: Let(("dz", Var(None)), Prim(Var("bz"), Var("b2z"), Sub, kind=None), Let(("dist2", Var(None)), Prim(Prim(Prim(Var("dx"), Var("dx"), Mul, kind=None), Prim(Var("dy"), Var("dy"), Mul, kind=None), Add, kind=None), Prim(Var("dz"), Var("dz"), Mul, kind=None), Add, kind=None), Let(("mag", Var(None)), Prim(Var("dt"), Prim(Var("dist2"), App(Var("sqrt"), targs=None, [Var("dist2")]), Mul, kind=None), Div, kind=None), Let(("new_b", Var(None)), Tuple([Var("bx"), Var("by"), Var("bz"), Prim(Var("bvx"), Prim(Prim(Var("dx"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Prim(Var("bvy"), Prim(Prim(Var("dy"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Prim(Var("bvz"), Prim(Prim(Var("dz"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Var("bm")]), Let(("_", Var(None)), Put(Var("bodies"), Var("i"), Var("new_b")), Let(("new_b2", Var(None)), Tuple([Var("b2x"), Var("b2y"), Var("b2z"), Prim(Var("b2vx"), Prim(Prim(Var("dx"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Prim(Var("b2vy"), Prim(Prim(Var("dy"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Prim(Var("b2vz"), Prim(Prim(Var("dz"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Var("b2m")]), Let(("_", Var(None)), Put(Var("bodies"), Var("j"), Var("new_b2")), Let(("_", Var(None)), App(Var("loop_j"), targs=None, [Prim(Var("j"), Int(1), Add, kind=None)]), Unit))))))))
// [Typer] resolve: Prim(Var("bz"), Var("b2z"), Sub, kind=None)
// [Typer] resolve: Var("bz")
// [Typer] resolve: Var("b2z")
// [Typer] resolve: Let(("dist2", Var(None)), Prim(Prim(Prim(Var("dx"), Var("dx"), Mul, kind=None), Prim(Var("dy"), Var("dy"), Mul, kind=None), Add, kind=None), Prim(Var("dz"), Var("dz"), Mul, kind=None), Add, kind=None), Let(("mag", Var(None)), Prim(Var("dt"), Prim(Var("dist2"), App(Var("sqrt"), targs=None, [Var("dist2")]), Mul, kind=None), Div, kind=None), Let(("new_b", Var(None)), Tuple([Var("bx"), Var("by"), Var("bz"), Prim(Var("bvx"), Prim(Prim(Var("dx"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Prim(Var("bvy"), Prim(Prim(Var("dy"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Prim(Var("bvz"), Prim(Prim(Var("dz"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Var("bm")]), Let(("_", Var(None)), Put(Var("bodies"), Var("i"), Var("new_b")), Let(("new_b2", Var(None)), Tuple([Var("b2x"), Var("b2y"), Var("b2z"), Prim(Var("b2vx"), Prim(Prim(Var("dx"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Prim(Var("b2vy"), Prim(Prim(Var("dy"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Prim(Var("b2vz"), Prim(Prim(Var("dz"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Var("b2m")]), Let(("_", Var(None)), Put(Var("bodies"), Var("j"), Var("new_b2")), Let(("_", Var(None)), App(Var("loop_j"), targs=None, [Prim(Var("j"), Int(1), Add, kind=None)]), Unit)))))))
// [Typer] resolve: Prim(Prim(Prim(Var("dx"), Var("dx"), Mul, kind=None), Prim(Var("dy"), Var("dy"), Mul, kind=None), Add, kind=None), Prim(Var("dz"), Var("dz"), Mul, kind=None), Add, kind=None)
// [Typer] resolve: Prim(Prim(Var("dx"), Var("dx"), Mul, kind=None), Prim(Var("dy"), Var("dy"), Mul, kind=None), Add, kind=None)
// [Typer] resolve: Prim(Var("dx"), Var("dx"), Mul, kind=None)
// [Typer] resolve: Var("dx")
// [Typer] resolve: Var("dx")
// [Typer] resolve: Prim(Var("dy"), Var("dy"), Mul, kind=None)
// [Typer] resolve: Var("dy")
// [Typer] resolve: Var("dy")
// [Typer] resolve: Prim(Var("dz"), Var("dz"), Mul, kind=None)
// [Typer] resolve: Var("dz")
// [Typer] resolve: Var("dz")
// [Typer] resolve: Let(("mag", Var(None)), Prim(Var("dt"), Prim(Var("dist2"), App(Var("sqrt"), targs=None, [Var("dist2")]), Mul, kind=None), Div, kind=None), Let(("new_b", Var(None)), Tuple([Var("bx"), Var("by"), Var("bz"), Prim(Var("bvx"), Prim(Prim(Var("dx"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Prim(Var("bvy"), Prim(Prim(Var("dy"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Prim(Var("bvz"), Prim(Prim(Var("dz"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Var("bm")]), Let(("_", Var(None)), Put(Var("bodies"), Var("i"), Var("new_b")), Let(("new_b2", Var(None)), Tuple([Var("b2x"), Var("b2y"), Var("b2z"), Prim(Var("b2vx"), Prim(Prim(Var("dx"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Prim(Var("b2vy"), Prim(Prim(Var("dy"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Prim(Var("b2vz"), Prim(Prim(Var("dz"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Var("b2m")]), Let(("_", Var(None)), Put(Var("bodies"), Var("j"), Var("new_b2")), Let(("_", Var(None)), App(Var("loop_j"), targs=None, [Prim(Var("j"), Int(1), Add, kind=None)]), Unit))))))
// [Typer] resolve: Prim(Var("dt"), Prim(Var("dist2"), App(Var("sqrt"), targs=None, [Var("dist2")]), Mul, kind=None), Div, kind=None)
// [Typer] resolve: Var("dt")
// [Typer] resolve: Prim(Var("dist2"), App(Var("sqrt"), targs=None, [Var("dist2")]), Mul, kind=None)
// [Typer] resolve: Var("dist2")
// [Typer] resolve: App(Var("sqrt"), targs=None, [Var("dist2")])
// [Typer] resolve: Var("dist2")
// [Typer] resolve: Var("sqrt")
// [Typer] resolve: Let(("new_b", Var(None)), Tuple([Var("bx"), Var("by"), Var("bz"), Prim(Var("bvx"), Prim(Prim(Var("dx"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Prim(Var("bvy"), Prim(Prim(Var("dy"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Prim(Var("bvz"), Prim(Prim(Var("dz"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Var("bm")]), Let(("_", Var(None)), Put(Var("bodies"), Var("i"), Var("new_b")), Let(("new_b2", Var(None)), Tuple([Var("b2x"), Var("b2y"), Var("b2z"), Prim(Var("b2vx"), Prim(Prim(Var("dx"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Prim(Var("b2vy"), Prim(Prim(Var("dy"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Prim(Var("b2vz"), Prim(Prim(Var("dz"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Var("b2m")]), Let(("_", Var(None)), Put(Var("bodies"), Var("j"), Var("new_b2")), Let(("_", Var(None)), App(Var("loop_j"), targs=None, [Prim(Var("j"), Int(1), Add, kind=None)]), Unit)))))
// [Typer] resolve: Tuple([Var("bx"), Var("by"), Var("bz"), Prim(Var("bvx"), Prim(Prim(Var("dx"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Prim(Var("bvy"), Prim(Prim(Var("dy"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Prim(Var("bvz"), Prim(Prim(Var("dz"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Var("bm")])
// [Typer] resolve: Let(("_", Var(None)), Put(Var("bodies"), Var("i"), Var("new_b")), Let(("new_b2", Var(None)), Tuple([Var("b2x"), Var("b2y"), Var("b2z"), Prim(Var("b2vx"), Prim(Prim(Var("dx"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Prim(Var("b2vy"), Prim(Prim(Var("dy"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Prim(Var("b2vz"), Prim(Prim(Var("dz"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Var("b2m")]), Let(("_", Var(None)), Put(Var("bodies"), Var("j"), Var("new_b2")), Let(("_", Var(None)), App(Var("loop_j"), targs=None, [Prim(Var("j"), Int(1), Add, kind=None)]), Unit))))
// [Typer] resolve: Put(Var("bodies"), Var("i"), Var("new_b"))
// [Typer] resolve: Var("bodies")
// [Typer] resolve: Var("i")
// [Typer] resolve: Var("new_b")
// [Typer] resolve: Let(("new_b2", Var(None)), Tuple([Var("b2x"), Var("b2y"), Var("b2z"), Prim(Var("b2vx"), Prim(Prim(Var("dx"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Prim(Var("b2vy"), Prim(Prim(Var("dy"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Prim(Var("b2vz"), Prim(Prim(Var("dz"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Var("b2m")]), Let(("_", Var(None)), Put(Var("bodies"), Var("j"), Var("new_b2")), Let(("_", Var(None)), App(Var("loop_j"), targs=None, [Prim(Var("j"), Int(1), Add, kind=None)]), Unit)))
// [Typer] resolve: Tuple([Var("b2x"), Var("b2y"), Var("b2z"), Prim(Var("b2vx"), Prim(Prim(Var("dx"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Prim(Var("b2vy"), Prim(Prim(Var("dy"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Prim(Var("b2vz"), Prim(Prim(Var("dz"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Var("b2m")])
// [Typer] resolve: Let(("_", Var(None)), Put(Var("bodies"), Var("j"), Var("new_b2")), Let(("_", Var(None)), App(Var("loop_j"), targs=None, [Prim(Var("j"), Int(1), Add, kind=None)]), Unit))
// [Typer] resolve: Put(Var("bodies"), Var("j"), Var("new_b2"))
// [Typer] resolve: Var("bodies")
// [Typer] resolve: Var("j")
// [Typer] resolve: Var("new_b2")
// [Typer] resolve: Let(("_", Var(None)), App(Var("loop_j"), targs=None, [Prim(Var("j"), Int(1), Add, kind=None)]), Unit)
// [Typer] resolve: App(Var("loop_j"), targs=None, [Prim(Var("j"), Int(1), Add, kind=None)])
// [Typer] resolve: Prim(Var("j"), Int(1), Add, kind=None)
// [Typer] resolve: Var("j")
// [Typer] resolve: Int(1)
// [Typer] resolve: Var("loop_j")
// [Typer] resolve: Unit
// [Typer] resolve: Unit
// [Typer] resolve: Unit
// [Typer] resolve: Let(("_", Var(None)), App(Var("loop_j"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Unit))
// [Typer] resolve: App(Var("loop_j"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)])
// [Typer] resolve: Prim(Var("i"), Int(1), Add, kind=None)
// [Typer] resolve: Var("i")
// [Typer] resolve: Int(1)
// [Typer] resolve: Var("loop_j")
// [Typer] resolve: Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Unit)
// [Typer] resolve: App(Var("loop_i"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)])
// [Typer] resolve: Prim(Var("i"), Int(1), Add, kind=None)
// [Typer] resolve: Var("i")
// [Typer] resolve: Int(1)
// [Typer] resolve: Var("loop_i")
// [Typer] resolve: Unit
// [Typer] resolve: Unit
// [Typer] resolve: Unit
// [Typer] resolve: Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Int(0)]), LetRec({tyvars: [], name: ("update_axis", Var(None)), args: [("i", Int)], body: Let(("_", Var(None)), If(LE(Var("i"), Prim(Var("n"), Int(1), Sub, kind=None)), Let(("b", Var(None)), Get(Var("bodies"), Var("i")), LetTuple([("bx", Var(None)), ("by", Var(None)), ("bz", Var(None)), ("bvx", Var(None)), ("bvy", Var(None)), ("bvz", Var(None)), ("bm", Var(None))], Var("b"), Let(("new_b", Var(None)), Tuple([Prim(Var("bx"), Prim(Var("dt"), Var("bvx"), Mul, kind=None), Add, kind=None), Prim(Var("by"), Prim(Var("dt"), Var("bvy"), Mul, kind=None), Add, kind=None), Prim(Var("bz"), Prim(Var("dt"), Var("bvz"), Mul, kind=None), Add, kind=None), Var("bvx"), Var("bvy"), Var("bvz"), Var("bm")]), Let(("_", Var(None)), Put(Var("bodies"), Var("i"), Var("new_b")), Let(("_", Var(None)), App(Var("update_axis"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Unit))))), Unit), Unit)}, Let(("_", Var(None)), App(Var("update_axis"), targs=None, [Int(0)]), Unit)))
// [Typer] resolve: App(Var("loop_i"), targs=None, [Int(0)])
// [Typer] resolve: Int(0)
// [Typer] resolve: Var("loop_i")
// [Typer] resolve: LetRec({tyvars: [], name: ("update_axis", Var(None)), args: [("i", Int)], body: Let(("_", Var(None)), If(LE(Var("i"), Prim(Var("n"), Int(1), Sub, kind=None)), Let(("b", Var(None)), Get(Var("bodies"), Var("i")), LetTuple([("bx", Var(None)), ("by", Var(None)), ("bz", Var(None)), ("bvx", Var(None)), ("bvy", Var(None)), ("bvz", Var(None)), ("bm", Var(None))], Var("b"), Let(("new_b", Var(None)), Tuple([Prim(Var("bx"), Prim(Var("dt"), Var("bvx"), Mul, kind=None), Add, kind=None), Prim(Var("by"), Prim(Var("dt"), Var("bvy"), Mul, kind=None), Add, kind=None), Prim(Var("bz"), Prim(Var("dt"), Var("bvz"), Mul, kind=None), Add, kind=None), Var("bvx"), Var("bvy"), Var("bvz"), Var("bm")]), Let(("_", Var(None)), Put(Var("bodies"), Var("i"), Var("new_b")), Let(("_", Var(None)), App(Var("update_axis"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Unit))))), Unit), Unit)}, Let(("_", Var(None)), App(Var("update_axis"), targs=None, [Int(0)]), Unit))
// [Typer] resolve: Let(("_", Var(None)), If(LE(Var("i"), Prim(Var("n"), Int(1), Sub, kind=None)), Let(("b", Var(None)), Get(Var("bodies"), Var("i")), LetTuple([("bx", Var(None)), ("by", Var(None)), ("bz", Var(None)), ("bvx", Var(None)), ("bvy", Var(None)), ("bvz", Var(None)), ("bm", Var(None))], Var("b"), Let(("new_b", Var(None)), Tuple([Prim(Var("bx"), Prim(Var("dt"), Var("bvx"), Mul, kind=None), Add, kind=None), Prim(Var("by"), Prim(Var("dt"), Var("bvy"), Mul, kind=None), Add, kind=None), Prim(Var("bz"), Prim(Var("dt"), Var("bvz"), Mul, kind=None), Add, kind=None), Var("bvx"), Var("bvy"), Var("bvz"), Var("bm")]), Let(("_", Var(None)), Put(Var("bodies"), Var("i"), Var("new_b")), Let(("_", Var(None)), App(Var("update_axis"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Unit))))), Unit), Unit)
// [Typer] resolve: If(LE(Var("i"), Prim(Var("n"), Int(1), Sub, kind=None)), Let(("b", Var(None)), Get(Var("bodies"), Var("i")), LetTuple([("bx", Var(None)), ("by", Var(None)), ("bz", Var(None)), ("bvx", Var(None)), ("bvy", Var(None)), ("bvz", Var(None)), ("bm", Var(None))], Var("b"), Let(("new_b", Var(None)), Tuple([Prim(Var("bx"), Prim(Var("dt"), Var("bvx"), Mul, kind=None), Add, kind=None), Prim(Var("by"), Prim(Var("dt"), Var("bvy"), Mul, kind=None), Add, kind=None), Prim(Var("bz"), Prim(Var("dt"), Var("bvz"), Mul, kind=None), Add, kind=None), Var("bvx"), Var("bvy"), Var("bvz"), Var("bm")]), Let(("_", Var(None)), Put(Var("bodies"), Var("i"), Var("new_b")), Let(("_", Var(None)), App(Var("update_axis"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Unit))))), Unit)
// [Typer] resolve: LE(Var("i"), Prim(Var("n"), Int(1), Sub, kind=None))
// [Typer] resolve: Var("i")
// [Typer] resolve: Prim(Var("n"), Int(1), Sub, kind=None)
// [Typer] resolve: Var("n")
// [Typer] resolve: Int(1)
// [Typer] resolve: Let(("b", Var(None)), Get(Var("bodies"), Var("i")), LetTuple([("bx", Var(None)), ("by", Var(None)), ("bz", Var(None)), ("bvx", Var(None)), ("bvy", Var(None)), ("bvz", Var(None)), ("bm", Var(None))], Var("b"), Let(("new_b", Var(None)), Tuple([Prim(Var("bx"), Prim(Var("dt"), Var("bvx"), Mul, kind=None), Add, kind=None), Prim(Var("by"), Prim(Var("dt"), Var("bvy"), Mul, kind=None), Add, kind=None), Prim(Var("bz"), Prim(Var("dt"), Var("bvz"), Mul, kind=None), Add, kind=None), Var("bvx"), Var("bvy"), Var("bvz"), Var("bm")]), Let(("_", Var(None)), Put(Var("bodies"), Var("i"), Var("new_b")), Let(("_", Var(None)), App(Var("update_axis"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Unit)))))
// [Typer] resolve: Get(Var("bodies"), Var("i"))
// [Typer] resolve: Var("bodies")
// [Typer] resolve: Var("i")
// [Typer] resolve: LetTuple([("bx", Var(None)), ("by", Var(None)), ("bz", Var(None)), ("bvx", Var(None)), ("bvy", Var(None)), ("bvz", Var(None)), ("bm", Var(None))], Var("b"), Let(("new_b", Var(None)), Tuple([Prim(Var("bx"), Prim(Var("dt"), Var("bvx"), Mul, kind=None), Add, kind=None), Prim(Var("by"), Prim(Var("dt"), Var("bvy"), Mul, kind=None), Add, kind=None), Prim(Var("bz"), Prim(Var("dt"), Var("bvz"), Mul, kind=None), Add, kind=None), Var("bvx"), Var("bvy"), Var("bvz"), Var("bm")]), Let(("_", Var(None)), Put(Var("bodies"), Var("i"), Var("new_b")), Let(("_", Var(None)), App(Var("update_axis"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Unit))))
// [Typer] resolve: Var("b")
// [Typer] resolve: Let(("new_b", Var(None)), Tuple([Prim(Var("bx"), Prim(Var("dt"), Var("bvx"), Mul, kind=None), Add, kind=None), Prim(Var("by"), Prim(Var("dt"), Var("bvy"), Mul, kind=None), Add, kind=None), Prim(Var("bz"), Prim(Var("dt"), Var("bvz"), Mul, kind=None), Add, kind=None), Var("bvx"), Var("bvy"), Var("bvz"), Var("bm")]), Let(("_", Var(None)), Put(Var("bodies"), Var("i"), Var("new_b")), Let(("_", Var(None)), App(Var("update_axis"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Unit)))
// [Typer] resolve: Tuple([Prim(Var("bx"), Prim(Var("dt"), Var("bvx"), Mul, kind=None), Add, kind=None), Prim(Var("by"), Prim(Var("dt"), Var("bvy"), Mul, kind=None), Add, kind=None), Prim(Var("bz"), Prim(Var("dt"), Var("bvz"), Mul, kind=None), Add, kind=None), Var("bvx"), Var("bvy"), Var("bvz"), Var("bm")])
// [Typer] resolve: Let(("_", Var(None)), Put(Var("bodies"), Var("i"), Var("new_b")), Let(("_", Var(None)), App(Var("update_axis"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Unit))
// [Typer] resolve: Put(Var("bodies"), Var("i"), Var("new_b"))
// [Typer] resolve: Var("bodies")
// [Typer] resolve: Var("i")
// [Typer] resolve: Var("new_b")
// [Typer] resolve: Let(("_", Var(None)), App(Var("update_axis"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Unit)
// [Typer] resolve: App(Var("update_axis"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)])
// [Typer] resolve: Prim(Var("i"), Int(1), Add, kind=None)
// [Typer] resolve: Var("i")
// [Typer] resolve: Int(1)
// [Typer] resolve: Var("update_axis")
// [Typer] resolve: Unit
// [Typer] resolve: Unit
// [Typer] resolve: Unit
// [Typer] resolve: Let(("_", Var(None)), App(Var("update_axis"), targs=None, [Int(0)]), Unit)
// [Typer] resolve: App(Var("update_axis"), targs=None, [Int(0)])
// [Typer] resolve: Int(0)
// [Typer] resolve: Var("update_axis")
// [Typer] resolve: Unit
// [Typer] resolve: LetRec({tyvars: [], name: ("energy", Double), args: [("bodies", Array[(Double, Double, Double, Double, Double, Double, Double)])], body: Let(("n", Var(None)), Int(5), Let(("e", Var(None)), Array(Int(1), Double(0)), LetRec({tyvars: [], name: ("loop_i", Var(None)), args: [("i", Int)], body: Let(("_", Var(None)), If(LE(Var("i"), Prim(Var("n"), Int(1), Sub, kind=None)), Let(("b", Var(None)), Get(Var("bodies"), Var("i")), LetTuple([("bx", Var(None)), ("by", Var(None)), ("bz", Var(None)), ("bvx", Var(None)), ("bvy", Var(None)), ("bvz", Var(None)), ("bm", Var(None))], Var("b"), Let(("_", Var(None)), Put(Var("e"), Int(0), Prim(Get(Var("e"), Int(0)), Prim(Prim(Double(0.5), Var("bm"), Mul, kind=None), Prim(Prim(Prim(Var("bvx"), Var("bvx"), Mul, kind=None), Prim(Var("bvy"), Var("bvy"), Mul, kind=None), Add, kind=None), Prim(Var("bvz"), Var("bvz"), Mul, kind=None), Add, kind=None), Mul, kind=None), Add, kind=None)), LetRec({tyvars: [], name: ("loop_j", Var(None)), args: [("j", Int)], body: Let(("_", Var(None)), If(LE(Var("j"), Prim(Var("n"), Int(1), Sub, kind=None)), Let(("b2", Var(None)), Get(Var("bodies"), Var("j")), LetTuple([("b2x", Var(None)), ("b2y", Var(None)), ("b2z", Var(None)), ("b2vx", Var(None)), ("b2vy", Var(None)), ("b2vz", Var(None)), ("b2m", Var(None))], Var("b2"), Let(("dx", Var(None)), Prim(Var("bx"), Var("b2x"), Sub, kind=None), Let(("dy", Var(None)), Prim(Var("by"), Var("b2y"), Sub, kind=None), Let(("dz", Var(None)), Prim(Var("bz"), Var("b2z"), Sub, kind=None), Let(("dist2", Var(None)), Prim(Prim(Prim(Var("dx"), Var("dx"), Mul, kind=None), Prim(Var("dy"), Var("dy"), Mul, kind=None), Add, kind=None), Prim(Var("dz"), Var("dz"), Mul, kind=None), Add, kind=None), Let(("_", Var(None)), Put(Var("e"), Int(0), Prim(Get(Var("e"), Int(0)), Prim(Prim(Var("bm"), Var("b2m"), Mul, kind=None), App(Var("sqrt"), targs=None, [Var("dist2")]), Div, kind=None), Sub, kind=None)), Let(("_", Var(None)), App(Var("loop_j"), targs=None, [Prim(Var("j"), Int(1), Add, kind=None)]), Unit)))))))), Unit), Unit)}, Let(("_", Var(None)), App(Var("loop_j"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Unit)))))), Unit), Unit)}, Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Int(0)]), Get(Var("e"), Int(0))))))}, LetRec({tyvars: [], name: ("offset_momentum", Unit), args: [("bodies", Array[(Double, Double, Double, Double, Double, Double, Double)])], body: Let(("n", Var(None)), Int(5), Let(("px", Var(None)), Array(Int(1), Double(0)), Let(("py", Var(None)), Array(Int(1), Double(0)), Let(("pz", Var(None)), Array(Int(1), Double(0)), LetRec({tyvars: [], name: ("loop_i", Var(None)), args: [("i", Int)], body: Let(("_", Var(None)), If(LE(Var("i"), Prim(Var("n"), Int(1), Sub, kind=None)), Let(("b", Var(None)), Get(Var("bodies"), Var("i")), LetTuple([("bx", Var(None)), ("by", Var(None)), ("bz", Var(None)), ("bvx", Var(None)), ("bvy", Var(None)), ("bvz", Var(None)), ("bm", Var(None))], Var("b"), Let(("_", Var(None)), Put(Var("px"), Int(0), Prim(Get(Var("px"), Int(0)), Prim(Var("bvx"), Var("bm"), Mul, kind=None), Add, kind=None)), Let(("_", Var(None)), Put(Var("py"), Int(0), Prim(Get(Var("py"), Int(0)), Prim(Var("bvy"), Var("bm"), Mul, kind=None), Add, kind=None)), Let(("_", Var(None)), Put(Var("pz"), Int(0), Prim(Get(Var("pz"), Int(0)), Prim(Var("bvz"), Var("bm"), Mul, kind=None), Add, kind=None)), Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Unit)))))), Unit), Unit)}, Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Int(0)]), Let(("b", Var(None)), Get(Var("bodies"), Int(0)), LetTuple([("bx", Var(None)), ("by", Var(None)), ("bz", Var(None)), ("bvx", Var(None)), ("bvy", Var(None)), ("bvz", Var(None)), ("bm", Var(None))], Var("b"), Let(("new_b", Var(None)), Tuple([Var("bx"), Var("by"), Var("bz"), Neg(Prim(Get(Var("px"), Int(0)), Var("solar_mass"), Div, kind=None), kind=None), Neg(Prim(Get(Var("py"), Int(0)), Var("solar_mass"), Div, kind=None), kind=None), Neg(Prim(Get(Var("pz"), Int(0)), Var("solar_mass"), Div, kind=None), kind=None), Var("bm")]), Let(("_", Var(None)), Put(Var("bodies"), Int(0), Var("new_b")), Unit))))))))))}, LetRec({tyvars: [], name: ("main", Var(None)), args: [], body: Let(("jupiter", Var(None)), Tuple([Double(4.841431442464721), Neg(Double(1.1603200440274284), kind=None), Neg(Double(0.10362204447112311), kind=None), Prim(Double(0.001660076642744037), Var("days_per_year"), Mul, kind=None), Prim(Double(0.007699011184197404), Var("days_per_year"), Mul, kind=None), Neg(Prim(Double(0.0000690460016972063), Var("days_per_year"), Mul, kind=None), kind=None), Prim(Double(0.0009547919384243266), Var("solar_mass"), Mul, kind=None)]), Let(("saturn", Var(None)), Tuple([Double(8.34336671824458), Double(4.124798564124305), Neg(Double(0.4035234171143214), kind=None), Neg(Prim(Double(0.002767425107268624), Var("days_per_year"), Mul, kind=None), kind=None), Prim(Double(0.004998528012349172), Var("days_per_year"), Mul, kind=None), Prim(Double(0.000023029345528229068), Var("days_per_year"), Mul, kind=None), Prim(Double(0.0002858859806661308), Var("solar_mass"), Mul, kind=None)]), Let(("uranus", Var(None)), Tuple([Double(12.894369562139131), Neg(Double(15.111151401698631), kind=None), Neg(Double(0.22330757889265587), kind=None), Prim(Double(0.002964601375647616), Var("days_per_year"), Mul, kind=None), Prim(Double(0.0023784717395948095), Var("days_per_year"), Mul, kind=None), Neg(Prim(Double(0.000029658956854023756), Var("days_per_year"), Mul, kind=None), kind=None), Prim(Double(0.00004366244043351563), Var("solar_mass"), Mul, kind=None)]), Let(("neptune", Var(None)), Tuple([Double(15.379697114850917), Neg(Double(25.919314609987964), kind=None), Double(0.17925877295037118), Prim(Double(0.0026806777249038932), Var("days_per_year"), Mul, kind=None), Prim(Double(0.001628241700382423), Var("days_per_year"), Mul, kind=None), Neg(Prim(Double(0.00009515922545197159), Var("days_per_year"), Mul, kind=None), kind=None), Prim(Double(0.00005151389020466116), Var("solar_mass"), Mul, kind=None)]), Let(("sun", Var(None)), Tuple([Double(0), Double(0), Double(0), Double(0), Double(0), Double(0), Var("solar_mass")]), Let(("bodies", Var(None)), Array(Int(5), Tuple([Double(0), Double(0), Double(0), Double(0), Double(0), Double(0), Double(0)])), Let(("_", Var(None)), Put(Var("bodies"), Int(0), Var("sun")), Let(("_", Var(None)), Put(Var("bodies"), Int(1), Var("jupiter")), Let(("_", Var(None)), Put(Var("bodies"), Int(2), Var("saturn")), Let(("_", Var(None)), Put(Var("bodies"), Int(3), Var("uranus")), Let(("_", Var(None)), Put(Var("bodies"), Int(4), Var("neptune")), Let(("_", Var(None)), App(Var("offset_momentum"), targs=None, [Var("bodies")]), Let(("_", Var(None)), App(Var("print_int"), targs=None, [App(Var("int_of_float"), targs=None, [Prim(App(Var("energy"), targs=None, [Var("bodies")]), Double(1000000000), Mul, kind=None)])]), Let(("iters", Var(None)), Int(500000), LetRec({tyvars: [], name: ("loop_i", Var(None)), args: [("i", Int)], body: Let(("_", Var(None)), If(LE(Var("i"), Var("iters")), Let(("_", Var(None)), App(Var("advance"), targs=None, [Var("bodies"), Double(0.01)]), Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Unit)), Unit), Unit)}, Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Int(1)]), Let(("_", Var(None)), App(Var("print_char"), targs=None, [Int(10)]), Let(("_", Var(None)), App(Var("print_int"), targs=None, [App(Var("int_of_float"), targs=None, [Prim(App(Var("energy"), targs=None, [Var("bodies")]), Double(1000000000), Mul, kind=None)])]), Unit))))))))))))))))))}, Unit)))
// [Typer] resolve: Let(("n", Var(None)), Int(5), Let(("e", Var(None)), Array(Int(1), Double(0)), LetRec({tyvars: [], name: ("loop_i", Var(None)), args: [("i", Int)], body: Let(("_", Var(None)), If(LE(Var("i"), Prim(Var("n"), Int(1), Sub, kind=None)), Let(("b", Var(None)), Get(Var("bodies"), Var("i")), LetTuple([("bx", Var(None)), ("by", Var(None)), ("bz", Var(None)), ("bvx", Var(None)), ("bvy", Var(None)), ("bvz", Var(None)), ("bm", Var(None))], Var("b"), Let(("_", Var(None)), Put(Var("e"), Int(0), Prim(Get(Var("e"), Int(0)), Prim(Prim(Double(0.5), Var("bm"), Mul, kind=None), Prim(Prim(Prim(Var("bvx"), Var("bvx"), Mul, kind=None), Prim(Var("bvy"), Var("bvy"), Mul, kind=None), Add, kind=None), Prim(Var("bvz"), Var("bvz"), Mul, kind=None), Add, kind=None), Mul, kind=None), Add, kind=None)), LetRec({tyvars: [], name: ("loop_j", Var(None)), args: [("j", Int)], body: Let(("_", Var(None)), If(LE(Var("j"), Prim(Var("n"), Int(1), Sub, kind=None)), Let(("b2", Var(None)), Get(Var("bodies"), Var("j")), LetTuple([("b2x", Var(None)), ("b2y", Var(None)), ("b2z", Var(None)), ("b2vx", Var(None)), ("b2vy", Var(None)), ("b2vz", Var(None)), ("b2m", Var(None))], Var("b2"), Let(("dx", Var(None)), Prim(Var("bx"), Var("b2x"), Sub, kind=None), Let(("dy", Var(None)), Prim(Var("by"), Var("b2y"), Sub, kind=None), Let(("dz", Var(None)), Prim(Var("bz"), Var("b2z"), Sub, kind=None), Let(("dist2", Var(None)), Prim(Prim(Prim(Var("dx"), Var("dx"), Mul, kind=None), Prim(Var("dy"), Var("dy"), Mul, kind=None), Add, kind=None), Prim(Var("dz"), Var("dz"), Mul, kind=None), Add, kind=None), Let(("_", Var(None)), Put(Var("e"), Int(0), Prim(Get(Var("e"), Int(0)), Prim(Prim(Var("bm"), Var("b2m"), Mul, kind=None), App(Var("sqrt"), targs=None, [Var("dist2")]), Div, kind=None), Sub, kind=None)), Let(("_", Var(None)), App(Var("loop_j"), targs=None, [Prim(Var("j"), Int(1), Add, kind=None)]), Unit)))))))), Unit), Unit)}, Let(("_", Var(None)), App(Var("loop_j"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Unit)))))), Unit), Unit)}, Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Int(0)]), Get(Var("e"), Int(0))))))
// [Typer] resolve: Int(5)
// [Typer] resolve: Let(("e", Var(None)), Array(Int(1), Double(0)), LetRec({tyvars: [], name: ("loop_i", Var(None)), args: [("i", Int)], body: Let(("_", Var(None)), If(LE(Var("i"), Prim(Var("n"), Int(1), Sub, kind=None)), Let(("b", Var(None)), Get(Var("bodies"), Var("i")), LetTuple([("bx", Var(None)), ("by", Var(None)), ("bz", Var(None)), ("bvx", Var(None)), ("bvy", Var(None)), ("bvz", Var(None)), ("bm", Var(None))], Var("b"), Let(("_", Var(None)), Put(Var("e"), Int(0), Prim(Get(Var("e"), Int(0)), Prim(Prim(Double(0.5), Var("bm"), Mul, kind=None), Prim(Prim(Prim(Var("bvx"), Var("bvx"), Mul, kind=None), Prim(Var("bvy"), Var("bvy"), Mul, kind=None), Add, kind=None), Prim(Var("bvz"), Var("bvz"), Mul, kind=None), Add, kind=None), Mul, kind=None), Add, kind=None)), LetRec({tyvars: [], name: ("loop_j", Var(None)), args: [("j", Int)], body: Let(("_", Var(None)), If(LE(Var("j"), Prim(Var("n"), Int(1), Sub, kind=None)), Let(("b2", Var(None)), Get(Var("bodies"), Var("j")), LetTuple([("b2x", Var(None)), ("b2y", Var(None)), ("b2z", Var(None)), ("b2vx", Var(None)), ("b2vy", Var(None)), ("b2vz", Var(None)), ("b2m", Var(None))], Var("b2"), Let(("dx", Var(None)), Prim(Var("bx"), Var("b2x"), Sub, kind=None), Let(("dy", Var(None)), Prim(Var("by"), Var("b2y"), Sub, kind=None), Let(("dz", Var(None)), Prim(Var("bz"), Var("b2z"), Sub, kind=None), Let(("dist2", Var(None)), Prim(Prim(Prim(Var("dx"), Var("dx"), Mul, kind=None), Prim(Var("dy"), Var("dy"), Mul, kind=None), Add, kind=None), Prim(Var("dz"), Var("dz"), Mul, kind=None), Add, kind=None), Let(("_", Var(None)), Put(Var("e"), Int(0), Prim(Get(Var("e"), Int(0)), Prim(Prim(Var("bm"), Var("b2m"), Mul, kind=None), App(Var("sqrt"), targs=None, [Var("dist2")]), Div, kind=None), Sub, kind=None)), Let(("_", Var(None)), App(Var("loop_j"), targs=None, [Prim(Var("j"), Int(1), Add, kind=None)]), Unit)))))))), Unit), Unit)}, Let(("_", Var(None)), App(Var("loop_j"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Unit)))))), Unit), Unit)}, Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Int(0)]), Get(Var("e"), Int(0)))))
// [Typer] resolve: Array(Int(1), Double(0))
// [Typer] resolve: Int(1)
// [Typer] resolve: Double(0)
// [Typer] resolve: LetRec({tyvars: [], name: ("loop_i", Var(None)), args: [("i", Int)], body: Let(("_", Var(None)), If(LE(Var("i"), Prim(Var("n"), Int(1), Sub, kind=None)), Let(("b", Var(None)), Get(Var("bodies"), Var("i")), LetTuple([("bx", Var(None)), ("by", Var(None)), ("bz", Var(None)), ("bvx", Var(None)), ("bvy", Var(None)), ("bvz", Var(None)), ("bm", Var(None))], Var("b"), Let(("_", Var(None)), Put(Var("e"), Int(0), Prim(Get(Var("e"), Int(0)), Prim(Prim(Double(0.5), Var("bm"), Mul, kind=None), Prim(Prim(Prim(Var("bvx"), Var("bvx"), Mul, kind=None), Prim(Var("bvy"), Var("bvy"), Mul, kind=None), Add, kind=None), Prim(Var("bvz"), Var("bvz"), Mul, kind=None), Add, kind=None), Mul, kind=None), Add, kind=None)), LetRec({tyvars: [], name: ("loop_j", Var(None)), args: [("j", Int)], body: Let(("_", Var(None)), If(LE(Var("j"), Prim(Var("n"), Int(1), Sub, kind=None)), Let(("b2", Var(None)), Get(Var("bodies"), Var("j")), LetTuple([("b2x", Var(None)), ("b2y", Var(None)), ("b2z", Var(None)), ("b2vx", Var(None)), ("b2vy", Var(None)), ("b2vz", Var(None)), ("b2m", Var(None))], Var("b2"), Let(("dx", Var(None)), Prim(Var("bx"), Var("b2x"), Sub, kind=None), Let(("dy", Var(None)), Prim(Var("by"), Var("b2y"), Sub, kind=None), Let(("dz", Var(None)), Prim(Var("bz"), Var("b2z"), Sub, kind=None), Let(("dist2", Var(None)), Prim(Prim(Prim(Var("dx"), Var("dx"), Mul, kind=None), Prim(Var("dy"), Var("dy"), Mul, kind=None), Add, kind=None), Prim(Var("dz"), Var("dz"), Mul, kind=None), Add, kind=None), Let(("_", Var(None)), Put(Var("e"), Int(0), Prim(Get(Var("e"), Int(0)), Prim(Prim(Var("bm"), Var("b2m"), Mul, kind=None), App(Var("sqrt"), targs=None, [Var("dist2")]), Div, kind=None), Sub, kind=None)), Let(("_", Var(None)), App(Var("loop_j"), targs=None, [Prim(Var("j"), Int(1), Add, kind=None)]), Unit)))))))), Unit), Unit)}, Let(("_", Var(None)), App(Var("loop_j"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Unit)))))), Unit), Unit)}, Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Int(0)]), Get(Var("e"), Int(0))))
// [Typer] resolve: Let(("_", Var(None)), If(LE(Var("i"), Prim(Var("n"), Int(1), Sub, kind=None)), Let(("b", Var(None)), Get(Var("bodies"), Var("i")), LetTuple([("bx", Var(None)), ("by", Var(None)), ("bz", Var(None)), ("bvx", Var(None)), ("bvy", Var(None)), ("bvz", Var(None)), ("bm", Var(None))], Var("b"), Let(("_", Var(None)), Put(Var("e"), Int(0), Prim(Get(Var("e"), Int(0)), Prim(Prim(Double(0.5), Var("bm"), Mul, kind=None), Prim(Prim(Prim(Var("bvx"), Var("bvx"), Mul, kind=None), Prim(Var("bvy"), Var("bvy"), Mul, kind=None), Add, kind=None), Prim(Var("bvz"), Var("bvz"), Mul, kind=None), Add, kind=None), Mul, kind=None), Add, kind=None)), LetRec({tyvars: [], name: ("loop_j", Var(None)), args: [("j", Int)], body: Let(("_", Var(None)), If(LE(Var("j"), Prim(Var("n"), Int(1), Sub, kind=None)), Let(("b2", Var(None)), Get(Var("bodies"), Var("j")), LetTuple([("b2x", Var(None)), ("b2y", Var(None)), ("b2z", Var(None)), ("b2vx", Var(None)), ("b2vy", Var(None)), ("b2vz", Var(None)), ("b2m", Var(None))], Var("b2"), Let(("dx", Var(None)), Prim(Var("bx"), Var("b2x"), Sub, kind=None), Let(("dy", Var(None)), Prim(Var("by"), Var("b2y"), Sub, kind=None), Let(("dz", Var(None)), Prim(Var("bz"), Var("b2z"), Sub, kind=None), Let(("dist2", Var(None)), Prim(Prim(Prim(Var("dx"), Var("dx"), Mul, kind=None), Prim(Var("dy"), Var("dy"), Mul, kind=None), Add, kind=None), Prim(Var("dz"), Var("dz"), Mul, kind=None), Add, kind=None), Let(("_", Var(None)), Put(Var("e"), Int(0), Prim(Get(Var("e"), Int(0)), Prim(Prim(Var("bm"), Var("b2m"), Mul, kind=None), App(Var("sqrt"), targs=None, [Var("dist2")]), Div, kind=None), Sub, kind=None)), Let(("_", Var(None)), App(Var("loop_j"), targs=None, [Prim(Var("j"), Int(1), Add, kind=None)]), Unit)))))))), Unit), Unit)}, Let(("_", Var(None)), App(Var("loop_j"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Unit)))))), Unit), Unit)
// [Typer] resolve: If(LE(Var("i"), Prim(Var("n"), Int(1), Sub, kind=None)), Let(("b", Var(None)), Get(Var("bodies"), Var("i")), LetTuple([("bx", Var(None)), ("by", Var(None)), ("bz", Var(None)), ("bvx", Var(None)), ("bvy", Var(None)), ("bvz", Var(None)), ("bm", Var(None))], Var("b"), Let(("_", Var(None)), Put(Var("e"), Int(0), Prim(Get(Var("e"), Int(0)), Prim(Prim(Double(0.5), Var("bm"), Mul, kind=None), Prim(Prim(Prim(Var("bvx"), Var("bvx"), Mul, kind=None), Prim(Var("bvy"), Var("bvy"), Mul, kind=None), Add, kind=None), Prim(Var("bvz"), Var("bvz"), Mul, kind=None), Add, kind=None), Mul, kind=None), Add, kind=None)), LetRec({tyvars: [], name: ("loop_j", Var(None)), args: [("j", Int)], body: Let(("_", Var(None)), If(LE(Var("j"), Prim(Var("n"), Int(1), Sub, kind=None)), Let(("b2", Var(None)), Get(Var("bodies"), Var("j")), LetTuple([("b2x", Var(None)), ("b2y", Var(None)), ("b2z", Var(None)), ("b2vx", Var(None)), ("b2vy", Var(None)), ("b2vz", Var(None)), ("b2m", Var(None))], Var("b2"), Let(("dx", Var(None)), Prim(Var("bx"), Var("b2x"), Sub, kind=None), Let(("dy", Var(None)), Prim(Var("by"), Var("b2y"), Sub, kind=None), Let(("dz", Var(None)), Prim(Var("bz"), Var("b2z"), Sub, kind=None), Let(("dist2", Var(None)), Prim(Prim(Prim(Var("dx"), Var("dx"), Mul, kind=None), Prim(Var("dy"), Var("dy"), Mul, kind=None), Add, kind=None), Prim(Var("dz"), Var("dz"), Mul, kind=None), Add, kind=None), Let(("_", Var(None)), Put(Var("e"), Int(0), Prim(Get(Var("e"), Int(0)), Prim(Prim(Var("bm"), Var("b2m"), Mul, kind=None), App(Var("sqrt"), targs=None, [Var("dist2")]), Div, kind=None), Sub, kind=None)), Let(("_", Var(None)), App(Var("loop_j"), targs=None, [Prim(Var("j"), Int(1), Add, kind=None)]), Unit)))))))), Unit), Unit)}, Let(("_", Var(None)), App(Var("loop_j"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Unit)))))), Unit)
// [Typer] resolve: LE(Var("i"), Prim(Var("n"), Int(1), Sub, kind=None))
// [Typer] resolve: Var("i")
// [Typer] resolve: Prim(Var("n"), Int(1), Sub, kind=None)
// [Typer] resolve: Var("n")
// [Typer] resolve: Int(1)
// [Typer] resolve: Let(("b", Var(None)), Get(Var("bodies"), Var("i")), LetTuple([("bx", Var(None)), ("by", Var(None)), ("bz", Var(None)), ("bvx", Var(None)), ("bvy", Var(None)), ("bvz", Var(None)), ("bm", Var(None))], Var("b"), Let(("_", Var(None)), Put(Var("e"), Int(0), Prim(Get(Var("e"), Int(0)), Prim(Prim(Double(0.5), Var("bm"), Mul, kind=None), Prim(Prim(Prim(Var("bvx"), Var("bvx"), Mul, kind=None), Prim(Var("bvy"), Var("bvy"), Mul, kind=None), Add, kind=None), Prim(Var("bvz"), Var("bvz"), Mul, kind=None), Add, kind=None), Mul, kind=None), Add, kind=None)), LetRec({tyvars: [], name: ("loop_j", Var(None)), args: [("j", Int)], body: Let(("_", Var(None)), If(LE(Var("j"), Prim(Var("n"), Int(1), Sub, kind=None)), Let(("b2", Var(None)), Get(Var("bodies"), Var("j")), LetTuple([("b2x", Var(None)), ("b2y", Var(None)), ("b2z", Var(None)), ("b2vx", Var(None)), ("b2vy", Var(None)), ("b2vz", Var(None)), ("b2m", Var(None))], Var("b2"), Let(("dx", Var(None)), Prim(Var("bx"), Var("b2x"), Sub, kind=None), Let(("dy", Var(None)), Prim(Var("by"), Var("b2y"), Sub, kind=None), Let(("dz", Var(None)), Prim(Var("bz"), Var("b2z"), Sub, kind=None), Let(("dist2", Var(None)), Prim(Prim(Prim(Var("dx"), Var("dx"), Mul, kind=None), Prim(Var("dy"), Var("dy"), Mul, kind=None), Add, kind=None), Prim(Var("dz"), Var("dz"), Mul, kind=None), Add, kind=None), Let(("_", Var(None)), Put(Var("e"), Int(0), Prim(Get(Var("e"), Int(0)), Prim(Prim(Var("bm"), Var("b2m"), Mul, kind=None), App(Var("sqrt"), targs=None, [Var("dist2")]), Div, kind=None), Sub, kind=None)), Let(("_", Var(None)), App(Var("loop_j"), targs=None, [Prim(Var("j"), Int(1), Add, kind=None)]), Unit)))))))), Unit), Unit)}, Let(("_", Var(None)), App(Var("loop_j"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Unit))))))
// [Typer] resolve: Get(Var("bodies"), Var("i"))
// [Typer] resolve: Var("bodies")
// [Typer] resolve: Var("i")
// [Typer] resolve: LetTuple([("bx", Var(None)), ("by", Var(None)), ("bz", Var(None)), ("bvx", Var(None)), ("bvy", Var(None)), ("bvz", Var(None)), ("bm", Var(None))], Var("b"), Let(("_", Var(None)), Put(Var("e"), Int(0), Prim(Get(Var("e"), Int(0)), Prim(Prim(Double(0.5), Var("bm"), Mul, kind=None), Prim(Prim(Prim(Var("bvx"), Var("bvx"), Mul, kind=None), Prim(Var("bvy"), Var("bvy"), Mul, kind=None), Add, kind=None), Prim(Var("bvz"), Var("bvz"), Mul, kind=None), Add, kind=None), Mul, kind=None), Add, kind=None)), LetRec({tyvars: [], name: ("loop_j", Var(None)), args: [("j", Int)], body: Let(("_", Var(None)), If(LE(Var("j"), Prim(Var("n"), Int(1), Sub, kind=None)), Let(("b2", Var(None)), Get(Var("bodies"), Var("j")), LetTuple([("b2x", Var(None)), ("b2y", Var(None)), ("b2z", Var(None)), ("b2vx", Var(None)), ("b2vy", Var(None)), ("b2vz", Var(None)), ("b2m", Var(None))], Var("b2"), Let(("dx", Var(None)), Prim(Var("bx"), Var("b2x"), Sub, kind=None), Let(("dy", Var(None)), Prim(Var("by"), Var("b2y"), Sub, kind=None), Let(("dz", Var(None)), Prim(Var("bz"), Var("b2z"), Sub, kind=None), Let(("dist2", Var(None)), Prim(Prim(Prim(Var("dx"), Var("dx"), Mul, kind=None), Prim(Var("dy"), Var("dy"), Mul, kind=None), Add, kind=None), Prim(Var("dz"), Var("dz"), Mul, kind=None), Add, kind=None), Let(("_", Var(None)), Put(Var("e"), Int(0), Prim(Get(Var("e"), Int(0)), Prim(Prim(Var("bm"), Var("b2m"), Mul, kind=None), App(Var("sqrt"), targs=None, [Var("dist2")]), Div, kind=None), Sub, kind=None)), Let(("_", Var(None)), App(Var("loop_j"), targs=None, [Prim(Var("j"), Int(1), Add, kind=None)]), Unit)))))))), Unit), Unit)}, Let(("_", Var(None)), App(Var("loop_j"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Unit)))))
// [Typer] resolve: Var("b")
// [Typer] resolve: Let(("_", Var(None)), Put(Var("e"), Int(0), Prim(Get(Var("e"), Int(0)), Prim(Prim(Double(0.5), Var("bm"), Mul, kind=None), Prim(Prim(Prim(Var("bvx"), Var("bvx"), Mul, kind=None), Prim(Var("bvy"), Var("bvy"), Mul, kind=None), Add, kind=None), Prim(Var("bvz"), Var("bvz"), Mul, kind=None), Add, kind=None), Mul, kind=None), Add, kind=None)), LetRec({tyvars: [], name: ("loop_j", Var(None)), args: [("j", Int)], body: Let(("_", Var(None)), If(LE(Var("j"), Prim(Var("n"), Int(1), Sub, kind=None)), Let(("b2", Var(None)), Get(Var("bodies"), Var("j")), LetTuple([("b2x", Var(None)), ("b2y", Var(None)), ("b2z", Var(None)), ("b2vx", Var(None)), ("b2vy", Var(None)), ("b2vz", Var(None)), ("b2m", Var(None))], Var("b2"), Let(("dx", Var(None)), Prim(Var("bx"), Var("b2x"), Sub, kind=None), Let(("dy", Var(None)), Prim(Var("by"), Var("b2y"), Sub, kind=None), Let(("dz", Var(None)), Prim(Var("bz"), Var("b2z"), Sub, kind=None), Let(("dist2", Var(None)), Prim(Prim(Prim(Var("dx"), Var("dx"), Mul, kind=None), Prim(Var("dy"), Var("dy"), Mul, kind=None), Add, kind=None), Prim(Var("dz"), Var("dz"), Mul, kind=None), Add, kind=None), Let(("_", Var(None)), Put(Var("e"), Int(0), Prim(Get(Var("e"), Int(0)), Prim(Prim(Var("bm"), Var("b2m"), Mul, kind=None), App(Var("sqrt"), targs=None, [Var("dist2")]), Div, kind=None), Sub, kind=None)), Let(("_", Var(None)), App(Var("loop_j"), targs=None, [Prim(Var("j"), Int(1), Add, kind=None)]), Unit)))))))), Unit), Unit)}, Let(("_", Var(None)), App(Var("loop_j"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Unit))))
// [Typer] resolve: Put(Var("e"), Int(0), Prim(Get(Var("e"), Int(0)), Prim(Prim(Double(0.5), Var("bm"), Mul, kind=None), Prim(Prim(Prim(Var("bvx"), Var("bvx"), Mul, kind=None), Prim(Var("bvy"), Var("bvy"), Mul, kind=None), Add, kind=None), Prim(Var("bvz"), Var("bvz"), Mul, kind=None), Add, kind=None), Mul, kind=None), Add, kind=None))
// [Typer] resolve: Var("e")
// [Typer] resolve: Int(0)
// [Typer] resolve: Prim(Get(Var("e"), Int(0)), Prim(Prim(Double(0.5), Var("bm"), Mul, kind=None), Prim(Prim(Prim(Var("bvx"), Var("bvx"), Mul, kind=None), Prim(Var("bvy"), Var("bvy"), Mul, kind=None), Add, kind=None), Prim(Var("bvz"), Var("bvz"), Mul, kind=None), Add, kind=None), Mul, kind=None), Add, kind=None)
// [Typer] resolve: Get(Var("e"), Int(0))
// [Typer] resolve: Var("e")
// [Typer] resolve: Int(0)
// [Typer] resolve: Prim(Prim(Double(0.5), Var("bm"), Mul, kind=None), Prim(Prim(Prim(Var("bvx"), Var("bvx"), Mul, kind=None), Prim(Var("bvy"), Var("bvy"), Mul, kind=None), Add, kind=None), Prim(Var("bvz"), Var("bvz"), Mul, kind=None), Add, kind=None), Mul, kind=None)
// [Typer] resolve: Prim(Double(0.5), Var("bm"), Mul, kind=None)
// [Typer] resolve: Double(0.5)
// [Typer] resolve: Var("bm")
// [Typer] resolve: Prim(Prim(Prim(Var("bvx"), Var("bvx"), Mul, kind=None), Prim(Var("bvy"), Var("bvy"), Mul, kind=None), Add, kind=None), Prim(Var("bvz"), Var("bvz"), Mul, kind=None), Add, kind=None)
// [Typer] resolve: Prim(Prim(Var("bvx"), Var("bvx"), Mul, kind=None), Prim(Var("bvy"), Var("bvy"), Mul, kind=None), Add, kind=None)
// [Typer] resolve: Prim(Var("bvx"), Var("bvx"), Mul, kind=None)
// [Typer] resolve: Var("bvx")
// [Typer] resolve: Var("bvx")
// [Typer] resolve: Prim(Var("bvy"), Var("bvy"), Mul, kind=None)
// [Typer] resolve: Var("bvy")
// [Typer] resolve: Var("bvy")
// [Typer] resolve: Prim(Var("bvz"), Var("bvz"), Mul, kind=None)
// [Typer] resolve: Var("bvz")
// [Typer] resolve: Var("bvz")
// [Typer] resolve: LetRec({tyvars: [], name: ("loop_j", Var(None)), args: [("j", Int)], body: Let(("_", Var(None)), If(LE(Var("j"), Prim(Var("n"), Int(1), Sub, kind=None)), Let(("b2", Var(None)), Get(Var("bodies"), Var("j")), LetTuple([("b2x", Var(None)), ("b2y", Var(None)), ("b2z", Var(None)), ("b2vx", Var(None)), ("b2vy", Var(None)), ("b2vz", Var(None)), ("b2m", Var(None))], Var("b2"), Let(("dx", Var(None)), Prim(Var("bx"), Var("b2x"), Sub, kind=None), Let(("dy", Var(None)), Prim(Var("by"), Var("b2y"), Sub, kind=None), Let(("dz", Var(None)), Prim(Var("bz"), Var("b2z"), Sub, kind=None), Let(("dist2", Var(None)), Prim(Prim(Prim(Var("dx"), Var("dx"), Mul, kind=None), Prim(Var("dy"), Var("dy"), Mul, kind=None), Add, kind=None), Prim(Var("dz"), Var("dz"), Mul, kind=None), Add, kind=None), Let(("_", Var(None)), Put(Var("e"), Int(0), Prim(Get(Var("e"), Int(0)), Prim(Prim(Var("bm"), Var("b2m"), Mul, kind=None), App(Var("sqrt"), targs=None, [Var("dist2")]), Div, kind=None), Sub, kind=None)), Let(("_", Var(None)), App(Var("loop_j"), targs=None, [Prim(Var("j"), Int(1), Add, kind=None)]), Unit)))))))), Unit), Unit)}, Let(("_", Var(None)), App(Var("loop_j"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Unit)))
// [Typer] resolve: Let(("_", Var(None)), If(LE(Var("j"), Prim(Var("n"), Int(1), Sub, kind=None)), Let(("b2", Var(None)), Get(Var("bodies"), Var("j")), LetTuple([("b2x", Var(None)), ("b2y", Var(None)), ("b2z", Var(None)), ("b2vx", Var(None)), ("b2vy", Var(None)), ("b2vz", Var(None)), ("b2m", Var(None))], Var("b2"), Let(("dx", Var(None)), Prim(Var("bx"), Var("b2x"), Sub, kind=None), Let(("dy", Var(None)), Prim(Var("by"), Var("b2y"), Sub, kind=None), Let(("dz", Var(None)), Prim(Var("bz"), Var("b2z"), Sub, kind=None), Let(("dist2", Var(None)), Prim(Prim(Prim(Var("dx"), Var("dx"), Mul, kind=None), Prim(Var("dy"), Var("dy"), Mul, kind=None), Add, kind=None), Prim(Var("dz"), Var("dz"), Mul, kind=None), Add, kind=None), Let(("_", Var(None)), Put(Var("e"), Int(0), Prim(Get(Var("e"), Int(0)), Prim(Prim(Var("bm"), Var("b2m"), Mul, kind=None), App(Var("sqrt"), targs=None, [Var("dist2")]), Div, kind=None), Sub, kind=None)), Let(("_", Var(None)), App(Var("loop_j"), targs=None, [Prim(Var("j"), Int(1), Add, kind=None)]), Unit)))))))), Unit), Unit)
// [Typer] resolve: If(LE(Var("j"), Prim(Var("n"), Int(1), Sub, kind=None)), Let(("b2", Var(None)), Get(Var("bodies"), Var("j")), LetTuple([("b2x", Var(None)), ("b2y", Var(None)), ("b2z", Var(None)), ("b2vx", Var(None)), ("b2vy", Var(None)), ("b2vz", Var(None)), ("b2m", Var(None))], Var("b2"), Let(("dx", Var(None)), Prim(Var("bx"), Var("b2x"), Sub, kind=None), Let(("dy", Var(None)), Prim(Var("by"), Var("b2y"), Sub, kind=None), Let(("dz", Var(None)), Prim(Var("bz"), Var("b2z"), Sub, kind=None), Let(("dist2", Var(None)), Prim(Prim(Prim(Var("dx"), Var("dx"), Mul, kind=None), Prim(Var("dy"), Var("dy"), Mul, kind=None), Add, kind=None), Prim(Var("dz"), Var("dz"), Mul, kind=None), Add, kind=None), Let(("_", Var(None)), Put(Var("e"), Int(0), Prim(Get(Var("e"), Int(0)), Prim(Prim(Var("bm"), Var("b2m"), Mul, kind=None), App(Var("sqrt"), targs=None, [Var("dist2")]), Div, kind=None), Sub, kind=None)), Let(("_", Var(None)), App(Var("loop_j"), targs=None, [Prim(Var("j"), Int(1), Add, kind=None)]), Unit)))))))), Unit)
// [Typer] resolve: LE(Var("j"), Prim(Var("n"), Int(1), Sub, kind=None))
// [Typer] resolve: Var("j")
// [Typer] resolve: Prim(Var("n"), Int(1), Sub, kind=None)
// [Typer] resolve: Var("n")
// [Typer] resolve: Int(1)
// [Typer] resolve: Let(("b2", Var(None)), Get(Var("bodies"), Var("j")), LetTuple([("b2x", Var(None)), ("b2y", Var(None)), ("b2z", Var(None)), ("b2vx", Var(None)), ("b2vy", Var(None)), ("b2vz", Var(None)), ("b2m", Var(None))], Var("b2"), Let(("dx", Var(None)), Prim(Var("bx"), Var("b2x"), Sub, kind=None), Let(("dy", Var(None)), Prim(Var("by"), Var("b2y"), Sub, kind=None), Let(("dz", Var(None)), Prim(Var("bz"), Var("b2z"), Sub, kind=None), Let(("dist2", Var(None)), Prim(Prim(Prim(Var("dx"), Var("dx"), Mul, kind=None), Prim(Var("dy"), Var("dy"), Mul, kind=None), Add, kind=None), Prim(Var("dz"), Var("dz"), Mul, kind=None), Add, kind=None), Let(("_", Var(None)), Put(Var("e"), Int(0), Prim(Get(Var("e"), Int(0)), Prim(Prim(Var("bm"), Var("b2m"), Mul, kind=None), App(Var("sqrt"), targs=None, [Var("dist2")]), Div, kind=None), Sub, kind=None)), Let(("_", Var(None)), App(Var("loop_j"), targs=None, [Prim(Var("j"), Int(1), Add, kind=None)]), Unit))))))))
// [Typer] resolve: Get(Var("bodies"), Var("j"))
// [Typer] resolve: Var("bodies")
// [Typer] resolve: Var("j")
// [Typer] resolve: LetTuple([("b2x", Var(None)), ("b2y", Var(None)), ("b2z", Var(None)), ("b2vx", Var(None)), ("b2vy", Var(None)), ("b2vz", Var(None)), ("b2m", Var(None))], Var("b2"), Let(("dx", Var(None)), Prim(Var("bx"), Var("b2x"), Sub, kind=None), Let(("dy", Var(None)), Prim(Var("by"), Var("b2y"), Sub, kind=None), Let(("dz", Var(None)), Prim(Var("bz"), Var("b2z"), Sub, kind=None), Let(("dist2", Var(None)), Prim(Prim(Prim(Var("dx"), Var("dx"), Mul, kind=None), Prim(Var("dy"), Var("dy"), Mul, kind=None), Add, kind=None), Prim(Var("dz"), Var("dz"), Mul, kind=None), Add, kind=None), Let(("_", Var(None)), Put(Var("e"), Int(0), Prim(Get(Var("e"), Int(0)), Prim(Prim(Var("bm"), Var("b2m"), Mul, kind=None), App(Var("sqrt"), targs=None, [Var("dist2")]), Div, kind=None), Sub, kind=None)), Let(("_", Var(None)), App(Var("loop_j"), targs=None, [Prim(Var("j"), Int(1), Add, kind=None)]), Unit)))))))
// [Typer] resolve: Var("b2")
// [Typer] resolve: Let(("dx", Var(None)), Prim(Var("bx"), Var("b2x"), Sub, kind=None), Let(("dy", Var(None)), Prim(Var("by"), Var("b2y"), Sub, kind=None), Let(("dz", Var(None)), Prim(Var("bz"), Var("b2z"), Sub, kind=None), Let(("dist2", Var(None)), Prim(Prim(Prim(Var("dx"), Var("dx"), Mul, kind=None), Prim(Var("dy"), Var("dy"), Mul, kind=None), Add, kind=None), Prim(Var("dz"), Var("dz"), Mul, kind=None), Add, kind=None), Let(("_", Var(None)), Put(Var("e"), Int(0), Prim(Get(Var("e"), Int(0)), Prim(Prim(Var("bm"), Var("b2m"), Mul, kind=None), App(Var("sqrt"), targs=None, [Var("dist2")]), Div, kind=None), Sub, kind=None)), Let(("_", Var(None)), App(Var("loop_j"), targs=None, [Prim(Var("j"), Int(1), Add, kind=None)]), Unit))))))
// [Typer] resolve: Prim(Var("bx"), Var("b2x"), Sub, kind=None)
// [Typer] resolve: Var("bx")
// [Typer] resolve: Var("b2x")
// [Typer] resolve: Let(("dy", Var(None)), Prim(Var("by"), Var("b2y"), Sub, kind=None), Let(("dz", Var(None)), Prim(Var("bz"), Var("b2z"), Sub, kind=None), Let(("dist2", Var(None)), Prim(Prim(Prim(Var("dx"), Var("dx"), Mul, kind=None), Prim(Var("dy"), Var("dy"), Mul, kind=None), Add, kind=None), Prim(Var("dz"), Var("dz"), Mul, kind=None), Add, kind=None), Let(("_", Var(None)), Put(Var("e"), Int(0), Prim(Get(Var("e"), Int(0)), Prim(Prim(Var("bm"), Var("b2m"), Mul, kind=None), App(Var("sqrt"), targs=None, [Var("dist2")]), Div, kind=None), Sub, kind=None)), Let(("_", Var(None)), App(Var("loop_j"), targs=None, [Prim(Var("j"), Int(1), Add, kind=None)]), Unit)))))
// [Typer] resolve: Prim(Var("by"), Var("b2y"), Sub, kind=None)
// [Typer] resolve: Var("by")
// [Typer] resolve: Var("b2y")
// [Typer] resolve: Let(("dz", Var(None)), Prim(Var("bz"), Var("b2z"), Sub, kind=None), Let(("dist2", Var(None)), Prim(Prim(Prim(Var("dx"), Var("dx"), Mul, kind=None), Prim(Var("dy"), Var("dy"), Mul, kind=None), Add, kind=None), Prim(Var("dz"), Var("dz"), Mul, kind=None), Add, kind=None), Let(("_", Var(None)), Put(Var("e"), Int(0), Prim(Get(Var("e"), Int(0)), Prim(Prim(Var("bm"), Var("b2m"), Mul, kind=None), App(Var("sqrt"), targs=None, [Var("dist2")]), Div, kind=None), Sub, kind=None)), Let(("_", Var(None)), App(Var("loop_j"), targs=None, [Prim(Var("j"), Int(1), Add, kind=None)]), Unit))))
// [Typer] resolve: Prim(Var("bz"), Var("b2z"), Sub, kind=None)
// [Typer] resolve: Var("bz")
// [Typer] resolve: Var("b2z")
// [Typer] resolve: Let(("dist2", Var(None)), Prim(Prim(Prim(Var("dx"), Var("dx"), Mul, kind=None), Prim(Var("dy"), Var("dy"), Mul, kind=None), Add, kind=None), Prim(Var("dz"), Var("dz"), Mul, kind=None), Add, kind=None), Let(("_", Var(None)), Put(Var("e"), Int(0), Prim(Get(Var("e"), Int(0)), Prim(Prim(Var("bm"), Var("b2m"), Mul, kind=None), App(Var("sqrt"), targs=None, [Var("dist2")]), Div, kind=None), Sub, kind=None)), Let(("_", Var(None)), App(Var("loop_j"), targs=None, [Prim(Var("j"), Int(1), Add, kind=None)]), Unit)))
// [Typer] resolve: Prim(Prim(Prim(Var("dx"), Var("dx"), Mul, kind=None), Prim(Var("dy"), Var("dy"), Mul, kind=None), Add, kind=None), Prim(Var("dz"), Var("dz"), Mul, kind=None), Add, kind=None)
// [Typer] resolve: Prim(Prim(Var("dx"), Var("dx"), Mul, kind=None), Prim(Var("dy"), Var("dy"), Mul, kind=None), Add, kind=None)
// [Typer] resolve: Prim(Var("dx"), Var("dx"), Mul, kind=None)
// [Typer] resolve: Var("dx")
// [Typer] resolve: Var("dx")
// [Typer] resolve: Prim(Var("dy"), Var("dy"), Mul, kind=None)
// [Typer] resolve: Var("dy")
// [Typer] resolve: Var("dy")
// [Typer] resolve: Prim(Var("dz"), Var("dz"), Mul, kind=None)
// [Typer] resolve: Var("dz")
// [Typer] resolve: Var("dz")
// [Typer] resolve: Let(("_", Var(None)), Put(Var("e"), Int(0), Prim(Get(Var("e"), Int(0)), Prim(Prim(Var("bm"), Var("b2m"), Mul, kind=None), App(Var("sqrt"), targs=None, [Var("dist2")]), Div, kind=None), Sub, kind=None)), Let(("_", Var(None)), App(Var("loop_j"), targs=None, [Prim(Var("j"), Int(1), Add, kind=None)]), Unit))
// [Typer] resolve: Put(Var("e"), Int(0), Prim(Get(Var("e"), Int(0)), Prim(Prim(Var("bm"), Var("b2m"), Mul, kind=None), App(Var("sqrt"), targs=None, [Var("dist2")]), Div, kind=None), Sub, kind=None))
// [Typer] resolve: Var("e")
// [Typer] resolve: Int(0)
// [Typer] resolve: Prim(Get(Var("e"), Int(0)), Prim(Prim(Var("bm"), Var("b2m"), Mul, kind=None), App(Var("sqrt"), targs=None, [Var("dist2")]), Div, kind=None), Sub, kind=None)
// [Typer] resolve: Get(Var("e"), Int(0))
// [Typer] resolve: Var("e")
// [Typer] resolve: Int(0)
// [Typer] resolve: Prim(Prim(Var("bm"), Var("b2m"), Mul, kind=None), App(Var("sqrt"), targs=None, [Var("dist2")]), Div, kind=None)
// [Typer] resolve: Prim(Var("bm"), Var("b2m"), Mul, kind=None)
// [Typer] resolve: Var("bm")
// [Typer] resolve: Var("b2m")
// [Typer] resolve: App(Var("sqrt"), targs=None, [Var("dist2")])
// [Typer] resolve: Var("dist2")
// [Typer] resolve: Var("sqrt")
// [Typer] resolve: Let(("_", Var(None)), App(Var("loop_j"), targs=None, [Prim(Var("j"), Int(1), Add, kind=None)]), Unit)
// [Typer] resolve: App(Var("loop_j"), targs=None, [Prim(Var("j"), Int(1), Add, kind=None)])
// [Typer] resolve: Prim(Var("j"), Int(1), Add, kind=None)
// [Typer] resolve: Var("j")
// [Typer] resolve: Int(1)
// [Typer] resolve: Var("loop_j")
// [Typer] resolve: Unit
// [Typer] resolve: Unit
// [Typer] resolve: Unit
// [Typer] resolve: Let(("_", Var(None)), App(Var("loop_j"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Unit))
// [Typer] resolve: App(Var("loop_j"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)])
// [Typer] resolve: Prim(Var("i"), Int(1), Add, kind=None)
// [Typer] resolve: Var("i")
// [Typer] resolve: Int(1)
// [Typer] resolve: Var("loop_j")
// [Typer] resolve: Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Unit)
// [Typer] resolve: App(Var("loop_i"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)])
// [Typer] resolve: Prim(Var("i"), Int(1), Add, kind=None)
// [Typer] resolve: Var("i")
// [Typer] resolve: Int(1)
// [Typer] resolve: Var("loop_i")
// [Typer] resolve: Unit
// [Typer] resolve: Unit
// [Typer] resolve: Unit
// [Typer] resolve: Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Int(0)]), Get(Var("e"), Int(0)))
// [Typer] resolve: App(Var("loop_i"), targs=None, [Int(0)])
// [Typer] resolve: Int(0)
// [Typer] resolve: Var("loop_i")
// [Typer] resolve: Get(Var("e"), Int(0))
// [Typer] resolve: Var("e")
// [Typer] resolve: Int(0)
// [Typer] resolve: LetRec({tyvars: [], name: ("offset_momentum", Unit), args: [("bodies", Array[(Double, Double, Double, Double, Double, Double, Double)])], body: Let(("n", Var(None)), Int(5), Let(("px", Var(None)), Array(Int(1), Double(0)), Let(("py", Var(None)), Array(Int(1), Double(0)), Let(("pz", Var(None)), Array(Int(1), Double(0)), LetRec({tyvars: [], name: ("loop_i", Var(None)), args: [("i", Int)], body: Let(("_", Var(None)), If(LE(Var("i"), Prim(Var("n"), Int(1), Sub, kind=None)), Let(("b", Var(None)), Get(Var("bodies"), Var("i")), LetTuple([("bx", Var(None)), ("by", Var(None)), ("bz", Var(None)), ("bvx", Var(None)), ("bvy", Var(None)), ("bvz", Var(None)), ("bm", Var(None))], Var("b"), Let(("_", Var(None)), Put(Var("px"), Int(0), Prim(Get(Var("px"), Int(0)), Prim(Var("bvx"), Var("bm"), Mul, kind=None), Add, kind=None)), Let(("_", Var(None)), Put(Var("py"), Int(0), Prim(Get(Var("py"), Int(0)), Prim(Var("bvy"), Var("bm"), Mul, kind=None), Add, kind=None)), Let(("_", Var(None)), Put(Var("pz"), Int(0), Prim(Get(Var("pz"), Int(0)), Prim(Var("bvz"), Var("bm"), Mul, kind=None), Add, kind=None)), Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Unit)))))), Unit), Unit)}, Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Int(0)]), Let(("b", Var(None)), Get(Var("bodies"), Int(0)), LetTuple([("bx", Var(None)), ("by", Var(None)), ("bz", Var(None)), ("bvx", Var(None)), ("bvy", Var(None)), ("bvz", Var(None)), ("bm", Var(None))], Var("b"), Let(("new_b", Var(None)), Tuple([Var("bx"), Var("by"), Var("bz"), Neg(Prim(Get(Var("px"), Int(0)), Var("solar_mass"), Div, kind=None), kind=None), Neg(Prim(Get(Var("py"), Int(0)), Var("solar_mass"), Div, kind=None), kind=None), Neg(Prim(Get(Var("pz"), Int(0)), Var("solar_mass"), Div, kind=None), kind=None), Var("bm")]), Let(("_", Var(None)), Put(Var("bodies"), Int(0), Var("new_b")), Unit))))))))))}, LetRec({tyvars: [], name: ("main", Var(None)), args: [], body: Let(("jupiter", Var(None)), Tuple([Double(4.841431442464721), Neg(Double(1.1603200440274284), kind=None), Neg(Double(0.10362204447112311), kind=None), Prim(Double(0.001660076642744037), Var("days_per_year"), Mul, kind=None), Prim(Double(0.007699011184197404), Var("days_per_year"), Mul, kind=None), Neg(Prim(Double(0.0000690460016972063), Var("days_per_year"), Mul, kind=None), kind=None), Prim(Double(0.0009547919384243266), Var("solar_mass"), Mul, kind=None)]), Let(("saturn", Var(None)), Tuple([Double(8.34336671824458), Double(4.124798564124305), Neg(Double(0.4035234171143214), kind=None), Neg(Prim(Double(0.002767425107268624), Var("days_per_year"), Mul, kind=None), kind=None), Prim(Double(0.004998528012349172), Var("days_per_year"), Mul, kind=None), Prim(Double(0.000023029345528229068), Var("days_per_year"), Mul, kind=None), Prim(Double(0.0002858859806661308), Var("solar_mass"), Mul, kind=None)]), Let(("uranus", Var(None)), Tuple([Double(12.894369562139131), Neg(Double(15.111151401698631), kind=None), Neg(Double(0.22330757889265587), kind=None), Prim(Double(0.002964601375647616), Var("days_per_year"), Mul, kind=None), Prim(Double(0.0023784717395948095), Var("days_per_year"), Mul, kind=None), Neg(Prim(Double(0.000029658956854023756), Var("days_per_year"), Mul, kind=None), kind=None), Prim(Double(0.00004366244043351563), Var("solar_mass"), Mul, kind=None)]), Let(("neptune", Var(None)), Tuple([Double(15.379697114850917), Neg(Double(25.919314609987964), kind=None), Double(0.17925877295037118), Prim(Double(0.0026806777249038932), Var("days_per_year"), Mul, kind=None), Prim(Double(0.001628241700382423), Var("days_per_year"), Mul, kind=None), Neg(Prim(Double(0.00009515922545197159), Var("days_per_year"), Mul, kind=None), kind=None), Prim(Double(0.00005151389020466116), Var("solar_mass"), Mul, kind=None)]), Let(("sun", Var(None)), Tuple([Double(0), Double(0), Double(0), Double(0), Double(0), Double(0), Var("solar_mass")]), Let(("bodies", Var(None)), Array(Int(5), Tuple([Double(0), Double(0), Double(0), Double(0), Double(0), Double(0), Double(0)])), Let(("_", Var(None)), Put(Var("bodies"), Int(0), Var("sun")), Let(("_", Var(None)), Put(Var("bodies"), Int(1), Var("jupiter")), Let(("_", Var(None)), Put(Var("bodies"), Int(2), Var("saturn")), Let(("_", Var(None)), Put(Var("bodies"), Int(3), Var("uranus")), Let(("_", Var(None)), Put(Var("bodies"), Int(4), Var("neptune")), Let(("_", Var(None)), App(Var("offset_momentum"), targs=None, [Var("bodies")]), Let(("_", Var(None)), App(Var("print_int"), targs=None, [App(Var("int_of_float"), targs=None, [Prim(App(Var("energy"), targs=None, [Var("bodies")]), Double(1000000000), Mul, kind=None)])]), Let(("iters", Var(None)), Int(500000), LetRec({tyvars: [], name: ("loop_i", Var(None)), args: [("i", Int)], body: Let(("_", Var(None)), If(LE(Var("i"), Var("iters")), Let(("_", Var(None)), App(Var("advance"), targs=None, [Var("bodies"), Double(0.01)]), Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Unit)), Unit), Unit)}, Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Int(1)]), Let(("_", Var(None)), App(Var("print_char"), targs=None, [Int(10)]), Let(("_", Var(None)), App(Var("print_int"), targs=None, [App(Var("int_of_float"), targs=None, [Prim(App(Var("energy"), targs=None, [Var("bodies")]), Double(1000000000), Mul, kind=None)])]), Unit))))))))))))))))))}, Unit))
// [Typer] resolve: Let(("n", Var(None)), Int(5), Let(("px", Var(None)), Array(Int(1), Double(0)), Let(("py", Var(None)), Array(Int(1), Double(0)), Let(("pz", Var(None)), Array(Int(1), Double(0)), LetRec({tyvars: [], name: ("loop_i", Var(None)), args: [("i", Int)], body: Let(("_", Var(None)), If(LE(Var("i"), Prim(Var("n"), Int(1), Sub, kind=None)), Let(("b", Var(None)), Get(Var("bodies"), Var("i")), LetTuple([("bx", Var(None)), ("by", Var(None)), ("bz", Var(None)), ("bvx", Var(None)), ("bvy", Var(None)), ("bvz", Var(None)), ("bm", Var(None))], Var("b"), Let(("_", Var(None)), Put(Var("px"), Int(0), Prim(Get(Var("px"), Int(0)), Prim(Var("bvx"), Var("bm"), Mul, kind=None), Add, kind=None)), Let(("_", Var(None)), Put(Var("py"), Int(0), Prim(Get(Var("py"), Int(0)), Prim(Var("bvy"), Var("bm"), Mul, kind=None), Add, kind=None)), Let(("_", Var(None)), Put(Var("pz"), Int(0), Prim(Get(Var("pz"), Int(0)), Prim(Var("bvz"), Var("bm"), Mul, kind=None), Add, kind=None)), Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Unit)))))), Unit), Unit)}, Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Int(0)]), Let(("b", Var(None)), Get(Var("bodies"), Int(0)), LetTuple([("bx", Var(None)), ("by", Var(None)), ("bz", Var(None)), ("bvx", Var(None)), ("bvy", Var(None)), ("bvz", Var(None)), ("bm", Var(None))], Var("b"), Let(("new_b", Var(None)), Tuple([Var("bx"), Var("by"), Var("bz"), Neg(Prim(Get(Var("px"), Int(0)), Var("solar_mass"), Div, kind=None), kind=None), Neg(Prim(Get(Var("py"), Int(0)), Var("solar_mass"), Div, kind=None), kind=None), Neg(Prim(Get(Var("pz"), Int(0)), Var("solar_mass"), Div, kind=None), kind=None), Var("bm")]), Let(("_", Var(None)), Put(Var("bodies"), Int(0), Var("new_b")), Unit))))))))))
// [Typer] resolve: Int(5)
// [Typer] resolve: Let(("px", Var(None)), Array(Int(1), Double(0)), Let(("py", Var(None)), Array(Int(1), Double(0)), Let(("pz", Var(None)), Array(Int(1), Double(0)), LetRec({tyvars: [], name: ("loop_i", Var(None)), args: [("i", Int)], body: Let(("_", Var(None)), If(LE(Var("i"), Prim(Var("n"), Int(1), Sub, kind=None)), Let(("b", Var(None)), Get(Var("bodies"), Var("i")), LetTuple([("bx", Var(None)), ("by", Var(None)), ("bz", Var(None)), ("bvx", Var(None)), ("bvy", Var(None)), ("bvz", Var(None)), ("bm", Var(None))], Var("b"), Let(("_", Var(None)), Put(Var("px"), Int(0), Prim(Get(Var("px"), Int(0)), Prim(Var("bvx"), Var("bm"), Mul, kind=None), Add, kind=None)), Let(("_", Var(None)), Put(Var("py"), Int(0), Prim(Get(Var("py"), Int(0)), Prim(Var("bvy"), Var("bm"), Mul, kind=None), Add, kind=None)), Let(("_", Var(None)), Put(Var("pz"), Int(0), Prim(Get(Var("pz"), Int(0)), Prim(Var("bvz"), Var("bm"), Mul, kind=None), Add, kind=None)), Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Unit)))))), Unit), Unit)}, Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Int(0)]), Let(("b", Var(None)), Get(Var("bodies"), Int(0)), LetTuple([("bx", Var(None)), ("by", Var(None)), ("bz", Var(None)), ("bvx", Var(None)), ("bvy", Var(None)), ("bvz", Var(None)), ("bm", Var(None))], Var("b"), Let(("new_b", Var(None)), Tuple([Var("bx"), Var("by"), Var("bz"), Neg(Prim(Get(Var("px"), Int(0)), Var("solar_mass"), Div, kind=None), kind=None), Neg(Prim(Get(Var("py"), Int(0)), Var("solar_mass"), Div, kind=None), kind=None), Neg(Prim(Get(Var("pz"), Int(0)), Var("solar_mass"), Div, kind=None), kind=None), Var("bm")]), Let(("_", Var(None)), Put(Var("bodies"), Int(0), Var("new_b")), Unit)))))))))
// [Typer] resolve: Array(Int(1), Double(0))
// [Typer] resolve: Int(1)
// [Typer] resolve: Double(0)
// [Typer] resolve: Let(("py", Var(None)), Array(Int(1), Double(0)), Let(("pz", Var(None)), Array(Int(1), Double(0)), LetRec({tyvars: [], name: ("loop_i", Var(None)), args: [("i", Int)], body: Let(("_", Var(None)), If(LE(Var("i"), Prim(Var("n"), Int(1), Sub, kind=None)), Let(("b", Var(None)), Get(Var("bodies"), Var("i")), LetTuple([("bx", Var(None)), ("by", Var(None)), ("bz", Var(None)), ("bvx", Var(None)), ("bvy", Var(None)), ("bvz", Var(None)), ("bm", Var(None))], Var("b"), Let(("_", Var(None)), Put(Var("px"), Int(0), Prim(Get(Var("px"), Int(0)), Prim(Var("bvx"), Var("bm"), Mul, kind=None), Add, kind=None)), Let(("_", Var(None)), Put(Var("py"), Int(0), Prim(Get(Var("py"), Int(0)), Prim(Var("bvy"), Var("bm"), Mul, kind=None), Add, kind=None)), Let(("_", Var(None)), Put(Var("pz"), Int(0), Prim(Get(Var("pz"), Int(0)), Prim(Var("bvz"), Var("bm"), Mul, kind=None), Add, kind=None)), Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Unit)))))), Unit), Unit)}, Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Int(0)]), Let(("b", Var(None)), Get(Var("bodies"), Int(0)), LetTuple([("bx", Var(None)), ("by", Var(None)), ("bz", Var(None)), ("bvx", Var(None)), ("bvy", Var(None)), ("bvz", Var(None)), ("bm", Var(None))], Var("b"), Let(("new_b", Var(None)), Tuple([Var("bx"), Var("by"), Var("bz"), Neg(Prim(Get(Var("px"), Int(0)), Var("solar_mass"), Div, kind=None), kind=None), Neg(Prim(Get(Var("py"), Int(0)), Var("solar_mass"), Div, kind=None), kind=None), Neg(Prim(Get(Var("pz"), Int(0)), Var("solar_mass"), Div, kind=None), kind=None), Var("bm")]), Let(("_", Var(None)), Put(Var("bodies"), Int(0), Var("new_b")), Unit))))))))
// [Typer] resolve: Array(Int(1), Double(0))
// [Typer] resolve: Int(1)
// [Typer] resolve: Double(0)
// [Typer] resolve: Let(("pz", Var(None)), Array(Int(1), Double(0)), LetRec({tyvars: [], name: ("loop_i", Var(None)), args: [("i", Int)], body: Let(("_", Var(None)), If(LE(Var("i"), Prim(Var("n"), Int(1), Sub, kind=None)), Let(("b", Var(None)), Get(Var("bodies"), Var("i")), LetTuple([("bx", Var(None)), ("by", Var(None)), ("bz", Var(None)), ("bvx", Var(None)), ("bvy", Var(None)), ("bvz", Var(None)), ("bm", Var(None))], Var("b"), Let(("_", Var(None)), Put(Var("px"), Int(0), Prim(Get(Var("px"), Int(0)), Prim(Var("bvx"), Var("bm"), Mul, kind=None), Add, kind=None)), Let(("_", Var(None)), Put(Var("py"), Int(0), Prim(Get(Var("py"), Int(0)), Prim(Var("bvy"), Var("bm"), Mul, kind=None), Add, kind=None)), Let(("_", Var(None)), Put(Var("pz"), Int(0), Prim(Get(Var("pz"), Int(0)), Prim(Var("bvz"), Var("bm"), Mul, kind=None), Add, kind=None)), Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Unit)))))), Unit), Unit)}, Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Int(0)]), Let(("b", Var(None)), Get(Var("bodies"), Int(0)), LetTuple([("bx", Var(None)), ("by", Var(None)), ("bz", Var(None)), ("bvx", Var(None)), ("bvy", Var(None)), ("bvz", Var(None)), ("bm", Var(None))], Var("b"), Let(("new_b", Var(None)), Tuple([Var("bx"), Var("by"), Var("bz"), Neg(Prim(Get(Var("px"), Int(0)), Var("solar_mass"), Div, kind=None), kind=None), Neg(Prim(Get(Var("py"), Int(0)), Var("solar_mass"), Div, kind=None), kind=None), Neg(Prim(Get(Var("pz"), Int(0)), Var("solar_mass"), Div, kind=None), kind=None), Var("bm")]), Let(("_", Var(None)), Put(Var("bodies"), Int(0), Var("new_b")), Unit)))))))
// [Typer] resolve: Array(Int(1), Double(0))
// [Typer] resolve: Int(1)
// [Typer] resolve: Double(0)
// [Typer] resolve: LetRec({tyvars: [], name: ("loop_i", Var(None)), args: [("i", Int)], body: Let(("_", Var(None)), If(LE(Var("i"), Prim(Var("n"), Int(1), Sub, kind=None)), Let(("b", Var(None)), Get(Var("bodies"), Var("i")), LetTuple([("bx", Var(None)), ("by", Var(None)), ("bz", Var(None)), ("bvx", Var(None)), ("bvy", Var(None)), ("bvz", Var(None)), ("bm", Var(None))], Var("b"), Let(("_", Var(None)), Put(Var("px"), Int(0), Prim(Get(Var("px"), Int(0)), Prim(Var("bvx"), Var("bm"), Mul, kind=None), Add, kind=None)), Let(("_", Var(None)), Put(Var("py"), Int(0), Prim(Get(Var("py"), Int(0)), Prim(Var("bvy"), Var("bm"), Mul, kind=None), Add, kind=None)), Let(("_", Var(None)), Put(Var("pz"), Int(0), Prim(Get(Var("pz"), Int(0)), Prim(Var("bvz"), Var("bm"), Mul, kind=None), Add, kind=None)), Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Unit)))))), Unit), Unit)}, Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Int(0)]), Let(("b", Var(None)), Get(Var("bodies"), Int(0)), LetTuple([("bx", Var(None)), ("by", Var(None)), ("bz", Var(None)), ("bvx", Var(None)), ("bvy", Var(None)), ("bvz", Var(None)), ("bm", Var(None))], Var("b"), Let(("new_b", Var(None)), Tuple([Var("bx"), Var("by"), Var("bz"), Neg(Prim(Get(Var("px"), Int(0)), Var("solar_mass"), Div, kind=None), kind=None), Neg(Prim(Get(Var("py"), Int(0)), Var("solar_mass"), Div, kind=None), kind=None), Neg(Prim(Get(Var("pz"), Int(0)), Var("solar_mass"), Div, kind=None), kind=None), Var("bm")]), Let(("_", Var(None)), Put(Var("bodies"), Int(0), Var("new_b")), Unit))))))
// [Typer] resolve: Let(("_", Var(None)), If(LE(Var("i"), Prim(Var("n"), Int(1), Sub, kind=None)), Let(("b", Var(None)), Get(Var("bodies"), Var("i")), LetTuple([("bx", Var(None)), ("by", Var(None)), ("bz", Var(None)), ("bvx", Var(None)), ("bvy", Var(None)), ("bvz", Var(None)), ("bm", Var(None))], Var("b"), Let(("_", Var(None)), Put(Var("px"), Int(0), Prim(Get(Var("px"), Int(0)), Prim(Var("bvx"), Var("bm"), Mul, kind=None), Add, kind=None)), Let(("_", Var(None)), Put(Var("py"), Int(0), Prim(Get(Var("py"), Int(0)), Prim(Var("bvy"), Var("bm"), Mul, kind=None), Add, kind=None)), Let(("_", Var(None)), Put(Var("pz"), Int(0), Prim(Get(Var("pz"), Int(0)), Prim(Var("bvz"), Var("bm"), Mul, kind=None), Add, kind=None)), Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Unit)))))), Unit), Unit)
// [Typer] resolve: If(LE(Var("i"), Prim(Var("n"), Int(1), Sub, kind=None)), Let(("b", Var(None)), Get(Var("bodies"), Var("i")), LetTuple([("bx", Var(None)), ("by", Var(None)), ("bz", Var(None)), ("bvx", Var(None)), ("bvy", Var(None)), ("bvz", Var(None)), ("bm", Var(None))], Var("b"), Let(("_", Var(None)), Put(Var("px"), Int(0), Prim(Get(Var("px"), Int(0)), Prim(Var("bvx"), Var("bm"), Mul, kind=None), Add, kind=None)), Let(("_", Var(None)), Put(Var("py"), Int(0), Prim(Get(Var("py"), Int(0)), Prim(Var("bvy"), Var("bm"), Mul, kind=None), Add, kind=None)), Let(("_", Var(None)), Put(Var("pz"), Int(0), Prim(Get(Var("pz"), Int(0)), Prim(Var("bvz"), Var("bm"), Mul, kind=None), Add, kind=None)), Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Unit)))))), Unit)
// [Typer] resolve: LE(Var("i"), Prim(Var("n"), Int(1), Sub, kind=None))
// [Typer] resolve: Var("i")
// [Typer] resolve: Prim(Var("n"), Int(1), Sub, kind=None)
// [Typer] resolve: Var("n")
// [Typer] resolve: Int(1)
// [Typer] resolve: Let(("b", Var(None)), Get(Var("bodies"), Var("i")), LetTuple([("bx", Var(None)), ("by", Var(None)), ("bz", Var(None)), ("bvx", Var(None)), ("bvy", Var(None)), ("bvz", Var(None)), ("bm", Var(None))], Var("b"), Let(("_", Var(None)), Put(Var("px"), Int(0), Prim(Get(Var("px"), Int(0)), Prim(Var("bvx"), Var("bm"), Mul, kind=None), Add, kind=None)), Let(("_", Var(None)), Put(Var("py"), Int(0), Prim(Get(Var("py"), Int(0)), Prim(Var("bvy"), Var("bm"), Mul, kind=None), Add, kind=None)), Let(("_", Var(None)), Put(Var("pz"), Int(0), Prim(Get(Var("pz"), Int(0)), Prim(Var("bvz"), Var("bm"), Mul, kind=None), Add, kind=None)), Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Unit))))))
// [Typer] resolve: Get(Var("bodies"), Var("i"))
// [Typer] resolve: Var("bodies")
// [Typer] resolve: Var("i")
// [Typer] resolve: LetTuple([("bx", Var(None)), ("by", Var(None)), ("bz", Var(None)), ("bvx", Var(None)), ("bvy", Var(None)), ("bvz", Var(None)), ("bm", Var(None))], Var("b"), Let(("_", Var(None)), Put(Var("px"), Int(0), Prim(Get(Var("px"), Int(0)), Prim(Var("bvx"), Var("bm"), Mul, kind=None), Add, kind=None)), Let(("_", Var(None)), Put(Var("py"), Int(0), Prim(Get(Var("py"), Int(0)), Prim(Var("bvy"), Var("bm"), Mul, kind=None), Add, kind=None)), Let(("_", Var(None)), Put(Var("pz"), Int(0), Prim(Get(Var("pz"), Int(0)), Prim(Var("bvz"), Var("bm"), Mul, kind=None), Add, kind=None)), Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Unit)))))
// [Typer] resolve: Var("b")
// [Typer] resolve: Let(("_", Var(None)), Put(Var("px"), Int(0), Prim(Get(Var("px"), Int(0)), Prim(Var("bvx"), Var("bm"), Mul, kind=None), Add, kind=None)), Let(("_", Var(None)), Put(Var("py"), Int(0), Prim(Get(Var("py"), Int(0)), Prim(Var("bvy"), Var("bm"), Mul, kind=None), Add, kind=None)), Let(("_", Var(None)), Put(Var("pz"), Int(0), Prim(Get(Var("pz"), Int(0)), Prim(Var("bvz"), Var("bm"), Mul, kind=None), Add, kind=None)), Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Unit))))
// [Typer] resolve: Put(Var("px"), Int(0), Prim(Get(Var("px"), Int(0)), Prim(Var("bvx"), Var("bm"), Mul, kind=None), Add, kind=None))
// [Typer] resolve: Var("px")
// [Typer] resolve: Int(0)
// [Typer] resolve: Prim(Get(Var("px"), Int(0)), Prim(Var("bvx"), Var("bm"), Mul, kind=None), Add, kind=None)
// [Typer] resolve: Get(Var("px"), Int(0))
// [Typer] resolve: Var("px")
// [Typer] resolve: Int(0)
// [Typer] resolve: Prim(Var("bvx"), Var("bm"), Mul, kind=None)
// [Typer] resolve: Var("bvx")
// [Typer] resolve: Var("bm")
// [Typer] resolve: Let(("_", Var(None)), Put(Var("py"), Int(0), Prim(Get(Var("py"), Int(0)), Prim(Var("bvy"), Var("bm"), Mul, kind=None), Add, kind=None)), Let(("_", Var(None)), Put(Var("pz"), Int(0), Prim(Get(Var("pz"), Int(0)), Prim(Var("bvz"), Var("bm"), Mul, kind=None), Add, kind=None)), Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Unit)))
// [Typer] resolve: Put(Var("py"), Int(0), Prim(Get(Var("py"), Int(0)), Prim(Var("bvy"), Var("bm"), Mul, kind=None), Add, kind=None))
// [Typer] resolve: Var("py")
// [Typer] resolve: Int(0)
// [Typer] resolve: Prim(Get(Var("py"), Int(0)), Prim(Var("bvy"), Var("bm"), Mul, kind=None), Add, kind=None)
// [Typer] resolve: Get(Var("py"), Int(0))
// [Typer] resolve: Var("py")
// [Typer] resolve: Int(0)
// [Typer] resolve: Prim(Var("bvy"), Var("bm"), Mul, kind=None)
// [Typer] resolve: Var("bvy")
// [Typer] resolve: Var("bm")
// [Typer] resolve: Let(("_", Var(None)), Put(Var("pz"), Int(0), Prim(Get(Var("pz"), Int(0)), Prim(Var("bvz"), Var("bm"), Mul, kind=None), Add, kind=None)), Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Unit))
// [Typer] resolve: Put(Var("pz"), Int(0), Prim(Get(Var("pz"), Int(0)), Prim(Var("bvz"), Var("bm"), Mul, kind=None), Add, kind=None))
// [Typer] resolve: Var("pz")
// [Typer] resolve: Int(0)
// [Typer] resolve: Prim(Get(Var("pz"), Int(0)), Prim(Var("bvz"), Var("bm"), Mul, kind=None), Add, kind=None)
// [Typer] resolve: Get(Var("pz"), Int(0))
// [Typer] resolve: Var("pz")
// [Typer] resolve: Int(0)
// [Typer] resolve: Prim(Var("bvz"), Var("bm"), Mul, kind=None)
// [Typer] resolve: Var("bvz")
// [Typer] resolve: Var("bm")
// [Typer] resolve: Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Unit)
// [Typer] resolve: App(Var("loop_i"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)])
// [Typer] resolve: Prim(Var("i"), Int(1), Add, kind=None)
// [Typer] resolve: Var("i")
// [Typer] resolve: Int(1)
// [Typer] resolve: Var("loop_i")
// [Typer] resolve: Unit
// [Typer] resolve: Unit
// [Typer] resolve: Unit
// [Typer] resolve: Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Int(0)]), Let(("b", Var(None)), Get(Var("bodies"), Int(0)), LetTuple([("bx", Var(None)), ("by", Var(None)), ("bz", Var(None)), ("bvx", Var(None)), ("bvy", Var(None)), ("bvz", Var(None)), ("bm", Var(None))], Var("b"), Let(("new_b", Var(None)), Tuple([Var("bx"), Var("by"), Var("bz"), Neg(Prim(Get(Var("px"), Int(0)), Var("solar_mass"), Div, kind=None), kind=None), Neg(Prim(Get(Var("py"), Int(0)), Var("solar_mass"), Div, kind=None), kind=None), Neg(Prim(Get(Var("pz"), Int(0)), Var("solar_mass"), Div, kind=None), kind=None), Var("bm")]), Let(("_", Var(None)), Put(Var("bodies"), Int(0), Var("new_b")), Unit)))))
// [Typer] resolve: App(Var("loop_i"), targs=None, [Int(0)])
// [Typer] resolve: Int(0)
// [Typer] resolve: Var("loop_i")
// [Typer] resolve: Let(("b", Var(None)), Get(Var("bodies"), Int(0)), LetTuple([("bx", Var(None)), ("by", Var(None)), ("bz", Var(None)), ("bvx", Var(None)), ("bvy", Var(None)), ("bvz", Var(None)), ("bm", Var(None))], Var("b"), Let(("new_b", Var(None)), Tuple([Var("bx"), Var("by"), Var("bz"), Neg(Prim(Get(Var("px"), Int(0)), Var("solar_mass"), Div, kind=None), kind=None), Neg(Prim(Get(Var("py"), Int(0)), Var("solar_mass"), Div, kind=None), kind=None), Neg(Prim(Get(Var("pz"), Int(0)), Var("solar_mass"), Div, kind=None), kind=None), Var("bm")]), Let(("_", Var(None)), Put(Var("bodies"), Int(0), Var("new_b")), Unit))))
// [Typer] resolve: Get(Var("bodies"), Int(0))
// [Typer] resolve: Var("bodies")
// [Typer] resolve: Int(0)
// [Typer] resolve: LetTuple([("bx", Var(None)), ("by", Var(None)), ("bz", Var(None)), ("bvx", Var(None)), ("bvy", Var(None)), ("bvz", Var(None)), ("bm", Var(None))], Var("b"), Let(("new_b", Var(None)), Tuple([Var("bx"), Var("by"), Var("bz"), Neg(Prim(Get(Var("px"), Int(0)), Var("solar_mass"), Div, kind=None), kind=None), Neg(Prim(Get(Var("py"), Int(0)), Var("solar_mass"), Div, kind=None), kind=None), Neg(Prim(Get(Var("pz"), Int(0)), Var("solar_mass"), Div, kind=None), kind=None), Var("bm")]), Let(("_", Var(None)), Put(Var("bodies"), Int(0), Var("new_b")), Unit)))
// [Typer] resolve: Var("b")
// [Typer] resolve: Let(("new_b", Var(None)), Tuple([Var("bx"), Var("by"), Var("bz"), Neg(Prim(Get(Var("px"), Int(0)), Var("solar_mass"), Div, kind=None), kind=None), Neg(Prim(Get(Var("py"), Int(0)), Var("solar_mass"), Div, kind=None), kind=None), Neg(Prim(Get(Var("pz"), Int(0)), Var("solar_mass"), Div, kind=None), kind=None), Var("bm")]), Let(("_", Var(None)), Put(Var("bodies"), Int(0), Var("new_b")), Unit))
// [Typer] resolve: Tuple([Var("bx"), Var("by"), Var("bz"), Neg(Prim(Get(Var("px"), Int(0)), Var("solar_mass"), Div, kind=None), kind=None), Neg(Prim(Get(Var("py"), Int(0)), Var("solar_mass"), Div, kind=None), kind=None), Neg(Prim(Get(Var("pz"), Int(0)), Var("solar_mass"), Div, kind=None), kind=None), Var("bm")])
// [Typer] resolve: Let(("_", Var(None)), Put(Var("bodies"), Int(0), Var("new_b")), Unit)
// [Typer] resolve: Put(Var("bodies"), Int(0), Var("new_b"))
// [Typer] resolve: Var("bodies")
// [Typer] resolve: Int(0)
// [Typer] resolve: Var("new_b")
// [Typer] resolve: Unit
// [Typer] resolve: LetRec({tyvars: [], name: ("main", Var(None)), args: [], body: Let(("jupiter", Var(None)), Tuple([Double(4.841431442464721), Neg(Double(1.1603200440274284), kind=None), Neg(Double(0.10362204447112311), kind=None), Prim(Double(0.001660076642744037), Var("days_per_year"), Mul, kind=None), Prim(Double(0.007699011184197404), Var("days_per_year"), Mul, kind=None), Neg(Prim(Double(0.0000690460016972063), Var("days_per_year"), Mul, kind=None), kind=None), Prim(Double(0.0009547919384243266), Var("solar_mass"), Mul, kind=None)]), Let(("saturn", Var(None)), Tuple([Double(8.34336671824458), Double(4.124798564124305), Neg(Double(0.4035234171143214), kind=None), Neg(Prim(Double(0.002767425107268624), Var("days_per_year"), Mul, kind=None), kind=None), Prim(Double(0.004998528012349172), Var("days_per_year"), Mul, kind=None), Prim(Double(0.000023029345528229068), Var("days_per_year"), Mul, kind=None), Prim(Double(0.0002858859806661308), Var("solar_mass"), Mul, kind=None)]), Let(("uranus", Var(None)), Tuple([Double(12.894369562139131), Neg(Double(15.111151401698631), kind=None), Neg(Double(0.22330757889265587), kind=None), Prim(Double(0.002964601375647616), Var("days_per_year"), Mul, kind=None), Prim(Double(0.0023784717395948095), Var("days_per_year"), Mul, kind=None), Neg(Prim(Double(0.000029658956854023756), Var("days_per_year"), Mul, kind=None), kind=None), Prim(Double(0.00004366244043351563), Var("solar_mass"), Mul, kind=None)]), Let(("neptune", Var(None)), Tuple([Double(15.379697114850917), Neg(Double(25.919314609987964), kind=None), Double(0.17925877295037118), Prim(Double(0.0026806777249038932), Var("days_per_year"), Mul, kind=None), Prim(Double(0.001628241700382423), Var("days_per_year"), Mul, kind=None), Neg(Prim(Double(0.00009515922545197159), Var("days_per_year"), Mul, kind=None), kind=None), Prim(Double(0.00005151389020466116), Var("solar_mass"), Mul, kind=None)]), Let(("sun", Var(None)), Tuple([Double(0), Double(0), Double(0), Double(0), Double(0), Double(0), Var("solar_mass")]), Let(("bodies", Var(None)), Array(Int(5), Tuple([Double(0), Double(0), Double(0), Double(0), Double(0), Double(0), Double(0)])), Let(("_", Var(None)), Put(Var("bodies"), Int(0), Var("sun")), Let(("_", Var(None)), Put(Var("bodies"), Int(1), Var("jupiter")), Let(("_", Var(None)), Put(Var("bodies"), Int(2), Var("saturn")), Let(("_", Var(None)), Put(Var("bodies"), Int(3), Var("uranus")), Let(("_", Var(None)), Put(Var("bodies"), Int(4), Var("neptune")), Let(("_", Var(None)), App(Var("offset_momentum"), targs=None, [Var("bodies")]), Let(("_", Var(None)), App(Var("print_int"), targs=None, [App(Var("int_of_float"), targs=None, [Prim(App(Var("energy"), targs=None, [Var("bodies")]), Double(1000000000), Mul, kind=None)])]), Let(("iters", Var(None)), Int(500000), LetRec({tyvars: [], name: ("loop_i", Var(None)), args: [("i", Int)], body: Let(("_", Var(None)), If(LE(Var("i"), Var("iters")), Let(("_", Var(None)), App(Var("advance"), targs=None, [Var("bodies"), Double(0.01)]), Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Unit)), Unit), Unit)}, Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Int(1)]), Let(("_", Var(None)), App(Var("print_char"), targs=None, [Int(10)]), Let(("_", Var(None)), App(Var("print_int"), targs=None, [App(Var("int_of_float"), targs=None, [Prim(App(Var("energy"), targs=None, [Var("bodies")]), Double(1000000000), Mul, kind=None)])]), Unit))))))))))))))))))}, Unit)
// [Typer] resolve: Let(("jupiter", Var(None)), Tuple([Double(4.841431442464721), Neg(Double(1.1603200440274284), kind=None), Neg(Double(0.10362204447112311), kind=None), Prim(Double(0.001660076642744037), Var("days_per_year"), Mul, kind=None), Prim(Double(0.007699011184197404), Var("days_per_year"), Mul, kind=None), Neg(Prim(Double(0.0000690460016972063), Var("days_per_year"), Mul, kind=None), kind=None), Prim(Double(0.0009547919384243266), Var("solar_mass"), Mul, kind=None)]), Let(("saturn", Var(None)), Tuple([Double(8.34336671824458), Double(4.124798564124305), Neg(Double(0.4035234171143214), kind=None), Neg(Prim(Double(0.002767425107268624), Var("days_per_year"), Mul, kind=None), kind=None), Prim(Double(0.004998528012349172), Var("days_per_year"), Mul, kind=None), Prim(Double(0.000023029345528229068), Var("days_per_year"), Mul, kind=None), Prim(Double(0.0002858859806661308), Var("solar_mass"), Mul, kind=None)]), Let(("uranus", Var(None)), Tuple([Double(12.894369562139131), Neg(Double(15.111151401698631), kind=None), Neg(Double(0.22330757889265587), kind=None), Prim(Double(0.002964601375647616), Var("days_per_year"), Mul, kind=None), Prim(Double(0.0023784717395948095), Var("days_per_year"), Mul, kind=None), Neg(Prim(Double(0.000029658956854023756), Var("days_per_year"), Mul, kind=None), kind=None), Prim(Double(0.00004366244043351563), Var("solar_mass"), Mul, kind=None)]), Let(("neptune", Var(None)), Tuple([Double(15.379697114850917), Neg(Double(25.919314609987964), kind=None), Double(0.17925877295037118), Prim(Double(0.0026806777249038932), Var("days_per_year"), Mul, kind=None), Prim(Double(0.001628241700382423), Var("days_per_year"), Mul, kind=None), Neg(Prim(Double(0.00009515922545197159), Var("days_per_year"), Mul, kind=None), kind=None), Prim(Double(0.00005151389020466116), Var("solar_mass"), Mul, kind=None)]), Let(("sun", Var(None)), Tuple([Double(0), Double(0), Double(0), Double(0), Double(0), Double(0), Var("solar_mass")]), Let(("bodies", Var(None)), Array(Int(5), Tuple([Double(0), Double(0), Double(0), Double(0), Double(0), Double(0), Double(0)])), Let(("_", Var(None)), Put(Var("bodies"), Int(0), Var("sun")), Let(("_", Var(None)), Put(Var("bodies"), Int(1), Var("jupiter")), Let(("_", Var(None)), Put(Var("bodies"), Int(2), Var("saturn")), Let(("_", Var(None)), Put(Var("bodies"), Int(3), Var("uranus")), Let(("_", Var(None)), Put(Var("bodies"), Int(4), Var("neptune")), Let(("_", Var(None)), App(Var("offset_momentum"), targs=None, [Var("bodies")]), Let(("_", Var(None)), App(Var("print_int"), targs=None, [App(Var("int_of_float"), targs=None, [Prim(App(Var("energy"), targs=None, [Var("bodies")]), Double(1000000000), Mul, kind=None)])]), Let(("iters", Var(None)), Int(500000), LetRec({tyvars: [], name: ("loop_i", Var(None)), args: [("i", Int)], body: Let(("_", Var(None)), If(LE(Var("i"), Var("iters")), Let(("_", Var(None)), App(Var("advance"), targs=None, [Var("bodies"), Double(0.01)]), Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Unit)), Unit), Unit)}, Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Int(1)]), Let(("_", Var(None)), App(Var("print_char"), targs=None, [Int(10)]), Let(("_", Var(None)), App(Var("print_int"), targs=None, [App(Var("int_of_float"), targs=None, [Prim(App(Var("energy"), targs=None, [Var("bodies")]), Double(1000000000), Mul, kind=None)])]), Unit))))))))))))))))))
// [Typer] resolve: Tuple([Double(4.841431442464721), Neg(Double(1.1603200440274284), kind=None), Neg(Double(0.10362204447112311), kind=None), Prim(Double(0.001660076642744037), Var("days_per_year"), Mul, kind=None), Prim(Double(0.007699011184197404), Var("days_per_year"), Mul, kind=None), Neg(Prim(Double(0.0000690460016972063), Var("days_per_year"), Mul, kind=None), kind=None), Prim(Double(0.0009547919384243266), Var("solar_mass"), Mul, kind=None)])
// [Typer] resolve: Let(("saturn", Var(None)), Tuple([Double(8.34336671824458), Double(4.124798564124305), Neg(Double(0.4035234171143214), kind=None), Neg(Prim(Double(0.002767425107268624), Var("days_per_year"), Mul, kind=None), kind=None), Prim(Double(0.004998528012349172), Var("days_per_year"), Mul, kind=None), Prim(Double(0.000023029345528229068), Var("days_per_year"), Mul, kind=None), Prim(Double(0.0002858859806661308), Var("solar_mass"), Mul, kind=None)]), Let(("uranus", Var(None)), Tuple([Double(12.894369562139131), Neg(Double(15.111151401698631), kind=None), Neg(Double(0.22330757889265587), kind=None), Prim(Double(0.002964601375647616), Var("days_per_year"), Mul, kind=None), Prim(Double(0.0023784717395948095), Var("days_per_year"), Mul, kind=None), Neg(Prim(Double(0.000029658956854023756), Var("days_per_year"), Mul, kind=None), kind=None), Prim(Double(0.00004366244043351563), Var("solar_mass"), Mul, kind=None)]), Let(("neptune", Var(None)), Tuple([Double(15.379697114850917), Neg(Double(25.919314609987964), kind=None), Double(0.17925877295037118), Prim(Double(0.0026806777249038932), Var("days_per_year"), Mul, kind=None), Prim(Double(0.001628241700382423), Var("days_per_year"), Mul, kind=None), Neg(Prim(Double(0.00009515922545197159), Var("days_per_year"), Mul, kind=None), kind=None), Prim(Double(0.00005151389020466116), Var("solar_mass"), Mul, kind=None)]), Let(("sun", Var(None)), Tuple([Double(0), Double(0), Double(0), Double(0), Double(0), Double(0), Var("solar_mass")]), Let(("bodies", Var(None)), Array(Int(5), Tuple([Double(0), Double(0), Double(0), Double(0), Double(0), Double(0), Double(0)])), Let(("_", Var(None)), Put(Var("bodies"), Int(0), Var("sun")), Let(("_", Var(None)), Put(Var("bodies"), Int(1), Var("jupiter")), Let(("_", Var(None)), Put(Var("bodies"), Int(2), Var("saturn")), Let(("_", Var(None)), Put(Var("bodies"), Int(3), Var("uranus")), Let(("_", Var(None)), Put(Var("bodies"), Int(4), Var("neptune")), Let(("_", Var(None)), App(Var("offset_momentum"), targs=None, [Var("bodies")]), Let(("_", Var(None)), App(Var("print_int"), targs=None, [App(Var("int_of_float"), targs=None, [Prim(App(Var("energy"), targs=None, [Var("bodies")]), Double(1000000000), Mul, kind=None)])]), Let(("iters", Var(None)), Int(500000), LetRec({tyvars: [], name: ("loop_i", Var(None)), args: [("i", Int)], body: Let(("_", Var(None)), If(LE(Var("i"), Var("iters")), Let(("_", Var(None)), App(Var("advance"), targs=None, [Var("bodies"), Double(0.01)]), Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Unit)), Unit), Unit)}, Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Int(1)]), Let(("_", Var(None)), App(Var("print_char"), targs=None, [Int(10)]), Let(("_", Var(None)), App(Var("print_int"), targs=None, [App(Var("int_of_float"), targs=None, [Prim(App(Var("energy"), targs=None, [Var("bodies")]), Double(1000000000), Mul, kind=None)])]), Unit)))))))))))))))))
// [Typer] resolve: Tuple([Double(8.34336671824458), Double(4.124798564124305), Neg(Double(0.4035234171143214), kind=None), Neg(Prim(Double(0.002767425107268624), Var("days_per_year"), Mul, kind=None), kind=None), Prim(Double(0.004998528012349172), Var("days_per_year"), Mul, kind=None), Prim(Double(0.000023029345528229068), Var("days_per_year"), Mul, kind=None), Prim(Double(0.0002858859806661308), Var("solar_mass"), Mul, kind=None)])
// [Typer] resolve: Let(("uranus", Var(None)), Tuple([Double(12.894369562139131), Neg(Double(15.111151401698631), kind=None), Neg(Double(0.22330757889265587), kind=None), Prim(Double(0.002964601375647616), Var("days_per_year"), Mul, kind=None), Prim(Double(0.0023784717395948095), Var("days_per_year"), Mul, kind=None), Neg(Prim(Double(0.000029658956854023756), Var("days_per_year"), Mul, kind=None), kind=None), Prim(Double(0.00004366244043351563), Var("solar_mass"), Mul, kind=None)]), Let(("neptune", Var(None)), Tuple([Double(15.379697114850917), Neg(Double(25.919314609987964), kind=None), Double(0.17925877295037118), Prim(Double(0.0026806777249038932), Var("days_per_year"), Mul, kind=None), Prim(Double(0.001628241700382423), Var("days_per_year"), Mul, kind=None), Neg(Prim(Double(0.00009515922545197159), Var("days_per_year"), Mul, kind=None), kind=None), Prim(Double(0.00005151389020466116), Var("solar_mass"), Mul, kind=None)]), Let(("sun", Var(None)), Tuple([Double(0), Double(0), Double(0), Double(0), Double(0), Double(0), Var("solar_mass")]), Let(("bodies", Var(None)), Array(Int(5), Tuple([Double(0), Double(0), Double(0), Double(0), Double(0), Double(0), Double(0)])), Let(("_", Var(None)), Put(Var("bodies"), Int(0), Var("sun")), Let(("_", Var(None)), Put(Var("bodies"), Int(1), Var("jupiter")), Let(("_", Var(None)), Put(Var("bodies"), Int(2), Var("saturn")), Let(("_", Var(None)), Put(Var("bodies"), Int(3), Var("uranus")), Let(("_", Var(None)), Put(Var("bodies"), Int(4), Var("neptune")), Let(("_", Var(None)), App(Var("offset_momentum"), targs=None, [Var("bodies")]), Let(("_", Var(None)), App(Var("print_int"), targs=None, [App(Var("int_of_float"), targs=None, [Prim(App(Var("energy"), targs=None, [Var("bodies")]), Double(1000000000), Mul, kind=None)])]), Let(("iters", Var(None)), Int(500000), LetRec({tyvars: [], name: ("loop_i", Var(None)), args: [("i", Int)], body: Let(("_", Var(None)), If(LE(Var("i"), Var("iters")), Let(("_", Var(None)), App(Var("advance"), targs=None, [Var("bodies"), Double(0.01)]), Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Unit)), Unit), Unit)}, Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Int(1)]), Let(("_", Var(None)), App(Var("print_char"), targs=None, [Int(10)]), Let(("_", Var(None)), App(Var("print_int"), targs=None, [App(Var("int_of_float"), targs=None, [Prim(App(Var("energy"), targs=None, [Var("bodies")]), Double(1000000000), Mul, kind=None)])]), Unit))))))))))))))))
// [Typer] resolve: Tuple([Double(12.894369562139131), Neg(Double(15.111151401698631), kind=None), Neg(Double(0.22330757889265587), kind=None), Prim(Double(0.002964601375647616), Var("days_per_year"), Mul, kind=None), Prim(Double(0.0023784717395948095), Var("days_per_year"), Mul, kind=None), Neg(Prim(Double(0.000029658956854023756), Var("days_per_year"), Mul, kind=None), kind=None), Prim(Double(0.00004366244043351563), Var("solar_mass"), Mul, kind=None)])
// [Typer] resolve: Let(("neptune", Var(None)), Tuple([Double(15.379697114850917), Neg(Double(25.919314609987964), kind=None), Double(0.17925877295037118), Prim(Double(0.0026806777249038932), Var("days_per_year"), Mul, kind=None), Prim(Double(0.001628241700382423), Var("days_per_year"), Mul, kind=None), Neg(Prim(Double(0.00009515922545197159), Var("days_per_year"), Mul, kind=None), kind=None), Prim(Double(0.00005151389020466116), Var("solar_mass"), Mul, kind=None)]), Let(("sun", Var(None)), Tuple([Double(0), Double(0), Double(0), Double(0), Double(0), Double(0), Var("solar_mass")]), Let(("bodies", Var(None)), Array(Int(5), Tuple([Double(0), Double(0), Double(0), Double(0), Double(0), Double(0), Double(0)])), Let(("_", Var(None)), Put(Var("bodies"), Int(0), Var("sun")), Let(("_", Var(None)), Put(Var("bodies"), Int(1), Var("jupiter")), Let(("_", Var(None)), Put(Var("bodies"), Int(2), Var("saturn")), Let(("_", Var(None)), Put(Var("bodies"), Int(3), Var("uranus")), Let(("_", Var(None)), Put(Var("bodies"), Int(4), Var("neptune")), Let(("_", Var(None)), App(Var("offset_momentum"), targs=None, [Var("bodies")]), Let(("_", Var(None)), App(Var("print_int"), targs=None, [App(Var("int_of_float"), targs=None, [Prim(App(Var("energy"), targs=None, [Var("bodies")]), Double(1000000000), Mul, kind=None)])]), Let(("iters", Var(None)), Int(500000), LetRec({tyvars: [], name: ("loop_i", Var(None)), args: [("i", Int)], body: Let(("_", Var(None)), If(LE(Var("i"), Var("iters")), Let(("_", Var(None)), App(Var("advance"), targs=None, [Var("bodies"), Double(0.01)]), Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Unit)), Unit), Unit)}, Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Int(1)]), Let(("_", Var(None)), App(Var("print_char"), targs=None, [Int(10)]), Let(("_", Var(None)), App(Var("print_int"), targs=None, [App(Var("int_of_float"), targs=None, [Prim(App(Var("energy"), targs=None, [Var("bodies")]), Double(1000000000), Mul, kind=None)])]), Unit)))))))))))))))
// [Typer] resolve: Tuple([Double(15.379697114850917), Neg(Double(25.919314609987964), kind=None), Double(0.17925877295037118), Prim(Double(0.0026806777249038932), Var("days_per_year"), Mul, kind=None), Prim(Double(0.001628241700382423), Var("days_per_year"), Mul, kind=None), Neg(Prim(Double(0.00009515922545197159), Var("days_per_year"), Mul, kind=None), kind=None), Prim(Double(0.00005151389020466116), Var("solar_mass"), Mul, kind=None)])
// [Typer] resolve: Let(("sun", Var(None)), Tuple([Double(0), Double(0), Double(0), Double(0), Double(0), Double(0), Var("solar_mass")]), Let(("bodies", Var(None)), Array(Int(5), Tuple([Double(0), Double(0), Double(0), Double(0), Double(0), Double(0), Double(0)])), Let(("_", Var(None)), Put(Var("bodies"), Int(0), Var("sun")), Let(("_", Var(None)), Put(Var("bodies"), Int(1), Var("jupiter")), Let(("_", Var(None)), Put(Var("bodies"), Int(2), Var("saturn")), Let(("_", Var(None)), Put(Var("bodies"), Int(3), Var("uranus")), Let(("_", Var(None)), Put(Var("bodies"), Int(4), Var("neptune")), Let(("_", Var(None)), App(Var("offset_momentum"), targs=None, [Var("bodies")]), Let(("_", Var(None)), App(Var("print_int"), targs=None, [App(Var("int_of_float"), targs=None, [Prim(App(Var("energy"), targs=None, [Var("bodies")]), Double(1000000000), Mul, kind=None)])]), Let(("iters", Var(None)), Int(500000), LetRec({tyvars: [], name: ("loop_i", Var(None)), args: [("i", Int)], body: Let(("_", Var(None)), If(LE(Var("i"), Var("iters")), Let(("_", Var(None)), App(Var("advance"), targs=None, [Var("bodies"), Double(0.01)]), Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Unit)), Unit), Unit)}, Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Int(1)]), Let(("_", Var(None)), App(Var("print_char"), targs=None, [Int(10)]), Let(("_", Var(None)), App(Var("print_int"), targs=None, [App(Var("int_of_float"), targs=None, [Prim(App(Var("energy"), targs=None, [Var("bodies")]), Double(1000000000), Mul, kind=None)])]), Unit))))))))))))))
// [Typer] resolve: Tuple([Double(0), Double(0), Double(0), Double(0), Double(0), Double(0), Var("solar_mass")])
// [Typer] resolve: Let(("bodies", Var(None)), Array(Int(5), Tuple([Double(0), Double(0), Double(0), Double(0), Double(0), Double(0), Double(0)])), Let(("_", Var(None)), Put(Var("bodies"), Int(0), Var("sun")), Let(("_", Var(None)), Put(Var("bodies"), Int(1), Var("jupiter")), Let(("_", Var(None)), Put(Var("bodies"), Int(2), Var("saturn")), Let(("_", Var(None)), Put(Var("bodies"), Int(3), Var("uranus")), Let(("_", Var(None)), Put(Var("bodies"), Int(4), Var("neptune")), Let(("_", Var(None)), App(Var("offset_momentum"), targs=None, [Var("bodies")]), Let(("_", Var(None)), App(Var("print_int"), targs=None, [App(Var("int_of_float"), targs=None, [Prim(App(Var("energy"), targs=None, [Var("bodies")]), Double(1000000000), Mul, kind=None)])]), Let(("iters", Var(None)), Int(500000), LetRec({tyvars: [], name: ("loop_i", Var(None)), args: [("i", Int)], body: Let(("_", Var(None)), If(LE(Var("i"), Var("iters")), Let(("_", Var(None)), App(Var("advance"), targs=None, [Var("bodies"), Double(0.01)]), Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Unit)), Unit), Unit)}, Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Int(1)]), Let(("_", Var(None)), App(Var("print_char"), targs=None, [Int(10)]), Let(("_", Var(None)), App(Var("print_int"), targs=None, [App(Var("int_of_float"), targs=None, [Prim(App(Var("energy"), targs=None, [Var("bodies")]), Double(1000000000), Mul, kind=None)])]), Unit)))))))))))))
// [Typer] resolve: Array(Int(5), Tuple([Double(0), Double(0), Double(0), Double(0), Double(0), Double(0), Double(0)]))
// [Typer] resolve: Int(5)
// [Typer] resolve: Tuple([Double(0), Double(0), Double(0), Double(0), Double(0), Double(0), Double(0)])
// [Typer] resolve: Let(("_", Var(None)), Put(Var("bodies"), Int(0), Var("sun")), Let(("_", Var(None)), Put(Var("bodies"), Int(1), Var("jupiter")), Let(("_", Var(None)), Put(Var("bodies"), Int(2), Var("saturn")), Let(("_", Var(None)), Put(Var("bodies"), Int(3), Var("uranus")), Let(("_", Var(None)), Put(Var("bodies"), Int(4), Var("neptune")), Let(("_", Var(None)), App(Var("offset_momentum"), targs=None, [Var("bodies")]), Let(("_", Var(None)), App(Var("print_int"), targs=None, [App(Var("int_of_float"), targs=None, [Prim(App(Var("energy"), targs=None, [Var("bodies")]), Double(1000000000), Mul, kind=None)])]), Let(("iters", Var(None)), Int(500000), LetRec({tyvars: [], name: ("loop_i", Var(None)), args: [("i", Int)], body: Let(("_", Var(None)), If(LE(Var("i"), Var("iters")), Let(("_", Var(None)), App(Var("advance"), targs=None, [Var("bodies"), Double(0.01)]), Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Unit)), Unit), Unit)}, Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Int(1)]), Let(("_", Var(None)), App(Var("print_char"), targs=None, [Int(10)]), Let(("_", Var(None)), App(Var("print_int"), targs=None, [App(Var("int_of_float"), targs=None, [Prim(App(Var("energy"), targs=None, [Var("bodies")]), Double(1000000000), Mul, kind=None)])]), Unit))))))))))))
// [Typer] resolve: Put(Var("bodies"), Int(0), Var("sun"))
// [Typer] resolve: Var("bodies")
// [Typer] resolve: Int(0)
// [Typer] resolve: Var("sun")
// [Typer] resolve: Let(("_", Var(None)), Put(Var("bodies"), Int(1), Var("jupiter")), Let(("_", Var(None)), Put(Var("bodies"), Int(2), Var("saturn")), Let(("_", Var(None)), Put(Var("bodies"), Int(3), Var("uranus")), Let(("_", Var(None)), Put(Var("bodies"), Int(4), Var("neptune")), Let(("_", Var(None)), App(Var("offset_momentum"), targs=None, [Var("bodies")]), Let(("_", Var(None)), App(Var("print_int"), targs=None, [App(Var("int_of_float"), targs=None, [Prim(App(Var("energy"), targs=None, [Var("bodies")]), Double(1000000000), Mul, kind=None)])]), Let(("iters", Var(None)), Int(500000), LetRec({tyvars: [], name: ("loop_i", Var(None)), args: [("i", Int)], body: Let(("_", Var(None)), If(LE(Var("i"), Var("iters")), Let(("_", Var(None)), App(Var("advance"), targs=None, [Var("bodies"), Double(0.01)]), Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Unit)), Unit), Unit)}, Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Int(1)]), Let(("_", Var(None)), App(Var("print_char"), targs=None, [Int(10)]), Let(("_", Var(None)), App(Var("print_int"), targs=None, [App(Var("int_of_float"), targs=None, [Prim(App(Var("energy"), targs=None, [Var("bodies")]), Double(1000000000), Mul, kind=None)])]), Unit)))))))))))
// [Typer] resolve: Put(Var("bodies"), Int(1), Var("jupiter"))
// [Typer] resolve: Var("bodies")
// [Typer] resolve: Int(1)
// [Typer] resolve: Var("jupiter")
// [Typer] resolve: Let(("_", Var(None)), Put(Var("bodies"), Int(2), Var("saturn")), Let(("_", Var(None)), Put(Var("bodies"), Int(3), Var("uranus")), Let(("_", Var(None)), Put(Var("bodies"), Int(4), Var("neptune")), Let(("_", Var(None)), App(Var("offset_momentum"), targs=None, [Var("bodies")]), Let(("_", Var(None)), App(Var("print_int"), targs=None, [App(Var("int_of_float"), targs=None, [Prim(App(Var("energy"), targs=None, [Var("bodies")]), Double(1000000000), Mul, kind=None)])]), Let(("iters", Var(None)), Int(500000), LetRec({tyvars: [], name: ("loop_i", Var(None)), args: [("i", Int)], body: Let(("_", Var(None)), If(LE(Var("i"), Var("iters")), Let(("_", Var(None)), App(Var("advance"), targs=None, [Var("bodies"), Double(0.01)]), Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Unit)), Unit), Unit)}, Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Int(1)]), Let(("_", Var(None)), App(Var("print_char"), targs=None, [Int(10)]), Let(("_", Var(None)), App(Var("print_int"), targs=None, [App(Var("int_of_float"), targs=None, [Prim(App(Var("energy"), targs=None, [Var("bodies")]), Double(1000000000), Mul, kind=None)])]), Unit))))))))))
// [Typer] resolve: Put(Var("bodies"), Int(2), Var("saturn"))
// [Typer] resolve: Var("bodies")
// [Typer] resolve: Int(2)
// [Typer] resolve: Var("saturn")
// [Typer] resolve: Let(("_", Var(None)), Put(Var("bodies"), Int(3), Var("uranus")), Let(("_", Var(None)), Put(Var("bodies"), Int(4), Var("neptune")), Let(("_", Var(None)), App(Var("offset_momentum"), targs=None, [Var("bodies")]), Let(("_", Var(None)), App(Var("print_int"), targs=None, [App(Var("int_of_float"), targs=None, [Prim(App(Var("energy"), targs=None, [Var("bodies")]), Double(1000000000), Mul, kind=None)])]), Let(("iters", Var(None)), Int(500000), LetRec({tyvars: [], name: ("loop_i", Var(None)), args: [("i", Int)], body: Let(("_", Var(None)), If(LE(Var("i"), Var("iters")), Let(("_", Var(None)), App(Var("advance"), targs=None, [Var("bodies"), Double(0.01)]), Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Unit)), Unit), Unit)}, Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Int(1)]), Let(("_", Var(None)), App(Var("print_char"), targs=None, [Int(10)]), Let(("_", Var(None)), App(Var("print_int"), targs=None, [App(Var("int_of_float"), targs=None, [Prim(App(Var("energy"), targs=None, [Var("bodies")]), Double(1000000000), Mul, kind=None)])]), Unit)))))))))
// [Typer] resolve: Put(Var("bodies"), Int(3), Var("uranus"))
// [Typer] resolve: Var("bodies")
// [Typer] resolve: Int(3)
// [Typer] resolve: Var("uranus")
// [Typer] resolve: Let(("_", Var(None)), Put(Var("bodies"), Int(4), Var("neptune")), Let(("_", Var(None)), App(Var("offset_momentum"), targs=None, [Var("bodies")]), Let(("_", Var(None)), App(Var("print_int"), targs=None, [App(Var("int_of_float"), targs=None, [Prim(App(Var("energy"), targs=None, [Var("bodies")]), Double(1000000000), Mul, kind=None)])]), Let(("iters", Var(None)), Int(500000), LetRec({tyvars: [], name: ("loop_i", Var(None)), args: [("i", Int)], body: Let(("_", Var(None)), If(LE(Var("i"), Var("iters")), Let(("_", Var(None)), App(Var("advance"), targs=None, [Var("bodies"), Double(0.01)]), Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Unit)), Unit), Unit)}, Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Int(1)]), Let(("_", Var(None)), App(Var("print_char"), targs=None, [Int(10)]), Let(("_", Var(None)), App(Var("print_int"), targs=None, [App(Var("int_of_float"), targs=None, [Prim(App(Var("energy"), targs=None, [Var("bodies")]), Double(1000000000), Mul, kind=None)])]), Unit))))))))
// [Typer] resolve: Put(Var("bodies"), Int(4), Var("neptune"))
// [Typer] resolve: Var("bodies")
// [Typer] resolve: Int(4)
// [Typer] resolve: Var("neptune")
// [Typer] resolve: Let(("_", Var(None)), App(Var("offset_momentum"), targs=None, [Var("bodies")]), Let(("_", Var(None)), App(Var("print_int"), targs=None, [App(Var("int_of_float"), targs=None, [Prim(App(Var("energy"), targs=None, [Var("bodies")]), Double(1000000000), Mul, kind=None)])]), Let(("iters", Var(None)), Int(500000), LetRec({tyvars: [], name: ("loop_i", Var(None)), args: [("i", Int)], body: Let(("_", Var(None)), If(LE(Var("i"), Var("iters")), Let(("_", Var(None)), App(Var("advance"), targs=None, [Var("bodies"), Double(0.01)]), Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Unit)), Unit), Unit)}, Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Int(1)]), Let(("_", Var(None)), App(Var("print_char"), targs=None, [Int(10)]), Let(("_", Var(None)), App(Var("print_int"), targs=None, [App(Var("int_of_float"), targs=None, [Prim(App(Var("energy"), targs=None, [Var("bodies")]), Double(1000000000), Mul, kind=None)])]), Unit)))))))
// [Typer] resolve: App(Var("offset_momentum"), targs=None, [Var("bodies")])
// [Typer] resolve: Var("bodies")
// [Typer] resolve: Var("offset_momentum")
// [Typer] resolve: Let(("_", Var(None)), App(Var("print_int"), targs=None, [App(Var("int_of_float"), targs=None, [Prim(App(Var("energy"), targs=None, [Var("bodies")]), Double(1000000000), Mul, kind=None)])]), Let(("iters", Var(None)), Int(500000), LetRec({tyvars: [], name: ("loop_i", Var(None)), args: [("i", Int)], body: Let(("_", Var(None)), If(LE(Var("i"), Var("iters")), Let(("_", Var(None)), App(Var("advance"), targs=None, [Var("bodies"), Double(0.01)]), Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Unit)), Unit), Unit)}, Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Int(1)]), Let(("_", Var(None)), App(Var("print_char"), targs=None, [Int(10)]), Let(("_", Var(None)), App(Var("print_int"), targs=None, [App(Var("int_of_float"), targs=None, [Prim(App(Var("energy"), targs=None, [Var("bodies")]), Double(1000000000), Mul, kind=None)])]), Unit))))))
// [Typer] resolve: App(Var("print_int"), targs=None, [App(Var("int_of_float"), targs=None, [Prim(App(Var("energy"), targs=None, [Var("bodies")]), Double(1000000000), Mul, kind=None)])])
// [Typer] resolve: App(Var("int_of_float"), targs=None, [Prim(App(Var("energy"), targs=None, [Var("bodies")]), Double(1000000000), Mul, kind=None)])
// [Typer] resolve: Prim(App(Var("energy"), targs=None, [Var("bodies")]), Double(1000000000), Mul, kind=None)
// [Typer] resolve: App(Var("energy"), targs=None, [Var("bodies")])
// [Typer] resolve: Var("bodies")
// [Typer] resolve: Var("energy")
// [Typer] resolve: Double(1000000000)
// [Typer] resolve: Var("int_of_float")
// [Typer] resolve: Var("print_int")
// [Typer] resolve: Let(("iters", Var(None)), Int(500000), LetRec({tyvars: [], name: ("loop_i", Var(None)), args: [("i", Int)], body: Let(("_", Var(None)), If(LE(Var("i"), Var("iters")), Let(("_", Var(None)), App(Var("advance"), targs=None, [Var("bodies"), Double(0.01)]), Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Unit)), Unit), Unit)}, Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Int(1)]), Let(("_", Var(None)), App(Var("print_char"), targs=None, [Int(10)]), Let(("_", Var(None)), App(Var("print_int"), targs=None, [App(Var("int_of_float"), targs=None, [Prim(App(Var("energy"), targs=None, [Var("bodies")]), Double(1000000000), Mul, kind=None)])]), Unit)))))
// [Typer] resolve: Int(500000)
// [Typer] resolve: LetRec({tyvars: [], name: ("loop_i", Var(None)), args: [("i", Int)], body: Let(("_", Var(None)), If(LE(Var("i"), Var("iters")), Let(("_", Var(None)), App(Var("advance"), targs=None, [Var("bodies"), Double(0.01)]), Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Unit)), Unit), Unit)}, Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Int(1)]), Let(("_", Var(None)), App(Var("print_char"), targs=None, [Int(10)]), Let(("_", Var(None)), App(Var("print_int"), targs=None, [App(Var("int_of_float"), targs=None, [Prim(App(Var("energy"), targs=None, [Var("bodies")]), Double(1000000000), Mul, kind=None)])]), Unit))))
// [Typer] resolve: Let(("_", Var(None)), If(LE(Var("i"), Var("iters")), Let(("_", Var(None)), App(Var("advance"), targs=None, [Var("bodies"), Double(0.01)]), Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Unit)), Unit), Unit)
// [Typer] resolve: If(LE(Var("i"), Var("iters")), Let(("_", Var(None)), App(Var("advance"), targs=None, [Var("bodies"), Double(0.01)]), Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Unit)), Unit)
// [Typer] resolve: LE(Var("i"), Var("iters"))
// [Typer] resolve: Var("i")
// [Typer] resolve: Var("iters")
// [Typer] resolve: Let(("_", Var(None)), App(Var("advance"), targs=None, [Var("bodies"), Double(0.01)]), Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Unit))
// [Typer] resolve: App(Var("advance"), targs=None, [Var("bodies"), Double(0.01)])
// [Typer] resolve: Var("bodies")
// [Typer] resolve: Double(0.01)
// [Typer] resolve: Var("advance")
// [Typer] resolve: Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Unit)
// [Typer] resolve: App(Var("loop_i"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)])
// [Typer] resolve: Prim(Var("i"), Int(1), Add, kind=None)
// [Typer] resolve: Var("i")
// [Typer] resolve: Int(1)
// [Typer] resolve: Var("loop_i")
// [Typer] resolve: Unit
// [Typer] resolve: Unit
// [Typer] resolve: Unit
// [Typer] resolve: Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Int(1)]), Let(("_", Var(None)), App(Var("print_char"), targs=None, [Int(10)]), Let(("_", Var(None)), App(Var("print_int"), targs=None, [App(Var("int_of_float"), targs=None, [Prim(App(Var("energy"), targs=None, [Var("bodies")]), Double(1000000000), Mul, kind=None)])]), Unit)))
// [Typer] resolve: App(Var("loop_i"), targs=None, [Int(1)])
// [Typer] resolve: Int(1)
// [Typer] resolve: Var("loop_i")
// [Typer] resolve: Let(("_", Var(None)), App(Var("print_char"), targs=None, [Int(10)]), Let(("_", Var(None)), App(Var("print_int"), targs=None, [App(Var("int_of_float"), targs=None, [Prim(App(Var("energy"), targs=None, [Var("bodies")]), Double(1000000000), Mul, kind=None)])]), Unit))
// [Typer] resolve: App(Var("print_char"), targs=None, [Int(10)])
// [Typer] resolve: Int(10)
// [Typer] resolve: Var("print_char")
// [Typer] resolve: Let(("_", Var(None)), App(Var("print_int"), targs=None, [App(Var("int_of_float"), targs=None, [Prim(App(Var("energy"), targs=None, [Var("bodies")]), Double(1000000000), Mul, kind=None)])]), Unit)
// [Typer] resolve: App(Var("print_int"), targs=None, [App(Var("int_of_float"), targs=None, [Prim(App(Var("energy"), targs=None, [Var("bodies")]), Double(1000000000), Mul, kind=None)])])
// [Typer] resolve: App(Var("int_of_float"), targs=None, [Prim(App(Var("energy"), targs=None, [Var("bodies")]), Double(1000000000), Mul, kind=None)])
// [Typer] resolve: Prim(App(Var("energy"), targs=None, [Var("bodies")]), Double(1000000000), Mul, kind=None)
// [Typer] resolve: App(Var("energy"), targs=None, [Var("bodies")])
// [Typer] resolve: Var("bodies")
// [Typer] resolve: Var("energy")
// [Typer] resolve: Double(1000000000)
// [Typer] resolve: Var("int_of_float")
// [Typer] resolve: Var("print_int")
// [Typer] resolve: Unit
// [Typer] resolve: Unit
// [Typer] check: Let(("pi", Double), Double(3.141592653589793), Let(("solar_mass", Double), Prim(Prim(Double(4), Var("pi"), Mul, kind=None), Var("pi"), Mul, kind=None), Let(("days_per_year", Double), Double(365.24), LetRec({tyvars: [], name: ("advance", Unit), args: [("bodies", Array[(Double, Double, Double, Double, Double, Double, Double)]), ("dt", Double)], body: Let(("n", Var(None)), Int(5), LetRec({tyvars: [], name: ("loop_i", Var(None)), args: [("i", Int)], body: Let(("_", Var(None)), If(LE(Var("i"), Prim(Var("n"), Int(1), Sub, kind=None)), Let(("b", Var(None)), Get(Var("bodies"), Var("i")), LetTuple([("bx", Var(None)), ("by", Var(None)), ("bz", Var(None)), ("bvx", Var(None)), ("bvy", Var(None)), ("bvz", Var(None)), ("bm", Var(None))], Var("b"), LetRec({tyvars: [], name: ("loop_j", Var(None)), args: [("j", Int)], body: Let(("_", Var(None)), If(LE(Var("j"), Prim(Var("n"), Int(1), Sub, kind=None)), Let(("b2", Var(None)), Get(Var("bodies"), Var("j")), LetTuple([("b2x", Var(None)), ("b2y", Var(None)), ("b2z", Var(None)), ("b2vx", Var(None)), ("b2vy", Var(None)), ("b2vz", Var(None)), ("b2m", Var(None))], Var("b2"), Let(("dx", Var(None)), Prim(Var("bx"), Var("b2x"), Sub, kind=None), Let(("dy", Var(None)), Prim(Var("by"), Var("b2y"), Sub, kind=None), Let(("dz", Var(None)), Prim(Var("bz"), Var("b2z"), Sub, kind=None), Let(("dist2", Var(None)), Prim(Prim(Prim(Var("dx"), Var("dx"), Mul, kind=None), Prim(Var("dy"), Var("dy"), Mul, kind=None), Add, kind=None), Prim(Var("dz"), Var("dz"), Mul, kind=None), Add, kind=None), Let(("mag", Var(None)), Prim(Var("dt"), Prim(Var("dist2"), App(Var("sqrt"), targs=None, [Var("dist2")]), Mul, kind=None), Div, kind=None), Let(("new_b", Var(None)), Tuple([Var("bx"), Var("by"), Var("bz"), Prim(Var("bvx"), Prim(Prim(Var("dx"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Prim(Var("bvy"), Prim(Prim(Var("dy"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Prim(Var("bvz"), Prim(Prim(Var("dz"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Var("bm")]), Let(("_", Var(None)), Put(Var("bodies"), Var("i"), Var("new_b")), Let(("new_b2", Var(None)), Tuple([Var("b2x"), Var("b2y"), Var("b2z"), Prim(Var("b2vx"), Prim(Prim(Var("dx"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Prim(Var("b2vy"), Prim(Prim(Var("dy"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Prim(Var("b2vz"), Prim(Prim(Var("dz"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Var("b2m")]), Let(("_", Var(None)), Put(Var("bodies"), Var("j"), Var("new_b2")), Let(("_", Var(None)), App(Var("loop_j"), targs=None, [Prim(Var("j"), Int(1), Add, kind=None)]), Unit)))))))))))), Unit), Unit)}, Let(("_", Var(None)), App(Var("loop_j"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Unit))))), Unit), Unit)}, Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Int(0)]), LetRec({tyvars: [], name: ("update_axis", Var(None)), args: [("i", Int)], body: Let(("_", Var(None)), If(LE(Var("i"), Prim(Var("n"), Int(1), Sub, kind=None)), Let(("b", Var(None)), Get(Var("bodies"), Var("i")), LetTuple([("bx", Var(None)), ("by", Var(None)), ("bz", Var(None)), ("bvx", Var(None)), ("bvy", Var(None)), ("bvz", Var(None)), ("bm", Var(None))], Var("b"), Let(("new_b", Var(None)), Tuple([Prim(Var("bx"), Prim(Var("dt"), Var("bvx"), Mul, kind=None), Add, kind=None), Prim(Var("by"), Prim(Var("dt"), Var("bvy"), Mul, kind=None), Add, kind=None), Prim(Var("bz"), Prim(Var("dt"), Var("bvz"), Mul, kind=None), Add, kind=None), Var("bvx"), Var("bvy"), Var("bvz"), Var("bm")]), Let(("_", Var(None)), Put(Var("bodies"), Var("i"), Var("new_b")), Let(("_", Var(None)), App(Var("update_axis"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Unit))))), Unit), Unit)}, Let(("_", Var(None)), App(Var("update_axis"), targs=None, [Int(0)]), Unit)))))}, LetRec({tyvars: [], name: ("energy", Double), args: [("bodies", Array[(Double, Double, Double, Double, Double, Double, Double)])], body: Let(("n", Var(None)), Int(5), Let(("e", Var(None)), Array(Int(1), Double(0)), LetRec({tyvars: [], name: ("loop_i", Var(None)), args: [("i", Int)], body: Let(("_", Var(None)), If(LE(Var("i"), Prim(Var("n"), Int(1), Sub, kind=None)), Let(("b", Var(None)), Get(Var("bodies"), Var("i")), LetTuple([("bx", Var(None)), ("by", Var(None)), ("bz", Var(None)), ("bvx", Var(None)), ("bvy", Var(None)), ("bvz", Var(None)), ("bm", Var(None))], Var("b"), Let(("_", Var(None)), Put(Var("e"), Int(0), Prim(Get(Var("e"), Int(0)), Prim(Prim(Double(0.5), Var("bm"), Mul, kind=None), Prim(Prim(Prim(Var("bvx"), Var("bvx"), Mul, kind=None), Prim(Var("bvy"), Var("bvy"), Mul, kind=None), Add, kind=None), Prim(Var("bvz"), Var("bvz"), Mul, kind=None), Add, kind=None), Mul, kind=None), Add, kind=None)), LetRec({tyvars: [], name: ("loop_j", Var(None)), args: [("j", Int)], body: Let(("_", Var(None)), If(LE(Var("j"), Prim(Var("n"), Int(1), Sub, kind=None)), Let(("b2", Var(None)), Get(Var("bodies"), Var("j")), LetTuple([("b2x", Var(None)), ("b2y", Var(None)), ("b2z", Var(None)), ("b2vx", Var(None)), ("b2vy", Var(None)), ("b2vz", Var(None)), ("b2m", Var(None))], Var("b2"), Let(("dx", Var(None)), Prim(Var("bx"), Var("b2x"), Sub, kind=None), Let(("dy", Var(None)), Prim(Var("by"), Var("b2y"), Sub, kind=None), Let(("dz", Var(None)), Prim(Var("bz"), Var("b2z"), Sub, kind=None), Let(("dist2", Var(None)), Prim(Prim(Prim(Var("dx"), Var("dx"), Mul, kind=None), Prim(Var("dy"), Var("dy"), Mul, kind=None), Add, kind=None), Prim(Var("dz"), Var("dz"), Mul, kind=None), Add, kind=None), Let(("_", Var(None)), Put(Var("e"), Int(0), Prim(Get(Var("e"), Int(0)), Prim(Prim(Var("bm"), Var("b2m"), Mul, kind=None), App(Var("sqrt"), targs=None, [Var("dist2")]), Div, kind=None), Sub, kind=None)), Let(("_", Var(None)), App(Var("loop_j"), targs=None, [Prim(Var("j"), Int(1), Add, kind=None)]), Unit)))))))), Unit), Unit)}, Let(("_", Var(None)), App(Var("loop_j"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Unit)))))), Unit), Unit)}, Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Int(0)]), Get(Var("e"), Int(0))))))}, LetRec({tyvars: [], name: ("offset_momentum", Unit), args: [("bodies", Array[(Double, Double, Double, Double, Double, Double, Double)])], body: Let(("n", Var(None)), Int(5), Let(("px", Var(None)), Array(Int(1), Double(0)), Let(("py", Var(None)), Array(Int(1), Double(0)), Let(("pz", Var(None)), Array(Int(1), Double(0)), LetRec({tyvars: [], name: ("loop_i", Var(None)), args: [("i", Int)], body: Let(("_", Var(None)), If(LE(Var("i"), Prim(Var("n"), Int(1), Sub, kind=None)), Let(("b", Var(None)), Get(Var("bodies"), Var("i")), LetTuple([("bx", Var(None)), ("by", Var(None)), ("bz", Var(None)), ("bvx", Var(None)), ("bvy", Var(None)), ("bvz", Var(None)), ("bm", Var(None))], Var("b"), Let(("_", Var(None)), Put(Var("px"), Int(0), Prim(Get(Var("px"), Int(0)), Prim(Var("bvx"), Var("bm"), Mul, kind=None), Add, kind=None)), Let(("_", Var(None)), Put(Var("py"), Int(0), Prim(Get(Var("py"), Int(0)), Prim(Var("bvy"), Var("bm"), Mul, kind=None), Add, kind=None)), Let(("_", Var(None)), Put(Var("pz"), Int(0), Prim(Get(Var("pz"), Int(0)), Prim(Var("bvz"), Var("bm"), Mul, kind=None), Add, kind=None)), Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Unit)))))), Unit), Unit)}, Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Int(0)]), Let(("b", Var(None)), Get(Var("bodies"), Int(0)), LetTuple([("bx", Var(None)), ("by", Var(None)), ("bz", Var(None)), ("bvx", Var(None)), ("bvy", Var(None)), ("bvz", Var(None)), ("bm", Var(None))], Var("b"), Let(("new_b", Var(None)), Tuple([Var("bx"), Var("by"), Var("bz"), Neg(Prim(Get(Var("px"), Int(0)), Var("solar_mass"), Div, kind=None), kind=None), Neg(Prim(Get(Var("py"), Int(0)), Var("solar_mass"), Div, kind=None), kind=None), Neg(Prim(Get(Var("pz"), Int(0)), Var("solar_mass"), Div, kind=None), kind=None), Var("bm")]), Let(("_", Var(None)), Put(Var("bodies"), Int(0), Var("new_b")), Unit))))))))))}, LetRec({tyvars: [], name: ("main", Var(None)), args: [], body: Let(("jupiter", Var(None)), Tuple([Double(4.841431442464721), Neg(Double(1.1603200440274284), kind=None), Neg(Double(0.10362204447112311), kind=None), Prim(Double(0.001660076642744037), Var("days_per_year"), Mul, kind=None), Prim(Double(0.007699011184197404), Var("days_per_year"), Mul, kind=None), Neg(Prim(Double(0.0000690460016972063), Var("days_per_year"), Mul, kind=None), kind=None), Prim(Double(0.0009547919384243266), Var("solar_mass"), Mul, kind=None)]), Let(("saturn", Var(None)), Tuple([Double(8.34336671824458), Double(4.124798564124305), Neg(Double(0.4035234171143214), kind=None), Neg(Prim(Double(0.002767425107268624), Var("days_per_year"), Mul, kind=None), kind=None), Prim(Double(0.004998528012349172), Var("days_per_year"), Mul, kind=None), Prim(Double(0.000023029345528229068), Var("days_per_year"), Mul, kind=None), Prim(Double(0.0002858859806661308), Var("solar_mass"), Mul, kind=None)]), Let(("uranus", Var(None)), Tuple([Double(12.894369562139131), Neg(Double(15.111151401698631), kind=None), Neg(Double(0.22330757889265587), kind=None), Prim(Double(0.002964601375647616), Var("days_per_year"), Mul, kind=None), Prim(Double(0.0023784717395948095), Var("days_per_year"), Mul, kind=None), Neg(Prim(Double(0.000029658956854023756), Var("days_per_year"), Mul, kind=None), kind=None), Prim(Double(0.00004366244043351563), Var("solar_mass"), Mul, kind=None)]), Let(("neptune", Var(None)), Tuple([Double(15.379697114850917), Neg(Double(25.919314609987964), kind=None), Double(0.17925877295037118), Prim(Double(0.0026806777249038932), Var("days_per_year"), Mul, kind=None), Prim(Double(0.001628241700382423), Var("days_per_year"), Mul, kind=None), Neg(Prim(Double(0.00009515922545197159), Var("days_per_year"), Mul, kind=None), kind=None), Prim(Double(0.00005151389020466116), Var("solar_mass"), Mul, kind=None)]), Let(("sun", Var(None)), Tuple([Double(0), Double(0), Double(0), Double(0), Double(0), Double(0), Var("solar_mass")]), Let(("bodies", Var(None)), Array(Int(5), Tuple([Double(0), Double(0), Double(0), Double(0), Double(0), Double(0), Double(0)])), Let(("_", Var(None)), Put(Var("bodies"), Int(0), Var("sun")), Let(("_", Var(None)), Put(Var("bodies"), Int(1), Var("jupiter")), Let(("_", Var(None)), Put(Var("bodies"), Int(2), Var("saturn")), Let(("_", Var(None)), Put(Var("bodies"), Int(3), Var("uranus")), Let(("_", Var(None)), Put(Var("bodies"), Int(4), Var("neptune")), Let(("_", Var(None)), App(Var("offset_momentum"), targs=None, [Var("bodies")]), Let(("_", Var(None)), App(Var("print_int"), targs=None, [App(Var("int_of_float"), targs=None, [Prim(App(Var("energy"), targs=None, [Var("bodies")]), Double(1000000000), Mul, kind=None)])]), Let(("iters", Var(None)), Int(500000), LetRec({tyvars: [], name: ("loop_i", Var(None)), args: [("i", Int)], body: Let(("_", Var(None)), If(LE(Var("i"), Var("iters")), Let(("_", Var(None)), App(Var("advance"), targs=None, [Var("bodies"), Double(0.01)]), Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Unit)), Unit), Unit)}, Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Int(1)]), Let(("_", Var(None)), App(Var("print_char"), targs=None, [Int(10)]), Let(("_", Var(None)), App(Var("print_int"), targs=None, [App(Var("int_of_float"), targs=None, [Prim(App(Var("energy"), targs=None, [Var("bodies")]), Double(1000000000), Mul, kind=None)])]), Unit))))))))))))))))))}, Unit))))))) against Unit
// [Typer] check: Double(3.141592653589793) against Double
// [Typer] check: Let(("solar_mass", Double), Prim(Prim(Double(4), Var("pi"), Mul, kind=None), Var("pi"), Mul, kind=None), Let(("days_per_year", Double), Double(365.24), LetRec({tyvars: [], name: ("advance", Unit), args: [("bodies", Array[(Double, Double, Double, Double, Double, Double, Double)]), ("dt", Double)], body: Let(("n", Var(None)), Int(5), LetRec({tyvars: [], name: ("loop_i", Var(None)), args: [("i", Int)], body: Let(("_", Var(None)), If(LE(Var("i"), Prim(Var("n"), Int(1), Sub, kind=None)), Let(("b", Var(None)), Get(Var("bodies"), Var("i")), LetTuple([("bx", Var(None)), ("by", Var(None)), ("bz", Var(None)), ("bvx", Var(None)), ("bvy", Var(None)), ("bvz", Var(None)), ("bm", Var(None))], Var("b"), LetRec({tyvars: [], name: ("loop_j", Var(None)), args: [("j", Int)], body: Let(("_", Var(None)), If(LE(Var("j"), Prim(Var("n"), Int(1), Sub, kind=None)), Let(("b2", Var(None)), Get(Var("bodies"), Var("j")), LetTuple([("b2x", Var(None)), ("b2y", Var(None)), ("b2z", Var(None)), ("b2vx", Var(None)), ("b2vy", Var(None)), ("b2vz", Var(None)), ("b2m", Var(None))], Var("b2"), Let(("dx", Var(None)), Prim(Var("bx"), Var("b2x"), Sub, kind=None), Let(("dy", Var(None)), Prim(Var("by"), Var("b2y"), Sub, kind=None), Let(("dz", Var(None)), Prim(Var("bz"), Var("b2z"), Sub, kind=None), Let(("dist2", Var(None)), Prim(Prim(Prim(Var("dx"), Var("dx"), Mul, kind=None), Prim(Var("dy"), Var("dy"), Mul, kind=None), Add, kind=None), Prim(Var("dz"), Var("dz"), Mul, kind=None), Add, kind=None), Let(("mag", Var(None)), Prim(Var("dt"), Prim(Var("dist2"), App(Var("sqrt"), targs=None, [Var("dist2")]), Mul, kind=None), Div, kind=None), Let(("new_b", Var(None)), Tuple([Var("bx"), Var("by"), Var("bz"), Prim(Var("bvx"), Prim(Prim(Var("dx"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Prim(Var("bvy"), Prim(Prim(Var("dy"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Prim(Var("bvz"), Prim(Prim(Var("dz"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Var("bm")]), Let(("_", Var(None)), Put(Var("bodies"), Var("i"), Var("new_b")), Let(("new_b2", Var(None)), Tuple([Var("b2x"), Var("b2y"), Var("b2z"), Prim(Var("b2vx"), Prim(Prim(Var("dx"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Prim(Var("b2vy"), Prim(Prim(Var("dy"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Prim(Var("b2vz"), Prim(Prim(Var("dz"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Var("b2m")]), Let(("_", Var(None)), Put(Var("bodies"), Var("j"), Var("new_b2")), Let(("_", Var(None)), App(Var("loop_j"), targs=None, [Prim(Var("j"), Int(1), Add, kind=None)]), Unit)))))))))))), Unit), Unit)}, Let(("_", Var(None)), App(Var("loop_j"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Unit))))), Unit), Unit)}, Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Int(0)]), LetRec({tyvars: [], name: ("update_axis", Var(None)), args: [("i", Int)], body: Let(("_", Var(None)), If(LE(Var("i"), Prim(Var("n"), Int(1), Sub, kind=None)), Let(("b", Var(None)), Get(Var("bodies"), Var("i")), LetTuple([("bx", Var(None)), ("by", Var(None)), ("bz", Var(None)), ("bvx", Var(None)), ("bvy", Var(None)), ("bvz", Var(None)), ("bm", Var(None))], Var("b"), Let(("new_b", Var(None)), Tuple([Prim(Var("bx"), Prim(Var("dt"), Var("bvx"), Mul, kind=None), Add, kind=None), Prim(Var("by"), Prim(Var("dt"), Var("bvy"), Mul, kind=None), Add, kind=None), Prim(Var("bz"), Prim(Var("dt"), Var("bvz"), Mul, kind=None), Add, kind=None), Var("bvx"), Var("bvy"), Var("bvz"), Var("bm")]), Let(("_", Var(None)), Put(Var("bodies"), Var("i"), Var("new_b")), Let(("_", Var(None)), App(Var("update_axis"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Unit))))), Unit), Unit)}, Let(("_", Var(None)), App(Var("update_axis"), targs=None, [Int(0)]), Unit)))))}, LetRec({tyvars: [], name: ("energy", Double), args: [("bodies", Array[(Double, Double, Double, Double, Double, Double, Double)])], body: Let(("n", Var(None)), Int(5), Let(("e", Var(None)), Array(Int(1), Double(0)), LetRec({tyvars: [], name: ("loop_i", Var(None)), args: [("i", Int)], body: Let(("_", Var(None)), If(LE(Var("i"), Prim(Var("n"), Int(1), Sub, kind=None)), Let(("b", Var(None)), Get(Var("bodies"), Var("i")), LetTuple([("bx", Var(None)), ("by", Var(None)), ("bz", Var(None)), ("bvx", Var(None)), ("bvy", Var(None)), ("bvz", Var(None)), ("bm", Var(None))], Var("b"), Let(("_", Var(None)), Put(Var("e"), Int(0), Prim(Get(Var("e"), Int(0)), Prim(Prim(Double(0.5), Var("bm"), Mul, kind=None), Prim(Prim(Prim(Var("bvx"), Var("bvx"), Mul, kind=None), Prim(Var("bvy"), Var("bvy"), Mul, kind=None), Add, kind=None), Prim(Var("bvz"), Var("bvz"), Mul, kind=None), Add, kind=None), Mul, kind=None), Add, kind=None)), LetRec({tyvars: [], name: ("loop_j", Var(None)), args: [("j", Int)], body: Let(("_", Var(None)), If(LE(Var("j"), Prim(Var("n"), Int(1), Sub, kind=None)), Let(("b2", Var(None)), Get(Var("bodies"), Var("j")), LetTuple([("b2x", Var(None)), ("b2y", Var(None)), ("b2z", Var(None)), ("b2vx", Var(None)), ("b2vy", Var(None)), ("b2vz", Var(None)), ("b2m", Var(None))], Var("b2"), Let(("dx", Var(None)), Prim(Var("bx"), Var("b2x"), Sub, kind=None), Let(("dy", Var(None)), Prim(Var("by"), Var("b2y"), Sub, kind=None), Let(("dz", Var(None)), Prim(Var("bz"), Var("b2z"), Sub, kind=None), Let(("dist2", Var(None)), Prim(Prim(Prim(Var("dx"), Var("dx"), Mul, kind=None), Prim(Var("dy"), Var("dy"), Mul, kind=None), Add, kind=None), Prim(Var("dz"), Var("dz"), Mul, kind=None), Add, kind=None), Let(("_", Var(None)), Put(Var("e"), Int(0), Prim(Get(Var("e"), Int(0)), Prim(Prim(Var("bm"), Var("b2m"), Mul, kind=None), App(Var("sqrt"), targs=None, [Var("dist2")]), Div, kind=None), Sub, kind=None)), Let(("_", Var(None)), App(Var("loop_j"), targs=None, [Prim(Var("j"), Int(1), Add, kind=None)]), Unit)))))))), Unit), Unit)}, Let(("_", Var(None)), App(Var("loop_j"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Unit)))))), Unit), Unit)}, Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Int(0)]), Get(Var("e"), Int(0))))))}, LetRec({tyvars: [], name: ("offset_momentum", Unit), args: [("bodies", Array[(Double, Double, Double, Double, Double, Double, Double)])], body: Let(("n", Var(None)), Int(5), Let(("px", Var(None)), Array(Int(1), Double(0)), Let(("py", Var(None)), Array(Int(1), Double(0)), Let(("pz", Var(None)), Array(Int(1), Double(0)), LetRec({tyvars: [], name: ("loop_i", Var(None)), args: [("i", Int)], body: Let(("_", Var(None)), If(LE(Var("i"), Prim(Var("n"), Int(1), Sub, kind=None)), Let(("b", Var(None)), Get(Var("bodies"), Var("i")), LetTuple([("bx", Var(None)), ("by", Var(None)), ("bz", Var(None)), ("bvx", Var(None)), ("bvy", Var(None)), ("bvz", Var(None)), ("bm", Var(None))], Var("b"), Let(("_", Var(None)), Put(Var("px"), Int(0), Prim(Get(Var("px"), Int(0)), Prim(Var("bvx"), Var("bm"), Mul, kind=None), Add, kind=None)), Let(("_", Var(None)), Put(Var("py"), Int(0), Prim(Get(Var("py"), Int(0)), Prim(Var("bvy"), Var("bm"), Mul, kind=None), Add, kind=None)), Let(("_", Var(None)), Put(Var("pz"), Int(0), Prim(Get(Var("pz"), Int(0)), Prim(Var("bvz"), Var("bm"), Mul, kind=None), Add, kind=None)), Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Unit)))))), Unit), Unit)}, Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Int(0)]), Let(("b", Var(None)), Get(Var("bodies"), Int(0)), LetTuple([("bx", Var(None)), ("by", Var(None)), ("bz", Var(None)), ("bvx", Var(None)), ("bvy", Var(None)), ("bvz", Var(None)), ("bm", Var(None))], Var("b"), Let(("new_b", Var(None)), Tuple([Var("bx"), Var("by"), Var("bz"), Neg(Prim(Get(Var("px"), Int(0)), Var("solar_mass"), Div, kind=None), kind=None), Neg(Prim(Get(Var("py"), Int(0)), Var("solar_mass"), Div, kind=None), kind=None), Neg(Prim(Get(Var("pz"), Int(0)), Var("solar_mass"), Div, kind=None), kind=None), Var("bm")]), Let(("_", Var(None)), Put(Var("bodies"), Int(0), Var("new_b")), Unit))))))))))}, LetRec({tyvars: [], name: ("main", Var(None)), args: [], body: Let(("jupiter", Var(None)), Tuple([Double(4.841431442464721), Neg(Double(1.1603200440274284), kind=None), Neg(Double(0.10362204447112311), kind=None), Prim(Double(0.001660076642744037), Var("days_per_year"), Mul, kind=None), Prim(Double(0.007699011184197404), Var("days_per_year"), Mul, kind=None), Neg(Prim(Double(0.0000690460016972063), Var("days_per_year"), Mul, kind=None), kind=None), Prim(Double(0.0009547919384243266), Var("solar_mass"), Mul, kind=None)]), Let(("saturn", Var(None)), Tuple([Double(8.34336671824458), Double(4.124798564124305), Neg(Double(0.4035234171143214), kind=None), Neg(Prim(Double(0.002767425107268624), Var("days_per_year"), Mul, kind=None), kind=None), Prim(Double(0.004998528012349172), Var("days_per_year"), Mul, kind=None), Prim(Double(0.000023029345528229068), Var("days_per_year"), Mul, kind=None), Prim(Double(0.0002858859806661308), Var("solar_mass"), Mul, kind=None)]), Let(("uranus", Var(None)), Tuple([Double(12.894369562139131), Neg(Double(15.111151401698631), kind=None), Neg(Double(0.22330757889265587), kind=None), Prim(Double(0.002964601375647616), Var("days_per_year"), Mul, kind=None), Prim(Double(0.0023784717395948095), Var("days_per_year"), Mul, kind=None), Neg(Prim(Double(0.000029658956854023756), Var("days_per_year"), Mul, kind=None), kind=None), Prim(Double(0.00004366244043351563), Var("solar_mass"), Mul, kind=None)]), Let(("neptune", Var(None)), Tuple([Double(15.379697114850917), Neg(Double(25.919314609987964), kind=None), Double(0.17925877295037118), Prim(Double(0.0026806777249038932), Var("days_per_year"), Mul, kind=None), Prim(Double(0.001628241700382423), Var("days_per_year"), Mul, kind=None), Neg(Prim(Double(0.00009515922545197159), Var("days_per_year"), Mul, kind=None), kind=None), Prim(Double(0.00005151389020466116), Var("solar_mass"), Mul, kind=None)]), Let(("sun", Var(None)), Tuple([Double(0), Double(0), Double(0), Double(0), Double(0), Double(0), Var("solar_mass")]), Let(("bodies", Var(None)), Array(Int(5), Tuple([Double(0), Double(0), Double(0), Double(0), Double(0), Double(0), Double(0)])), Let(("_", Var(None)), Put(Var("bodies"), Int(0), Var("sun")), Let(("_", Var(None)), Put(Var("bodies"), Int(1), Var("jupiter")), Let(("_", Var(None)), Put(Var("bodies"), Int(2), Var("saturn")), Let(("_", Var(None)), Put(Var("bodies"), Int(3), Var("uranus")), Let(("_", Var(None)), Put(Var("bodies"), Int(4), Var("neptune")), Let(("_", Var(None)), App(Var("offset_momentum"), targs=None, [Var("bodies")]), Let(("_", Var(None)), App(Var("print_int"), targs=None, [App(Var("int_of_float"), targs=None, [Prim(App(Var("energy"), targs=None, [Var("bodies")]), Double(1000000000), Mul, kind=None)])]), Let(("iters", Var(None)), Int(500000), LetRec({tyvars: [], name: ("loop_i", Var(None)), args: [("i", Int)], body: Let(("_", Var(None)), If(LE(Var("i"), Var("iters")), Let(("_", Var(None)), App(Var("advance"), targs=None, [Var("bodies"), Double(0.01)]), Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Unit)), Unit), Unit)}, Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Int(1)]), Let(("_", Var(None)), App(Var("print_char"), targs=None, [Int(10)]), Let(("_", Var(None)), App(Var("print_int"), targs=None, [App(Var("int_of_float"), targs=None, [Prim(App(Var("energy"), targs=None, [Var("bodies")]), Double(1000000000), Mul, kind=None)])]), Unit))))))))))))))))))}, Unit)))))) against Unit
// [Typer] check: Prim(Prim(Double(4), Var("pi"), Mul, kind=None), Var("pi"), Mul, kind=None) against Double
// [Typer] check: Prim(Double(4), Var("pi"), Mul, kind=None) against Double
// [Typer] check: Double(4) against Double
// [Typer] check: Var("pi") against Double
// [Typer] inst: TypeScheme(([], Double))
// [Typer] inst result: Double
// [Typer] unify: Double and Double
// [Typer] check: Var("pi") against Double
// [Typer] inst: TypeScheme(([], Double))
// [Typer] inst result: Double
// [Typer] unify: Double and Double
// [Typer] check: Let(("days_per_year", Double), Double(365.24), LetRec({tyvars: [], name: ("advance", Unit), args: [("bodies", Array[(Double, Double, Double, Double, Double, Double, Double)]), ("dt", Double)], body: Let(("n", Var(None)), Int(5), LetRec({tyvars: [], name: ("loop_i", Var(None)), args: [("i", Int)], body: Let(("_", Var(None)), If(LE(Var("i"), Prim(Var("n"), Int(1), Sub, kind=None)), Let(("b", Var(None)), Get(Var("bodies"), Var("i")), LetTuple([("bx", Var(None)), ("by", Var(None)), ("bz", Var(None)), ("bvx", Var(None)), ("bvy", Var(None)), ("bvz", Var(None)), ("bm", Var(None))], Var("b"), LetRec({tyvars: [], name: ("loop_j", Var(None)), args: [("j", Int)], body: Let(("_", Var(None)), If(LE(Var("j"), Prim(Var("n"), Int(1), Sub, kind=None)), Let(("b2", Var(None)), Get(Var("bodies"), Var("j")), LetTuple([("b2x", Var(None)), ("b2y", Var(None)), ("b2z", Var(None)), ("b2vx", Var(None)), ("b2vy", Var(None)), ("b2vz", Var(None)), ("b2m", Var(None))], Var("b2"), Let(("dx", Var(None)), Prim(Var("bx"), Var("b2x"), Sub, kind=None), Let(("dy", Var(None)), Prim(Var("by"), Var("b2y"), Sub, kind=None), Let(("dz", Var(None)), Prim(Var("bz"), Var("b2z"), Sub, kind=None), Let(("dist2", Var(None)), Prim(Prim(Prim(Var("dx"), Var("dx"), Mul, kind=None), Prim(Var("dy"), Var("dy"), Mul, kind=None), Add, kind=None), Prim(Var("dz"), Var("dz"), Mul, kind=None), Add, kind=None), Let(("mag", Var(None)), Prim(Var("dt"), Prim(Var("dist2"), App(Var("sqrt"), targs=None, [Var("dist2")]), Mul, kind=None), Div, kind=None), Let(("new_b", Var(None)), Tuple([Var("bx"), Var("by"), Var("bz"), Prim(Var("bvx"), Prim(Prim(Var("dx"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Prim(Var("bvy"), Prim(Prim(Var("dy"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Prim(Var("bvz"), Prim(Prim(Var("dz"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Var("bm")]), Let(("_", Var(None)), Put(Var("bodies"), Var("i"), Var("new_b")), Let(("new_b2", Var(None)), Tuple([Var("b2x"), Var("b2y"), Var("b2z"), Prim(Var("b2vx"), Prim(Prim(Var("dx"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Prim(Var("b2vy"), Prim(Prim(Var("dy"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Prim(Var("b2vz"), Prim(Prim(Var("dz"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Var("b2m")]), Let(("_", Var(None)), Put(Var("bodies"), Var("j"), Var("new_b2")), Let(("_", Var(None)), App(Var("loop_j"), targs=None, [Prim(Var("j"), Int(1), Add, kind=None)]), Unit)))))))))))), Unit), Unit)}, Let(("_", Var(None)), App(Var("loop_j"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Unit))))), Unit), Unit)}, Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Int(0)]), LetRec({tyvars: [], name: ("update_axis", Var(None)), args: [("i", Int)], body: Let(("_", Var(None)), If(LE(Var("i"), Prim(Var("n"), Int(1), Sub, kind=None)), Let(("b", Var(None)), Get(Var("bodies"), Var("i")), LetTuple([("bx", Var(None)), ("by", Var(None)), ("bz", Var(None)), ("bvx", Var(None)), ("bvy", Var(None)), ("bvz", Var(None)), ("bm", Var(None))], Var("b"), Let(("new_b", Var(None)), Tuple([Prim(Var("bx"), Prim(Var("dt"), Var("bvx"), Mul, kind=None), Add, kind=None), Prim(Var("by"), Prim(Var("dt"), Var("bvy"), Mul, kind=None), Add, kind=None), Prim(Var("bz"), Prim(Var("dt"), Var("bvz"), Mul, kind=None), Add, kind=None), Var("bvx"), Var("bvy"), Var("bvz"), Var("bm")]), Let(("_", Var(None)), Put(Var("bodies"), Var("i"), Var("new_b")), Let(("_", Var(None)), App(Var("update_axis"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Unit))))), Unit), Unit)}, Let(("_", Var(None)), App(Var("update_axis"), targs=None, [Int(0)]), Unit)))))}, LetRec({tyvars: [], name: ("energy", Double), args: [("bodies", Array[(Double, Double, Double, Double, Double, Double, Double)])], body: Let(("n", Var(None)), Int(5), Let(("e", Var(None)), Array(Int(1), Double(0)), LetRec({tyvars: [], name: ("loop_i", Var(None)), args: [("i", Int)], body: Let(("_", Var(None)), If(LE(Var("i"), Prim(Var("n"), Int(1), Sub, kind=None)), Let(("b", Var(None)), Get(Var("bodies"), Var("i")), LetTuple([("bx", Var(None)), ("by", Var(None)), ("bz", Var(None)), ("bvx", Var(None)), ("bvy", Var(None)), ("bvz", Var(None)), ("bm", Var(None))], Var("b"), Let(("_", Var(None)), Put(Var("e"), Int(0), Prim(Get(Var("e"), Int(0)), Prim(Prim(Double(0.5), Var("bm"), Mul, kind=None), Prim(Prim(Prim(Var("bvx"), Var("bvx"), Mul, kind=None), Prim(Var("bvy"), Var("bvy"), Mul, kind=None), Add, kind=None), Prim(Var("bvz"), Var("bvz"), Mul, kind=None), Add, kind=None), Mul, kind=None), Add, kind=None)), LetRec({tyvars: [], name: ("loop_j", Var(None)), args: [("j", Int)], body: Let(("_", Var(None)), If(LE(Var("j"), Prim(Var("n"), Int(1), Sub, kind=None)), Let(("b2", Var(None)), Get(Var("bodies"), Var("j")), LetTuple([("b2x", Var(None)), ("b2y", Var(None)), ("b2z", Var(None)), ("b2vx", Var(None)), ("b2vy", Var(None)), ("b2vz", Var(None)), ("b2m", Var(None))], Var("b2"), Let(("dx", Var(None)), Prim(Var("bx"), Var("b2x"), Sub, kind=None), Let(("dy", Var(None)), Prim(Var("by"), Var("b2y"), Sub, kind=None), Let(("dz", Var(None)), Prim(Var("bz"), Var("b2z"), Sub, kind=None), Let(("dist2", Var(None)), Prim(Prim(Prim(Var("dx"), Var("dx"), Mul, kind=None), Prim(Var("dy"), Var("dy"), Mul, kind=None), Add, kind=None), Prim(Var("dz"), Var("dz"), Mul, kind=None), Add, kind=None), Let(("_", Var(None)), Put(Var("e"), Int(0), Prim(Get(Var("e"), Int(0)), Prim(Prim(Var("bm"), Var("b2m"), Mul, kind=None), App(Var("sqrt"), targs=None, [Var("dist2")]), Div, kind=None), Sub, kind=None)), Let(("_", Var(None)), App(Var("loop_j"), targs=None, [Prim(Var("j"), Int(1), Add, kind=None)]), Unit)))))))), Unit), Unit)}, Let(("_", Var(None)), App(Var("loop_j"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Unit)))))), Unit), Unit)}, Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Int(0)]), Get(Var("e"), Int(0))))))}, LetRec({tyvars: [], name: ("offset_momentum", Unit), args: [("bodies", Array[(Double, Double, Double, Double, Double, Double, Double)])], body: Let(("n", Var(None)), Int(5), Let(("px", Var(None)), Array(Int(1), Double(0)), Let(("py", Var(None)), Array(Int(1), Double(0)), Let(("pz", Var(None)), Array(Int(1), Double(0)), LetRec({tyvars: [], name: ("loop_i", Var(None)), args: [("i", Int)], body: Let(("_", Var(None)), If(LE(Var("i"), Prim(Var("n"), Int(1), Sub, kind=None)), Let(("b", Var(None)), Get(Var("bodies"), Var("i")), LetTuple([("bx", Var(None)), ("by", Var(None)), ("bz", Var(None)), ("bvx", Var(None)), ("bvy", Var(None)), ("bvz", Var(None)), ("bm", Var(None))], Var("b"), Let(("_", Var(None)), Put(Var("px"), Int(0), Prim(Get(Var("px"), Int(0)), Prim(Var("bvx"), Var("bm"), Mul, kind=None), Add, kind=None)), Let(("_", Var(None)), Put(Var("py"), Int(0), Prim(Get(Var("py"), Int(0)), Prim(Var("bvy"), Var("bm"), Mul, kind=None), Add, kind=None)), Let(("_", Var(None)), Put(Var("pz"), Int(0), Prim(Get(Var("pz"), Int(0)), Prim(Var("bvz"), Var("bm"), Mul, kind=None), Add, kind=None)), Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Unit)))))), Unit), Unit)}, Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Int(0)]), Let(("b", Var(None)), Get(Var("bodies"), Int(0)), LetTuple([("bx", Var(None)), ("by", Var(None)), ("bz", Var(None)), ("bvx", Var(None)), ("bvy", Var(None)), ("bvz", Var(None)), ("bm", Var(None))], Var("b"), Let(("new_b", Var(None)), Tuple([Var("bx"), Var("by"), Var("bz"), Neg(Prim(Get(Var("px"), Int(0)), Var("solar_mass"), Div, kind=None), kind=None), Neg(Prim(Get(Var("py"), Int(0)), Var("solar_mass"), Div, kind=None), kind=None), Neg(Prim(Get(Var("pz"), Int(0)), Var("solar_mass"), Div, kind=None), kind=None), Var("bm")]), Let(("_", Var(None)), Put(Var("bodies"), Int(0), Var("new_b")), Unit))))))))))}, LetRec({tyvars: [], name: ("main", Var(None)), args: [], body: Let(("jupiter", Var(None)), Tuple([Double(4.841431442464721), Neg(Double(1.1603200440274284), kind=None), Neg(Double(0.10362204447112311), kind=None), Prim(Double(0.001660076642744037), Var("days_per_year"), Mul, kind=None), Prim(Double(0.007699011184197404), Var("days_per_year"), Mul, kind=None), Neg(Prim(Double(0.0000690460016972063), Var("days_per_year"), Mul, kind=None), kind=None), Prim(Double(0.0009547919384243266), Var("solar_mass"), Mul, kind=None)]), Let(("saturn", Var(None)), Tuple([Double(8.34336671824458), Double(4.124798564124305), Neg(Double(0.4035234171143214), kind=None), Neg(Prim(Double(0.002767425107268624), Var("days_per_year"), Mul, kind=None), kind=None), Prim(Double(0.004998528012349172), Var("days_per_year"), Mul, kind=None), Prim(Double(0.000023029345528229068), Var("days_per_year"), Mul, kind=None), Prim(Double(0.0002858859806661308), Var("solar_mass"), Mul, kind=None)]), Let(("uranus", Var(None)), Tuple([Double(12.894369562139131), Neg(Double(15.111151401698631), kind=None), Neg(Double(0.22330757889265587), kind=None), Prim(Double(0.002964601375647616), Var("days_per_year"), Mul, kind=None), Prim(Double(0.0023784717395948095), Var("days_per_year"), Mul, kind=None), Neg(Prim(Double(0.000029658956854023756), Var("days_per_year"), Mul, kind=None), kind=None), Prim(Double(0.00004366244043351563), Var("solar_mass"), Mul, kind=None)]), Let(("neptune", Var(None)), Tuple([Double(15.379697114850917), Neg(Double(25.919314609987964), kind=None), Double(0.17925877295037118), Prim(Double(0.0026806777249038932), Var("days_per_year"), Mul, kind=None), Prim(Double(0.001628241700382423), Var("days_per_year"), Mul, kind=None), Neg(Prim(Double(0.00009515922545197159), Var("days_per_year"), Mul, kind=None), kind=None), Prim(Double(0.00005151389020466116), Var("solar_mass"), Mul, kind=None)]), Let(("sun", Var(None)), Tuple([Double(0), Double(0), Double(0), Double(0), Double(0), Double(0), Var("solar_mass")]), Let(("bodies", Var(None)), Array(Int(5), Tuple([Double(0), Double(0), Double(0), Double(0), Double(0), Double(0), Double(0)])), Let(("_", Var(None)), Put(Var("bodies"), Int(0), Var("sun")), Let(("_", Var(None)), Put(Var("bodies"), Int(1), Var("jupiter")), Let(("_", Var(None)), Put(Var("bodies"), Int(2), Var("saturn")), Let(("_", Var(None)), Put(Var("bodies"), Int(3), Var("uranus")), Let(("_", Var(None)), Put(Var("bodies"), Int(4), Var("neptune")), Let(("_", Var(None)), App(Var("offset_momentum"), targs=None, [Var("bodies")]), Let(("_", Var(None)), App(Var("print_int"), targs=None, [App(Var("int_of_float"), targs=None, [Prim(App(Var("energy"), targs=None, [Var("bodies")]), Double(1000000000), Mul, kind=None)])]), Let(("iters", Var(None)), Int(500000), LetRec({tyvars: [], name: ("loop_i", Var(None)), args: [("i", Int)], body: Let(("_", Var(None)), If(LE(Var("i"), Var("iters")), Let(("_", Var(None)), App(Var("advance"), targs=None, [Var("bodies"), Double(0.01)]), Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Unit)), Unit), Unit)}, Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Int(1)]), Let(("_", Var(None)), App(Var("print_char"), targs=None, [Int(10)]), Let(("_", Var(None)), App(Var("print_int"), targs=None, [App(Var("int_of_float"), targs=None, [Prim(App(Var("energy"), targs=None, [Var("bodies")]), Double(1000000000), Mul, kind=None)])]), Unit))))))))))))))))))}, Unit))))) against Unit
// [Typer] check: Double(365.24) against Double
// [Typer] check: LetRec({tyvars: [], name: ("advance", Unit), args: [("bodies", Array[(Double, Double, Double, Double, Double, Double, Double)]), ("dt", Double)], body: Let(("n", Var(None)), Int(5), LetRec({tyvars: [], name: ("loop_i", Var(None)), args: [("i", Int)], body: Let(("_", Var(None)), If(LE(Var("i"), Prim(Var("n"), Int(1), Sub, kind=None)), Let(("b", Var(None)), Get(Var("bodies"), Var("i")), LetTuple([("bx", Var(None)), ("by", Var(None)), ("bz", Var(None)), ("bvx", Var(None)), ("bvy", Var(None)), ("bvz", Var(None)), ("bm", Var(None))], Var("b"), LetRec({tyvars: [], name: ("loop_j", Var(None)), args: [("j", Int)], body: Let(("_", Var(None)), If(LE(Var("j"), Prim(Var("n"), Int(1), Sub, kind=None)), Let(("b2", Var(None)), Get(Var("bodies"), Var("j")), LetTuple([("b2x", Var(None)), ("b2y", Var(None)), ("b2z", Var(None)), ("b2vx", Var(None)), ("b2vy", Var(None)), ("b2vz", Var(None)), ("b2m", Var(None))], Var("b2"), Let(("dx", Var(None)), Prim(Var("bx"), Var("b2x"), Sub, kind=None), Let(("dy", Var(None)), Prim(Var("by"), Var("b2y"), Sub, kind=None), Let(("dz", Var(None)), Prim(Var("bz"), Var("b2z"), Sub, kind=None), Let(("dist2", Var(None)), Prim(Prim(Prim(Var("dx"), Var("dx"), Mul, kind=None), Prim(Var("dy"), Var("dy"), Mul, kind=None), Add, kind=None), Prim(Var("dz"), Var("dz"), Mul, kind=None), Add, kind=None), Let(("mag", Var(None)), Prim(Var("dt"), Prim(Var("dist2"), App(Var("sqrt"), targs=None, [Var("dist2")]), Mul, kind=None), Div, kind=None), Let(("new_b", Var(None)), Tuple([Var("bx"), Var("by"), Var("bz"), Prim(Var("bvx"), Prim(Prim(Var("dx"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Prim(Var("bvy"), Prim(Prim(Var("dy"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Prim(Var("bvz"), Prim(Prim(Var("dz"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Var("bm")]), Let(("_", Var(None)), Put(Var("bodies"), Var("i"), Var("new_b")), Let(("new_b2", Var(None)), Tuple([Var("b2x"), Var("b2y"), Var("b2z"), Prim(Var("b2vx"), Prim(Prim(Var("dx"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Prim(Var("b2vy"), Prim(Prim(Var("dy"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Prim(Var("b2vz"), Prim(Prim(Var("dz"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Var("b2m")]), Let(("_", Var(None)), Put(Var("bodies"), Var("j"), Var("new_b2")), Let(("_", Var(None)), App(Var("loop_j"), targs=None, [Prim(Var("j"), Int(1), Add, kind=None)]), Unit)))))))))))), Unit), Unit)}, Let(("_", Var(None)), App(Var("loop_j"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Unit))))), Unit), Unit)}, Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Int(0)]), LetRec({tyvars: [], name: ("update_axis", Var(None)), args: [("i", Int)], body: Let(("_", Var(None)), If(LE(Var("i"), Prim(Var("n"), Int(1), Sub, kind=None)), Let(("b", Var(None)), Get(Var("bodies"), Var("i")), LetTuple([("bx", Var(None)), ("by", Var(None)), ("bz", Var(None)), ("bvx", Var(None)), ("bvy", Var(None)), ("bvz", Var(None)), ("bm", Var(None))], Var("b"), Let(("new_b", Var(None)), Tuple([Prim(Var("bx"), Prim(Var("dt"), Var("bvx"), Mul, kind=None), Add, kind=None), Prim(Var("by"), Prim(Var("dt"), Var("bvy"), Mul, kind=None), Add, kind=None), Prim(Var("bz"), Prim(Var("dt"), Var("bvz"), Mul, kind=None), Add, kind=None), Var("bvx"), Var("bvy"), Var("bvz"), Var("bm")]), Let(("_", Var(None)), Put(Var("bodies"), Var("i"), Var("new_b")), Let(("_", Var(None)), App(Var("update_axis"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Unit))))), Unit), Unit)}, Let(("_", Var(None)), App(Var("update_axis"), targs=None, [Int(0)]), Unit)))))}, LetRec({tyvars: [], name: ("energy", Double), args: [("bodies", Array[(Double, Double, Double, Double, Double, Double, Double)])], body: Let(("n", Var(None)), Int(5), Let(("e", Var(None)), Array(Int(1), Double(0)), LetRec({tyvars: [], name: ("loop_i", Var(None)), args: [("i", Int)], body: Let(("_", Var(None)), If(LE(Var("i"), Prim(Var("n"), Int(1), Sub, kind=None)), Let(("b", Var(None)), Get(Var("bodies"), Var("i")), LetTuple([("bx", Var(None)), ("by", Var(None)), ("bz", Var(None)), ("bvx", Var(None)), ("bvy", Var(None)), ("bvz", Var(None)), ("bm", Var(None))], Var("b"), Let(("_", Var(None)), Put(Var("e"), Int(0), Prim(Get(Var("e"), Int(0)), Prim(Prim(Double(0.5), Var("bm"), Mul, kind=None), Prim(Prim(Prim(Var("bvx"), Var("bvx"), Mul, kind=None), Prim(Var("bvy"), Var("bvy"), Mul, kind=None), Add, kind=None), Prim(Var("bvz"), Var("bvz"), Mul, kind=None), Add, kind=None), Mul, kind=None), Add, kind=None)), LetRec({tyvars: [], name: ("loop_j", Var(None)), args: [("j", Int)], body: Let(("_", Var(None)), If(LE(Var("j"), Prim(Var("n"), Int(1), Sub, kind=None)), Let(("b2", Var(None)), Get(Var("bodies"), Var("j")), LetTuple([("b2x", Var(None)), ("b2y", Var(None)), ("b2z", Var(None)), ("b2vx", Var(None)), ("b2vy", Var(None)), ("b2vz", Var(None)), ("b2m", Var(None))], Var("b2"), Let(("dx", Var(None)), Prim(Var("bx"), Var("b2x"), Sub, kind=None), Let(("dy", Var(None)), Prim(Var("by"), Var("b2y"), Sub, kind=None), Let(("dz", Var(None)), Prim(Var("bz"), Var("b2z"), Sub, kind=None), Let(("dist2", Var(None)), Prim(Prim(Prim(Var("dx"), Var("dx"), Mul, kind=None), Prim(Var("dy"), Var("dy"), Mul, kind=None), Add, kind=None), Prim(Var("dz"), Var("dz"), Mul, kind=None), Add, kind=None), Let(("_", Var(None)), Put(Var("e"), Int(0), Prim(Get(Var("e"), Int(0)), Prim(Prim(Var("bm"), Var("b2m"), Mul, kind=None), App(Var("sqrt"), targs=None, [Var("dist2")]), Div, kind=None), Sub, kind=None)), Let(("_", Var(None)), App(Var("loop_j"), targs=None, [Prim(Var("j"), Int(1), Add, kind=None)]), Unit)))))))), Unit), Unit)}, Let(("_", Var(None)), App(Var("loop_j"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Unit)))))), Unit), Unit)}, Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Int(0)]), Get(Var("e"), Int(0))))))}, LetRec({tyvars: [], name: ("offset_momentum", Unit), args: [("bodies", Array[(Double, Double, Double, Double, Double, Double, Double)])], body: Let(("n", Var(None)), Int(5), Let(("px", Var(None)), Array(Int(1), Double(0)), Let(("py", Var(None)), Array(Int(1), Double(0)), Let(("pz", Var(None)), Array(Int(1), Double(0)), LetRec({tyvars: [], name: ("loop_i", Var(None)), args: [("i", Int)], body: Let(("_", Var(None)), If(LE(Var("i"), Prim(Var("n"), Int(1), Sub, kind=None)), Let(("b", Var(None)), Get(Var("bodies"), Var("i")), LetTuple([("bx", Var(None)), ("by", Var(None)), ("bz", Var(None)), ("bvx", Var(None)), ("bvy", Var(None)), ("bvz", Var(None)), ("bm", Var(None))], Var("b"), Let(("_", Var(None)), Put(Var("px"), Int(0), Prim(Get(Var("px"), Int(0)), Prim(Var("bvx"), Var("bm"), Mul, kind=None), Add, kind=None)), Let(("_", Var(None)), Put(Var("py"), Int(0), Prim(Get(Var("py"), Int(0)), Prim(Var("bvy"), Var("bm"), Mul, kind=None), Add, kind=None)), Let(("_", Var(None)), Put(Var("pz"), Int(0), Prim(Get(Var("pz"), Int(0)), Prim(Var("bvz"), Var("bm"), Mul, kind=None), Add, kind=None)), Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Unit)))))), Unit), Unit)}, Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Int(0)]), Let(("b", Var(None)), Get(Var("bodies"), Int(0)), LetTuple([("bx", Var(None)), ("by", Var(None)), ("bz", Var(None)), ("bvx", Var(None)), ("bvy", Var(None)), ("bvz", Var(None)), ("bm", Var(None))], Var("b"), Let(("new_b", Var(None)), Tuple([Var("bx"), Var("by"), Var("bz"), Neg(Prim(Get(Var("px"), Int(0)), Var("solar_mass"), Div, kind=None), kind=None), Neg(Prim(Get(Var("py"), Int(0)), Var("solar_mass"), Div, kind=None), kind=None), Neg(Prim(Get(Var("pz"), Int(0)), Var("solar_mass"), Div, kind=None), kind=None), Var("bm")]), Let(("_", Var(None)), Put(Var("bodies"), Int(0), Var("new_b")), Unit))))))))))}, LetRec({tyvars: [], name: ("main", Var(None)), args: [], body: Let(("jupiter", Var(None)), Tuple([Double(4.841431442464721), Neg(Double(1.1603200440274284), kind=None), Neg(Double(0.10362204447112311), kind=None), Prim(Double(0.001660076642744037), Var("days_per_year"), Mul, kind=None), Prim(Double(0.007699011184197404), Var("days_per_year"), Mul, kind=None), Neg(Prim(Double(0.0000690460016972063), Var("days_per_year"), Mul, kind=None), kind=None), Prim(Double(0.0009547919384243266), Var("solar_mass"), Mul, kind=None)]), Let(("saturn", Var(None)), Tuple([Double(8.34336671824458), Double(4.124798564124305), Neg(Double(0.4035234171143214), kind=None), Neg(Prim(Double(0.002767425107268624), Var("days_per_year"), Mul, kind=None), kind=None), Prim(Double(0.004998528012349172), Var("days_per_year"), Mul, kind=None), Prim(Double(0.000023029345528229068), Var("days_per_year"), Mul, kind=None), Prim(Double(0.0002858859806661308), Var("solar_mass"), Mul, kind=None)]), Let(("uranus", Var(None)), Tuple([Double(12.894369562139131), Neg(Double(15.111151401698631), kind=None), Neg(Double(0.22330757889265587), kind=None), Prim(Double(0.002964601375647616), Var("days_per_year"), Mul, kind=None), Prim(Double(0.0023784717395948095), Var("days_per_year"), Mul, kind=None), Neg(Prim(Double(0.000029658956854023756), Var("days_per_year"), Mul, kind=None), kind=None), Prim(Double(0.00004366244043351563), Var("solar_mass"), Mul, kind=None)]), Let(("neptune", Var(None)), Tuple([Double(15.379697114850917), Neg(Double(25.919314609987964), kind=None), Double(0.17925877295037118), Prim(Double(0.0026806777249038932), Var("days_per_year"), Mul, kind=None), Prim(Double(0.001628241700382423), Var("days_per_year"), Mul, kind=None), Neg(Prim(Double(0.00009515922545197159), Var("days_per_year"), Mul, kind=None), kind=None), Prim(Double(0.00005151389020466116), Var("solar_mass"), Mul, kind=None)]), Let(("sun", Var(None)), Tuple([Double(0), Double(0), Double(0), Double(0), Double(0), Double(0), Var("solar_mass")]), Let(("bodies", Var(None)), Array(Int(5), Tuple([Double(0), Double(0), Double(0), Double(0), Double(0), Double(0), Double(0)])), Let(("_", Var(None)), Put(Var("bodies"), Int(0), Var("sun")), Let(("_", Var(None)), Put(Var("bodies"), Int(1), Var("jupiter")), Let(("_", Var(None)), Put(Var("bodies"), Int(2), Var("saturn")), Let(("_", Var(None)), Put(Var("bodies"), Int(3), Var("uranus")), Let(("_", Var(None)), Put(Var("bodies"), Int(4), Var("neptune")), Let(("_", Var(None)), App(Var("offset_momentum"), targs=None, [Var("bodies")]), Let(("_", Var(None)), App(Var("print_int"), targs=None, [App(Var("int_of_float"), targs=None, [Prim(App(Var("energy"), targs=None, [Var("bodies")]), Double(1000000000), Mul, kind=None)])]), Let(("iters", Var(None)), Int(500000), LetRec({tyvars: [], name: ("loop_i", Var(None)), args: [("i", Int)], body: Let(("_", Var(None)), If(LE(Var("i"), Var("iters")), Let(("_", Var(None)), App(Var("advance"), targs=None, [Var("bodies"), Double(0.01)]), Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Unit)), Unit), Unit)}, Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Int(1)]), Let(("_", Var(None)), App(Var("print_char"), targs=None, [Int(10)]), Let(("_", Var(None)), App(Var("print_int"), targs=None, [App(Var("int_of_float"), targs=None, [Prim(App(Var("energy"), targs=None, [Var("bodies")]), Double(1000000000), Mul, kind=None)])]), Unit))))))))))))))))))}, Unit)))) against Unit
// [Typer] typevars: []
// [Typer] check: Let(("n", Var(None)), Int(5), LetRec({tyvars: [], name: ("loop_i", Var(None)), args: [("i", Int)], body: Let(("_", Var(None)), If(LE(Var("i"), Prim(Var("n"), Int(1), Sub, kind=None)), Let(("b", Var(None)), Get(Var("bodies"), Var("i")), LetTuple([("bx", Var(None)), ("by", Var(None)), ("bz", Var(None)), ("bvx", Var(None)), ("bvy", Var(None)), ("bvz", Var(None)), ("bm", Var(None))], Var("b"), LetRec({tyvars: [], name: ("loop_j", Var(None)), args: [("j", Int)], body: Let(("_", Var(None)), If(LE(Var("j"), Prim(Var("n"), Int(1), Sub, kind=None)), Let(("b2", Var(None)), Get(Var("bodies"), Var("j")), LetTuple([("b2x", Var(None)), ("b2y", Var(None)), ("b2z", Var(None)), ("b2vx", Var(None)), ("b2vy", Var(None)), ("b2vz", Var(None)), ("b2m", Var(None))], Var("b2"), Let(("dx", Var(None)), Prim(Var("bx"), Var("b2x"), Sub, kind=None), Let(("dy", Var(None)), Prim(Var("by"), Var("b2y"), Sub, kind=None), Let(("dz", Var(None)), Prim(Var("bz"), Var("b2z"), Sub, kind=None), Let(("dist2", Var(None)), Prim(Prim(Prim(Var("dx"), Var("dx"), Mul, kind=None), Prim(Var("dy"), Var("dy"), Mul, kind=None), Add, kind=None), Prim(Var("dz"), Var("dz"), Mul, kind=None), Add, kind=None), Let(("mag", Var(None)), Prim(Var("dt"), Prim(Var("dist2"), App(Var("sqrt"), targs=None, [Var("dist2")]), Mul, kind=None), Div, kind=None), Let(("new_b", Var(None)), Tuple([Var("bx"), Var("by"), Var("bz"), Prim(Var("bvx"), Prim(Prim(Var("dx"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Prim(Var("bvy"), Prim(Prim(Var("dy"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Prim(Var("bvz"), Prim(Prim(Var("dz"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Var("bm")]), Let(("_", Var(None)), Put(Var("bodies"), Var("i"), Var("new_b")), Let(("new_b2", Var(None)), Tuple([Var("b2x"), Var("b2y"), Var("b2z"), Prim(Var("b2vx"), Prim(Prim(Var("dx"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Prim(Var("b2vy"), Prim(Prim(Var("dy"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Prim(Var("b2vz"), Prim(Prim(Var("dz"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Var("b2m")]), Let(("_", Var(None)), Put(Var("bodies"), Var("j"), Var("new_b2")), Let(("_", Var(None)), App(Var("loop_j"), targs=None, [Prim(Var("j"), Int(1), Add, kind=None)]), Unit)))))))))))), Unit), Unit)}, Let(("_", Var(None)), App(Var("loop_j"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Unit))))), Unit), Unit)}, Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Int(0)]), LetRec({tyvars: [], name: ("update_axis", Var(None)), args: [("i", Int)], body: Let(("_", Var(None)), If(LE(Var("i"), Prim(Var("n"), Int(1), Sub, kind=None)), Let(("b", Var(None)), Get(Var("bodies"), Var("i")), LetTuple([("bx", Var(None)), ("by", Var(None)), ("bz", Var(None)), ("bvx", Var(None)), ("bvy", Var(None)), ("bvz", Var(None)), ("bm", Var(None))], Var("b"), Let(("new_b", Var(None)), Tuple([Prim(Var("bx"), Prim(Var("dt"), Var("bvx"), Mul, kind=None), Add, kind=None), Prim(Var("by"), Prim(Var("dt"), Var("bvy"), Mul, kind=None), Add, kind=None), Prim(Var("bz"), Prim(Var("dt"), Var("bvz"), Mul, kind=None), Add, kind=None), Var("bvx"), Var("bvy"), Var("bvz"), Var("bm")]), Let(("_", Var(None)), Put(Var("bodies"), Var("i"), Var("new_b")), Let(("_", Var(None)), App(Var("update_axis"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Unit))))), Unit), Unit)}, Let(("_", Var(None)), App(Var("update_axis"), targs=None, [Int(0)]), Unit))))) against Unit
// [Typer] infer: Int(5)
// [Typer] unify: Var(None) and Int
// [Typer] union: Var(None) and Int
// [Typer] check: LetRec({tyvars: [], name: ("loop_i", Var(None)), args: [("i", Int)], body: Let(("_", Var(None)), If(LE(Var("i"), Prim(Var("n"), Int(1), Sub, kind=None)), Let(("b", Var(None)), Get(Var("bodies"), Var("i")), LetTuple([("bx", Var(None)), ("by", Var(None)), ("bz", Var(None)), ("bvx", Var(None)), ("bvy", Var(None)), ("bvz", Var(None)), ("bm", Var(None))], Var("b"), LetRec({tyvars: [], name: ("loop_j", Var(None)), args: [("j", Int)], body: Let(("_", Var(None)), If(LE(Var("j"), Prim(Var("n"), Int(1), Sub, kind=None)), Let(("b2", Var(None)), Get(Var("bodies"), Var("j")), LetTuple([("b2x", Var(None)), ("b2y", Var(None)), ("b2z", Var(None)), ("b2vx", Var(None)), ("b2vy", Var(None)), ("b2vz", Var(None)), ("b2m", Var(None))], Var("b2"), Let(("dx", Var(None)), Prim(Var("bx"), Var("b2x"), Sub, kind=None), Let(("dy", Var(None)), Prim(Var("by"), Var("b2y"), Sub, kind=None), Let(("dz", Var(None)), Prim(Var("bz"), Var("b2z"), Sub, kind=None), Let(("dist2", Var(None)), Prim(Prim(Prim(Var("dx"), Var("dx"), Mul, kind=None), Prim(Var("dy"), Var("dy"), Mul, kind=None), Add, kind=None), Prim(Var("dz"), Var("dz"), Mul, kind=None), Add, kind=None), Let(("mag", Var(None)), Prim(Var("dt"), Prim(Var("dist2"), App(Var("sqrt"), targs=None, [Var("dist2")]), Mul, kind=None), Div, kind=None), Let(("new_b", Var(None)), Tuple([Var("bx"), Var("by"), Var("bz"), Prim(Var("bvx"), Prim(Prim(Var("dx"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Prim(Var("bvy"), Prim(Prim(Var("dy"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Prim(Var("bvz"), Prim(Prim(Var("dz"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Var("bm")]), Let(("_", Var(None)), Put(Var("bodies"), Var("i"), Var("new_b")), Let(("new_b2", Var(None)), Tuple([Var("b2x"), Var("b2y"), Var("b2z"), Prim(Var("b2vx"), Prim(Prim(Var("dx"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Prim(Var("b2vy"), Prim(Prim(Var("dy"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Prim(Var("b2vz"), Prim(Prim(Var("dz"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Var("b2m")]), Let(("_", Var(None)), Put(Var("bodies"), Var("j"), Var("new_b2")), Let(("_", Var(None)), App(Var("loop_j"), targs=None, [Prim(Var("j"), Int(1), Add, kind=None)]), Unit)))))))))))), Unit), Unit)}, Let(("_", Var(None)), App(Var("loop_j"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Unit))))), Unit), Unit)}, Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Int(0)]), LetRec({tyvars: [], name: ("update_axis", Var(None)), args: [("i", Int)], body: Let(("_", Var(None)), If(LE(Var("i"), Prim(Var("n"), Int(1), Sub, kind=None)), Let(("b", Var(None)), Get(Var("bodies"), Var("i")), LetTuple([("bx", Var(None)), ("by", Var(None)), ("bz", Var(None)), ("bvx", Var(None)), ("bvy", Var(None)), ("bvz", Var(None)), ("bm", Var(None))], Var("b"), Let(("new_b", Var(None)), Tuple([Prim(Var("bx"), Prim(Var("dt"), Var("bvx"), Mul, kind=None), Add, kind=None), Prim(Var("by"), Prim(Var("dt"), Var("bvy"), Mul, kind=None), Add, kind=None), Prim(Var("bz"), Prim(Var("dt"), Var("bvz"), Mul, kind=None), Add, kind=None), Var("bvx"), Var("bvy"), Var("bvz"), Var("bm")]), Let(("_", Var(None)), Put(Var("bodies"), Var("i"), Var("new_b")), Let(("_", Var(None)), App(Var("update_axis"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Unit))))), Unit), Unit)}, Let(("_", Var(None)), App(Var("update_axis"), targs=None, [Int(0)]), Unit)))) against Unit
// [Typer] typevars: []
// [Typer] infer: Let(("_", Var(None)), If(LE(Var("i"), Prim(Var("n"), Int(1), Sub, kind=None)), Let(("b", Var(None)), Get(Var("bodies"), Var("i")), LetTuple([("bx", Var(None)), ("by", Var(None)), ("bz", Var(None)), ("bvx", Var(None)), ("bvy", Var(None)), ("bvz", Var(None)), ("bm", Var(None))], Var("b"), LetRec({tyvars: [], name: ("loop_j", Var(None)), args: [("j", Int)], body: Let(("_", Var(None)), If(LE(Var("j"), Prim(Var("n"), Int(1), Sub, kind=None)), Let(("b2", Var(None)), Get(Var("bodies"), Var("j")), LetTuple([("b2x", Var(None)), ("b2y", Var(None)), ("b2z", Var(None)), ("b2vx", Var(None)), ("b2vy", Var(None)), ("b2vz", Var(None)), ("b2m", Var(None))], Var("b2"), Let(("dx", Var(None)), Prim(Var("bx"), Var("b2x"), Sub, kind=None), Let(("dy", Var(None)), Prim(Var("by"), Var("b2y"), Sub, kind=None), Let(("dz", Var(None)), Prim(Var("bz"), Var("b2z"), Sub, kind=None), Let(("dist2", Var(None)), Prim(Prim(Prim(Var("dx"), Var("dx"), Mul, kind=None), Prim(Var("dy"), Var("dy"), Mul, kind=None), Add, kind=None), Prim(Var("dz"), Var("dz"), Mul, kind=None), Add, kind=None), Let(("mag", Var(None)), Prim(Var("dt"), Prim(Var("dist2"), App(Var("sqrt"), targs=None, [Var("dist2")]), Mul, kind=None), Div, kind=None), Let(("new_b", Var(None)), Tuple([Var("bx"), Var("by"), Var("bz"), Prim(Var("bvx"), Prim(Prim(Var("dx"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Prim(Var("bvy"), Prim(Prim(Var("dy"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Prim(Var("bvz"), Prim(Prim(Var("dz"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Var("bm")]), Let(("_", Var(None)), Put(Var("bodies"), Var("i"), Var("new_b")), Let(("new_b2", Var(None)), Tuple([Var("b2x"), Var("b2y"), Var("b2z"), Prim(Var("b2vx"), Prim(Prim(Var("dx"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Prim(Var("b2vy"), Prim(Prim(Var("dy"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Prim(Var("b2vz"), Prim(Prim(Var("dz"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Var("b2m")]), Let(("_", Var(None)), Put(Var("bodies"), Var("j"), Var("new_b2")), Let(("_", Var(None)), App(Var("loop_j"), targs=None, [Prim(Var("j"), Int(1), Add, kind=None)]), Unit)))))))))))), Unit), Unit)}, Let(("_", Var(None)), App(Var("loop_j"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Unit))))), Unit), Unit)
// [Typer] infer: If(LE(Var("i"), Prim(Var("n"), Int(1), Sub, kind=None)), Let(("b", Var(None)), Get(Var("bodies"), Var("i")), LetTuple([("bx", Var(None)), ("by", Var(None)), ("bz", Var(None)), ("bvx", Var(None)), ("bvy", Var(None)), ("bvz", Var(None)), ("bm", Var(None))], Var("b"), LetRec({tyvars: [], name: ("loop_j", Var(None)), args: [("j", Int)], body: Let(("_", Var(None)), If(LE(Var("j"), Prim(Var("n"), Int(1), Sub, kind=None)), Let(("b2", Var(None)), Get(Var("bodies"), Var("j")), LetTuple([("b2x", Var(None)), ("b2y", Var(None)), ("b2z", Var(None)), ("b2vx", Var(None)), ("b2vy", Var(None)), ("b2vz", Var(None)), ("b2m", Var(None))], Var("b2"), Let(("dx", Var(None)), Prim(Var("bx"), Var("b2x"), Sub, kind=None), Let(("dy", Var(None)), Prim(Var("by"), Var("b2y"), Sub, kind=None), Let(("dz", Var(None)), Prim(Var("bz"), Var("b2z"), Sub, kind=None), Let(("dist2", Var(None)), Prim(Prim(Prim(Var("dx"), Var("dx"), Mul, kind=None), Prim(Var("dy"), Var("dy"), Mul, kind=None), Add, kind=None), Prim(Var("dz"), Var("dz"), Mul, kind=None), Add, kind=None), Let(("mag", Var(None)), Prim(Var("dt"), Prim(Var("dist2"), App(Var("sqrt"), targs=None, [Var("dist2")]), Mul, kind=None), Div, kind=None), Let(("new_b", Var(None)), Tuple([Var("bx"), Var("by"), Var("bz"), Prim(Var("bvx"), Prim(Prim(Var("dx"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Prim(Var("bvy"), Prim(Prim(Var("dy"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Prim(Var("bvz"), Prim(Prim(Var("dz"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Var("bm")]), Let(("_", Var(None)), Put(Var("bodies"), Var("i"), Var("new_b")), Let(("new_b2", Var(None)), Tuple([Var("b2x"), Var("b2y"), Var("b2z"), Prim(Var("b2vx"), Prim(Prim(Var("dx"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Prim(Var("b2vy"), Prim(Prim(Var("dy"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Prim(Var("b2vz"), Prim(Prim(Var("dz"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Var("b2m")]), Let(("_", Var(None)), Put(Var("bodies"), Var("j"), Var("new_b2")), Let(("_", Var(None)), App(Var("loop_j"), targs=None, [Prim(Var("j"), Int(1), Add, kind=None)]), Unit)))))))))))), Unit), Unit)}, Let(("_", Var(None)), App(Var("loop_j"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Unit))))), Unit)
// [Typer] check: LE(Var("i"), Prim(Var("n"), Int(1), Sub, kind=None)) against Bool
// [Typer] infer: Var("i")
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] infer: Prim(Var("n"), Int(1), Sub, kind=None)
// [Typer] infer: Var("n")
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] infer: Int(1)
// [Typer] unify: Int and Int
// [Typer] unify: Int and Int
// [Typer] infer: Let(("b", Var(None)), Get(Var("bodies"), Var("i")), LetTuple([("bx", Var(None)), ("by", Var(None)), ("bz", Var(None)), ("bvx", Var(None)), ("bvy", Var(None)), ("bvz", Var(None)), ("bm", Var(None))], Var("b"), LetRec({tyvars: [], name: ("loop_j", Var(None)), args: [("j", Int)], body: Let(("_", Var(None)), If(LE(Var("j"), Prim(Var("n"), Int(1), Sub, kind=None)), Let(("b2", Var(None)), Get(Var("bodies"), Var("j")), LetTuple([("b2x", Var(None)), ("b2y", Var(None)), ("b2z", Var(None)), ("b2vx", Var(None)), ("b2vy", Var(None)), ("b2vz", Var(None)), ("b2m", Var(None))], Var("b2"), Let(("dx", Var(None)), Prim(Var("bx"), Var("b2x"), Sub, kind=None), Let(("dy", Var(None)), Prim(Var("by"), Var("b2y"), Sub, kind=None), Let(("dz", Var(None)), Prim(Var("bz"), Var("b2z"), Sub, kind=None), Let(("dist2", Var(None)), Prim(Prim(Prim(Var("dx"), Var("dx"), Mul, kind=None), Prim(Var("dy"), Var("dy"), Mul, kind=None), Add, kind=None), Prim(Var("dz"), Var("dz"), Mul, kind=None), Add, kind=None), Let(("mag", Var(None)), Prim(Var("dt"), Prim(Var("dist2"), App(Var("sqrt"), targs=None, [Var("dist2")]), Mul, kind=None), Div, kind=None), Let(("new_b", Var(None)), Tuple([Var("bx"), Var("by"), Var("bz"), Prim(Var("bvx"), Prim(Prim(Var("dx"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Prim(Var("bvy"), Prim(Prim(Var("dy"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Prim(Var("bvz"), Prim(Prim(Var("dz"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Var("bm")]), Let(("_", Var(None)), Put(Var("bodies"), Var("i"), Var("new_b")), Let(("new_b2", Var(None)), Tuple([Var("b2x"), Var("b2y"), Var("b2z"), Prim(Var("b2vx"), Prim(Prim(Var("dx"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Prim(Var("b2vy"), Prim(Prim(Var("dy"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Prim(Var("b2vz"), Prim(Prim(Var("dz"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Var("b2m")]), Let(("_", Var(None)), Put(Var("bodies"), Var("j"), Var("new_b2")), Let(("_", Var(None)), App(Var("loop_j"), targs=None, [Prim(Var("j"), Int(1), Add, kind=None)]), Unit)))))))))))), Unit), Unit)}, Let(("_", Var(None)), App(Var("loop_j"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Unit)))))
// [Typer] infer: Get(Var("bodies"), Var("i"))
// [Typer] infer: Var("bodies")
// [Typer] inst: TypeScheme(([], Array[(Double, Double, Double, Double, Double, Double, Double)]))
// [Typer] inst result: Array[(Double, Double, Double, Double, Double, Double, Double)]
// [Typer] check: Var("i") against Int
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] unify: Var(None) and (Double, Double, Double, Double, Double, Double, Double)
// [Typer] union: Var(None) and (Double, Double, Double, Double, Double, Double, Double)
// [Typer] infer: LetTuple([("bx", Var(None)), ("by", Var(None)), ("bz", Var(None)), ("bvx", Var(None)), ("bvy", Var(None)), ("bvz", Var(None)), ("bm", Var(None))], Var("b"), LetRec({tyvars: [], name: ("loop_j", Var(None)), args: [("j", Int)], body: Let(("_", Var(None)), If(LE(Var("j"), Prim(Var("n"), Int(1), Sub, kind=None)), Let(("b2", Var(None)), Get(Var("bodies"), Var("j")), LetTuple([("b2x", Var(None)), ("b2y", Var(None)), ("b2z", Var(None)), ("b2vx", Var(None)), ("b2vy", Var(None)), ("b2vz", Var(None)), ("b2m", Var(None))], Var("b2"), Let(("dx", Var(None)), Prim(Var("bx"), Var("b2x"), Sub, kind=None), Let(("dy", Var(None)), Prim(Var("by"), Var("b2y"), Sub, kind=None), Let(("dz", Var(None)), Prim(Var("bz"), Var("b2z"), Sub, kind=None), Let(("dist2", Var(None)), Prim(Prim(Prim(Var("dx"), Var("dx"), Mul, kind=None), Prim(Var("dy"), Var("dy"), Mul, kind=None), Add, kind=None), Prim(Var("dz"), Var("dz"), Mul, kind=None), Add, kind=None), Let(("mag", Var(None)), Prim(Var("dt"), Prim(Var("dist2"), App(Var("sqrt"), targs=None, [Var("dist2")]), Mul, kind=None), Div, kind=None), Let(("new_b", Var(None)), Tuple([Var("bx"), Var("by"), Var("bz"), Prim(Var("bvx"), Prim(Prim(Var("dx"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Prim(Var("bvy"), Prim(Prim(Var("dy"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Prim(Var("bvz"), Prim(Prim(Var("dz"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Var("bm")]), Let(("_", Var(None)), Put(Var("bodies"), Var("i"), Var("new_b")), Let(("new_b2", Var(None)), Tuple([Var("b2x"), Var("b2y"), Var("b2z"), Prim(Var("b2vx"), Prim(Prim(Var("dx"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Prim(Var("b2vy"), Prim(Prim(Var("dy"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Prim(Var("b2vz"), Prim(Prim(Var("dz"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Var("b2m")]), Let(("_", Var(None)), Put(Var("bodies"), Var("j"), Var("new_b2")), Let(("_", Var(None)), App(Var("loop_j"), targs=None, [Prim(Var("j"), Int(1), Add, kind=None)]), Unit)))))))))))), Unit), Unit)}, Let(("_", Var(None)), App(Var("loop_j"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Unit))))
// [Typer] infer: Var("b")
// [Typer] inst: TypeScheme(([], (Double, Double, Double, Double, Double, Double, Double)))
// [Typer] inst result: (Double, Double, Double, Double, Double, Double, Double)
// [Typer] unify: Var(None) and Double
// [Typer] union: Var(None) and Double
// [Typer] unify: Var(None) and Double
// [Typer] union: Var(None) and Double
// [Typer] unify: Var(None) and Double
// [Typer] union: Var(None) and Double
// [Typer] unify: Var(None) and Double
// [Typer] union: Var(None) and Double
// [Typer] unify: Var(None) and Double
// [Typer] union: Var(None) and Double
// [Typer] unify: Var(None) and Double
// [Typer] union: Var(None) and Double
// [Typer] unify: Var(None) and Double
// [Typer] union: Var(None) and Double
// [Typer] infer: LetRec({tyvars: [], name: ("loop_j", Var(None)), args: [("j", Int)], body: Let(("_", Var(None)), If(LE(Var("j"), Prim(Var("n"), Int(1), Sub, kind=None)), Let(("b2", Var(None)), Get(Var("bodies"), Var("j")), LetTuple([("b2x", Var(None)), ("b2y", Var(None)), ("b2z", Var(None)), ("b2vx", Var(None)), ("b2vy", Var(None)), ("b2vz", Var(None)), ("b2m", Var(None))], Var("b2"), Let(("dx", Var(None)), Prim(Var("bx"), Var("b2x"), Sub, kind=None), Let(("dy", Var(None)), Prim(Var("by"), Var("b2y"), Sub, kind=None), Let(("dz", Var(None)), Prim(Var("bz"), Var("b2z"), Sub, kind=None), Let(("dist2", Var(None)), Prim(Prim(Prim(Var("dx"), Var("dx"), Mul, kind=None), Prim(Var("dy"), Var("dy"), Mul, kind=None), Add, kind=None), Prim(Var("dz"), Var("dz"), Mul, kind=None), Add, kind=None), Let(("mag", Var(None)), Prim(Var("dt"), Prim(Var("dist2"), App(Var("sqrt"), targs=None, [Var("dist2")]), Mul, kind=None), Div, kind=None), Let(("new_b", Var(None)), Tuple([Var("bx"), Var("by"), Var("bz"), Prim(Var("bvx"), Prim(Prim(Var("dx"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Prim(Var("bvy"), Prim(Prim(Var("dy"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Prim(Var("bvz"), Prim(Prim(Var("dz"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Var("bm")]), Let(("_", Var(None)), Put(Var("bodies"), Var("i"), Var("new_b")), Let(("new_b2", Var(None)), Tuple([Var("b2x"), Var("b2y"), Var("b2z"), Prim(Var("b2vx"), Prim(Prim(Var("dx"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Prim(Var("b2vy"), Prim(Prim(Var("dy"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Prim(Var("b2vz"), Prim(Prim(Var("dz"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Var("b2m")]), Let(("_", Var(None)), Put(Var("bodies"), Var("j"), Var("new_b2")), Let(("_", Var(None)), App(Var("loop_j"), targs=None, [Prim(Var("j"), Int(1), Add, kind=None)]), Unit)))))))))))), Unit), Unit)}, Let(("_", Var(None)), App(Var("loop_j"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Unit)))
// [Typer] typevars: []
// [Typer] infer: Let(("_", Var(None)), If(LE(Var("j"), Prim(Var("n"), Int(1), Sub, kind=None)), Let(("b2", Var(None)), Get(Var("bodies"), Var("j")), LetTuple([("b2x", Var(None)), ("b2y", Var(None)), ("b2z", Var(None)), ("b2vx", Var(None)), ("b2vy", Var(None)), ("b2vz", Var(None)), ("b2m", Var(None))], Var("b2"), Let(("dx", Var(None)), Prim(Var("bx"), Var("b2x"), Sub, kind=None), Let(("dy", Var(None)), Prim(Var("by"), Var("b2y"), Sub, kind=None), Let(("dz", Var(None)), Prim(Var("bz"), Var("b2z"), Sub, kind=None), Let(("dist2", Var(None)), Prim(Prim(Prim(Var("dx"), Var("dx"), Mul, kind=None), Prim(Var("dy"), Var("dy"), Mul, kind=None), Add, kind=None), Prim(Var("dz"), Var("dz"), Mul, kind=None), Add, kind=None), Let(("mag", Var(None)), Prim(Var("dt"), Prim(Var("dist2"), App(Var("sqrt"), targs=None, [Var("dist2")]), Mul, kind=None), Div, kind=None), Let(("new_b", Var(None)), Tuple([Var("bx"), Var("by"), Var("bz"), Prim(Var("bvx"), Prim(Prim(Var("dx"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Prim(Var("bvy"), Prim(Prim(Var("dy"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Prim(Var("bvz"), Prim(Prim(Var("dz"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Var("bm")]), Let(("_", Var(None)), Put(Var("bodies"), Var("i"), Var("new_b")), Let(("new_b2", Var(None)), Tuple([Var("b2x"), Var("b2y"), Var("b2z"), Prim(Var("b2vx"), Prim(Prim(Var("dx"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Prim(Var("b2vy"), Prim(Prim(Var("dy"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Prim(Var("b2vz"), Prim(Prim(Var("dz"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Var("b2m")]), Let(("_", Var(None)), Put(Var("bodies"), Var("j"), Var("new_b2")), Let(("_", Var(None)), App(Var("loop_j"), targs=None, [Prim(Var("j"), Int(1), Add, kind=None)]), Unit)))))))))))), Unit), Unit)
// [Typer] infer: If(LE(Var("j"), Prim(Var("n"), Int(1), Sub, kind=None)), Let(("b2", Var(None)), Get(Var("bodies"), Var("j")), LetTuple([("b2x", Var(None)), ("b2y", Var(None)), ("b2z", Var(None)), ("b2vx", Var(None)), ("b2vy", Var(None)), ("b2vz", Var(None)), ("b2m", Var(None))], Var("b2"), Let(("dx", Var(None)), Prim(Var("bx"), Var("b2x"), Sub, kind=None), Let(("dy", Var(None)), Prim(Var("by"), Var("b2y"), Sub, kind=None), Let(("dz", Var(None)), Prim(Var("bz"), Var("b2z"), Sub, kind=None), Let(("dist2", Var(None)), Prim(Prim(Prim(Var("dx"), Var("dx"), Mul, kind=None), Prim(Var("dy"), Var("dy"), Mul, kind=None), Add, kind=None), Prim(Var("dz"), Var("dz"), Mul, kind=None), Add, kind=None), Let(("mag", Var(None)), Prim(Var("dt"), Prim(Var("dist2"), App(Var("sqrt"), targs=None, [Var("dist2")]), Mul, kind=None), Div, kind=None), Let(("new_b", Var(None)), Tuple([Var("bx"), Var("by"), Var("bz"), Prim(Var("bvx"), Prim(Prim(Var("dx"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Prim(Var("bvy"), Prim(Prim(Var("dy"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Prim(Var("bvz"), Prim(Prim(Var("dz"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Var("bm")]), Let(("_", Var(None)), Put(Var("bodies"), Var("i"), Var("new_b")), Let(("new_b2", Var(None)), Tuple([Var("b2x"), Var("b2y"), Var("b2z"), Prim(Var("b2vx"), Prim(Prim(Var("dx"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Prim(Var("b2vy"), Prim(Prim(Var("dy"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Prim(Var("b2vz"), Prim(Prim(Var("dz"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Var("b2m")]), Let(("_", Var(None)), Put(Var("bodies"), Var("j"), Var("new_b2")), Let(("_", Var(None)), App(Var("loop_j"), targs=None, [Prim(Var("j"), Int(1), Add, kind=None)]), Unit)))))))))))), Unit)
// [Typer] check: LE(Var("j"), Prim(Var("n"), Int(1), Sub, kind=None)) against Bool
// [Typer] infer: Var("j")
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] infer: Prim(Var("n"), Int(1), Sub, kind=None)
// [Typer] infer: Var("n")
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] infer: Int(1)
// [Typer] unify: Int and Int
// [Typer] unify: Int and Int
// [Typer] infer: Let(("b2", Var(None)), Get(Var("bodies"), Var("j")), LetTuple([("b2x", Var(None)), ("b2y", Var(None)), ("b2z", Var(None)), ("b2vx", Var(None)), ("b2vy", Var(None)), ("b2vz", Var(None)), ("b2m", Var(None))], Var("b2"), Let(("dx", Var(None)), Prim(Var("bx"), Var("b2x"), Sub, kind=None), Let(("dy", Var(None)), Prim(Var("by"), Var("b2y"), Sub, kind=None), Let(("dz", Var(None)), Prim(Var("bz"), Var("b2z"), Sub, kind=None), Let(("dist2", Var(None)), Prim(Prim(Prim(Var("dx"), Var("dx"), Mul, kind=None), Prim(Var("dy"), Var("dy"), Mul, kind=None), Add, kind=None), Prim(Var("dz"), Var("dz"), Mul, kind=None), Add, kind=None), Let(("mag", Var(None)), Prim(Var("dt"), Prim(Var("dist2"), App(Var("sqrt"), targs=None, [Var("dist2")]), Mul, kind=None), Div, kind=None), Let(("new_b", Var(None)), Tuple([Var("bx"), Var("by"), Var("bz"), Prim(Var("bvx"), Prim(Prim(Var("dx"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Prim(Var("bvy"), Prim(Prim(Var("dy"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Prim(Var("bvz"), Prim(Prim(Var("dz"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Var("bm")]), Let(("_", Var(None)), Put(Var("bodies"), Var("i"), Var("new_b")), Let(("new_b2", Var(None)), Tuple([Var("b2x"), Var("b2y"), Var("b2z"), Prim(Var("b2vx"), Prim(Prim(Var("dx"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Prim(Var("b2vy"), Prim(Prim(Var("dy"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Prim(Var("b2vz"), Prim(Prim(Var("dz"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Var("b2m")]), Let(("_", Var(None)), Put(Var("bodies"), Var("j"), Var("new_b2")), Let(("_", Var(None)), App(Var("loop_j"), targs=None, [Prim(Var("j"), Int(1), Add, kind=None)]), Unit))))))))))))
// [Typer] infer: Get(Var("bodies"), Var("j"))
// [Typer] infer: Var("bodies")
// [Typer] inst: TypeScheme(([], Array[(Double, Double, Double, Double, Double, Double, Double)]))
// [Typer] inst result: Array[(Double, Double, Double, Double, Double, Double, Double)]
// [Typer] check: Var("j") against Int
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] unify: Var(None) and (Double, Double, Double, Double, Double, Double, Double)
// [Typer] union: Var(None) and (Double, Double, Double, Double, Double, Double, Double)
// [Typer] infer: LetTuple([("b2x", Var(None)), ("b2y", Var(None)), ("b2z", Var(None)), ("b2vx", Var(None)), ("b2vy", Var(None)), ("b2vz", Var(None)), ("b2m", Var(None))], Var("b2"), Let(("dx", Var(None)), Prim(Var("bx"), Var("b2x"), Sub, kind=None), Let(("dy", Var(None)), Prim(Var("by"), Var("b2y"), Sub, kind=None), Let(("dz", Var(None)), Prim(Var("bz"), Var("b2z"), Sub, kind=None), Let(("dist2", Var(None)), Prim(Prim(Prim(Var("dx"), Var("dx"), Mul, kind=None), Prim(Var("dy"), Var("dy"), Mul, kind=None), Add, kind=None), Prim(Var("dz"), Var("dz"), Mul, kind=None), Add, kind=None), Let(("mag", Var(None)), Prim(Var("dt"), Prim(Var("dist2"), App(Var("sqrt"), targs=None, [Var("dist2")]), Mul, kind=None), Div, kind=None), Let(("new_b", Var(None)), Tuple([Var("bx"), Var("by"), Var("bz"), Prim(Var("bvx"), Prim(Prim(Var("dx"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Prim(Var("bvy"), Prim(Prim(Var("dy"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Prim(Var("bvz"), Prim(Prim(Var("dz"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Var("bm")]), Let(("_", Var(None)), Put(Var("bodies"), Var("i"), Var("new_b")), Let(("new_b2", Var(None)), Tuple([Var("b2x"), Var("b2y"), Var("b2z"), Prim(Var("b2vx"), Prim(Prim(Var("dx"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Prim(Var("b2vy"), Prim(Prim(Var("dy"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Prim(Var("b2vz"), Prim(Prim(Var("dz"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Var("b2m")]), Let(("_", Var(None)), Put(Var("bodies"), Var("j"), Var("new_b2")), Let(("_", Var(None)), App(Var("loop_j"), targs=None, [Prim(Var("j"), Int(1), Add, kind=None)]), Unit)))))))))))
// [Typer] infer: Var("b2")
// [Typer] inst: TypeScheme(([], (Double, Double, Double, Double, Double, Double, Double)))
// [Typer] inst result: (Double, Double, Double, Double, Double, Double, Double)
// [Typer] unify: Var(None) and Double
// [Typer] union: Var(None) and Double
// [Typer] unify: Var(None) and Double
// [Typer] union: Var(None) and Double
// [Typer] unify: Var(None) and Double
// [Typer] union: Var(None) and Double
// [Typer] unify: Var(None) and Double
// [Typer] union: Var(None) and Double
// [Typer] unify: Var(None) and Double
// [Typer] union: Var(None) and Double
// [Typer] unify: Var(None) and Double
// [Typer] union: Var(None) and Double
// [Typer] unify: Var(None) and Double
// [Typer] union: Var(None) and Double
// [Typer] infer: Let(("dx", Var(None)), Prim(Var("bx"), Var("b2x"), Sub, kind=None), Let(("dy", Var(None)), Prim(Var("by"), Var("b2y"), Sub, kind=None), Let(("dz", Var(None)), Prim(Var("bz"), Var("b2z"), Sub, kind=None), Let(("dist2", Var(None)), Prim(Prim(Prim(Var("dx"), Var("dx"), Mul, kind=None), Prim(Var("dy"), Var("dy"), Mul, kind=None), Add, kind=None), Prim(Var("dz"), Var("dz"), Mul, kind=None), Add, kind=None), Let(("mag", Var(None)), Prim(Var("dt"), Prim(Var("dist2"), App(Var("sqrt"), targs=None, [Var("dist2")]), Mul, kind=None), Div, kind=None), Let(("new_b", Var(None)), Tuple([Var("bx"), Var("by"), Var("bz"), Prim(Var("bvx"), Prim(Prim(Var("dx"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Prim(Var("bvy"), Prim(Prim(Var("dy"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Prim(Var("bvz"), Prim(Prim(Var("dz"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Var("bm")]), Let(("_", Var(None)), Put(Var("bodies"), Var("i"), Var("new_b")), Let(("new_b2", Var(None)), Tuple([Var("b2x"), Var("b2y"), Var("b2z"), Prim(Var("b2vx"), Prim(Prim(Var("dx"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Prim(Var("b2vy"), Prim(Prim(Var("dy"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Prim(Var("b2vz"), Prim(Prim(Var("dz"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Var("b2m")]), Let(("_", Var(None)), Put(Var("bodies"), Var("j"), Var("new_b2")), Let(("_", Var(None)), App(Var("loop_j"), targs=None, [Prim(Var("j"), Int(1), Add, kind=None)]), Unit))))))))))
// [Typer] infer: Prim(Var("bx"), Var("b2x"), Sub, kind=None)
// [Typer] infer: Var("bx")
// [Typer] inst: TypeScheme(([], Double))
// [Typer] inst result: Double
// [Typer] infer: Var("b2x")
// [Typer] inst: TypeScheme(([], Double))
// [Typer] inst result: Double
// [Typer] unify: Double and Double
// [Typer] unify: Var(None) and Double
// [Typer] union: Var(None) and Double
// [Typer] infer: Let(("dy", Var(None)), Prim(Var("by"), Var("b2y"), Sub, kind=None), Let(("dz", Var(None)), Prim(Var("bz"), Var("b2z"), Sub, kind=None), Let(("dist2", Var(None)), Prim(Prim(Prim(Var("dx"), Var("dx"), Mul, kind=None), Prim(Var("dy"), Var("dy"), Mul, kind=None), Add, kind=None), Prim(Var("dz"), Var("dz"), Mul, kind=None), Add, kind=None), Let(("mag", Var(None)), Prim(Var("dt"), Prim(Var("dist2"), App(Var("sqrt"), targs=None, [Var("dist2")]), Mul, kind=None), Div, kind=None), Let(("new_b", Var(None)), Tuple([Var("bx"), Var("by"), Var("bz"), Prim(Var("bvx"), Prim(Prim(Var("dx"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Prim(Var("bvy"), Prim(Prim(Var("dy"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Prim(Var("bvz"), Prim(Prim(Var("dz"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Var("bm")]), Let(("_", Var(None)), Put(Var("bodies"), Var("i"), Var("new_b")), Let(("new_b2", Var(None)), Tuple([Var("b2x"), Var("b2y"), Var("b2z"), Prim(Var("b2vx"), Prim(Prim(Var("dx"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Prim(Var("b2vy"), Prim(Prim(Var("dy"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Prim(Var("b2vz"), Prim(Prim(Var("dz"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Var("b2m")]), Let(("_", Var(None)), Put(Var("bodies"), Var("j"), Var("new_b2")), Let(("_", Var(None)), App(Var("loop_j"), targs=None, [Prim(Var("j"), Int(1), Add, kind=None)]), Unit)))))))))
// [Typer] infer: Prim(Var("by"), Var("b2y"), Sub, kind=None)
// [Typer] infer: Var("by")
// [Typer] inst: TypeScheme(([], Double))
// [Typer] inst result: Double
// [Typer] infer: Var("b2y")
// [Typer] inst: TypeScheme(([], Double))
// [Typer] inst result: Double
// [Typer] unify: Double and Double
// [Typer] unify: Var(None) and Double
// [Typer] union: Var(None) and Double
// [Typer] infer: Let(("dz", Var(None)), Prim(Var("bz"), Var("b2z"), Sub, kind=None), Let(("dist2", Var(None)), Prim(Prim(Prim(Var("dx"), Var("dx"), Mul, kind=None), Prim(Var("dy"), Var("dy"), Mul, kind=None), Add, kind=None), Prim(Var("dz"), Var("dz"), Mul, kind=None), Add, kind=None), Let(("mag", Var(None)), Prim(Var("dt"), Prim(Var("dist2"), App(Var("sqrt"), targs=None, [Var("dist2")]), Mul, kind=None), Div, kind=None), Let(("new_b", Var(None)), Tuple([Var("bx"), Var("by"), Var("bz"), Prim(Var("bvx"), Prim(Prim(Var("dx"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Prim(Var("bvy"), Prim(Prim(Var("dy"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Prim(Var("bvz"), Prim(Prim(Var("dz"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Var("bm")]), Let(("_", Var(None)), Put(Var("bodies"), Var("i"), Var("new_b")), Let(("new_b2", Var(None)), Tuple([Var("b2x"), Var("b2y"), Var("b2z"), Prim(Var("b2vx"), Prim(Prim(Var("dx"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Prim(Var("b2vy"), Prim(Prim(Var("dy"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Prim(Var("b2vz"), Prim(Prim(Var("dz"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Var("b2m")]), Let(("_", Var(None)), Put(Var("bodies"), Var("j"), Var("new_b2")), Let(("_", Var(None)), App(Var("loop_j"), targs=None, [Prim(Var("j"), Int(1), Add, kind=None)]), Unit))))))))
// [Typer] infer: Prim(Var("bz"), Var("b2z"), Sub, kind=None)
// [Typer] infer: Var("bz")
// [Typer] inst: TypeScheme(([], Double))
// [Typer] inst result: Double
// [Typer] infer: Var("b2z")
// [Typer] inst: TypeScheme(([], Double))
// [Typer] inst result: Double
// [Typer] unify: Double and Double
// [Typer] unify: Var(None) and Double
// [Typer] union: Var(None) and Double
// [Typer] infer: Let(("dist2", Var(None)), Prim(Prim(Prim(Var("dx"), Var("dx"), Mul, kind=None), Prim(Var("dy"), Var("dy"), Mul, kind=None), Add, kind=None), Prim(Var("dz"), Var("dz"), Mul, kind=None), Add, kind=None), Let(("mag", Var(None)), Prim(Var("dt"), Prim(Var("dist2"), App(Var("sqrt"), targs=None, [Var("dist2")]), Mul, kind=None), Div, kind=None), Let(("new_b", Var(None)), Tuple([Var("bx"), Var("by"), Var("bz"), Prim(Var("bvx"), Prim(Prim(Var("dx"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Prim(Var("bvy"), Prim(Prim(Var("dy"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Prim(Var("bvz"), Prim(Prim(Var("dz"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Var("bm")]), Let(("_", Var(None)), Put(Var("bodies"), Var("i"), Var("new_b")), Let(("new_b2", Var(None)), Tuple([Var("b2x"), Var("b2y"), Var("b2z"), Prim(Var("b2vx"), Prim(Prim(Var("dx"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Prim(Var("b2vy"), Prim(Prim(Var("dy"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Prim(Var("b2vz"), Prim(Prim(Var("dz"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Var("b2m")]), Let(("_", Var(None)), Put(Var("bodies"), Var("j"), Var("new_b2")), Let(("_", Var(None)), App(Var("loop_j"), targs=None, [Prim(Var("j"), Int(1), Add, kind=None)]), Unit)))))))
// [Typer] infer: Prim(Prim(Prim(Var("dx"), Var("dx"), Mul, kind=None), Prim(Var("dy"), Var("dy"), Mul, kind=None), Add, kind=None), Prim(Var("dz"), Var("dz"), Mul, kind=None), Add, kind=None)
// [Typer] infer: Prim(Prim(Var("dx"), Var("dx"), Mul, kind=None), Prim(Var("dy"), Var("dy"), Mul, kind=None), Add, kind=None)
// [Typer] infer: Prim(Var("dx"), Var("dx"), Mul, kind=None)
// [Typer] infer: Var("dx")
// [Typer] inst: TypeScheme(([], Double))
// [Typer] inst result: Double
// [Typer] infer: Var("dx")
// [Typer] inst: TypeScheme(([], Double))
// [Typer] inst result: Double
// [Typer] unify: Double and Double
// [Typer] infer: Prim(Var("dy"), Var("dy"), Mul, kind=None)
// [Typer] infer: Var("dy")
// [Typer] inst: TypeScheme(([], Double))
// [Typer] inst result: Double
// [Typer] infer: Var("dy")
// [Typer] inst: TypeScheme(([], Double))
// [Typer] inst result: Double
// [Typer] unify: Double and Double
// [Typer] unify: Double and Double
// [Typer] infer: Prim(Var("dz"), Var("dz"), Mul, kind=None)
// [Typer] infer: Var("dz")
// [Typer] inst: TypeScheme(([], Double))
// [Typer] inst result: Double
// [Typer] infer: Var("dz")
// [Typer] inst: TypeScheme(([], Double))
// [Typer] inst result: Double
// [Typer] unify: Double and Double
// [Typer] unify: Double and Double
// [Typer] unify: Var(None) and Double
// [Typer] union: Var(None) and Double
// [Typer] infer: Let(("mag", Var(None)), Prim(Var("dt"), Prim(Var("dist2"), App(Var("sqrt"), targs=None, [Var("dist2")]), Mul, kind=None), Div, kind=None), Let(("new_b", Var(None)), Tuple([Var("bx"), Var("by"), Var("bz"), Prim(Var("bvx"), Prim(Prim(Var("dx"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Prim(Var("bvy"), Prim(Prim(Var("dy"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Prim(Var("bvz"), Prim(Prim(Var("dz"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Var("bm")]), Let(("_", Var(None)), Put(Var("bodies"), Var("i"), Var("new_b")), Let(("new_b2", Var(None)), Tuple([Var("b2x"), Var("b2y"), Var("b2z"), Prim(Var("b2vx"), Prim(Prim(Var("dx"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Prim(Var("b2vy"), Prim(Prim(Var("dy"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Prim(Var("b2vz"), Prim(Prim(Var("dz"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Var("b2m")]), Let(("_", Var(None)), Put(Var("bodies"), Var("j"), Var("new_b2")), Let(("_", Var(None)), App(Var("loop_j"), targs=None, [Prim(Var("j"), Int(1), Add, kind=None)]), Unit))))))
// [Typer] infer: Prim(Var("dt"), Prim(Var("dist2"), App(Var("sqrt"), targs=None, [Var("dist2")]), Mul, kind=None), Div, kind=None)
// [Typer] infer: Var("dt")
// [Typer] inst: TypeScheme(([], Double))
// [Typer] inst result: Double
// [Typer] infer: Prim(Var("dist2"), App(Var("sqrt"), targs=None, [Var("dist2")]), Mul, kind=None)
// [Typer] infer: Var("dist2")
// [Typer] inst: TypeScheme(([], Double))
// [Typer] inst result: Double
// [Typer] infer: App(Var("sqrt"), targs=None, [Var("dist2")])
// [Typer] inst: TypeScheme(([], (Double) -> Double))
// [Typer] inst result: (Double) -> Double
// [Typer] check: Var("dist2") against Double
// [Typer] inst: TypeScheme(([], Double))
// [Typer] inst result: Double
// [Typer] unify: Double and Double
// [Typer] unify: Double and Double
// [Typer] unify: Double and Double
// [Typer] unify: Var(None) and Double
// [Typer] union: Var(None) and Double
// [Typer] infer: Let(("new_b", Var(None)), Tuple([Var("bx"), Var("by"), Var("bz"), Prim(Var("bvx"), Prim(Prim(Var("dx"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Prim(Var("bvy"), Prim(Prim(Var("dy"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Prim(Var("bvz"), Prim(Prim(Var("dz"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Var("bm")]), Let(("_", Var(None)), Put(Var("bodies"), Var("i"), Var("new_b")), Let(("new_b2", Var(None)), Tuple([Var("b2x"), Var("b2y"), Var("b2z"), Prim(Var("b2vx"), Prim(Prim(Var("dx"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Prim(Var("b2vy"), Prim(Prim(Var("dy"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Prim(Var("b2vz"), Prim(Prim(Var("dz"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Var("b2m")]), Let(("_", Var(None)), Put(Var("bodies"), Var("j"), Var("new_b2")), Let(("_", Var(None)), App(Var("loop_j"), targs=None, [Prim(Var("j"), Int(1), Add, kind=None)]), Unit)))))
// [Typer] infer: Tuple([Var("bx"), Var("by"), Var("bz"), Prim(Var("bvx"), Prim(Prim(Var("dx"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Prim(Var("bvy"), Prim(Prim(Var("dy"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Prim(Var("bvz"), Prim(Prim(Var("dz"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Var("bm")])
// [Typer] infer: Var("bx")
// [Typer] inst: TypeScheme(([], Double))
// [Typer] inst result: Double
// [Typer] infer: Var("by")
// [Typer] inst: TypeScheme(([], Double))
// [Typer] inst result: Double
// [Typer] infer: Var("bz")
// [Typer] inst: TypeScheme(([], Double))
// [Typer] inst result: Double
// [Typer] infer: Prim(Var("bvx"), Prim(Prim(Var("dx"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None)
// [Typer] infer: Var("bvx")
// [Typer] inst: TypeScheme(([], Double))
// [Typer] inst result: Double
// [Typer] infer: Prim(Prim(Var("dx"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None)
// [Typer] infer: Prim(Var("dx"), Var("b2m"), Mul, kind=None)
// [Typer] infer: Var("dx")
// [Typer] inst: TypeScheme(([], Double))
// [Typer] inst result: Double
// [Typer] infer: Var("b2m")
// [Typer] inst: TypeScheme(([], Double))
// [Typer] inst result: Double
// [Typer] unify: Double and Double
// [Typer] infer: Var("mag")
// [Typer] inst: TypeScheme(([], Double))
// [Typer] inst result: Double
// [Typer] unify: Double and Double
// [Typer] unify: Double and Double
// [Typer] infer: Prim(Var("bvy"), Prim(Prim(Var("dy"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None)
// [Typer] infer: Var("bvy")
// [Typer] inst: TypeScheme(([], Double))
// [Typer] inst result: Double
// [Typer] infer: Prim(Prim(Var("dy"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None)
// [Typer] infer: Prim(Var("dy"), Var("b2m"), Mul, kind=None)
// [Typer] infer: Var("dy")
// [Typer] inst: TypeScheme(([], Double))
// [Typer] inst result: Double
// [Typer] infer: Var("b2m")
// [Typer] inst: TypeScheme(([], Double))
// [Typer] inst result: Double
// [Typer] unify: Double and Double
// [Typer] infer: Var("mag")
// [Typer] inst: TypeScheme(([], Double))
// [Typer] inst result: Double
// [Typer] unify: Double and Double
// [Typer] unify: Double and Double
// [Typer] infer: Prim(Var("bvz"), Prim(Prim(Var("dz"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None)
// [Typer] infer: Var("bvz")
// [Typer] inst: TypeScheme(([], Double))
// [Typer] inst result: Double
// [Typer] infer: Prim(Prim(Var("dz"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None)
// [Typer] infer: Prim(Var("dz"), Var("b2m"), Mul, kind=None)
// [Typer] infer: Var("dz")
// [Typer] inst: TypeScheme(([], Double))
// [Typer] inst result: Double
// [Typer] infer: Var("b2m")
// [Typer] inst: TypeScheme(([], Double))
// [Typer] inst result: Double
// [Typer] unify: Double and Double
// [Typer] infer: Var("mag")
// [Typer] inst: TypeScheme(([], Double))
// [Typer] inst result: Double
// [Typer] unify: Double and Double
// [Typer] unify: Double and Double
// [Typer] infer: Var("bm")
// [Typer] inst: TypeScheme(([], Double))
// [Typer] inst result: Double
// [Typer] unify: Var(None) and (Double, Double, Double, Double, Double, Double, Double)
// [Typer] union: Var(None) and (Double, Double, Double, Double, Double, Double, Double)
// [Typer] infer: Let(("_", Var(None)), Put(Var("bodies"), Var("i"), Var("new_b")), Let(("new_b2", Var(None)), Tuple([Var("b2x"), Var("b2y"), Var("b2z"), Prim(Var("b2vx"), Prim(Prim(Var("dx"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Prim(Var("b2vy"), Prim(Prim(Var("dy"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Prim(Var("b2vz"), Prim(Prim(Var("dz"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Var("b2m")]), Let(("_", Var(None)), Put(Var("bodies"), Var("j"), Var("new_b2")), Let(("_", Var(None)), App(Var("loop_j"), targs=None, [Prim(Var("j"), Int(1), Add, kind=None)]), Unit))))
// [Typer] infer: Put(Var("bodies"), Var("i"), Var("new_b"))
// [Typer] infer: Var("new_b")
// [Typer] inst: TypeScheme(([], (Double, Double, Double, Double, Double, Double, Double)))
// [Typer] inst result: (Double, Double, Double, Double, Double, Double, Double)
// [Typer] check: Var("bodies") against Array[(Double, Double, Double, Double, Double, Double, Double)]
// [Typer] inst: TypeScheme(([], Array[(Double, Double, Double, Double, Double, Double, Double)]))
// [Typer] inst result: Array[(Double, Double, Double, Double, Double, Double, Double)]
// [Typer] unify: Array[(Double, Double, Double, Double, Double, Double, Double)] and Array[(Double, Double, Double, Double, Double, Double, Double)]
// [Typer] unify: (Double, Double, Double, Double, Double, Double, Double) and (Double, Double, Double, Double, Double, Double, Double)
// [Typer] unify: Double and Double
// [Typer] unify: Double and Double
// [Typer] unify: Double and Double
// [Typer] unify: Double and Double
// [Typer] unify: Double and Double
// [Typer] unify: Double and Double
// [Typer] unify: Double and Double
// [Typer] check: Var("i") against Int
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] unify: Var(None) and Unit
// [Typer] union: Var(None) and Unit
// [Typer] infer: Let(("new_b2", Var(None)), Tuple([Var("b2x"), Var("b2y"), Var("b2z"), Prim(Var("b2vx"), Prim(Prim(Var("dx"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Prim(Var("b2vy"), Prim(Prim(Var("dy"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Prim(Var("b2vz"), Prim(Prim(Var("dz"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Var("b2m")]), Let(("_", Var(None)), Put(Var("bodies"), Var("j"), Var("new_b2")), Let(("_", Var(None)), App(Var("loop_j"), targs=None, [Prim(Var("j"), Int(1), Add, kind=None)]), Unit)))
// [Typer] infer: Tuple([Var("b2x"), Var("b2y"), Var("b2z"), Prim(Var("b2vx"), Prim(Prim(Var("dx"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Prim(Var("b2vy"), Prim(Prim(Var("dy"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Prim(Var("b2vz"), Prim(Prim(Var("dz"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None), Var("b2m")])
// [Typer] infer: Var("b2x")
// [Typer] inst: TypeScheme(([], Double))
// [Typer] inst result: Double
// [Typer] infer: Var("b2y")
// [Typer] inst: TypeScheme(([], Double))
// [Typer] inst result: Double
// [Typer] infer: Var("b2z")
// [Typer] inst: TypeScheme(([], Double))
// [Typer] inst result: Double
// [Typer] infer: Prim(Var("b2vx"), Prim(Prim(Var("dx"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None)
// [Typer] infer: Var("b2vx")
// [Typer] inst: TypeScheme(([], Double))
// [Typer] inst result: Double
// [Typer] infer: Prim(Prim(Var("dx"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None)
// [Typer] infer: Prim(Var("dx"), Var("b2m"), Mul, kind=None)
// [Typer] infer: Var("dx")
// [Typer] inst: TypeScheme(([], Double))
// [Typer] inst result: Double
// [Typer] infer: Var("b2m")
// [Typer] inst: TypeScheme(([], Double))
// [Typer] inst result: Double
// [Typer] unify: Double and Double
// [Typer] infer: Var("mag")
// [Typer] inst: TypeScheme(([], Double))
// [Typer] inst result: Double
// [Typer] unify: Double and Double
// [Typer] unify: Double and Double
// [Typer] infer: Prim(Var("b2vy"), Prim(Prim(Var("dy"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None)
// [Typer] infer: Var("b2vy")
// [Typer] inst: TypeScheme(([], Double))
// [Typer] inst result: Double
// [Typer] infer: Prim(Prim(Var("dy"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None)
// [Typer] infer: Prim(Var("dy"), Var("b2m"), Mul, kind=None)
// [Typer] infer: Var("dy")
// [Typer] inst: TypeScheme(([], Double))
// [Typer] inst result: Double
// [Typer] infer: Var("b2m")
// [Typer] inst: TypeScheme(([], Double))
// [Typer] inst result: Double
// [Typer] unify: Double and Double
// [Typer] infer: Var("mag")
// [Typer] inst: TypeScheme(([], Double))
// [Typer] inst result: Double
// [Typer] unify: Double and Double
// [Typer] unify: Double and Double
// [Typer] infer: Prim(Var("b2vz"), Prim(Prim(Var("dz"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None), Sub, kind=None)
// [Typer] infer: Var("b2vz")
// [Typer] inst: TypeScheme(([], Double))
// [Typer] inst result: Double
// [Typer] infer: Prim(Prim(Var("dz"), Var("b2m"), Mul, kind=None), Var("mag"), Mul, kind=None)
// [Typer] infer: Prim(Var("dz"), Var("b2m"), Mul, kind=None)
// [Typer] infer: Var("dz")
// [Typer] inst: TypeScheme(([], Double))
// [Typer] inst result: Double
// [Typer] infer: Var("b2m")
// [Typer] inst: TypeScheme(([], Double))
// [Typer] inst result: Double
// [Typer] unify: Double and Double
// [Typer] infer: Var("mag")
// [Typer] inst: TypeScheme(([], Double))
// [Typer] inst result: Double
// [Typer] unify: Double and Double
// [Typer] unify: Double and Double
// [Typer] infer: Var("b2m")
// [Typer] inst: TypeScheme(([], Double))
// [Typer] inst result: Double
// [Typer] unify: Var(None) and (Double, Double, Double, Double, Double, Double, Double)
// [Typer] union: Var(None) and (Double, Double, Double, Double, Double, Double, Double)
// [Typer] infer: Let(("_", Var(None)), Put(Var("bodies"), Var("j"), Var("new_b2")), Let(("_", Var(None)), App(Var("loop_j"), targs=None, [Prim(Var("j"), Int(1), Add, kind=None)]), Unit))
// [Typer] infer: Put(Var("bodies"), Var("j"), Var("new_b2"))
// [Typer] infer: Var("new_b2")
// [Typer] inst: TypeScheme(([], (Double, Double, Double, Double, Double, Double, Double)))
// [Typer] inst result: (Double, Double, Double, Double, Double, Double, Double)
// [Typer] check: Var("bodies") against Array[(Double, Double, Double, Double, Double, Double, Double)]
// [Typer] inst: TypeScheme(([], Array[(Double, Double, Double, Double, Double, Double, Double)]))
// [Typer] inst result: Array[(Double, Double, Double, Double, Double, Double, Double)]
// [Typer] unify: Array[(Double, Double, Double, Double, Double, Double, Double)] and Array[(Double, Double, Double, Double, Double, Double, Double)]
// [Typer] unify: (Double, Double, Double, Double, Double, Double, Double) and (Double, Double, Double, Double, Double, Double, Double)
// [Typer] unify: Double and Double
// [Typer] unify: Double and Double
// [Typer] unify: Double and Double
// [Typer] unify: Double and Double
// [Typer] unify: Double and Double
// [Typer] unify: Double and Double
// [Typer] unify: Double and Double
// [Typer] check: Var("j") against Int
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] unify: Var(None) and Unit
// [Typer] union: Var(None) and Unit
// [Typer] infer: Let(("_", Var(None)), App(Var("loop_j"), targs=None, [Prim(Var("j"), Int(1), Add, kind=None)]), Unit)
// [Typer] infer: App(Var("loop_j"), targs=None, [Prim(Var("j"), Int(1), Add, kind=None)])
// [Typer] inst: TypeScheme(([], (Int) -> Var(None)))
// [Typer] inst result: (Int) -> Var(None)
// [Typer] check: Prim(Var("j"), Int(1), Add, kind=None) against Int
// [Typer] check: Var("j") against Int
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] check: Int(1) against Int
// [Typer] unify: Var(None) and Var(None)
// [Typer] union: Var(None) and Var(None)
// [Typer] infer: Unit
// [Typer] infer: Unit
// [Typer] unify: Unit and Unit
// [Typer] unify: Var(None) and Unit
// [Typer] union: Var(None) and Unit
// [Typer] infer: Unit
// [Typer] unify: Unit and Var(None)
// [Typer] union: Unit and Var(None)
// [Typer] infer: Let(("_", Var(None)), App(Var("loop_j"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Unit))
// [Typer] infer: App(Var("loop_j"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)])
// [Typer] inst: TypeScheme(([], (Int) -> Unit))
// [Typer] inst result: (Int) -> Unit
// [Typer] check: Prim(Var("i"), Int(1), Add, kind=None) against Int
// [Typer] check: Var("i") against Int
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] check: Int(1) against Int
// [Typer] unify: Var(None) and Unit
// [Typer] union: Var(None) and Unit
// [Typer] infer: Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Unit)
// [Typer] infer: App(Var("loop_i"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)])
// [Typer] inst: TypeScheme(([], (Int) -> Var(None)))
// [Typer] inst result: (Int) -> Var(None)
// [Typer] check: Prim(Var("i"), Int(1), Add, kind=None) against Int
// [Typer] check: Var("i") against Int
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] check: Int(1) against Int
// [Typer] unify: Var(None) and Var(None)
// [Typer] union: Var(None) and Var(None)
// [Typer] infer: Unit
// [Typer] infer: Unit
// [Typer] unify: Unit and Unit
// [Typer] unify: Var(None) and Unit
// [Typer] union: Var(None) and Unit
// [Typer] infer: Unit
// [Typer] unify: Unit and Var(None)
// [Typer] union: Unit and Var(None)
// [Typer] check: Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Int(0)]), LetRec({tyvars: [], name: ("update_axis", Var(None)), args: [("i", Int)], body: Let(("_", Var(None)), If(LE(Var("i"), Prim(Var("n"), Int(1), Sub, kind=None)), Let(("b", Var(None)), Get(Var("bodies"), Var("i")), LetTuple([("bx", Var(None)), ("by", Var(None)), ("bz", Var(None)), ("bvx", Var(None)), ("bvy", Var(None)), ("bvz", Var(None)), ("bm", Var(None))], Var("b"), Let(("new_b", Var(None)), Tuple([Prim(Var("bx"), Prim(Var("dt"), Var("bvx"), Mul, kind=None), Add, kind=None), Prim(Var("by"), Prim(Var("dt"), Var("bvy"), Mul, kind=None), Add, kind=None), Prim(Var("bz"), Prim(Var("dt"), Var("bvz"), Mul, kind=None), Add, kind=None), Var("bvx"), Var("bvy"), Var("bvz"), Var("bm")]), Let(("_", Var(None)), Put(Var("bodies"), Var("i"), Var("new_b")), Let(("_", Var(None)), App(Var("update_axis"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Unit))))), Unit), Unit)}, Let(("_", Var(None)), App(Var("update_axis"), targs=None, [Int(0)]), Unit))) against Unit
// [Typer] infer: App(Var("loop_i"), targs=None, [Int(0)])
// [Typer] inst: TypeScheme(([], (Int) -> Unit))
// [Typer] inst result: (Int) -> Unit
// [Typer] check: Int(0) against Int
// [Typer] unify: Var(None) and Unit
// [Typer] union: Var(None) and Unit
// [Typer] check: LetRec({tyvars: [], name: ("update_axis", Var(None)), args: [("i", Int)], body: Let(("_", Var(None)), If(LE(Var("i"), Prim(Var("n"), Int(1), Sub, kind=None)), Let(("b", Var(None)), Get(Var("bodies"), Var("i")), LetTuple([("bx", Var(None)), ("by", Var(None)), ("bz", Var(None)), ("bvx", Var(None)), ("bvy", Var(None)), ("bvz", Var(None)), ("bm", Var(None))], Var("b"), Let(("new_b", Var(None)), Tuple([Prim(Var("bx"), Prim(Var("dt"), Var("bvx"), Mul, kind=None), Add, kind=None), Prim(Var("by"), Prim(Var("dt"), Var("bvy"), Mul, kind=None), Add, kind=None), Prim(Var("bz"), Prim(Var("dt"), Var("bvz"), Mul, kind=None), Add, kind=None), Var("bvx"), Var("bvy"), Var("bvz"), Var("bm")]), Let(("_", Var(None)), Put(Var("bodies"), Var("i"), Var("new_b")), Let(("_", Var(None)), App(Var("update_axis"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Unit))))), Unit), Unit)}, Let(("_", Var(None)), App(Var("update_axis"), targs=None, [Int(0)]), Unit)) against Unit
// [Typer] typevars: []
// [Typer] infer: Let(("_", Var(None)), If(LE(Var("i"), Prim(Var("n"), Int(1), Sub, kind=None)), Let(("b", Var(None)), Get(Var("bodies"), Var("i")), LetTuple([("bx", Var(None)), ("by", Var(None)), ("bz", Var(None)), ("bvx", Var(None)), ("bvy", Var(None)), ("bvz", Var(None)), ("bm", Var(None))], Var("b"), Let(("new_b", Var(None)), Tuple([Prim(Var("bx"), Prim(Var("dt"), Var("bvx"), Mul, kind=None), Add, kind=None), Prim(Var("by"), Prim(Var("dt"), Var("bvy"), Mul, kind=None), Add, kind=None), Prim(Var("bz"), Prim(Var("dt"), Var("bvz"), Mul, kind=None), Add, kind=None), Var("bvx"), Var("bvy"), Var("bvz"), Var("bm")]), Let(("_", Var(None)), Put(Var("bodies"), Var("i"), Var("new_b")), Let(("_", Var(None)), App(Var("update_axis"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Unit))))), Unit), Unit)
// [Typer] infer: If(LE(Var("i"), Prim(Var("n"), Int(1), Sub, kind=None)), Let(("b", Var(None)), Get(Var("bodies"), Var("i")), LetTuple([("bx", Var(None)), ("by", Var(None)), ("bz", Var(None)), ("bvx", Var(None)), ("bvy", Var(None)), ("bvz", Var(None)), ("bm", Var(None))], Var("b"), Let(("new_b", Var(None)), Tuple([Prim(Var("bx"), Prim(Var("dt"), Var("bvx"), Mul, kind=None), Add, kind=None), Prim(Var("by"), Prim(Var("dt"), Var("bvy"), Mul, kind=None), Add, kind=None), Prim(Var("bz"), Prim(Var("dt"), Var("bvz"), Mul, kind=None), Add, kind=None), Var("bvx"), Var("bvy"), Var("bvz"), Var("bm")]), Let(("_", Var(None)), Put(Var("bodies"), Var("i"), Var("new_b")), Let(("_", Var(None)), App(Var("update_axis"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Unit))))), Unit)
// [Typer] check: LE(Var("i"), Prim(Var("n"), Int(1), Sub, kind=None)) against Bool
// [Typer] infer: Var("i")
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] infer: Prim(Var("n"), Int(1), Sub, kind=None)
// [Typer] infer: Var("n")
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] infer: Int(1)
// [Typer] unify: Int and Int
// [Typer] unify: Int and Int
// [Typer] infer: Let(("b", Var(None)), Get(Var("bodies"), Var("i")), LetTuple([("bx", Var(None)), ("by", Var(None)), ("bz", Var(None)), ("bvx", Var(None)), ("bvy", Var(None)), ("bvz", Var(None)), ("bm", Var(None))], Var("b"), Let(("new_b", Var(None)), Tuple([Prim(Var("bx"), Prim(Var("dt"), Var("bvx"), Mul, kind=None), Add, kind=None), Prim(Var("by"), Prim(Var("dt"), Var("bvy"), Mul, kind=None), Add, kind=None), Prim(Var("bz"), Prim(Var("dt"), Var("bvz"), Mul, kind=None), Add, kind=None), Var("bvx"), Var("bvy"), Var("bvz"), Var("bm")]), Let(("_", Var(None)), Put(Var("bodies"), Var("i"), Var("new_b")), Let(("_", Var(None)), App(Var("update_axis"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Unit)))))
// [Typer] infer: Get(Var("bodies"), Var("i"))
// [Typer] infer: Var("bodies")
// [Typer] inst: TypeScheme(([], Array[(Double, Double, Double, Double, Double, Double, Double)]))
// [Typer] inst result: Array[(Double, Double, Double, Double, Double, Double, Double)]
// [Typer] check: Var("i") against Int
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] unify: Var(None) and (Double, Double, Double, Double, Double, Double, Double)
// [Typer] union: Var(None) and (Double, Double, Double, Double, Double, Double, Double)
// [Typer] infer: LetTuple([("bx", Var(None)), ("by", Var(None)), ("bz", Var(None)), ("bvx", Var(None)), ("bvy", Var(None)), ("bvz", Var(None)), ("bm", Var(None))], Var("b"), Let(("new_b", Var(None)), Tuple([Prim(Var("bx"), Prim(Var("dt"), Var("bvx"), Mul, kind=None), Add, kind=None), Prim(Var("by"), Prim(Var("dt"), Var("bvy"), Mul, kind=None), Add, kind=None), Prim(Var("bz"), Prim(Var("dt"), Var("bvz"), Mul, kind=None), Add, kind=None), Var("bvx"), Var("bvy"), Var("bvz"), Var("bm")]), Let(("_", Var(None)), Put(Var("bodies"), Var("i"), Var("new_b")), Let(("_", Var(None)), App(Var("update_axis"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Unit))))
// [Typer] infer: Var("b")
// [Typer] inst: TypeScheme(([], (Double, Double, Double, Double, Double, Double, Double)))
// [Typer] inst result: (Double, Double, Double, Double, Double, Double, Double)
// [Typer] unify: Var(None) and Double
// [Typer] union: Var(None) and Double
// [Typer] unify: Var(None) and Double
// [Typer] union: Var(None) and Double
// [Typer] unify: Var(None) and Double
// [Typer] union: Var(None) and Double
// [Typer] unify: Var(None) and Double
// [Typer] union: Var(None) and Double
// [Typer] unify: Var(None) and Double
// [Typer] union: Var(None) and Double
// [Typer] unify: Var(None) and Double
// [Typer] union: Var(None) and Double
// [Typer] unify: Var(None) and Double
// [Typer] union: Var(None) and Double
// [Typer] infer: Let(("new_b", Var(None)), Tuple([Prim(Var("bx"), Prim(Var("dt"), Var("bvx"), Mul, kind=None), Add, kind=None), Prim(Var("by"), Prim(Var("dt"), Var("bvy"), Mul, kind=None), Add, kind=None), Prim(Var("bz"), Prim(Var("dt"), Var("bvz"), Mul, kind=None), Add, kind=None), Var("bvx"), Var("bvy"), Var("bvz"), Var("bm")]), Let(("_", Var(None)), Put(Var("bodies"), Var("i"), Var("new_b")), Let(("_", Var(None)), App(Var("update_axis"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Unit)))
// [Typer] infer: Tuple([Prim(Var("bx"), Prim(Var("dt"), Var("bvx"), Mul, kind=None), Add, kind=None), Prim(Var("by"), Prim(Var("dt"), Var("bvy"), Mul, kind=None), Add, kind=None), Prim(Var("bz"), Prim(Var("dt"), Var("bvz"), Mul, kind=None), Add, kind=None), Var("bvx"), Var("bvy"), Var("bvz"), Var("bm")])
// [Typer] infer: Prim(Var("bx"), Prim(Var("dt"), Var("bvx"), Mul, kind=None), Add, kind=None)
// [Typer] infer: Var("bx")
// [Typer] inst: TypeScheme(([], Double))
// [Typer] inst result: Double
// [Typer] infer: Prim(Var("dt"), Var("bvx"), Mul, kind=None)
// [Typer] infer: Var("dt")
// [Typer] inst: TypeScheme(([], Double))
// [Typer] inst result: Double
// [Typer] infer: Var("bvx")
// [Typer] inst: TypeScheme(([], Double))
// [Typer] inst result: Double
// [Typer] unify: Double and Double
// [Typer] unify: Double and Double
// [Typer] infer: Prim(Var("by"), Prim(Var("dt"), Var("bvy"), Mul, kind=None), Add, kind=None)
// [Typer] infer: Var("by")
// [Typer] inst: TypeScheme(([], Double))
// [Typer] inst result: Double
// [Typer] infer: Prim(Var("dt"), Var("bvy"), Mul, kind=None)
// [Typer] infer: Var("dt")
// [Typer] inst: TypeScheme(([], Double))
// [Typer] inst result: Double
// [Typer] infer: Var("bvy")
// [Typer] inst: TypeScheme(([], Double))
// [Typer] inst result: Double
// [Typer] unify: Double and Double
// [Typer] unify: Double and Double
// [Typer] infer: Prim(Var("bz"), Prim(Var("dt"), Var("bvz"), Mul, kind=None), Add, kind=None)
// [Typer] infer: Var("bz")
// [Typer] inst: TypeScheme(([], Double))
// [Typer] inst result: Double
// [Typer] infer: Prim(Var("dt"), Var("bvz"), Mul, kind=None)
// [Typer] infer: Var("dt")
// [Typer] inst: TypeScheme(([], Double))
// [Typer] inst result: Double
// [Typer] infer: Var("bvz")
// [Typer] inst: TypeScheme(([], Double))
// [Typer] inst result: Double
// [Typer] unify: Double and Double
// [Typer] unify: Double and Double
// [Typer] infer: Var("bvx")
// [Typer] inst: TypeScheme(([], Double))
// [Typer] inst result: Double
// [Typer] infer: Var("bvy")
// [Typer] inst: TypeScheme(([], Double))
// [Typer] inst result: Double
// [Typer] infer: Var("bvz")
// [Typer] inst: TypeScheme(([], Double))
// [Typer] inst result: Double
// [Typer] infer: Var("bm")
// [Typer] inst: TypeScheme(([], Double))
// [Typer] inst result: Double
// [Typer] unify: Var(None) and (Double, Double, Double, Double, Double, Double, Double)
// [Typer] union: Var(None) and (Double, Double, Double, Double, Double, Double, Double)
// [Typer] infer: Let(("_", Var(None)), Put(Var("bodies"), Var("i"), Var("new_b")), Let(("_", Var(None)), App(Var("update_axis"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Unit))
// [Typer] infer: Put(Var("bodies"), Var("i"), Var("new_b"))
// [Typer] infer: Var("new_b")
// [Typer] inst: TypeScheme(([], (Double, Double, Double, Double, Double, Double, Double)))
// [Typer] inst result: (Double, Double, Double, Double, Double, Double, Double)
// [Typer] check: Var("bodies") against Array[(Double, Double, Double, Double, Double, Double, Double)]
// [Typer] inst: TypeScheme(([], Array[(Double, Double, Double, Double, Double, Double, Double)]))
// [Typer] inst result: Array[(Double, Double, Double, Double, Double, Double, Double)]
// [Typer] unify: Array[(Double, Double, Double, Double, Double, Double, Double)] and Array[(Double, Double, Double, Double, Double, Double, Double)]
// [Typer] unify: (Double, Double, Double, Double, Double, Double, Double) and (Double, Double, Double, Double, Double, Double, Double)
// [Typer] unify: Double and Double
// [Typer] unify: Double and Double
// [Typer] unify: Double and Double
// [Typer] unify: Double and Double
// [Typer] unify: Double and Double
// [Typer] unify: Double and Double
// [Typer] unify: Double and Double
// [Typer] check: Var("i") against Int
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] unify: Var(None) and Unit
// [Typer] union: Var(None) and Unit
// [Typer] infer: Let(("_", Var(None)), App(Var("update_axis"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Unit)
// [Typer] infer: App(Var("update_axis"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)])
// [Typer] inst: TypeScheme(([], (Int) -> Var(None)))
// [Typer] inst result: (Int) -> Var(None)
// [Typer] check: Prim(Var("i"), Int(1), Add, kind=None) against Int
// [Typer] check: Var("i") against Int
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] check: Int(1) against Int
// [Typer] unify: Var(None) and Var(None)
// [Typer] union: Var(None) and Var(None)
// [Typer] infer: Unit
// [Typer] infer: Unit
// [Typer] unify: Unit and Unit
// [Typer] unify: Var(None) and Unit
// [Typer] union: Var(None) and Unit
// [Typer] infer: Unit
// [Typer] unify: Unit and Var(None)
// [Typer] union: Unit and Var(None)
// [Typer] check: Let(("_", Var(None)), App(Var("update_axis"), targs=None, [Int(0)]), Unit) against Unit
// [Typer] infer: App(Var("update_axis"), targs=None, [Int(0)])
// [Typer] inst: TypeScheme(([], (Int) -> Unit))
// [Typer] inst result: (Int) -> Unit
// [Typer] check: Int(0) against Int
// [Typer] unify: Var(None) and Unit
// [Typer] union: Var(None) and Unit
// [Typer] check: Unit against Unit
// [Typer] check: LetRec({tyvars: [], name: ("energy", Double), args: [("bodies", Array[(Double, Double, Double, Double, Double, Double, Double)])], body: Let(("n", Var(None)), Int(5), Let(("e", Var(None)), Array(Int(1), Double(0)), LetRec({tyvars: [], name: ("loop_i", Var(None)), args: [("i", Int)], body: Let(("_", Var(None)), If(LE(Var("i"), Prim(Var("n"), Int(1), Sub, kind=None)), Let(("b", Var(None)), Get(Var("bodies"), Var("i")), LetTuple([("bx", Var(None)), ("by", Var(None)), ("bz", Var(None)), ("bvx", Var(None)), ("bvy", Var(None)), ("bvz", Var(None)), ("bm", Var(None))], Var("b"), Let(("_", Var(None)), Put(Var("e"), Int(0), Prim(Get(Var("e"), Int(0)), Prim(Prim(Double(0.5), Var("bm"), Mul, kind=None), Prim(Prim(Prim(Var("bvx"), Var("bvx"), Mul, kind=None), Prim(Var("bvy"), Var("bvy"), Mul, kind=None), Add, kind=None), Prim(Var("bvz"), Var("bvz"), Mul, kind=None), Add, kind=None), Mul, kind=None), Add, kind=None)), LetRec({tyvars: [], name: ("loop_j", Var(None)), args: [("j", Int)], body: Let(("_", Var(None)), If(LE(Var("j"), Prim(Var("n"), Int(1), Sub, kind=None)), Let(("b2", Var(None)), Get(Var("bodies"), Var("j")), LetTuple([("b2x", Var(None)), ("b2y", Var(None)), ("b2z", Var(None)), ("b2vx", Var(None)), ("b2vy", Var(None)), ("b2vz", Var(None)), ("b2m", Var(None))], Var("b2"), Let(("dx", Var(None)), Prim(Var("bx"), Var("b2x"), Sub, kind=None), Let(("dy", Var(None)), Prim(Var("by"), Var("b2y"), Sub, kind=None), Let(("dz", Var(None)), Prim(Var("bz"), Var("b2z"), Sub, kind=None), Let(("dist2", Var(None)), Prim(Prim(Prim(Var("dx"), Var("dx"), Mul, kind=None), Prim(Var("dy"), Var("dy"), Mul, kind=None), Add, kind=None), Prim(Var("dz"), Var("dz"), Mul, kind=None), Add, kind=None), Let(("_", Var(None)), Put(Var("e"), Int(0), Prim(Get(Var("e"), Int(0)), Prim(Prim(Var("bm"), Var("b2m"), Mul, kind=None), App(Var("sqrt"), targs=None, [Var("dist2")]), Div, kind=None), Sub, kind=None)), Let(("_", Var(None)), App(Var("loop_j"), targs=None, [Prim(Var("j"), Int(1), Add, kind=None)]), Unit)))))))), Unit), Unit)}, Let(("_", Var(None)), App(Var("loop_j"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Unit)))))), Unit), Unit)}, Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Int(0)]), Get(Var("e"), Int(0))))))}, LetRec({tyvars: [], name: ("offset_momentum", Unit), args: [("bodies", Array[(Double, Double, Double, Double, Double, Double, Double)])], body: Let(("n", Var(None)), Int(5), Let(("px", Var(None)), Array(Int(1), Double(0)), Let(("py", Var(None)), Array(Int(1), Double(0)), Let(("pz", Var(None)), Array(Int(1), Double(0)), LetRec({tyvars: [], name: ("loop_i", Var(None)), args: [("i", Int)], body: Let(("_", Var(None)), If(LE(Var("i"), Prim(Var("n"), Int(1), Sub, kind=None)), Let(("b", Var(None)), Get(Var("bodies"), Var("i")), LetTuple([("bx", Var(None)), ("by", Var(None)), ("bz", Var(None)), ("bvx", Var(None)), ("bvy", Var(None)), ("bvz", Var(None)), ("bm", Var(None))], Var("b"), Let(("_", Var(None)), Put(Var("px"), Int(0), Prim(Get(Var("px"), Int(0)), Prim(Var("bvx"), Var("bm"), Mul, kind=None), Add, kind=None)), Let(("_", Var(None)), Put(Var("py"), Int(0), Prim(Get(Var("py"), Int(0)), Prim(Var("bvy"), Var("bm"), Mul, kind=None), Add, kind=None)), Let(("_", Var(None)), Put(Var("pz"), Int(0), Prim(Get(Var("pz"), Int(0)), Prim(Var("bvz"), Var("bm"), Mul, kind=None), Add, kind=None)), Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Unit)))))), Unit), Unit)}, Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Int(0)]), Let(("b", Var(None)), Get(Var("bodies"), Int(0)), LetTuple([("bx", Var(None)), ("by", Var(None)), ("bz", Var(None)), ("bvx", Var(None)), ("bvy", Var(None)), ("bvz", Var(None)), ("bm", Var(None))], Var("b"), Let(("new_b", Var(None)), Tuple([Var("bx"), Var("by"), Var("bz"), Neg(Prim(Get(Var("px"), Int(0)), Var("solar_mass"), Div, kind=None), kind=None), Neg(Prim(Get(Var("py"), Int(0)), Var("solar_mass"), Div, kind=None), kind=None), Neg(Prim(Get(Var("pz"), Int(0)), Var("solar_mass"), Div, kind=None), kind=None), Var("bm")]), Let(("_", Var(None)), Put(Var("bodies"), Int(0), Var("new_b")), Unit))))))))))}, LetRec({tyvars: [], name: ("main", Var(None)), args: [], body: Let(("jupiter", Var(None)), Tuple([Double(4.841431442464721), Neg(Double(1.1603200440274284), kind=None), Neg(Double(0.10362204447112311), kind=None), Prim(Double(0.001660076642744037), Var("days_per_year"), Mul, kind=None), Prim(Double(0.007699011184197404), Var("days_per_year"), Mul, kind=None), Neg(Prim(Double(0.0000690460016972063), Var("days_per_year"), Mul, kind=None), kind=None), Prim(Double(0.0009547919384243266), Var("solar_mass"), Mul, kind=None)]), Let(("saturn", Var(None)), Tuple([Double(8.34336671824458), Double(4.124798564124305), Neg(Double(0.4035234171143214), kind=None), Neg(Prim(Double(0.002767425107268624), Var("days_per_year"), Mul, kind=None), kind=None), Prim(Double(0.004998528012349172), Var("days_per_year"), Mul, kind=None), Prim(Double(0.000023029345528229068), Var("days_per_year"), Mul, kind=None), Prim(Double(0.0002858859806661308), Var("solar_mass"), Mul, kind=None)]), Let(("uranus", Var(None)), Tuple([Double(12.894369562139131), Neg(Double(15.111151401698631), kind=None), Neg(Double(0.22330757889265587), kind=None), Prim(Double(0.002964601375647616), Var("days_per_year"), Mul, kind=None), Prim(Double(0.0023784717395948095), Var("days_per_year"), Mul, kind=None), Neg(Prim(Double(0.000029658956854023756), Var("days_per_year"), Mul, kind=None), kind=None), Prim(Double(0.00004366244043351563), Var("solar_mass"), Mul, kind=None)]), Let(("neptune", Var(None)), Tuple([Double(15.379697114850917), Neg(Double(25.919314609987964), kind=None), Double(0.17925877295037118), Prim(Double(0.0026806777249038932), Var("days_per_year"), Mul, kind=None), Prim(Double(0.001628241700382423), Var("days_per_year"), Mul, kind=None), Neg(Prim(Double(0.00009515922545197159), Var("days_per_year"), Mul, kind=None), kind=None), Prim(Double(0.00005151389020466116), Var("solar_mass"), Mul, kind=None)]), Let(("sun", Var(None)), Tuple([Double(0), Double(0), Double(0), Double(0), Double(0), Double(0), Var("solar_mass")]), Let(("bodies", Var(None)), Array(Int(5), Tuple([Double(0), Double(0), Double(0), Double(0), Double(0), Double(0), Double(0)])), Let(("_", Var(None)), Put(Var("bodies"), Int(0), Var("sun")), Let(("_", Var(None)), Put(Var("bodies"), Int(1), Var("jupiter")), Let(("_", Var(None)), Put(Var("bodies"), Int(2), Var("saturn")), Let(("_", Var(None)), Put(Var("bodies"), Int(3), Var("uranus")), Let(("_", Var(None)), Put(Var("bodies"), Int(4), Var("neptune")), Let(("_", Var(None)), App(Var("offset_momentum"), targs=None, [Var("bodies")]), Let(("_", Var(None)), App(Var("print_int"), targs=None, [App(Var("int_of_float"), targs=None, [Prim(App(Var("energy"), targs=None, [Var("bodies")]), Double(1000000000), Mul, kind=None)])]), Let(("iters", Var(None)), Int(500000), LetRec({tyvars: [], name: ("loop_i", Var(None)), args: [("i", Int)], body: Let(("_", Var(None)), If(LE(Var("i"), Var("iters")), Let(("_", Var(None)), App(Var("advance"), targs=None, [Var("bodies"), Double(0.01)]), Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Unit)), Unit), Unit)}, Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Int(1)]), Let(("_", Var(None)), App(Var("print_char"), targs=None, [Int(10)]), Let(("_", Var(None)), App(Var("print_int"), targs=None, [App(Var("int_of_float"), targs=None, [Prim(App(Var("energy"), targs=None, [Var("bodies")]), Double(1000000000), Mul, kind=None)])]), Unit))))))))))))))))))}, Unit))) against Unit
// [Typer] typevars: []
// [Typer] check: Let(("n", Var(None)), Int(5), Let(("e", Var(None)), Array(Int(1), Double(0)), LetRec({tyvars: [], name: ("loop_i", Var(None)), args: [("i", Int)], body: Let(("_", Var(None)), If(LE(Var("i"), Prim(Var("n"), Int(1), Sub, kind=None)), Let(("b", Var(None)), Get(Var("bodies"), Var("i")), LetTuple([("bx", Var(None)), ("by", Var(None)), ("bz", Var(None)), ("bvx", Var(None)), ("bvy", Var(None)), ("bvz", Var(None)), ("bm", Var(None))], Var("b"), Let(("_", Var(None)), Put(Var("e"), Int(0), Prim(Get(Var("e"), Int(0)), Prim(Prim(Double(0.5), Var("bm"), Mul, kind=None), Prim(Prim(Prim(Var("bvx"), Var("bvx"), Mul, kind=None), Prim(Var("bvy"), Var("bvy"), Mul, kind=None), Add, kind=None), Prim(Var("bvz"), Var("bvz"), Mul, kind=None), Add, kind=None), Mul, kind=None), Add, kind=None)), LetRec({tyvars: [], name: ("loop_j", Var(None)), args: [("j", Int)], body: Let(("_", Var(None)), If(LE(Var("j"), Prim(Var("n"), Int(1), Sub, kind=None)), Let(("b2", Var(None)), Get(Var("bodies"), Var("j")), LetTuple([("b2x", Var(None)), ("b2y", Var(None)), ("b2z", Var(None)), ("b2vx", Var(None)), ("b2vy", Var(None)), ("b2vz", Var(None)), ("b2m", Var(None))], Var("b2"), Let(("dx", Var(None)), Prim(Var("bx"), Var("b2x"), Sub, kind=None), Let(("dy", Var(None)), Prim(Var("by"), Var("b2y"), Sub, kind=None), Let(("dz", Var(None)), Prim(Var("bz"), Var("b2z"), Sub, kind=None), Let(("dist2", Var(None)), Prim(Prim(Prim(Var("dx"), Var("dx"), Mul, kind=None), Prim(Var("dy"), Var("dy"), Mul, kind=None), Add, kind=None), Prim(Var("dz"), Var("dz"), Mul, kind=None), Add, kind=None), Let(("_", Var(None)), Put(Var("e"), Int(0), Prim(Get(Var("e"), Int(0)), Prim(Prim(Var("bm"), Var("b2m"), Mul, kind=None), App(Var("sqrt"), targs=None, [Var("dist2")]), Div, kind=None), Sub, kind=None)), Let(("_", Var(None)), App(Var("loop_j"), targs=None, [Prim(Var("j"), Int(1), Add, kind=None)]), Unit)))))))), Unit), Unit)}, Let(("_", Var(None)), App(Var("loop_j"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Unit)))))), Unit), Unit)}, Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Int(0)]), Get(Var("e"), Int(0)))))) against Double
// [Typer] infer: Int(5)
// [Typer] unify: Var(None) and Int
// [Typer] union: Var(None) and Int
// [Typer] check: Let(("e", Var(None)), Array(Int(1), Double(0)), LetRec({tyvars: [], name: ("loop_i", Var(None)), args: [("i", Int)], body: Let(("_", Var(None)), If(LE(Var("i"), Prim(Var("n"), Int(1), Sub, kind=None)), Let(("b", Var(None)), Get(Var("bodies"), Var("i")), LetTuple([("bx", Var(None)), ("by", Var(None)), ("bz", Var(None)), ("bvx", Var(None)), ("bvy", Var(None)), ("bvz", Var(None)), ("bm", Var(None))], Var("b"), Let(("_", Var(None)), Put(Var("e"), Int(0), Prim(Get(Var("e"), Int(0)), Prim(Prim(Double(0.5), Var("bm"), Mul, kind=None), Prim(Prim(Prim(Var("bvx"), Var("bvx"), Mul, kind=None), Prim(Var("bvy"), Var("bvy"), Mul, kind=None), Add, kind=None), Prim(Var("bvz"), Var("bvz"), Mul, kind=None), Add, kind=None), Mul, kind=None), Add, kind=None)), LetRec({tyvars: [], name: ("loop_j", Var(None)), args: [("j", Int)], body: Let(("_", Var(None)), If(LE(Var("j"), Prim(Var("n"), Int(1), Sub, kind=None)), Let(("b2", Var(None)), Get(Var("bodies"), Var("j")), LetTuple([("b2x", Var(None)), ("b2y", Var(None)), ("b2z", Var(None)), ("b2vx", Var(None)), ("b2vy", Var(None)), ("b2vz", Var(None)), ("b2m", Var(None))], Var("b2"), Let(("dx", Var(None)), Prim(Var("bx"), Var("b2x"), Sub, kind=None), Let(("dy", Var(None)), Prim(Var("by"), Var("b2y"), Sub, kind=None), Let(("dz", Var(None)), Prim(Var("bz"), Var("b2z"), Sub, kind=None), Let(("dist2", Var(None)), Prim(Prim(Prim(Var("dx"), Var("dx"), Mul, kind=None), Prim(Var("dy"), Var("dy"), Mul, kind=None), Add, kind=None), Prim(Var("dz"), Var("dz"), Mul, kind=None), Add, kind=None), Let(("_", Var(None)), Put(Var("e"), Int(0), Prim(Get(Var("e"), Int(0)), Prim(Prim(Var("bm"), Var("b2m"), Mul, kind=None), App(Var("sqrt"), targs=None, [Var("dist2")]), Div, kind=None), Sub, kind=None)), Let(("_", Var(None)), App(Var("loop_j"), targs=None, [Prim(Var("j"), Int(1), Add, kind=None)]), Unit)))))))), Unit), Unit)}, Let(("_", Var(None)), App(Var("loop_j"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Unit)))))), Unit), Unit)}, Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Int(0)]), Get(Var("e"), Int(0))))) against Double
// [Typer] infer: Array(Int(1), Double(0))
// [Typer] infer: Double(0)
// [Typer] check: Int(1) against Int
// [Typer] unify: Var(None) and Array[Double]
// [Typer] union: Var(None) and Array[Double]
// [Typer] check: LetRec({tyvars: [], name: ("loop_i", Var(None)), args: [("i", Int)], body: Let(("_", Var(None)), If(LE(Var("i"), Prim(Var("n"), Int(1), Sub, kind=None)), Let(("b", Var(None)), Get(Var("bodies"), Var("i")), LetTuple([("bx", Var(None)), ("by", Var(None)), ("bz", Var(None)), ("bvx", Var(None)), ("bvy", Var(None)), ("bvz", Var(None)), ("bm", Var(None))], Var("b"), Let(("_", Var(None)), Put(Var("e"), Int(0), Prim(Get(Var("e"), Int(0)), Prim(Prim(Double(0.5), Var("bm"), Mul, kind=None), Prim(Prim(Prim(Var("bvx"), Var("bvx"), Mul, kind=None), Prim(Var("bvy"), Var("bvy"), Mul, kind=None), Add, kind=None), Prim(Var("bvz"), Var("bvz"), Mul, kind=None), Add, kind=None), Mul, kind=None), Add, kind=None)), LetRec({tyvars: [], name: ("loop_j", Var(None)), args: [("j", Int)], body: Let(("_", Var(None)), If(LE(Var("j"), Prim(Var("n"), Int(1), Sub, kind=None)), Let(("b2", Var(None)), Get(Var("bodies"), Var("j")), LetTuple([("b2x", Var(None)), ("b2y", Var(None)), ("b2z", Var(None)), ("b2vx", Var(None)), ("b2vy", Var(None)), ("b2vz", Var(None)), ("b2m", Var(None))], Var("b2"), Let(("dx", Var(None)), Prim(Var("bx"), Var("b2x"), Sub, kind=None), Let(("dy", Var(None)), Prim(Var("by"), Var("b2y"), Sub, kind=None), Let(("dz", Var(None)), Prim(Var("bz"), Var("b2z"), Sub, kind=None), Let(("dist2", Var(None)), Prim(Prim(Prim(Var("dx"), Var("dx"), Mul, kind=None), Prim(Var("dy"), Var("dy"), Mul, kind=None), Add, kind=None), Prim(Var("dz"), Var("dz"), Mul, kind=None), Add, kind=None), Let(("_", Var(None)), Put(Var("e"), Int(0), Prim(Get(Var("e"), Int(0)), Prim(Prim(Var("bm"), Var("b2m"), Mul, kind=None), App(Var("sqrt"), targs=None, [Var("dist2")]), Div, kind=None), Sub, kind=None)), Let(("_", Var(None)), App(Var("loop_j"), targs=None, [Prim(Var("j"), Int(1), Add, kind=None)]), Unit)))))))), Unit), Unit)}, Let(("_", Var(None)), App(Var("loop_j"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Unit)))))), Unit), Unit)}, Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Int(0)]), Get(Var("e"), Int(0)))) against Double
// [Typer] typevars: []
// [Typer] infer: Let(("_", Var(None)), If(LE(Var("i"), Prim(Var("n"), Int(1), Sub, kind=None)), Let(("b", Var(None)), Get(Var("bodies"), Var("i")), LetTuple([("bx", Var(None)), ("by", Var(None)), ("bz", Var(None)), ("bvx", Var(None)), ("bvy", Var(None)), ("bvz", Var(None)), ("bm", Var(None))], Var("b"), Let(("_", Var(None)), Put(Var("e"), Int(0), Prim(Get(Var("e"), Int(0)), Prim(Prim(Double(0.5), Var("bm"), Mul, kind=None), Prim(Prim(Prim(Var("bvx"), Var("bvx"), Mul, kind=None), Prim(Var("bvy"), Var("bvy"), Mul, kind=None), Add, kind=None), Prim(Var("bvz"), Var("bvz"), Mul, kind=None), Add, kind=None), Mul, kind=None), Add, kind=None)), LetRec({tyvars: [], name: ("loop_j", Var(None)), args: [("j", Int)], body: Let(("_", Var(None)), If(LE(Var("j"), Prim(Var("n"), Int(1), Sub, kind=None)), Let(("b2", Var(None)), Get(Var("bodies"), Var("j")), LetTuple([("b2x", Var(None)), ("b2y", Var(None)), ("b2z", Var(None)), ("b2vx", Var(None)), ("b2vy", Var(None)), ("b2vz", Var(None)), ("b2m", Var(None))], Var("b2"), Let(("dx", Var(None)), Prim(Var("bx"), Var("b2x"), Sub, kind=None), Let(("dy", Var(None)), Prim(Var("by"), Var("b2y"), Sub, kind=None), Let(("dz", Var(None)), Prim(Var("bz"), Var("b2z"), Sub, kind=None), Let(("dist2", Var(None)), Prim(Prim(Prim(Var("dx"), Var("dx"), Mul, kind=None), Prim(Var("dy"), Var("dy"), Mul, kind=None), Add, kind=None), Prim(Var("dz"), Var("dz"), Mul, kind=None), Add, kind=None), Let(("_", Var(None)), Put(Var("e"), Int(0), Prim(Get(Var("e"), Int(0)), Prim(Prim(Var("bm"), Var("b2m"), Mul, kind=None), App(Var("sqrt"), targs=None, [Var("dist2")]), Div, kind=None), Sub, kind=None)), Let(("_", Var(None)), App(Var("loop_j"), targs=None, [Prim(Var("j"), Int(1), Add, kind=None)]), Unit)))))))), Unit), Unit)}, Let(("_", Var(None)), App(Var("loop_j"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Unit)))))), Unit), Unit)
// [Typer] infer: If(LE(Var("i"), Prim(Var("n"), Int(1), Sub, kind=None)), Let(("b", Var(None)), Get(Var("bodies"), Var("i")), LetTuple([("bx", Var(None)), ("by", Var(None)), ("bz", Var(None)), ("bvx", Var(None)), ("bvy", Var(None)), ("bvz", Var(None)), ("bm", Var(None))], Var("b"), Let(("_", Var(None)), Put(Var("e"), Int(0), Prim(Get(Var("e"), Int(0)), Prim(Prim(Double(0.5), Var("bm"), Mul, kind=None), Prim(Prim(Prim(Var("bvx"), Var("bvx"), Mul, kind=None), Prim(Var("bvy"), Var("bvy"), Mul, kind=None), Add, kind=None), Prim(Var("bvz"), Var("bvz"), Mul, kind=None), Add, kind=None), Mul, kind=None), Add, kind=None)), LetRec({tyvars: [], name: ("loop_j", Var(None)), args: [("j", Int)], body: Let(("_", Var(None)), If(LE(Var("j"), Prim(Var("n"), Int(1), Sub, kind=None)), Let(("b2", Var(None)), Get(Var("bodies"), Var("j")), LetTuple([("b2x", Var(None)), ("b2y", Var(None)), ("b2z", Var(None)), ("b2vx", Var(None)), ("b2vy", Var(None)), ("b2vz", Var(None)), ("b2m", Var(None))], Var("b2"), Let(("dx", Var(None)), Prim(Var("bx"), Var("b2x"), Sub, kind=None), Let(("dy", Var(None)), Prim(Var("by"), Var("b2y"), Sub, kind=None), Let(("dz", Var(None)), Prim(Var("bz"), Var("b2z"), Sub, kind=None), Let(("dist2", Var(None)), Prim(Prim(Prim(Var("dx"), Var("dx"), Mul, kind=None), Prim(Var("dy"), Var("dy"), Mul, kind=None), Add, kind=None), Prim(Var("dz"), Var("dz"), Mul, kind=None), Add, kind=None), Let(("_", Var(None)), Put(Var("e"), Int(0), Prim(Get(Var("e"), Int(0)), Prim(Prim(Var("bm"), Var("b2m"), Mul, kind=None), App(Var("sqrt"), targs=None, [Var("dist2")]), Div, kind=None), Sub, kind=None)), Let(("_", Var(None)), App(Var("loop_j"), targs=None, [Prim(Var("j"), Int(1), Add, kind=None)]), Unit)))))))), Unit), Unit)}, Let(("_", Var(None)), App(Var("loop_j"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Unit)))))), Unit)
// [Typer] check: LE(Var("i"), Prim(Var("n"), Int(1), Sub, kind=None)) against Bool
// [Typer] infer: Var("i")
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] infer: Prim(Var("n"), Int(1), Sub, kind=None)
// [Typer] infer: Var("n")
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] infer: Int(1)
// [Typer] unify: Int and Int
// [Typer] unify: Int and Int
// [Typer] infer: Let(("b", Var(None)), Get(Var("bodies"), Var("i")), LetTuple([("bx", Var(None)), ("by", Var(None)), ("bz", Var(None)), ("bvx", Var(None)), ("bvy", Var(None)), ("bvz", Var(None)), ("bm", Var(None))], Var("b"), Let(("_", Var(None)), Put(Var("e"), Int(0), Prim(Get(Var("e"), Int(0)), Prim(Prim(Double(0.5), Var("bm"), Mul, kind=None), Prim(Prim(Prim(Var("bvx"), Var("bvx"), Mul, kind=None), Prim(Var("bvy"), Var("bvy"), Mul, kind=None), Add, kind=None), Prim(Var("bvz"), Var("bvz"), Mul, kind=None), Add, kind=None), Mul, kind=None), Add, kind=None)), LetRec({tyvars: [], name: ("loop_j", Var(None)), args: [("j", Int)], body: Let(("_", Var(None)), If(LE(Var("j"), Prim(Var("n"), Int(1), Sub, kind=None)), Let(("b2", Var(None)), Get(Var("bodies"), Var("j")), LetTuple([("b2x", Var(None)), ("b2y", Var(None)), ("b2z", Var(None)), ("b2vx", Var(None)), ("b2vy", Var(None)), ("b2vz", Var(None)), ("b2m", Var(None))], Var("b2"), Let(("dx", Var(None)), Prim(Var("bx"), Var("b2x"), Sub, kind=None), Let(("dy", Var(None)), Prim(Var("by"), Var("b2y"), Sub, kind=None), Let(("dz", Var(None)), Prim(Var("bz"), Var("b2z"), Sub, kind=None), Let(("dist2", Var(None)), Prim(Prim(Prim(Var("dx"), Var("dx"), Mul, kind=None), Prim(Var("dy"), Var("dy"), Mul, kind=None), Add, kind=None), Prim(Var("dz"), Var("dz"), Mul, kind=None), Add, kind=None), Let(("_", Var(None)), Put(Var("e"), Int(0), Prim(Get(Var("e"), Int(0)), Prim(Prim(Var("bm"), Var("b2m"), Mul, kind=None), App(Var("sqrt"), targs=None, [Var("dist2")]), Div, kind=None), Sub, kind=None)), Let(("_", Var(None)), App(Var("loop_j"), targs=None, [Prim(Var("j"), Int(1), Add, kind=None)]), Unit)))))))), Unit), Unit)}, Let(("_", Var(None)), App(Var("loop_j"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Unit))))))
// [Typer] infer: Get(Var("bodies"), Var("i"))
// [Typer] infer: Var("bodies")
// [Typer] inst: TypeScheme(([], Array[(Double, Double, Double, Double, Double, Double, Double)]))
// [Typer] inst result: Array[(Double, Double, Double, Double, Double, Double, Double)]
// [Typer] check: Var("i") against Int
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] unify: Var(None) and (Double, Double, Double, Double, Double, Double, Double)
// [Typer] union: Var(None) and (Double, Double, Double, Double, Double, Double, Double)
// [Typer] infer: LetTuple([("bx", Var(None)), ("by", Var(None)), ("bz", Var(None)), ("bvx", Var(None)), ("bvy", Var(None)), ("bvz", Var(None)), ("bm", Var(None))], Var("b"), Let(("_", Var(None)), Put(Var("e"), Int(0), Prim(Get(Var("e"), Int(0)), Prim(Prim(Double(0.5), Var("bm"), Mul, kind=None), Prim(Prim(Prim(Var("bvx"), Var("bvx"), Mul, kind=None), Prim(Var("bvy"), Var("bvy"), Mul, kind=None), Add, kind=None), Prim(Var("bvz"), Var("bvz"), Mul, kind=None), Add, kind=None), Mul, kind=None), Add, kind=None)), LetRec({tyvars: [], name: ("loop_j", Var(None)), args: [("j", Int)], body: Let(("_", Var(None)), If(LE(Var("j"), Prim(Var("n"), Int(1), Sub, kind=None)), Let(("b2", Var(None)), Get(Var("bodies"), Var("j")), LetTuple([("b2x", Var(None)), ("b2y", Var(None)), ("b2z", Var(None)), ("b2vx", Var(None)), ("b2vy", Var(None)), ("b2vz", Var(None)), ("b2m", Var(None))], Var("b2"), Let(("dx", Var(None)), Prim(Var("bx"), Var("b2x"), Sub, kind=None), Let(("dy", Var(None)), Prim(Var("by"), Var("b2y"), Sub, kind=None), Let(("dz", Var(None)), Prim(Var("bz"), Var("b2z"), Sub, kind=None), Let(("dist2", Var(None)), Prim(Prim(Prim(Var("dx"), Var("dx"), Mul, kind=None), Prim(Var("dy"), Var("dy"), Mul, kind=None), Add, kind=None), Prim(Var("dz"), Var("dz"), Mul, kind=None), Add, kind=None), Let(("_", Var(None)), Put(Var("e"), Int(0), Prim(Get(Var("e"), Int(0)), Prim(Prim(Var("bm"), Var("b2m"), Mul, kind=None), App(Var("sqrt"), targs=None, [Var("dist2")]), Div, kind=None), Sub, kind=None)), Let(("_", Var(None)), App(Var("loop_j"), targs=None, [Prim(Var("j"), Int(1), Add, kind=None)]), Unit)))))))), Unit), Unit)}, Let(("_", Var(None)), App(Var("loop_j"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Unit)))))
// [Typer] infer: Var("b")
// [Typer] inst: TypeScheme(([], (Double, Double, Double, Double, Double, Double, Double)))
// [Typer] inst result: (Double, Double, Double, Double, Double, Double, Double)
// [Typer] unify: Var(None) and Double
// [Typer] union: Var(None) and Double
// [Typer] unify: Var(None) and Double
// [Typer] union: Var(None) and Double
// [Typer] unify: Var(None) and Double
// [Typer] union: Var(None) and Double
// [Typer] unify: Var(None) and Double
// [Typer] union: Var(None) and Double
// [Typer] unify: Var(None) and Double
// [Typer] union: Var(None) and Double
// [Typer] unify: Var(None) and Double
// [Typer] union: Var(None) and Double
// [Typer] unify: Var(None) and Double
// [Typer] union: Var(None) and Double
// [Typer] infer: Let(("_", Var(None)), Put(Var("e"), Int(0), Prim(Get(Var("e"), Int(0)), Prim(Prim(Double(0.5), Var("bm"), Mul, kind=None), Prim(Prim(Prim(Var("bvx"), Var("bvx"), Mul, kind=None), Prim(Var("bvy"), Var("bvy"), Mul, kind=None), Add, kind=None), Prim(Var("bvz"), Var("bvz"), Mul, kind=None), Add, kind=None), Mul, kind=None), Add, kind=None)), LetRec({tyvars: [], name: ("loop_j", Var(None)), args: [("j", Int)], body: Let(("_", Var(None)), If(LE(Var("j"), Prim(Var("n"), Int(1), Sub, kind=None)), Let(("b2", Var(None)), Get(Var("bodies"), Var("j")), LetTuple([("b2x", Var(None)), ("b2y", Var(None)), ("b2z", Var(None)), ("b2vx", Var(None)), ("b2vy", Var(None)), ("b2vz", Var(None)), ("b2m", Var(None))], Var("b2"), Let(("dx", Var(None)), Prim(Var("bx"), Var("b2x"), Sub, kind=None), Let(("dy", Var(None)), Prim(Var("by"), Var("b2y"), Sub, kind=None), Let(("dz", Var(None)), Prim(Var("bz"), Var("b2z"), Sub, kind=None), Let(("dist2", Var(None)), Prim(Prim(Prim(Var("dx"), Var("dx"), Mul, kind=None), Prim(Var("dy"), Var("dy"), Mul, kind=None), Add, kind=None), Prim(Var("dz"), Var("dz"), Mul, kind=None), Add, kind=None), Let(("_", Var(None)), Put(Var("e"), Int(0), Prim(Get(Var("e"), Int(0)), Prim(Prim(Var("bm"), Var("b2m"), Mul, kind=None), App(Var("sqrt"), targs=None, [Var("dist2")]), Div, kind=None), Sub, kind=None)), Let(("_", Var(None)), App(Var("loop_j"), targs=None, [Prim(Var("j"), Int(1), Add, kind=None)]), Unit)))))))), Unit), Unit)}, Let(("_", Var(None)), App(Var("loop_j"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Unit))))
// [Typer] infer: Put(Var("e"), Int(0), Prim(Get(Var("e"), Int(0)), Prim(Prim(Double(0.5), Var("bm"), Mul, kind=None), Prim(Prim(Prim(Var("bvx"), Var("bvx"), Mul, kind=None), Prim(Var("bvy"), Var("bvy"), Mul, kind=None), Add, kind=None), Prim(Var("bvz"), Var("bvz"), Mul, kind=None), Add, kind=None), Mul, kind=None), Add, kind=None))
// [Typer] infer: Prim(Get(Var("e"), Int(0)), Prim(Prim(Double(0.5), Var("bm"), Mul, kind=None), Prim(Prim(Prim(Var("bvx"), Var("bvx"), Mul, kind=None), Prim(Var("bvy"), Var("bvy"), Mul, kind=None), Add, kind=None), Prim(Var("bvz"), Var("bvz"), Mul, kind=None), Add, kind=None), Mul, kind=None), Add, kind=None)
// [Typer] infer: Get(Var("e"), Int(0))
// [Typer] infer: Var("e")
// [Typer] inst: TypeScheme(([], Array[Double]))
// [Typer] inst result: Array[Double]
// [Typer] check: Int(0) against Int
// [Typer] infer: Prim(Prim(Double(0.5), Var("bm"), Mul, kind=None), Prim(Prim(Prim(Var("bvx"), Var("bvx"), Mul, kind=None), Prim(Var("bvy"), Var("bvy"), Mul, kind=None), Add, kind=None), Prim(Var("bvz"), Var("bvz"), Mul, kind=None), Add, kind=None), Mul, kind=None)
// [Typer] infer: Prim(Double(0.5), Var("bm"), Mul, kind=None)
// [Typer] infer: Double(0.5)
// [Typer] infer: Var("bm")
// [Typer] inst: TypeScheme(([], Double))
// [Typer] inst result: Double
// [Typer] unify: Double and Double
// [Typer] infer: Prim(Prim(Prim(Var("bvx"), Var("bvx"), Mul, kind=None), Prim(Var("bvy"), Var("bvy"), Mul, kind=None), Add, kind=None), Prim(Var("bvz"), Var("bvz"), Mul, kind=None), Add, kind=None)
// [Typer] infer: Prim(Prim(Var("bvx"), Var("bvx"), Mul, kind=None), Prim(Var("bvy"), Var("bvy"), Mul, kind=None), Add, kind=None)
// [Typer] infer: Prim(Var("bvx"), Var("bvx"), Mul, kind=None)
// [Typer] infer: Var("bvx")
// [Typer] inst: TypeScheme(([], Double))
// [Typer] inst result: Double
// [Typer] infer: Var("bvx")
// [Typer] inst: TypeScheme(([], Double))
// [Typer] inst result: Double
// [Typer] unify: Double and Double
// [Typer] infer: Prim(Var("bvy"), Var("bvy"), Mul, kind=None)
// [Typer] infer: Var("bvy")
// [Typer] inst: TypeScheme(([], Double))
// [Typer] inst result: Double
// [Typer] infer: Var("bvy")
// [Typer] inst: TypeScheme(([], Double))
// [Typer] inst result: Double
// [Typer] unify: Double and Double
// [Typer] unify: Double and Double
// [Typer] infer: Prim(Var("bvz"), Var("bvz"), Mul, kind=None)
// [Typer] infer: Var("bvz")
// [Typer] inst: TypeScheme(([], Double))
// [Typer] inst result: Double
// [Typer] infer: Var("bvz")
// [Typer] inst: TypeScheme(([], Double))
// [Typer] inst result: Double
// [Typer] unify: Double and Double
// [Typer] unify: Double and Double
// [Typer] unify: Double and Double
// [Typer] unify: Double and Double
// [Typer] check: Var("e") against Array[Double]
// [Typer] inst: TypeScheme(([], Array[Double]))
// [Typer] inst result: Array[Double]
// [Typer] unify: Array[Double] and Array[Double]
// [Typer] unify: Double and Double
// [Typer] check: Int(0) against Int
// [Typer] unify: Var(None) and Unit
// [Typer] union: Var(None) and Unit
// [Typer] infer: LetRec({tyvars: [], name: ("loop_j", Var(None)), args: [("j", Int)], body: Let(("_", Var(None)), If(LE(Var("j"), Prim(Var("n"), Int(1), Sub, kind=None)), Let(("b2", Var(None)), Get(Var("bodies"), Var("j")), LetTuple([("b2x", Var(None)), ("b2y", Var(None)), ("b2z", Var(None)), ("b2vx", Var(None)), ("b2vy", Var(None)), ("b2vz", Var(None)), ("b2m", Var(None))], Var("b2"), Let(("dx", Var(None)), Prim(Var("bx"), Var("b2x"), Sub, kind=None), Let(("dy", Var(None)), Prim(Var("by"), Var("b2y"), Sub, kind=None), Let(("dz", Var(None)), Prim(Var("bz"), Var("b2z"), Sub, kind=None), Let(("dist2", Var(None)), Prim(Prim(Prim(Var("dx"), Var("dx"), Mul, kind=None), Prim(Var("dy"), Var("dy"), Mul, kind=None), Add, kind=None), Prim(Var("dz"), Var("dz"), Mul, kind=None), Add, kind=None), Let(("_", Var(None)), Put(Var("e"), Int(0), Prim(Get(Var("e"), Int(0)), Prim(Prim(Var("bm"), Var("b2m"), Mul, kind=None), App(Var("sqrt"), targs=None, [Var("dist2")]), Div, kind=None), Sub, kind=None)), Let(("_", Var(None)), App(Var("loop_j"), targs=None, [Prim(Var("j"), Int(1), Add, kind=None)]), Unit)))))))), Unit), Unit)}, Let(("_", Var(None)), App(Var("loop_j"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Unit)))
// [Typer] typevars: []
// [Typer] infer: Let(("_", Var(None)), If(LE(Var("j"), Prim(Var("n"), Int(1), Sub, kind=None)), Let(("b2", Var(None)), Get(Var("bodies"), Var("j")), LetTuple([("b2x", Var(None)), ("b2y", Var(None)), ("b2z", Var(None)), ("b2vx", Var(None)), ("b2vy", Var(None)), ("b2vz", Var(None)), ("b2m", Var(None))], Var("b2"), Let(("dx", Var(None)), Prim(Var("bx"), Var("b2x"), Sub, kind=None), Let(("dy", Var(None)), Prim(Var("by"), Var("b2y"), Sub, kind=None), Let(("dz", Var(None)), Prim(Var("bz"), Var("b2z"), Sub, kind=None), Let(("dist2", Var(None)), Prim(Prim(Prim(Var("dx"), Var("dx"), Mul, kind=None), Prim(Var("dy"), Var("dy"), Mul, kind=None), Add, kind=None), Prim(Var("dz"), Var("dz"), Mul, kind=None), Add, kind=None), Let(("_", Var(None)), Put(Var("e"), Int(0), Prim(Get(Var("e"), Int(0)), Prim(Prim(Var("bm"), Var("b2m"), Mul, kind=None), App(Var("sqrt"), targs=None, [Var("dist2")]), Div, kind=None), Sub, kind=None)), Let(("_", Var(None)), App(Var("loop_j"), targs=None, [Prim(Var("j"), Int(1), Add, kind=None)]), Unit)))))))), Unit), Unit)
// [Typer] infer: If(LE(Var("j"), Prim(Var("n"), Int(1), Sub, kind=None)), Let(("b2", Var(None)), Get(Var("bodies"), Var("j")), LetTuple([("b2x", Var(None)), ("b2y", Var(None)), ("b2z", Var(None)), ("b2vx", Var(None)), ("b2vy", Var(None)), ("b2vz", Var(None)), ("b2m", Var(None))], Var("b2"), Let(("dx", Var(None)), Prim(Var("bx"), Var("b2x"), Sub, kind=None), Let(("dy", Var(None)), Prim(Var("by"), Var("b2y"), Sub, kind=None), Let(("dz", Var(None)), Prim(Var("bz"), Var("b2z"), Sub, kind=None), Let(("dist2", Var(None)), Prim(Prim(Prim(Var("dx"), Var("dx"), Mul, kind=None), Prim(Var("dy"), Var("dy"), Mul, kind=None), Add, kind=None), Prim(Var("dz"), Var("dz"), Mul, kind=None), Add, kind=None), Let(("_", Var(None)), Put(Var("e"), Int(0), Prim(Get(Var("e"), Int(0)), Prim(Prim(Var("bm"), Var("b2m"), Mul, kind=None), App(Var("sqrt"), targs=None, [Var("dist2")]), Div, kind=None), Sub, kind=None)), Let(("_", Var(None)), App(Var("loop_j"), targs=None, [Prim(Var("j"), Int(1), Add, kind=None)]), Unit)))))))), Unit)
// [Typer] check: LE(Var("j"), Prim(Var("n"), Int(1), Sub, kind=None)) against Bool
// [Typer] infer: Var("j")
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] infer: Prim(Var("n"), Int(1), Sub, kind=None)
// [Typer] infer: Var("n")
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] infer: Int(1)
// [Typer] unify: Int and Int
// [Typer] unify: Int and Int
// [Typer] infer: Let(("b2", Var(None)), Get(Var("bodies"), Var("j")), LetTuple([("b2x", Var(None)), ("b2y", Var(None)), ("b2z", Var(None)), ("b2vx", Var(None)), ("b2vy", Var(None)), ("b2vz", Var(None)), ("b2m", Var(None))], Var("b2"), Let(("dx", Var(None)), Prim(Var("bx"), Var("b2x"), Sub, kind=None), Let(("dy", Var(None)), Prim(Var("by"), Var("b2y"), Sub, kind=None), Let(("dz", Var(None)), Prim(Var("bz"), Var("b2z"), Sub, kind=None), Let(("dist2", Var(None)), Prim(Prim(Prim(Var("dx"), Var("dx"), Mul, kind=None), Prim(Var("dy"), Var("dy"), Mul, kind=None), Add, kind=None), Prim(Var("dz"), Var("dz"), Mul, kind=None), Add, kind=None), Let(("_", Var(None)), Put(Var("e"), Int(0), Prim(Get(Var("e"), Int(0)), Prim(Prim(Var("bm"), Var("b2m"), Mul, kind=None), App(Var("sqrt"), targs=None, [Var("dist2")]), Div, kind=None), Sub, kind=None)), Let(("_", Var(None)), App(Var("loop_j"), targs=None, [Prim(Var("j"), Int(1), Add, kind=None)]), Unit))))))))
// [Typer] infer: Get(Var("bodies"), Var("j"))
// [Typer] infer: Var("bodies")
// [Typer] inst: TypeScheme(([], Array[(Double, Double, Double, Double, Double, Double, Double)]))
// [Typer] inst result: Array[(Double, Double, Double, Double, Double, Double, Double)]
// [Typer] check: Var("j") against Int
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] unify: Var(None) and (Double, Double, Double, Double, Double, Double, Double)
// [Typer] union: Var(None) and (Double, Double, Double, Double, Double, Double, Double)
// [Typer] infer: LetTuple([("b2x", Var(None)), ("b2y", Var(None)), ("b2z", Var(None)), ("b2vx", Var(None)), ("b2vy", Var(None)), ("b2vz", Var(None)), ("b2m", Var(None))], Var("b2"), Let(("dx", Var(None)), Prim(Var("bx"), Var("b2x"), Sub, kind=None), Let(("dy", Var(None)), Prim(Var("by"), Var("b2y"), Sub, kind=None), Let(("dz", Var(None)), Prim(Var("bz"), Var("b2z"), Sub, kind=None), Let(("dist2", Var(None)), Prim(Prim(Prim(Var("dx"), Var("dx"), Mul, kind=None), Prim(Var("dy"), Var("dy"), Mul, kind=None), Add, kind=None), Prim(Var("dz"), Var("dz"), Mul, kind=None), Add, kind=None), Let(("_", Var(None)), Put(Var("e"), Int(0), Prim(Get(Var("e"), Int(0)), Prim(Prim(Var("bm"), Var("b2m"), Mul, kind=None), App(Var("sqrt"), targs=None, [Var("dist2")]), Div, kind=None), Sub, kind=None)), Let(("_", Var(None)), App(Var("loop_j"), targs=None, [Prim(Var("j"), Int(1), Add, kind=None)]), Unit)))))))
// [Typer] infer: Var("b2")
// [Typer] inst: TypeScheme(([], (Double, Double, Double, Double, Double, Double, Double)))
// [Typer] inst result: (Double, Double, Double, Double, Double, Double, Double)
// [Typer] unify: Var(None) and Double
// [Typer] union: Var(None) and Double
// [Typer] unify: Var(None) and Double
// [Typer] union: Var(None) and Double
// [Typer] unify: Var(None) and Double
// [Typer] union: Var(None) and Double
// [Typer] unify: Var(None) and Double
// [Typer] union: Var(None) and Double
// [Typer] unify: Var(None) and Double
// [Typer] union: Var(None) and Double
// [Typer] unify: Var(None) and Double
// [Typer] union: Var(None) and Double
// [Typer] unify: Var(None) and Double
// [Typer] union: Var(None) and Double
// [Typer] infer: Let(("dx", Var(None)), Prim(Var("bx"), Var("b2x"), Sub, kind=None), Let(("dy", Var(None)), Prim(Var("by"), Var("b2y"), Sub, kind=None), Let(("dz", Var(None)), Prim(Var("bz"), Var("b2z"), Sub, kind=None), Let(("dist2", Var(None)), Prim(Prim(Prim(Var("dx"), Var("dx"), Mul, kind=None), Prim(Var("dy"), Var("dy"), Mul, kind=None), Add, kind=None), Prim(Var("dz"), Var("dz"), Mul, kind=None), Add, kind=None), Let(("_", Var(None)), Put(Var("e"), Int(0), Prim(Get(Var("e"), Int(0)), Prim(Prim(Var("bm"), Var("b2m"), Mul, kind=None), App(Var("sqrt"), targs=None, [Var("dist2")]), Div, kind=None), Sub, kind=None)), Let(("_", Var(None)), App(Var("loop_j"), targs=None, [Prim(Var("j"), Int(1), Add, kind=None)]), Unit))))))
// [Typer] infer: Prim(Var("bx"), Var("b2x"), Sub, kind=None)
// [Typer] infer: Var("bx")
// [Typer] inst: TypeScheme(([], Double))
// [Typer] inst result: Double
// [Typer] infer: Var("b2x")
// [Typer] inst: TypeScheme(([], Double))
// [Typer] inst result: Double
// [Typer] unify: Double and Double
// [Typer] unify: Var(None) and Double
// [Typer] union: Var(None) and Double
// [Typer] infer: Let(("dy", Var(None)), Prim(Var("by"), Var("b2y"), Sub, kind=None), Let(("dz", Var(None)), Prim(Var("bz"), Var("b2z"), Sub, kind=None), Let(("dist2", Var(None)), Prim(Prim(Prim(Var("dx"), Var("dx"), Mul, kind=None), Prim(Var("dy"), Var("dy"), Mul, kind=None), Add, kind=None), Prim(Var("dz"), Var("dz"), Mul, kind=None), Add, kind=None), Let(("_", Var(None)), Put(Var("e"), Int(0), Prim(Get(Var("e"), Int(0)), Prim(Prim(Var("bm"), Var("b2m"), Mul, kind=None), App(Var("sqrt"), targs=None, [Var("dist2")]), Div, kind=None), Sub, kind=None)), Let(("_", Var(None)), App(Var("loop_j"), targs=None, [Prim(Var("j"), Int(1), Add, kind=None)]), Unit)))))
// [Typer] infer: Prim(Var("by"), Var("b2y"), Sub, kind=None)
// [Typer] infer: Var("by")
// [Typer] inst: TypeScheme(([], Double))
// [Typer] inst result: Double
// [Typer] infer: Var("b2y")
// [Typer] inst: TypeScheme(([], Double))
// [Typer] inst result: Double
// [Typer] unify: Double and Double
// [Typer] unify: Var(None) and Double
// [Typer] union: Var(None) and Double
// [Typer] infer: Let(("dz", Var(None)), Prim(Var("bz"), Var("b2z"), Sub, kind=None), Let(("dist2", Var(None)), Prim(Prim(Prim(Var("dx"), Var("dx"), Mul, kind=None), Prim(Var("dy"), Var("dy"), Mul, kind=None), Add, kind=None), Prim(Var("dz"), Var("dz"), Mul, kind=None), Add, kind=None), Let(("_", Var(None)), Put(Var("e"), Int(0), Prim(Get(Var("e"), Int(0)), Prim(Prim(Var("bm"), Var("b2m"), Mul, kind=None), App(Var("sqrt"), targs=None, [Var("dist2")]), Div, kind=None), Sub, kind=None)), Let(("_", Var(None)), App(Var("loop_j"), targs=None, [Prim(Var("j"), Int(1), Add, kind=None)]), Unit))))
// [Typer] infer: Prim(Var("bz"), Var("b2z"), Sub, kind=None)
// [Typer] infer: Var("bz")
// [Typer] inst: TypeScheme(([], Double))
// [Typer] inst result: Double
// [Typer] infer: Var("b2z")
// [Typer] inst: TypeScheme(([], Double))
// [Typer] inst result: Double
// [Typer] unify: Double and Double
// [Typer] unify: Var(None) and Double
// [Typer] union: Var(None) and Double
// [Typer] infer: Let(("dist2", Var(None)), Prim(Prim(Prim(Var("dx"), Var("dx"), Mul, kind=None), Prim(Var("dy"), Var("dy"), Mul, kind=None), Add, kind=None), Prim(Var("dz"), Var("dz"), Mul, kind=None), Add, kind=None), Let(("_", Var(None)), Put(Var("e"), Int(0), Prim(Get(Var("e"), Int(0)), Prim(Prim(Var("bm"), Var("b2m"), Mul, kind=None), App(Var("sqrt"), targs=None, [Var("dist2")]), Div, kind=None), Sub, kind=None)), Let(("_", Var(None)), App(Var("loop_j"), targs=None, [Prim(Var("j"), Int(1), Add, kind=None)]), Unit)))
// [Typer] infer: Prim(Prim(Prim(Var("dx"), Var("dx"), Mul, kind=None), Prim(Var("dy"), Var("dy"), Mul, kind=None), Add, kind=None), Prim(Var("dz"), Var("dz"), Mul, kind=None), Add, kind=None)
// [Typer] infer: Prim(Prim(Var("dx"), Var("dx"), Mul, kind=None), Prim(Var("dy"), Var("dy"), Mul, kind=None), Add, kind=None)
// [Typer] infer: Prim(Var("dx"), Var("dx"), Mul, kind=None)
// [Typer] infer: Var("dx")
// [Typer] inst: TypeScheme(([], Double))
// [Typer] inst result: Double
// [Typer] infer: Var("dx")
// [Typer] inst: TypeScheme(([], Double))
// [Typer] inst result: Double
// [Typer] unify: Double and Double
// [Typer] infer: Prim(Var("dy"), Var("dy"), Mul, kind=None)
// [Typer] infer: Var("dy")
// [Typer] inst: TypeScheme(([], Double))
// [Typer] inst result: Double
// [Typer] infer: Var("dy")
// [Typer] inst: TypeScheme(([], Double))
// [Typer] inst result: Double
// [Typer] unify: Double and Double
// [Typer] unify: Double and Double
// [Typer] infer: Prim(Var("dz"), Var("dz"), Mul, kind=None)
// [Typer] infer: Var("dz")
// [Typer] inst: TypeScheme(([], Double))
// [Typer] inst result: Double
// [Typer] infer: Var("dz")
// [Typer] inst: TypeScheme(([], Double))
// [Typer] inst result: Double
// [Typer] unify: Double and Double
// [Typer] unify: Double and Double
// [Typer] unify: Var(None) and Double
// [Typer] union: Var(None) and Double
// [Typer] infer: Let(("_", Var(None)), Put(Var("e"), Int(0), Prim(Get(Var("e"), Int(0)), Prim(Prim(Var("bm"), Var("b2m"), Mul, kind=None), App(Var("sqrt"), targs=None, [Var("dist2")]), Div, kind=None), Sub, kind=None)), Let(("_", Var(None)), App(Var("loop_j"), targs=None, [Prim(Var("j"), Int(1), Add, kind=None)]), Unit))
// [Typer] infer: Put(Var("e"), Int(0), Prim(Get(Var("e"), Int(0)), Prim(Prim(Var("bm"), Var("b2m"), Mul, kind=None), App(Var("sqrt"), targs=None, [Var("dist2")]), Div, kind=None), Sub, kind=None))
// [Typer] infer: Prim(Get(Var("e"), Int(0)), Prim(Prim(Var("bm"), Var("b2m"), Mul, kind=None), App(Var("sqrt"), targs=None, [Var("dist2")]), Div, kind=None), Sub, kind=None)
// [Typer] infer: Get(Var("e"), Int(0))
// [Typer] infer: Var("e")
// [Typer] inst: TypeScheme(([], Array[Double]))
// [Typer] inst result: Array[Double]
// [Typer] check: Int(0) against Int
// [Typer] infer: Prim(Prim(Var("bm"), Var("b2m"), Mul, kind=None), App(Var("sqrt"), targs=None, [Var("dist2")]), Div, kind=None)
// [Typer] infer: Prim(Var("bm"), Var("b2m"), Mul, kind=None)
// [Typer] infer: Var("bm")
// [Typer] inst: TypeScheme(([], Double))
// [Typer] inst result: Double
// [Typer] infer: Var("b2m")
// [Typer] inst: TypeScheme(([], Double))
// [Typer] inst result: Double
// [Typer] unify: Double and Double
// [Typer] infer: App(Var("sqrt"), targs=None, [Var("dist2")])
// [Typer] inst: TypeScheme(([], (Double) -> Double))
// [Typer] inst result: (Double) -> Double
// [Typer] check: Var("dist2") against Double
// [Typer] inst: TypeScheme(([], Double))
// [Typer] inst result: Double
// [Typer] unify: Double and Double
// [Typer] unify: Double and Double
// [Typer] unify: Double and Double
// [Typer] check: Var("e") against Array[Double]
// [Typer] inst: TypeScheme(([], Array[Double]))
// [Typer] inst result: Array[Double]
// [Typer] unify: Array[Double] and Array[Double]
// [Typer] unify: Double and Double
// [Typer] check: Int(0) against Int
// [Typer] unify: Var(None) and Unit
// [Typer] union: Var(None) and Unit
// [Typer] infer: Let(("_", Var(None)), App(Var("loop_j"), targs=None, [Prim(Var("j"), Int(1), Add, kind=None)]), Unit)
// [Typer] infer: App(Var("loop_j"), targs=None, [Prim(Var("j"), Int(1), Add, kind=None)])
// [Typer] inst: TypeScheme(([], (Int) -> Var(None)))
// [Typer] inst result: (Int) -> Var(None)
// [Typer] check: Prim(Var("j"), Int(1), Add, kind=None) against Int
// [Typer] check: Var("j") against Int
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] check: Int(1) against Int
// [Typer] unify: Var(None) and Var(None)
// [Typer] union: Var(None) and Var(None)
// [Typer] infer: Unit
// [Typer] infer: Unit
// [Typer] unify: Unit and Unit
// [Typer] unify: Var(None) and Unit
// [Typer] union: Var(None) and Unit
// [Typer] infer: Unit
// [Typer] unify: Unit and Var(None)
// [Typer] union: Unit and Var(None)
// [Typer] infer: Let(("_", Var(None)), App(Var("loop_j"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Unit))
// [Typer] infer: App(Var("loop_j"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)])
// [Typer] inst: TypeScheme(([], (Int) -> Unit))
// [Typer] inst result: (Int) -> Unit
// [Typer] check: Prim(Var("i"), Int(1), Add, kind=None) against Int
// [Typer] check: Var("i") against Int
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] check: Int(1) against Int
// [Typer] unify: Var(None) and Unit
// [Typer] union: Var(None) and Unit
// [Typer] infer: Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Unit)
// [Typer] infer: App(Var("loop_i"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)])
// [Typer] inst: TypeScheme(([], (Int) -> Var(None)))
// [Typer] inst result: (Int) -> Var(None)
// [Typer] check: Prim(Var("i"), Int(1), Add, kind=None) against Int
// [Typer] check: Var("i") against Int
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] check: Int(1) against Int
// [Typer] unify: Var(None) and Var(None)
// [Typer] union: Var(None) and Var(None)
// [Typer] infer: Unit
// [Typer] infer: Unit
// [Typer] unify: Unit and Unit
// [Typer] unify: Var(None) and Unit
// [Typer] union: Var(None) and Unit
// [Typer] infer: Unit
// [Typer] unify: Unit and Var(None)
// [Typer] union: Unit and Var(None)
// [Typer] check: Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Int(0)]), Get(Var("e"), Int(0))) against Double
// [Typer] infer: App(Var("loop_i"), targs=None, [Int(0)])
// [Typer] inst: TypeScheme(([], (Int) -> Unit))
// [Typer] inst result: (Int) -> Unit
// [Typer] check: Int(0) against Int
// [Typer] unify: Var(None) and Unit
// [Typer] union: Var(None) and Unit
// [Typer] check: Get(Var("e"), Int(0)) against Double
// [Typer] check: Var("e") against Array[Double]
// [Typer] inst: TypeScheme(([], Array[Double]))
// [Typer] inst result: Array[Double]
// [Typer] unify: Array[Double] and Array[Double]
// [Typer] unify: Double and Double
// [Typer] check: Int(0) against Int
// [Typer] check: LetRec({tyvars: [], name: ("offset_momentum", Unit), args: [("bodies", Array[(Double, Double, Double, Double, Double, Double, Double)])], body: Let(("n", Var(None)), Int(5), Let(("px", Var(None)), Array(Int(1), Double(0)), Let(("py", Var(None)), Array(Int(1), Double(0)), Let(("pz", Var(None)), Array(Int(1), Double(0)), LetRec({tyvars: [], name: ("loop_i", Var(None)), args: [("i", Int)], body: Let(("_", Var(None)), If(LE(Var("i"), Prim(Var("n"), Int(1), Sub, kind=None)), Let(("b", Var(None)), Get(Var("bodies"), Var("i")), LetTuple([("bx", Var(None)), ("by", Var(None)), ("bz", Var(None)), ("bvx", Var(None)), ("bvy", Var(None)), ("bvz", Var(None)), ("bm", Var(None))], Var("b"), Let(("_", Var(None)), Put(Var("px"), Int(0), Prim(Get(Var("px"), Int(0)), Prim(Var("bvx"), Var("bm"), Mul, kind=None), Add, kind=None)), Let(("_", Var(None)), Put(Var("py"), Int(0), Prim(Get(Var("py"), Int(0)), Prim(Var("bvy"), Var("bm"), Mul, kind=None), Add, kind=None)), Let(("_", Var(None)), Put(Var("pz"), Int(0), Prim(Get(Var("pz"), Int(0)), Prim(Var("bvz"), Var("bm"), Mul, kind=None), Add, kind=None)), Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Unit)))))), Unit), Unit)}, Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Int(0)]), Let(("b", Var(None)), Get(Var("bodies"), Int(0)), LetTuple([("bx", Var(None)), ("by", Var(None)), ("bz", Var(None)), ("bvx", Var(None)), ("bvy", Var(None)), ("bvz", Var(None)), ("bm", Var(None))], Var("b"), Let(("new_b", Var(None)), Tuple([Var("bx"), Var("by"), Var("bz"), Neg(Prim(Get(Var("px"), Int(0)), Var("solar_mass"), Div, kind=None), kind=None), Neg(Prim(Get(Var("py"), Int(0)), Var("solar_mass"), Div, kind=None), kind=None), Neg(Prim(Get(Var("pz"), Int(0)), Var("solar_mass"), Div, kind=None), kind=None), Var("bm")]), Let(("_", Var(None)), Put(Var("bodies"), Int(0), Var("new_b")), Unit))))))))))}, LetRec({tyvars: [], name: ("main", Var(None)), args: [], body: Let(("jupiter", Var(None)), Tuple([Double(4.841431442464721), Neg(Double(1.1603200440274284), kind=None), Neg(Double(0.10362204447112311), kind=None), Prim(Double(0.001660076642744037), Var("days_per_year"), Mul, kind=None), Prim(Double(0.007699011184197404), Var("days_per_year"), Mul, kind=None), Neg(Prim(Double(0.0000690460016972063), Var("days_per_year"), Mul, kind=None), kind=None), Prim(Double(0.0009547919384243266), Var("solar_mass"), Mul, kind=None)]), Let(("saturn", Var(None)), Tuple([Double(8.34336671824458), Double(4.124798564124305), Neg(Double(0.4035234171143214), kind=None), Neg(Prim(Double(0.002767425107268624), Var("days_per_year"), Mul, kind=None), kind=None), Prim(Double(0.004998528012349172), Var("days_per_year"), Mul, kind=None), Prim(Double(0.000023029345528229068), Var("days_per_year"), Mul, kind=None), Prim(Double(0.0002858859806661308), Var("solar_mass"), Mul, kind=None)]), Let(("uranus", Var(None)), Tuple([Double(12.894369562139131), Neg(Double(15.111151401698631), kind=None), Neg(Double(0.22330757889265587), kind=None), Prim(Double(0.002964601375647616), Var("days_per_year"), Mul, kind=None), Prim(Double(0.0023784717395948095), Var("days_per_year"), Mul, kind=None), Neg(Prim(Double(0.000029658956854023756), Var("days_per_year"), Mul, kind=None), kind=None), Prim(Double(0.00004366244043351563), Var("solar_mass"), Mul, kind=None)]), Let(("neptune", Var(None)), Tuple([Double(15.379697114850917), Neg(Double(25.919314609987964), kind=None), Double(0.17925877295037118), Prim(Double(0.0026806777249038932), Var("days_per_year"), Mul, kind=None), Prim(Double(0.001628241700382423), Var("days_per_year"), Mul, kind=None), Neg(Prim(Double(0.00009515922545197159), Var("days_per_year"), Mul, kind=None), kind=None), Prim(Double(0.00005151389020466116), Var("solar_mass"), Mul, kind=None)]), Let(("sun", Var(None)), Tuple([Double(0), Double(0), Double(0), Double(0), Double(0), Double(0), Var("solar_mass")]), Let(("bodies", Var(None)), Array(Int(5), Tuple([Double(0), Double(0), Double(0), Double(0), Double(0), Double(0), Double(0)])), Let(("_", Var(None)), Put(Var("bodies"), Int(0), Var("sun")), Let(("_", Var(None)), Put(Var("bodies"), Int(1), Var("jupiter")), Let(("_", Var(None)), Put(Var("bodies"), Int(2), Var("saturn")), Let(("_", Var(None)), Put(Var("bodies"), Int(3), Var("uranus")), Let(("_", Var(None)), Put(Var("bodies"), Int(4), Var("neptune")), Let(("_", Var(None)), App(Var("offset_momentum"), targs=None, [Var("bodies")]), Let(("_", Var(None)), App(Var("print_int"), targs=None, [App(Var("int_of_float"), targs=None, [Prim(App(Var("energy"), targs=None, [Var("bodies")]), Double(1000000000), Mul, kind=None)])]), Let(("iters", Var(None)), Int(500000), LetRec({tyvars: [], name: ("loop_i", Var(None)), args: [("i", Int)], body: Let(("_", Var(None)), If(LE(Var("i"), Var("iters")), Let(("_", Var(None)), App(Var("advance"), targs=None, [Var("bodies"), Double(0.01)]), Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Unit)), Unit), Unit)}, Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Int(1)]), Let(("_", Var(None)), App(Var("print_char"), targs=None, [Int(10)]), Let(("_", Var(None)), App(Var("print_int"), targs=None, [App(Var("int_of_float"), targs=None, [Prim(App(Var("energy"), targs=None, [Var("bodies")]), Double(1000000000), Mul, kind=None)])]), Unit))))))))))))))))))}, Unit)) against Unit
// [Typer] typevars: []
// [Typer] check: Let(("n", Var(None)), Int(5), Let(("px", Var(None)), Array(Int(1), Double(0)), Let(("py", Var(None)), Array(Int(1), Double(0)), Let(("pz", Var(None)), Array(Int(1), Double(0)), LetRec({tyvars: [], name: ("loop_i", Var(None)), args: [("i", Int)], body: Let(("_", Var(None)), If(LE(Var("i"), Prim(Var("n"), Int(1), Sub, kind=None)), Let(("b", Var(None)), Get(Var("bodies"), Var("i")), LetTuple([("bx", Var(None)), ("by", Var(None)), ("bz", Var(None)), ("bvx", Var(None)), ("bvy", Var(None)), ("bvz", Var(None)), ("bm", Var(None))], Var("b"), Let(("_", Var(None)), Put(Var("px"), Int(0), Prim(Get(Var("px"), Int(0)), Prim(Var("bvx"), Var("bm"), Mul, kind=None), Add, kind=None)), Let(("_", Var(None)), Put(Var("py"), Int(0), Prim(Get(Var("py"), Int(0)), Prim(Var("bvy"), Var("bm"), Mul, kind=None), Add, kind=None)), Let(("_", Var(None)), Put(Var("pz"), Int(0), Prim(Get(Var("pz"), Int(0)), Prim(Var("bvz"), Var("bm"), Mul, kind=None), Add, kind=None)), Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Unit)))))), Unit), Unit)}, Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Int(0)]), Let(("b", Var(None)), Get(Var("bodies"), Int(0)), LetTuple([("bx", Var(None)), ("by", Var(None)), ("bz", Var(None)), ("bvx", Var(None)), ("bvy", Var(None)), ("bvz", Var(None)), ("bm", Var(None))], Var("b"), Let(("new_b", Var(None)), Tuple([Var("bx"), Var("by"), Var("bz"), Neg(Prim(Get(Var("px"), Int(0)), Var("solar_mass"), Div, kind=None), kind=None), Neg(Prim(Get(Var("py"), Int(0)), Var("solar_mass"), Div, kind=None), kind=None), Neg(Prim(Get(Var("pz"), Int(0)), Var("solar_mass"), Div, kind=None), kind=None), Var("bm")]), Let(("_", Var(None)), Put(Var("bodies"), Int(0), Var("new_b")), Unit)))))))))) against Unit
// [Typer] infer: Int(5)
// [Typer] unify: Var(None) and Int
// [Typer] union: Var(None) and Int
// [Typer] check: Let(("px", Var(None)), Array(Int(1), Double(0)), Let(("py", Var(None)), Array(Int(1), Double(0)), Let(("pz", Var(None)), Array(Int(1), Double(0)), LetRec({tyvars: [], name: ("loop_i", Var(None)), args: [("i", Int)], body: Let(("_", Var(None)), If(LE(Var("i"), Prim(Var("n"), Int(1), Sub, kind=None)), Let(("b", Var(None)), Get(Var("bodies"), Var("i")), LetTuple([("bx", Var(None)), ("by", Var(None)), ("bz", Var(None)), ("bvx", Var(None)), ("bvy", Var(None)), ("bvz", Var(None)), ("bm", Var(None))], Var("b"), Let(("_", Var(None)), Put(Var("px"), Int(0), Prim(Get(Var("px"), Int(0)), Prim(Var("bvx"), Var("bm"), Mul, kind=None), Add, kind=None)), Let(("_", Var(None)), Put(Var("py"), Int(0), Prim(Get(Var("py"), Int(0)), Prim(Var("bvy"), Var("bm"), Mul, kind=None), Add, kind=None)), Let(("_", Var(None)), Put(Var("pz"), Int(0), Prim(Get(Var("pz"), Int(0)), Prim(Var("bvz"), Var("bm"), Mul, kind=None), Add, kind=None)), Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Unit)))))), Unit), Unit)}, Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Int(0)]), Let(("b", Var(None)), Get(Var("bodies"), Int(0)), LetTuple([("bx", Var(None)), ("by", Var(None)), ("bz", Var(None)), ("bvx", Var(None)), ("bvy", Var(None)), ("bvz", Var(None)), ("bm", Var(None))], Var("b"), Let(("new_b", Var(None)), Tuple([Var("bx"), Var("by"), Var("bz"), Neg(Prim(Get(Var("px"), Int(0)), Var("solar_mass"), Div, kind=None), kind=None), Neg(Prim(Get(Var("py"), Int(0)), Var("solar_mass"), Div, kind=None), kind=None), Neg(Prim(Get(Var("pz"), Int(0)), Var("solar_mass"), Div, kind=None), kind=None), Var("bm")]), Let(("_", Var(None)), Put(Var("bodies"), Int(0), Var("new_b")), Unit))))))))) against Unit
// [Typer] infer: Array(Int(1), Double(0))
// [Typer] infer: Double(0)
// [Typer] check: Int(1) against Int
// [Typer] unify: Var(None) and Array[Double]
// [Typer] union: Var(None) and Array[Double]
// [Typer] check: Let(("py", Var(None)), Array(Int(1), Double(0)), Let(("pz", Var(None)), Array(Int(1), Double(0)), LetRec({tyvars: [], name: ("loop_i", Var(None)), args: [("i", Int)], body: Let(("_", Var(None)), If(LE(Var("i"), Prim(Var("n"), Int(1), Sub, kind=None)), Let(("b", Var(None)), Get(Var("bodies"), Var("i")), LetTuple([("bx", Var(None)), ("by", Var(None)), ("bz", Var(None)), ("bvx", Var(None)), ("bvy", Var(None)), ("bvz", Var(None)), ("bm", Var(None))], Var("b"), Let(("_", Var(None)), Put(Var("px"), Int(0), Prim(Get(Var("px"), Int(0)), Prim(Var("bvx"), Var("bm"), Mul, kind=None), Add, kind=None)), Let(("_", Var(None)), Put(Var("py"), Int(0), Prim(Get(Var("py"), Int(0)), Prim(Var("bvy"), Var("bm"), Mul, kind=None), Add, kind=None)), Let(("_", Var(None)), Put(Var("pz"), Int(0), Prim(Get(Var("pz"), Int(0)), Prim(Var("bvz"), Var("bm"), Mul, kind=None), Add, kind=None)), Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Unit)))))), Unit), Unit)}, Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Int(0)]), Let(("b", Var(None)), Get(Var("bodies"), Int(0)), LetTuple([("bx", Var(None)), ("by", Var(None)), ("bz", Var(None)), ("bvx", Var(None)), ("bvy", Var(None)), ("bvz", Var(None)), ("bm", Var(None))], Var("b"), Let(("new_b", Var(None)), Tuple([Var("bx"), Var("by"), Var("bz"), Neg(Prim(Get(Var("px"), Int(0)), Var("solar_mass"), Div, kind=None), kind=None), Neg(Prim(Get(Var("py"), Int(0)), Var("solar_mass"), Div, kind=None), kind=None), Neg(Prim(Get(Var("pz"), Int(0)), Var("solar_mass"), Div, kind=None), kind=None), Var("bm")]), Let(("_", Var(None)), Put(Var("bodies"), Int(0), Var("new_b")), Unit)))))))) against Unit
// [Typer] infer: Array(Int(1), Double(0))
// [Typer] infer: Double(0)
// [Typer] check: Int(1) against Int
// [Typer] unify: Var(None) and Array[Double]
// [Typer] union: Var(None) and Array[Double]
// [Typer] check: Let(("pz", Var(None)), Array(Int(1), Double(0)), LetRec({tyvars: [], name: ("loop_i", Var(None)), args: [("i", Int)], body: Let(("_", Var(None)), If(LE(Var("i"), Prim(Var("n"), Int(1), Sub, kind=None)), Let(("b", Var(None)), Get(Var("bodies"), Var("i")), LetTuple([("bx", Var(None)), ("by", Var(None)), ("bz", Var(None)), ("bvx", Var(None)), ("bvy", Var(None)), ("bvz", Var(None)), ("bm", Var(None))], Var("b"), Let(("_", Var(None)), Put(Var("px"), Int(0), Prim(Get(Var("px"), Int(0)), Prim(Var("bvx"), Var("bm"), Mul, kind=None), Add, kind=None)), Let(("_", Var(None)), Put(Var("py"), Int(0), Prim(Get(Var("py"), Int(0)), Prim(Var("bvy"), Var("bm"), Mul, kind=None), Add, kind=None)), Let(("_", Var(None)), Put(Var("pz"), Int(0), Prim(Get(Var("pz"), Int(0)), Prim(Var("bvz"), Var("bm"), Mul, kind=None), Add, kind=None)), Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Unit)))))), Unit), Unit)}, Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Int(0)]), Let(("b", Var(None)), Get(Var("bodies"), Int(0)), LetTuple([("bx", Var(None)), ("by", Var(None)), ("bz", Var(None)), ("bvx", Var(None)), ("bvy", Var(None)), ("bvz", Var(None)), ("bm", Var(None))], Var("b"), Let(("new_b", Var(None)), Tuple([Var("bx"), Var("by"), Var("bz"), Neg(Prim(Get(Var("px"), Int(0)), Var("solar_mass"), Div, kind=None), kind=None), Neg(Prim(Get(Var("py"), Int(0)), Var("solar_mass"), Div, kind=None), kind=None), Neg(Prim(Get(Var("pz"), Int(0)), Var("solar_mass"), Div, kind=None), kind=None), Var("bm")]), Let(("_", Var(None)), Put(Var("bodies"), Int(0), Var("new_b")), Unit))))))) against Unit
// [Typer] infer: Array(Int(1), Double(0))
// [Typer] infer: Double(0)
// [Typer] check: Int(1) against Int
// [Typer] unify: Var(None) and Array[Double]
// [Typer] union: Var(None) and Array[Double]
// [Typer] check: LetRec({tyvars: [], name: ("loop_i", Var(None)), args: [("i", Int)], body: Let(("_", Var(None)), If(LE(Var("i"), Prim(Var("n"), Int(1), Sub, kind=None)), Let(("b", Var(None)), Get(Var("bodies"), Var("i")), LetTuple([("bx", Var(None)), ("by", Var(None)), ("bz", Var(None)), ("bvx", Var(None)), ("bvy", Var(None)), ("bvz", Var(None)), ("bm", Var(None))], Var("b"), Let(("_", Var(None)), Put(Var("px"), Int(0), Prim(Get(Var("px"), Int(0)), Prim(Var("bvx"), Var("bm"), Mul, kind=None), Add, kind=None)), Let(("_", Var(None)), Put(Var("py"), Int(0), Prim(Get(Var("py"), Int(0)), Prim(Var("bvy"), Var("bm"), Mul, kind=None), Add, kind=None)), Let(("_", Var(None)), Put(Var("pz"), Int(0), Prim(Get(Var("pz"), Int(0)), Prim(Var("bvz"), Var("bm"), Mul, kind=None), Add, kind=None)), Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Unit)))))), Unit), Unit)}, Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Int(0)]), Let(("b", Var(None)), Get(Var("bodies"), Int(0)), LetTuple([("bx", Var(None)), ("by", Var(None)), ("bz", Var(None)), ("bvx", Var(None)), ("bvy", Var(None)), ("bvz", Var(None)), ("bm", Var(None))], Var("b"), Let(("new_b", Var(None)), Tuple([Var("bx"), Var("by"), Var("bz"), Neg(Prim(Get(Var("px"), Int(0)), Var("solar_mass"), Div, kind=None), kind=None), Neg(Prim(Get(Var("py"), Int(0)), Var("solar_mass"), Div, kind=None), kind=None), Neg(Prim(Get(Var("pz"), Int(0)), Var("solar_mass"), Div, kind=None), kind=None), Var("bm")]), Let(("_", Var(None)), Put(Var("bodies"), Int(0), Var("new_b")), Unit)))))) against Unit
// [Typer] typevars: []
// [Typer] infer: Let(("_", Var(None)), If(LE(Var("i"), Prim(Var("n"), Int(1), Sub, kind=None)), Let(("b", Var(None)), Get(Var("bodies"), Var("i")), LetTuple([("bx", Var(None)), ("by", Var(None)), ("bz", Var(None)), ("bvx", Var(None)), ("bvy", Var(None)), ("bvz", Var(None)), ("bm", Var(None))], Var("b"), Let(("_", Var(None)), Put(Var("px"), Int(0), Prim(Get(Var("px"), Int(0)), Prim(Var("bvx"), Var("bm"), Mul, kind=None), Add, kind=None)), Let(("_", Var(None)), Put(Var("py"), Int(0), Prim(Get(Var("py"), Int(0)), Prim(Var("bvy"), Var("bm"), Mul, kind=None), Add, kind=None)), Let(("_", Var(None)), Put(Var("pz"), Int(0), Prim(Get(Var("pz"), Int(0)), Prim(Var("bvz"), Var("bm"), Mul, kind=None), Add, kind=None)), Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Unit)))))), Unit), Unit)
// [Typer] infer: If(LE(Var("i"), Prim(Var("n"), Int(1), Sub, kind=None)), Let(("b", Var(None)), Get(Var("bodies"), Var("i")), LetTuple([("bx", Var(None)), ("by", Var(None)), ("bz", Var(None)), ("bvx", Var(None)), ("bvy", Var(None)), ("bvz", Var(None)), ("bm", Var(None))], Var("b"), Let(("_", Var(None)), Put(Var("px"), Int(0), Prim(Get(Var("px"), Int(0)), Prim(Var("bvx"), Var("bm"), Mul, kind=None), Add, kind=None)), Let(("_", Var(None)), Put(Var("py"), Int(0), Prim(Get(Var("py"), Int(0)), Prim(Var("bvy"), Var("bm"), Mul, kind=None), Add, kind=None)), Let(("_", Var(None)), Put(Var("pz"), Int(0), Prim(Get(Var("pz"), Int(0)), Prim(Var("bvz"), Var("bm"), Mul, kind=None), Add, kind=None)), Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Unit)))))), Unit)
// [Typer] check: LE(Var("i"), Prim(Var("n"), Int(1), Sub, kind=None)) against Bool
// [Typer] infer: Var("i")
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] infer: Prim(Var("n"), Int(1), Sub, kind=None)
// [Typer] infer: Var("n")
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] infer: Int(1)
// [Typer] unify: Int and Int
// [Typer] unify: Int and Int
// [Typer] infer: Let(("b", Var(None)), Get(Var("bodies"), Var("i")), LetTuple([("bx", Var(None)), ("by", Var(None)), ("bz", Var(None)), ("bvx", Var(None)), ("bvy", Var(None)), ("bvz", Var(None)), ("bm", Var(None))], Var("b"), Let(("_", Var(None)), Put(Var("px"), Int(0), Prim(Get(Var("px"), Int(0)), Prim(Var("bvx"), Var("bm"), Mul, kind=None), Add, kind=None)), Let(("_", Var(None)), Put(Var("py"), Int(0), Prim(Get(Var("py"), Int(0)), Prim(Var("bvy"), Var("bm"), Mul, kind=None), Add, kind=None)), Let(("_", Var(None)), Put(Var("pz"), Int(0), Prim(Get(Var("pz"), Int(0)), Prim(Var("bvz"), Var("bm"), Mul, kind=None), Add, kind=None)), Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Unit))))))
// [Typer] infer: Get(Var("bodies"), Var("i"))
// [Typer] infer: Var("bodies")
// [Typer] inst: TypeScheme(([], Array[(Double, Double, Double, Double, Double, Double, Double)]))
// [Typer] inst result: Array[(Double, Double, Double, Double, Double, Double, Double)]
// [Typer] check: Var("i") against Int
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] unify: Var(None) and (Double, Double, Double, Double, Double, Double, Double)
// [Typer] union: Var(None) and (Double, Double, Double, Double, Double, Double, Double)
// [Typer] infer: LetTuple([("bx", Var(None)), ("by", Var(None)), ("bz", Var(None)), ("bvx", Var(None)), ("bvy", Var(None)), ("bvz", Var(None)), ("bm", Var(None))], Var("b"), Let(("_", Var(None)), Put(Var("px"), Int(0), Prim(Get(Var("px"), Int(0)), Prim(Var("bvx"), Var("bm"), Mul, kind=None), Add, kind=None)), Let(("_", Var(None)), Put(Var("py"), Int(0), Prim(Get(Var("py"), Int(0)), Prim(Var("bvy"), Var("bm"), Mul, kind=None), Add, kind=None)), Let(("_", Var(None)), Put(Var("pz"), Int(0), Prim(Get(Var("pz"), Int(0)), Prim(Var("bvz"), Var("bm"), Mul, kind=None), Add, kind=None)), Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Unit)))))
// [Typer] infer: Var("b")
// [Typer] inst: TypeScheme(([], (Double, Double, Double, Double, Double, Double, Double)))
// [Typer] inst result: (Double, Double, Double, Double, Double, Double, Double)
// [Typer] unify: Var(None) and Double
// [Typer] union: Var(None) and Double
// [Typer] unify: Var(None) and Double
// [Typer] union: Var(None) and Double
// [Typer] unify: Var(None) and Double
// [Typer] union: Var(None) and Double
// [Typer] unify: Var(None) and Double
// [Typer] union: Var(None) and Double
// [Typer] unify: Var(None) and Double
// [Typer] union: Var(None) and Double
// [Typer] unify: Var(None) and Double
// [Typer] union: Var(None) and Double
// [Typer] unify: Var(None) and Double
// [Typer] union: Var(None) and Double
// [Typer] infer: Let(("_", Var(None)), Put(Var("px"), Int(0), Prim(Get(Var("px"), Int(0)), Prim(Var("bvx"), Var("bm"), Mul, kind=None), Add, kind=None)), Let(("_", Var(None)), Put(Var("py"), Int(0), Prim(Get(Var("py"), Int(0)), Prim(Var("bvy"), Var("bm"), Mul, kind=None), Add, kind=None)), Let(("_", Var(None)), Put(Var("pz"), Int(0), Prim(Get(Var("pz"), Int(0)), Prim(Var("bvz"), Var("bm"), Mul, kind=None), Add, kind=None)), Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Unit))))
// [Typer] infer: Put(Var("px"), Int(0), Prim(Get(Var("px"), Int(0)), Prim(Var("bvx"), Var("bm"), Mul, kind=None), Add, kind=None))
// [Typer] infer: Prim(Get(Var("px"), Int(0)), Prim(Var("bvx"), Var("bm"), Mul, kind=None), Add, kind=None)
// [Typer] infer: Get(Var("px"), Int(0))
// [Typer] infer: Var("px")
// [Typer] inst: TypeScheme(([], Array[Double]))
// [Typer] inst result: Array[Double]
// [Typer] check: Int(0) against Int
// [Typer] infer: Prim(Var("bvx"), Var("bm"), Mul, kind=None)
// [Typer] infer: Var("bvx")
// [Typer] inst: TypeScheme(([], Double))
// [Typer] inst result: Double
// [Typer] infer: Var("bm")
// [Typer] inst: TypeScheme(([], Double))
// [Typer] inst result: Double
// [Typer] unify: Double and Double
// [Typer] unify: Double and Double
// [Typer] check: Var("px") against Array[Double]
// [Typer] inst: TypeScheme(([], Array[Double]))
// [Typer] inst result: Array[Double]
// [Typer] unify: Array[Double] and Array[Double]
// [Typer] unify: Double and Double
// [Typer] check: Int(0) against Int
// [Typer] unify: Var(None) and Unit
// [Typer] union: Var(None) and Unit
// [Typer] infer: Let(("_", Var(None)), Put(Var("py"), Int(0), Prim(Get(Var("py"), Int(0)), Prim(Var("bvy"), Var("bm"), Mul, kind=None), Add, kind=None)), Let(("_", Var(None)), Put(Var("pz"), Int(0), Prim(Get(Var("pz"), Int(0)), Prim(Var("bvz"), Var("bm"), Mul, kind=None), Add, kind=None)), Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Unit)))
// [Typer] infer: Put(Var("py"), Int(0), Prim(Get(Var("py"), Int(0)), Prim(Var("bvy"), Var("bm"), Mul, kind=None), Add, kind=None))
// [Typer] infer: Prim(Get(Var("py"), Int(0)), Prim(Var("bvy"), Var("bm"), Mul, kind=None), Add, kind=None)
// [Typer] infer: Get(Var("py"), Int(0))
// [Typer] infer: Var("py")
// [Typer] inst: TypeScheme(([], Array[Double]))
// [Typer] inst result: Array[Double]
// [Typer] check: Int(0) against Int
// [Typer] infer: Prim(Var("bvy"), Var("bm"), Mul, kind=None)
// [Typer] infer: Var("bvy")
// [Typer] inst: TypeScheme(([], Double))
// [Typer] inst result: Double
// [Typer] infer: Var("bm")
// [Typer] inst: TypeScheme(([], Double))
// [Typer] inst result: Double
// [Typer] unify: Double and Double
// [Typer] unify: Double and Double
// [Typer] check: Var("py") against Array[Double]
// [Typer] inst: TypeScheme(([], Array[Double]))
// [Typer] inst result: Array[Double]
// [Typer] unify: Array[Double] and Array[Double]
// [Typer] unify: Double and Double
// [Typer] check: Int(0) against Int
// [Typer] unify: Var(None) and Unit
// [Typer] union: Var(None) and Unit
// [Typer] infer: Let(("_", Var(None)), Put(Var("pz"), Int(0), Prim(Get(Var("pz"), Int(0)), Prim(Var("bvz"), Var("bm"), Mul, kind=None), Add, kind=None)), Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Unit))
// [Typer] infer: Put(Var("pz"), Int(0), Prim(Get(Var("pz"), Int(0)), Prim(Var("bvz"), Var("bm"), Mul, kind=None), Add, kind=None))
// [Typer] infer: Prim(Get(Var("pz"), Int(0)), Prim(Var("bvz"), Var("bm"), Mul, kind=None), Add, kind=None)
// [Typer] infer: Get(Var("pz"), Int(0))
// [Typer] infer: Var("pz")
// [Typer] inst: TypeScheme(([], Array[Double]))
// [Typer] inst result: Array[Double]
// [Typer] check: Int(0) against Int
// [Typer] infer: Prim(Var("bvz"), Var("bm"), Mul, kind=None)
// [Typer] infer: Var("bvz")
// [Typer] inst: TypeScheme(([], Double))
// [Typer] inst result: Double
// [Typer] infer: Var("bm")
// [Typer] inst: TypeScheme(([], Double))
// [Typer] inst result: Double
// [Typer] unify: Double and Double
// [Typer] unify: Double and Double
// [Typer] check: Var("pz") against Array[Double]
// [Typer] inst: TypeScheme(([], Array[Double]))
// [Typer] inst result: Array[Double]
// [Typer] unify: Array[Double] and Array[Double]
// [Typer] unify: Double and Double
// [Typer] check: Int(0) against Int
// [Typer] unify: Var(None) and Unit
// [Typer] union: Var(None) and Unit
// [Typer] infer: Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Unit)
// [Typer] infer: App(Var("loop_i"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)])
// [Typer] inst: TypeScheme(([], (Int) -> Var(None)))
// [Typer] inst result: (Int) -> Var(None)
// [Typer] check: Prim(Var("i"), Int(1), Add, kind=None) against Int
// [Typer] check: Var("i") against Int
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] check: Int(1) against Int
// [Typer] unify: Var(None) and Var(None)
// [Typer] union: Var(None) and Var(None)
// [Typer] infer: Unit
// [Typer] infer: Unit
// [Typer] unify: Unit and Unit
// [Typer] unify: Var(None) and Unit
// [Typer] union: Var(None) and Unit
// [Typer] infer: Unit
// [Typer] unify: Unit and Var(None)
// [Typer] union: Unit and Var(None)
// [Typer] check: Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Int(0)]), Let(("b", Var(None)), Get(Var("bodies"), Int(0)), LetTuple([("bx", Var(None)), ("by", Var(None)), ("bz", Var(None)), ("bvx", Var(None)), ("bvy", Var(None)), ("bvz", Var(None)), ("bm", Var(None))], Var("b"), Let(("new_b", Var(None)), Tuple([Var("bx"), Var("by"), Var("bz"), Neg(Prim(Get(Var("px"), Int(0)), Var("solar_mass"), Div, kind=None), kind=None), Neg(Prim(Get(Var("py"), Int(0)), Var("solar_mass"), Div, kind=None), kind=None), Neg(Prim(Get(Var("pz"), Int(0)), Var("solar_mass"), Div, kind=None), kind=None), Var("bm")]), Let(("_", Var(None)), Put(Var("bodies"), Int(0), Var("new_b")), Unit))))) against Unit
// [Typer] infer: App(Var("loop_i"), targs=None, [Int(0)])
// [Typer] inst: TypeScheme(([], (Int) -> Unit))
// [Typer] inst result: (Int) -> Unit
// [Typer] check: Int(0) against Int
// [Typer] unify: Var(None) and Unit
// [Typer] union: Var(None) and Unit
// [Typer] check: Let(("b", Var(None)), Get(Var("bodies"), Int(0)), LetTuple([("bx", Var(None)), ("by", Var(None)), ("bz", Var(None)), ("bvx", Var(None)), ("bvy", Var(None)), ("bvz", Var(None)), ("bm", Var(None))], Var("b"), Let(("new_b", Var(None)), Tuple([Var("bx"), Var("by"), Var("bz"), Neg(Prim(Get(Var("px"), Int(0)), Var("solar_mass"), Div, kind=None), kind=None), Neg(Prim(Get(Var("py"), Int(0)), Var("solar_mass"), Div, kind=None), kind=None), Neg(Prim(Get(Var("pz"), Int(0)), Var("solar_mass"), Div, kind=None), kind=None), Var("bm")]), Let(("_", Var(None)), Put(Var("bodies"), Int(0), Var("new_b")), Unit)))) against Unit
// [Typer] infer: Get(Var("bodies"), Int(0))
// [Typer] infer: Var("bodies")
// [Typer] inst: TypeScheme(([], Array[(Double, Double, Double, Double, Double, Double, Double)]))
// [Typer] inst result: Array[(Double, Double, Double, Double, Double, Double, Double)]
// [Typer] check: Int(0) against Int
// [Typer] unify: Var(None) and (Double, Double, Double, Double, Double, Double, Double)
// [Typer] union: Var(None) and (Double, Double, Double, Double, Double, Double, Double)
// [Typer] check: LetTuple([("bx", Var(None)), ("by", Var(None)), ("bz", Var(None)), ("bvx", Var(None)), ("bvy", Var(None)), ("bvz", Var(None)), ("bm", Var(None))], Var("b"), Let(("new_b", Var(None)), Tuple([Var("bx"), Var("by"), Var("bz"), Neg(Prim(Get(Var("px"), Int(0)), Var("solar_mass"), Div, kind=None), kind=None), Neg(Prim(Get(Var("py"), Int(0)), Var("solar_mass"), Div, kind=None), kind=None), Neg(Prim(Get(Var("pz"), Int(0)), Var("solar_mass"), Div, kind=None), kind=None), Var("bm")]), Let(("_", Var(None)), Put(Var("bodies"), Int(0), Var("new_b")), Unit))) against Unit
// [Typer] infer: Var("b")
// [Typer] inst: TypeScheme(([], (Double, Double, Double, Double, Double, Double, Double)))
// [Typer] inst result: (Double, Double, Double, Double, Double, Double, Double)
// [Typer] unify: Var(None) and Double
// [Typer] union: Var(None) and Double
// [Typer] unify: Var(None) and Double
// [Typer] union: Var(None) and Double
// [Typer] unify: Var(None) and Double
// [Typer] union: Var(None) and Double
// [Typer] unify: Var(None) and Double
// [Typer] union: Var(None) and Double
// [Typer] unify: Var(None) and Double
// [Typer] union: Var(None) and Double
// [Typer] unify: Var(None) and Double
// [Typer] union: Var(None) and Double
// [Typer] unify: Var(None) and Double
// [Typer] union: Var(None) and Double
// [Typer] check: Let(("new_b", Var(None)), Tuple([Var("bx"), Var("by"), Var("bz"), Neg(Prim(Get(Var("px"), Int(0)), Var("solar_mass"), Div, kind=None), kind=None), Neg(Prim(Get(Var("py"), Int(0)), Var("solar_mass"), Div, kind=None), kind=None), Neg(Prim(Get(Var("pz"), Int(0)), Var("solar_mass"), Div, kind=None), kind=None), Var("bm")]), Let(("_", Var(None)), Put(Var("bodies"), Int(0), Var("new_b")), Unit)) against Unit
// [Typer] infer: Tuple([Var("bx"), Var("by"), Var("bz"), Neg(Prim(Get(Var("px"), Int(0)), Var("solar_mass"), Div, kind=None), kind=None), Neg(Prim(Get(Var("py"), Int(0)), Var("solar_mass"), Div, kind=None), kind=None), Neg(Prim(Get(Var("pz"), Int(0)), Var("solar_mass"), Div, kind=None), kind=None), Var("bm")])
// [Typer] infer: Var("bx")
// [Typer] inst: TypeScheme(([], Double))
// [Typer] inst result: Double
// [Typer] infer: Var("by")
// [Typer] inst: TypeScheme(([], Double))
// [Typer] inst result: Double
// [Typer] infer: Var("bz")
// [Typer] inst: TypeScheme(([], Double))
// [Typer] inst result: Double
// [Typer] infer: Neg(Prim(Get(Var("px"), Int(0)), Var("solar_mass"), Div, kind=None), kind=None)
// [Typer] infer: Prim(Get(Var("px"), Int(0)), Var("solar_mass"), Div, kind=None)
// [Typer] infer: Get(Var("px"), Int(0))
// [Typer] infer: Var("px")
// [Typer] inst: TypeScheme(([], Array[Double]))
// [Typer] inst result: Array[Double]
// [Typer] check: Int(0) against Int
// [Typer] infer: Var("solar_mass")
// [Typer] inst: TypeScheme(([], Double))
// [Typer] inst result: Double
// [Typer] unify: Double and Double
// [Typer] infer: Neg(Prim(Get(Var("py"), Int(0)), Var("solar_mass"), Div, kind=None), kind=None)
// [Typer] infer: Prim(Get(Var("py"), Int(0)), Var("solar_mass"), Div, kind=None)
// [Typer] infer: Get(Var("py"), Int(0))
// [Typer] infer: Var("py")
// [Typer] inst: TypeScheme(([], Array[Double]))
// [Typer] inst result: Array[Double]
// [Typer] check: Int(0) against Int
// [Typer] infer: Var("solar_mass")
// [Typer] inst: TypeScheme(([], Double))
// [Typer] inst result: Double
// [Typer] unify: Double and Double
// [Typer] infer: Neg(Prim(Get(Var("pz"), Int(0)), Var("solar_mass"), Div, kind=None), kind=None)
// [Typer] infer: Prim(Get(Var("pz"), Int(0)), Var("solar_mass"), Div, kind=None)
// [Typer] infer: Get(Var("pz"), Int(0))
// [Typer] infer: Var("pz")
// [Typer] inst: TypeScheme(([], Array[Double]))
// [Typer] inst result: Array[Double]
// [Typer] check: Int(0) against Int
// [Typer] infer: Var("solar_mass")
// [Typer] inst: TypeScheme(([], Double))
// [Typer] inst result: Double
// [Typer] unify: Double and Double
// [Typer] infer: Var("bm")
// [Typer] inst: TypeScheme(([], Double))
// [Typer] inst result: Double
// [Typer] unify: Var(None) and (Double, Double, Double, Double, Double, Double, Double)
// [Typer] union: Var(None) and (Double, Double, Double, Double, Double, Double, Double)
// [Typer] check: Let(("_", Var(None)), Put(Var("bodies"), Int(0), Var("new_b")), Unit) against Unit
// [Typer] infer: Put(Var("bodies"), Int(0), Var("new_b"))
// [Typer] infer: Var("new_b")
// [Typer] inst: TypeScheme(([], (Double, Double, Double, Double, Double, Double, Double)))
// [Typer] inst result: (Double, Double, Double, Double, Double, Double, Double)
// [Typer] check: Var("bodies") against Array[(Double, Double, Double, Double, Double, Double, Double)]
// [Typer] inst: TypeScheme(([], Array[(Double, Double, Double, Double, Double, Double, Double)]))
// [Typer] inst result: Array[(Double, Double, Double, Double, Double, Double, Double)]
// [Typer] unify: Array[(Double, Double, Double, Double, Double, Double, Double)] and Array[(Double, Double, Double, Double, Double, Double, Double)]
// [Typer] unify: (Double, Double, Double, Double, Double, Double, Double) and (Double, Double, Double, Double, Double, Double, Double)
// [Typer] unify: Double and Double
// [Typer] unify: Double and Double
// [Typer] unify: Double and Double
// [Typer] unify: Double and Double
// [Typer] unify: Double and Double
// [Typer] unify: Double and Double
// [Typer] unify: Double and Double
// [Typer] check: Int(0) against Int
// [Typer] unify: Var(None) and Unit
// [Typer] union: Var(None) and Unit
// [Typer] check: Unit against Unit
// [Typer] check: LetRec({tyvars: [], name: ("main", Var(None)), args: [], body: Let(("jupiter", Var(None)), Tuple([Double(4.841431442464721), Neg(Double(1.1603200440274284), kind=None), Neg(Double(0.10362204447112311), kind=None), Prim(Double(0.001660076642744037), Var("days_per_year"), Mul, kind=None), Prim(Double(0.007699011184197404), Var("days_per_year"), Mul, kind=None), Neg(Prim(Double(0.0000690460016972063), Var("days_per_year"), Mul, kind=None), kind=None), Prim(Double(0.0009547919384243266), Var("solar_mass"), Mul, kind=None)]), Let(("saturn", Var(None)), Tuple([Double(8.34336671824458), Double(4.124798564124305), Neg(Double(0.4035234171143214), kind=None), Neg(Prim(Double(0.002767425107268624), Var("days_per_year"), Mul, kind=None), kind=None), Prim(Double(0.004998528012349172), Var("days_per_year"), Mul, kind=None), Prim(Double(0.000023029345528229068), Var("days_per_year"), Mul, kind=None), Prim(Double(0.0002858859806661308), Var("solar_mass"), Mul, kind=None)]), Let(("uranus", Var(None)), Tuple([Double(12.894369562139131), Neg(Double(15.111151401698631), kind=None), Neg(Double(0.22330757889265587), kind=None), Prim(Double(0.002964601375647616), Var("days_per_year"), Mul, kind=None), Prim(Double(0.0023784717395948095), Var("days_per_year"), Mul, kind=None), Neg(Prim(Double(0.000029658956854023756), Var("days_per_year"), Mul, kind=None), kind=None), Prim(Double(0.00004366244043351563), Var("solar_mass"), Mul, kind=None)]), Let(("neptune", Var(None)), Tuple([Double(15.379697114850917), Neg(Double(25.919314609987964), kind=None), Double(0.17925877295037118), Prim(Double(0.0026806777249038932), Var("days_per_year"), Mul, kind=None), Prim(Double(0.001628241700382423), Var("days_per_year"), Mul, kind=None), Neg(Prim(Double(0.00009515922545197159), Var("days_per_year"), Mul, kind=None), kind=None), Prim(Double(0.00005151389020466116), Var("solar_mass"), Mul, kind=None)]), Let(("sun", Var(None)), Tuple([Double(0), Double(0), Double(0), Double(0), Double(0), Double(0), Var("solar_mass")]), Let(("bodies", Var(None)), Array(Int(5), Tuple([Double(0), Double(0), Double(0), Double(0), Double(0), Double(0), Double(0)])), Let(("_", Var(None)), Put(Var("bodies"), Int(0), Var("sun")), Let(("_", Var(None)), Put(Var("bodies"), Int(1), Var("jupiter")), Let(("_", Var(None)), Put(Var("bodies"), Int(2), Var("saturn")), Let(("_", Var(None)), Put(Var("bodies"), Int(3), Var("uranus")), Let(("_", Var(None)), Put(Var("bodies"), Int(4), Var("neptune")), Let(("_", Var(None)), App(Var("offset_momentum"), targs=None, [Var("bodies")]), Let(("_", Var(None)), App(Var("print_int"), targs=None, [App(Var("int_of_float"), targs=None, [Prim(App(Var("energy"), targs=None, [Var("bodies")]), Double(1000000000), Mul, kind=None)])]), Let(("iters", Var(None)), Int(500000), LetRec({tyvars: [], name: ("loop_i", Var(None)), args: [("i", Int)], body: Let(("_", Var(None)), If(LE(Var("i"), Var("iters")), Let(("_", Var(None)), App(Var("advance"), targs=None, [Var("bodies"), Double(0.01)]), Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Unit)), Unit), Unit)}, Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Int(1)]), Let(("_", Var(None)), App(Var("print_char"), targs=None, [Int(10)]), Let(("_", Var(None)), App(Var("print_int"), targs=None, [App(Var("int_of_float"), targs=None, [Prim(App(Var("energy"), targs=None, [Var("bodies")]), Double(1000000000), Mul, kind=None)])]), Unit))))))))))))))))))}, Unit) against Unit
// [Typer] typevars: []
// [Typer] infer: Let(("jupiter", Var(None)), Tuple([Double(4.841431442464721), Neg(Double(1.1603200440274284), kind=None), Neg(Double(0.10362204447112311), kind=None), Prim(Double(0.001660076642744037), Var("days_per_year"), Mul, kind=None), Prim(Double(0.007699011184197404), Var("days_per_year"), Mul, kind=None), Neg(Prim(Double(0.0000690460016972063), Var("days_per_year"), Mul, kind=None), kind=None), Prim(Double(0.0009547919384243266), Var("solar_mass"), Mul, kind=None)]), Let(("saturn", Var(None)), Tuple([Double(8.34336671824458), Double(4.124798564124305), Neg(Double(0.4035234171143214), kind=None), Neg(Prim(Double(0.002767425107268624), Var("days_per_year"), Mul, kind=None), kind=None), Prim(Double(0.004998528012349172), Var("days_per_year"), Mul, kind=None), Prim(Double(0.000023029345528229068), Var("days_per_year"), Mul, kind=None), Prim(Double(0.0002858859806661308), Var("solar_mass"), Mul, kind=None)]), Let(("uranus", Var(None)), Tuple([Double(12.894369562139131), Neg(Double(15.111151401698631), kind=None), Neg(Double(0.22330757889265587), kind=None), Prim(Double(0.002964601375647616), Var("days_per_year"), Mul, kind=None), Prim(Double(0.0023784717395948095), Var("days_per_year"), Mul, kind=None), Neg(Prim(Double(0.000029658956854023756), Var("days_per_year"), Mul, kind=None), kind=None), Prim(Double(0.00004366244043351563), Var("solar_mass"), Mul, kind=None)]), Let(("neptune", Var(None)), Tuple([Double(15.379697114850917), Neg(Double(25.919314609987964), kind=None), Double(0.17925877295037118), Prim(Double(0.0026806777249038932), Var("days_per_year"), Mul, kind=None), Prim(Double(0.001628241700382423), Var("days_per_year"), Mul, kind=None), Neg(Prim(Double(0.00009515922545197159), Var("days_per_year"), Mul, kind=None), kind=None), Prim(Double(0.00005151389020466116), Var("solar_mass"), Mul, kind=None)]), Let(("sun", Var(None)), Tuple([Double(0), Double(0), Double(0), Double(0), Double(0), Double(0), Var("solar_mass")]), Let(("bodies", Var(None)), Array(Int(5), Tuple([Double(0), Double(0), Double(0), Double(0), Double(0), Double(0), Double(0)])), Let(("_", Var(None)), Put(Var("bodies"), Int(0), Var("sun")), Let(("_", Var(None)), Put(Var("bodies"), Int(1), Var("jupiter")), Let(("_", Var(None)), Put(Var("bodies"), Int(2), Var("saturn")), Let(("_", Var(None)), Put(Var("bodies"), Int(3), Var("uranus")), Let(("_", Var(None)), Put(Var("bodies"), Int(4), Var("neptune")), Let(("_", Var(None)), App(Var("offset_momentum"), targs=None, [Var("bodies")]), Let(("_", Var(None)), App(Var("print_int"), targs=None, [App(Var("int_of_float"), targs=None, [Prim(App(Var("energy"), targs=None, [Var("bodies")]), Double(1000000000), Mul, kind=None)])]), Let(("iters", Var(None)), Int(500000), LetRec({tyvars: [], name: ("loop_i", Var(None)), args: [("i", Int)], body: Let(("_", Var(None)), If(LE(Var("i"), Var("iters")), Let(("_", Var(None)), App(Var("advance"), targs=None, [Var("bodies"), Double(0.01)]), Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Unit)), Unit), Unit)}, Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Int(1)]), Let(("_", Var(None)), App(Var("print_char"), targs=None, [Int(10)]), Let(("_", Var(None)), App(Var("print_int"), targs=None, [App(Var("int_of_float"), targs=None, [Prim(App(Var("energy"), targs=None, [Var("bodies")]), Double(1000000000), Mul, kind=None)])]), Unit))))))))))))))))))
// [Typer] infer: Tuple([Double(4.841431442464721), Neg(Double(1.1603200440274284), kind=None), Neg(Double(0.10362204447112311), kind=None), Prim(Double(0.001660076642744037), Var("days_per_year"), Mul, kind=None), Prim(Double(0.007699011184197404), Var("days_per_year"), Mul, kind=None), Neg(Prim(Double(0.0000690460016972063), Var("days_per_year"), Mul, kind=None), kind=None), Prim(Double(0.0009547919384243266), Var("solar_mass"), Mul, kind=None)])
// [Typer] infer: Double(4.841431442464721)
// [Typer] infer: Neg(Double(1.1603200440274284), kind=None)
// [Typer] infer: Double(1.1603200440274284)
// [Typer] infer: Neg(Double(0.10362204447112311), kind=None)
// [Typer] infer: Double(0.10362204447112311)
// [Typer] infer: Prim(Double(0.001660076642744037), Var("days_per_year"), Mul, kind=None)
// [Typer] infer: Double(0.001660076642744037)
// [Typer] infer: Var("days_per_year")
// [Typer] inst: TypeScheme(([], Double))
// [Typer] inst result: Double
// [Typer] unify: Double and Double
// [Typer] infer: Prim(Double(0.007699011184197404), Var("days_per_year"), Mul, kind=None)
// [Typer] infer: Double(0.007699011184197404)
// [Typer] infer: Var("days_per_year")
// [Typer] inst: TypeScheme(([], Double))
// [Typer] inst result: Double
// [Typer] unify: Double and Double
// [Typer] infer: Neg(Prim(Double(0.0000690460016972063), Var("days_per_year"), Mul, kind=None), kind=None)
// [Typer] infer: Prim(Double(0.0000690460016972063), Var("days_per_year"), Mul, kind=None)
// [Typer] infer: Double(0.0000690460016972063)
// [Typer] infer: Var("days_per_year")
// [Typer] inst: TypeScheme(([], Double))
// [Typer] inst result: Double
// [Typer] unify: Double and Double
// [Typer] infer: Prim(Double(0.0009547919384243266), Var("solar_mass"), Mul, kind=None)
// [Typer] infer: Double(0.0009547919384243266)
// [Typer] infer: Var("solar_mass")
// [Typer] inst: TypeScheme(([], Double))
// [Typer] inst result: Double
// [Typer] unify: Double and Double
// [Typer] unify: Var(None) and (Double, Double, Double, Double, Double, Double, Double)
// [Typer] union: Var(None) and (Double, Double, Double, Double, Double, Double, Double)
// [Typer] infer: Let(("saturn", Var(None)), Tuple([Double(8.34336671824458), Double(4.124798564124305), Neg(Double(0.4035234171143214), kind=None), Neg(Prim(Double(0.002767425107268624), Var("days_per_year"), Mul, kind=None), kind=None), Prim(Double(0.004998528012349172), Var("days_per_year"), Mul, kind=None), Prim(Double(0.000023029345528229068), Var("days_per_year"), Mul, kind=None), Prim(Double(0.0002858859806661308), Var("solar_mass"), Mul, kind=None)]), Let(("uranus", Var(None)), Tuple([Double(12.894369562139131), Neg(Double(15.111151401698631), kind=None), Neg(Double(0.22330757889265587), kind=None), Prim(Double(0.002964601375647616), Var("days_per_year"), Mul, kind=None), Prim(Double(0.0023784717395948095), Var("days_per_year"), Mul, kind=None), Neg(Prim(Double(0.000029658956854023756), Var("days_per_year"), Mul, kind=None), kind=None), Prim(Double(0.00004366244043351563), Var("solar_mass"), Mul, kind=None)]), Let(("neptune", Var(None)), Tuple([Double(15.379697114850917), Neg(Double(25.919314609987964), kind=None), Double(0.17925877295037118), Prim(Double(0.0026806777249038932), Var("days_per_year"), Mul, kind=None), Prim(Double(0.001628241700382423), Var("days_per_year"), Mul, kind=None), Neg(Prim(Double(0.00009515922545197159), Var("days_per_year"), Mul, kind=None), kind=None), Prim(Double(0.00005151389020466116), Var("solar_mass"), Mul, kind=None)]), Let(("sun", Var(None)), Tuple([Double(0), Double(0), Double(0), Double(0), Double(0), Double(0), Var("solar_mass")]), Let(("bodies", Var(None)), Array(Int(5), Tuple([Double(0), Double(0), Double(0), Double(0), Double(0), Double(0), Double(0)])), Let(("_", Var(None)), Put(Var("bodies"), Int(0), Var("sun")), Let(("_", Var(None)), Put(Var("bodies"), Int(1), Var("jupiter")), Let(("_", Var(None)), Put(Var("bodies"), Int(2), Var("saturn")), Let(("_", Var(None)), Put(Var("bodies"), Int(3), Var("uranus")), Let(("_", Var(None)), Put(Var("bodies"), Int(4), Var("neptune")), Let(("_", Var(None)), App(Var("offset_momentum"), targs=None, [Var("bodies")]), Let(("_", Var(None)), App(Var("print_int"), targs=None, [App(Var("int_of_float"), targs=None, [Prim(App(Var("energy"), targs=None, [Var("bodies")]), Double(1000000000), Mul, kind=None)])]), Let(("iters", Var(None)), Int(500000), LetRec({tyvars: [], name: ("loop_i", Var(None)), args: [("i", Int)], body: Let(("_", Var(None)), If(LE(Var("i"), Var("iters")), Let(("_", Var(None)), App(Var("advance"), targs=None, [Var("bodies"), Double(0.01)]), Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Unit)), Unit), Unit)}, Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Int(1)]), Let(("_", Var(None)), App(Var("print_char"), targs=None, [Int(10)]), Let(("_", Var(None)), App(Var("print_int"), targs=None, [App(Var("int_of_float"), targs=None, [Prim(App(Var("energy"), targs=None, [Var("bodies")]), Double(1000000000), Mul, kind=None)])]), Unit)))))))))))))))))
// [Typer] infer: Tuple([Double(8.34336671824458), Double(4.124798564124305), Neg(Double(0.4035234171143214), kind=None), Neg(Prim(Double(0.002767425107268624), Var("days_per_year"), Mul, kind=None), kind=None), Prim(Double(0.004998528012349172), Var("days_per_year"), Mul, kind=None), Prim(Double(0.000023029345528229068), Var("days_per_year"), Mul, kind=None), Prim(Double(0.0002858859806661308), Var("solar_mass"), Mul, kind=None)])
// [Typer] infer: Double(8.34336671824458)
// [Typer] infer: Double(4.124798564124305)
// [Typer] infer: Neg(Double(0.4035234171143214), kind=None)
// [Typer] infer: Double(0.4035234171143214)
// [Typer] infer: Neg(Prim(Double(0.002767425107268624), Var("days_per_year"), Mul, kind=None), kind=None)
// [Typer] infer: Prim(Double(0.002767425107268624), Var("days_per_year"), Mul, kind=None)
// [Typer] infer: Double(0.002767425107268624)
// [Typer] infer: Var("days_per_year")
// [Typer] inst: TypeScheme(([], Double))
// [Typer] inst result: Double
// [Typer] unify: Double and Double
// [Typer] infer: Prim(Double(0.004998528012349172), Var("days_per_year"), Mul, kind=None)
// [Typer] infer: Double(0.004998528012349172)
// [Typer] infer: Var("days_per_year")
// [Typer] inst: TypeScheme(([], Double))
// [Typer] inst result: Double
// [Typer] unify: Double and Double
// [Typer] infer: Prim(Double(0.000023029345528229068), Var("days_per_year"), Mul, kind=None)
// [Typer] infer: Double(0.000023029345528229068)
// [Typer] infer: Var("days_per_year")
// [Typer] inst: TypeScheme(([], Double))
// [Typer] inst result: Double
// [Typer] unify: Double and Double
// [Typer] infer: Prim(Double(0.0002858859806661308), Var("solar_mass"), Mul, kind=None)
// [Typer] infer: Double(0.0002858859806661308)
// [Typer] infer: Var("solar_mass")
// [Typer] inst: TypeScheme(([], Double))
// [Typer] inst result: Double
// [Typer] unify: Double and Double
// [Typer] unify: Var(None) and (Double, Double, Double, Double, Double, Double, Double)
// [Typer] union: Var(None) and (Double, Double, Double, Double, Double, Double, Double)
// [Typer] infer: Let(("uranus", Var(None)), Tuple([Double(12.894369562139131), Neg(Double(15.111151401698631), kind=None), Neg(Double(0.22330757889265587), kind=None), Prim(Double(0.002964601375647616), Var("days_per_year"), Mul, kind=None), Prim(Double(0.0023784717395948095), Var("days_per_year"), Mul, kind=None), Neg(Prim(Double(0.000029658956854023756), Var("days_per_year"), Mul, kind=None), kind=None), Prim(Double(0.00004366244043351563), Var("solar_mass"), Mul, kind=None)]), Let(("neptune", Var(None)), Tuple([Double(15.379697114850917), Neg(Double(25.919314609987964), kind=None), Double(0.17925877295037118), Prim(Double(0.0026806777249038932), Var("days_per_year"), Mul, kind=None), Prim(Double(0.001628241700382423), Var("days_per_year"), Mul, kind=None), Neg(Prim(Double(0.00009515922545197159), Var("days_per_year"), Mul, kind=None), kind=None), Prim(Double(0.00005151389020466116), Var("solar_mass"), Mul, kind=None)]), Let(("sun", Var(None)), Tuple([Double(0), Double(0), Double(0), Double(0), Double(0), Double(0), Var("solar_mass")]), Let(("bodies", Var(None)), Array(Int(5), Tuple([Double(0), Double(0), Double(0), Double(0), Double(0), Double(0), Double(0)])), Let(("_", Var(None)), Put(Var("bodies"), Int(0), Var("sun")), Let(("_", Var(None)), Put(Var("bodies"), Int(1), Var("jupiter")), Let(("_", Var(None)), Put(Var("bodies"), Int(2), Var("saturn")), Let(("_", Var(None)), Put(Var("bodies"), Int(3), Var("uranus")), Let(("_", Var(None)), Put(Var("bodies"), Int(4), Var("neptune")), Let(("_", Var(None)), App(Var("offset_momentum"), targs=None, [Var("bodies")]), Let(("_", Var(None)), App(Var("print_int"), targs=None, [App(Var("int_of_float"), targs=None, [Prim(App(Var("energy"), targs=None, [Var("bodies")]), Double(1000000000), Mul, kind=None)])]), Let(("iters", Var(None)), Int(500000), LetRec({tyvars: [], name: ("loop_i", Var(None)), args: [("i", Int)], body: Let(("_", Var(None)), If(LE(Var("i"), Var("iters")), Let(("_", Var(None)), App(Var("advance"), targs=None, [Var("bodies"), Double(0.01)]), Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Unit)), Unit), Unit)}, Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Int(1)]), Let(("_", Var(None)), App(Var("print_char"), targs=None, [Int(10)]), Let(("_", Var(None)), App(Var("print_int"), targs=None, [App(Var("int_of_float"), targs=None, [Prim(App(Var("energy"), targs=None, [Var("bodies")]), Double(1000000000), Mul, kind=None)])]), Unit))))))))))))))))
// [Typer] infer: Tuple([Double(12.894369562139131), Neg(Double(15.111151401698631), kind=None), Neg(Double(0.22330757889265587), kind=None), Prim(Double(0.002964601375647616), Var("days_per_year"), Mul, kind=None), Prim(Double(0.0023784717395948095), Var("days_per_year"), Mul, kind=None), Neg(Prim(Double(0.000029658956854023756), Var("days_per_year"), Mul, kind=None), kind=None), Prim(Double(0.00004366244043351563), Var("solar_mass"), Mul, kind=None)])
// [Typer] infer: Double(12.894369562139131)
// [Typer] infer: Neg(Double(15.111151401698631), kind=None)
// [Typer] infer: Double(15.111151401698631)
// [Typer] infer: Neg(Double(0.22330757889265587), kind=None)
// [Typer] infer: Double(0.22330757889265587)
// [Typer] infer: Prim(Double(0.002964601375647616), Var("days_per_year"), Mul, kind=None)
// [Typer] infer: Double(0.002964601375647616)
// [Typer] infer: Var("days_per_year")
// [Typer] inst: TypeScheme(([], Double))
// [Typer] inst result: Double
// [Typer] unify: Double and Double
// [Typer] infer: Prim(Double(0.0023784717395948095), Var("days_per_year"), Mul, kind=None)
// [Typer] infer: Double(0.0023784717395948095)
// [Typer] infer: Var("days_per_year")
// [Typer] inst: TypeScheme(([], Double))
// [Typer] inst result: Double
// [Typer] unify: Double and Double
// [Typer] infer: Neg(Prim(Double(0.000029658956854023756), Var("days_per_year"), Mul, kind=None), kind=None)
// [Typer] infer: Prim(Double(0.000029658956854023756), Var("days_per_year"), Mul, kind=None)
// [Typer] infer: Double(0.000029658956854023756)
// [Typer] infer: Var("days_per_year")
// [Typer] inst: TypeScheme(([], Double))
// [Typer] inst result: Double
// [Typer] unify: Double and Double
// [Typer] infer: Prim(Double(0.00004366244043351563), Var("solar_mass"), Mul, kind=None)
// [Typer] infer: Double(0.00004366244043351563)
// [Typer] infer: Var("solar_mass")
// [Typer] inst: TypeScheme(([], Double))
// [Typer] inst result: Double
// [Typer] unify: Double and Double
// [Typer] unify: Var(None) and (Double, Double, Double, Double, Double, Double, Double)
// [Typer] union: Var(None) and (Double, Double, Double, Double, Double, Double, Double)
// [Typer] infer: Let(("neptune", Var(None)), Tuple([Double(15.379697114850917), Neg(Double(25.919314609987964), kind=None), Double(0.17925877295037118), Prim(Double(0.0026806777249038932), Var("days_per_year"), Mul, kind=None), Prim(Double(0.001628241700382423), Var("days_per_year"), Mul, kind=None), Neg(Prim(Double(0.00009515922545197159), Var("days_per_year"), Mul, kind=None), kind=None), Prim(Double(0.00005151389020466116), Var("solar_mass"), Mul, kind=None)]), Let(("sun", Var(None)), Tuple([Double(0), Double(0), Double(0), Double(0), Double(0), Double(0), Var("solar_mass")]), Let(("bodies", Var(None)), Array(Int(5), Tuple([Double(0), Double(0), Double(0), Double(0), Double(0), Double(0), Double(0)])), Let(("_", Var(None)), Put(Var("bodies"), Int(0), Var("sun")), Let(("_", Var(None)), Put(Var("bodies"), Int(1), Var("jupiter")), Let(("_", Var(None)), Put(Var("bodies"), Int(2), Var("saturn")), Let(("_", Var(None)), Put(Var("bodies"), Int(3), Var("uranus")), Let(("_", Var(None)), Put(Var("bodies"), Int(4), Var("neptune")), Let(("_", Var(None)), App(Var("offset_momentum"), targs=None, [Var("bodies")]), Let(("_", Var(None)), App(Var("print_int"), targs=None, [App(Var("int_of_float"), targs=None, [Prim(App(Var("energy"), targs=None, [Var("bodies")]), Double(1000000000), Mul, kind=None)])]), Let(("iters", Var(None)), Int(500000), LetRec({tyvars: [], name: ("loop_i", Var(None)), args: [("i", Int)], body: Let(("_", Var(None)), If(LE(Var("i"), Var("iters")), Let(("_", Var(None)), App(Var("advance"), targs=None, [Var("bodies"), Double(0.01)]), Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Unit)), Unit), Unit)}, Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Int(1)]), Let(("_", Var(None)), App(Var("print_char"), targs=None, [Int(10)]), Let(("_", Var(None)), App(Var("print_int"), targs=None, [App(Var("int_of_float"), targs=None, [Prim(App(Var("energy"), targs=None, [Var("bodies")]), Double(1000000000), Mul, kind=None)])]), Unit)))))))))))))))
// [Typer] infer: Tuple([Double(15.379697114850917), Neg(Double(25.919314609987964), kind=None), Double(0.17925877295037118), Prim(Double(0.0026806777249038932), Var("days_per_year"), Mul, kind=None), Prim(Double(0.001628241700382423), Var("days_per_year"), Mul, kind=None), Neg(Prim(Double(0.00009515922545197159), Var("days_per_year"), Mul, kind=None), kind=None), Prim(Double(0.00005151389020466116), Var("solar_mass"), Mul, kind=None)])
// [Typer] infer: Double(15.379697114850917)
// [Typer] infer: Neg(Double(25.919314609987964), kind=None)
// [Typer] infer: Double(25.919314609987964)
// [Typer] infer: Double(0.17925877295037118)
// [Typer] infer: Prim(Double(0.0026806777249038932), Var("days_per_year"), Mul, kind=None)
// [Typer] infer: Double(0.0026806777249038932)
// [Typer] infer: Var("days_per_year")
// [Typer] inst: TypeScheme(([], Double))
// [Typer] inst result: Double
// [Typer] unify: Double and Double
// [Typer] infer: Prim(Double(0.001628241700382423), Var("days_per_year"), Mul, kind=None)
// [Typer] infer: Double(0.001628241700382423)
// [Typer] infer: Var("days_per_year")
// [Typer] inst: TypeScheme(([], Double))
// [Typer] inst result: Double
// [Typer] unify: Double and Double
// [Typer] infer: Neg(Prim(Double(0.00009515922545197159), Var("days_per_year"), Mul, kind=None), kind=None)
// [Typer] infer: Prim(Double(0.00009515922545197159), Var("days_per_year"), Mul, kind=None)
// [Typer] infer: Double(0.00009515922545197159)
// [Typer] infer: Var("days_per_year")
// [Typer] inst: TypeScheme(([], Double))
// [Typer] inst result: Double
// [Typer] unify: Double and Double
// [Typer] infer: Prim(Double(0.00005151389020466116), Var("solar_mass"), Mul, kind=None)
// [Typer] infer: Double(0.00005151389020466116)
// [Typer] infer: Var("solar_mass")
// [Typer] inst: TypeScheme(([], Double))
// [Typer] inst result: Double
// [Typer] unify: Double and Double
// [Typer] unify: Var(None) and (Double, Double, Double, Double, Double, Double, Double)
// [Typer] union: Var(None) and (Double, Double, Double, Double, Double, Double, Double)
// [Typer] infer: Let(("sun", Var(None)), Tuple([Double(0), Double(0), Double(0), Double(0), Double(0), Double(0), Var("solar_mass")]), Let(("bodies", Var(None)), Array(Int(5), Tuple([Double(0), Double(0), Double(0), Double(0), Double(0), Double(0), Double(0)])), Let(("_", Var(None)), Put(Var("bodies"), Int(0), Var("sun")), Let(("_", Var(None)), Put(Var("bodies"), Int(1), Var("jupiter")), Let(("_", Var(None)), Put(Var("bodies"), Int(2), Var("saturn")), Let(("_", Var(None)), Put(Var("bodies"), Int(3), Var("uranus")), Let(("_", Var(None)), Put(Var("bodies"), Int(4), Var("neptune")), Let(("_", Var(None)), App(Var("offset_momentum"), targs=None, [Var("bodies")]), Let(("_", Var(None)), App(Var("print_int"), targs=None, [App(Var("int_of_float"), targs=None, [Prim(App(Var("energy"), targs=None, [Var("bodies")]), Double(1000000000), Mul, kind=None)])]), Let(("iters", Var(None)), Int(500000), LetRec({tyvars: [], name: ("loop_i", Var(None)), args: [("i", Int)], body: Let(("_", Var(None)), If(LE(Var("i"), Var("iters")), Let(("_", Var(None)), App(Var("advance"), targs=None, [Var("bodies"), Double(0.01)]), Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Unit)), Unit), Unit)}, Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Int(1)]), Let(("_", Var(None)), App(Var("print_char"), targs=None, [Int(10)]), Let(("_", Var(None)), App(Var("print_int"), targs=None, [App(Var("int_of_float"), targs=None, [Prim(App(Var("energy"), targs=None, [Var("bodies")]), Double(1000000000), Mul, kind=None)])]), Unit))))))))))))))
// [Typer] infer: Tuple([Double(0), Double(0), Double(0), Double(0), Double(0), Double(0), Var("solar_mass")])
// [Typer] infer: Double(0)
// [Typer] infer: Double(0)
// [Typer] infer: Double(0)
// [Typer] infer: Double(0)
// [Typer] infer: Double(0)
// [Typer] infer: Double(0)
// [Typer] infer: Var("solar_mass")
// [Typer] inst: TypeScheme(([], Double))
// [Typer] inst result: Double
// [Typer] unify: Var(None) and (Double, Double, Double, Double, Double, Double, Double)
// [Typer] union: Var(None) and (Double, Double, Double, Double, Double, Double, Double)
// [Typer] infer: Let(("bodies", Var(None)), Array(Int(5), Tuple([Double(0), Double(0), Double(0), Double(0), Double(0), Double(0), Double(0)])), Let(("_", Var(None)), Put(Var("bodies"), Int(0), Var("sun")), Let(("_", Var(None)), Put(Var("bodies"), Int(1), Var("jupiter")), Let(("_", Var(None)), Put(Var("bodies"), Int(2), Var("saturn")), Let(("_", Var(None)), Put(Var("bodies"), Int(3), Var("uranus")), Let(("_", Var(None)), Put(Var("bodies"), Int(4), Var("neptune")), Let(("_", Var(None)), App(Var("offset_momentum"), targs=None, [Var("bodies")]), Let(("_", Var(None)), App(Var("print_int"), targs=None, [App(Var("int_of_float"), targs=None, [Prim(App(Var("energy"), targs=None, [Var("bodies")]), Double(1000000000), Mul, kind=None)])]), Let(("iters", Var(None)), Int(500000), LetRec({tyvars: [], name: ("loop_i", Var(None)), args: [("i", Int)], body: Let(("_", Var(None)), If(LE(Var("i"), Var("iters")), Let(("_", Var(None)), App(Var("advance"), targs=None, [Var("bodies"), Double(0.01)]), Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Unit)), Unit), Unit)}, Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Int(1)]), Let(("_", Var(None)), App(Var("print_char"), targs=None, [Int(10)]), Let(("_", Var(None)), App(Var("print_int"), targs=None, [App(Var("int_of_float"), targs=None, [Prim(App(Var("energy"), targs=None, [Var("bodies")]), Double(1000000000), Mul, kind=None)])]), Unit)))))))))))))
// [Typer] infer: Array(Int(5), Tuple([Double(0), Double(0), Double(0), Double(0), Double(0), Double(0), Double(0)]))
// [Typer] infer: Tuple([Double(0), Double(0), Double(0), Double(0), Double(0), Double(0), Double(0)])
// [Typer] infer: Double(0)
// [Typer] infer: Double(0)
// [Typer] infer: Double(0)
// [Typer] infer: Double(0)
// [Typer] infer: Double(0)
// [Typer] infer: Double(0)
// [Typer] infer: Double(0)
// [Typer] check: Int(5) against Int
// [Typer] unify: Var(None) and Array[(Double, Double, Double, Double, Double, Double, Double)]
// [Typer] union: Var(None) and Array[(Double, Double, Double, Double, Double, Double, Double)]
// [Typer] infer: Let(("_", Var(None)), Put(Var("bodies"), Int(0), Var("sun")), Let(("_", Var(None)), Put(Var("bodies"), Int(1), Var("jupiter")), Let(("_", Var(None)), Put(Var("bodies"), Int(2), Var("saturn")), Let(("_", Var(None)), Put(Var("bodies"), Int(3), Var("uranus")), Let(("_", Var(None)), Put(Var("bodies"), Int(4), Var("neptune")), Let(("_", Var(None)), App(Var("offset_momentum"), targs=None, [Var("bodies")]), Let(("_", Var(None)), App(Var("print_int"), targs=None, [App(Var("int_of_float"), targs=None, [Prim(App(Var("energy"), targs=None, [Var("bodies")]), Double(1000000000), Mul, kind=None)])]), Let(("iters", Var(None)), Int(500000), LetRec({tyvars: [], name: ("loop_i", Var(None)), args: [("i", Int)], body: Let(("_", Var(None)), If(LE(Var("i"), Var("iters")), Let(("_", Var(None)), App(Var("advance"), targs=None, [Var("bodies"), Double(0.01)]), Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Unit)), Unit), Unit)}, Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Int(1)]), Let(("_", Var(None)), App(Var("print_char"), targs=None, [Int(10)]), Let(("_", Var(None)), App(Var("print_int"), targs=None, [App(Var("int_of_float"), targs=None, [Prim(App(Var("energy"), targs=None, [Var("bodies")]), Double(1000000000), Mul, kind=None)])]), Unit))))))))))))
// [Typer] infer: Put(Var("bodies"), Int(0), Var("sun"))
// [Typer] infer: Var("sun")
// [Typer] inst: TypeScheme(([], (Double, Double, Double, Double, Double, Double, Double)))
// [Typer] inst result: (Double, Double, Double, Double, Double, Double, Double)
// [Typer] check: Var("bodies") against Array[(Double, Double, Double, Double, Double, Double, Double)]
// [Typer] inst: TypeScheme(([], Array[(Double, Double, Double, Double, Double, Double, Double)]))
// [Typer] inst result: Array[(Double, Double, Double, Double, Double, Double, Double)]
// [Typer] unify: Array[(Double, Double, Double, Double, Double, Double, Double)] and Array[(Double, Double, Double, Double, Double, Double, Double)]
// [Typer] unify: (Double, Double, Double, Double, Double, Double, Double) and (Double, Double, Double, Double, Double, Double, Double)
// [Typer] unify: Double and Double
// [Typer] unify: Double and Double
// [Typer] unify: Double and Double
// [Typer] unify: Double and Double
// [Typer] unify: Double and Double
// [Typer] unify: Double and Double
// [Typer] unify: Double and Double
// [Typer] check: Int(0) against Int
// [Typer] unify: Var(None) and Unit
// [Typer] union: Var(None) and Unit
// [Typer] infer: Let(("_", Var(None)), Put(Var("bodies"), Int(1), Var("jupiter")), Let(("_", Var(None)), Put(Var("bodies"), Int(2), Var("saturn")), Let(("_", Var(None)), Put(Var("bodies"), Int(3), Var("uranus")), Let(("_", Var(None)), Put(Var("bodies"), Int(4), Var("neptune")), Let(("_", Var(None)), App(Var("offset_momentum"), targs=None, [Var("bodies")]), Let(("_", Var(None)), App(Var("print_int"), targs=None, [App(Var("int_of_float"), targs=None, [Prim(App(Var("energy"), targs=None, [Var("bodies")]), Double(1000000000), Mul, kind=None)])]), Let(("iters", Var(None)), Int(500000), LetRec({tyvars: [], name: ("loop_i", Var(None)), args: [("i", Int)], body: Let(("_", Var(None)), If(LE(Var("i"), Var("iters")), Let(("_", Var(None)), App(Var("advance"), targs=None, [Var("bodies"), Double(0.01)]), Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Unit)), Unit), Unit)}, Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Int(1)]), Let(("_", Var(None)), App(Var("print_char"), targs=None, [Int(10)]), Let(("_", Var(None)), App(Var("print_int"), targs=None, [App(Var("int_of_float"), targs=None, [Prim(App(Var("energy"), targs=None, [Var("bodies")]), Double(1000000000), Mul, kind=None)])]), Unit)))))))))))
// [Typer] infer: Put(Var("bodies"), Int(1), Var("jupiter"))
// [Typer] infer: Var("jupiter")
// [Typer] inst: TypeScheme(([], (Double, Double, Double, Double, Double, Double, Double)))
// [Typer] inst result: (Double, Double, Double, Double, Double, Double, Double)
// [Typer] check: Var("bodies") against Array[(Double, Double, Double, Double, Double, Double, Double)]
// [Typer] inst: TypeScheme(([], Array[(Double, Double, Double, Double, Double, Double, Double)]))
// [Typer] inst result: Array[(Double, Double, Double, Double, Double, Double, Double)]
// [Typer] unify: Array[(Double, Double, Double, Double, Double, Double, Double)] and Array[(Double, Double, Double, Double, Double, Double, Double)]
// [Typer] unify: (Double, Double, Double, Double, Double, Double, Double) and (Double, Double, Double, Double, Double, Double, Double)
// [Typer] unify: Double and Double
// [Typer] unify: Double and Double
// [Typer] unify: Double and Double
// [Typer] unify: Double and Double
// [Typer] unify: Double and Double
// [Typer] unify: Double and Double
// [Typer] unify: Double and Double
// [Typer] check: Int(1) against Int
// [Typer] unify: Var(None) and Unit
// [Typer] union: Var(None) and Unit
// [Typer] infer: Let(("_", Var(None)), Put(Var("bodies"), Int(2), Var("saturn")), Let(("_", Var(None)), Put(Var("bodies"), Int(3), Var("uranus")), Let(("_", Var(None)), Put(Var("bodies"), Int(4), Var("neptune")), Let(("_", Var(None)), App(Var("offset_momentum"), targs=None, [Var("bodies")]), Let(("_", Var(None)), App(Var("print_int"), targs=None, [App(Var("int_of_float"), targs=None, [Prim(App(Var("energy"), targs=None, [Var("bodies")]), Double(1000000000), Mul, kind=None)])]), Let(("iters", Var(None)), Int(500000), LetRec({tyvars: [], name: ("loop_i", Var(None)), args: [("i", Int)], body: Let(("_", Var(None)), If(LE(Var("i"), Var("iters")), Let(("_", Var(None)), App(Var("advance"), targs=None, [Var("bodies"), Double(0.01)]), Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Unit)), Unit), Unit)}, Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Int(1)]), Let(("_", Var(None)), App(Var("print_char"), targs=None, [Int(10)]), Let(("_", Var(None)), App(Var("print_int"), targs=None, [App(Var("int_of_float"), targs=None, [Prim(App(Var("energy"), targs=None, [Var("bodies")]), Double(1000000000), Mul, kind=None)])]), Unit))))))))))
// [Typer] infer: Put(Var("bodies"), Int(2), Var("saturn"))
// [Typer] infer: Var("saturn")
// [Typer] inst: TypeScheme(([], (Double, Double, Double, Double, Double, Double, Double)))
// [Typer] inst result: (Double, Double, Double, Double, Double, Double, Double)
// [Typer] check: Var("bodies") against Array[(Double, Double, Double, Double, Double, Double, Double)]
// [Typer] inst: TypeScheme(([], Array[(Double, Double, Double, Double, Double, Double, Double)]))
// [Typer] inst result: Array[(Double, Double, Double, Double, Double, Double, Double)]
// [Typer] unify: Array[(Double, Double, Double, Double, Double, Double, Double)] and Array[(Double, Double, Double, Double, Double, Double, Double)]
// [Typer] unify: (Double, Double, Double, Double, Double, Double, Double) and (Double, Double, Double, Double, Double, Double, Double)
// [Typer] unify: Double and Double
// [Typer] unify: Double and Double
// [Typer] unify: Double and Double
// [Typer] unify: Double and Double
// [Typer] unify: Double and Double
// [Typer] unify: Double and Double
// [Typer] unify: Double and Double
// [Typer] check: Int(2) against Int
// [Typer] unify: Var(None) and Unit
// [Typer] union: Var(None) and Unit
// [Typer] infer: Let(("_", Var(None)), Put(Var("bodies"), Int(3), Var("uranus")), Let(("_", Var(None)), Put(Var("bodies"), Int(4), Var("neptune")), Let(("_", Var(None)), App(Var("offset_momentum"), targs=None, [Var("bodies")]), Let(("_", Var(None)), App(Var("print_int"), targs=None, [App(Var("int_of_float"), targs=None, [Prim(App(Var("energy"), targs=None, [Var("bodies")]), Double(1000000000), Mul, kind=None)])]), Let(("iters", Var(None)), Int(500000), LetRec({tyvars: [], name: ("loop_i", Var(None)), args: [("i", Int)], body: Let(("_", Var(None)), If(LE(Var("i"), Var("iters")), Let(("_", Var(None)), App(Var("advance"), targs=None, [Var("bodies"), Double(0.01)]), Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Unit)), Unit), Unit)}, Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Int(1)]), Let(("_", Var(None)), App(Var("print_char"), targs=None, [Int(10)]), Let(("_", Var(None)), App(Var("print_int"), targs=None, [App(Var("int_of_float"), targs=None, [Prim(App(Var("energy"), targs=None, [Var("bodies")]), Double(1000000000), Mul, kind=None)])]), Unit)))))))))
// [Typer] infer: Put(Var("bodies"), Int(3), Var("uranus"))
// [Typer] infer: Var("uranus")
// [Typer] inst: TypeScheme(([], (Double, Double, Double, Double, Double, Double, Double)))
// [Typer] inst result: (Double, Double, Double, Double, Double, Double, Double)
// [Typer] check: Var("bodies") against Array[(Double, Double, Double, Double, Double, Double, Double)]
// [Typer] inst: TypeScheme(([], Array[(Double, Double, Double, Double, Double, Double, Double)]))
// [Typer] inst result: Array[(Double, Double, Double, Double, Double, Double, Double)]
// [Typer] unify: Array[(Double, Double, Double, Double, Double, Double, Double)] and Array[(Double, Double, Double, Double, Double, Double, Double)]
// [Typer] unify: (Double, Double, Double, Double, Double, Double, Double) and (Double, Double, Double, Double, Double, Double, Double)
// [Typer] unify: Double and Double
// [Typer] unify: Double and Double
// [Typer] unify: Double and Double
// [Typer] unify: Double and Double
// [Typer] unify: Double and Double
// [Typer] unify: Double and Double
// [Typer] unify: Double and Double
// [Typer] check: Int(3) against Int
// [Typer] unify: Var(None) and Unit
// [Typer] union: Var(None) and Unit
// [Typer] infer: Let(("_", Var(None)), Put(Var("bodies"), Int(4), Var("neptune")), Let(("_", Var(None)), App(Var("offset_momentum"), targs=None, [Var("bodies")]), Let(("_", Var(None)), App(Var("print_int"), targs=None, [App(Var("int_of_float"), targs=None, [Prim(App(Var("energy"), targs=None, [Var("bodies")]), Double(1000000000), Mul, kind=None)])]), Let(("iters", Var(None)), Int(500000), LetRec({tyvars: [], name: ("loop_i", Var(None)), args: [("i", Int)], body: Let(("_", Var(None)), If(LE(Var("i"), Var("iters")), Let(("_", Var(None)), App(Var("advance"), targs=None, [Var("bodies"), Double(0.01)]), Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Unit)), Unit), Unit)}, Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Int(1)]), Let(("_", Var(None)), App(Var("print_char"), targs=None, [Int(10)]), Let(("_", Var(None)), App(Var("print_int"), targs=None, [App(Var("int_of_float"), targs=None, [Prim(App(Var("energy"), targs=None, [Var("bodies")]), Double(1000000000), Mul, kind=None)])]), Unit))))))))
// [Typer] infer: Put(Var("bodies"), Int(4), Var("neptune"))
// [Typer] infer: Var("neptune")
// [Typer] inst: TypeScheme(([], (Double, Double, Double, Double, Double, Double, Double)))
// [Typer] inst result: (Double, Double, Double, Double, Double, Double, Double)
// [Typer] check: Var("bodies") against Array[(Double, Double, Double, Double, Double, Double, Double)]
// [Typer] inst: TypeScheme(([], Array[(Double, Double, Double, Double, Double, Double, Double)]))
// [Typer] inst result: Array[(Double, Double, Double, Double, Double, Double, Double)]
// [Typer] unify: Array[(Double, Double, Double, Double, Double, Double, Double)] and Array[(Double, Double, Double, Double, Double, Double, Double)]
// [Typer] unify: (Double, Double, Double, Double, Double, Double, Double) and (Double, Double, Double, Double, Double, Double, Double)
// [Typer] unify: Double and Double
// [Typer] unify: Double and Double
// [Typer] unify: Double and Double
// [Typer] unify: Double and Double
// [Typer] unify: Double and Double
// [Typer] unify: Double and Double
// [Typer] unify: Double and Double
// [Typer] check: Int(4) against Int
// [Typer] unify: Var(None) and Unit
// [Typer] union: Var(None) and Unit
// [Typer] infer: Let(("_", Var(None)), App(Var("offset_momentum"), targs=None, [Var("bodies")]), Let(("_", Var(None)), App(Var("print_int"), targs=None, [App(Var("int_of_float"), targs=None, [Prim(App(Var("energy"), targs=None, [Var("bodies")]), Double(1000000000), Mul, kind=None)])]), Let(("iters", Var(None)), Int(500000), LetRec({tyvars: [], name: ("loop_i", Var(None)), args: [("i", Int)], body: Let(("_", Var(None)), If(LE(Var("i"), Var("iters")), Let(("_", Var(None)), App(Var("advance"), targs=None, [Var("bodies"), Double(0.01)]), Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Unit)), Unit), Unit)}, Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Int(1)]), Let(("_", Var(None)), App(Var("print_char"), targs=None, [Int(10)]), Let(("_", Var(None)), App(Var("print_int"), targs=None, [App(Var("int_of_float"), targs=None, [Prim(App(Var("energy"), targs=None, [Var("bodies")]), Double(1000000000), Mul, kind=None)])]), Unit)))))))
// [Typer] infer: App(Var("offset_momentum"), targs=None, [Var("bodies")])
// [Typer] inst: TypeScheme(([], (Array[(Double, Double, Double, Double, Double, Double, Double)]) -> Unit))
// [Typer] inst result: (Array[(Double, Double, Double, Double, Double, Double, Double)]) -> Unit
// [Typer] check: Var("bodies") against Array[(Double, Double, Double, Double, Double, Double, Double)]
// [Typer] inst: TypeScheme(([], Array[(Double, Double, Double, Double, Double, Double, Double)]))
// [Typer] inst result: Array[(Double, Double, Double, Double, Double, Double, Double)]
// [Typer] unify: Array[(Double, Double, Double, Double, Double, Double, Double)] and Array[(Double, Double, Double, Double, Double, Double, Double)]
// [Typer] unify: (Double, Double, Double, Double, Double, Double, Double) and (Double, Double, Double, Double, Double, Double, Double)
// [Typer] unify: Double and Double
// [Typer] unify: Double and Double
// [Typer] unify: Double and Double
// [Typer] unify: Double and Double
// [Typer] unify: Double and Double
// [Typer] unify: Double and Double
// [Typer] unify: Double and Double
// [Typer] unify: Var(None) and Unit
// [Typer] union: Var(None) and Unit
// [Typer] infer: Let(("_", Var(None)), App(Var("print_int"), targs=None, [App(Var("int_of_float"), targs=None, [Prim(App(Var("energy"), targs=None, [Var("bodies")]), Double(1000000000), Mul, kind=None)])]), Let(("iters", Var(None)), Int(500000), LetRec({tyvars: [], name: ("loop_i", Var(None)), args: [("i", Int)], body: Let(("_", Var(None)), If(LE(Var("i"), Var("iters")), Let(("_", Var(None)), App(Var("advance"), targs=None, [Var("bodies"), Double(0.01)]), Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Unit)), Unit), Unit)}, Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Int(1)]), Let(("_", Var(None)), App(Var("print_char"), targs=None, [Int(10)]), Let(("_", Var(None)), App(Var("print_int"), targs=None, [App(Var("int_of_float"), targs=None, [Prim(App(Var("energy"), targs=None, [Var("bodies")]), Double(1000000000), Mul, kind=None)])]), Unit))))))
// [Typer] infer: App(Var("print_int"), targs=None, [App(Var("int_of_float"), targs=None, [Prim(App(Var("energy"), targs=None, [Var("bodies")]), Double(1000000000), Mul, kind=None)])])
// [Typer] inst: TypeScheme(([], (Int) -> Unit))
// [Typer] inst result: (Int) -> Unit
// [Typer] check: App(Var("int_of_float"), targs=None, [Prim(App(Var("energy"), targs=None, [Var("bodies")]), Double(1000000000), Mul, kind=None)]) against Int
// [Typer] infer: Prim(App(Var("energy"), targs=None, [Var("bodies")]), Double(1000000000), Mul, kind=None)
// [Typer] infer: App(Var("energy"), targs=None, [Var("bodies")])
// [Typer] inst: TypeScheme(([], (Array[(Double, Double, Double, Double, Double, Double, Double)]) -> Double))
// [Typer] inst result: (Array[(Double, Double, Double, Double, Double, Double, Double)]) -> Double
// [Typer] check: Var("bodies") against Array[(Double, Double, Double, Double, Double, Double, Double)]
// [Typer] inst: TypeScheme(([], Array[(Double, Double, Double, Double, Double, Double, Double)]))
// [Typer] inst result: Array[(Double, Double, Double, Double, Double, Double, Double)]
// [Typer] unify: Array[(Double, Double, Double, Double, Double, Double, Double)] and Array[(Double, Double, Double, Double, Double, Double, Double)]
// [Typer] unify: (Double, Double, Double, Double, Double, Double, Double) and (Double, Double, Double, Double, Double, Double, Double)
// [Typer] unify: Double and Double
// [Typer] unify: Double and Double
// [Typer] unify: Double and Double
// [Typer] unify: Double and Double
// [Typer] unify: Double and Double
// [Typer] unify: Double and Double
// [Typer] unify: Double and Double
// [Typer] infer: Double(1000000000)
// [Typer] unify: Double and Double
// [Typer] inst: TypeScheme(([], (Double) -> Int))
// [Typer] inst result: (Double) -> Int
// [Typer] unify: (Double) -> Int and (Double) -> Int
// [Typer] unify: Double and Double
// [Typer] unify: Int and Int
// [Typer] unify: Var(None) and Unit
// [Typer] union: Var(None) and Unit
// [Typer] infer: Let(("iters", Var(None)), Int(500000), LetRec({tyvars: [], name: ("loop_i", Var(None)), args: [("i", Int)], body: Let(("_", Var(None)), If(LE(Var("i"), Var("iters")), Let(("_", Var(None)), App(Var("advance"), targs=None, [Var("bodies"), Double(0.01)]), Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Unit)), Unit), Unit)}, Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Int(1)]), Let(("_", Var(None)), App(Var("print_char"), targs=None, [Int(10)]), Let(("_", Var(None)), App(Var("print_int"), targs=None, [App(Var("int_of_float"), targs=None, [Prim(App(Var("energy"), targs=None, [Var("bodies")]), Double(1000000000), Mul, kind=None)])]), Unit)))))
// [Typer] infer: Int(500000)
// [Typer] unify: Var(None) and Int
// [Typer] union: Var(None) and Int
// [Typer] infer: LetRec({tyvars: [], name: ("loop_i", Var(None)), args: [("i", Int)], body: Let(("_", Var(None)), If(LE(Var("i"), Var("iters")), Let(("_", Var(None)), App(Var("advance"), targs=None, [Var("bodies"), Double(0.01)]), Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Unit)), Unit), Unit)}, Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Int(1)]), Let(("_", Var(None)), App(Var("print_char"), targs=None, [Int(10)]), Let(("_", Var(None)), App(Var("print_int"), targs=None, [App(Var("int_of_float"), targs=None, [Prim(App(Var("energy"), targs=None, [Var("bodies")]), Double(1000000000), Mul, kind=None)])]), Unit))))
// [Typer] typevars: []
// [Typer] infer: Let(("_", Var(None)), If(LE(Var("i"), Var("iters")), Let(("_", Var(None)), App(Var("advance"), targs=None, [Var("bodies"), Double(0.01)]), Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Unit)), Unit), Unit)
// [Typer] infer: If(LE(Var("i"), Var("iters")), Let(("_", Var(None)), App(Var("advance"), targs=None, [Var("bodies"), Double(0.01)]), Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Unit)), Unit)
// [Typer] check: LE(Var("i"), Var("iters")) against Bool
// [Typer] infer: Var("i")
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] infer: Var("iters")
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] infer: Let(("_", Var(None)), App(Var("advance"), targs=None, [Var("bodies"), Double(0.01)]), Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Unit))
// [Typer] infer: App(Var("advance"), targs=None, [Var("bodies"), Double(0.01)])
// [Typer] inst: TypeScheme(([], (Array[(Double, Double, Double, Double, Double, Double, Double)], Double) -> Unit))
// [Typer] inst result: (Array[(Double, Double, Double, Double, Double, Double, Double)], Double) -> Unit
// [Typer] check: Var("bodies") against Array[(Double, Double, Double, Double, Double, Double, Double)]
// [Typer] inst: TypeScheme(([], Array[(Double, Double, Double, Double, Double, Double, Double)]))
// [Typer] inst result: Array[(Double, Double, Double, Double, Double, Double, Double)]
// [Typer] unify: Array[(Double, Double, Double, Double, Double, Double, Double)] and Array[(Double, Double, Double, Double, Double, Double, Double)]
// [Typer] unify: (Double, Double, Double, Double, Double, Double, Double) and (Double, Double, Double, Double, Double, Double, Double)
// [Typer] unify: Double and Double
// [Typer] unify: Double and Double
// [Typer] unify: Double and Double
// [Typer] unify: Double and Double
// [Typer] unify: Double and Double
// [Typer] unify: Double and Double
// [Typer] unify: Double and Double
// [Typer] check: Double(0.01) against Double
// [Typer] unify: Var(None) and Unit
// [Typer] union: Var(None) and Unit
// [Typer] infer: Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)]), Unit)
// [Typer] infer: App(Var("loop_i"), targs=None, [Prim(Var("i"), Int(1), Add, kind=None)])
// [Typer] inst: TypeScheme(([], (Int) -> Var(None)))
// [Typer] inst result: (Int) -> Var(None)
// [Typer] check: Prim(Var("i"), Int(1), Add, kind=None) against Int
// [Typer] check: Var("i") against Int
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] check: Int(1) against Int
// [Typer] unify: Var(None) and Var(None)
// [Typer] union: Var(None) and Var(None)
// [Typer] infer: Unit
// [Typer] infer: Unit
// [Typer] unify: Unit and Unit
// [Typer] unify: Var(None) and Unit
// [Typer] union: Var(None) and Unit
// [Typer] infer: Unit
// [Typer] unify: Unit and Var(None)
// [Typer] union: Unit and Var(None)
// [Typer] infer: Let(("_", Var(None)), App(Var("loop_i"), targs=None, [Int(1)]), Let(("_", Var(None)), App(Var("print_char"), targs=None, [Int(10)]), Let(("_", Var(None)), App(Var("print_int"), targs=None, [App(Var("int_of_float"), targs=None, [Prim(App(Var("energy"), targs=None, [Var("bodies")]), Double(1000000000), Mul, kind=None)])]), Unit)))
// [Typer] infer: App(Var("loop_i"), targs=None, [Int(1)])
// [Typer] inst: TypeScheme(([], (Int) -> Unit))
// [Typer] inst result: (Int) -> Unit
// [Typer] check: Int(1) against Int
// [Typer] unify: Var(None) and Unit
// [Typer] union: Var(None) and Unit
// [Typer] infer: Let(("_", Var(None)), App(Var("print_char"), targs=None, [Int(10)]), Let(("_", Var(None)), App(Var("print_int"), targs=None, [App(Var("int_of_float"), targs=None, [Prim(App(Var("energy"), targs=None, [Var("bodies")]), Double(1000000000), Mul, kind=None)])]), Unit))
// [Typer] infer: App(Var("print_char"), targs=None, [Int(10)])
// [Typer] inst: TypeScheme(([], (Int) -> Unit))
// [Typer] inst result: (Int) -> Unit
// [Typer] check: Int(10) against Int
// [Typer] unify: Var(None) and Unit
// [Typer] union: Var(None) and Unit
// [Typer] infer: Let(("_", Var(None)), App(Var("print_int"), targs=None, [App(Var("int_of_float"), targs=None, [Prim(App(Var("energy"), targs=None, [Var("bodies")]), Double(1000000000), Mul, kind=None)])]), Unit)
// [Typer] infer: App(Var("print_int"), targs=None, [App(Var("int_of_float"), targs=None, [Prim(App(Var("energy"), targs=None, [Var("bodies")]), Double(1000000000), Mul, kind=None)])])
// [Typer] inst: TypeScheme(([], (Int) -> Unit))
// [Typer] inst result: (Int) -> Unit
// [Typer] check: App(Var("int_of_float"), targs=None, [Prim(App(Var("energy"), targs=None, [Var("bodies")]), Double(1000000000), Mul, kind=None)]) against Int
// [Typer] infer: Prim(App(Var("energy"), targs=None, [Var("bodies")]), Double(1000000000), Mul, kind=None)
// [Typer] infer: App(Var("energy"), targs=None, [Var("bodies")])
// [Typer] inst: TypeScheme(([], (Array[(Double, Double, Double, Double, Double, Double, Double)]) -> Double))
// [Typer] inst result: (Array[(Double, Double, Double, Double, Double, Double, Double)]) -> Double
// [Typer] check: Var("bodies") against Array[(Double, Double, Double, Double, Double, Double, Double)]
// [Typer] inst: TypeScheme(([], Array[(Double, Double, Double, Double, Double, Double, Double)]))
// [Typer] inst result: Array[(Double, Double, Double, Double, Double, Double, Double)]
// [Typer] unify: Array[(Double, Double, Double, Double, Double, Double, Double)] and Array[(Double, Double, Double, Double, Double, Double, Double)]
// [Typer] unify: (Double, Double, Double, Double, Double, Double, Double) and (Double, Double, Double, Double, Double, Double, Double)
// [Typer] unify: Double and Double
// [Typer] unify: Double and Double
// [Typer] unify: Double and Double
// [Typer] unify: Double and Double
// [Typer] unify: Double and Double
// [Typer] unify: Double and Double
// [Typer] unify: Double and Double
// [Typer] infer: Double(1000000000)
// [Typer] unify: Double and Double
// [Typer] inst: TypeScheme(([], (Double) -> Int))
// [Typer] inst result: (Double) -> Int
// [Typer] unify: (Double) -> Int and (Double) -> Int
// [Typer] unify: Double and Double
// [Typer] unify: Int and Int
// [Typer] unify: Var(None) and Unit
// [Typer] union: Var(None) and Unit
// [Typer] infer: Unit
// [Typer] unify: Unit and Var(None)
// [Typer] union: Unit and Var(None)
// [Typer] check: Unit against Unit
// [KnfOpt] freq: {advance.6: Once, loop_i.12: Many(2), loop_j.32: Many(2), update_axis.106: Many(2), energy.144: Many(2), loop_i.151: Many(2), loop_j.185: Many(2), offset_momentum.242: Once, loop_i.255: Many(2), main.337: Once, loop_i.437: Many(2)}
// [KnfOpt] Fn like 0
// [KnfOpt] Inline threshold 2 84
// [KnfOpt] Inline decision rejected
// [KnfOpt] Fn like 0
// [KnfOpt] Inline threshold 2 84
// [KnfOpt] Inline decision rejected
// [KnfOpt] Fn like 0
// [KnfOpt] Inline threshold 2 109
// [KnfOpt] Inline decision rejected
// [KnfOpt] Fn like 0
// [KnfOpt] Inline threshold 2 109
// [KnfOpt] Inline decision rejected
// [KnfOpt] Fn like 0
// [KnfOpt] Inline threshold 2 34
// [KnfOpt] Inline decision rejected
// [KnfOpt] Fn like 0
// [KnfOpt] Inline threshold 2 34
// [KnfOpt] Inline decision rejected
// [KnfOpt] Fn like 0
// [KnfOpt] Inline threshold 2 50
// [KnfOpt] Inline decision rejected
// [KnfOpt] Fn like 0
// [KnfOpt] Inline threshold 2 50
// [KnfOpt] Inline decision rejected
// [KnfOpt] Fn like 0
// [KnfOpt] Inline threshold 2 101
// [KnfOpt] Inline decision rejected
// [KnfOpt] Fn like 0
// [KnfOpt] Inline threshold 2 101
// [KnfOpt] Inline decision rejected
// [KnfOpt] Fn like 0
// [KnfOpt] Inline threshold 2 54
// [KnfOpt] Inline decision rejected
// [KnfOpt] Fn like 0
// [KnfOpt] Inline threshold 2 54
// [KnfOpt] Inline decision rejected
// [KnfOpt] Knf inline Some(offset_momentum)
// [KnfOpt] Fn like 0
// [KnfOpt] Inline threshold 2 117
// [KnfOpt] Inline decision rejected
// [KnfOpt] Knf inline Some(advance)
// [KnfOpt] Fn like 0
// [KnfOpt] Inline threshold 2 15
// [KnfOpt] Inline decision rejected
// [KnfOpt] Fn like 0
// [KnfOpt] Inline threshold 2 170
// [KnfOpt] Inline decision rejected
// [KnfOpt] Fn like 0
// [KnfOpt] Inline threshold 2 117
// [KnfOpt] Inline decision rejected
// [KnfOpt] freq: {energy.144: Many(2), loop_i.151: Many(2), loop_j.185: Many(2), main.337: Once, loop_i.471: Many(2), loop_i.437: Many(2), loop_i.532: Many(2), loop_j.545: Many(2), update_axis.602: Many(2)}
// [KnfOpt] Fn like 0
// [KnfOpt] Inline threshold 2 50
// [KnfOpt] Inline decision rejected
// [KnfOpt] Fn like 0
// [KnfOpt] Inline threshold 2 50
// [KnfOpt] Inline decision rejected
// [KnfOpt] Fn like 0
// [KnfOpt] Inline threshold 2 101
// [KnfOpt] Inline decision rejected
// [KnfOpt] Fn like 0
// [KnfOpt] Inline threshold 2 101
// [KnfOpt] Inline decision rejected
// [KnfOpt] Fn like 0
// [KnfOpt] Inline threshold 2 54
// [KnfOpt] Inline decision rejected
// [KnfOpt] Fn like 0
// [KnfOpt] Inline threshold 2 54
// [KnfOpt] Inline decision rejected
// [KnfOpt] Fn like 0
// [KnfOpt] Inline threshold 2 117
// [KnfOpt] Inline decision rejected
// [KnfOpt] Fn like 0
// [KnfOpt] Inline threshold 2 84
// [KnfOpt] Inline decision rejected
// [KnfOpt] Fn like 0
// [KnfOpt] Inline threshold 2 84
// [KnfOpt] Inline decision rejected
// [KnfOpt] Fn like 0
// [KnfOpt] Inline threshold 2 109
// [KnfOpt] Inline decision rejected
// [KnfOpt] Fn like 0
// [KnfOpt] Inline threshold 2 109
// [KnfOpt] Inline decision rejected
// [KnfOpt] Fn like 0
// [KnfOpt] Inline threshold 2 34
// [KnfOpt] Inline decision rejected
// [KnfOpt] Fn like 0
// [KnfOpt] Inline threshold 2 34
// [KnfOpt] Inline decision rejected
// [KnfOpt] Fn like 0
// [KnfOpt] Inline threshold 2 170
// [KnfOpt] Inline decision rejected
// [KnfOpt] Fn like 0
// [KnfOpt] Inline threshold 2 170
// [KnfOpt] Inline decision rejected
// [KnfOpt] Fn like 0
// [KnfOpt] Inline threshold 2 117
// [KnfOpt] Inline decision rejected
// [KnfOpt] freq: {energy.144: Many(2), loop_i.151: Many(2), loop_j.185: Many(2), main.337: Once, loop_i.471: Many(2), loop_i.437: Many(2), loop_i.532: Many(2), loop_j.545: Many(2), update_axis.602: Many(2)}
// [KnfOpt] Fn like 0
// [KnfOpt] Inline threshold 2 50
// [KnfOpt] Inline decision rejected
// [KnfOpt] Fn like 0
// [KnfOpt] Inline threshold 2 50
// [KnfOpt] Inline decision rejected
// [KnfOpt] Fn like 0
// [KnfOpt] Inline threshold 2 101
// [KnfOpt] Inline decision rejected
// [KnfOpt] Fn like 0
// [KnfOpt] Inline threshold 2 101
// [KnfOpt] Inline decision rejected
// [KnfOpt] Fn like 0
// [KnfOpt] Inline threshold 2 54
// [KnfOpt] Inline decision rejected
// [KnfOpt] Fn like 0
// [KnfOpt] Inline threshold 2 54
// [KnfOpt] Inline decision rejected
// [KnfOpt] Fn like 0
// [KnfOpt] Inline threshold 2 117
// [KnfOpt] Inline decision rejected
// [KnfOpt] Fn like 0
// [KnfOpt] Inline threshold 2 84
// [KnfOpt] Inline decision rejected
// [KnfOpt] Fn like 0
// [KnfOpt] Inline threshold 2 84
// [KnfOpt] Inline decision rejected
// [KnfOpt] Fn like 0
// [KnfOpt] Inline threshold 2 109
// [KnfOpt] Inline decision rejected
// [KnfOpt] Fn like 0
// [KnfOpt] Inline threshold 2 109
// [KnfOpt] Inline decision rejected
// [KnfOpt] Fn like 0
// [KnfOpt] Inline threshold 2 34
// [KnfOpt] Inline decision rejected
// [KnfOpt] Fn like 0
// [KnfOpt] Inline threshold 2 34
// [KnfOpt] Inline decision rejected
// [KnfOpt] Fn like 0
// [KnfOpt] Inline threshold 2 170
// [KnfOpt] Inline decision rejected
// [KnfOpt] Fn like 0
// [KnfOpt] Inline threshold 2 170
// [KnfOpt] Inline decision rejected
// [KnfOpt] Fn like 0
// [KnfOpt] Inline threshold 2 117
// [KnfOpt] Inline decision rejected
// [KnfOpt] Numbers of let rec: 9 9 0
// [KnfOpt] Tuple freq: {b2.190: Destructed, dist2.212: MayEscape, _219: MayEscape, _223: MayEscape, e.150: MayEscape, bm.170: MayEscape, bx.158: MayEscape, by.160: MayEscape, bz.162: MayEscape, bodies.146: MayEscape, b.156: Destructed, _182: MayEscape, _229: MayEscape, _233: MayEscape, _148: MayEscape, _149: MayEscape, _238: MayEscape, b.476: Destructed, _488: MayEscape, _494: MayEscape, _500: MayEscape, _503: MayEscape, px.464: MayEscape, py.467: MayEscape, pz.470: MayEscape, bodies.412: MayEscape, b2.550: Destructed, dist2.565: MayEscape, bx.538: MayEscape, by.539: MayEscape, bz.540: MayEscape, _571: MayEscape, _574: MayEscape, _577: MayEscape, bm.544: MayEscape, new_b.578: MayEscape, b2x.551: MayEscape, b2y.552: MayEscape, b2z.553: MayEscape, _582: MayEscape, _585: MayEscape, _588: MayEscape, b2m.557: MayEscape, new_b2.589: MayEscape, _592: MayEscape, _440: MayEscape, i.533: MayEscape, bvx.541: MayEscape, bvy.542: MayEscape, bvz.543: MayEscape, b.537: Destructed, _595: MayEscape, _598: MayEscape, b.607: Destructed, _616: MayEscape, _618: MayEscape, _620: MayEscape, bvx.611: MayEscape, bvy.612: MayEscape, bvz.613: MayEscape, bm.614: MayEscape, new_b.621: MayEscape, _624: MayEscape, _600: MayEscape, _626: MayEscape, _444: MayEscape, iters.436: MayEscape, _338: MayEscape, _340: MayEscape, _342: MayEscape, _344: MayEscape, _346: MayEscape, _349: MayEscape, _351: MayEscape, _353: MayEscape, _354: MayEscape, _356: MayEscape, _359: MayEscape, _361: MayEscape, _363: MayEscape, _365: MayEscape, _367: MayEscape, _369: MayEscape, _371: MayEscape, _373: MayEscape, _375: MayEscape, _378: MayEscape, _380: MayEscape, _382: MayEscape, _384: MayEscape, _385: MayEscape, _387: MayEscape, _389: MayEscape, _392: MayEscape, _394: MayEscape, _396: MayEscape, _397: MayEscape, _398: MayEscape, _399: MayEscape, _400: MayEscape, _401: MayEscape, solar_mass.4: MayEscape, _404: MayEscape, _405: MayEscape, _406: MayEscape, _407: MayEscape, _408: MayEscape, _409: MayEscape, _410: MayEscape, _403: MayEscape, _411: MayEscape, sun.402: MayEscape, jupiter.352: MayEscape, saturn.366: MayEscape, uranus.381: MayEscape, neptune.395: MayEscape, _462: MayEscape, _463: MayEscape, _465: MayEscape, _466: MayEscape, _468: MayEscape, _469: MayEscape, _505: MayEscape, b.508: Destructed, bx.509: MayEscape, by.510: MayEscape, bz.511: MayEscape, _519: MayEscape, _523: MayEscape, _527: MayEscape, bm.515: MayEscape, new_b.528: MayEscape, _432: MayEscape, _433: MayEscape, _449: MayEscape, _452: MayEscape, _457: MayEscape, _458: MayEscape}
// [Parser] flags: [""]
// [CoreOpt] Call frequnce: FnCallFreq({f6: Multiple, f4: Multiple, f8: Once, f0: Multiple, f1: Multiple, f5: Multiple, f2: Multiple, f18: Once, f3: Multiple, f7: Multiple})
// [CoreOpt] allow_inline: false %18 update_axis.636 true false true false true
// [CoreOpt] allow_inline: false %43 loop_j.635 true false true false true
// [CoreOpt] allow_inline: false %16 loop_i.632 false false true false true
// [CoreOpt] allow_inline: false %39 energy.628 false false true true true
// [CoreOpt] allow_inline: false %43 loop_i.633 false false true false true
// [CoreOpt] allow_inline: false %45 energy.628 false false true true true
// [CoreOpt] allow_inline: false %24 loop_j.630 true false true false true
// [CoreOpt] allow_inline: false %20 loop_j.630 true false true false true
// [CoreOpt] allow_inline: false %22 loop_i.629 true false true false true
// [CoreOpt] allow_inline: false %10 loop_j.635 true false true false true
// [CoreOpt] allow_inline: false %12 loop_i.634 true false true false true
// [CoreOpt] allow_inline: false %1 loop_i.629 true false true false true
// [CoreOpt] allow_inline: false %0 main.631 false true true false true
// [CoreOpt] allow_inline: false %22 loop_i.632 true false true false true
// [CoreOpt] allow_inline: false %1 loop_i.634 true false true false true
// [CoreOpt] allow_inline: false %2 update_axis.636 true false true false true
// [CoreOpt] allow_inline: false %4 loop_i.633 true false true false true
// [CoreOpt] allow_inline: false %18 update_axis.636 true false true false true
// [CoreOpt] allow_inline: false %43 loop_j.635 true false true false true
// [CoreOpt] allow_inline: false %16 loop_i.632 false false true false true
// [CoreOpt] allow_inline: false %39 energy.628 false false true true true
// [CoreOpt] allow_inline: false %43 loop_i.633 false false true false true
// [CoreOpt] allow_inline: false %45 energy.628 false false true true true
// [CoreOpt] allow_inline: false %24 loop_j.630 true false true false true
// [CoreOpt] allow_inline: false %20 loop_j.630 true false true false true
// [CoreOpt] allow_inline: false %22 loop_i.629 true false true false true
// [CoreOpt] allow_inline: false %10 loop_j.635 true false true false true
// [CoreOpt] allow_inline: false %12 loop_i.634 true false true false true
// [CoreOpt] allow_inline: false %1 loop_i.629 true false true false true
// [CoreOpt] allow_inline: false %0 main.631 false true true false true
// [CoreOpt] allow_inline: false %22 loop_i.632 true false true false true
// [CoreOpt] allow_inline: false %1 loop_i.634 true false true false true
// [CoreOpt] allow_inline: false %2 update_axis.636 true false true false true
// [CoreOpt] allow_inline: false %4 loop_i.633 true false true false true
// [CoreOpt] allow_inline: false %18 update_axis.636 true false true false true
// [CoreOpt] allow_inline: false %43 loop_j.635 true false true false true
// [CoreOpt] allow_inline: false %16 loop_i.632 false false true false true
// [CoreOpt] allow_inline: false %39 energy.628 false false true true true
// [CoreOpt] allow_inline: false %43 loop_i.633 false false true false true
// [CoreOpt] allow_inline: false %45 energy.628 false false true true true
// [CoreOpt] allow_inline: false %24 loop_j.630 true false true false true
// [CoreOpt] allow_inline: false %20 loop_j.630 true false true false true
// [CoreOpt] allow_inline: false %22 loop_i.629 true false true false true
// [CoreOpt] allow_inline: false %10 loop_j.635 true false true false true
// [CoreOpt] allow_inline: false %12 loop_i.634 true false true false true
// [CoreOpt] allow_inline: false %1 loop_i.629 true false true false true
// [CoreOpt] allow_inline: false %0 main.631 false true true false true
// [CoreOpt] allow_inline: false %22 loop_i.632 true false true false true
// [CoreOpt] allow_inline: false %1 loop_i.634 true false true false true
// [CoreOpt] allow_inline: false %2 update_axis.636 true false true false true
// [CoreOpt] allow_inline: false %4 loop_i.633 true false true false true
// [CoreOpt] allow_inline: false %18 update_axis.636 true false true false true
// [CoreOpt] allow_inline: false %43 loop_j.635 true false true false true
// [CoreOpt] allow_inline: false %16 loop_i.632 false false true false true
// [CoreOpt] allow_inline: false %39 energy.628 false false true true true
// [CoreOpt] allow_inline: false %43 loop_i.633 false false true false true
// [CoreOpt] allow_inline: false %45 energy.628 false false true true true
// [CoreOpt] allow_inline: false %24 loop_j.630 true false true false true
// [CoreOpt] allow_inline: false %20 loop_j.630 true false true false true
// [CoreOpt] allow_inline: false %22 loop_i.629 true false true false true
// [CoreOpt] allow_inline: false %10 loop_j.635 true false true false true
// [CoreOpt] allow_inline: false %12 loop_i.634 true false true false true
// [CoreOpt] allow_inline: false %1 loop_i.629 true false true false true
// [CoreOpt] allow_inline: false %0 main.631 false true true false true
// [CoreOpt] allow_inline: false %22 loop_i.632 true false true false true
// [CoreOpt] allow_inline: false %1 loop_i.634 true false true false true
// [CoreOpt] allow_inline: false %2 update_axis.636 true false true false true
// [CoreOpt] allow_inline: false %4 loop_i.633 true false true false true
// [CoreOpt] allow_inline: false %18 update_axis.636 true false true false true
// [CoreOpt] allow_inline: false %43 loop_j.635 true false true false true
// [CoreOpt] allow_inline: false %16 loop_i.632 false false true false true
// [CoreOpt] allow_inline: false %39 energy.628 false false true true true
// [CoreOpt] allow_inline: false %43 loop_i.633 false false true false true
// [CoreOpt] allow_inline: false %45 energy.628 false false true true true
// [CoreOpt] allow_inline: false %24 loop_j.630 true false true false true
// [CoreOpt] allow_inline: false %20 loop_j.630 true false true false true
// [CoreOpt] allow_inline: false %22 loop_i.629 true false true false true
// [CoreOpt] allow_inline: false %10 loop_j.635 true false true false true
// [CoreOpt] allow_inline: false %12 loop_i.634 true false true false true
// [CoreOpt] allow_inline: false %1 loop_i.629 true false true false true
// [CoreOpt] allow_inline: false %0 main.631 false true true false true
// [CoreOpt] allow_inline: false %22 loop_i.632 true false true false true
// [CoreOpt] allow_inline: false %1 loop_i.634 true false true false true
// [CoreOpt] allow_inline: false %2 update_axis.636 true false true false true
// [CoreOpt] allow_inline: false %4 loop_i.633 true false true false true
// [CoreOpt] allow_inline: false %18 update_axis.636 true false true false true
// [CoreOpt] allow_inline: false %43 loop_j.635 true false true false true
// [CoreOpt] allow_inline: false %16 loop_i.632 false false true false true
// [CoreOpt] allow_inline: false %39 energy.628 false false true true true
// [CoreOpt] allow_inline: false %43 loop_i.633 false false true false true
// [CoreOpt] allow_inline: false %45 energy.628 false false true true true
// [CoreOpt] allow_inline: false %24 loop_j.630 true false true false true
// [CoreOpt] allow_inline: false %20 loop_j.630 true false true false true
// [CoreOpt] allow_inline: false %22 loop_i.629 true false true false true
// [CoreOpt] allow_inline: false %10 loop_j.635 true false true false true
// [CoreOpt] allow_inline: false %12 loop_i.634 true false true false true
// [CoreOpt] allow_inline: false %1 loop_i.629 true false true false true
// [CoreOpt] allow_inline: false %0 main.631 false true true false true
// [CoreOpt] allow_inline: false %22 loop_i.632 true false true false true
// [CoreOpt] allow_inline: false %1 loop_i.634 true false true false true
// [CoreOpt] allow_inline: false %2 update_axis.636 true false true false true
// [CoreOpt] allow_inline: false %4 loop_i.633 true false true false true
// [CoreOpt] LVN subst Insn(iref=%31) with Insn(iref=%20)
// [CoreOpt] LVN subst Insn(iref=%32) with Insn(iref=%21)
// [CoreOpt] LVN subst Insn(iref=%34) with Insn(iref=%23)
// [CoreOpt] LVN subst Insn(iref=%35) with Insn(iref=%24)
// [CoreOpt] LVN subst Insn(iref=%37) with Insn(iref=%26)
// [CoreOpt] LVN subst Insn(iref=%38) with Insn(iref=%27)
// [CoreOpt] LVN subst Insn(iref=%30) with Insn(iref=%26)
// [CoreOpt] LVN subst Insn(iref=%34) with Insn(iref=%26)
// [CoreOpt2] LVN subst Insn(iref=%20) with Insn(iref=%21)
// [CoreOpt2] LVN subst Insn(iref=%46) with Insn(iref=%49)
