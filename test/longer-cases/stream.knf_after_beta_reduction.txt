let rec main.87: Var({val: Some(Unit)}) = () {
  let _88: Int = Int(0)
  let _89: Int = Int(100)
  let _6412: Int = Int(1)
  let state.6413: Array(Int) = ExtApply(minimbt_create_array, [_6412, _88, ])
  let rec aux.6414: Tuple([Int, Int]) = (u.6415: Var({val: Some(Unit)})) {
    let _6416: Int = Int(0)
    let val.6417: Int = Get state.6413[_6416]
    if (val.6417 == _89) then {
      let _6418: Int = Int(0)
      let _6419: Int = Int(0)
      Tuple([_6418, _6419, ])
    } else {
      let _6420: Int = Int(0)
      let _6421: Int = Int(1)
      let _6422: Int = Add(val.6417, _6421)
      let _6423: Unit = Put state.6413[_6420] = _6422
      let _6424: Int = Int(1)
      Tuple([_6424, val.6417, ])
    }
  }
  let _91: Int = Int(0)
  let _92: Int = Int(1000)
  let _9554: Int = Int(1)
  let state.9555: Array(Int) = ExtApply(minimbt_create_array, [_9554, _91, ])
  let rec aux.9556: Tuple([Int, Int]) = (u.9557: Var({val: Some(Unit)})) {
    let _9558: Int = Int(0)
    let val.9559: Int = Get state.9555[_9558]
    if (val.9559 == _92) then {
      let _9560: Int = Int(0)
      let _9561: Int = Int(0)
      Tuple([_9560, _9561, ])
    } else {
      let _9562: Int = Int(0)
      let _9563: Int = Int(1)
      let _9564: Int = Add(val.9559, _9563)
      let _9565: Unit = Put state.9555[_9562] = _9564
      let _9566: Int = Int(1)
      Tuple([_9566, val.9559, ])
    }
  }
  let rec aux.11127: Tuple([Int, Int]) = (u.11128: Var({val: Some(Unit)})) {
    let _11129: Unit = Unit
    let _11130: Tuple([Int, Int]) = Apply(aux.6414, [_11129, ])
    let (ok.11131: Var({val: Some(Int)}), val.11132: Var({val: Some(Int)})) = _11130
    let _11133: Int = Int(0)
    if (ok.11131 == _11133) then {
      let _11134: Unit = Unit
      Apply(aux.9556, [_11134, ])
    } else {
      let _11135: Int = Int(1)
      Tuple([_11135, val.11132, ])
    }
  }
  let _95: Int = Int(1)
  let rec aux.11915: Int = (y.11916: Int) {
    Add(_95, y.11916)
  }
  let rec aux.12301: Tuple([Int, Int]) = (u.12302: Var({val: Some(Unit)})) {
    let _12303: Unit = Unit
    let _12304: Tuple([Int, Int]) = Apply(aux.11127, [_12303, ])
    let (ok.12305: Var({val: Some(Int)}), val.12306: Var({val: Some(Int)})) = _12304
    let _12307: Int = Int(0)
    if (ok.12305 == _12307) then {
      let _12308: Int = Int(0)
      let _12309: Int = Int(0)
      Tuple([_12308, _12309, ])
    } else {
      let _12310: Int = Int(1)
      let _12311: Int = Apply(aux.11915, [val.12306, ])
      Tuple([_12310, _12311, ])
    }
  }
  let _98: Int = Int(50)
  let rec aux.12503: Int = (y.12504: Int) {
    if (_98 <= y.12504) then {
      Int(0)
    } else {
      Int(1)
    }
  }
  let rec aux.12593: Tuple([Int, Int]) = (u.12594: Var({val: Some(Unit)})) {
    let join aux.12595: Tuple([Int, Int]) = (u.12596: Var({val: Some(Unit)})) {
      let _12597: Unit = Unit
      let _12598: Tuple([Int, Int]) = Apply(aux.12301, [_12597, ])
      let (ok.12599: Var({val: Some(Int)}), val.12600: Var({val: Some(Int)})) = _12598
      let _12601: Int = Int(0)
      if (ok.12599 == _12601) then {
        let _12602: Int = Int(0)
        let _12603: Int = Int(0)
        Tuple([_12602, _12603, ])
      } else {
        let r.12604: Int = Apply(aux.12503, [val.12600, ])
        let _12605: Int = Int(0)
        if (r.12604 == _12605) then {
          let _12606: Int = Int(1)
          Tuple([_12606, val.12600, ])
        } else {
          let _12607: Unit = Unit
          Jump(aux.12595, [_12607, ])
        }
      }
    }
    Jump(aux.12595, [u.12594, ])
  }
  let _101: Int = Int(1200)
  let rec aux.12651: Int = (y.12652: Int) {
    if (y.12652 <= _101) then {
      Int(0)
    } else {
      Int(1)
    }
  }
  let rec aux.12667: Tuple([Int, Int]) = (u.12668: Var({val: Some(Unit)})) {
    let join aux.12669: Tuple([Int, Int]) = (u.12670: Var({val: Some(Unit)})) {
      let _12671: Unit = Unit
      let _12672: Tuple([Int, Int]) = Apply(aux.12593, [_12671, ])
      let (ok.12673: Var({val: Some(Int)}), val.12674: Var({val: Some(Int)})) = _12672
      let _12675: Int = Int(0)
      if (ok.12673 == _12675) then {
        let _12676: Int = Int(0)
        let _12677: Int = Int(0)
        Tuple([_12676, _12677, ])
      } else {
        let r.12678: Int = Apply(aux.12651, [val.12674, ])
        let _12679: Int = Int(0)
        if (r.12678 == _12679) then {
          let _12680: Int = Int(1)
          Tuple([_12680, val.12674, ])
        } else {
          let _12681: Unit = Unit
          Jump(aux.12669, [_12681, ])
        }
      }
    }
    Jump(aux.12669, [u.12668, ])
  }
  let rec add.12682: Int = (x.12683: Int, y.12684: Int) {
    Add(x.12683, y.12684)
  }
  let _12685: Int = Int(0)
  let join fold.12686: Int = (stream.12687: Fun([Unit], Tuple([Int, Int])), f.12688: Fun([Int, Int], Int), acc.12689: Int) {
    let _12690: Unit = Unit
    let _12691: Tuple([Int, Int]) = Apply(stream.12687, [_12690, ])
    let (ok.12692: Var({val: Some(Int)}), val.12693: Var({val: Some(Int)})) = _12691
    let _12694: Int = Int(0)
    if (ok.12692 == _12694) then {
      let _105: Unit = ExtApply(minimbt_print_int, [acc.12689, ])
      let _106: Int = Int(10)
      let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
      Unit
    } else {
      let _12695: Int = Apply(f.12688, [acc.12689, val.12693, ])
      Jump(fold.12686, [stream.12687, f.12688, _12695, ])
    }
  }
  Jump(fold.12686, [aux.12667, add.12682, _12685, ])
}
Apply(main.87, [])