let rec fold.63: Int = (stream.64: Fun([Unit], Tuple([Int, Int])), f.65: Fun([Int, Int], Int), acc.66: Int) {
  let _67: Unit = Unit
  let _68: Tuple([Int, Int]) = Apply(stream.64, [_67, ])
  let (ok.69: Var({val: Some(Int)}), val.70: Var({val: Some(Int)})) = _68
  let _71: Int = Int(0)
  if (ok.69 == _71) then {
    Var(acc.66)
  } else {
    let _72: Int = Apply(f.65, [acc.66, val.70, ])
    let _108: Unit = Unit
    let _109: Tuple([Int, Int]) = Apply(stream.64, [_108, ])
    let (ok.110: Var({val: Some(Int)}), val.111: Var({val: Some(Int)})) = _109
    let _112: Int = Int(0)
    if (ok.110 == _112) then {
      Var(_72)
    } else {
      let _113: Int = Apply(f.65, [_72, val.111, ])
      Apply(fold.63, [stream.64, f.65, _113, ])
    }
  }
}
let rec main.87: Var({val: Some(Unit)}) = () {
  let _88: Int = Int(0)
  let _89: Int = Int(100)
  let _3511: Int = Int(1)
  let state.3512: Array(Int) = ExtApply(minimbt_create_array, [_3511, _88, ])
  let rec aux.3513: Tuple([Int, Int]) = (u.3514: Var({val: Some(Unit)})) {
    let _3515: Int = Int(0)
    let val.3516: Int = Get state.3512[_3515]
    if (val.3516 == _89) then {
      let _3517: Int = Int(0)
      let _3518: Int = Int(0)
      Tuple([_3517, _3518, ])
    } else {
      let _3519: Int = Int(0)
      let _3520: Int = Int(1)
      let _3521: Int = Add(val.3516, _3520)
      let _3522: Unit = Put state.3512[_3519] = _3521
      let _3523: Int = Int(1)
      Tuple([_3523, val.3516, ])
    }
  }
  let _91: Int = Int(0)
  let _92: Int = Int(1000)
  let _5213: Int = Int(1)
  let state.5214: Array(Int) = ExtApply(minimbt_create_array, [_5213, _91, ])
  let rec aux.5215: Tuple([Int, Int]) = (u.5216: Var({val: Some(Unit)})) {
    let _5217: Int = Int(0)
    let val.5218: Int = Get state.5214[_5217]
    if (val.5218 == _92) then {
      let _5219: Int = Int(0)
      let _5220: Int = Int(0)
      Tuple([_5219, _5220, ])
    } else {
      let _5221: Int = Int(0)
      let _5222: Int = Int(1)
      let _5223: Int = Add(val.5218, _5222)
      let _5224: Unit = Put state.5214[_5221] = _5223
      let _5225: Int = Int(1)
      Tuple([_5225, val.5218, ])
    }
  }
  let rec aux.6066: Tuple([Int, Int]) = (u.6067: Var({val: Some(Unit)})) {
    let _6068: Unit = Unit
    let _6069: Tuple([Int, Int]) = Apply(aux.3513, [_6068, ])
    let (ok.6070: Var({val: Some(Int)}), val.6071: Var({val: Some(Int)})) = _6069
    let _6072: Int = Int(0)
    if (ok.6070 == _6072) then {
      let _6073: Unit = Unit
      Apply(aux.5215, [_6073, ])
    } else {
      let _6074: Int = Int(1)
      Tuple([_6074, val.6071, ])
    }
  }
  let _95: Int = Int(1)
  let rec aux.6494: Int = (y.6495: Int) {
    Add(_95, y.6495)
  }
  let rec aux.6700: Tuple([Int, Int]) = (u.6701: Var({val: Some(Unit)})) {
    let _6702: Unit = Unit
    let _6703: Tuple([Int, Int]) = Apply(aux.6066, [_6702, ])
    let (ok.6704: Var({val: Some(Int)}), val.6705: Var({val: Some(Int)})) = _6703
    let _6706: Int = Int(0)
    if (ok.6704 == _6706) then {
      let _6707: Int = Int(0)
      let _6708: Int = Int(0)
      Tuple([_6707, _6708, ])
    } else {
      let _6709: Int = Int(1)
      let _6710: Int = Apply(aux.6494, [val.6705, ])
      Tuple([_6709, _6710, ])
    }
  }
  let _98: Int = Int(50)
  let rec aux.6812: Int = (y.6813: Int) {
    if (_98 <= y.6813) then {
      Int(0)
    } else {
      Int(1)
    }
  }
  let rec aux.6858: Tuple([Int, Int]) = (u.6859: Var({val: Some(Unit)})) {
    let _6860: Unit = Unit
    let _6861: Tuple([Int, Int]) = Apply(aux.6700, [_6860, ])
    let (ok.6862: Var({val: Some(Int)}), val.6863: Var({val: Some(Int)})) = _6861
    let _6864: Int = Int(0)
    if (ok.6862 == _6864) then {
      let _6865: Int = Int(0)
      let _6866: Int = Int(0)
      Tuple([_6865, _6866, ])
    } else {
      let r.6867: Int = Apply(aux.6812, [val.6863, ])
      let _6868: Int = Int(0)
      if (r.6867 == _6868) then {
        let _6869: Int = Int(1)
        Tuple([_6869, val.6863, ])
      } else {
        let _6870: Unit = Unit
        Apply(aux.6858, [_6870, ])
      }
    }
  }
  let _101: Int = Int(1200)
  let rec aux.6892: Int = (y.6893: Int) {
    if (y.6893 <= _101) then {
      Int(0)
    } else {
      Int(1)
    }
  }
  let rec aux.6898: Tuple([Int, Int]) = (u.6899: Var({val: Some(Unit)})) {
    let _6900: Unit = Unit
    let _6901: Tuple([Int, Int]) = Apply(aux.6858, [_6900, ])
    let (ok.6902: Var({val: Some(Int)}), val.6903: Var({val: Some(Int)})) = _6901
    let _6904: Int = Int(0)
    if (ok.6902 == _6904) then {
      let _6905: Int = Int(0)
      let _6906: Int = Int(0)
      Tuple([_6905, _6906, ])
    } else {
      let r.6907: Int = Apply(aux.6892, [val.6903, ])
      let _6908: Int = Int(0)
      if (r.6907 == _6908) then {
        let _6909: Int = Int(1)
        Tuple([_6909, val.6903, ])
      } else {
        let _6910: Unit = Unit
        Apply(aux.6898, [_6910, ])
      }
    }
  }
  let rec add.6911: Int = (x.6912: Int, y.6913: Int) {
    Add(x.6912, y.6913)
  }
  let _6914: Int = Int(0)
  let sum.104: Int = Apply(fold.63, [aux.6898, add.6911, _6914, ])
  let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
  let _106: Int = Int(10)
  let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
  Unit
}
Apply(main.87, [])