let rec swap.1: Unit = (arr.2: Array(Int), i.3: Int, j.4: Int) {
  let tmp.5: Int = Get arr.2[i.3]
  let _6: Int = Get arr.2[j.4]
  let _7: Unit = Put arr.2[i.3] = _6
  let _8: Unit = Put arr.2[j.4] = tmp.5
  Unit
}
let rec output.9: Unit = (arr.10: Array(Int), i.11: Int, len.12: Int) {
  let _13: Int = Int(1)
  let _14: Int = Sub(len.12, _13)
  if (i.11 <= _14) then {
    let _15: Int = Get arr.10[i.11]
    let _16: Unit = ExtApply(minimbt_print_int, [_15, ])
    let _17: Unit = ExtApply(minimbt_print_endline, [])
    let _18: Int = Int(1)
    let _19: Int = Add(i.11, _18)
    Apply(output.9, [arr.10, _19, len.12, ])
  } else {
    Unit
  }
}
let rec quick_sort.166: Unit = (arr.167: Array(Int), low.168: Int, high.169: Int) {
  let len.170: Int = Sub(high.169, low.168)
  let _171: Int = Int(16)
  if (len.170 <= _171) then {
    let rec g.201: Unit = (j.202: Int) {
      let _203: Int = Int(1)
      let _204: Int = Add(_203, low.168)
      if (_204 <= j.202) then {
        let _205: Int = Get arr.167[j.202]
        let _206: Int = Int(1)
        let _207: Int = Sub(j.202, _206)
        let _208: Int = Get arr.167[_207]
        let _209: Int = Int(1)
        let _210: Int = Sub(_208, _209)
        if (_205 <= _210) then {
          let _211: Int = Int(1)
          let _212: Int = Sub(j.202, _211)
          let _213: Unit = Apply(swap.1, [arr.167, j.202, _212, ])
          let _214: Int = Int(1)
          let _215: Int = Sub(j.202, _214)
          Apply(g.201, [_215, ])
        } else {
          Unit
        }
      } else {
        Unit
      }
    }
    let rec f.216: Unit = (i.217: Int) {
      let _218: Int = Int(1)
      let _219: Int = Sub(high.169, _218)
      if (i.217 <= _219) then {
        let _220: Unit = Apply(g.201, [i.217, ])
        let _221: Int = Int(1)
        let _222: Int = Add(i.217, _221)
        Apply(f.216, [_222, ])
      } else {
        Unit
      }
    }
    let _223: Int = Int(1)
    let _224: Int = Add(low.168, _223)
    Apply(f.216, [_224, ])
  } else {
    let _172: Tuple([Int, Bool]) = 
      let use_median_of_medians.225: Int = Int(50)
      let _226: Int = Int(1)
      let _227: Int = Int(0)
      let swaps.228: Array(Int) = ExtApply(minimbt_create_array, [_226, _227, ])
      let len.229: Int = Sub(high.169, low.168)
      let _230: Int = Int(4)
      let _231: Int = Div(len.229, _230)
      let _232: Int = Int(2)
      let _233: Int = Mul(_231, _232)
      let b.234: Int = Add(low.168, _233)
      let _235: Int = Int(8)
      let _236: Var({val: Some(Unit)}) = if (_235 <= len.229) then {
        let _237: Int = Int(4)
        let _238: Int = Div(len.229, _237)
        let _239: Int = Int(1)
        let _240: Int = Mul(_238, _239)
        let a.241: Int = Add(low.168, _240)
        let _242: Int = Int(4)
        let _243: Int = Div(len.229, _242)
        let _244: Int = Int(3)
        let _245: Int = Mul(_243, _244)
        let c.246: Int = Add(low.168, _245)
        let rec sort_2.247: Var({val: Some(Unit)}) = (a.248: Int, b.249: Int) {
          let _250: Int = Get arr.167[b.249]
          let _251: Int = Get arr.167[a.248]
          let _252: Int = Int(1)
          let _253: Int = Sub(_251, _252)
          if (_250 <= _253) then {
            let _254: Unit = Apply(swap.1, [arr.167, a.248, b.249, ])
            let _255: Int = Int(0)
            let _256: Int = Int(0)
            let _257: Int = Get swaps.228[_256]
            let _258: Int = Int(1)
            let _259: Int = Add(_257, _258)
            Put swaps.228[_255] = _259
          } else {
            Unit
          }
        }
        let rec sort_3.260: Var({val: Some(Unit)}) = (a.261: Int, b.262: Int, c.263: Int) {
          let _264: Var({val: Some(Unit)}) = Apply(sort_2.247, [a.261, b.262, ])
          let _265: Var({val: Some(Unit)}) = Apply(sort_2.247, [b.262, c.263, ])
          Apply(sort_2.247, [a.261, b.262, ])
        }
        let _266: Int = Int(1)
        let _267: Int = Sub(len.229, _266)
        let _268: Var({val: Some(Unit)}) = if (use_median_of_medians.225 <= _267) then {
          let _269: Int = Int(1)
          let _270: Int = Sub(a.241, _269)
          let _271: Int = Int(1)
          let _272: Int = Add(a.241, _271)
          let _273: Var({val: Some(Unit)}) = Apply(sort_3.260, [_270, a.241, _272, ])
          let _274: Int = Int(1)
          let _275: Int = Sub(b.234, _274)
          let _276: Int = Int(1)
          let _277: Int = Add(b.234, _276)
          let _278: Var({val: Some(Unit)}) = Apply(sort_3.260, [_275, b.234, _277, ])
          let _279: Int = Int(1)
          let _280: Int = Sub(c.246, _279)
          let _281: Int = Int(1)
          let _282: Int = Add(c.246, _281)
          Apply(sort_3.260, [_280, c.246, _282, ])
        } else {
          Unit
        }
        Apply(sort_3.260, [a.241, b.234, c.246, ])
      } else {
        Unit
      }
      let _283: Int = Int(0)
      let _284: Int = Get swaps.228[_283]
      let _285: Int = Int(0)
      let _286: Int = if (_284 == _285) then {
        Bool(true)
      } else {
        Bool(false)
      }
      Tuple([b.234, _286, ])
    let (pivot_index.173: Var({val: Some(Int)}), likely_sorted.174: Var({val: Some(Bool)})) = _172
    let _175: Tuple([Int, Bool]) = 
      let _287: Int = Int(1)
      let _288: Int = Sub(high.169, _287)
      let _289: Unit = Apply(swap.1, [arr.167, pivot_index.173, _288, ])
      let _290: Int = Int(1)
      let _291: Int = Sub(high.169, _290)
      let pivot.292: Int = Get arr.167[_291]
      let _293: Int = Int(1)
      let i.294: Array(Int) = ExtApply(minimbt_create_array, [_293, low.168, ])
      let _295: Int = Int(1)
      let _296: Int = Int(1)
      let partitioned.297: Array(Int) = ExtApply(minimbt_create_array, [_295, _296, ])
      let rec aux.298: Var({val: Some(Unit)}) = (j.299: Int) {
        let _300: Int = Int(2)
        let _301: Int = Sub(high.169, _300)
        if (j.299 <= _301) then {
          let _302: Int = Get arr.167[j.299]
          let _303: Int = Int(1)
          let _304: Int = Sub(pivot.292, _303)
          let _305: Unit = if (_302 <= _304) then {
            let _306: Int = Int(0)
            let _307: Int = Get i.294[_306]
            let _308: Unit = if (_307 == j.299) then {
              Unit
            } else {
              let _309: Int = Int(0)
              let _310: Int = Get i.294[_309]
              let _311: Unit = Apply(swap.1, [arr.167, _310, j.299, ])
              let _312: Int = Int(0)
              let _313: Int = Int(0)
              Put partitioned.297[_312] = _313
            }
            let _314: Int = Int(0)
            let _315: Int = Int(0)
            let _316: Int = Get i.294[_315]
            let _317: Int = Int(1)
            let _318: Int = Add(_316, _317)
            let _319: Unit = Put i.294[_314] = _318
            Unit
          } else {
            Unit
          }
          let _320: Int = Int(1)
          let _321: Int = Add(j.299, _320)
          Apply(aux.298, [_321, ])
        } else {
          Unit
        }
      }
      let _322: Var({val: Some(Unit)}) = Apply(aux.298, [low.168, ])
      let _323: Int = Int(0)
      let _324: Int = Get i.294[_323]
      let _325: Int = Int(1)
      let _326: Int = Sub(high.169, _325)
      let _327: Unit = Apply(swap.1, [arr.167, _324, _326, ])
      let _328: Int = Int(0)
      let _329: Int = Get i.294[_328]
      let _330: Int = Int(0)
      let _331: Int = Get partitioned.297[_330]
      let _332: Int = Int(1)
      let _333: Int = if (_331 == _332) then {
        Bool(true)
      } else {
        Bool(false)
      }
      Tuple([_329, _333, ])
    let (pivot.176: Var({val: Some(Int)}), partitioned.177: Var({val: Some(Bool)})) = _175
    let _178: Unit = Apply(quick_sort.166, [arr.167, low.168, pivot.176, ])
    let _179: Int = Int(1)
    let _180: Int = Add(pivot.176, _179)
    Apply(quick_sort.166, [arr.167, _180, high.169, ])
  }
}
let rec main.185: Var({val: Some(Unit)}) = () {
  let len.186: Int = ExtApply(minimbt_read_int, [])
  let _187: Int = Int(0)
  let arr.188: Array(Int) = ExtApply(minimbt_create_array, [len.186, _187, ])
  let rec input.189: Var({val: Some(Unit)}) = (i.190: Int) {
    let _191: Int = Int(1)
    let _192: Int = Sub(len.186, _191)
    if (i.190 <= _192) then {
      let _193: Int = ExtApply(minimbt_read_int, [])
      let _194: Unit = Put arr.188[i.190] = _193
      let _195: Int = Int(1)
      let _196: Int = Add(i.190, _195)
      Apply(input.189, [_196, ])
    } else {
      Unit
    }
  }
  let _197: Int = Int(0)
  let _198: Var({val: Some(Unit)}) = Apply(input.189, [_197, ])
  let _199: Unit = 
    let _334: Int = Int(0)
    Apply(quick_sort.166, [arr.188, _334, len.186, ])
  let _200: Int = Int(0)
  Apply(output.9, [arr.188, _200, len.186, ])
}
Apply(main.185, [])