// [Knf] build_knf: LetRec({tyvars: [], name: ("swap", Unit), args: [("arr", Array(Int)), ("i", Int), ("j", Int)], body: Let(("tmp", Int), Get(Var("arr"), Var("i")), Let(("_", Unit), Put(Var("arr"), Var("i"), Get(Var("arr"), Var("j"))), Let(("_", Unit), Put(Var("arr"), Var("j"), Var("tmp")), Unit)))}, LetRec({tyvars: [], name: ("output", Unit), args: [("arr", Array(Int)), ("i", Int), ("len", Int)], body: If(LE(Var("i"), Prim(Var("len"), Int(1), Sub, kind=Some(Int))), Let(("_", Unit), App(Var("print_int"), [Get(Var("arr"), Var("i"))]), Let(("_", Unit), App(Var("print_endline"), []), App(Var("output"), [Var("arr"), Prim(Var("i"), Int(1), Add, kind=Some(Int)), Var("len")]))), Unit)}, LetRec({tyvars: [], name: ("insertion_sort", Unit), args: [("arr", Array(Int)), ("low", Int), ("high", Int)], body: LetRec({tyvars: [], name: ("g", Unit), args: [("j", Int)], body: If(LE(Prim(Int(1), Var("low"), Add, kind=Some(Int)), Var("j")), If(LE(Get(Var("arr"), Var("j")), Prim(Get(Var("arr"), Prim(Var("j"), Int(1), Sub, kind=Some(Int))), Int(1), Sub, kind=Some(Int))), Let(("_", Unit), App(Var("swap"), [Var("arr"), Var("j"), Prim(Var("j"), Int(1), Sub, kind=Some(Int))]), App(Var("g"), [Prim(Var("j"), Int(1), Sub, kind=Some(Int))])), Unit), Unit)}, LetRec({tyvars: [], name: ("f", Unit), args: [("i", Int)], body: If(LE(Var("i"), Prim(Var("high"), Int(1), Sub, kind=Some(Int))), Let(("j", Int), Var("i"), Let(("_", Unit), App(Var("g"), [Var("j")]), App(Var("f"), [Prim(Var("i"), Int(1), Add, kind=Some(Int))]))), Unit)}, App(Var("f"), [Prim(Var("low"), Int(1), Add, kind=Some(Int))])))}, LetRec({tyvars: [], name: ("partition", Tuple([Int, Bool])), args: [("arr", Array(Int)), ("pivot_index", Int), ("low", Int), ("high", Int)], body: Let(("_", Unit), App(Var("swap"), [Var("arr"), Var("pivot_index"), Prim(Var("high"), Int(1), Sub, kind=Some(Int))]), Let(("pivot", Int), Get(Var("arr"), Prim(Var("high"), Int(1), Sub, kind=Some(Int))), Let(("i", Array(Int)), Array(Int(1), Var("low")), Let(("partitioned", Array(Int)), Array(Int(1), Int(1)), LetRec({tyvars: [], name: ("aux", Unit), args: [("j", Int)], body: If(LE(Var("j"), Prim(Var("high"), Int(2), Sub, kind=Some(Int))), Let(("_", Unit), If(LE(Get(Var("arr"), Var("j")), Prim(Var("pivot"), Int(1), Sub, kind=Some(Int))), Let(("_", Unit), If(Eq(Get(Var("i"), Int(0)), Var("j")), Unit, Let(("_", Unit), App(Var("swap"), [Var("arr"), Get(Var("i"), Int(0)), Var("j")]), Put(Var("partitioned"), Int(0), Int(0)))), Let(("_", Unit), Put(Var("i"), Int(0), Prim(Get(Var("i"), Int(0)), Int(1), Add, kind=Some(Int))), Unit)), Unit), App(Var("aux"), [Prim(Var("j"), Int(1), Add, kind=Some(Int))])), Unit)}, Let(("_", Unit), App(Var("aux"), [Var("low")]), Let(("_", Unit), App(Var("swap"), [Var("arr"), Get(Var("i"), Int(0)), Prim(Var("high"), Int(1), Sub, kind=Some(Int))]), Tuple([Get(Var("i"), Int(0)), Eq(Get(Var("partitioned"), Int(0)), Int(1))]))))))))}, LetRec({tyvars: [], name: ("choose_pivot", Tuple([Int, Bool])), args: [("arr", Array(Int)), ("low", Int), ("high", Int)], body: Let(("use_median_of_medians", Int), Int(50), Let(("swaps", Array(Int)), Array(Int(1), Int(0)), Let(("len", Int), Prim(Var("high"), Var("low"), Sub, kind=Some(Int)), Let(("b", Int), Prim(Var("low"), Prim(Prim(Var("len"), Int(4), Div, kind=Some(Int)), Int(2), Mul, kind=Some(Int)), Add, kind=Some(Int)), Let(("_", Unit), If(LE(Int(8), Var("len")), Let(("a", Int), Prim(Var("low"), Prim(Prim(Var("len"), Int(4), Div, kind=Some(Int)), Int(1), Mul, kind=Some(Int)), Add, kind=Some(Int)), Let(("c", Int), Prim(Var("low"), Prim(Prim(Var("len"), Int(4), Div, kind=Some(Int)), Int(3), Mul, kind=Some(Int)), Add, kind=Some(Int)), LetRec({tyvars: [], name: ("sort_2", Unit), args: [("a", Int), ("b", Int)], body: If(LE(Get(Var("arr"), Var("b")), Prim(Get(Var("arr"), Var("a")), Int(1), Sub, kind=Some(Int))), Let(("_", Unit), App(Var("swap"), [Var("arr"), Var("a"), Var("b")]), Put(Var("swaps"), Int(0), Prim(Get(Var("swaps"), Int(0)), Int(1), Add, kind=Some(Int)))), Unit)}, LetRec({tyvars: [], name: ("sort_3", Unit), args: [("a", Int), ("b", Int), ("c", Int)], body: Let(("_", Unit), App(Var("sort_2"), [Var("a"), Var("b")]), Let(("_", Unit), App(Var("sort_2"), [Var("b"), Var("c")]), App(Var("sort_2"), [Var("a"), Var("b")])))}, Let(("_", Unit), If(LE(Var("use_median_of_medians"), Prim(Var("len"), Int(1), Sub, kind=Some(Int))), Let(("_", Unit), App(Var("sort_3"), [Prim(Var("a"), Int(1), Sub, kind=Some(Int)), Var("a"), Prim(Var("a"), Int(1), Add, kind=Some(Int))]), Let(("_", Unit), App(Var("sort_3"), [Prim(Var("b"), Int(1), Sub, kind=Some(Int)), Var("b"), Prim(Var("b"), Int(1), Add, kind=Some(Int))]), App(Var("sort_3"), [Prim(Var("c"), Int(1), Sub, kind=Some(Int)), Var("c"), Prim(Var("c"), Int(1), Add, kind=Some(Int))]))), Unit), App(Var("sort_3"), [Var("a"), Var("b"), Var("c")])))))), Unit), Tuple([Var("b"), Eq(Get(Var("swaps"), Int(0)), Int(0))]))))))}, LetRec({tyvars: [], name: ("quick_sort", Unit), args: [("arr", Array(Int)), ("low", Int), ("high", Int)], body: Let(("len", Int), Prim(Var("high"), Var("low"), Sub, kind=Some(Int)), If(LE(Var("len"), Int(16)), App(Var("insertion_sort"), [Var("arr"), Var("low"), Var("high")]), LetTuple([("pivot_index", Int), ("likely_sorted", Bool)], App(Var("choose_pivot"), [Var("arr"), Var("low"), Var("high")]), LetTuple([("pivot", Int), ("partitioned", Bool)], App(Var("partition"), [Var("arr"), Var("pivot_index"), Var("low"), Var("high")]), Let(("_", Unit), App(Var("quick_sort"), [Var("arr"), Var("low"), Var("pivot")]), App(Var("quick_sort"), [Var("arr"), Prim(Var("pivot"), Int(1), Add, kind=Some(Int)), Var("high")]))))))}, LetRec({tyvars: [], name: ("sort", Unit), args: [("x", Array(Int)), ("len", Int)], body: App(Var("quick_sort"), [Var("x"), Int(0), Var("len")])}, LetRec({tyvars: [], name: ("main", Unit), args: [], body: Let(("len", Int), App(Var("read_int"), []), Let(("arr", Array(Int)), Array(Var("len"), Int(0)), LetRec({tyvars: [], name: ("input", Unit), args: [("i", Int)], body: If(LE(Var("i"), Prim(Var("len"), Int(1), Sub, kind=Some(Int))), Let(("_", Unit), Put(Var("arr"), Var("i"), App(Var("read_int"), [])), App(Var("input"), [Prim(Var("i"), Int(1), Add, kind=Some(Int))])), Unit)}, Let(("_", Unit), App(Var("input"), [Int(0)]), Let(("_", Unit), App(Var("sort"), [Var("arr"), Var("len")]), App(Var("output"), [Var("arr"), Int(0), Var("len")]))))))}, App(Var("main"), [])))))))))
// [Knf] build_knf: Let(("tmp", Int), Get(Var("arr"), Var("i")), Let(("_", Unit), Put(Var("arr"), Var("i"), Get(Var("arr"), Var("j"))), Let(("_", Unit), Put(Var("arr"), Var("j"), Var("tmp")), Unit)))
// [Knf] build_knf: Get(Var("arr"), Var("i"))
// [Knf] build_knf: Var("arr")
// [Knf] build_knf: Var("i")
// [Knf] build_knf: Let(("_", Unit), Put(Var("arr"), Var("i"), Get(Var("arr"), Var("j"))), Let(("_", Unit), Put(Var("arr"), Var("j"), Var("tmp")), Unit))
// [Knf] build_knf: Put(Var("arr"), Var("i"), Get(Var("arr"), Var("j")))
// [Knf] build_knf: Var("arr")
// [Knf] build_knf: Var("i")
// [Knf] build_knf: Get(Var("arr"), Var("j"))
// [Knf] build_knf: Var("arr")
// [Knf] build_knf: Var("j")
// [Knf] build_knf: Let(("_", Unit), Put(Var("arr"), Var("j"), Var("tmp")), Unit)
// [Knf] build_knf: Put(Var("arr"), Var("j"), Var("tmp"))
// [Knf] build_knf: Var("arr")
// [Knf] build_knf: Var("j")
// [Knf] build_knf: Var("tmp")
// [Knf] build_knf: Unit
// [Knf] build_knf: LetRec({tyvars: [], name: ("output", Unit), args: [("arr", Array(Int)), ("i", Int), ("len", Int)], body: If(LE(Var("i"), Prim(Var("len"), Int(1), Sub, kind=Some(Int))), Let(("_", Unit), App(Var("print_int"), [Get(Var("arr"), Var("i"))]), Let(("_", Unit), App(Var("print_endline"), []), App(Var("output"), [Var("arr"), Prim(Var("i"), Int(1), Add, kind=Some(Int)), Var("len")]))), Unit)}, LetRec({tyvars: [], name: ("insertion_sort", Unit), args: [("arr", Array(Int)), ("low", Int), ("high", Int)], body: LetRec({tyvars: [], name: ("g", Unit), args: [("j", Int)], body: If(LE(Prim(Int(1), Var("low"), Add, kind=Some(Int)), Var("j")), If(LE(Get(Var("arr"), Var("j")), Prim(Get(Var("arr"), Prim(Var("j"), Int(1), Sub, kind=Some(Int))), Int(1), Sub, kind=Some(Int))), Let(("_", Unit), App(Var("swap"), [Var("arr"), Var("j"), Prim(Var("j"), Int(1), Sub, kind=Some(Int))]), App(Var("g"), [Prim(Var("j"), Int(1), Sub, kind=Some(Int))])), Unit), Unit)}, LetRec({tyvars: [], name: ("f", Unit), args: [("i", Int)], body: If(LE(Var("i"), Prim(Var("high"), Int(1), Sub, kind=Some(Int))), Let(("j", Int), Var("i"), Let(("_", Unit), App(Var("g"), [Var("j")]), App(Var("f"), [Prim(Var("i"), Int(1), Add, kind=Some(Int))]))), Unit)}, App(Var("f"), [Prim(Var("low"), Int(1), Add, kind=Some(Int))])))}, LetRec({tyvars: [], name: ("partition", Tuple([Int, Bool])), args: [("arr", Array(Int)), ("pivot_index", Int), ("low", Int), ("high", Int)], body: Let(("_", Unit), App(Var("swap"), [Var("arr"), Var("pivot_index"), Prim(Var("high"), Int(1), Sub, kind=Some(Int))]), Let(("pivot", Int), Get(Var("arr"), Prim(Var("high"), Int(1), Sub, kind=Some(Int))), Let(("i", Array(Int)), Array(Int(1), Var("low")), Let(("partitioned", Array(Int)), Array(Int(1), Int(1)), LetRec({tyvars: [], name: ("aux", Unit), args: [("j", Int)], body: If(LE(Var("j"), Prim(Var("high"), Int(2), Sub, kind=Some(Int))), Let(("_", Unit), If(LE(Get(Var("arr"), Var("j")), Prim(Var("pivot"), Int(1), Sub, kind=Some(Int))), Let(("_", Unit), If(Eq(Get(Var("i"), Int(0)), Var("j")), Unit, Let(("_", Unit), App(Var("swap"), [Var("arr"), Get(Var("i"), Int(0)), Var("j")]), Put(Var("partitioned"), Int(0), Int(0)))), Let(("_", Unit), Put(Var("i"), Int(0), Prim(Get(Var("i"), Int(0)), Int(1), Add, kind=Some(Int))), Unit)), Unit), App(Var("aux"), [Prim(Var("j"), Int(1), Add, kind=Some(Int))])), Unit)}, Let(("_", Unit), App(Var("aux"), [Var("low")]), Let(("_", Unit), App(Var("swap"), [Var("arr"), Get(Var("i"), Int(0)), Prim(Var("high"), Int(1), Sub, kind=Some(Int))]), Tuple([Get(Var("i"), Int(0)), Eq(Get(Var("partitioned"), Int(0)), Int(1))]))))))))}, LetRec({tyvars: [], name: ("choose_pivot", Tuple([Int, Bool])), args: [("arr", Array(Int)), ("low", Int), ("high", Int)], body: Let(("use_median_of_medians", Int), Int(50), Let(("swaps", Array(Int)), Array(Int(1), Int(0)), Let(("len", Int), Prim(Var("high"), Var("low"), Sub, kind=Some(Int)), Let(("b", Int), Prim(Var("low"), Prim(Prim(Var("len"), Int(4), Div, kind=Some(Int)), Int(2), Mul, kind=Some(Int)), Add, kind=Some(Int)), Let(("_", Unit), If(LE(Int(8), Var("len")), Let(("a", Int), Prim(Var("low"), Prim(Prim(Var("len"), Int(4), Div, kind=Some(Int)), Int(1), Mul, kind=Some(Int)), Add, kind=Some(Int)), Let(("c", Int), Prim(Var("low"), Prim(Prim(Var("len"), Int(4), Div, kind=Some(Int)), Int(3), Mul, kind=Some(Int)), Add, kind=Some(Int)), LetRec({tyvars: [], name: ("sort_2", Unit), args: [("a", Int), ("b", Int)], body: If(LE(Get(Var("arr"), Var("b")), Prim(Get(Var("arr"), Var("a")), Int(1), Sub, kind=Some(Int))), Let(("_", Unit), App(Var("swap"), [Var("arr"), Var("a"), Var("b")]), Put(Var("swaps"), Int(0), Prim(Get(Var("swaps"), Int(0)), Int(1), Add, kind=Some(Int)))), Unit)}, LetRec({tyvars: [], name: ("sort_3", Unit), args: [("a", Int), ("b", Int), ("c", Int)], body: Let(("_", Unit), App(Var("sort_2"), [Var("a"), Var("b")]), Let(("_", Unit), App(Var("sort_2"), [Var("b"), Var("c")]), App(Var("sort_2"), [Var("a"), Var("b")])))}, Let(("_", Unit), If(LE(Var("use_median_of_medians"), Prim(Var("len"), Int(1), Sub, kind=Some(Int))), Let(("_", Unit), App(Var("sort_3"), [Prim(Var("a"), Int(1), Sub, kind=Some(Int)), Var("a"), Prim(Var("a"), Int(1), Add, kind=Some(Int))]), Let(("_", Unit), App(Var("sort_3"), [Prim(Var("b"), Int(1), Sub, kind=Some(Int)), Var("b"), Prim(Var("b"), Int(1), Add, kind=Some(Int))]), App(Var("sort_3"), [Prim(Var("c"), Int(1), Sub, kind=Some(Int)), Var("c"), Prim(Var("c"), Int(1), Add, kind=Some(Int))]))), Unit), App(Var("sort_3"), [Var("a"), Var("b"), Var("c")])))))), Unit), Tuple([Var("b"), Eq(Get(Var("swaps"), Int(0)), Int(0))]))))))}, LetRec({tyvars: [], name: ("quick_sort", Unit), args: [("arr", Array(Int)), ("low", Int), ("high", Int)], body: Let(("len", Int), Prim(Var("high"), Var("low"), Sub, kind=Some(Int)), If(LE(Var("len"), Int(16)), App(Var("insertion_sort"), [Var("arr"), Var("low"), Var("high")]), LetTuple([("pivot_index", Int), ("likely_sorted", Bool)], App(Var("choose_pivot"), [Var("arr"), Var("low"), Var("high")]), LetTuple([("pivot", Int), ("partitioned", Bool)], App(Var("partition"), [Var("arr"), Var("pivot_index"), Var("low"), Var("high")]), Let(("_", Unit), App(Var("quick_sort"), [Var("arr"), Var("low"), Var("pivot")]), App(Var("quick_sort"), [Var("arr"), Prim(Var("pivot"), Int(1), Add, kind=Some(Int)), Var("high")]))))))}, LetRec({tyvars: [], name: ("sort", Unit), args: [("x", Array(Int)), ("len", Int)], body: App(Var("quick_sort"), [Var("x"), Int(0), Var("len")])}, LetRec({tyvars: [], name: ("main", Unit), args: [], body: Let(("len", Int), App(Var("read_int"), []), Let(("arr", Array(Int)), Array(Var("len"), Int(0)), LetRec({tyvars: [], name: ("input", Unit), args: [("i", Int)], body: If(LE(Var("i"), Prim(Var("len"), Int(1), Sub, kind=Some(Int))), Let(("_", Unit), Put(Var("arr"), Var("i"), App(Var("read_int"), [])), App(Var("input"), [Prim(Var("i"), Int(1), Add, kind=Some(Int))])), Unit)}, Let(("_", Unit), App(Var("input"), [Int(0)]), Let(("_", Unit), App(Var("sort"), [Var("arr"), Var("len")]), App(Var("output"), [Var("arr"), Int(0), Var("len")]))))))}, App(Var("main"), []))))))))
// [Knf] build_knf: If(LE(Var("i"), Prim(Var("len"), Int(1), Sub, kind=Some(Int))), Let(("_", Unit), App(Var("print_int"), [Get(Var("arr"), Var("i"))]), Let(("_", Unit), App(Var("print_endline"), []), App(Var("output"), [Var("arr"), Prim(Var("i"), Int(1), Add, kind=Some(Int)), Var("len")]))), Unit)
// [Knf] build_knf: Var("i")
// [Knf] build_knf: Prim(Var("len"), Int(1), Sub, kind=Some(Int))
// [Knf] build_knf: Var("len")
// [Knf] build_knf: Int(1)
// [Knf] build_knf: Let(("_", Unit), App(Var("print_int"), [Get(Var("arr"), Var("i"))]), Let(("_", Unit), App(Var("print_endline"), []), App(Var("output"), [Var("arr"), Prim(Var("i"), Int(1), Add, kind=Some(Int)), Var("len")])))
// [Knf] build_knf: App(Var("print_int"), [Get(Var("arr"), Var("i"))])
// [Knf] build_knf: Get(Var("arr"), Var("i"))
// [Knf] build_knf: Var("arr")
// [Knf] build_knf: Var("i")
// [Knf] build_knf: Let(("_", Unit), App(Var("print_endline"), []), App(Var("output"), [Var("arr"), Prim(Var("i"), Int(1), Add, kind=Some(Int)), Var("len")]))
// [Knf] build_knf: App(Var("print_endline"), [])
// [Knf] build_knf: App(Var("output"), [Var("arr"), Prim(Var("i"), Int(1), Add, kind=Some(Int)), Var("len")])
// [Knf] build_knf: Var("output")
// [Knf] build_knf: Var("arr")
// [Knf] build_knf: Prim(Var("i"), Int(1), Add, kind=Some(Int))
// [Knf] build_knf: Var("i")
// [Knf] build_knf: Int(1)
// [Knf] build_knf: Var("len")
// [Knf] build_knf: Unit
// [Knf] build_knf: LetRec({tyvars: [], name: ("insertion_sort", Unit), args: [("arr", Array(Int)), ("low", Int), ("high", Int)], body: LetRec({tyvars: [], name: ("g", Unit), args: [("j", Int)], body: If(LE(Prim(Int(1), Var("low"), Add, kind=Some(Int)), Var("j")), If(LE(Get(Var("arr"), Var("j")), Prim(Get(Var("arr"), Prim(Var("j"), Int(1), Sub, kind=Some(Int))), Int(1), Sub, kind=Some(Int))), Let(("_", Unit), App(Var("swap"), [Var("arr"), Var("j"), Prim(Var("j"), Int(1), Sub, kind=Some(Int))]), App(Var("g"), [Prim(Var("j"), Int(1), Sub, kind=Some(Int))])), Unit), Unit)}, LetRec({tyvars: [], name: ("f", Unit), args: [("i", Int)], body: If(LE(Var("i"), Prim(Var("high"), Int(1), Sub, kind=Some(Int))), Let(("j", Int), Var("i"), Let(("_", Unit), App(Var("g"), [Var("j")]), App(Var("f"), [Prim(Var("i"), Int(1), Add, kind=Some(Int))]))), Unit)}, App(Var("f"), [Prim(Var("low"), Int(1), Add, kind=Some(Int))])))}, LetRec({tyvars: [], name: ("partition", Tuple([Int, Bool])), args: [("arr", Array(Int)), ("pivot_index", Int), ("low", Int), ("high", Int)], body: Let(("_", Unit), App(Var("swap"), [Var("arr"), Var("pivot_index"), Prim(Var("high"), Int(1), Sub, kind=Some(Int))]), Let(("pivot", Int), Get(Var("arr"), Prim(Var("high"), Int(1), Sub, kind=Some(Int))), Let(("i", Array(Int)), Array(Int(1), Var("low")), Let(("partitioned", Array(Int)), Array(Int(1), Int(1)), LetRec({tyvars: [], name: ("aux", Unit), args: [("j", Int)], body: If(LE(Var("j"), Prim(Var("high"), Int(2), Sub, kind=Some(Int))), Let(("_", Unit), If(LE(Get(Var("arr"), Var("j")), Prim(Var("pivot"), Int(1), Sub, kind=Some(Int))), Let(("_", Unit), If(Eq(Get(Var("i"), Int(0)), Var("j")), Unit, Let(("_", Unit), App(Var("swap"), [Var("arr"), Get(Var("i"), Int(0)), Var("j")]), Put(Var("partitioned"), Int(0), Int(0)))), Let(("_", Unit), Put(Var("i"), Int(0), Prim(Get(Var("i"), Int(0)), Int(1), Add, kind=Some(Int))), Unit)), Unit), App(Var("aux"), [Prim(Var("j"), Int(1), Add, kind=Some(Int))])), Unit)}, Let(("_", Unit), App(Var("aux"), [Var("low")]), Let(("_", Unit), App(Var("swap"), [Var("arr"), Get(Var("i"), Int(0)), Prim(Var("high"), Int(1), Sub, kind=Some(Int))]), Tuple([Get(Var("i"), Int(0)), Eq(Get(Var("partitioned"), Int(0)), Int(1))]))))))))}, LetRec({tyvars: [], name: ("choose_pivot", Tuple([Int, Bool])), args: [("arr", Array(Int)), ("low", Int), ("high", Int)], body: Let(("use_median_of_medians", Int), Int(50), Let(("swaps", Array(Int)), Array(Int(1), Int(0)), Let(("len", Int), Prim(Var("high"), Var("low"), Sub, kind=Some(Int)), Let(("b", Int), Prim(Var("low"), Prim(Prim(Var("len"), Int(4), Div, kind=Some(Int)), Int(2), Mul, kind=Some(Int)), Add, kind=Some(Int)), Let(("_", Unit), If(LE(Int(8), Var("len")), Let(("a", Int), Prim(Var("low"), Prim(Prim(Var("len"), Int(4), Div, kind=Some(Int)), Int(1), Mul, kind=Some(Int)), Add, kind=Some(Int)), Let(("c", Int), Prim(Var("low"), Prim(Prim(Var("len"), Int(4), Div, kind=Some(Int)), Int(3), Mul, kind=Some(Int)), Add, kind=Some(Int)), LetRec({tyvars: [], name: ("sort_2", Unit), args: [("a", Int), ("b", Int)], body: If(LE(Get(Var("arr"), Var("b")), Prim(Get(Var("arr"), Var("a")), Int(1), Sub, kind=Some(Int))), Let(("_", Unit), App(Var("swap"), [Var("arr"), Var("a"), Var("b")]), Put(Var("swaps"), Int(0), Prim(Get(Var("swaps"), Int(0)), Int(1), Add, kind=Some(Int)))), Unit)}, LetRec({tyvars: [], name: ("sort_3", Unit), args: [("a", Int), ("b", Int), ("c", Int)], body: Let(("_", Unit), App(Var("sort_2"), [Var("a"), Var("b")]), Let(("_", Unit), App(Var("sort_2"), [Var("b"), Var("c")]), App(Var("sort_2"), [Var("a"), Var("b")])))}, Let(("_", Unit), If(LE(Var("use_median_of_medians"), Prim(Var("len"), Int(1), Sub, kind=Some(Int))), Let(("_", Unit), App(Var("sort_3"), [Prim(Var("a"), Int(1), Sub, kind=Some(Int)), Var("a"), Prim(Var("a"), Int(1), Add, kind=Some(Int))]), Let(("_", Unit), App(Var("sort_3"), [Prim(Var("b"), Int(1), Sub, kind=Some(Int)), Var("b"), Prim(Var("b"), Int(1), Add, kind=Some(Int))]), App(Var("sort_3"), [Prim(Var("c"), Int(1), Sub, kind=Some(Int)), Var("c"), Prim(Var("c"), Int(1), Add, kind=Some(Int))]))), Unit), App(Var("sort_3"), [Var("a"), Var("b"), Var("c")])))))), Unit), Tuple([Var("b"), Eq(Get(Var("swaps"), Int(0)), Int(0))]))))))}, LetRec({tyvars: [], name: ("quick_sort", Unit), args: [("arr", Array(Int)), ("low", Int), ("high", Int)], body: Let(("len", Int), Prim(Var("high"), Var("low"), Sub, kind=Some(Int)), If(LE(Var("len"), Int(16)), App(Var("insertion_sort"), [Var("arr"), Var("low"), Var("high")]), LetTuple([("pivot_index", Int), ("likely_sorted", Bool)], App(Var("choose_pivot"), [Var("arr"), Var("low"), Var("high")]), LetTuple([("pivot", Int), ("partitioned", Bool)], App(Var("partition"), [Var("arr"), Var("pivot_index"), Var("low"), Var("high")]), Let(("_", Unit), App(Var("quick_sort"), [Var("arr"), Var("low"), Var("pivot")]), App(Var("quick_sort"), [Var("arr"), Prim(Var("pivot"), Int(1), Add, kind=Some(Int)), Var("high")]))))))}, LetRec({tyvars: [], name: ("sort", Unit), args: [("x", Array(Int)), ("len", Int)], body: App(Var("quick_sort"), [Var("x"), Int(0), Var("len")])}, LetRec({tyvars: [], name: ("main", Unit), args: [], body: Let(("len", Int), App(Var("read_int"), []), Let(("arr", Array(Int)), Array(Var("len"), Int(0)), LetRec({tyvars: [], name: ("input", Unit), args: [("i", Int)], body: If(LE(Var("i"), Prim(Var("len"), Int(1), Sub, kind=Some(Int))), Let(("_", Unit), Put(Var("arr"), Var("i"), App(Var("read_int"), [])), App(Var("input"), [Prim(Var("i"), Int(1), Add, kind=Some(Int))])), Unit)}, Let(("_", Unit), App(Var("input"), [Int(0)]), Let(("_", Unit), App(Var("sort"), [Var("arr"), Var("len")]), App(Var("output"), [Var("arr"), Int(0), Var("len")]))))))}, App(Var("main"), [])))))))
// [Knf] build_knf: LetRec({tyvars: [], name: ("g", Unit), args: [("j", Int)], body: If(LE(Prim(Int(1), Var("low"), Add, kind=Some(Int)), Var("j")), If(LE(Get(Var("arr"), Var("j")), Prim(Get(Var("arr"), Prim(Var("j"), Int(1), Sub, kind=Some(Int))), Int(1), Sub, kind=Some(Int))), Let(("_", Unit), App(Var("swap"), [Var("arr"), Var("j"), Prim(Var("j"), Int(1), Sub, kind=Some(Int))]), App(Var("g"), [Prim(Var("j"), Int(1), Sub, kind=Some(Int))])), Unit), Unit)}, LetRec({tyvars: [], name: ("f", Unit), args: [("i", Int)], body: If(LE(Var("i"), Prim(Var("high"), Int(1), Sub, kind=Some(Int))), Let(("j", Int), Var("i"), Let(("_", Unit), App(Var("g"), [Var("j")]), App(Var("f"), [Prim(Var("i"), Int(1), Add, kind=Some(Int))]))), Unit)}, App(Var("f"), [Prim(Var("low"), Int(1), Add, kind=Some(Int))])))
// [Knf] build_knf: If(LE(Prim(Int(1), Var("low"), Add, kind=Some(Int)), Var("j")), If(LE(Get(Var("arr"), Var("j")), Prim(Get(Var("arr"), Prim(Var("j"), Int(1), Sub, kind=Some(Int))), Int(1), Sub, kind=Some(Int))), Let(("_", Unit), App(Var("swap"), [Var("arr"), Var("j"), Prim(Var("j"), Int(1), Sub, kind=Some(Int))]), App(Var("g"), [Prim(Var("j"), Int(1), Sub, kind=Some(Int))])), Unit), Unit)
// [Knf] build_knf: Prim(Int(1), Var("low"), Add, kind=Some(Int))
// [Knf] build_knf: Int(1)
// [Knf] build_knf: Var("low")
// [Knf] build_knf: Var("j")
// [Knf] build_knf: If(LE(Get(Var("arr"), Var("j")), Prim(Get(Var("arr"), Prim(Var("j"), Int(1), Sub, kind=Some(Int))), Int(1), Sub, kind=Some(Int))), Let(("_", Unit), App(Var("swap"), [Var("arr"), Var("j"), Prim(Var("j"), Int(1), Sub, kind=Some(Int))]), App(Var("g"), [Prim(Var("j"), Int(1), Sub, kind=Some(Int))])), Unit)
// [Knf] build_knf: Get(Var("arr"), Var("j"))
// [Knf] build_knf: Var("arr")
// [Knf] build_knf: Var("j")
// [Knf] build_knf: Prim(Get(Var("arr"), Prim(Var("j"), Int(1), Sub, kind=Some(Int))), Int(1), Sub, kind=Some(Int))
// [Knf] build_knf: Get(Var("arr"), Prim(Var("j"), Int(1), Sub, kind=Some(Int)))
// [Knf] build_knf: Var("arr")
// [Knf] build_knf: Prim(Var("j"), Int(1), Sub, kind=Some(Int))
// [Knf] build_knf: Var("j")
// [Knf] build_knf: Int(1)
// [Knf] build_knf: Int(1)
// [Knf] build_knf: Let(("_", Unit), App(Var("swap"), [Var("arr"), Var("j"), Prim(Var("j"), Int(1), Sub, kind=Some(Int))]), App(Var("g"), [Prim(Var("j"), Int(1), Sub, kind=Some(Int))]))
// [Knf] build_knf: App(Var("swap"), [Var("arr"), Var("j"), Prim(Var("j"), Int(1), Sub, kind=Some(Int))])
// [Knf] build_knf: Var("swap")
// [Knf] build_knf: Var("arr")
// [Knf] build_knf: Var("j")
// [Knf] build_knf: Prim(Var("j"), Int(1), Sub, kind=Some(Int))
// [Knf] build_knf: Var("j")
// [Knf] build_knf: Int(1)
// [Knf] build_knf: App(Var("g"), [Prim(Var("j"), Int(1), Sub, kind=Some(Int))])
// [Knf] build_knf: Var("g")
// [Knf] build_knf: Prim(Var("j"), Int(1), Sub, kind=Some(Int))
// [Knf] build_knf: Var("j")
// [Knf] build_knf: Int(1)
// [Knf] build_knf: Unit
// [Knf] build_knf: Unit
// [Knf] build_knf: LetRec({tyvars: [], name: ("f", Unit), args: [("i", Int)], body: If(LE(Var("i"), Prim(Var("high"), Int(1), Sub, kind=Some(Int))), Let(("j", Int), Var("i"), Let(("_", Unit), App(Var("g"), [Var("j")]), App(Var("f"), [Prim(Var("i"), Int(1), Add, kind=Some(Int))]))), Unit)}, App(Var("f"), [Prim(Var("low"), Int(1), Add, kind=Some(Int))]))
// [Knf] build_knf: If(LE(Var("i"), Prim(Var("high"), Int(1), Sub, kind=Some(Int))), Let(("j", Int), Var("i"), Let(("_", Unit), App(Var("g"), [Var("j")]), App(Var("f"), [Prim(Var("i"), Int(1), Add, kind=Some(Int))]))), Unit)
// [Knf] build_knf: Var("i")
// [Knf] build_knf: Prim(Var("high"), Int(1), Sub, kind=Some(Int))
// [Knf] build_knf: Var("high")
// [Knf] build_knf: Int(1)
// [Knf] build_knf: Let(("j", Int), Var("i"), Let(("_", Unit), App(Var("g"), [Var("j")]), App(Var("f"), [Prim(Var("i"), Int(1), Add, kind=Some(Int))])))
// [Knf] build_knf: Var("i")
// [Knf] build_knf: Let(("_", Unit), App(Var("g"), [Var("j")]), App(Var("f"), [Prim(Var("i"), Int(1), Add, kind=Some(Int))]))
// [Knf] build_knf: App(Var("g"), [Var("j")])
// [Knf] build_knf: Var("g")
// [Knf] build_knf: Var("j")
// [Knf] build_knf: App(Var("f"), [Prim(Var("i"), Int(1), Add, kind=Some(Int))])
// [Knf] build_knf: Var("f")
// [Knf] build_knf: Prim(Var("i"), Int(1), Add, kind=Some(Int))
// [Knf] build_knf: Var("i")
// [Knf] build_knf: Int(1)
// [Knf] build_knf: Unit
// [Knf] build_knf: App(Var("f"), [Prim(Var("low"), Int(1), Add, kind=Some(Int))])
// [Knf] build_knf: Var("f")
// [Knf] build_knf: Prim(Var("low"), Int(1), Add, kind=Some(Int))
// [Knf] build_knf: Var("low")
// [Knf] build_knf: Int(1)
// [Knf] build_knf: LetRec({tyvars: [], name: ("partition", Tuple([Int, Bool])), args: [("arr", Array(Int)), ("pivot_index", Int), ("low", Int), ("high", Int)], body: Let(("_", Unit), App(Var("swap"), [Var("arr"), Var("pivot_index"), Prim(Var("high"), Int(1), Sub, kind=Some(Int))]), Let(("pivot", Int), Get(Var("arr"), Prim(Var("high"), Int(1), Sub, kind=Some(Int))), Let(("i", Array(Int)), Array(Int(1), Var("low")), Let(("partitioned", Array(Int)), Array(Int(1), Int(1)), LetRec({tyvars: [], name: ("aux", Unit), args: [("j", Int)], body: If(LE(Var("j"), Prim(Var("high"), Int(2), Sub, kind=Some(Int))), Let(("_", Unit), If(LE(Get(Var("arr"), Var("j")), Prim(Var("pivot"), Int(1), Sub, kind=Some(Int))), Let(("_", Unit), If(Eq(Get(Var("i"), Int(0)), Var("j")), Unit, Let(("_", Unit), App(Var("swap"), [Var("arr"), Get(Var("i"), Int(0)), Var("j")]), Put(Var("partitioned"), Int(0), Int(0)))), Let(("_", Unit), Put(Var("i"), Int(0), Prim(Get(Var("i"), Int(0)), Int(1), Add, kind=Some(Int))), Unit)), Unit), App(Var("aux"), [Prim(Var("j"), Int(1), Add, kind=Some(Int))])), Unit)}, Let(("_", Unit), App(Var("aux"), [Var("low")]), Let(("_", Unit), App(Var("swap"), [Var("arr"), Get(Var("i"), Int(0)), Prim(Var("high"), Int(1), Sub, kind=Some(Int))]), Tuple([Get(Var("i"), Int(0)), Eq(Get(Var("partitioned"), Int(0)), Int(1))]))))))))}, LetRec({tyvars: [], name: ("choose_pivot", Tuple([Int, Bool])), args: [("arr", Array(Int)), ("low", Int), ("high", Int)], body: Let(("use_median_of_medians", Int), Int(50), Let(("swaps", Array(Int)), Array(Int(1), Int(0)), Let(("len", Int), Prim(Var("high"), Var("low"), Sub, kind=Some(Int)), Let(("b", Int), Prim(Var("low"), Prim(Prim(Var("len"), Int(4), Div, kind=Some(Int)), Int(2), Mul, kind=Some(Int)), Add, kind=Some(Int)), Let(("_", Unit), If(LE(Int(8), Var("len")), Let(("a", Int), Prim(Var("low"), Prim(Prim(Var("len"), Int(4), Div, kind=Some(Int)), Int(1), Mul, kind=Some(Int)), Add, kind=Some(Int)), Let(("c", Int), Prim(Var("low"), Prim(Prim(Var("len"), Int(4), Div, kind=Some(Int)), Int(3), Mul, kind=Some(Int)), Add, kind=Some(Int)), LetRec({tyvars: [], name: ("sort_2", Unit), args: [("a", Int), ("b", Int)], body: If(LE(Get(Var("arr"), Var("b")), Prim(Get(Var("arr"), Var("a")), Int(1), Sub, kind=Some(Int))), Let(("_", Unit), App(Var("swap"), [Var("arr"), Var("a"), Var("b")]), Put(Var("swaps"), Int(0), Prim(Get(Var("swaps"), Int(0)), Int(1), Add, kind=Some(Int)))), Unit)}, LetRec({tyvars: [], name: ("sort_3", Unit), args: [("a", Int), ("b", Int), ("c", Int)], body: Let(("_", Unit), App(Var("sort_2"), [Var("a"), Var("b")]), Let(("_", Unit), App(Var("sort_2"), [Var("b"), Var("c")]), App(Var("sort_2"), [Var("a"), Var("b")])))}, Let(("_", Unit), If(LE(Var("use_median_of_medians"), Prim(Var("len"), Int(1), Sub, kind=Some(Int))), Let(("_", Unit), App(Var("sort_3"), [Prim(Var("a"), Int(1), Sub, kind=Some(Int)), Var("a"), Prim(Var("a"), Int(1), Add, kind=Some(Int))]), Let(("_", Unit), App(Var("sort_3"), [Prim(Var("b"), Int(1), Sub, kind=Some(Int)), Var("b"), Prim(Var("b"), Int(1), Add, kind=Some(Int))]), App(Var("sort_3"), [Prim(Var("c"), Int(1), Sub, kind=Some(Int)), Var("c"), Prim(Var("c"), Int(1), Add, kind=Some(Int))]))), Unit), App(Var("sort_3"), [Var("a"), Var("b"), Var("c")])))))), Unit), Tuple([Var("b"), Eq(Get(Var("swaps"), Int(0)), Int(0))]))))))}, LetRec({tyvars: [], name: ("quick_sort", Unit), args: [("arr", Array(Int)), ("low", Int), ("high", Int)], body: Let(("len", Int), Prim(Var("high"), Var("low"), Sub, kind=Some(Int)), If(LE(Var("len"), Int(16)), App(Var("insertion_sort"), [Var("arr"), Var("low"), Var("high")]), LetTuple([("pivot_index", Int), ("likely_sorted", Bool)], App(Var("choose_pivot"), [Var("arr"), Var("low"), Var("high")]), LetTuple([("pivot", Int), ("partitioned", Bool)], App(Var("partition"), [Var("arr"), Var("pivot_index"), Var("low"), Var("high")]), Let(("_", Unit), App(Var("quick_sort"), [Var("arr"), Var("low"), Var("pivot")]), App(Var("quick_sort"), [Var("arr"), Prim(Var("pivot"), Int(1), Add, kind=Some(Int)), Var("high")]))))))}, LetRec({tyvars: [], name: ("sort", Unit), args: [("x", Array(Int)), ("len", Int)], body: App(Var("quick_sort"), [Var("x"), Int(0), Var("len")])}, LetRec({tyvars: [], name: ("main", Unit), args: [], body: Let(("len", Int), App(Var("read_int"), []), Let(("arr", Array(Int)), Array(Var("len"), Int(0)), LetRec({tyvars: [], name: ("input", Unit), args: [("i", Int)], body: If(LE(Var("i"), Prim(Var("len"), Int(1), Sub, kind=Some(Int))), Let(("_", Unit), Put(Var("arr"), Var("i"), App(Var("read_int"), [])), App(Var("input"), [Prim(Var("i"), Int(1), Add, kind=Some(Int))])), Unit)}, Let(("_", Unit), App(Var("input"), [Int(0)]), Let(("_", Unit), App(Var("sort"), [Var("arr"), Var("len")]), App(Var("output"), [Var("arr"), Int(0), Var("len")]))))))}, App(Var("main"), []))))))
// [Knf] build_knf: Let(("_", Unit), App(Var("swap"), [Var("arr"), Var("pivot_index"), Prim(Var("high"), Int(1), Sub, kind=Some(Int))]), Let(("pivot", Int), Get(Var("arr"), Prim(Var("high"), Int(1), Sub, kind=Some(Int))), Let(("i", Array(Int)), Array(Int(1), Var("low")), Let(("partitioned", Array(Int)), Array(Int(1), Int(1)), LetRec({tyvars: [], name: ("aux", Unit), args: [("j", Int)], body: If(LE(Var("j"), Prim(Var("high"), Int(2), Sub, kind=Some(Int))), Let(("_", Unit), If(LE(Get(Var("arr"), Var("j")), Prim(Var("pivot"), Int(1), Sub, kind=Some(Int))), Let(("_", Unit), If(Eq(Get(Var("i"), Int(0)), Var("j")), Unit, Let(("_", Unit), App(Var("swap"), [Var("arr"), Get(Var("i"), Int(0)), Var("j")]), Put(Var("partitioned"), Int(0), Int(0)))), Let(("_", Unit), Put(Var("i"), Int(0), Prim(Get(Var("i"), Int(0)), Int(1), Add, kind=Some(Int))), Unit)), Unit), App(Var("aux"), [Prim(Var("j"), Int(1), Add, kind=Some(Int))])), Unit)}, Let(("_", Unit), App(Var("aux"), [Var("low")]), Let(("_", Unit), App(Var("swap"), [Var("arr"), Get(Var("i"), Int(0)), Prim(Var("high"), Int(1), Sub, kind=Some(Int))]), Tuple([Get(Var("i"), Int(0)), Eq(Get(Var("partitioned"), Int(0)), Int(1))]))))))))
// [Knf] build_knf: App(Var("swap"), [Var("arr"), Var("pivot_index"), Prim(Var("high"), Int(1), Sub, kind=Some(Int))])
// [Knf] build_knf: Var("swap")
// [Knf] build_knf: Var("arr")
// [Knf] build_knf: Var("pivot_index")
// [Knf] build_knf: Prim(Var("high"), Int(1), Sub, kind=Some(Int))
// [Knf] build_knf: Var("high")
// [Knf] build_knf: Int(1)
// [Knf] build_knf: Let(("pivot", Int), Get(Var("arr"), Prim(Var("high"), Int(1), Sub, kind=Some(Int))), Let(("i", Array(Int)), Array(Int(1), Var("low")), Let(("partitioned", Array(Int)), Array(Int(1), Int(1)), LetRec({tyvars: [], name: ("aux", Unit), args: [("j", Int)], body: If(LE(Var("j"), Prim(Var("high"), Int(2), Sub, kind=Some(Int))), Let(("_", Unit), If(LE(Get(Var("arr"), Var("j")), Prim(Var("pivot"), Int(1), Sub, kind=Some(Int))), Let(("_", Unit), If(Eq(Get(Var("i"), Int(0)), Var("j")), Unit, Let(("_", Unit), App(Var("swap"), [Var("arr"), Get(Var("i"), Int(0)), Var("j")]), Put(Var("partitioned"), Int(0), Int(0)))), Let(("_", Unit), Put(Var("i"), Int(0), Prim(Get(Var("i"), Int(0)), Int(1), Add, kind=Some(Int))), Unit)), Unit), App(Var("aux"), [Prim(Var("j"), Int(1), Add, kind=Some(Int))])), Unit)}, Let(("_", Unit), App(Var("aux"), [Var("low")]), Let(("_", Unit), App(Var("swap"), [Var("arr"), Get(Var("i"), Int(0)), Prim(Var("high"), Int(1), Sub, kind=Some(Int))]), Tuple([Get(Var("i"), Int(0)), Eq(Get(Var("partitioned"), Int(0)), Int(1))])))))))
// [Knf] build_knf: Get(Var("arr"), Prim(Var("high"), Int(1), Sub, kind=Some(Int)))
// [Knf] build_knf: Var("arr")
// [Knf] build_knf: Prim(Var("high"), Int(1), Sub, kind=Some(Int))
// [Knf] build_knf: Var("high")
// [Knf] build_knf: Int(1)
// [Knf] build_knf: Let(("i", Array(Int)), Array(Int(1), Var("low")), Let(("partitioned", Array(Int)), Array(Int(1), Int(1)), LetRec({tyvars: [], name: ("aux", Unit), args: [("j", Int)], body: If(LE(Var("j"), Prim(Var("high"), Int(2), Sub, kind=Some(Int))), Let(("_", Unit), If(LE(Get(Var("arr"), Var("j")), Prim(Var("pivot"), Int(1), Sub, kind=Some(Int))), Let(("_", Unit), If(Eq(Get(Var("i"), Int(0)), Var("j")), Unit, Let(("_", Unit), App(Var("swap"), [Var("arr"), Get(Var("i"), Int(0)), Var("j")]), Put(Var("partitioned"), Int(0), Int(0)))), Let(("_", Unit), Put(Var("i"), Int(0), Prim(Get(Var("i"), Int(0)), Int(1), Add, kind=Some(Int))), Unit)), Unit), App(Var("aux"), [Prim(Var("j"), Int(1), Add, kind=Some(Int))])), Unit)}, Let(("_", Unit), App(Var("aux"), [Var("low")]), Let(("_", Unit), App(Var("swap"), [Var("arr"), Get(Var("i"), Int(0)), Prim(Var("high"), Int(1), Sub, kind=Some(Int))]), Tuple([Get(Var("i"), Int(0)), Eq(Get(Var("partitioned"), Int(0)), Int(1))]))))))
// [Knf] build_knf: Array(Int(1), Var("low"))
// [Knf] build_knf: Int(1)
// [Knf] build_knf: Var("low")
// [Knf] build_knf: Let(("partitioned", Array(Int)), Array(Int(1), Int(1)), LetRec({tyvars: [], name: ("aux", Unit), args: [("j", Int)], body: If(LE(Var("j"), Prim(Var("high"), Int(2), Sub, kind=Some(Int))), Let(("_", Unit), If(LE(Get(Var("arr"), Var("j")), Prim(Var("pivot"), Int(1), Sub, kind=Some(Int))), Let(("_", Unit), If(Eq(Get(Var("i"), Int(0)), Var("j")), Unit, Let(("_", Unit), App(Var("swap"), [Var("arr"), Get(Var("i"), Int(0)), Var("j")]), Put(Var("partitioned"), Int(0), Int(0)))), Let(("_", Unit), Put(Var("i"), Int(0), Prim(Get(Var("i"), Int(0)), Int(1), Add, kind=Some(Int))), Unit)), Unit), App(Var("aux"), [Prim(Var("j"), Int(1), Add, kind=Some(Int))])), Unit)}, Let(("_", Unit), App(Var("aux"), [Var("low")]), Let(("_", Unit), App(Var("swap"), [Var("arr"), Get(Var("i"), Int(0)), Prim(Var("high"), Int(1), Sub, kind=Some(Int))]), Tuple([Get(Var("i"), Int(0)), Eq(Get(Var("partitioned"), Int(0)), Int(1))])))))
// [Knf] build_knf: Array(Int(1), Int(1))
// [Knf] build_knf: Int(1)
// [Knf] build_knf: Int(1)
// [Knf] build_knf: LetRec({tyvars: [], name: ("aux", Unit), args: [("j", Int)], body: If(LE(Var("j"), Prim(Var("high"), Int(2), Sub, kind=Some(Int))), Let(("_", Unit), If(LE(Get(Var("arr"), Var("j")), Prim(Var("pivot"), Int(1), Sub, kind=Some(Int))), Let(("_", Unit), If(Eq(Get(Var("i"), Int(0)), Var("j")), Unit, Let(("_", Unit), App(Var("swap"), [Var("arr"), Get(Var("i"), Int(0)), Var("j")]), Put(Var("partitioned"), Int(0), Int(0)))), Let(("_", Unit), Put(Var("i"), Int(0), Prim(Get(Var("i"), Int(0)), Int(1), Add, kind=Some(Int))), Unit)), Unit), App(Var("aux"), [Prim(Var("j"), Int(1), Add, kind=Some(Int))])), Unit)}, Let(("_", Unit), App(Var("aux"), [Var("low")]), Let(("_", Unit), App(Var("swap"), [Var("arr"), Get(Var("i"), Int(0)), Prim(Var("high"), Int(1), Sub, kind=Some(Int))]), Tuple([Get(Var("i"), Int(0)), Eq(Get(Var("partitioned"), Int(0)), Int(1))]))))
// [Knf] build_knf: If(LE(Var("j"), Prim(Var("high"), Int(2), Sub, kind=Some(Int))), Let(("_", Unit), If(LE(Get(Var("arr"), Var("j")), Prim(Var("pivot"), Int(1), Sub, kind=Some(Int))), Let(("_", Unit), If(Eq(Get(Var("i"), Int(0)), Var("j")), Unit, Let(("_", Unit), App(Var("swap"), [Var("arr"), Get(Var("i"), Int(0)), Var("j")]), Put(Var("partitioned"), Int(0), Int(0)))), Let(("_", Unit), Put(Var("i"), Int(0), Prim(Get(Var("i"), Int(0)), Int(1), Add, kind=Some(Int))), Unit)), Unit), App(Var("aux"), [Prim(Var("j"), Int(1), Add, kind=Some(Int))])), Unit)
// [Knf] build_knf: Var("j")
// [Knf] build_knf: Prim(Var("high"), Int(2), Sub, kind=Some(Int))
// [Knf] build_knf: Var("high")
// [Knf] build_knf: Int(2)
// [Knf] build_knf: Let(("_", Unit), If(LE(Get(Var("arr"), Var("j")), Prim(Var("pivot"), Int(1), Sub, kind=Some(Int))), Let(("_", Unit), If(Eq(Get(Var("i"), Int(0)), Var("j")), Unit, Let(("_", Unit), App(Var("swap"), [Var("arr"), Get(Var("i"), Int(0)), Var("j")]), Put(Var("partitioned"), Int(0), Int(0)))), Let(("_", Unit), Put(Var("i"), Int(0), Prim(Get(Var("i"), Int(0)), Int(1), Add, kind=Some(Int))), Unit)), Unit), App(Var("aux"), [Prim(Var("j"), Int(1), Add, kind=Some(Int))]))
// [Knf] build_knf: If(LE(Get(Var("arr"), Var("j")), Prim(Var("pivot"), Int(1), Sub, kind=Some(Int))), Let(("_", Unit), If(Eq(Get(Var("i"), Int(0)), Var("j")), Unit, Let(("_", Unit), App(Var("swap"), [Var("arr"), Get(Var("i"), Int(0)), Var("j")]), Put(Var("partitioned"), Int(0), Int(0)))), Let(("_", Unit), Put(Var("i"), Int(0), Prim(Get(Var("i"), Int(0)), Int(1), Add, kind=Some(Int))), Unit)), Unit)
// [Knf] build_knf: Get(Var("arr"), Var("j"))
// [Knf] build_knf: Var("arr")
// [Knf] build_knf: Var("j")
// [Knf] build_knf: Prim(Var("pivot"), Int(1), Sub, kind=Some(Int))
// [Knf] build_knf: Var("pivot")
// [Knf] build_knf: Int(1)
// [Knf] build_knf: Let(("_", Unit), If(Eq(Get(Var("i"), Int(0)), Var("j")), Unit, Let(("_", Unit), App(Var("swap"), [Var("arr"), Get(Var("i"), Int(0)), Var("j")]), Put(Var("partitioned"), Int(0), Int(0)))), Let(("_", Unit), Put(Var("i"), Int(0), Prim(Get(Var("i"), Int(0)), Int(1), Add, kind=Some(Int))), Unit))
// [Knf] build_knf: If(Eq(Get(Var("i"), Int(0)), Var("j")), Unit, Let(("_", Unit), App(Var("swap"), [Var("arr"), Get(Var("i"), Int(0)), Var("j")]), Put(Var("partitioned"), Int(0), Int(0))))
// [Knf] build_knf: Get(Var("i"), Int(0))
// [Knf] build_knf: Var("i")
// [Knf] build_knf: Int(0)
// [Knf] build_knf: Var("j")
// [Knf] build_knf: Unit
// [Knf] build_knf: Let(("_", Unit), App(Var("swap"), [Var("arr"), Get(Var("i"), Int(0)), Var("j")]), Put(Var("partitioned"), Int(0), Int(0)))
// [Knf] build_knf: App(Var("swap"), [Var("arr"), Get(Var("i"), Int(0)), Var("j")])
// [Knf] build_knf: Var("swap")
// [Knf] build_knf: Var("arr")
// [Knf] build_knf: Get(Var("i"), Int(0))
// [Knf] build_knf: Var("i")
// [Knf] build_knf: Int(0)
// [Knf] build_knf: Var("j")
// [Knf] build_knf: Put(Var("partitioned"), Int(0), Int(0))
// [Knf] build_knf: Var("partitioned")
// [Knf] build_knf: Int(0)
// [Knf] build_knf: Int(0)
// [Knf] build_knf: Let(("_", Unit), Put(Var("i"), Int(0), Prim(Get(Var("i"), Int(0)), Int(1), Add, kind=Some(Int))), Unit)
// [Knf] build_knf: Put(Var("i"), Int(0), Prim(Get(Var("i"), Int(0)), Int(1), Add, kind=Some(Int)))
// [Knf] build_knf: Var("i")
// [Knf] build_knf: Int(0)
// [Knf] build_knf: Prim(Get(Var("i"), Int(0)), Int(1), Add, kind=Some(Int))
// [Knf] build_knf: Get(Var("i"), Int(0))
// [Knf] build_knf: Var("i")
// [Knf] build_knf: Int(0)
// [Knf] build_knf: Int(1)
// [Knf] build_knf: Unit
// [Knf] build_knf: Unit
// [Knf] build_knf: App(Var("aux"), [Prim(Var("j"), Int(1), Add, kind=Some(Int))])
// [Knf] build_knf: Var("aux")
// [Knf] build_knf: Prim(Var("j"), Int(1), Add, kind=Some(Int))
// [Knf] build_knf: Var("j")
// [Knf] build_knf: Int(1)
// [Knf] build_knf: Unit
// [Knf] build_knf: Let(("_", Unit), App(Var("aux"), [Var("low")]), Let(("_", Unit), App(Var("swap"), [Var("arr"), Get(Var("i"), Int(0)), Prim(Var("high"), Int(1), Sub, kind=Some(Int))]), Tuple([Get(Var("i"), Int(0)), Eq(Get(Var("partitioned"), Int(0)), Int(1))])))
// [Knf] build_knf: App(Var("aux"), [Var("low")])
// [Knf] build_knf: Var("aux")
// [Knf] build_knf: Var("low")
// [Knf] build_knf: Let(("_", Unit), App(Var("swap"), [Var("arr"), Get(Var("i"), Int(0)), Prim(Var("high"), Int(1), Sub, kind=Some(Int))]), Tuple([Get(Var("i"), Int(0)), Eq(Get(Var("partitioned"), Int(0)), Int(1))]))
// [Knf] build_knf: App(Var("swap"), [Var("arr"), Get(Var("i"), Int(0)), Prim(Var("high"), Int(1), Sub, kind=Some(Int))])
// [Knf] build_knf: Var("swap")
// [Knf] build_knf: Var("arr")
// [Knf] build_knf: Get(Var("i"), Int(0))
// [Knf] build_knf: Var("i")
// [Knf] build_knf: Int(0)
// [Knf] build_knf: Prim(Var("high"), Int(1), Sub, kind=Some(Int))
// [Knf] build_knf: Var("high")
// [Knf] build_knf: Int(1)
// [Knf] build_knf: Tuple([Get(Var("i"), Int(0)), Eq(Get(Var("partitioned"), Int(0)), Int(1))])
// [Knf] build_knf: Get(Var("i"), Int(0))
// [Knf] build_knf: Var("i")
// [Knf] build_knf: Int(0)
// [Knf] build_knf: Eq(Get(Var("partitioned"), Int(0)), Int(1))
// [Knf] build_knf: Get(Var("partitioned"), Int(0))
// [Knf] build_knf: Var("partitioned")
// [Knf] build_knf: Int(0)
// [Knf] build_knf: Int(1)
// [Knf] build_knf: LetRec({tyvars: [], name: ("choose_pivot", Tuple([Int, Bool])), args: [("arr", Array(Int)), ("low", Int), ("high", Int)], body: Let(("use_median_of_medians", Int), Int(50), Let(("swaps", Array(Int)), Array(Int(1), Int(0)), Let(("len", Int), Prim(Var("high"), Var("low"), Sub, kind=Some(Int)), Let(("b", Int), Prim(Var("low"), Prim(Prim(Var("len"), Int(4), Div, kind=Some(Int)), Int(2), Mul, kind=Some(Int)), Add, kind=Some(Int)), Let(("_", Unit), If(LE(Int(8), Var("len")), Let(("a", Int), Prim(Var("low"), Prim(Prim(Var("len"), Int(4), Div, kind=Some(Int)), Int(1), Mul, kind=Some(Int)), Add, kind=Some(Int)), Let(("c", Int), Prim(Var("low"), Prim(Prim(Var("len"), Int(4), Div, kind=Some(Int)), Int(3), Mul, kind=Some(Int)), Add, kind=Some(Int)), LetRec({tyvars: [], name: ("sort_2", Unit), args: [("a", Int), ("b", Int)], body: If(LE(Get(Var("arr"), Var("b")), Prim(Get(Var("arr"), Var("a")), Int(1), Sub, kind=Some(Int))), Let(("_", Unit), App(Var("swap"), [Var("arr"), Var("a"), Var("b")]), Put(Var("swaps"), Int(0), Prim(Get(Var("swaps"), Int(0)), Int(1), Add, kind=Some(Int)))), Unit)}, LetRec({tyvars: [], name: ("sort_3", Unit), args: [("a", Int), ("b", Int), ("c", Int)], body: Let(("_", Unit), App(Var("sort_2"), [Var("a"), Var("b")]), Let(("_", Unit), App(Var("sort_2"), [Var("b"), Var("c")]), App(Var("sort_2"), [Var("a"), Var("b")])))}, Let(("_", Unit), If(LE(Var("use_median_of_medians"), Prim(Var("len"), Int(1), Sub, kind=Some(Int))), Let(("_", Unit), App(Var("sort_3"), [Prim(Var("a"), Int(1), Sub, kind=Some(Int)), Var("a"), Prim(Var("a"), Int(1), Add, kind=Some(Int))]), Let(("_", Unit), App(Var("sort_3"), [Prim(Var("b"), Int(1), Sub, kind=Some(Int)), Var("b"), Prim(Var("b"), Int(1), Add, kind=Some(Int))]), App(Var("sort_3"), [Prim(Var("c"), Int(1), Sub, kind=Some(Int)), Var("c"), Prim(Var("c"), Int(1), Add, kind=Some(Int))]))), Unit), App(Var("sort_3"), [Var("a"), Var("b"), Var("c")])))))), Unit), Tuple([Var("b"), Eq(Get(Var("swaps"), Int(0)), Int(0))]))))))}, LetRec({tyvars: [], name: ("quick_sort", Unit), args: [("arr", Array(Int)), ("low", Int), ("high", Int)], body: Let(("len", Int), Prim(Var("high"), Var("low"), Sub, kind=Some(Int)), If(LE(Var("len"), Int(16)), App(Var("insertion_sort"), [Var("arr"), Var("low"), Var("high")]), LetTuple([("pivot_index", Int), ("likely_sorted", Bool)], App(Var("choose_pivot"), [Var("arr"), Var("low"), Var("high")]), LetTuple([("pivot", Int), ("partitioned", Bool)], App(Var("partition"), [Var("arr"), Var("pivot_index"), Var("low"), Var("high")]), Let(("_", Unit), App(Var("quick_sort"), [Var("arr"), Var("low"), Var("pivot")]), App(Var("quick_sort"), [Var("arr"), Prim(Var("pivot"), Int(1), Add, kind=Some(Int)), Var("high")]))))))}, LetRec({tyvars: [], name: ("sort", Unit), args: [("x", Array(Int)), ("len", Int)], body: App(Var("quick_sort"), [Var("x"), Int(0), Var("len")])}, LetRec({tyvars: [], name: ("main", Unit), args: [], body: Let(("len", Int), App(Var("read_int"), []), Let(("arr", Array(Int)), Array(Var("len"), Int(0)), LetRec({tyvars: [], name: ("input", Unit), args: [("i", Int)], body: If(LE(Var("i"), Prim(Var("len"), Int(1), Sub, kind=Some(Int))), Let(("_", Unit), Put(Var("arr"), Var("i"), App(Var("read_int"), [])), App(Var("input"), [Prim(Var("i"), Int(1), Add, kind=Some(Int))])), Unit)}, Let(("_", Unit), App(Var("input"), [Int(0)]), Let(("_", Unit), App(Var("sort"), [Var("arr"), Var("len")]), App(Var("output"), [Var("arr"), Int(0), Var("len")]))))))}, App(Var("main"), [])))))
// [Knf] build_knf: Let(("use_median_of_medians", Int), Int(50), Let(("swaps", Array(Int)), Array(Int(1), Int(0)), Let(("len", Int), Prim(Var("high"), Var("low"), Sub, kind=Some(Int)), Let(("b", Int), Prim(Var("low"), Prim(Prim(Var("len"), Int(4), Div, kind=Some(Int)), Int(2), Mul, kind=Some(Int)), Add, kind=Some(Int)), Let(("_", Unit), If(LE(Int(8), Var("len")), Let(("a", Int), Prim(Var("low"), Prim(Prim(Var("len"), Int(4), Div, kind=Some(Int)), Int(1), Mul, kind=Some(Int)), Add, kind=Some(Int)), Let(("c", Int), Prim(Var("low"), Prim(Prim(Var("len"), Int(4), Div, kind=Some(Int)), Int(3), Mul, kind=Some(Int)), Add, kind=Some(Int)), LetRec({tyvars: [], name: ("sort_2", Unit), args: [("a", Int), ("b", Int)], body: If(LE(Get(Var("arr"), Var("b")), Prim(Get(Var("arr"), Var("a")), Int(1), Sub, kind=Some(Int))), Let(("_", Unit), App(Var("swap"), [Var("arr"), Var("a"), Var("b")]), Put(Var("swaps"), Int(0), Prim(Get(Var("swaps"), Int(0)), Int(1), Add, kind=Some(Int)))), Unit)}, LetRec({tyvars: [], name: ("sort_3", Unit), args: [("a", Int), ("b", Int), ("c", Int)], body: Let(("_", Unit), App(Var("sort_2"), [Var("a"), Var("b")]), Let(("_", Unit), App(Var("sort_2"), [Var("b"), Var("c")]), App(Var("sort_2"), [Var("a"), Var("b")])))}, Let(("_", Unit), If(LE(Var("use_median_of_medians"), Prim(Var("len"), Int(1), Sub, kind=Some(Int))), Let(("_", Unit), App(Var("sort_3"), [Prim(Var("a"), Int(1), Sub, kind=Some(Int)), Var("a"), Prim(Var("a"), Int(1), Add, kind=Some(Int))]), Let(("_", Unit), App(Var("sort_3"), [Prim(Var("b"), Int(1), Sub, kind=Some(Int)), Var("b"), Prim(Var("b"), Int(1), Add, kind=Some(Int))]), App(Var("sort_3"), [Prim(Var("c"), Int(1), Sub, kind=Some(Int)), Var("c"), Prim(Var("c"), Int(1), Add, kind=Some(Int))]))), Unit), App(Var("sort_3"), [Var("a"), Var("b"), Var("c")])))))), Unit), Tuple([Var("b"), Eq(Get(Var("swaps"), Int(0)), Int(0))]))))))
// [Knf] build_knf: Int(50)
// [Knf] build_knf: Let(("swaps", Array(Int)), Array(Int(1), Int(0)), Let(("len", Int), Prim(Var("high"), Var("low"), Sub, kind=Some(Int)), Let(("b", Int), Prim(Var("low"), Prim(Prim(Var("len"), Int(4), Div, kind=Some(Int)), Int(2), Mul, kind=Some(Int)), Add, kind=Some(Int)), Let(("_", Unit), If(LE(Int(8), Var("len")), Let(("a", Int), Prim(Var("low"), Prim(Prim(Var("len"), Int(4), Div, kind=Some(Int)), Int(1), Mul, kind=Some(Int)), Add, kind=Some(Int)), Let(("c", Int), Prim(Var("low"), Prim(Prim(Var("len"), Int(4), Div, kind=Some(Int)), Int(3), Mul, kind=Some(Int)), Add, kind=Some(Int)), LetRec({tyvars: [], name: ("sort_2", Unit), args: [("a", Int), ("b", Int)], body: If(LE(Get(Var("arr"), Var("b")), Prim(Get(Var("arr"), Var("a")), Int(1), Sub, kind=Some(Int))), Let(("_", Unit), App(Var("swap"), [Var("arr"), Var("a"), Var("b")]), Put(Var("swaps"), Int(0), Prim(Get(Var("swaps"), Int(0)), Int(1), Add, kind=Some(Int)))), Unit)}, LetRec({tyvars: [], name: ("sort_3", Unit), args: [("a", Int), ("b", Int), ("c", Int)], body: Let(("_", Unit), App(Var("sort_2"), [Var("a"), Var("b")]), Let(("_", Unit), App(Var("sort_2"), [Var("b"), Var("c")]), App(Var("sort_2"), [Var("a"), Var("b")])))}, Let(("_", Unit), If(LE(Var("use_median_of_medians"), Prim(Var("len"), Int(1), Sub, kind=Some(Int))), Let(("_", Unit), App(Var("sort_3"), [Prim(Var("a"), Int(1), Sub, kind=Some(Int)), Var("a"), Prim(Var("a"), Int(1), Add, kind=Some(Int))]), Let(("_", Unit), App(Var("sort_3"), [Prim(Var("b"), Int(1), Sub, kind=Some(Int)), Var("b"), Prim(Var("b"), Int(1), Add, kind=Some(Int))]), App(Var("sort_3"), [Prim(Var("c"), Int(1), Sub, kind=Some(Int)), Var("c"), Prim(Var("c"), Int(1), Add, kind=Some(Int))]))), Unit), App(Var("sort_3"), [Var("a"), Var("b"), Var("c")])))))), Unit), Tuple([Var("b"), Eq(Get(Var("swaps"), Int(0)), Int(0))])))))
// [Knf] build_knf: Array(Int(1), Int(0))
// [Knf] build_knf: Int(1)
// [Knf] build_knf: Int(0)
// [Knf] build_knf: Let(("len", Int), Prim(Var("high"), Var("low"), Sub, kind=Some(Int)), Let(("b", Int), Prim(Var("low"), Prim(Prim(Var("len"), Int(4), Div, kind=Some(Int)), Int(2), Mul, kind=Some(Int)), Add, kind=Some(Int)), Let(("_", Unit), If(LE(Int(8), Var("len")), Let(("a", Int), Prim(Var("low"), Prim(Prim(Var("len"), Int(4), Div, kind=Some(Int)), Int(1), Mul, kind=Some(Int)), Add, kind=Some(Int)), Let(("c", Int), Prim(Var("low"), Prim(Prim(Var("len"), Int(4), Div, kind=Some(Int)), Int(3), Mul, kind=Some(Int)), Add, kind=Some(Int)), LetRec({tyvars: [], name: ("sort_2", Unit), args: [("a", Int), ("b", Int)], body: If(LE(Get(Var("arr"), Var("b")), Prim(Get(Var("arr"), Var("a")), Int(1), Sub, kind=Some(Int))), Let(("_", Unit), App(Var("swap"), [Var("arr"), Var("a"), Var("b")]), Put(Var("swaps"), Int(0), Prim(Get(Var("swaps"), Int(0)), Int(1), Add, kind=Some(Int)))), Unit)}, LetRec({tyvars: [], name: ("sort_3", Unit), args: [("a", Int), ("b", Int), ("c", Int)], body: Let(("_", Unit), App(Var("sort_2"), [Var("a"), Var("b")]), Let(("_", Unit), App(Var("sort_2"), [Var("b"), Var("c")]), App(Var("sort_2"), [Var("a"), Var("b")])))}, Let(("_", Unit), If(LE(Var("use_median_of_medians"), Prim(Var("len"), Int(1), Sub, kind=Some(Int))), Let(("_", Unit), App(Var("sort_3"), [Prim(Var("a"), Int(1), Sub, kind=Some(Int)), Var("a"), Prim(Var("a"), Int(1), Add, kind=Some(Int))]), Let(("_", Unit), App(Var("sort_3"), [Prim(Var("b"), Int(1), Sub, kind=Some(Int)), Var("b"), Prim(Var("b"), Int(1), Add, kind=Some(Int))]), App(Var("sort_3"), [Prim(Var("c"), Int(1), Sub, kind=Some(Int)), Var("c"), Prim(Var("c"), Int(1), Add, kind=Some(Int))]))), Unit), App(Var("sort_3"), [Var("a"), Var("b"), Var("c")])))))), Unit), Tuple([Var("b"), Eq(Get(Var("swaps"), Int(0)), Int(0))]))))
// [Knf] build_knf: Prim(Var("high"), Var("low"), Sub, kind=Some(Int))
// [Knf] build_knf: Var("high")
// [Knf] build_knf: Var("low")
// [Knf] build_knf: Let(("b", Int), Prim(Var("low"), Prim(Prim(Var("len"), Int(4), Div, kind=Some(Int)), Int(2), Mul, kind=Some(Int)), Add, kind=Some(Int)), Let(("_", Unit), If(LE(Int(8), Var("len")), Let(("a", Int), Prim(Var("low"), Prim(Prim(Var("len"), Int(4), Div, kind=Some(Int)), Int(1), Mul, kind=Some(Int)), Add, kind=Some(Int)), Let(("c", Int), Prim(Var("low"), Prim(Prim(Var("len"), Int(4), Div, kind=Some(Int)), Int(3), Mul, kind=Some(Int)), Add, kind=Some(Int)), LetRec({tyvars: [], name: ("sort_2", Unit), args: [("a", Int), ("b", Int)], body: If(LE(Get(Var("arr"), Var("b")), Prim(Get(Var("arr"), Var("a")), Int(1), Sub, kind=Some(Int))), Let(("_", Unit), App(Var("swap"), [Var("arr"), Var("a"), Var("b")]), Put(Var("swaps"), Int(0), Prim(Get(Var("swaps"), Int(0)), Int(1), Add, kind=Some(Int)))), Unit)}, LetRec({tyvars: [], name: ("sort_3", Unit), args: [("a", Int), ("b", Int), ("c", Int)], body: Let(("_", Unit), App(Var("sort_2"), [Var("a"), Var("b")]), Let(("_", Unit), App(Var("sort_2"), [Var("b"), Var("c")]), App(Var("sort_2"), [Var("a"), Var("b")])))}, Let(("_", Unit), If(LE(Var("use_median_of_medians"), Prim(Var("len"), Int(1), Sub, kind=Some(Int))), Let(("_", Unit), App(Var("sort_3"), [Prim(Var("a"), Int(1), Sub, kind=Some(Int)), Var("a"), Prim(Var("a"), Int(1), Add, kind=Some(Int))]), Let(("_", Unit), App(Var("sort_3"), [Prim(Var("b"), Int(1), Sub, kind=Some(Int)), Var("b"), Prim(Var("b"), Int(1), Add, kind=Some(Int))]), App(Var("sort_3"), [Prim(Var("c"), Int(1), Sub, kind=Some(Int)), Var("c"), Prim(Var("c"), Int(1), Add, kind=Some(Int))]))), Unit), App(Var("sort_3"), [Var("a"), Var("b"), Var("c")])))))), Unit), Tuple([Var("b"), Eq(Get(Var("swaps"), Int(0)), Int(0))])))
// [Knf] build_knf: Prim(Var("low"), Prim(Prim(Var("len"), Int(4), Div, kind=Some(Int)), Int(2), Mul, kind=Some(Int)), Add, kind=Some(Int))
// [Knf] build_knf: Var("low")
// [Knf] build_knf: Prim(Prim(Var("len"), Int(4), Div, kind=Some(Int)), Int(2), Mul, kind=Some(Int))
// [Knf] build_knf: Prim(Var("len"), Int(4), Div, kind=Some(Int))
// [Knf] build_knf: Var("len")
// [Knf] build_knf: Int(4)
// [Knf] build_knf: Int(2)
// [Knf] build_knf: Let(("_", Unit), If(LE(Int(8), Var("len")), Let(("a", Int), Prim(Var("low"), Prim(Prim(Var("len"), Int(4), Div, kind=Some(Int)), Int(1), Mul, kind=Some(Int)), Add, kind=Some(Int)), Let(("c", Int), Prim(Var("low"), Prim(Prim(Var("len"), Int(4), Div, kind=Some(Int)), Int(3), Mul, kind=Some(Int)), Add, kind=Some(Int)), LetRec({tyvars: [], name: ("sort_2", Unit), args: [("a", Int), ("b", Int)], body: If(LE(Get(Var("arr"), Var("b")), Prim(Get(Var("arr"), Var("a")), Int(1), Sub, kind=Some(Int))), Let(("_", Unit), App(Var("swap"), [Var("arr"), Var("a"), Var("b")]), Put(Var("swaps"), Int(0), Prim(Get(Var("swaps"), Int(0)), Int(1), Add, kind=Some(Int)))), Unit)}, LetRec({tyvars: [], name: ("sort_3", Unit), args: [("a", Int), ("b", Int), ("c", Int)], body: Let(("_", Unit), App(Var("sort_2"), [Var("a"), Var("b")]), Let(("_", Unit), App(Var("sort_2"), [Var("b"), Var("c")]), App(Var("sort_2"), [Var("a"), Var("b")])))}, Let(("_", Unit), If(LE(Var("use_median_of_medians"), Prim(Var("len"), Int(1), Sub, kind=Some(Int))), Let(("_", Unit), App(Var("sort_3"), [Prim(Var("a"), Int(1), Sub, kind=Some(Int)), Var("a"), Prim(Var("a"), Int(1), Add, kind=Some(Int))]), Let(("_", Unit), App(Var("sort_3"), [Prim(Var("b"), Int(1), Sub, kind=Some(Int)), Var("b"), Prim(Var("b"), Int(1), Add, kind=Some(Int))]), App(Var("sort_3"), [Prim(Var("c"), Int(1), Sub, kind=Some(Int)), Var("c"), Prim(Var("c"), Int(1), Add, kind=Some(Int))]))), Unit), App(Var("sort_3"), [Var("a"), Var("b"), Var("c")])))))), Unit), Tuple([Var("b"), Eq(Get(Var("swaps"), Int(0)), Int(0))]))
// [Knf] build_knf: If(LE(Int(8), Var("len")), Let(("a", Int), Prim(Var("low"), Prim(Prim(Var("len"), Int(4), Div, kind=Some(Int)), Int(1), Mul, kind=Some(Int)), Add, kind=Some(Int)), Let(("c", Int), Prim(Var("low"), Prim(Prim(Var("len"), Int(4), Div, kind=Some(Int)), Int(3), Mul, kind=Some(Int)), Add, kind=Some(Int)), LetRec({tyvars: [], name: ("sort_2", Unit), args: [("a", Int), ("b", Int)], body: If(LE(Get(Var("arr"), Var("b")), Prim(Get(Var("arr"), Var("a")), Int(1), Sub, kind=Some(Int))), Let(("_", Unit), App(Var("swap"), [Var("arr"), Var("a"), Var("b")]), Put(Var("swaps"), Int(0), Prim(Get(Var("swaps"), Int(0)), Int(1), Add, kind=Some(Int)))), Unit)}, LetRec({tyvars: [], name: ("sort_3", Unit), args: [("a", Int), ("b", Int), ("c", Int)], body: Let(("_", Unit), App(Var("sort_2"), [Var("a"), Var("b")]), Let(("_", Unit), App(Var("sort_2"), [Var("b"), Var("c")]), App(Var("sort_2"), [Var("a"), Var("b")])))}, Let(("_", Unit), If(LE(Var("use_median_of_medians"), Prim(Var("len"), Int(1), Sub, kind=Some(Int))), Let(("_", Unit), App(Var("sort_3"), [Prim(Var("a"), Int(1), Sub, kind=Some(Int)), Var("a"), Prim(Var("a"), Int(1), Add, kind=Some(Int))]), Let(("_", Unit), App(Var("sort_3"), [Prim(Var("b"), Int(1), Sub, kind=Some(Int)), Var("b"), Prim(Var("b"), Int(1), Add, kind=Some(Int))]), App(Var("sort_3"), [Prim(Var("c"), Int(1), Sub, kind=Some(Int)), Var("c"), Prim(Var("c"), Int(1), Add, kind=Some(Int))]))), Unit), App(Var("sort_3"), [Var("a"), Var("b"), Var("c")])))))), Unit)
// [Knf] build_knf: Int(8)
// [Knf] build_knf: Var("len")
// [Knf] build_knf: Let(("a", Int), Prim(Var("low"), Prim(Prim(Var("len"), Int(4), Div, kind=Some(Int)), Int(1), Mul, kind=Some(Int)), Add, kind=Some(Int)), Let(("c", Int), Prim(Var("low"), Prim(Prim(Var("len"), Int(4), Div, kind=Some(Int)), Int(3), Mul, kind=Some(Int)), Add, kind=Some(Int)), LetRec({tyvars: [], name: ("sort_2", Unit), args: [("a", Int), ("b", Int)], body: If(LE(Get(Var("arr"), Var("b")), Prim(Get(Var("arr"), Var("a")), Int(1), Sub, kind=Some(Int))), Let(("_", Unit), App(Var("swap"), [Var("arr"), Var("a"), Var("b")]), Put(Var("swaps"), Int(0), Prim(Get(Var("swaps"), Int(0)), Int(1), Add, kind=Some(Int)))), Unit)}, LetRec({tyvars: [], name: ("sort_3", Unit), args: [("a", Int), ("b", Int), ("c", Int)], body: Let(("_", Unit), App(Var("sort_2"), [Var("a"), Var("b")]), Let(("_", Unit), App(Var("sort_2"), [Var("b"), Var("c")]), App(Var("sort_2"), [Var("a"), Var("b")])))}, Let(("_", Unit), If(LE(Var("use_median_of_medians"), Prim(Var("len"), Int(1), Sub, kind=Some(Int))), Let(("_", Unit), App(Var("sort_3"), [Prim(Var("a"), Int(1), Sub, kind=Some(Int)), Var("a"), Prim(Var("a"), Int(1), Add, kind=Some(Int))]), Let(("_", Unit), App(Var("sort_3"), [Prim(Var("b"), Int(1), Sub, kind=Some(Int)), Var("b"), Prim(Var("b"), Int(1), Add, kind=Some(Int))]), App(Var("sort_3"), [Prim(Var("c"), Int(1), Sub, kind=Some(Int)), Var("c"), Prim(Var("c"), Int(1), Add, kind=Some(Int))]))), Unit), App(Var("sort_3"), [Var("a"), Var("b"), Var("c")]))))))
// [Knf] build_knf: Prim(Var("low"), Prim(Prim(Var("len"), Int(4), Div, kind=Some(Int)), Int(1), Mul, kind=Some(Int)), Add, kind=Some(Int))
// [Knf] build_knf: Var("low")
// [Knf] build_knf: Prim(Prim(Var("len"), Int(4), Div, kind=Some(Int)), Int(1), Mul, kind=Some(Int))
// [Knf] build_knf: Prim(Var("len"), Int(4), Div, kind=Some(Int))
// [Knf] build_knf: Var("len")
// [Knf] build_knf: Int(4)
// [Knf] build_knf: Int(1)
// [Knf] build_knf: Let(("c", Int), Prim(Var("low"), Prim(Prim(Var("len"), Int(4), Div, kind=Some(Int)), Int(3), Mul, kind=Some(Int)), Add, kind=Some(Int)), LetRec({tyvars: [], name: ("sort_2", Unit), args: [("a", Int), ("b", Int)], body: If(LE(Get(Var("arr"), Var("b")), Prim(Get(Var("arr"), Var("a")), Int(1), Sub, kind=Some(Int))), Let(("_", Unit), App(Var("swap"), [Var("arr"), Var("a"), Var("b")]), Put(Var("swaps"), Int(0), Prim(Get(Var("swaps"), Int(0)), Int(1), Add, kind=Some(Int)))), Unit)}, LetRec({tyvars: [], name: ("sort_3", Unit), args: [("a", Int), ("b", Int), ("c", Int)], body: Let(("_", Unit), App(Var("sort_2"), [Var("a"), Var("b")]), Let(("_", Unit), App(Var("sort_2"), [Var("b"), Var("c")]), App(Var("sort_2"), [Var("a"), Var("b")])))}, Let(("_", Unit), If(LE(Var("use_median_of_medians"), Prim(Var("len"), Int(1), Sub, kind=Some(Int))), Let(("_", Unit), App(Var("sort_3"), [Prim(Var("a"), Int(1), Sub, kind=Some(Int)), Var("a"), Prim(Var("a"), Int(1), Add, kind=Some(Int))]), Let(("_", Unit), App(Var("sort_3"), [Prim(Var("b"), Int(1), Sub, kind=Some(Int)), Var("b"), Prim(Var("b"), Int(1), Add, kind=Some(Int))]), App(Var("sort_3"), [Prim(Var("c"), Int(1), Sub, kind=Some(Int)), Var("c"), Prim(Var("c"), Int(1), Add, kind=Some(Int))]))), Unit), App(Var("sort_3"), [Var("a"), Var("b"), Var("c")])))))
// [Knf] build_knf: Prim(Var("low"), Prim(Prim(Var("len"), Int(4), Div, kind=Some(Int)), Int(3), Mul, kind=Some(Int)), Add, kind=Some(Int))
// [Knf] build_knf: Var("low")
// [Knf] build_knf: Prim(Prim(Var("len"), Int(4), Div, kind=Some(Int)), Int(3), Mul, kind=Some(Int))
// [Knf] build_knf: Prim(Var("len"), Int(4), Div, kind=Some(Int))
// [Knf] build_knf: Var("len")
// [Knf] build_knf: Int(4)
// [Knf] build_knf: Int(3)
// [Knf] build_knf: LetRec({tyvars: [], name: ("sort_2", Unit), args: [("a", Int), ("b", Int)], body: If(LE(Get(Var("arr"), Var("b")), Prim(Get(Var("arr"), Var("a")), Int(1), Sub, kind=Some(Int))), Let(("_", Unit), App(Var("swap"), [Var("arr"), Var("a"), Var("b")]), Put(Var("swaps"), Int(0), Prim(Get(Var("swaps"), Int(0)), Int(1), Add, kind=Some(Int)))), Unit)}, LetRec({tyvars: [], name: ("sort_3", Unit), args: [("a", Int), ("b", Int), ("c", Int)], body: Let(("_", Unit), App(Var("sort_2"), [Var("a"), Var("b")]), Let(("_", Unit), App(Var("sort_2"), [Var("b"), Var("c")]), App(Var("sort_2"), [Var("a"), Var("b")])))}, Let(("_", Unit), If(LE(Var("use_median_of_medians"), Prim(Var("len"), Int(1), Sub, kind=Some(Int))), Let(("_", Unit), App(Var("sort_3"), [Prim(Var("a"), Int(1), Sub, kind=Some(Int)), Var("a"), Prim(Var("a"), Int(1), Add, kind=Some(Int))]), Let(("_", Unit), App(Var("sort_3"), [Prim(Var("b"), Int(1), Sub, kind=Some(Int)), Var("b"), Prim(Var("b"), Int(1), Add, kind=Some(Int))]), App(Var("sort_3"), [Prim(Var("c"), Int(1), Sub, kind=Some(Int)), Var("c"), Prim(Var("c"), Int(1), Add, kind=Some(Int))]))), Unit), App(Var("sort_3"), [Var("a"), Var("b"), Var("c")]))))
// [Knf] build_knf: If(LE(Get(Var("arr"), Var("b")), Prim(Get(Var("arr"), Var("a")), Int(1), Sub, kind=Some(Int))), Let(("_", Unit), App(Var("swap"), [Var("arr"), Var("a"), Var("b")]), Put(Var("swaps"), Int(0), Prim(Get(Var("swaps"), Int(0)), Int(1), Add, kind=Some(Int)))), Unit)
// [Knf] build_knf: Get(Var("arr"), Var("b"))
// [Knf] build_knf: Var("arr")
// [Knf] build_knf: Var("b")
// [Knf] build_knf: Prim(Get(Var("arr"), Var("a")), Int(1), Sub, kind=Some(Int))
// [Knf] build_knf: Get(Var("arr"), Var("a"))
// [Knf] build_knf: Var("arr")
// [Knf] build_knf: Var("a")
// [Knf] build_knf: Int(1)
// [Knf] build_knf: Let(("_", Unit), App(Var("swap"), [Var("arr"), Var("a"), Var("b")]), Put(Var("swaps"), Int(0), Prim(Get(Var("swaps"), Int(0)), Int(1), Add, kind=Some(Int))))
// [Knf] build_knf: App(Var("swap"), [Var("arr"), Var("a"), Var("b")])
// [Knf] build_knf: Var("swap")
// [Knf] build_knf: Var("arr")
// [Knf] build_knf: Var("a")
// [Knf] build_knf: Var("b")
// [Knf] build_knf: Put(Var("swaps"), Int(0), Prim(Get(Var("swaps"), Int(0)), Int(1), Add, kind=Some(Int)))
// [Knf] build_knf: Var("swaps")
// [Knf] build_knf: Int(0)
// [Knf] build_knf: Prim(Get(Var("swaps"), Int(0)), Int(1), Add, kind=Some(Int))
// [Knf] build_knf: Get(Var("swaps"), Int(0))
// [Knf] build_knf: Var("swaps")
// [Knf] build_knf: Int(0)
// [Knf] build_knf: Int(1)
// [Knf] build_knf: Unit
// [Knf] build_knf: LetRec({tyvars: [], name: ("sort_3", Unit), args: [("a", Int), ("b", Int), ("c", Int)], body: Let(("_", Unit), App(Var("sort_2"), [Var("a"), Var("b")]), Let(("_", Unit), App(Var("sort_2"), [Var("b"), Var("c")]), App(Var("sort_2"), [Var("a"), Var("b")])))}, Let(("_", Unit), If(LE(Var("use_median_of_medians"), Prim(Var("len"), Int(1), Sub, kind=Some(Int))), Let(("_", Unit), App(Var("sort_3"), [Prim(Var("a"), Int(1), Sub, kind=Some(Int)), Var("a"), Prim(Var("a"), Int(1), Add, kind=Some(Int))]), Let(("_", Unit), App(Var("sort_3"), [Prim(Var("b"), Int(1), Sub, kind=Some(Int)), Var("b"), Prim(Var("b"), Int(1), Add, kind=Some(Int))]), App(Var("sort_3"), [Prim(Var("c"), Int(1), Sub, kind=Some(Int)), Var("c"), Prim(Var("c"), Int(1), Add, kind=Some(Int))]))), Unit), App(Var("sort_3"), [Var("a"), Var("b"), Var("c")])))
// [Knf] build_knf: Let(("_", Unit), App(Var("sort_2"), [Var("a"), Var("b")]), Let(("_", Unit), App(Var("sort_2"), [Var("b"), Var("c")]), App(Var("sort_2"), [Var("a"), Var("b")])))
// [Knf] build_knf: App(Var("sort_2"), [Var("a"), Var("b")])
// [Knf] build_knf: Var("sort_2")
// [Knf] build_knf: Var("a")
// [Knf] build_knf: Var("b")
// [Knf] build_knf: Let(("_", Unit), App(Var("sort_2"), [Var("b"), Var("c")]), App(Var("sort_2"), [Var("a"), Var("b")]))
// [Knf] build_knf: App(Var("sort_2"), [Var("b"), Var("c")])
// [Knf] build_knf: Var("sort_2")
// [Knf] build_knf: Var("b")
// [Knf] build_knf: Var("c")
// [Knf] build_knf: App(Var("sort_2"), [Var("a"), Var("b")])
// [Knf] build_knf: Var("sort_2")
// [Knf] build_knf: Var("a")
// [Knf] build_knf: Var("b")
// [Knf] build_knf: Let(("_", Unit), If(LE(Var("use_median_of_medians"), Prim(Var("len"), Int(1), Sub, kind=Some(Int))), Let(("_", Unit), App(Var("sort_3"), [Prim(Var("a"), Int(1), Sub, kind=Some(Int)), Var("a"), Prim(Var("a"), Int(1), Add, kind=Some(Int))]), Let(("_", Unit), App(Var("sort_3"), [Prim(Var("b"), Int(1), Sub, kind=Some(Int)), Var("b"), Prim(Var("b"), Int(1), Add, kind=Some(Int))]), App(Var("sort_3"), [Prim(Var("c"), Int(1), Sub, kind=Some(Int)), Var("c"), Prim(Var("c"), Int(1), Add, kind=Some(Int))]))), Unit), App(Var("sort_3"), [Var("a"), Var("b"), Var("c")]))
// [Knf] build_knf: If(LE(Var("use_median_of_medians"), Prim(Var("len"), Int(1), Sub, kind=Some(Int))), Let(("_", Unit), App(Var("sort_3"), [Prim(Var("a"), Int(1), Sub, kind=Some(Int)), Var("a"), Prim(Var("a"), Int(1), Add, kind=Some(Int))]), Let(("_", Unit), App(Var("sort_3"), [Prim(Var("b"), Int(1), Sub, kind=Some(Int)), Var("b"), Prim(Var("b"), Int(1), Add, kind=Some(Int))]), App(Var("sort_3"), [Prim(Var("c"), Int(1), Sub, kind=Some(Int)), Var("c"), Prim(Var("c"), Int(1), Add, kind=Some(Int))]))), Unit)
// [Knf] build_knf: Var("use_median_of_medians")
// [Knf] build_knf: Prim(Var("len"), Int(1), Sub, kind=Some(Int))
// [Knf] build_knf: Var("len")
// [Knf] build_knf: Int(1)
// [Knf] build_knf: Let(("_", Unit), App(Var("sort_3"), [Prim(Var("a"), Int(1), Sub, kind=Some(Int)), Var("a"), Prim(Var("a"), Int(1), Add, kind=Some(Int))]), Let(("_", Unit), App(Var("sort_3"), [Prim(Var("b"), Int(1), Sub, kind=Some(Int)), Var("b"), Prim(Var("b"), Int(1), Add, kind=Some(Int))]), App(Var("sort_3"), [Prim(Var("c"), Int(1), Sub, kind=Some(Int)), Var("c"), Prim(Var("c"), Int(1), Add, kind=Some(Int))])))
// [Knf] build_knf: App(Var("sort_3"), [Prim(Var("a"), Int(1), Sub, kind=Some(Int)), Var("a"), Prim(Var("a"), Int(1), Add, kind=Some(Int))])
// [Knf] build_knf: Var("sort_3")
// [Knf] build_knf: Prim(Var("a"), Int(1), Sub, kind=Some(Int))
// [Knf] build_knf: Var("a")
// [Knf] build_knf: Int(1)
// [Knf] build_knf: Var("a")
// [Knf] build_knf: Prim(Var("a"), Int(1), Add, kind=Some(Int))
// [Knf] build_knf: Var("a")
// [Knf] build_knf: Int(1)
// [Knf] build_knf: Let(("_", Unit), App(Var("sort_3"), [Prim(Var("b"), Int(1), Sub, kind=Some(Int)), Var("b"), Prim(Var("b"), Int(1), Add, kind=Some(Int))]), App(Var("sort_3"), [Prim(Var("c"), Int(1), Sub, kind=Some(Int)), Var("c"), Prim(Var("c"), Int(1), Add, kind=Some(Int))]))
// [Knf] build_knf: App(Var("sort_3"), [Prim(Var("b"), Int(1), Sub, kind=Some(Int)), Var("b"), Prim(Var("b"), Int(1), Add, kind=Some(Int))])
// [Knf] build_knf: Var("sort_3")
// [Knf] build_knf: Prim(Var("b"), Int(1), Sub, kind=Some(Int))
// [Knf] build_knf: Var("b")
// [Knf] build_knf: Int(1)
// [Knf] build_knf: Var("b")
// [Knf] build_knf: Prim(Var("b"), Int(1), Add, kind=Some(Int))
// [Knf] build_knf: Var("b")
// [Knf] build_knf: Int(1)
// [Knf] build_knf: App(Var("sort_3"), [Prim(Var("c"), Int(1), Sub, kind=Some(Int)), Var("c"), Prim(Var("c"), Int(1), Add, kind=Some(Int))])
// [Knf] build_knf: Var("sort_3")
// [Knf] build_knf: Prim(Var("c"), Int(1), Sub, kind=Some(Int))
// [Knf] build_knf: Var("c")
// [Knf] build_knf: Int(1)
// [Knf] build_knf: Var("c")
// [Knf] build_knf: Prim(Var("c"), Int(1), Add, kind=Some(Int))
// [Knf] build_knf: Var("c")
// [Knf] build_knf: Int(1)
// [Knf] build_knf: Unit
// [Knf] build_knf: App(Var("sort_3"), [Var("a"), Var("b"), Var("c")])
// [Knf] build_knf: Var("sort_3")
// [Knf] build_knf: Var("a")
// [Knf] build_knf: Var("b")
// [Knf] build_knf: Var("c")
// [Knf] build_knf: Unit
// [Knf] build_knf: Tuple([Var("b"), Eq(Get(Var("swaps"), Int(0)), Int(0))])
// [Knf] build_knf: Var("b")
// [Knf] build_knf: Eq(Get(Var("swaps"), Int(0)), Int(0))
// [Knf] build_knf: Get(Var("swaps"), Int(0))
// [Knf] build_knf: Var("swaps")
// [Knf] build_knf: Int(0)
// [Knf] build_knf: Int(0)
// [Knf] build_knf: LetRec({tyvars: [], name: ("quick_sort", Unit), args: [("arr", Array(Int)), ("low", Int), ("high", Int)], body: Let(("len", Int), Prim(Var("high"), Var("low"), Sub, kind=Some(Int)), If(LE(Var("len"), Int(16)), App(Var("insertion_sort"), [Var("arr"), Var("low"), Var("high")]), LetTuple([("pivot_index", Int), ("likely_sorted", Bool)], App(Var("choose_pivot"), [Var("arr"), Var("low"), Var("high")]), LetTuple([("pivot", Int), ("partitioned", Bool)], App(Var("partition"), [Var("arr"), Var("pivot_index"), Var("low"), Var("high")]), Let(("_", Unit), App(Var("quick_sort"), [Var("arr"), Var("low"), Var("pivot")]), App(Var("quick_sort"), [Var("arr"), Prim(Var("pivot"), Int(1), Add, kind=Some(Int)), Var("high")]))))))}, LetRec({tyvars: [], name: ("sort", Unit), args: [("x", Array(Int)), ("len", Int)], body: App(Var("quick_sort"), [Var("x"), Int(0), Var("len")])}, LetRec({tyvars: [], name: ("main", Unit), args: [], body: Let(("len", Int), App(Var("read_int"), []), Let(("arr", Array(Int)), Array(Var("len"), Int(0)), LetRec({tyvars: [], name: ("input", Unit), args: [("i", Int)], body: If(LE(Var("i"), Prim(Var("len"), Int(1), Sub, kind=Some(Int))), Let(("_", Unit), Put(Var("arr"), Var("i"), App(Var("read_int"), [])), App(Var("input"), [Prim(Var("i"), Int(1), Add, kind=Some(Int))])), Unit)}, Let(("_", Unit), App(Var("input"), [Int(0)]), Let(("_", Unit), App(Var("sort"), [Var("arr"), Var("len")]), App(Var("output"), [Var("arr"), Int(0), Var("len")]))))))}, App(Var("main"), []))))
// [Knf] build_knf: Let(("len", Int), Prim(Var("high"), Var("low"), Sub, kind=Some(Int)), If(LE(Var("len"), Int(16)), App(Var("insertion_sort"), [Var("arr"), Var("low"), Var("high")]), LetTuple([("pivot_index", Int), ("likely_sorted", Bool)], App(Var("choose_pivot"), [Var("arr"), Var("low"), Var("high")]), LetTuple([("pivot", Int), ("partitioned", Bool)], App(Var("partition"), [Var("arr"), Var("pivot_index"), Var("low"), Var("high")]), Let(("_", Unit), App(Var("quick_sort"), [Var("arr"), Var("low"), Var("pivot")]), App(Var("quick_sort"), [Var("arr"), Prim(Var("pivot"), Int(1), Add, kind=Some(Int)), Var("high")]))))))
// [Knf] build_knf: Prim(Var("high"), Var("low"), Sub, kind=Some(Int))
// [Knf] build_knf: Var("high")
// [Knf] build_knf: Var("low")
// [Knf] build_knf: If(LE(Var("len"), Int(16)), App(Var("insertion_sort"), [Var("arr"), Var("low"), Var("high")]), LetTuple([("pivot_index", Int), ("likely_sorted", Bool)], App(Var("choose_pivot"), [Var("arr"), Var("low"), Var("high")]), LetTuple([("pivot", Int), ("partitioned", Bool)], App(Var("partition"), [Var("arr"), Var("pivot_index"), Var("low"), Var("high")]), Let(("_", Unit), App(Var("quick_sort"), [Var("arr"), Var("low"), Var("pivot")]), App(Var("quick_sort"), [Var("arr"), Prim(Var("pivot"), Int(1), Add, kind=Some(Int)), Var("high")])))))
// [Knf] build_knf: Var("len")
// [Knf] build_knf: Int(16)
// [Knf] build_knf: App(Var("insertion_sort"), [Var("arr"), Var("low"), Var("high")])
// [Knf] build_knf: Var("insertion_sort")
// [Knf] build_knf: Var("arr")
// [Knf] build_knf: Var("low")
// [Knf] build_knf: Var("high")
// [Knf] build_knf: LetTuple([("pivot_index", Int), ("likely_sorted", Bool)], App(Var("choose_pivot"), [Var("arr"), Var("low"), Var("high")]), LetTuple([("pivot", Int), ("partitioned", Bool)], App(Var("partition"), [Var("arr"), Var("pivot_index"), Var("low"), Var("high")]), Let(("_", Unit), App(Var("quick_sort"), [Var("arr"), Var("low"), Var("pivot")]), App(Var("quick_sort"), [Var("arr"), Prim(Var("pivot"), Int(1), Add, kind=Some(Int)), Var("high")]))))
// [Knf] build_knf: App(Var("choose_pivot"), [Var("arr"), Var("low"), Var("high")])
// [Knf] build_knf: Var("choose_pivot")
// [Knf] build_knf: Var("arr")
// [Knf] build_knf: Var("low")
// [Knf] build_knf: Var("high")
// [Knf] build_knf: LetTuple([("pivot", Int), ("partitioned", Bool)], App(Var("partition"), [Var("arr"), Var("pivot_index"), Var("low"), Var("high")]), Let(("_", Unit), App(Var("quick_sort"), [Var("arr"), Var("low"), Var("pivot")]), App(Var("quick_sort"), [Var("arr"), Prim(Var("pivot"), Int(1), Add, kind=Some(Int)), Var("high")])))
// [Knf] build_knf: App(Var("partition"), [Var("arr"), Var("pivot_index"), Var("low"), Var("high")])
// [Knf] build_knf: Var("partition")
// [Knf] build_knf: Var("arr")
// [Knf] build_knf: Var("pivot_index")
// [Knf] build_knf: Var("low")
// [Knf] build_knf: Var("high")
// [Knf] build_knf: Let(("_", Unit), App(Var("quick_sort"), [Var("arr"), Var("low"), Var("pivot")]), App(Var("quick_sort"), [Var("arr"), Prim(Var("pivot"), Int(1), Add, kind=Some(Int)), Var("high")]))
// [Knf] build_knf: App(Var("quick_sort"), [Var("arr"), Var("low"), Var("pivot")])
// [Knf] build_knf: Var("quick_sort")
// [Knf] build_knf: Var("arr")
// [Knf] build_knf: Var("low")
// [Knf] build_knf: Var("pivot")
// [Knf] build_knf: App(Var("quick_sort"), [Var("arr"), Prim(Var("pivot"), Int(1), Add, kind=Some(Int)), Var("high")])
// [Knf] build_knf: Var("quick_sort")
// [Knf] build_knf: Var("arr")
// [Knf] build_knf: Prim(Var("pivot"), Int(1), Add, kind=Some(Int))
// [Knf] build_knf: Var("pivot")
// [Knf] build_knf: Int(1)
// [Knf] build_knf: Var("high")
// [Knf] build_knf: LetRec({tyvars: [], name: ("sort", Unit), args: [("x", Array(Int)), ("len", Int)], body: App(Var("quick_sort"), [Var("x"), Int(0), Var("len")])}, LetRec({tyvars: [], name: ("main", Unit), args: [], body: Let(("len", Int), App(Var("read_int"), []), Let(("arr", Array(Int)), Array(Var("len"), Int(0)), LetRec({tyvars: [], name: ("input", Unit), args: [("i", Int)], body: If(LE(Var("i"), Prim(Var("len"), Int(1), Sub, kind=Some(Int))), Let(("_", Unit), Put(Var("arr"), Var("i"), App(Var("read_int"), [])), App(Var("input"), [Prim(Var("i"), Int(1), Add, kind=Some(Int))])), Unit)}, Let(("_", Unit), App(Var("input"), [Int(0)]), Let(("_", Unit), App(Var("sort"), [Var("arr"), Var("len")]), App(Var("output"), [Var("arr"), Int(0), Var("len")]))))))}, App(Var("main"), [])))
// [Knf] build_knf: App(Var("quick_sort"), [Var("x"), Int(0), Var("len")])
// [Knf] build_knf: Var("quick_sort")
// [Knf] build_knf: Var("x")
// [Knf] build_knf: Int(0)
// [Knf] build_knf: Var("len")
// [Knf] build_knf: LetRec({tyvars: [], name: ("main", Unit), args: [], body: Let(("len", Int), App(Var("read_int"), []), Let(("arr", Array(Int)), Array(Var("len"), Int(0)), LetRec({tyvars: [], name: ("input", Unit), args: [("i", Int)], body: If(LE(Var("i"), Prim(Var("len"), Int(1), Sub, kind=Some(Int))), Let(("_", Unit), Put(Var("arr"), Var("i"), App(Var("read_int"), [])), App(Var("input"), [Prim(Var("i"), Int(1), Add, kind=Some(Int))])), Unit)}, Let(("_", Unit), App(Var("input"), [Int(0)]), Let(("_", Unit), App(Var("sort"), [Var("arr"), Var("len")]), App(Var("output"), [Var("arr"), Int(0), Var("len")]))))))}, App(Var("main"), []))
// [Knf] build_knf: Let(("len", Int), App(Var("read_int"), []), Let(("arr", Array(Int)), Array(Var("len"), Int(0)), LetRec({tyvars: [], name: ("input", Unit), args: [("i", Int)], body: If(LE(Var("i"), Prim(Var("len"), Int(1), Sub, kind=Some(Int))), Let(("_", Unit), Put(Var("arr"), Var("i"), App(Var("read_int"), [])), App(Var("input"), [Prim(Var("i"), Int(1), Add, kind=Some(Int))])), Unit)}, Let(("_", Unit), App(Var("input"), [Int(0)]), Let(("_", Unit), App(Var("sort"), [Var("arr"), Var("len")]), App(Var("output"), [Var("arr"), Int(0), Var("len")]))))))
// [Knf] build_knf: App(Var("read_int"), [])
// [Knf] build_knf: Let(("arr", Array(Int)), Array(Var("len"), Int(0)), LetRec({tyvars: [], name: ("input", Unit), args: [("i", Int)], body: If(LE(Var("i"), Prim(Var("len"), Int(1), Sub, kind=Some(Int))), Let(("_", Unit), Put(Var("arr"), Var("i"), App(Var("read_int"), [])), App(Var("input"), [Prim(Var("i"), Int(1), Add, kind=Some(Int))])), Unit)}, Let(("_", Unit), App(Var("input"), [Int(0)]), Let(("_", Unit), App(Var("sort"), [Var("arr"), Var("len")]), App(Var("output"), [Var("arr"), Int(0), Var("len")])))))
// [Knf] build_knf: Array(Var("len"), Int(0))
// [Knf] build_knf: Var("len")
// [Knf] build_knf: Int(0)
// [Knf] build_knf: LetRec({tyvars: [], name: ("input", Unit), args: [("i", Int)], body: If(LE(Var("i"), Prim(Var("len"), Int(1), Sub, kind=Some(Int))), Let(("_", Unit), Put(Var("arr"), Var("i"), App(Var("read_int"), [])), App(Var("input"), [Prim(Var("i"), Int(1), Add, kind=Some(Int))])), Unit)}, Let(("_", Unit), App(Var("input"), [Int(0)]), Let(("_", Unit), App(Var("sort"), [Var("arr"), Var("len")]), App(Var("output"), [Var("arr"), Int(0), Var("len")]))))
// [Knf] build_knf: If(LE(Var("i"), Prim(Var("len"), Int(1), Sub, kind=Some(Int))), Let(("_", Unit), Put(Var("arr"), Var("i"), App(Var("read_int"), [])), App(Var("input"), [Prim(Var("i"), Int(1), Add, kind=Some(Int))])), Unit)
// [Knf] build_knf: Var("i")
// [Knf] build_knf: Prim(Var("len"), Int(1), Sub, kind=Some(Int))
// [Knf] build_knf: Var("len")
// [Knf] build_knf: Int(1)
// [Knf] build_knf: Let(("_", Unit), Put(Var("arr"), Var("i"), App(Var("read_int"), [])), App(Var("input"), [Prim(Var("i"), Int(1), Add, kind=Some(Int))]))
// [Knf] build_knf: Put(Var("arr"), Var("i"), App(Var("read_int"), []))
// [Knf] build_knf: Var("arr")
// [Knf] build_knf: Var("i")
// [Knf] build_knf: App(Var("read_int"), [])
// [Knf] build_knf: App(Var("input"), [Prim(Var("i"), Int(1), Add, kind=Some(Int))])
// [Knf] build_knf: Var("input")
// [Knf] build_knf: Prim(Var("i"), Int(1), Add, kind=Some(Int))
// [Knf] build_knf: Var("i")
// [Knf] build_knf: Int(1)
// [Knf] build_knf: Unit
// [Knf] build_knf: Let(("_", Unit), App(Var("input"), [Int(0)]), Let(("_", Unit), App(Var("sort"), [Var("arr"), Var("len")]), App(Var("output"), [Var("arr"), Int(0), Var("len")])))
// [Knf] build_knf: App(Var("input"), [Int(0)])
// [Knf] build_knf: Var("input")
// [Knf] build_knf: Int(0)
// [Knf] build_knf: Let(("_", Unit), App(Var("sort"), [Var("arr"), Var("len")]), App(Var("output"), [Var("arr"), Int(0), Var("len")]))
// [Knf] build_knf: App(Var("sort"), [Var("arr"), Var("len")])
// [Knf] build_knf: Var("sort")
// [Knf] build_knf: Var("arr")
// [Knf] build_knf: Var("len")
// [Knf] build_knf: App(Var("output"), [Var("arr"), Int(0), Var("len")])
// [Knf] build_knf: Var("output")
// [Knf] build_knf: Var("arr")
// [Knf] build_knf: Int(0)
// [Knf] build_knf: Var("len")
// [Knf] build_knf: App(Var("main"), [])
// [Knf] build_knf: Var("main")
// [Main] function thunk_main(k) {
// [Main]   function swap_1(arr_3, i_5, j_7, k) {
// [Main]     const tmp_8 = arr_3[i_5];
// [Main]     const _9 = arr_3[j_7];
// [Main]     const _11 = arr_3[i_5] = _9;
// [Main]     const _13 = arr_3[j_7] = tmp_8;
// [Main]     return k(null)
// [Main]   }
// [Main]   function output_14(arr_16, i_18, len_20, k) {
// [Main]     const _21 = 1;
// [Main]     const _22 = len_20 - _21;
// [Main]     if (i_18 <= _22) {
// [Main]       const _23 = arr_16[i_18];
// [Main]       const _25 = minimbt_print_int($force(_23));
// [Main]       const _27 = minimbt_print_endline();
// [Main]       const _28 = 1;
// [Main]       const _29 = i_18 + _28;
// [Main]       return $thunk(() => output_14(arr_16, _29, len_20, k))
// [Main]     } else {
// [Main]       return k(null)
// [Main]     }
// [Main]   }
// [Main]   function insertion_sort_30(arr_32, low_34, high_36, k) {
// [Main]     function g_37(j_39, k) {
// [Main]       const _40 = 1;
// [Main]       const _41 = _40 + low_34;
// [Main]       if (_41 <= j_39) {
// [Main]         const _42 = arr_32[j_39];
// [Main]         const _43 = 1;
// [Main]         const _44 = j_39 - _43;
// [Main]         const _45 = arr_32[_44];
// [Main]         const _46 = 1;
// [Main]         const _47 = _45 - _46;
// [Main]         if (_42 <= _47) {
// [Main]           const _48 = 1;
// [Main]           const _49 = j_39 - _48;
// [Main]           return $thunk(() => swap_1(arr_32, j_39, _49, function (_51) {
// [Main]             const _52 = 1;
// [Main]             const _53 = j_39 - _52;
// [Main]             return $thunk(() => g_37(_53, k))
// [Main]           }
// [Main]           ))
// [Main]         } else {
// [Main]           return k(null)
// [Main]         }
// [Main]       } else {
// [Main]         return k(null)
// [Main]       }
// [Main]     }
// [Main]     function f_54(i_56, k) {
// [Main]       const _57 = 1;
// [Main]       const _58 = high_36 - _57;
// [Main]       if (i_56 <= _58) {
// [Main]         return $thunk(() => g_37(i_56, function (_60) {
// [Main]           const _61 = 1;
// [Main]           const _62 = i_56 + _61;
// [Main]           return $thunk(() => f_54(_62, k))
// [Main]         }
// [Main]         ))
// [Main]       } else {
// [Main]         return k(null)
// [Main]       }
// [Main]     }
// [Main]     const _63 = 1;
// [Main]     const _64 = low_34 + _63;
// [Main]     return $thunk(() => f_54(_64, k))
// [Main]   }
// [Main]   function partition_65(arr_67, pivot_index_69, low_71, high_73, k) {
// [Main]     const _74 = 1;
// [Main]     const _75 = high_73 - _74;
// [Main]     return $thunk(() => swap_1(arr_67, pivot_index_69, _75, function (_77) {
// [Main]       const _78 = 1;
// [Main]       const _79 = high_73 - _78;
// [Main]       const pivot_80 = arr_67[_79];
// [Main]       const _81 = 1;
// [Main]       const i_82 = minimbt_create_array($force(_81), $force(low_71));
// [Main]       const _83 = 1;
// [Main]       const _84 = 1;
// [Main]       const partitioned_85 = minimbt_create_array($force(_83), $force(_84));
// [Main]       function aux_86(j_88, k) {
// [Main]         const _89 = 2;
// [Main]         const _90 = high_73 - _89;
// [Main]         if (j_88 <= _90) {
// [Main]           const _91 = arr_67[j_88];
// [Main]           const _92 = 1;
// [Main]           const _93 = pivot_80 - _92;
// [Main]           const _112 = $force((() => {
// [Main]             if (_91 <= _93) {
// [Main]               const _94 = 0;
// [Main]               const _95 = i_82[_94];
// [Main]               const _103 = $force((() => {
// [Main]                 if (_95 === j_88) {
// [Main]                   return null
// [Main]                 } else {
// [Main]                   const _96 = 0;
// [Main]                   const _97 = i_82[_96];
// [Main]                   return $thunk(() => swap_1(arr_67, _97, j_88, function (_99) {
// [Main]                     const _100 = 0;
// [Main]                     const _101 = 0;
// [Main]                     return $thunk(() => partitioned_85[_100] = _101)
// [Main]                   }
// [Main]                   ))
// [Main]                 }
// [Main]               })());
// [Main]               const _104 = 0;
// [Main]               const _105 = 0;
// [Main]               const _106 = i_82[_105];
// [Main]               const _107 = 1;
// [Main]               const _108 = _106 + _107;
// [Main]               const _110 = i_82[_104] = _108;
// [Main]               return null
// [Main]             } else {
// [Main]               return null
// [Main]             }
// [Main]           })());
// [Main]           const _113 = 1;
// [Main]           const _114 = j_88 + _113;
// [Main]           return $thunk(() => aux_86(_114, k))
// [Main]         } else {
// [Main]           return k(null)
// [Main]         }
// [Main]       }
// [Main]       return $thunk(() => aux_86(low_71, function (_116) {
// [Main]         const _117 = 0;
// [Main]         const _118 = i_82[_117];
// [Main]         const _119 = 1;
// [Main]         const _120 = high_73 - _119;
// [Main]         return $thunk(() => swap_1(arr_67, _118, _120, function (_122) {
// [Main]           const _123 = 0;
// [Main]           const _124 = i_82[_123];
// [Main]           const _125 = 0;
// [Main]           const _126 = partitioned_85[_125];
// [Main]           const _127 = 1;
// [Main]           const _128 = $force((() => {
// [Main]             if (_126 === _127) {
// [Main]               return true
// [Main]             } else {
// [Main]               return false
// [Main]             }
// [Main]           })());
// [Main]           return $thunk(() => $thunk(() => $thunk(() => k([_124, _128]))))
// [Main]         }
// [Main]         ))
// [Main]       }
// [Main]       ))
// [Main]     }
// [Main]     ))
// [Main]   }
// [Main]   function choose_pivot_129(arr_131, low_133, high_135, k) {
// [Main]     const use_median_of_medians_136 = 50;
// [Main]     const _137 = 1;
// [Main]     const _138 = 0;
// [Main]     const swaps_139 = minimbt_create_array($force(_137), $force(_138));
// [Main]     const len_140 = high_135 - low_133;
// [Main]     const _141 = 4;
// [Main]     const _142 = len_140 / _141;
// [Main]     const _143 = 2;
// [Main]     const _144 = _142 * _143;
// [Main]     const b_145 = low_133 + _144;
// [Main]     const _146 = 8;
// [Main]     const _205 = $force((() => {
// [Main]       if (_146 <= len_140) {
// [Main]         const _147 = 4;
// [Main]         const _148 = len_140 / _147;
// [Main]         const _149 = 1;
// [Main]         const _150 = _148 * _149;
// [Main]         const a_151 = low_133 + _150;
// [Main]         const _152 = 4;
// [Main]         const _153 = len_140 / _152;
// [Main]         const _154 = 3;
// [Main]         const _155 = _153 * _154;
// [Main]         const c_156 = low_133 + _155;
// [Main]         function sort_2_157(a_159, b_161, k) {
// [Main]           const _162 = arr_131[b_161];
// [Main]           const _163 = arr_131[a_159];
// [Main]           const _164 = 1;
// [Main]           const _165 = _163 - _164;
// [Main]           if (_162 <= _165) {
// [Main]             return $thunk(() => swap_1(arr_131, a_159, b_161, function (_167) {
// [Main]               const _168 = 0;
// [Main]               const _169 = 0;
// [Main]               const _170 = swaps_139[_169];
// [Main]               const _171 = 1;
// [Main]               const _172 = _170 + _171;
// [Main]               return $thunk(() => k(swaps_139[_168] = _172))
// [Main]             }
// [Main]             ))
// [Main]           } else {
// [Main]             return k(null)
// [Main]           }
// [Main]         }
// [Main]         function sort_3_173(a_175, b_177, c_179, k) {
// [Main]           return $thunk(() => sort_2_157(a_175, b_177, function (_181) {
// [Main]             return $thunk(() => sort_2_157(b_177, c_179, function (_183) {
// [Main]               return $thunk(() => sort_2_157(a_175, b_177, k))
// [Main]             }
// [Main]             ))
// [Main]           }
// [Main]           ))
// [Main]         }
// [Main]         const _184 = 1;
// [Main]         const _185 = len_140 - _184;
// [Main]         const _203 = $force((() => {
// [Main]           if (use_median_of_medians_136 <= _185) {
// [Main]             const _186 = 1;
// [Main]             const _187 = a_151 - _186;
// [Main]             const _188 = 1;
// [Main]             const _189 = a_151 + _188;
// [Main]             return $thunk(() => sort_3_173(_187, a_151, _189, function (_191) {
// [Main]               const _192 = 1;
// [Main]               const _193 = b_145 - _192;
// [Main]               const _194 = 1;
// [Main]               const _195 = b_145 + _194;
// [Main]               return $thunk(() => sort_3_173(_193, b_145, _195, function (_197) {
// [Main]                 const _198 = 1;
// [Main]                 const _199 = c_156 - _198;
// [Main]                 const _200 = 1;
// [Main]                 const _201 = c_156 + _200;
// [Main]                 return $thunk(() => sort_3_173(_199, c_156, _201, k))
// [Main]               }
// [Main]               ))
// [Main]             }
// [Main]             ))
// [Main]           } else {
// [Main]             return null
// [Main]           }
// [Main]         })());
// [Main]         return $thunk(() => sort_3_173(a_151, b_145, c_156, k))
// [Main]       } else {
// [Main]         return null
// [Main]       }
// [Main]     })());
// [Main]     const _206 = 0;
// [Main]     const _207 = swaps_139[_206];
// [Main]     const _208 = 0;
// [Main]     const _209 = $force((() => {
// [Main]       if (_207 === _208) {
// [Main]         return true
// [Main]       } else {
// [Main]         return false
// [Main]       }
// [Main]     })());
// [Main]     return k([b_145, _209])
// [Main]   }
// [Main]   function quick_sort_210(arr_212, low_214, high_216, k) {
// [Main]     const len_217 = high_216 - low_214;
// [Main]     const _218 = 16;
// [Main]     if (len_217 <= _218) {
// [Main]       return $thunk(() => insertion_sort_30(arr_212, low_214, high_216, k))
// [Main]     } else {
// [Main]       return $thunk(() => choose_pivot_129(arr_212, low_214, high_216, function (_219) {
// [Main]         const [pivot_index_221, likely_sorted_223] = _219;return $thunk(() => partition_65(arr_212, pivot_index_221, low_214, high_216, function (_224) {
// [Main]           const [pivot_226, partitioned_228] = _224;return $thunk(() => quick_sort_210(arr_212, low_214, pivot_226, function (_230) {
// [Main]             const _231 = 1;
// [Main]             const _232 = pivot_226 + _231;
// [Main]             return $thunk(() => quick_sort_210(arr_212, _232, high_216, k))
// [Main]           }
// [Main]           ))
// [Main]         }
// [Main]         ))
// [Main]       }
// [Main]       ))
// [Main]     }
// [Main]   }
// [Main]   function sort_233(x_235, len_237, k) {
// [Main]     const _238 = 0;
// [Main]     return $thunk(() => quick_sort_210(x_235, _238, len_237, k))
// [Main]   }
// [Main]   function main_239(k) {
// [Main]     const len_240 = minimbt_read_int();
// [Main]     const _241 = 0;
// [Main]     const arr_242 = minimbt_create_array($force(len_240), $force(_241));
// [Main]     function input_243(i_245, k) {
// [Main]       const _246 = 1;
// [Main]       const _247 = len_240 - _246;
// [Main]       if (i_245 <= _247) {
// [Main]         const _248 = minimbt_read_int();
// [Main]         const _250 = arr_242[i_245] = _248;
// [Main]         const _251 = 1;
// [Main]         const _252 = i_245 + _251;
// [Main]         return $thunk(() => input_243(_252, k))
// [Main]       } else {
// [Main]         return k(null)
// [Main]       }
// [Main]     }
// [Main]     const _253 = 0;
// [Main]     return $thunk(() => input_243(_253, function (_255) {
// [Main]       return $thunk(() => sort_233(arr_242, len_240, function (_257) {
// [Main]         const _258 = 0;
// [Main]         return $thunk(() => output_14(arr_242, _258, len_240, k))
// [Main]       }
// [Main]       ))
// [Main]     }
// [Main]     ))
// [Main]   }
// [Main]   return $thunk(() => main_239(k))
// [Main] }
// [Main] 
// [Main] function $thunk(lambda) {
// [Main]   return { thunk: lambda };
// [Main] }
// [Main] function $is_thunk(x) {
// [Main]   return x && x.hasOwnProperty('thunk') && x.thunk !== undefined;
// [Main] }
// [Main] function $force(x) {
// [Main]   while ($is_thunk(x)) {
// [Main]     x = x.thunk();
// [Main]   }
// [Main]   return x;
// [Main] }
// [Main] function $trampoline(f, ...args) {
// [Main]   let x = f(...args);
// [Main]   return $force(x);
// [Main] }
// [Main] export default () => $trampoline(thunk_main, x => x);
// [Typer] check: LetRec({tyvars: [], name: ("swap", Unit), args: [("arr", Array(Int)), ("i", Int), ("j", Int)], body: Let(("tmp", Var({val: None})), Get(Var("arr"), Var("i")), Let(("_", Var({val: None})), Put(Var("arr"), Var("i"), Get(Var("arr"), Var("j"))), Let(("_", Var({val: None})), Put(Var("arr"), Var("j"), Var("tmp")), Unit)))}, LetRec({tyvars: [], name: ("output", Unit), args: [("arr", Array(Int)), ("i", Int), ("len", Int)], body: If(LE(Var("i"), Prim(Var("len"), Int(1), Sub, kind=None)), Let(("_", Var({val: None})), App(Var("print_int"), [Get(Var("arr"), Var("i"))]), Let(("_", Var({val: None})), App(Var("print_endline"), []), App(Var("output"), [Var("arr"), Prim(Var("i"), Int(1), Add, kind=None), Var("len")]))), Unit)}, LetRec({tyvars: [], name: ("insertion_sort", Unit), args: [("arr", Array(Int)), ("low", Int), ("high", Int)], body: LetRec({tyvars: [], name: ("g", Unit), args: [("j", Int)], body: If(LE(Prim(Int(1), Var("low"), Add, kind=None), Var("j")), If(LE(Get(Var("arr"), Var("j")), Prim(Get(Var("arr"), Prim(Var("j"), Int(1), Sub, kind=None)), Int(1), Sub, kind=None)), Let(("_", Var({val: None})), App(Var("swap"), [Var("arr"), Var("j"), Prim(Var("j"), Int(1), Sub, kind=None)]), App(Var("g"), [Prim(Var("j"), Int(1), Sub, kind=None)])), Unit), Unit)}, LetRec({tyvars: [], name: ("f", Unit), args: [("i", Int)], body: If(LE(Var("i"), Prim(Var("high"), Int(1), Sub, kind=None)), Let(("j", Var({val: None})), Var("i"), Let(("_", Var({val: None})), App(Var("g"), [Var("j")]), App(Var("f"), [Prim(Var("i"), Int(1), Add, kind=None)]))), Unit)}, App(Var("f"), [Prim(Var("low"), Int(1), Add, kind=None)])))}, LetRec({tyvars: [], name: ("partition", Tuple([Int, Bool])), args: [("arr", Array(Int)), ("pivot_index", Int), ("low", Int), ("high", Int)], body: Let(("_", Var({val: None})), App(Var("swap"), [Var("arr"), Var("pivot_index"), Prim(Var("high"), Int(1), Sub, kind=None)]), Let(("pivot", Var({val: None})), Get(Var("arr"), Prim(Var("high"), Int(1), Sub, kind=None)), Let(("i", Var({val: None})), Array(Int(1), Var("low")), Let(("partitioned", Var({val: None})), Array(Int(1), Int(1)), LetRec({tyvars: [], name: ("aux", Var({val: None})), args: [("j", Int)], body: If(LE(Var("j"), Prim(Var("high"), Int(2), Sub, kind=None)), Let(("_", Var({val: None})), If(LE(Get(Var("arr"), Var("j")), Prim(Var("pivot"), Int(1), Sub, kind=None)), Let(("_", Var({val: None})), If(Eq(Get(Var("i"), Int(0)), Var("j")), Unit, Let(("_", Var({val: None})), App(Var("swap"), [Var("arr"), Get(Var("i"), Int(0)), Var("j")]), Put(Var("partitioned"), Int(0), Int(0)))), Let(("_", Var({val: None})), Put(Var("i"), Int(0), Prim(Get(Var("i"), Int(0)), Int(1), Add, kind=None)), Unit)), Unit), App(Var("aux"), [Prim(Var("j"), Int(1), Add, kind=None)])), Unit)}, Let(("_", Var({val: None})), App(Var("aux"), [Var("low")]), Let(("_", Var({val: None})), App(Var("swap"), [Var("arr"), Get(Var("i"), Int(0)), Prim(Var("high"), Int(1), Sub, kind=None)]), Tuple([Get(Var("i"), Int(0)), Eq(Get(Var("partitioned"), Int(0)), Int(1))]))))))))}, LetRec({tyvars: [], name: ("choose_pivot", Tuple([Int, Bool])), args: [("arr", Array(Int)), ("low", Int), ("high", Int)], body: Let(("use_median_of_medians", Var({val: None})), Int(50), Let(("swaps", Var({val: None})), Array(Int(1), Int(0)), Let(("len", Var({val: None})), Prim(Var("high"), Var("low"), Sub, kind=None), Let(("b", Var({val: None})), Prim(Var("low"), Prim(Prim(Var("len"), Int(4), Div, kind=None), Int(2), Mul, kind=None), Add, kind=None), Let(("_", Var({val: None})), If(LE(Int(8), Var("len")), Let(("a", Var({val: None})), Prim(Var("low"), Prim(Prim(Var("len"), Int(4), Div, kind=None), Int(1), Mul, kind=None), Add, kind=None), Let(("c", Var({val: None})), Prim(Var("low"), Prim(Prim(Var("len"), Int(4), Div, kind=None), Int(3), Mul, kind=None), Add, kind=None), LetRec({tyvars: [], name: ("sort_2", Var({val: None})), args: [("a", Int), ("b", Int)], body: If(LE(Get(Var("arr"), Var("b")), Prim(Get(Var("arr"), Var("a")), Int(1), Sub, kind=None)), Let(("_", Var({val: None})), App(Var("swap"), [Var("arr"), Var("a"), Var("b")]), Put(Var("swaps"), Int(0), Prim(Get(Var("swaps"), Int(0)), Int(1), Add, kind=None))), Unit)}, LetRec({tyvars: [], name: ("sort_3", Var({val: None})), args: [("a", Int), ("b", Int), ("c", Int)], body: Let(("_", Var({val: None})), App(Var("sort_2"), [Var("a"), Var("b")]), Let(("_", Var({val: None})), App(Var("sort_2"), [Var("b"), Var("c")]), App(Var("sort_2"), [Var("a"), Var("b")])))}, Let(("_", Var({val: None})), If(LE(Var("use_median_of_medians"), Prim(Var("len"), Int(1), Sub, kind=None)), Let(("_", Var({val: None})), App(Var("sort_3"), [Prim(Var("a"), Int(1), Sub, kind=None), Var("a"), Prim(Var("a"), Int(1), Add, kind=None)]), Let(("_", Var({val: None})), App(Var("sort_3"), [Prim(Var("b"), Int(1), Sub, kind=None), Var("b"), Prim(Var("b"), Int(1), Add, kind=None)]), App(Var("sort_3"), [Prim(Var("c"), Int(1), Sub, kind=None), Var("c"), Prim(Var("c"), Int(1), Add, kind=None)]))), Unit), App(Var("sort_3"), [Var("a"), Var("b"), Var("c")])))))), Unit), Tuple([Var("b"), Eq(Get(Var("swaps"), Int(0)), Int(0))]))))))}, LetRec({tyvars: [], name: ("quick_sort", Unit), args: [("arr", Array(Int)), ("low", Int), ("high", Int)], body: Let(("len", Var({val: None})), Prim(Var("high"), Var("low"), Sub, kind=None), If(LE(Var("len"), Int(16)), App(Var("insertion_sort"), [Var("arr"), Var("low"), Var("high")]), LetTuple([("pivot_index", Var({val: None})), ("likely_sorted", Var({val: None}))], App(Var("choose_pivot"), [Var("arr"), Var("low"), Var("high")]), LetTuple([("pivot", Var({val: None})), ("partitioned", Var({val: None}))], App(Var("partition"), [Var("arr"), Var("pivot_index"), Var("low"), Var("high")]), Let(("_", Var({val: None})), App(Var("quick_sort"), [Var("arr"), Var("low"), Var("pivot")]), App(Var("quick_sort"), [Var("arr"), Prim(Var("pivot"), Int(1), Add, kind=None), Var("high")]))))))}, LetRec({tyvars: [], name: ("sort", Unit), args: [("x", Array(Int)), ("len", Int)], body: App(Var("quick_sort"), [Var("x"), Int(0), Var("len")])}, LetRec({tyvars: [], name: ("main", Var({val: None})), args: [], body: Let(("len", Var({val: None})), App(Var("read_int"), []), Let(("arr", Var({val: None})), Array(Var("len"), Int(0)), LetRec({tyvars: [], name: ("input", Var({val: None})), args: [("i", Int)], body: If(LE(Var("i"), Prim(Var("len"), Int(1), Sub, kind=None)), Let(("_", Var({val: None})), Put(Var("arr"), Var("i"), App(Var("read_int"), [])), App(Var("input"), [Prim(Var("i"), Int(1), Add, kind=None)])), Unit)}, Let(("_", Var({val: None})), App(Var("input"), [Int(0)]), Let(("_", Var({val: None})), App(Var("sort"), [Var("arr"), Var("len")]), App(Var("output"), [Var("arr"), Int(0), Var("len")]))))))}, Unit)))))))) against Unit
// [Typer] typevars: []
// [Typer] check: Let(("tmp", Var({val: None})), Get(Var("arr"), Var("i")), Let(("_", Var({val: None})), Put(Var("arr"), Var("i"), Get(Var("arr"), Var("j"))), Let(("_", Var({val: None})), Put(Var("arr"), Var("j"), Var("tmp")), Unit))) against Unit
// [Typer] infer: Get(Var("arr"), Var("i"))
// [Typer] infer: Var("arr")
// [Typer] inst: TypeScheme(([], Array(Int)))
// [Typer] inst result: Array(Int)
// [Typer] check: Var("i") against Int
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] unify: Var({val: None}) and Int
// [Typer] union: Var({val: None}) and Int
// [Typer] check: Let(("_", Var({val: None})), Put(Var("arr"), Var("i"), Get(Var("arr"), Var("j"))), Let(("_", Var({val: None})), Put(Var("arr"), Var("j"), Var("tmp")), Unit)) against Unit
// [Typer] infer: Put(Var("arr"), Var("i"), Get(Var("arr"), Var("j")))
// [Typer] infer: Get(Var("arr"), Var("j"))
// [Typer] infer: Var("arr")
// [Typer] inst: TypeScheme(([], Array(Int)))
// [Typer] inst result: Array(Int)
// [Typer] check: Var("j") against Int
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] check: Var("arr") against Array(Int)
// [Typer] inst: TypeScheme(([], Array(Int)))
// [Typer] inst result: Array(Int)
// [Typer] unify: Array(Int) and Array(Int)
// [Typer] unify: Int and Int
// [Typer] check: Var("i") against Int
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] unify: Var({val: None}) and Unit
// [Typer] union: Var({val: None}) and Unit
// [Typer] check: Let(("_", Var({val: None})), Put(Var("arr"), Var("j"), Var("tmp")), Unit) against Unit
// [Typer] infer: Put(Var("arr"), Var("j"), Var("tmp"))
// [Typer] infer: Var("tmp")
// [Typer] inst: TypeScheme(([], Var({val: Some(Int)})))
// [Typer] inst result: Int
// [Typer] check: Var("arr") against Array(Int)
// [Typer] inst: TypeScheme(([], Array(Int)))
// [Typer] inst result: Array(Int)
// [Typer] unify: Array(Int) and Array(Int)
// [Typer] unify: Int and Int
// [Typer] check: Var("j") against Int
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] unify: Var({val: None}) and Unit
// [Typer] union: Var({val: None}) and Unit
// [Typer] check: Unit against Unit
// [Typer] check: LetRec({tyvars: [], name: ("output", Unit), args: [("arr", Array(Int)), ("i", Int), ("len", Int)], body: If(LE(Var("i"), Prim(Var("len"), Int(1), Sub, kind=None)), Let(("_", Var({val: None})), App(Var("print_int"), [Get(Var("arr"), Var("i"))]), Let(("_", Var({val: None})), App(Var("print_endline"), []), App(Var("output"), [Var("arr"), Prim(Var("i"), Int(1), Add, kind=None), Var("len")]))), Unit)}, LetRec({tyvars: [], name: ("insertion_sort", Unit), args: [("arr", Array(Int)), ("low", Int), ("high", Int)], body: LetRec({tyvars: [], name: ("g", Unit), args: [("j", Int)], body: If(LE(Prim(Int(1), Var("low"), Add, kind=None), Var("j")), If(LE(Get(Var("arr"), Var("j")), Prim(Get(Var("arr"), Prim(Var("j"), Int(1), Sub, kind=None)), Int(1), Sub, kind=None)), Let(("_", Var({val: None})), App(Var("swap"), [Var("arr"), Var("j"), Prim(Var("j"), Int(1), Sub, kind=None)]), App(Var("g"), [Prim(Var("j"), Int(1), Sub, kind=None)])), Unit), Unit)}, LetRec({tyvars: [], name: ("f", Unit), args: [("i", Int)], body: If(LE(Var("i"), Prim(Var("high"), Int(1), Sub, kind=None)), Let(("j", Var({val: None})), Var("i"), Let(("_", Var({val: None})), App(Var("g"), [Var("j")]), App(Var("f"), [Prim(Var("i"), Int(1), Add, kind=None)]))), Unit)}, App(Var("f"), [Prim(Var("low"), Int(1), Add, kind=None)])))}, LetRec({tyvars: [], name: ("partition", Tuple([Int, Bool])), args: [("arr", Array(Int)), ("pivot_index", Int), ("low", Int), ("high", Int)], body: Let(("_", Var({val: None})), App(Var("swap"), [Var("arr"), Var("pivot_index"), Prim(Var("high"), Int(1), Sub, kind=None)]), Let(("pivot", Var({val: None})), Get(Var("arr"), Prim(Var("high"), Int(1), Sub, kind=None)), Let(("i", Var({val: None})), Array(Int(1), Var("low")), Let(("partitioned", Var({val: None})), Array(Int(1), Int(1)), LetRec({tyvars: [], name: ("aux", Var({val: None})), args: [("j", Int)], body: If(LE(Var("j"), Prim(Var("high"), Int(2), Sub, kind=None)), Let(("_", Var({val: None})), If(LE(Get(Var("arr"), Var("j")), Prim(Var("pivot"), Int(1), Sub, kind=None)), Let(("_", Var({val: None})), If(Eq(Get(Var("i"), Int(0)), Var("j")), Unit, Let(("_", Var({val: None})), App(Var("swap"), [Var("arr"), Get(Var("i"), Int(0)), Var("j")]), Put(Var("partitioned"), Int(0), Int(0)))), Let(("_", Var({val: None})), Put(Var("i"), Int(0), Prim(Get(Var("i"), Int(0)), Int(1), Add, kind=None)), Unit)), Unit), App(Var("aux"), [Prim(Var("j"), Int(1), Add, kind=None)])), Unit)}, Let(("_", Var({val: None})), App(Var("aux"), [Var("low")]), Let(("_", Var({val: None})), App(Var("swap"), [Var("arr"), Get(Var("i"), Int(0)), Prim(Var("high"), Int(1), Sub, kind=None)]), Tuple([Get(Var("i"), Int(0)), Eq(Get(Var("partitioned"), Int(0)), Int(1))]))))))))}, LetRec({tyvars: [], name: ("choose_pivot", Tuple([Int, Bool])), args: [("arr", Array(Int)), ("low", Int), ("high", Int)], body: Let(("use_median_of_medians", Var({val: None})), Int(50), Let(("swaps", Var({val: None})), Array(Int(1), Int(0)), Let(("len", Var({val: None})), Prim(Var("high"), Var("low"), Sub, kind=None), Let(("b", Var({val: None})), Prim(Var("low"), Prim(Prim(Var("len"), Int(4), Div, kind=None), Int(2), Mul, kind=None), Add, kind=None), Let(("_", Var({val: None})), If(LE(Int(8), Var("len")), Let(("a", Var({val: None})), Prim(Var("low"), Prim(Prim(Var("len"), Int(4), Div, kind=None), Int(1), Mul, kind=None), Add, kind=None), Let(("c", Var({val: None})), Prim(Var("low"), Prim(Prim(Var("len"), Int(4), Div, kind=None), Int(3), Mul, kind=None), Add, kind=None), LetRec({tyvars: [], name: ("sort_2", Var({val: None})), args: [("a", Int), ("b", Int)], body: If(LE(Get(Var("arr"), Var("b")), Prim(Get(Var("arr"), Var("a")), Int(1), Sub, kind=None)), Let(("_", Var({val: None})), App(Var("swap"), [Var("arr"), Var("a"), Var("b")]), Put(Var("swaps"), Int(0), Prim(Get(Var("swaps"), Int(0)), Int(1), Add, kind=None))), Unit)}, LetRec({tyvars: [], name: ("sort_3", Var({val: None})), args: [("a", Int), ("b", Int), ("c", Int)], body: Let(("_", Var({val: None})), App(Var("sort_2"), [Var("a"), Var("b")]), Let(("_", Var({val: None})), App(Var("sort_2"), [Var("b"), Var("c")]), App(Var("sort_2"), [Var("a"), Var("b")])))}, Let(("_", Var({val: None})), If(LE(Var("use_median_of_medians"), Prim(Var("len"), Int(1), Sub, kind=None)), Let(("_", Var({val: None})), App(Var("sort_3"), [Prim(Var("a"), Int(1), Sub, kind=None), Var("a"), Prim(Var("a"), Int(1), Add, kind=None)]), Let(("_", Var({val: None})), App(Var("sort_3"), [Prim(Var("b"), Int(1), Sub, kind=None), Var("b"), Prim(Var("b"), Int(1), Add, kind=None)]), App(Var("sort_3"), [Prim(Var("c"), Int(1), Sub, kind=None), Var("c"), Prim(Var("c"), Int(1), Add, kind=None)]))), Unit), App(Var("sort_3"), [Var("a"), Var("b"), Var("c")])))))), Unit), Tuple([Var("b"), Eq(Get(Var("swaps"), Int(0)), Int(0))]))))))}, LetRec({tyvars: [], name: ("quick_sort", Unit), args: [("arr", Array(Int)), ("low", Int), ("high", Int)], body: Let(("len", Var({val: None})), Prim(Var("high"), Var("low"), Sub, kind=None), If(LE(Var("len"), Int(16)), App(Var("insertion_sort"), [Var("arr"), Var("low"), Var("high")]), LetTuple([("pivot_index", Var({val: None})), ("likely_sorted", Var({val: None}))], App(Var("choose_pivot"), [Var("arr"), Var("low"), Var("high")]), LetTuple([("pivot", Var({val: None})), ("partitioned", Var({val: None}))], App(Var("partition"), [Var("arr"), Var("pivot_index"), Var("low"), Var("high")]), Let(("_", Var({val: None})), App(Var("quick_sort"), [Var("arr"), Var("low"), Var("pivot")]), App(Var("quick_sort"), [Var("arr"), Prim(Var("pivot"), Int(1), Add, kind=None), Var("high")]))))))}, LetRec({tyvars: [], name: ("sort", Unit), args: [("x", Array(Int)), ("len", Int)], body: App(Var("quick_sort"), [Var("x"), Int(0), Var("len")])}, LetRec({tyvars: [], name: ("main", Var({val: None})), args: [], body: Let(("len", Var({val: None})), App(Var("read_int"), []), Let(("arr", Var({val: None})), Array(Var("len"), Int(0)), LetRec({tyvars: [], name: ("input", Var({val: None})), args: [("i", Int)], body: If(LE(Var("i"), Prim(Var("len"), Int(1), Sub, kind=None)), Let(("_", Var({val: None})), Put(Var("arr"), Var("i"), App(Var("read_int"), [])), App(Var("input"), [Prim(Var("i"), Int(1), Add, kind=None)])), Unit)}, Let(("_", Var({val: None})), App(Var("input"), [Int(0)]), Let(("_", Var({val: None})), App(Var("sort"), [Var("arr"), Var("len")]), App(Var("output"), [Var("arr"), Int(0), Var("len")]))))))}, Unit))))))) against Unit
// [Typer] typevars: []
// [Typer] check: If(LE(Var("i"), Prim(Var("len"), Int(1), Sub, kind=None)), Let(("_", Var({val: None})), App(Var("print_int"), [Get(Var("arr"), Var("i"))]), Let(("_", Var({val: None})), App(Var("print_endline"), []), App(Var("output"), [Var("arr"), Prim(Var("i"), Int(1), Add, kind=None), Var("len")]))), Unit) against Unit
// [Typer] check: LE(Var("i"), Prim(Var("len"), Int(1), Sub, kind=None)) against Bool
// [Typer] infer: Var("i")
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] infer: Prim(Var("len"), Int(1), Sub, kind=None)
// [Typer] infer: Var("len")
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] infer: Int(1)
// [Typer] unify: Int and Int
// [Typer] unify: Int and Int
// [Typer] check: Let(("_", Var({val: None})), App(Var("print_int"), [Get(Var("arr"), Var("i"))]), Let(("_", Var({val: None})), App(Var("print_endline"), []), App(Var("output"), [Var("arr"), Prim(Var("i"), Int(1), Add, kind=None), Var("len")]))) against Unit
// [Typer] infer: App(Var("print_int"), [Get(Var("arr"), Var("i"))])
// [Typer] infer: Var("print_int")
// [Typer] inst: TypeScheme(([], Fun([Int], Unit)))
// [Typer] inst result: Fun([Int], Unit)
// [Typer] check: Get(Var("arr"), Var("i")) against Int
// [Typer] check: Var("arr") against Array(Int)
// [Typer] inst: TypeScheme(([], Array(Int)))
// [Typer] inst result: Array(Int)
// [Typer] unify: Array(Int) and Array(Int)
// [Typer] unify: Int and Int
// [Typer] check: Var("i") against Int
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] unify: Var({val: None}) and Unit
// [Typer] union: Var({val: None}) and Unit
// [Typer] check: Let(("_", Var({val: None})), App(Var("print_endline"), []), App(Var("output"), [Var("arr"), Prim(Var("i"), Int(1), Add, kind=None), Var("len")])) against Unit
// [Typer] infer: App(Var("print_endline"), [])
// [Typer] infer: Var("print_endline")
// [Typer] inst: TypeScheme(([], Fun([], Unit)))
// [Typer] inst result: Fun([], Unit)
// [Typer] unify: Var({val: None}) and Unit
// [Typer] union: Var({val: None}) and Unit
// [Typer] check: App(Var("output"), [Var("arr"), Prim(Var("i"), Int(1), Add, kind=None), Var("len")]) against Unit
// [Typer] infer: Var("arr")
// [Typer] inst: TypeScheme(([], Array(Int)))
// [Typer] inst result: Array(Int)
// [Typer] infer: Prim(Var("i"), Int(1), Add, kind=None)
// [Typer] infer: Var("i")
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] infer: Int(1)
// [Typer] unify: Int and Int
// [Typer] infer: Var("len")
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] check: Var("output") against Fun([Array(Int), Int, Int], Unit)
// [Typer] inst: TypeScheme(([], Fun([Array(Int), Int, Int], Unit)))
// [Typer] inst result: Fun([Array(Int), Int, Int], Unit)
// [Typer] unify: Fun([Array(Int), Int, Int], Unit) and Fun([Array(Int), Int, Int], Unit)
// [Typer] unify: Array(Int) and Array(Int)
// [Typer] unify: Int and Int
// [Typer] unify: Int and Int
// [Typer] unify: Int and Int
// [Typer] unify: Unit and Unit
// [Typer] check: Unit against Unit
// [Typer] check: LetRec({tyvars: [], name: ("insertion_sort", Unit), args: [("arr", Array(Int)), ("low", Int), ("high", Int)], body: LetRec({tyvars: [], name: ("g", Unit), args: [("j", Int)], body: If(LE(Prim(Int(1), Var("low"), Add, kind=None), Var("j")), If(LE(Get(Var("arr"), Var("j")), Prim(Get(Var("arr"), Prim(Var("j"), Int(1), Sub, kind=None)), Int(1), Sub, kind=None)), Let(("_", Var({val: None})), App(Var("swap"), [Var("arr"), Var("j"), Prim(Var("j"), Int(1), Sub, kind=None)]), App(Var("g"), [Prim(Var("j"), Int(1), Sub, kind=None)])), Unit), Unit)}, LetRec({tyvars: [], name: ("f", Unit), args: [("i", Int)], body: If(LE(Var("i"), Prim(Var("high"), Int(1), Sub, kind=None)), Let(("j", Var({val: None})), Var("i"), Let(("_", Var({val: None})), App(Var("g"), [Var("j")]), App(Var("f"), [Prim(Var("i"), Int(1), Add, kind=None)]))), Unit)}, App(Var("f"), [Prim(Var("low"), Int(1), Add, kind=None)])))}, LetRec({tyvars: [], name: ("partition", Tuple([Int, Bool])), args: [("arr", Array(Int)), ("pivot_index", Int), ("low", Int), ("high", Int)], body: Let(("_", Var({val: None})), App(Var("swap"), [Var("arr"), Var("pivot_index"), Prim(Var("high"), Int(1), Sub, kind=None)]), Let(("pivot", Var({val: None})), Get(Var("arr"), Prim(Var("high"), Int(1), Sub, kind=None)), Let(("i", Var({val: None})), Array(Int(1), Var("low")), Let(("partitioned", Var({val: None})), Array(Int(1), Int(1)), LetRec({tyvars: [], name: ("aux", Var({val: None})), args: [("j", Int)], body: If(LE(Var("j"), Prim(Var("high"), Int(2), Sub, kind=None)), Let(("_", Var({val: None})), If(LE(Get(Var("arr"), Var("j")), Prim(Var("pivot"), Int(1), Sub, kind=None)), Let(("_", Var({val: None})), If(Eq(Get(Var("i"), Int(0)), Var("j")), Unit, Let(("_", Var({val: None})), App(Var("swap"), [Var("arr"), Get(Var("i"), Int(0)), Var("j")]), Put(Var("partitioned"), Int(0), Int(0)))), Let(("_", Var({val: None})), Put(Var("i"), Int(0), Prim(Get(Var("i"), Int(0)), Int(1), Add, kind=None)), Unit)), Unit), App(Var("aux"), [Prim(Var("j"), Int(1), Add, kind=None)])), Unit)}, Let(("_", Var({val: None})), App(Var("aux"), [Var("low")]), Let(("_", Var({val: None})), App(Var("swap"), [Var("arr"), Get(Var("i"), Int(0)), Prim(Var("high"), Int(1), Sub, kind=None)]), Tuple([Get(Var("i"), Int(0)), Eq(Get(Var("partitioned"), Int(0)), Int(1))]))))))))}, LetRec({tyvars: [], name: ("choose_pivot", Tuple([Int, Bool])), args: [("arr", Array(Int)), ("low", Int), ("high", Int)], body: Let(("use_median_of_medians", Var({val: None})), Int(50), Let(("swaps", Var({val: None})), Array(Int(1), Int(0)), Let(("len", Var({val: None})), Prim(Var("high"), Var("low"), Sub, kind=None), Let(("b", Var({val: None})), Prim(Var("low"), Prim(Prim(Var("len"), Int(4), Div, kind=None), Int(2), Mul, kind=None), Add, kind=None), Let(("_", Var({val: None})), If(LE(Int(8), Var("len")), Let(("a", Var({val: None})), Prim(Var("low"), Prim(Prim(Var("len"), Int(4), Div, kind=None), Int(1), Mul, kind=None), Add, kind=None), Let(("c", Var({val: None})), Prim(Var("low"), Prim(Prim(Var("len"), Int(4), Div, kind=None), Int(3), Mul, kind=None), Add, kind=None), LetRec({tyvars: [], name: ("sort_2", Var({val: None})), args: [("a", Int), ("b", Int)], body: If(LE(Get(Var("arr"), Var("b")), Prim(Get(Var("arr"), Var("a")), Int(1), Sub, kind=None)), Let(("_", Var({val: None})), App(Var("swap"), [Var("arr"), Var("a"), Var("b")]), Put(Var("swaps"), Int(0), Prim(Get(Var("swaps"), Int(0)), Int(1), Add, kind=None))), Unit)}, LetRec({tyvars: [], name: ("sort_3", Var({val: None})), args: [("a", Int), ("b", Int), ("c", Int)], body: Let(("_", Var({val: None})), App(Var("sort_2"), [Var("a"), Var("b")]), Let(("_", Var({val: None})), App(Var("sort_2"), [Var("b"), Var("c")]), App(Var("sort_2"), [Var("a"), Var("b")])))}, Let(("_", Var({val: None})), If(LE(Var("use_median_of_medians"), Prim(Var("len"), Int(1), Sub, kind=None)), Let(("_", Var({val: None})), App(Var("sort_3"), [Prim(Var("a"), Int(1), Sub, kind=None), Var("a"), Prim(Var("a"), Int(1), Add, kind=None)]), Let(("_", Var({val: None})), App(Var("sort_3"), [Prim(Var("b"), Int(1), Sub, kind=None), Var("b"), Prim(Var("b"), Int(1), Add, kind=None)]), App(Var("sort_3"), [Prim(Var("c"), Int(1), Sub, kind=None), Var("c"), Prim(Var("c"), Int(1), Add, kind=None)]))), Unit), App(Var("sort_3"), [Var("a"), Var("b"), Var("c")])))))), Unit), Tuple([Var("b"), Eq(Get(Var("swaps"), Int(0)), Int(0))]))))))}, LetRec({tyvars: [], name: ("quick_sort", Unit), args: [("arr", Array(Int)), ("low", Int), ("high", Int)], body: Let(("len", Var({val: None})), Prim(Var("high"), Var("low"), Sub, kind=None), If(LE(Var("len"), Int(16)), App(Var("insertion_sort"), [Var("arr"), Var("low"), Var("high")]), LetTuple([("pivot_index", Var({val: None})), ("likely_sorted", Var({val: None}))], App(Var("choose_pivot"), [Var("arr"), Var("low"), Var("high")]), LetTuple([("pivot", Var({val: None})), ("partitioned", Var({val: None}))], App(Var("partition"), [Var("arr"), Var("pivot_index"), Var("low"), Var("high")]), Let(("_", Var({val: None})), App(Var("quick_sort"), [Var("arr"), Var("low"), Var("pivot")]), App(Var("quick_sort"), [Var("arr"), Prim(Var("pivot"), Int(1), Add, kind=None), Var("high")]))))))}, LetRec({tyvars: [], name: ("sort", Unit), args: [("x", Array(Int)), ("len", Int)], body: App(Var("quick_sort"), [Var("x"), Int(0), Var("len")])}, LetRec({tyvars: [], name: ("main", Var({val: None})), args: [], body: Let(("len", Var({val: None})), App(Var("read_int"), []), Let(("arr", Var({val: None})), Array(Var("len"), Int(0)), LetRec({tyvars: [], name: ("input", Var({val: None})), args: [("i", Int)], body: If(LE(Var("i"), Prim(Var("len"), Int(1), Sub, kind=None)), Let(("_", Var({val: None})), Put(Var("arr"), Var("i"), App(Var("read_int"), [])), App(Var("input"), [Prim(Var("i"), Int(1), Add, kind=None)])), Unit)}, Let(("_", Var({val: None})), App(Var("input"), [Int(0)]), Let(("_", Var({val: None})), App(Var("sort"), [Var("arr"), Var("len")]), App(Var("output"), [Var("arr"), Int(0), Var("len")]))))))}, Unit)))))) against Unit
// [Typer] typevars: []
// [Typer] check: LetRec({tyvars: [], name: ("g", Unit), args: [("j", Int)], body: If(LE(Prim(Int(1), Var("low"), Add, kind=None), Var("j")), If(LE(Get(Var("arr"), Var("j")), Prim(Get(Var("arr"), Prim(Var("j"), Int(1), Sub, kind=None)), Int(1), Sub, kind=None)), Let(("_", Var({val: None})), App(Var("swap"), [Var("arr"), Var("j"), Prim(Var("j"), Int(1), Sub, kind=None)]), App(Var("g"), [Prim(Var("j"), Int(1), Sub, kind=None)])), Unit), Unit)}, LetRec({tyvars: [], name: ("f", Unit), args: [("i", Int)], body: If(LE(Var("i"), Prim(Var("high"), Int(1), Sub, kind=None)), Let(("j", Var({val: None})), Var("i"), Let(("_", Var({val: None})), App(Var("g"), [Var("j")]), App(Var("f"), [Prim(Var("i"), Int(1), Add, kind=None)]))), Unit)}, App(Var("f"), [Prim(Var("low"), Int(1), Add, kind=None)]))) against Unit
// [Typer] typevars: []
// [Typer] check: If(LE(Prim(Int(1), Var("low"), Add, kind=None), Var("j")), If(LE(Get(Var("arr"), Var("j")), Prim(Get(Var("arr"), Prim(Var("j"), Int(1), Sub, kind=None)), Int(1), Sub, kind=None)), Let(("_", Var({val: None})), App(Var("swap"), [Var("arr"), Var("j"), Prim(Var("j"), Int(1), Sub, kind=None)]), App(Var("g"), [Prim(Var("j"), Int(1), Sub, kind=None)])), Unit), Unit) against Unit
// [Typer] check: LE(Prim(Int(1), Var("low"), Add, kind=None), Var("j")) against Bool
// [Typer] infer: Prim(Int(1), Var("low"), Add, kind=None)
// [Typer] infer: Int(1)
// [Typer] infer: Var("low")
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] infer: Var("j")
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] check: If(LE(Get(Var("arr"), Var("j")), Prim(Get(Var("arr"), Prim(Var("j"), Int(1), Sub, kind=None)), Int(1), Sub, kind=None)), Let(("_", Var({val: None})), App(Var("swap"), [Var("arr"), Var("j"), Prim(Var("j"), Int(1), Sub, kind=None)]), App(Var("g"), [Prim(Var("j"), Int(1), Sub, kind=None)])), Unit) against Unit
// [Typer] check: LE(Get(Var("arr"), Var("j")), Prim(Get(Var("arr"), Prim(Var("j"), Int(1), Sub, kind=None)), Int(1), Sub, kind=None)) against Bool
// [Typer] infer: Get(Var("arr"), Var("j"))
// [Typer] infer: Var("arr")
// [Typer] inst: TypeScheme(([], Array(Int)))
// [Typer] inst result: Array(Int)
// [Typer] check: Var("j") against Int
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] infer: Prim(Get(Var("arr"), Prim(Var("j"), Int(1), Sub, kind=None)), Int(1), Sub, kind=None)
// [Typer] infer: Get(Var("arr"), Prim(Var("j"), Int(1), Sub, kind=None))
// [Typer] infer: Var("arr")
// [Typer] inst: TypeScheme(([], Array(Int)))
// [Typer] inst result: Array(Int)
// [Typer] check: Prim(Var("j"), Int(1), Sub, kind=None) against Int
// [Typer] check: Var("j") against Int
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] check: Int(1) against Int
// [Typer] infer: Int(1)
// [Typer] unify: Int and Int
// [Typer] unify: Int and Int
// [Typer] check: Let(("_", Var({val: None})), App(Var("swap"), [Var("arr"), Var("j"), Prim(Var("j"), Int(1), Sub, kind=None)]), App(Var("g"), [Prim(Var("j"), Int(1), Sub, kind=None)])) against Unit
// [Typer] infer: App(Var("swap"), [Var("arr"), Var("j"), Prim(Var("j"), Int(1), Sub, kind=None)])
// [Typer] infer: Var("swap")
// [Typer] inst: TypeScheme(([], Fun([Array(Int), Int, Int], Unit)))
// [Typer] inst result: Fun([Array(Int), Int, Int], Unit)
// [Typer] check: Var("arr") against Array(Int)
// [Typer] inst: TypeScheme(([], Array(Int)))
// [Typer] inst result: Array(Int)
// [Typer] unify: Array(Int) and Array(Int)
// [Typer] unify: Int and Int
// [Typer] check: Var("j") against Int
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] check: Prim(Var("j"), Int(1), Sub, kind=None) against Int
// [Typer] check: Var("j") against Int
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] check: Int(1) against Int
// [Typer] unify: Var({val: None}) and Unit
// [Typer] union: Var({val: None}) and Unit
// [Typer] check: App(Var("g"), [Prim(Var("j"), Int(1), Sub, kind=None)]) against Unit
// [Typer] infer: Prim(Var("j"), Int(1), Sub, kind=None)
// [Typer] infer: Var("j")
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] infer: Int(1)
// [Typer] unify: Int and Int
// [Typer] check: Var("g") against Fun([Int], Unit)
// [Typer] inst: TypeScheme(([], Fun([Int], Unit)))
// [Typer] inst result: Fun([Int], Unit)
// [Typer] unify: Fun([Int], Unit) and Fun([Int], Unit)
// [Typer] unify: Int and Int
// [Typer] unify: Unit and Unit
// [Typer] check: Unit against Unit
// [Typer] check: Unit against Unit
// [Typer] check: LetRec({tyvars: [], name: ("f", Unit), args: [("i", Int)], body: If(LE(Var("i"), Prim(Var("high"), Int(1), Sub, kind=None)), Let(("j", Var({val: None})), Var("i"), Let(("_", Var({val: None})), App(Var("g"), [Var("j")]), App(Var("f"), [Prim(Var("i"), Int(1), Add, kind=None)]))), Unit)}, App(Var("f"), [Prim(Var("low"), Int(1), Add, kind=None)])) against Unit
// [Typer] typevars: []
// [Typer] check: If(LE(Var("i"), Prim(Var("high"), Int(1), Sub, kind=None)), Let(("j", Var({val: None})), Var("i"), Let(("_", Var({val: None})), App(Var("g"), [Var("j")]), App(Var("f"), [Prim(Var("i"), Int(1), Add, kind=None)]))), Unit) against Unit
// [Typer] check: LE(Var("i"), Prim(Var("high"), Int(1), Sub, kind=None)) against Bool
// [Typer] infer: Var("i")
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] infer: Prim(Var("high"), Int(1), Sub, kind=None)
// [Typer] infer: Var("high")
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] infer: Int(1)
// [Typer] unify: Int and Int
// [Typer] unify: Int and Int
// [Typer] check: Let(("j", Var({val: None})), Var("i"), Let(("_", Var({val: None})), App(Var("g"), [Var("j")]), App(Var("f"), [Prim(Var("i"), Int(1), Add, kind=None)]))) against Unit
// [Typer] infer: Var("i")
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] unify: Var({val: None}) and Int
// [Typer] union: Var({val: None}) and Int
// [Typer] check: Let(("_", Var({val: None})), App(Var("g"), [Var("j")]), App(Var("f"), [Prim(Var("i"), Int(1), Add, kind=None)])) against Unit
// [Typer] infer: App(Var("g"), [Var("j")])
// [Typer] infer: Var("g")
// [Typer] inst: TypeScheme(([], Fun([Int], Unit)))
// [Typer] inst result: Fun([Int], Unit)
// [Typer] check: Var("j") against Int
// [Typer] inst: TypeScheme(([], Var({val: Some(Int)})))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] unify: Var({val: None}) and Unit
// [Typer] union: Var({val: None}) and Unit
// [Typer] check: App(Var("f"), [Prim(Var("i"), Int(1), Add, kind=None)]) against Unit
// [Typer] infer: Prim(Var("i"), Int(1), Add, kind=None)
// [Typer] infer: Var("i")
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] infer: Int(1)
// [Typer] unify: Int and Int
// [Typer] check: Var("f") against Fun([Int], Unit)
// [Typer] inst: TypeScheme(([], Fun([Int], Unit)))
// [Typer] inst result: Fun([Int], Unit)
// [Typer] unify: Fun([Int], Unit) and Fun([Int], Unit)
// [Typer] unify: Int and Int
// [Typer] unify: Unit and Unit
// [Typer] check: Unit against Unit
// [Typer] check: App(Var("f"), [Prim(Var("low"), Int(1), Add, kind=None)]) against Unit
// [Typer] infer: Prim(Var("low"), Int(1), Add, kind=None)
// [Typer] infer: Var("low")
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] infer: Int(1)
// [Typer] unify: Int and Int
// [Typer] check: Var("f") against Fun([Int], Unit)
// [Typer] inst: TypeScheme(([], Fun([Int], Unit)))
// [Typer] inst result: Fun([Int], Unit)
// [Typer] unify: Fun([Int], Unit) and Fun([Int], Unit)
// [Typer] unify: Int and Int
// [Typer] unify: Unit and Unit
// [Typer] check: LetRec({tyvars: [], name: ("partition", Tuple([Int, Bool])), args: [("arr", Array(Int)), ("pivot_index", Int), ("low", Int), ("high", Int)], body: Let(("_", Var({val: None})), App(Var("swap"), [Var("arr"), Var("pivot_index"), Prim(Var("high"), Int(1), Sub, kind=None)]), Let(("pivot", Var({val: None})), Get(Var("arr"), Prim(Var("high"), Int(1), Sub, kind=None)), Let(("i", Var({val: None})), Array(Int(1), Var("low")), Let(("partitioned", Var({val: None})), Array(Int(1), Int(1)), LetRec({tyvars: [], name: ("aux", Var({val: None})), args: [("j", Int)], body: If(LE(Var("j"), Prim(Var("high"), Int(2), Sub, kind=None)), Let(("_", Var({val: None})), If(LE(Get(Var("arr"), Var("j")), Prim(Var("pivot"), Int(1), Sub, kind=None)), Let(("_", Var({val: None})), If(Eq(Get(Var("i"), Int(0)), Var("j")), Unit, Let(("_", Var({val: None})), App(Var("swap"), [Var("arr"), Get(Var("i"), Int(0)), Var("j")]), Put(Var("partitioned"), Int(0), Int(0)))), Let(("_", Var({val: None})), Put(Var("i"), Int(0), Prim(Get(Var("i"), Int(0)), Int(1), Add, kind=None)), Unit)), Unit), App(Var("aux"), [Prim(Var("j"), Int(1), Add, kind=None)])), Unit)}, Let(("_", Var({val: None})), App(Var("aux"), [Var("low")]), Let(("_", Var({val: None})), App(Var("swap"), [Var("arr"), Get(Var("i"), Int(0)), Prim(Var("high"), Int(1), Sub, kind=None)]), Tuple([Get(Var("i"), Int(0)), Eq(Get(Var("partitioned"), Int(0)), Int(1))]))))))))}, LetRec({tyvars: [], name: ("choose_pivot", Tuple([Int, Bool])), args: [("arr", Array(Int)), ("low", Int), ("high", Int)], body: Let(("use_median_of_medians", Var({val: None})), Int(50), Let(("swaps", Var({val: None})), Array(Int(1), Int(0)), Let(("len", Var({val: None})), Prim(Var("high"), Var("low"), Sub, kind=None), Let(("b", Var({val: None})), Prim(Var("low"), Prim(Prim(Var("len"), Int(4), Div, kind=None), Int(2), Mul, kind=None), Add, kind=None), Let(("_", Var({val: None})), If(LE(Int(8), Var("len")), Let(("a", Var({val: None})), Prim(Var("low"), Prim(Prim(Var("len"), Int(4), Div, kind=None), Int(1), Mul, kind=None), Add, kind=None), Let(("c", Var({val: None})), Prim(Var("low"), Prim(Prim(Var("len"), Int(4), Div, kind=None), Int(3), Mul, kind=None), Add, kind=None), LetRec({tyvars: [], name: ("sort_2", Var({val: None})), args: [("a", Int), ("b", Int)], body: If(LE(Get(Var("arr"), Var("b")), Prim(Get(Var("arr"), Var("a")), Int(1), Sub, kind=None)), Let(("_", Var({val: None})), App(Var("swap"), [Var("arr"), Var("a"), Var("b")]), Put(Var("swaps"), Int(0), Prim(Get(Var("swaps"), Int(0)), Int(1), Add, kind=None))), Unit)}, LetRec({tyvars: [], name: ("sort_3", Var({val: None})), args: [("a", Int), ("b", Int), ("c", Int)], body: Let(("_", Var({val: None})), App(Var("sort_2"), [Var("a"), Var("b")]), Let(("_", Var({val: None})), App(Var("sort_2"), [Var("b"), Var("c")]), App(Var("sort_2"), [Var("a"), Var("b")])))}, Let(("_", Var({val: None})), If(LE(Var("use_median_of_medians"), Prim(Var("len"), Int(1), Sub, kind=None)), Let(("_", Var({val: None})), App(Var("sort_3"), [Prim(Var("a"), Int(1), Sub, kind=None), Var("a"), Prim(Var("a"), Int(1), Add, kind=None)]), Let(("_", Var({val: None})), App(Var("sort_3"), [Prim(Var("b"), Int(1), Sub, kind=None), Var("b"), Prim(Var("b"), Int(1), Add, kind=None)]), App(Var("sort_3"), [Prim(Var("c"), Int(1), Sub, kind=None), Var("c"), Prim(Var("c"), Int(1), Add, kind=None)]))), Unit), App(Var("sort_3"), [Var("a"), Var("b"), Var("c")])))))), Unit), Tuple([Var("b"), Eq(Get(Var("swaps"), Int(0)), Int(0))]))))))}, LetRec({tyvars: [], name: ("quick_sort", Unit), args: [("arr", Array(Int)), ("low", Int), ("high", Int)], body: Let(("len", Var({val: None})), Prim(Var("high"), Var("low"), Sub, kind=None), If(LE(Var("len"), Int(16)), App(Var("insertion_sort"), [Var("arr"), Var("low"), Var("high")]), LetTuple([("pivot_index", Var({val: None})), ("likely_sorted", Var({val: None}))], App(Var("choose_pivot"), [Var("arr"), Var("low"), Var("high")]), LetTuple([("pivot", Var({val: None})), ("partitioned", Var({val: None}))], App(Var("partition"), [Var("arr"), Var("pivot_index"), Var("low"), Var("high")]), Let(("_", Var({val: None})), App(Var("quick_sort"), [Var("arr"), Var("low"), Var("pivot")]), App(Var("quick_sort"), [Var("arr"), Prim(Var("pivot"), Int(1), Add, kind=None), Var("high")]))))))}, LetRec({tyvars: [], name: ("sort", Unit), args: [("x", Array(Int)), ("len", Int)], body: App(Var("quick_sort"), [Var("x"), Int(0), Var("len")])}, LetRec({tyvars: [], name: ("main", Var({val: None})), args: [], body: Let(("len", Var({val: None})), App(Var("read_int"), []), Let(("arr", Var({val: None})), Array(Var("len"), Int(0)), LetRec({tyvars: [], name: ("input", Var({val: None})), args: [("i", Int)], body: If(LE(Var("i"), Prim(Var("len"), Int(1), Sub, kind=None)), Let(("_", Var({val: None})), Put(Var("arr"), Var("i"), App(Var("read_int"), [])), App(Var("input"), [Prim(Var("i"), Int(1), Add, kind=None)])), Unit)}, Let(("_", Var({val: None})), App(Var("input"), [Int(0)]), Let(("_", Var({val: None})), App(Var("sort"), [Var("arr"), Var("len")]), App(Var("output"), [Var("arr"), Int(0), Var("len")]))))))}, Unit))))) against Unit
// [Typer] typevars: []
// [Typer] check: Let(("_", Var({val: None})), App(Var("swap"), [Var("arr"), Var("pivot_index"), Prim(Var("high"), Int(1), Sub, kind=None)]), Let(("pivot", Var({val: None})), Get(Var("arr"), Prim(Var("high"), Int(1), Sub, kind=None)), Let(("i", Var({val: None})), Array(Int(1), Var("low")), Let(("partitioned", Var({val: None})), Array(Int(1), Int(1)), LetRec({tyvars: [], name: ("aux", Var({val: None})), args: [("j", Int)], body: If(LE(Var("j"), Prim(Var("high"), Int(2), Sub, kind=None)), Let(("_", Var({val: None})), If(LE(Get(Var("arr"), Var("j")), Prim(Var("pivot"), Int(1), Sub, kind=None)), Let(("_", Var({val: None})), If(Eq(Get(Var("i"), Int(0)), Var("j")), Unit, Let(("_", Var({val: None})), App(Var("swap"), [Var("arr"), Get(Var("i"), Int(0)), Var("j")]), Put(Var("partitioned"), Int(0), Int(0)))), Let(("_", Var({val: None})), Put(Var("i"), Int(0), Prim(Get(Var("i"), Int(0)), Int(1), Add, kind=None)), Unit)), Unit), App(Var("aux"), [Prim(Var("j"), Int(1), Add, kind=None)])), Unit)}, Let(("_", Var({val: None})), App(Var("aux"), [Var("low")]), Let(("_", Var({val: None})), App(Var("swap"), [Var("arr"), Get(Var("i"), Int(0)), Prim(Var("high"), Int(1), Sub, kind=None)]), Tuple([Get(Var("i"), Int(0)), Eq(Get(Var("partitioned"), Int(0)), Int(1))])))))))) against Tuple([Int, Bool])
// [Typer] infer: App(Var("swap"), [Var("arr"), Var("pivot_index"), Prim(Var("high"), Int(1), Sub, kind=None)])
// [Typer] infer: Var("swap")
// [Typer] inst: TypeScheme(([], Fun([Array(Int), Int, Int], Unit)))
// [Typer] inst result: Fun([Array(Int), Int, Int], Unit)
// [Typer] check: Var("arr") against Array(Int)
// [Typer] inst: TypeScheme(([], Array(Int)))
// [Typer] inst result: Array(Int)
// [Typer] unify: Array(Int) and Array(Int)
// [Typer] unify: Int and Int
// [Typer] check: Var("pivot_index") against Int
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] check: Prim(Var("high"), Int(1), Sub, kind=None) against Int
// [Typer] check: Var("high") against Int
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] check: Int(1) against Int
// [Typer] unify: Var({val: None}) and Unit
// [Typer] union: Var({val: None}) and Unit
// [Typer] check: Let(("pivot", Var({val: None})), Get(Var("arr"), Prim(Var("high"), Int(1), Sub, kind=None)), Let(("i", Var({val: None})), Array(Int(1), Var("low")), Let(("partitioned", Var({val: None})), Array(Int(1), Int(1)), LetRec({tyvars: [], name: ("aux", Var({val: None})), args: [("j", Int)], body: If(LE(Var("j"), Prim(Var("high"), Int(2), Sub, kind=None)), Let(("_", Var({val: None})), If(LE(Get(Var("arr"), Var("j")), Prim(Var("pivot"), Int(1), Sub, kind=None)), Let(("_", Var({val: None})), If(Eq(Get(Var("i"), Int(0)), Var("j")), Unit, Let(("_", Var({val: None})), App(Var("swap"), [Var("arr"), Get(Var("i"), Int(0)), Var("j")]), Put(Var("partitioned"), Int(0), Int(0)))), Let(("_", Var({val: None})), Put(Var("i"), Int(0), Prim(Get(Var("i"), Int(0)), Int(1), Add, kind=None)), Unit)), Unit), App(Var("aux"), [Prim(Var("j"), Int(1), Add, kind=None)])), Unit)}, Let(("_", Var({val: None})), App(Var("aux"), [Var("low")]), Let(("_", Var({val: None})), App(Var("swap"), [Var("arr"), Get(Var("i"), Int(0)), Prim(Var("high"), Int(1), Sub, kind=None)]), Tuple([Get(Var("i"), Int(0)), Eq(Get(Var("partitioned"), Int(0)), Int(1))]))))))) against Tuple([Int, Bool])
// [Typer] infer: Get(Var("arr"), Prim(Var("high"), Int(1), Sub, kind=None))
// [Typer] infer: Var("arr")
// [Typer] inst: TypeScheme(([], Array(Int)))
// [Typer] inst result: Array(Int)
// [Typer] check: Prim(Var("high"), Int(1), Sub, kind=None) against Int
// [Typer] check: Var("high") against Int
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] check: Int(1) against Int
// [Typer] unify: Var({val: None}) and Int
// [Typer] union: Var({val: None}) and Int
// [Typer] check: Let(("i", Var({val: None})), Array(Int(1), Var("low")), Let(("partitioned", Var({val: None})), Array(Int(1), Int(1)), LetRec({tyvars: [], name: ("aux", Var({val: None})), args: [("j", Int)], body: If(LE(Var("j"), Prim(Var("high"), Int(2), Sub, kind=None)), Let(("_", Var({val: None})), If(LE(Get(Var("arr"), Var("j")), Prim(Var("pivot"), Int(1), Sub, kind=None)), Let(("_", Var({val: None})), If(Eq(Get(Var("i"), Int(0)), Var("j")), Unit, Let(("_", Var({val: None})), App(Var("swap"), [Var("arr"), Get(Var("i"), Int(0)), Var("j")]), Put(Var("partitioned"), Int(0), Int(0)))), Let(("_", Var({val: None})), Put(Var("i"), Int(0), Prim(Get(Var("i"), Int(0)), Int(1), Add, kind=None)), Unit)), Unit), App(Var("aux"), [Prim(Var("j"), Int(1), Add, kind=None)])), Unit)}, Let(("_", Var({val: None})), App(Var("aux"), [Var("low")]), Let(("_", Var({val: None})), App(Var("swap"), [Var("arr"), Get(Var("i"), Int(0)), Prim(Var("high"), Int(1), Sub, kind=None)]), Tuple([Get(Var("i"), Int(0)), Eq(Get(Var("partitioned"), Int(0)), Int(1))])))))) against Tuple([Int, Bool])
// [Typer] infer: Array(Int(1), Var("low"))
// [Typer] infer: Var("low")
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] check: Int(1) against Int
// [Typer] unify: Var({val: None}) and Array(Int)
// [Typer] union: Var({val: None}) and Array(Int)
// [Typer] check: Let(("partitioned", Var({val: None})), Array(Int(1), Int(1)), LetRec({tyvars: [], name: ("aux", Var({val: None})), args: [("j", Int)], body: If(LE(Var("j"), Prim(Var("high"), Int(2), Sub, kind=None)), Let(("_", Var({val: None})), If(LE(Get(Var("arr"), Var("j")), Prim(Var("pivot"), Int(1), Sub, kind=None)), Let(("_", Var({val: None})), If(Eq(Get(Var("i"), Int(0)), Var("j")), Unit, Let(("_", Var({val: None})), App(Var("swap"), [Var("arr"), Get(Var("i"), Int(0)), Var("j")]), Put(Var("partitioned"), Int(0), Int(0)))), Let(("_", Var({val: None})), Put(Var("i"), Int(0), Prim(Get(Var("i"), Int(0)), Int(1), Add, kind=None)), Unit)), Unit), App(Var("aux"), [Prim(Var("j"), Int(1), Add, kind=None)])), Unit)}, Let(("_", Var({val: None})), App(Var("aux"), [Var("low")]), Let(("_", Var({val: None})), App(Var("swap"), [Var("arr"), Get(Var("i"), Int(0)), Prim(Var("high"), Int(1), Sub, kind=None)]), Tuple([Get(Var("i"), Int(0)), Eq(Get(Var("partitioned"), Int(0)), Int(1))]))))) against Tuple([Int, Bool])
// [Typer] infer: Array(Int(1), Int(1))
// [Typer] infer: Int(1)
// [Typer] check: Int(1) against Int
// [Typer] unify: Var({val: None}) and Array(Int)
// [Typer] union: Var({val: None}) and Array(Int)
// [Typer] check: LetRec({tyvars: [], name: ("aux", Var({val: None})), args: [("j", Int)], body: If(LE(Var("j"), Prim(Var("high"), Int(2), Sub, kind=None)), Let(("_", Var({val: None})), If(LE(Get(Var("arr"), Var("j")), Prim(Var("pivot"), Int(1), Sub, kind=None)), Let(("_", Var({val: None})), If(Eq(Get(Var("i"), Int(0)), Var("j")), Unit, Let(("_", Var({val: None})), App(Var("swap"), [Var("arr"), Get(Var("i"), Int(0)), Var("j")]), Put(Var("partitioned"), Int(0), Int(0)))), Let(("_", Var({val: None})), Put(Var("i"), Int(0), Prim(Get(Var("i"), Int(0)), Int(1), Add, kind=None)), Unit)), Unit), App(Var("aux"), [Prim(Var("j"), Int(1), Add, kind=None)])), Unit)}, Let(("_", Var({val: None})), App(Var("aux"), [Var("low")]), Let(("_", Var({val: None})), App(Var("swap"), [Var("arr"), Get(Var("i"), Int(0)), Prim(Var("high"), Int(1), Sub, kind=None)]), Tuple([Get(Var("i"), Int(0)), Eq(Get(Var("partitioned"), Int(0)), Int(1))])))) against Tuple([Int, Bool])
// [Typer] typevars: []
// [Typer] infer: If(LE(Var("j"), Prim(Var("high"), Int(2), Sub, kind=None)), Let(("_", Var({val: None})), If(LE(Get(Var("arr"), Var("j")), Prim(Var("pivot"), Int(1), Sub, kind=None)), Let(("_", Var({val: None})), If(Eq(Get(Var("i"), Int(0)), Var("j")), Unit, Let(("_", Var({val: None})), App(Var("swap"), [Var("arr"), Get(Var("i"), Int(0)), Var("j")]), Put(Var("partitioned"), Int(0), Int(0)))), Let(("_", Var({val: None})), Put(Var("i"), Int(0), Prim(Get(Var("i"), Int(0)), Int(1), Add, kind=None)), Unit)), Unit), App(Var("aux"), [Prim(Var("j"), Int(1), Add, kind=None)])), Unit)
// [Typer] check: LE(Var("j"), Prim(Var("high"), Int(2), Sub, kind=None)) against Bool
// [Typer] infer: Var("j")
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] infer: Prim(Var("high"), Int(2), Sub, kind=None)
// [Typer] infer: Var("high")
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] infer: Int(2)
// [Typer] unify: Int and Int
// [Typer] unify: Int and Int
// [Typer] infer: Let(("_", Var({val: None})), If(LE(Get(Var("arr"), Var("j")), Prim(Var("pivot"), Int(1), Sub, kind=None)), Let(("_", Var({val: None})), If(Eq(Get(Var("i"), Int(0)), Var("j")), Unit, Let(("_", Var({val: None})), App(Var("swap"), [Var("arr"), Get(Var("i"), Int(0)), Var("j")]), Put(Var("partitioned"), Int(0), Int(0)))), Let(("_", Var({val: None})), Put(Var("i"), Int(0), Prim(Get(Var("i"), Int(0)), Int(1), Add, kind=None)), Unit)), Unit), App(Var("aux"), [Prim(Var("j"), Int(1), Add, kind=None)]))
// [Typer] infer: If(LE(Get(Var("arr"), Var("j")), Prim(Var("pivot"), Int(1), Sub, kind=None)), Let(("_", Var({val: None})), If(Eq(Get(Var("i"), Int(0)), Var("j")), Unit, Let(("_", Var({val: None})), App(Var("swap"), [Var("arr"), Get(Var("i"), Int(0)), Var("j")]), Put(Var("partitioned"), Int(0), Int(0)))), Let(("_", Var({val: None})), Put(Var("i"), Int(0), Prim(Get(Var("i"), Int(0)), Int(1), Add, kind=None)), Unit)), Unit)
// [Typer] check: LE(Get(Var("arr"), Var("j")), Prim(Var("pivot"), Int(1), Sub, kind=None)) against Bool
// [Typer] infer: Get(Var("arr"), Var("j"))
// [Typer] infer: Var("arr")
// [Typer] inst: TypeScheme(([], Array(Int)))
// [Typer] inst result: Array(Int)
// [Typer] check: Var("j") against Int
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] infer: Prim(Var("pivot"), Int(1), Sub, kind=None)
// [Typer] infer: Var("pivot")
// [Typer] inst: TypeScheme(([], Var({val: Some(Int)})))
// [Typer] inst result: Int
// [Typer] infer: Int(1)
// [Typer] unify: Int and Int
// [Typer] unify: Int and Int
// [Typer] infer: Let(("_", Var({val: None})), If(Eq(Get(Var("i"), Int(0)), Var("j")), Unit, Let(("_", Var({val: None})), App(Var("swap"), [Var("arr"), Get(Var("i"), Int(0)), Var("j")]), Put(Var("partitioned"), Int(0), Int(0)))), Let(("_", Var({val: None})), Put(Var("i"), Int(0), Prim(Get(Var("i"), Int(0)), Int(1), Add, kind=None)), Unit))
// [Typer] infer: If(Eq(Get(Var("i"), Int(0)), Var("j")), Unit, Let(("_", Var({val: None})), App(Var("swap"), [Var("arr"), Get(Var("i"), Int(0)), Var("j")]), Put(Var("partitioned"), Int(0), Int(0))))
// [Typer] check: Eq(Get(Var("i"), Int(0)), Var("j")) against Bool
// [Typer] infer: Get(Var("i"), Int(0))
// [Typer] infer: Var("i")
// [Typer] inst: TypeScheme(([], Var({val: Some(Array(Int))})))
// [Typer] inst result: Array(Int)
// [Typer] check: Int(0) against Int
// [Typer] infer: Var("j")
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] infer: Unit
// [Typer] infer: Let(("_", Var({val: None})), App(Var("swap"), [Var("arr"), Get(Var("i"), Int(0)), Var("j")]), Put(Var("partitioned"), Int(0), Int(0)))
// [Typer] infer: App(Var("swap"), [Var("arr"), Get(Var("i"), Int(0)), Var("j")])
// [Typer] infer: Var("swap")
// [Typer] inst: TypeScheme(([], Fun([Array(Int), Int, Int], Unit)))
// [Typer] inst result: Fun([Array(Int), Int, Int], Unit)
// [Typer] check: Var("arr") against Array(Int)
// [Typer] inst: TypeScheme(([], Array(Int)))
// [Typer] inst result: Array(Int)
// [Typer] unify: Array(Int) and Array(Int)
// [Typer] unify: Int and Int
// [Typer] check: Get(Var("i"), Int(0)) against Int
// [Typer] check: Var("i") against Array(Int)
// [Typer] inst: TypeScheme(([], Var({val: Some(Array(Int))})))
// [Typer] inst result: Array(Int)
// [Typer] unify: Array(Int) and Array(Int)
// [Typer] unify: Int and Int
// [Typer] check: Int(0) against Int
// [Typer] check: Var("j") against Int
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] unify: Var({val: None}) and Unit
// [Typer] union: Var({val: None}) and Unit
// [Typer] infer: Put(Var("partitioned"), Int(0), Int(0))
// [Typer] infer: Int(0)
// [Typer] check: Var("partitioned") against Array(Int)
// [Typer] inst: TypeScheme(([], Var({val: Some(Array(Int))})))
// [Typer] inst result: Array(Int)
// [Typer] unify: Array(Int) and Array(Int)
// [Typer] unify: Int and Int
// [Typer] check: Int(0) against Int
// [Typer] unify: Unit and Unit
// [Typer] unify: Var({val: None}) and Unit
// [Typer] union: Var({val: None}) and Unit
// [Typer] infer: Let(("_", Var({val: None})), Put(Var("i"), Int(0), Prim(Get(Var("i"), Int(0)), Int(1), Add, kind=None)), Unit)
// [Typer] infer: Put(Var("i"), Int(0), Prim(Get(Var("i"), Int(0)), Int(1), Add, kind=None))
// [Typer] infer: Prim(Get(Var("i"), Int(0)), Int(1), Add, kind=None)
// [Typer] infer: Get(Var("i"), Int(0))
// [Typer] infer: Var("i")
// [Typer] inst: TypeScheme(([], Var({val: Some(Array(Int))})))
// [Typer] inst result: Array(Int)
// [Typer] check: Int(0) against Int
// [Typer] infer: Int(1)
// [Typer] unify: Int and Int
// [Typer] check: Var("i") against Array(Int)
// [Typer] inst: TypeScheme(([], Var({val: Some(Array(Int))})))
// [Typer] inst result: Array(Int)
// [Typer] unify: Array(Int) and Array(Int)
// [Typer] unify: Int and Int
// [Typer] check: Int(0) against Int
// [Typer] unify: Var({val: None}) and Unit
// [Typer] union: Var({val: None}) and Unit
// [Typer] infer: Unit
// [Typer] infer: Unit
// [Typer] unify: Unit and Unit
// [Typer] unify: Var({val: None}) and Unit
// [Typer] union: Var({val: None}) and Unit
// [Typer] infer: App(Var("aux"), [Prim(Var("j"), Int(1), Add, kind=None)])
// [Typer] infer: Var("aux")
// [Typer] inst: TypeScheme(([], Fun([Int], Var({val: None}))))
// [Typer] inst result: Fun([Int], Var({val: None}))
// [Typer] check: Prim(Var("j"), Int(1), Add, kind=None) against Int
// [Typer] check: Var("j") against Int
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] check: Int(1) against Int
// [Typer] infer: Unit
// [Typer] unify: Var({val: None}) and Unit
// [Typer] union: Var({val: None}) and Unit
// [Typer] unify: Unit and Var({val: Some(Unit)})
// [Typer] check: Let(("_", Var({val: None})), App(Var("aux"), [Var("low")]), Let(("_", Var({val: None})), App(Var("swap"), [Var("arr"), Get(Var("i"), Int(0)), Prim(Var("high"), Int(1), Sub, kind=None)]), Tuple([Get(Var("i"), Int(0)), Eq(Get(Var("partitioned"), Int(0)), Int(1))]))) against Tuple([Int, Bool])
// [Typer] infer: App(Var("aux"), [Var("low")])
// [Typer] infer: Var("aux")
// [Typer] inst: TypeScheme(([], Fun([Int], Var({val: Some(Unit)}))))
// [Typer] inst result: Fun([Int], Unit)
// [Typer] check: Var("low") against Int
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] unify: Var({val: None}) and Unit
// [Typer] union: Var({val: None}) and Unit
// [Typer] check: Let(("_", Var({val: None})), App(Var("swap"), [Var("arr"), Get(Var("i"), Int(0)), Prim(Var("high"), Int(1), Sub, kind=None)]), Tuple([Get(Var("i"), Int(0)), Eq(Get(Var("partitioned"), Int(0)), Int(1))])) against Tuple([Int, Bool])
// [Typer] infer: App(Var("swap"), [Var("arr"), Get(Var("i"), Int(0)), Prim(Var("high"), Int(1), Sub, kind=None)])
// [Typer] infer: Var("swap")
// [Typer] inst: TypeScheme(([], Fun([Array(Int), Int, Int], Unit)))
// [Typer] inst result: Fun([Array(Int), Int, Int], Unit)
// [Typer] check: Var("arr") against Array(Int)
// [Typer] inst: TypeScheme(([], Array(Int)))
// [Typer] inst result: Array(Int)
// [Typer] unify: Array(Int) and Array(Int)
// [Typer] unify: Int and Int
// [Typer] check: Get(Var("i"), Int(0)) against Int
// [Typer] check: Var("i") against Array(Int)
// [Typer] inst: TypeScheme(([], Var({val: Some(Array(Int))})))
// [Typer] inst result: Array(Int)
// [Typer] unify: Array(Int) and Array(Int)
// [Typer] unify: Int and Int
// [Typer] check: Int(0) against Int
// [Typer] check: Prim(Var("high"), Int(1), Sub, kind=None) against Int
// [Typer] check: Var("high") against Int
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] check: Int(1) against Int
// [Typer] unify: Var({val: None}) and Unit
// [Typer] union: Var({val: None}) and Unit
// [Typer] check: Tuple([Get(Var("i"), Int(0)), Eq(Get(Var("partitioned"), Int(0)), Int(1))]) against Tuple([Int, Bool])
// [Typer] check: Get(Var("i"), Int(0)) against Int
// [Typer] check: Var("i") against Array(Int)
// [Typer] inst: TypeScheme(([], Var({val: Some(Array(Int))})))
// [Typer] inst result: Array(Int)
// [Typer] unify: Array(Int) and Array(Int)
// [Typer] unify: Int and Int
// [Typer] check: Int(0) against Int
// [Typer] check: Eq(Get(Var("partitioned"), Int(0)), Int(1)) against Bool
// [Typer] infer: Get(Var("partitioned"), Int(0))
// [Typer] infer: Var("partitioned")
// [Typer] inst: TypeScheme(([], Var({val: Some(Array(Int))})))
// [Typer] inst result: Array(Int)
// [Typer] check: Int(0) against Int
// [Typer] infer: Int(1)
// [Typer] unify: Int and Int
// [Typer] check: LetRec({tyvars: [], name: ("choose_pivot", Tuple([Int, Bool])), args: [("arr", Array(Int)), ("low", Int), ("high", Int)], body: Let(("use_median_of_medians", Var({val: None})), Int(50), Let(("swaps", Var({val: None})), Array(Int(1), Int(0)), Let(("len", Var({val: None})), Prim(Var("high"), Var("low"), Sub, kind=None), Let(("b", Var({val: None})), Prim(Var("low"), Prim(Prim(Var("len"), Int(4), Div, kind=None), Int(2), Mul, kind=None), Add, kind=None), Let(("_", Var({val: None})), If(LE(Int(8), Var("len")), Let(("a", Var({val: None})), Prim(Var("low"), Prim(Prim(Var("len"), Int(4), Div, kind=None), Int(1), Mul, kind=None), Add, kind=None), Let(("c", Var({val: None})), Prim(Var("low"), Prim(Prim(Var("len"), Int(4), Div, kind=None), Int(3), Mul, kind=None), Add, kind=None), LetRec({tyvars: [], name: ("sort_2", Var({val: None})), args: [("a", Int), ("b", Int)], body: If(LE(Get(Var("arr"), Var("b")), Prim(Get(Var("arr"), Var("a")), Int(1), Sub, kind=None)), Let(("_", Var({val: None})), App(Var("swap"), [Var("arr"), Var("a"), Var("b")]), Put(Var("swaps"), Int(0), Prim(Get(Var("swaps"), Int(0)), Int(1), Add, kind=None))), Unit)}, LetRec({tyvars: [], name: ("sort_3", Var({val: None})), args: [("a", Int), ("b", Int), ("c", Int)], body: Let(("_", Var({val: None})), App(Var("sort_2"), [Var("a"), Var("b")]), Let(("_", Var({val: None})), App(Var("sort_2"), [Var("b"), Var("c")]), App(Var("sort_2"), [Var("a"), Var("b")])))}, Let(("_", Var({val: None})), If(LE(Var("use_median_of_medians"), Prim(Var("len"), Int(1), Sub, kind=None)), Let(("_", Var({val: None})), App(Var("sort_3"), [Prim(Var("a"), Int(1), Sub, kind=None), Var("a"), Prim(Var("a"), Int(1), Add, kind=None)]), Let(("_", Var({val: None})), App(Var("sort_3"), [Prim(Var("b"), Int(1), Sub, kind=None), Var("b"), Prim(Var("b"), Int(1), Add, kind=None)]), App(Var("sort_3"), [Prim(Var("c"), Int(1), Sub, kind=None), Var("c"), Prim(Var("c"), Int(1), Add, kind=None)]))), Unit), App(Var("sort_3"), [Var("a"), Var("b"), Var("c")])))))), Unit), Tuple([Var("b"), Eq(Get(Var("swaps"), Int(0)), Int(0))]))))))}, LetRec({tyvars: [], name: ("quick_sort", Unit), args: [("arr", Array(Int)), ("low", Int), ("high", Int)], body: Let(("len", Var({val: None})), Prim(Var("high"), Var("low"), Sub, kind=None), If(LE(Var("len"), Int(16)), App(Var("insertion_sort"), [Var("arr"), Var("low"), Var("high")]), LetTuple([("pivot_index", Var({val: None})), ("likely_sorted", Var({val: None}))], App(Var("choose_pivot"), [Var("arr"), Var("low"), Var("high")]), LetTuple([("pivot", Var({val: None})), ("partitioned", Var({val: None}))], App(Var("partition"), [Var("arr"), Var("pivot_index"), Var("low"), Var("high")]), Let(("_", Var({val: None})), App(Var("quick_sort"), [Var("arr"), Var("low"), Var("pivot")]), App(Var("quick_sort"), [Var("arr"), Prim(Var("pivot"), Int(1), Add, kind=None), Var("high")]))))))}, LetRec({tyvars: [], name: ("sort", Unit), args: [("x", Array(Int)), ("len", Int)], body: App(Var("quick_sort"), [Var("x"), Int(0), Var("len")])}, LetRec({tyvars: [], name: ("main", Var({val: None})), args: [], body: Let(("len", Var({val: None})), App(Var("read_int"), []), Let(("arr", Var({val: None})), Array(Var("len"), Int(0)), LetRec({tyvars: [], name: ("input", Var({val: None})), args: [("i", Int)], body: If(LE(Var("i"), Prim(Var("len"), Int(1), Sub, kind=None)), Let(("_", Var({val: None})), Put(Var("arr"), Var("i"), App(Var("read_int"), [])), App(Var("input"), [Prim(Var("i"), Int(1), Add, kind=None)])), Unit)}, Let(("_", Var({val: None})), App(Var("input"), [Int(0)]), Let(("_", Var({val: None})), App(Var("sort"), [Var("arr"), Var("len")]), App(Var("output"), [Var("arr"), Int(0), Var("len")]))))))}, Unit)))) against Unit
// [Typer] typevars: []
// [Typer] check: Let(("use_median_of_medians", Var({val: None})), Int(50), Let(("swaps", Var({val: None})), Array(Int(1), Int(0)), Let(("len", Var({val: None})), Prim(Var("high"), Var("low"), Sub, kind=None), Let(("b", Var({val: None})), Prim(Var("low"), Prim(Prim(Var("len"), Int(4), Div, kind=None), Int(2), Mul, kind=None), Add, kind=None), Let(("_", Var({val: None})), If(LE(Int(8), Var("len")), Let(("a", Var({val: None})), Prim(Var("low"), Prim(Prim(Var("len"), Int(4), Div, kind=None), Int(1), Mul, kind=None), Add, kind=None), Let(("c", Var({val: None})), Prim(Var("low"), Prim(Prim(Var("len"), Int(4), Div, kind=None), Int(3), Mul, kind=None), Add, kind=None), LetRec({tyvars: [], name: ("sort_2", Var({val: None})), args: [("a", Int), ("b", Int)], body: If(LE(Get(Var("arr"), Var("b")), Prim(Get(Var("arr"), Var("a")), Int(1), Sub, kind=None)), Let(("_", Var({val: None})), App(Var("swap"), [Var("arr"), Var("a"), Var("b")]), Put(Var("swaps"), Int(0), Prim(Get(Var("swaps"), Int(0)), Int(1), Add, kind=None))), Unit)}, LetRec({tyvars: [], name: ("sort_3", Var({val: None})), args: [("a", Int), ("b", Int), ("c", Int)], body: Let(("_", Var({val: None})), App(Var("sort_2"), [Var("a"), Var("b")]), Let(("_", Var({val: None})), App(Var("sort_2"), [Var("b"), Var("c")]), App(Var("sort_2"), [Var("a"), Var("b")])))}, Let(("_", Var({val: None})), If(LE(Var("use_median_of_medians"), Prim(Var("len"), Int(1), Sub, kind=None)), Let(("_", Var({val: None})), App(Var("sort_3"), [Prim(Var("a"), Int(1), Sub, kind=None), Var("a"), Prim(Var("a"), Int(1), Add, kind=None)]), Let(("_", Var({val: None})), App(Var("sort_3"), [Prim(Var("b"), Int(1), Sub, kind=None), Var("b"), Prim(Var("b"), Int(1), Add, kind=None)]), App(Var("sort_3"), [Prim(Var("c"), Int(1), Sub, kind=None), Var("c"), Prim(Var("c"), Int(1), Add, kind=None)]))), Unit), App(Var("sort_3"), [Var("a"), Var("b"), Var("c")])))))), Unit), Tuple([Var("b"), Eq(Get(Var("swaps"), Int(0)), Int(0))])))))) against Tuple([Int, Bool])
// [Typer] infer: Int(50)
// [Typer] unify: Var({val: None}) and Int
// [Typer] union: Var({val: None}) and Int
// [Typer] check: Let(("swaps", Var({val: None})), Array(Int(1), Int(0)), Let(("len", Var({val: None})), Prim(Var("high"), Var("low"), Sub, kind=None), Let(("b", Var({val: None})), Prim(Var("low"), Prim(Prim(Var("len"), Int(4), Div, kind=None), Int(2), Mul, kind=None), Add, kind=None), Let(("_", Var({val: None})), If(LE(Int(8), Var("len")), Let(("a", Var({val: None})), Prim(Var("low"), Prim(Prim(Var("len"), Int(4), Div, kind=None), Int(1), Mul, kind=None), Add, kind=None), Let(("c", Var({val: None})), Prim(Var("low"), Prim(Prim(Var("len"), Int(4), Div, kind=None), Int(3), Mul, kind=None), Add, kind=None), LetRec({tyvars: [], name: ("sort_2", Var({val: None})), args: [("a", Int), ("b", Int)], body: If(LE(Get(Var("arr"), Var("b")), Prim(Get(Var("arr"), Var("a")), Int(1), Sub, kind=None)), Let(("_", Var({val: None})), App(Var("swap"), [Var("arr"), Var("a"), Var("b")]), Put(Var("swaps"), Int(0), Prim(Get(Var("swaps"), Int(0)), Int(1), Add, kind=None))), Unit)}, LetRec({tyvars: [], name: ("sort_3", Var({val: None})), args: [("a", Int), ("b", Int), ("c", Int)], body: Let(("_", Var({val: None})), App(Var("sort_2"), [Var("a"), Var("b")]), Let(("_", Var({val: None})), App(Var("sort_2"), [Var("b"), Var("c")]), App(Var("sort_2"), [Var("a"), Var("b")])))}, Let(("_", Var({val: None})), If(LE(Var("use_median_of_medians"), Prim(Var("len"), Int(1), Sub, kind=None)), Let(("_", Var({val: None})), App(Var("sort_3"), [Prim(Var("a"), Int(1), Sub, kind=None), Var("a"), Prim(Var("a"), Int(1), Add, kind=None)]), Let(("_", Var({val: None})), App(Var("sort_3"), [Prim(Var("b"), Int(1), Sub, kind=None), Var("b"), Prim(Var("b"), Int(1), Add, kind=None)]), App(Var("sort_3"), [Prim(Var("c"), Int(1), Sub, kind=None), Var("c"), Prim(Var("c"), Int(1), Add, kind=None)]))), Unit), App(Var("sort_3"), [Var("a"), Var("b"), Var("c")])))))), Unit), Tuple([Var("b"), Eq(Get(Var("swaps"), Int(0)), Int(0))]))))) against Tuple([Int, Bool])
// [Typer] infer: Array(Int(1), Int(0))
// [Typer] infer: Int(0)
// [Typer] check: Int(1) against Int
// [Typer] unify: Var({val: None}) and Array(Int)
// [Typer] union: Var({val: None}) and Array(Int)
// [Typer] check: Let(("len", Var({val: None})), Prim(Var("high"), Var("low"), Sub, kind=None), Let(("b", Var({val: None})), Prim(Var("low"), Prim(Prim(Var("len"), Int(4), Div, kind=None), Int(2), Mul, kind=None), Add, kind=None), Let(("_", Var({val: None})), If(LE(Int(8), Var("len")), Let(("a", Var({val: None})), Prim(Var("low"), Prim(Prim(Var("len"), Int(4), Div, kind=None), Int(1), Mul, kind=None), Add, kind=None), Let(("c", Var({val: None})), Prim(Var("low"), Prim(Prim(Var("len"), Int(4), Div, kind=None), Int(3), Mul, kind=None), Add, kind=None), LetRec({tyvars: [], name: ("sort_2", Var({val: None})), args: [("a", Int), ("b", Int)], body: If(LE(Get(Var("arr"), Var("b")), Prim(Get(Var("arr"), Var("a")), Int(1), Sub, kind=None)), Let(("_", Var({val: None})), App(Var("swap"), [Var("arr"), Var("a"), Var("b")]), Put(Var("swaps"), Int(0), Prim(Get(Var("swaps"), Int(0)), Int(1), Add, kind=None))), Unit)}, LetRec({tyvars: [], name: ("sort_3", Var({val: None})), args: [("a", Int), ("b", Int), ("c", Int)], body: Let(("_", Var({val: None})), App(Var("sort_2"), [Var("a"), Var("b")]), Let(("_", Var({val: None})), App(Var("sort_2"), [Var("b"), Var("c")]), App(Var("sort_2"), [Var("a"), Var("b")])))}, Let(("_", Var({val: None})), If(LE(Var("use_median_of_medians"), Prim(Var("len"), Int(1), Sub, kind=None)), Let(("_", Var({val: None})), App(Var("sort_3"), [Prim(Var("a"), Int(1), Sub, kind=None), Var("a"), Prim(Var("a"), Int(1), Add, kind=None)]), Let(("_", Var({val: None})), App(Var("sort_3"), [Prim(Var("b"), Int(1), Sub, kind=None), Var("b"), Prim(Var("b"), Int(1), Add, kind=None)]), App(Var("sort_3"), [Prim(Var("c"), Int(1), Sub, kind=None), Var("c"), Prim(Var("c"), Int(1), Add, kind=None)]))), Unit), App(Var("sort_3"), [Var("a"), Var("b"), Var("c")])))))), Unit), Tuple([Var("b"), Eq(Get(Var("swaps"), Int(0)), Int(0))])))) against Tuple([Int, Bool])
// [Typer] infer: Prim(Var("high"), Var("low"), Sub, kind=None)
// [Typer] infer: Var("high")
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] infer: Var("low")
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] unify: Var({val: None}) and Int
// [Typer] union: Var({val: None}) and Int
// [Typer] check: Let(("b", Var({val: None})), Prim(Var("low"), Prim(Prim(Var("len"), Int(4), Div, kind=None), Int(2), Mul, kind=None), Add, kind=None), Let(("_", Var({val: None})), If(LE(Int(8), Var("len")), Let(("a", Var({val: None})), Prim(Var("low"), Prim(Prim(Var("len"), Int(4), Div, kind=None), Int(1), Mul, kind=None), Add, kind=None), Let(("c", Var({val: None})), Prim(Var("low"), Prim(Prim(Var("len"), Int(4), Div, kind=None), Int(3), Mul, kind=None), Add, kind=None), LetRec({tyvars: [], name: ("sort_2", Var({val: None})), args: [("a", Int), ("b", Int)], body: If(LE(Get(Var("arr"), Var("b")), Prim(Get(Var("arr"), Var("a")), Int(1), Sub, kind=None)), Let(("_", Var({val: None})), App(Var("swap"), [Var("arr"), Var("a"), Var("b")]), Put(Var("swaps"), Int(0), Prim(Get(Var("swaps"), Int(0)), Int(1), Add, kind=None))), Unit)}, LetRec({tyvars: [], name: ("sort_3", Var({val: None})), args: [("a", Int), ("b", Int), ("c", Int)], body: Let(("_", Var({val: None})), App(Var("sort_2"), [Var("a"), Var("b")]), Let(("_", Var({val: None})), App(Var("sort_2"), [Var("b"), Var("c")]), App(Var("sort_2"), [Var("a"), Var("b")])))}, Let(("_", Var({val: None})), If(LE(Var("use_median_of_medians"), Prim(Var("len"), Int(1), Sub, kind=None)), Let(("_", Var({val: None})), App(Var("sort_3"), [Prim(Var("a"), Int(1), Sub, kind=None), Var("a"), Prim(Var("a"), Int(1), Add, kind=None)]), Let(("_", Var({val: None})), App(Var("sort_3"), [Prim(Var("b"), Int(1), Sub, kind=None), Var("b"), Prim(Var("b"), Int(1), Add, kind=None)]), App(Var("sort_3"), [Prim(Var("c"), Int(1), Sub, kind=None), Var("c"), Prim(Var("c"), Int(1), Add, kind=None)]))), Unit), App(Var("sort_3"), [Var("a"), Var("b"), Var("c")])))))), Unit), Tuple([Var("b"), Eq(Get(Var("swaps"), Int(0)), Int(0))]))) against Tuple([Int, Bool])
// [Typer] infer: Prim(Var("low"), Prim(Prim(Var("len"), Int(4), Div, kind=None), Int(2), Mul, kind=None), Add, kind=None)
// [Typer] infer: Var("low")
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] infer: Prim(Prim(Var("len"), Int(4), Div, kind=None), Int(2), Mul, kind=None)
// [Typer] infer: Prim(Var("len"), Int(4), Div, kind=None)
// [Typer] infer: Var("len")
// [Typer] inst: TypeScheme(([], Var({val: Some(Int)})))
// [Typer] inst result: Int
// [Typer] infer: Int(4)
// [Typer] unify: Int and Int
// [Typer] infer: Int(2)
// [Typer] unify: Int and Int
// [Typer] unify: Int and Int
// [Typer] unify: Var({val: None}) and Int
// [Typer] union: Var({val: None}) and Int
// [Typer] check: Let(("_", Var({val: None})), If(LE(Int(8), Var("len")), Let(("a", Var({val: None})), Prim(Var("low"), Prim(Prim(Var("len"), Int(4), Div, kind=None), Int(1), Mul, kind=None), Add, kind=None), Let(("c", Var({val: None})), Prim(Var("low"), Prim(Prim(Var("len"), Int(4), Div, kind=None), Int(3), Mul, kind=None), Add, kind=None), LetRec({tyvars: [], name: ("sort_2", Var({val: None})), args: [("a", Int), ("b", Int)], body: If(LE(Get(Var("arr"), Var("b")), Prim(Get(Var("arr"), Var("a")), Int(1), Sub, kind=None)), Let(("_", Var({val: None})), App(Var("swap"), [Var("arr"), Var("a"), Var("b")]), Put(Var("swaps"), Int(0), Prim(Get(Var("swaps"), Int(0)), Int(1), Add, kind=None))), Unit)}, LetRec({tyvars: [], name: ("sort_3", Var({val: None})), args: [("a", Int), ("b", Int), ("c", Int)], body: Let(("_", Var({val: None})), App(Var("sort_2"), [Var("a"), Var("b")]), Let(("_", Var({val: None})), App(Var("sort_2"), [Var("b"), Var("c")]), App(Var("sort_2"), [Var("a"), Var("b")])))}, Let(("_", Var({val: None})), If(LE(Var("use_median_of_medians"), Prim(Var("len"), Int(1), Sub, kind=None)), Let(("_", Var({val: None})), App(Var("sort_3"), [Prim(Var("a"), Int(1), Sub, kind=None), Var("a"), Prim(Var("a"), Int(1), Add, kind=None)]), Let(("_", Var({val: None})), App(Var("sort_3"), [Prim(Var("b"), Int(1), Sub, kind=None), Var("b"), Prim(Var("b"), Int(1), Add, kind=None)]), App(Var("sort_3"), [Prim(Var("c"), Int(1), Sub, kind=None), Var("c"), Prim(Var("c"), Int(1), Add, kind=None)]))), Unit), App(Var("sort_3"), [Var("a"), Var("b"), Var("c")])))))), Unit), Tuple([Var("b"), Eq(Get(Var("swaps"), Int(0)), Int(0))])) against Tuple([Int, Bool])
// [Typer] infer: If(LE(Int(8), Var("len")), Let(("a", Var({val: None})), Prim(Var("low"), Prim(Prim(Var("len"), Int(4), Div, kind=None), Int(1), Mul, kind=None), Add, kind=None), Let(("c", Var({val: None})), Prim(Var("low"), Prim(Prim(Var("len"), Int(4), Div, kind=None), Int(3), Mul, kind=None), Add, kind=None), LetRec({tyvars: [], name: ("sort_2", Var({val: None})), args: [("a", Int), ("b", Int)], body: If(LE(Get(Var("arr"), Var("b")), Prim(Get(Var("arr"), Var("a")), Int(1), Sub, kind=None)), Let(("_", Var({val: None})), App(Var("swap"), [Var("arr"), Var("a"), Var("b")]), Put(Var("swaps"), Int(0), Prim(Get(Var("swaps"), Int(0)), Int(1), Add, kind=None))), Unit)}, LetRec({tyvars: [], name: ("sort_3", Var({val: None})), args: [("a", Int), ("b", Int), ("c", Int)], body: Let(("_", Var({val: None})), App(Var("sort_2"), [Var("a"), Var("b")]), Let(("_", Var({val: None})), App(Var("sort_2"), [Var("b"), Var("c")]), App(Var("sort_2"), [Var("a"), Var("b")])))}, Let(("_", Var({val: None})), If(LE(Var("use_median_of_medians"), Prim(Var("len"), Int(1), Sub, kind=None)), Let(("_", Var({val: None})), App(Var("sort_3"), [Prim(Var("a"), Int(1), Sub, kind=None), Var("a"), Prim(Var("a"), Int(1), Add, kind=None)]), Let(("_", Var({val: None})), App(Var("sort_3"), [Prim(Var("b"), Int(1), Sub, kind=None), Var("b"), Prim(Var("b"), Int(1), Add, kind=None)]), App(Var("sort_3"), [Prim(Var("c"), Int(1), Sub, kind=None), Var("c"), Prim(Var("c"), Int(1), Add, kind=None)]))), Unit), App(Var("sort_3"), [Var("a"), Var("b"), Var("c")])))))), Unit)
// [Typer] check: LE(Int(8), Var("len")) against Bool
// [Typer] infer: Int(8)
// [Typer] infer: Var("len")
// [Typer] inst: TypeScheme(([], Var({val: Some(Int)})))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] infer: Let(("a", Var({val: None})), Prim(Var("low"), Prim(Prim(Var("len"), Int(4), Div, kind=None), Int(1), Mul, kind=None), Add, kind=None), Let(("c", Var({val: None})), Prim(Var("low"), Prim(Prim(Var("len"), Int(4), Div, kind=None), Int(3), Mul, kind=None), Add, kind=None), LetRec({tyvars: [], name: ("sort_2", Var({val: None})), args: [("a", Int), ("b", Int)], body: If(LE(Get(Var("arr"), Var("b")), Prim(Get(Var("arr"), Var("a")), Int(1), Sub, kind=None)), Let(("_", Var({val: None})), App(Var("swap"), [Var("arr"), Var("a"), Var("b")]), Put(Var("swaps"), Int(0), Prim(Get(Var("swaps"), Int(0)), Int(1), Add, kind=None))), Unit)}, LetRec({tyvars: [], name: ("sort_3", Var({val: None})), args: [("a", Int), ("b", Int), ("c", Int)], body: Let(("_", Var({val: None})), App(Var("sort_2"), [Var("a"), Var("b")]), Let(("_", Var({val: None})), App(Var("sort_2"), [Var("b"), Var("c")]), App(Var("sort_2"), [Var("a"), Var("b")])))}, Let(("_", Var({val: None})), If(LE(Var("use_median_of_medians"), Prim(Var("len"), Int(1), Sub, kind=None)), Let(("_", Var({val: None})), App(Var("sort_3"), [Prim(Var("a"), Int(1), Sub, kind=None), Var("a"), Prim(Var("a"), Int(1), Add, kind=None)]), Let(("_", Var({val: None})), App(Var("sort_3"), [Prim(Var("b"), Int(1), Sub, kind=None), Var("b"), Prim(Var("b"), Int(1), Add, kind=None)]), App(Var("sort_3"), [Prim(Var("c"), Int(1), Sub, kind=None), Var("c"), Prim(Var("c"), Int(1), Add, kind=None)]))), Unit), App(Var("sort_3"), [Var("a"), Var("b"), Var("c")]))))))
// [Typer] infer: Prim(Var("low"), Prim(Prim(Var("len"), Int(4), Div, kind=None), Int(1), Mul, kind=None), Add, kind=None)
// [Typer] infer: Var("low")
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] infer: Prim(Prim(Var("len"), Int(4), Div, kind=None), Int(1), Mul, kind=None)
// [Typer] infer: Prim(Var("len"), Int(4), Div, kind=None)
// [Typer] infer: Var("len")
// [Typer] inst: TypeScheme(([], Var({val: Some(Int)})))
// [Typer] inst result: Int
// [Typer] infer: Int(4)
// [Typer] unify: Int and Int
// [Typer] infer: Int(1)
// [Typer] unify: Int and Int
// [Typer] unify: Int and Int
// [Typer] unify: Var({val: None}) and Int
// [Typer] union: Var({val: None}) and Int
// [Typer] infer: Let(("c", Var({val: None})), Prim(Var("low"), Prim(Prim(Var("len"), Int(4), Div, kind=None), Int(3), Mul, kind=None), Add, kind=None), LetRec({tyvars: [], name: ("sort_2", Var({val: None})), args: [("a", Int), ("b", Int)], body: If(LE(Get(Var("arr"), Var("b")), Prim(Get(Var("arr"), Var("a")), Int(1), Sub, kind=None)), Let(("_", Var({val: None})), App(Var("swap"), [Var("arr"), Var("a"), Var("b")]), Put(Var("swaps"), Int(0), Prim(Get(Var("swaps"), Int(0)), Int(1), Add, kind=None))), Unit)}, LetRec({tyvars: [], name: ("sort_3", Var({val: None})), args: [("a", Int), ("b", Int), ("c", Int)], body: Let(("_", Var({val: None})), App(Var("sort_2"), [Var("a"), Var("b")]), Let(("_", Var({val: None})), App(Var("sort_2"), [Var("b"), Var("c")]), App(Var("sort_2"), [Var("a"), Var("b")])))}, Let(("_", Var({val: None})), If(LE(Var("use_median_of_medians"), Prim(Var("len"), Int(1), Sub, kind=None)), Let(("_", Var({val: None})), App(Var("sort_3"), [Prim(Var("a"), Int(1), Sub, kind=None), Var("a"), Prim(Var("a"), Int(1), Add, kind=None)]), Let(("_", Var({val: None})), App(Var("sort_3"), [Prim(Var("b"), Int(1), Sub, kind=None), Var("b"), Prim(Var("b"), Int(1), Add, kind=None)]), App(Var("sort_3"), [Prim(Var("c"), Int(1), Sub, kind=None), Var("c"), Prim(Var("c"), Int(1), Add, kind=None)]))), Unit), App(Var("sort_3"), [Var("a"), Var("b"), Var("c")])))))
// [Typer] infer: Prim(Var("low"), Prim(Prim(Var("len"), Int(4), Div, kind=None), Int(3), Mul, kind=None), Add, kind=None)
// [Typer] infer: Var("low")
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] infer: Prim(Prim(Var("len"), Int(4), Div, kind=None), Int(3), Mul, kind=None)
// [Typer] infer: Prim(Var("len"), Int(4), Div, kind=None)
// [Typer] infer: Var("len")
// [Typer] inst: TypeScheme(([], Var({val: Some(Int)})))
// [Typer] inst result: Int
// [Typer] infer: Int(4)
// [Typer] unify: Int and Int
// [Typer] infer: Int(3)
// [Typer] unify: Int and Int
// [Typer] unify: Int and Int
// [Typer] unify: Var({val: None}) and Int
// [Typer] union: Var({val: None}) and Int
// [Typer] infer: LetRec({tyvars: [], name: ("sort_2", Var({val: None})), args: [("a", Int), ("b", Int)], body: If(LE(Get(Var("arr"), Var("b")), Prim(Get(Var("arr"), Var("a")), Int(1), Sub, kind=None)), Let(("_", Var({val: None})), App(Var("swap"), [Var("arr"), Var("a"), Var("b")]), Put(Var("swaps"), Int(0), Prim(Get(Var("swaps"), Int(0)), Int(1), Add, kind=None))), Unit)}, LetRec({tyvars: [], name: ("sort_3", Var({val: None})), args: [("a", Int), ("b", Int), ("c", Int)], body: Let(("_", Var({val: None})), App(Var("sort_2"), [Var("a"), Var("b")]), Let(("_", Var({val: None})), App(Var("sort_2"), [Var("b"), Var("c")]), App(Var("sort_2"), [Var("a"), Var("b")])))}, Let(("_", Var({val: None})), If(LE(Var("use_median_of_medians"), Prim(Var("len"), Int(1), Sub, kind=None)), Let(("_", Var({val: None})), App(Var("sort_3"), [Prim(Var("a"), Int(1), Sub, kind=None), Var("a"), Prim(Var("a"), Int(1), Add, kind=None)]), Let(("_", Var({val: None})), App(Var("sort_3"), [Prim(Var("b"), Int(1), Sub, kind=None), Var("b"), Prim(Var("b"), Int(1), Add, kind=None)]), App(Var("sort_3"), [Prim(Var("c"), Int(1), Sub, kind=None), Var("c"), Prim(Var("c"), Int(1), Add, kind=None)]))), Unit), App(Var("sort_3"), [Var("a"), Var("b"), Var("c")]))))
// [Typer] typevars: []
// [Typer] infer: If(LE(Get(Var("arr"), Var("b")), Prim(Get(Var("arr"), Var("a")), Int(1), Sub, kind=None)), Let(("_", Var({val: None})), App(Var("swap"), [Var("arr"), Var("a"), Var("b")]), Put(Var("swaps"), Int(0), Prim(Get(Var("swaps"), Int(0)), Int(1), Add, kind=None))), Unit)
// [Typer] check: LE(Get(Var("arr"), Var("b")), Prim(Get(Var("arr"), Var("a")), Int(1), Sub, kind=None)) against Bool
// [Typer] infer: Get(Var("arr"), Var("b"))
// [Typer] infer: Var("arr")
// [Typer] inst: TypeScheme(([], Array(Int)))
// [Typer] inst result: Array(Int)
// [Typer] check: Var("b") against Int
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] infer: Prim(Get(Var("arr"), Var("a")), Int(1), Sub, kind=None)
// [Typer] infer: Get(Var("arr"), Var("a"))
// [Typer] infer: Var("arr")
// [Typer] inst: TypeScheme(([], Array(Int)))
// [Typer] inst result: Array(Int)
// [Typer] check: Var("a") against Int
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] infer: Int(1)
// [Typer] unify: Int and Int
// [Typer] unify: Int and Int
// [Typer] infer: Let(("_", Var({val: None})), App(Var("swap"), [Var("arr"), Var("a"), Var("b")]), Put(Var("swaps"), Int(0), Prim(Get(Var("swaps"), Int(0)), Int(1), Add, kind=None)))
// [Typer] infer: App(Var("swap"), [Var("arr"), Var("a"), Var("b")])
// [Typer] infer: Var("swap")
// [Typer] inst: TypeScheme(([], Fun([Array(Int), Int, Int], Unit)))
// [Typer] inst result: Fun([Array(Int), Int, Int], Unit)
// [Typer] check: Var("arr") against Array(Int)
// [Typer] inst: TypeScheme(([], Array(Int)))
// [Typer] inst result: Array(Int)
// [Typer] unify: Array(Int) and Array(Int)
// [Typer] unify: Int and Int
// [Typer] check: Var("a") against Int
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] check: Var("b") against Int
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] unify: Var({val: None}) and Unit
// [Typer] union: Var({val: None}) and Unit
// [Typer] infer: Put(Var("swaps"), Int(0), Prim(Get(Var("swaps"), Int(0)), Int(1), Add, kind=None))
// [Typer] infer: Prim(Get(Var("swaps"), Int(0)), Int(1), Add, kind=None)
// [Typer] infer: Get(Var("swaps"), Int(0))
// [Typer] infer: Var("swaps")
// [Typer] inst: TypeScheme(([], Var({val: Some(Array(Int))})))
// [Typer] inst result: Array(Int)
// [Typer] check: Int(0) against Int
// [Typer] infer: Int(1)
// [Typer] unify: Int and Int
// [Typer] check: Var("swaps") against Array(Int)
// [Typer] inst: TypeScheme(([], Var({val: Some(Array(Int))})))
// [Typer] inst result: Array(Int)
// [Typer] unify: Array(Int) and Array(Int)
// [Typer] unify: Int and Int
// [Typer] check: Int(0) against Int
// [Typer] infer: Unit
// [Typer] unify: Unit and Unit
// [Typer] unify: Unit and Var({val: None})
// [Typer] union: Unit and Var({val: None})
// [Typer] infer: LetRec({tyvars: [], name: ("sort_3", Var({val: None})), args: [("a", Int), ("b", Int), ("c", Int)], body: Let(("_", Var({val: None})), App(Var("sort_2"), [Var("a"), Var("b")]), Let(("_", Var({val: None})), App(Var("sort_2"), [Var("b"), Var("c")]), App(Var("sort_2"), [Var("a"), Var("b")])))}, Let(("_", Var({val: None})), If(LE(Var("use_median_of_medians"), Prim(Var("len"), Int(1), Sub, kind=None)), Let(("_", Var({val: None})), App(Var("sort_3"), [Prim(Var("a"), Int(1), Sub, kind=None), Var("a"), Prim(Var("a"), Int(1), Add, kind=None)]), Let(("_", Var({val: None})), App(Var("sort_3"), [Prim(Var("b"), Int(1), Sub, kind=None), Var("b"), Prim(Var("b"), Int(1), Add, kind=None)]), App(Var("sort_3"), [Prim(Var("c"), Int(1), Sub, kind=None), Var("c"), Prim(Var("c"), Int(1), Add, kind=None)]))), Unit), App(Var("sort_3"), [Var("a"), Var("b"), Var("c")])))
// [Typer] typevars: []
// [Typer] infer: Let(("_", Var({val: None})), App(Var("sort_2"), [Var("a"), Var("b")]), Let(("_", Var({val: None})), App(Var("sort_2"), [Var("b"), Var("c")]), App(Var("sort_2"), [Var("a"), Var("b")])))
// [Typer] infer: App(Var("sort_2"), [Var("a"), Var("b")])
// [Typer] infer: Var("sort_2")
// [Typer] inst: TypeScheme(([], Fun([Int, Int], Var({val: Some(Unit)}))))
// [Typer] inst result: Fun([Int, Int], Unit)
// [Typer] check: Var("a") against Int
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] check: Var("b") against Int
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] unify: Var({val: None}) and Unit
// [Typer] union: Var({val: None}) and Unit
// [Typer] infer: Let(("_", Var({val: None})), App(Var("sort_2"), [Var("b"), Var("c")]), App(Var("sort_2"), [Var("a"), Var("b")]))
// [Typer] infer: App(Var("sort_2"), [Var("b"), Var("c")])
// [Typer] infer: Var("sort_2")
// [Typer] inst: TypeScheme(([], Fun([Int, Int], Var({val: Some(Unit)}))))
// [Typer] inst result: Fun([Int, Int], Unit)
// [Typer] check: Var("b") against Int
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] check: Var("c") against Int
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] unify: Var({val: None}) and Unit
// [Typer] union: Var({val: None}) and Unit
// [Typer] infer: App(Var("sort_2"), [Var("a"), Var("b")])
// [Typer] infer: Var("sort_2")
// [Typer] inst: TypeScheme(([], Fun([Int, Int], Var({val: Some(Unit)}))))
// [Typer] inst result: Fun([Int, Int], Unit)
// [Typer] check: Var("a") against Int
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] check: Var("b") against Int
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] unify: Unit and Var({val: None})
// [Typer] union: Unit and Var({val: None})
// [Typer] infer: Let(("_", Var({val: None})), If(LE(Var("use_median_of_medians"), Prim(Var("len"), Int(1), Sub, kind=None)), Let(("_", Var({val: None})), App(Var("sort_3"), [Prim(Var("a"), Int(1), Sub, kind=None), Var("a"), Prim(Var("a"), Int(1), Add, kind=None)]), Let(("_", Var({val: None})), App(Var("sort_3"), [Prim(Var("b"), Int(1), Sub, kind=None), Var("b"), Prim(Var("b"), Int(1), Add, kind=None)]), App(Var("sort_3"), [Prim(Var("c"), Int(1), Sub, kind=None), Var("c"), Prim(Var("c"), Int(1), Add, kind=None)]))), Unit), App(Var("sort_3"), [Var("a"), Var("b"), Var("c")]))
// [Typer] infer: If(LE(Var("use_median_of_medians"), Prim(Var("len"), Int(1), Sub, kind=None)), Let(("_", Var({val: None})), App(Var("sort_3"), [Prim(Var("a"), Int(1), Sub, kind=None), Var("a"), Prim(Var("a"), Int(1), Add, kind=None)]), Let(("_", Var({val: None})), App(Var("sort_3"), [Prim(Var("b"), Int(1), Sub, kind=None), Var("b"), Prim(Var("b"), Int(1), Add, kind=None)]), App(Var("sort_3"), [Prim(Var("c"), Int(1), Sub, kind=None), Var("c"), Prim(Var("c"), Int(1), Add, kind=None)]))), Unit)
// [Typer] check: LE(Var("use_median_of_medians"), Prim(Var("len"), Int(1), Sub, kind=None)) against Bool
// [Typer] infer: Var("use_median_of_medians")
// [Typer] inst: TypeScheme(([], Var({val: Some(Int)})))
// [Typer] inst result: Int
// [Typer] infer: Prim(Var("len"), Int(1), Sub, kind=None)
// [Typer] infer: Var("len")
// [Typer] inst: TypeScheme(([], Var({val: Some(Int)})))
// [Typer] inst result: Int
// [Typer] infer: Int(1)
// [Typer] unify: Int and Int
// [Typer] unify: Int and Int
// [Typer] infer: Let(("_", Var({val: None})), App(Var("sort_3"), [Prim(Var("a"), Int(1), Sub, kind=None), Var("a"), Prim(Var("a"), Int(1), Add, kind=None)]), Let(("_", Var({val: None})), App(Var("sort_3"), [Prim(Var("b"), Int(1), Sub, kind=None), Var("b"), Prim(Var("b"), Int(1), Add, kind=None)]), App(Var("sort_3"), [Prim(Var("c"), Int(1), Sub, kind=None), Var("c"), Prim(Var("c"), Int(1), Add, kind=None)])))
// [Typer] infer: App(Var("sort_3"), [Prim(Var("a"), Int(1), Sub, kind=None), Var("a"), Prim(Var("a"), Int(1), Add, kind=None)])
// [Typer] infer: Var("sort_3")
// [Typer] inst: TypeScheme(([], Fun([Int, Int, Int], Var({val: Some(Unit)}))))
// [Typer] inst result: Fun([Int, Int, Int], Unit)
// [Typer] check: Prim(Var("a"), Int(1), Sub, kind=None) against Int
// [Typer] check: Var("a") against Int
// [Typer] inst: TypeScheme(([], Var({val: Some(Int)})))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] check: Int(1) against Int
// [Typer] check: Var("a") against Int
// [Typer] inst: TypeScheme(([], Var({val: Some(Int)})))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] check: Prim(Var("a"), Int(1), Add, kind=None) against Int
// [Typer] check: Var("a") against Int
// [Typer] inst: TypeScheme(([], Var({val: Some(Int)})))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] check: Int(1) against Int
// [Typer] unify: Var({val: None}) and Unit
// [Typer] union: Var({val: None}) and Unit
// [Typer] infer: Let(("_", Var({val: None})), App(Var("sort_3"), [Prim(Var("b"), Int(1), Sub, kind=None), Var("b"), Prim(Var("b"), Int(1), Add, kind=None)]), App(Var("sort_3"), [Prim(Var("c"), Int(1), Sub, kind=None), Var("c"), Prim(Var("c"), Int(1), Add, kind=None)]))
// [Typer] infer: App(Var("sort_3"), [Prim(Var("b"), Int(1), Sub, kind=None), Var("b"), Prim(Var("b"), Int(1), Add, kind=None)])
// [Typer] infer: Var("sort_3")
// [Typer] inst: TypeScheme(([], Fun([Int, Int, Int], Var({val: Some(Unit)}))))
// [Typer] inst result: Fun([Int, Int, Int], Unit)
// [Typer] check: Prim(Var("b"), Int(1), Sub, kind=None) against Int
// [Typer] check: Var("b") against Int
// [Typer] inst: TypeScheme(([], Var({val: Some(Int)})))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] check: Int(1) against Int
// [Typer] check: Var("b") against Int
// [Typer] inst: TypeScheme(([], Var({val: Some(Int)})))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] check: Prim(Var("b"), Int(1), Add, kind=None) against Int
// [Typer] check: Var("b") against Int
// [Typer] inst: TypeScheme(([], Var({val: Some(Int)})))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] check: Int(1) against Int
// [Typer] unify: Var({val: None}) and Unit
// [Typer] union: Var({val: None}) and Unit
// [Typer] infer: App(Var("sort_3"), [Prim(Var("c"), Int(1), Sub, kind=None), Var("c"), Prim(Var("c"), Int(1), Add, kind=None)])
// [Typer] infer: Var("sort_3")
// [Typer] inst: TypeScheme(([], Fun([Int, Int, Int], Var({val: Some(Unit)}))))
// [Typer] inst result: Fun([Int, Int, Int], Unit)
// [Typer] check: Prim(Var("c"), Int(1), Sub, kind=None) against Int
// [Typer] check: Var("c") against Int
// [Typer] inst: TypeScheme(([], Var({val: Some(Int)})))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] check: Int(1) against Int
// [Typer] check: Var("c") against Int
// [Typer] inst: TypeScheme(([], Var({val: Some(Int)})))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] check: Prim(Var("c"), Int(1), Add, kind=None) against Int
// [Typer] check: Var("c") against Int
// [Typer] inst: TypeScheme(([], Var({val: Some(Int)})))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] check: Int(1) against Int
// [Typer] infer: Unit
// [Typer] unify: Unit and Unit
// [Typer] unify: Var({val: None}) and Unit
// [Typer] union: Var({val: None}) and Unit
// [Typer] infer: App(Var("sort_3"), [Var("a"), Var("b"), Var("c")])
// [Typer] infer: Var("sort_3")
// [Typer] inst: TypeScheme(([], Fun([Int, Int, Int], Var({val: Some(Unit)}))))
// [Typer] inst result: Fun([Int, Int, Int], Unit)
// [Typer] check: Var("a") against Int
// [Typer] inst: TypeScheme(([], Var({val: Some(Int)})))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] check: Var("b") against Int
// [Typer] inst: TypeScheme(([], Var({val: Some(Int)})))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] check: Var("c") against Int
// [Typer] inst: TypeScheme(([], Var({val: Some(Int)})))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] infer: Unit
// [Typer] unify: Unit and Unit
// [Typer] unify: Var({val: None}) and Unit
// [Typer] union: Var({val: None}) and Unit
// [Typer] check: Tuple([Var("b"), Eq(Get(Var("swaps"), Int(0)), Int(0))]) against Tuple([Int, Bool])
// [Typer] check: Var("b") against Int
// [Typer] inst: TypeScheme(([], Var({val: Some(Int)})))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] check: Eq(Get(Var("swaps"), Int(0)), Int(0)) against Bool
// [Typer] infer: Get(Var("swaps"), Int(0))
// [Typer] infer: Var("swaps")
// [Typer] inst: TypeScheme(([], Var({val: Some(Array(Int))})))
// [Typer] inst result: Array(Int)
// [Typer] check: Int(0) against Int
// [Typer] infer: Int(0)
// [Typer] unify: Int and Int
// [Typer] check: LetRec({tyvars: [], name: ("quick_sort", Unit), args: [("arr", Array(Int)), ("low", Int), ("high", Int)], body: Let(("len", Var({val: None})), Prim(Var("high"), Var("low"), Sub, kind=None), If(LE(Var("len"), Int(16)), App(Var("insertion_sort"), [Var("arr"), Var("low"), Var("high")]), LetTuple([("pivot_index", Var({val: None})), ("likely_sorted", Var({val: None}))], App(Var("choose_pivot"), [Var("arr"), Var("low"), Var("high")]), LetTuple([("pivot", Var({val: None})), ("partitioned", Var({val: None}))], App(Var("partition"), [Var("arr"), Var("pivot_index"), Var("low"), Var("high")]), Let(("_", Var({val: None})), App(Var("quick_sort"), [Var("arr"), Var("low"), Var("pivot")]), App(Var("quick_sort"), [Var("arr"), Prim(Var("pivot"), Int(1), Add, kind=None), Var("high")]))))))}, LetRec({tyvars: [], name: ("sort", Unit), args: [("x", Array(Int)), ("len", Int)], body: App(Var("quick_sort"), [Var("x"), Int(0), Var("len")])}, LetRec({tyvars: [], name: ("main", Var({val: None})), args: [], body: Let(("len", Var({val: None})), App(Var("read_int"), []), Let(("arr", Var({val: None})), Array(Var("len"), Int(0)), LetRec({tyvars: [], name: ("input", Var({val: None})), args: [("i", Int)], body: If(LE(Var("i"), Prim(Var("len"), Int(1), Sub, kind=None)), Let(("_", Var({val: None})), Put(Var("arr"), Var("i"), App(Var("read_int"), [])), App(Var("input"), [Prim(Var("i"), Int(1), Add, kind=None)])), Unit)}, Let(("_", Var({val: None})), App(Var("input"), [Int(0)]), Let(("_", Var({val: None})), App(Var("sort"), [Var("arr"), Var("len")]), App(Var("output"), [Var("arr"), Int(0), Var("len")]))))))}, Unit))) against Unit
// [Typer] typevars: []
// [Typer] check: Let(("len", Var({val: None})), Prim(Var("high"), Var("low"), Sub, kind=None), If(LE(Var("len"), Int(16)), App(Var("insertion_sort"), [Var("arr"), Var("low"), Var("high")]), LetTuple([("pivot_index", Var({val: None})), ("likely_sorted", Var({val: None}))], App(Var("choose_pivot"), [Var("arr"), Var("low"), Var("high")]), LetTuple([("pivot", Var({val: None})), ("partitioned", Var({val: None}))], App(Var("partition"), [Var("arr"), Var("pivot_index"), Var("low"), Var("high")]), Let(("_", Var({val: None})), App(Var("quick_sort"), [Var("arr"), Var("low"), Var("pivot")]), App(Var("quick_sort"), [Var("arr"), Prim(Var("pivot"), Int(1), Add, kind=None), Var("high")])))))) against Unit
// [Typer] infer: Prim(Var("high"), Var("low"), Sub, kind=None)
// [Typer] infer: Var("high")
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] infer: Var("low")
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] unify: Var({val: None}) and Int
// [Typer] union: Var({val: None}) and Int
// [Typer] check: If(LE(Var("len"), Int(16)), App(Var("insertion_sort"), [Var("arr"), Var("low"), Var("high")]), LetTuple([("pivot_index", Var({val: None})), ("likely_sorted", Var({val: None}))], App(Var("choose_pivot"), [Var("arr"), Var("low"), Var("high")]), LetTuple([("pivot", Var({val: None})), ("partitioned", Var({val: None}))], App(Var("partition"), [Var("arr"), Var("pivot_index"), Var("low"), Var("high")]), Let(("_", Var({val: None})), App(Var("quick_sort"), [Var("arr"), Var("low"), Var("pivot")]), App(Var("quick_sort"), [Var("arr"), Prim(Var("pivot"), Int(1), Add, kind=None), Var("high")]))))) against Unit
// [Typer] check: LE(Var("len"), Int(16)) against Bool
// [Typer] infer: Var("len")
// [Typer] inst: TypeScheme(([], Var({val: Some(Int)})))
// [Typer] inst result: Int
// [Typer] infer: Int(16)
// [Typer] unify: Int and Int
// [Typer] check: App(Var("insertion_sort"), [Var("arr"), Var("low"), Var("high")]) against Unit
// [Typer] infer: Var("arr")
// [Typer] inst: TypeScheme(([], Array(Int)))
// [Typer] inst result: Array(Int)
// [Typer] infer: Var("low")
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] infer: Var("high")
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] check: Var("insertion_sort") against Fun([Array(Int), Int, Int], Unit)
// [Typer] inst: TypeScheme(([], Fun([Array(Int), Int, Int], Unit)))
// [Typer] inst result: Fun([Array(Int), Int, Int], Unit)
// [Typer] unify: Fun([Array(Int), Int, Int], Unit) and Fun([Array(Int), Int, Int], Unit)
// [Typer] unify: Array(Int) and Array(Int)
// [Typer] unify: Int and Int
// [Typer] unify: Int and Int
// [Typer] unify: Int and Int
// [Typer] unify: Unit and Unit
// [Typer] check: LetTuple([("pivot_index", Var({val: None})), ("likely_sorted", Var({val: None}))], App(Var("choose_pivot"), [Var("arr"), Var("low"), Var("high")]), LetTuple([("pivot", Var({val: None})), ("partitioned", Var({val: None}))], App(Var("partition"), [Var("arr"), Var("pivot_index"), Var("low"), Var("high")]), Let(("_", Var({val: None})), App(Var("quick_sort"), [Var("arr"), Var("low"), Var("pivot")]), App(Var("quick_sort"), [Var("arr"), Prim(Var("pivot"), Int(1), Add, kind=None), Var("high")])))) against Unit
// [Typer] infer: App(Var("choose_pivot"), [Var("arr"), Var("low"), Var("high")])
// [Typer] infer: Var("choose_pivot")
// [Typer] inst: TypeScheme(([], Fun([Array(Int), Int, Int], Tuple([Int, Bool]))))
// [Typer] inst result: Fun([Array(Int), Int, Int], Tuple([Int, Bool]))
// [Typer] check: Var("arr") against Array(Int)
// [Typer] inst: TypeScheme(([], Array(Int)))
// [Typer] inst result: Array(Int)
// [Typer] unify: Array(Int) and Array(Int)
// [Typer] unify: Int and Int
// [Typer] check: Var("low") against Int
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] check: Var("high") against Int
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] unify: Var({val: None}) and Int
// [Typer] union: Var({val: None}) and Int
// [Typer] unify: Var({val: None}) and Bool
// [Typer] union: Var({val: None}) and Bool
// [Typer] check: LetTuple([("pivot", Var({val: None})), ("partitioned", Var({val: None}))], App(Var("partition"), [Var("arr"), Var("pivot_index"), Var("low"), Var("high")]), Let(("_", Var({val: None})), App(Var("quick_sort"), [Var("arr"), Var("low"), Var("pivot")]), App(Var("quick_sort"), [Var("arr"), Prim(Var("pivot"), Int(1), Add, kind=None), Var("high")]))) against Unit
// [Typer] infer: App(Var("partition"), [Var("arr"), Var("pivot_index"), Var("low"), Var("high")])
// [Typer] infer: Var("partition")
// [Typer] inst: TypeScheme(([], Fun([Array(Int), Int, Int, Int], Tuple([Int, Bool]))))
// [Typer] inst result: Fun([Array(Int), Int, Int, Int], Tuple([Int, Bool]))
// [Typer] check: Var("arr") against Array(Int)
// [Typer] inst: TypeScheme(([], Array(Int)))
// [Typer] inst result: Array(Int)
// [Typer] unify: Array(Int) and Array(Int)
// [Typer] unify: Int and Int
// [Typer] check: Var("pivot_index") against Int
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] check: Var("low") against Int
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] check: Var("high") against Int
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] unify: Var({val: None}) and Int
// [Typer] union: Var({val: None}) and Int
// [Typer] unify: Var({val: None}) and Bool
// [Typer] union: Var({val: None}) and Bool
// [Typer] check: Let(("_", Var({val: None})), App(Var("quick_sort"), [Var("arr"), Var("low"), Var("pivot")]), App(Var("quick_sort"), [Var("arr"), Prim(Var("pivot"), Int(1), Add, kind=None), Var("high")])) against Unit
// [Typer] infer: App(Var("quick_sort"), [Var("arr"), Var("low"), Var("pivot")])
// [Typer] infer: Var("quick_sort")
// [Typer] inst: TypeScheme(([], Fun([Array(Int), Int, Int], Unit)))
// [Typer] inst result: Fun([Array(Int), Int, Int], Unit)
// [Typer] check: Var("arr") against Array(Int)
// [Typer] inst: TypeScheme(([], Array(Int)))
// [Typer] inst result: Array(Int)
// [Typer] unify: Array(Int) and Array(Int)
// [Typer] unify: Int and Int
// [Typer] check: Var("low") against Int
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] check: Var("pivot") against Int
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] unify: Var({val: None}) and Unit
// [Typer] union: Var({val: None}) and Unit
// [Typer] check: App(Var("quick_sort"), [Var("arr"), Prim(Var("pivot"), Int(1), Add, kind=None), Var("high")]) against Unit
// [Typer] infer: Var("arr")
// [Typer] inst: TypeScheme(([], Array(Int)))
// [Typer] inst result: Array(Int)
// [Typer] infer: Prim(Var("pivot"), Int(1), Add, kind=None)
// [Typer] infer: Var("pivot")
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] infer: Int(1)
// [Typer] unify: Int and Int
// [Typer] infer: Var("high")
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] check: Var("quick_sort") against Fun([Array(Int), Int, Int], Unit)
// [Typer] inst: TypeScheme(([], Fun([Array(Int), Int, Int], Unit)))
// [Typer] inst result: Fun([Array(Int), Int, Int], Unit)
// [Typer] unify: Fun([Array(Int), Int, Int], Unit) and Fun([Array(Int), Int, Int], Unit)
// [Typer] unify: Array(Int) and Array(Int)
// [Typer] unify: Int and Int
// [Typer] unify: Int and Int
// [Typer] unify: Int and Int
// [Typer] unify: Unit and Unit
// [Typer] check: LetRec({tyvars: [], name: ("sort", Unit), args: [("x", Array(Int)), ("len", Int)], body: App(Var("quick_sort"), [Var("x"), Int(0), Var("len")])}, LetRec({tyvars: [], name: ("main", Var({val: None})), args: [], body: Let(("len", Var({val: None})), App(Var("read_int"), []), Let(("arr", Var({val: None})), Array(Var("len"), Int(0)), LetRec({tyvars: [], name: ("input", Var({val: None})), args: [("i", Int)], body: If(LE(Var("i"), Prim(Var("len"), Int(1), Sub, kind=None)), Let(("_", Var({val: None})), Put(Var("arr"), Var("i"), App(Var("read_int"), [])), App(Var("input"), [Prim(Var("i"), Int(1), Add, kind=None)])), Unit)}, Let(("_", Var({val: None})), App(Var("input"), [Int(0)]), Let(("_", Var({val: None})), App(Var("sort"), [Var("arr"), Var("len")]), App(Var("output"), [Var("arr"), Int(0), Var("len")]))))))}, Unit)) against Unit
// [Typer] typevars: []
// [Typer] check: App(Var("quick_sort"), [Var("x"), Int(0), Var("len")]) against Unit
// [Typer] infer: Var("x")
// [Typer] inst: TypeScheme(([], Array(Int)))
// [Typer] inst result: Array(Int)
// [Typer] infer: Int(0)
// [Typer] infer: Var("len")
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] check: Var("quick_sort") against Fun([Array(Int), Int, Int], Unit)
// [Typer] inst: TypeScheme(([], Fun([Array(Int), Int, Int], Unit)))
// [Typer] inst result: Fun([Array(Int), Int, Int], Unit)
// [Typer] unify: Fun([Array(Int), Int, Int], Unit) and Fun([Array(Int), Int, Int], Unit)
// [Typer] unify: Array(Int) and Array(Int)
// [Typer] unify: Int and Int
// [Typer] unify: Int and Int
// [Typer] unify: Int and Int
// [Typer] unify: Unit and Unit
// [Typer] check: LetRec({tyvars: [], name: ("main", Var({val: None})), args: [], body: Let(("len", Var({val: None})), App(Var("read_int"), []), Let(("arr", Var({val: None})), Array(Var("len"), Int(0)), LetRec({tyvars: [], name: ("input", Var({val: None})), args: [("i", Int)], body: If(LE(Var("i"), Prim(Var("len"), Int(1), Sub, kind=None)), Let(("_", Var({val: None})), Put(Var("arr"), Var("i"), App(Var("read_int"), [])), App(Var("input"), [Prim(Var("i"), Int(1), Add, kind=None)])), Unit)}, Let(("_", Var({val: None})), App(Var("input"), [Int(0)]), Let(("_", Var({val: None})), App(Var("sort"), [Var("arr"), Var("len")]), App(Var("output"), [Var("arr"), Int(0), Var("len")]))))))}, Unit) against Unit
// [Typer] typevars: []
// [Typer] infer: Let(("len", Var({val: None})), App(Var("read_int"), []), Let(("arr", Var({val: None})), Array(Var("len"), Int(0)), LetRec({tyvars: [], name: ("input", Var({val: None})), args: [("i", Int)], body: If(LE(Var("i"), Prim(Var("len"), Int(1), Sub, kind=None)), Let(("_", Var({val: None})), Put(Var("arr"), Var("i"), App(Var("read_int"), [])), App(Var("input"), [Prim(Var("i"), Int(1), Add, kind=None)])), Unit)}, Let(("_", Var({val: None})), App(Var("input"), [Int(0)]), Let(("_", Var({val: None})), App(Var("sort"), [Var("arr"), Var("len")]), App(Var("output"), [Var("arr"), Int(0), Var("len")]))))))
// [Typer] infer: App(Var("read_int"), [])
// [Typer] infer: Var("read_int")
// [Typer] inst: TypeScheme(([], Fun([], Int)))
// [Typer] inst result: Fun([], Int)
// [Typer] unify: Var({val: None}) and Int
// [Typer] union: Var({val: None}) and Int
// [Typer] infer: Let(("arr", Var({val: None})), Array(Var("len"), Int(0)), LetRec({tyvars: [], name: ("input", Var({val: None})), args: [("i", Int)], body: If(LE(Var("i"), Prim(Var("len"), Int(1), Sub, kind=None)), Let(("_", Var({val: None})), Put(Var("arr"), Var("i"), App(Var("read_int"), [])), App(Var("input"), [Prim(Var("i"), Int(1), Add, kind=None)])), Unit)}, Let(("_", Var({val: None})), App(Var("input"), [Int(0)]), Let(("_", Var({val: None})), App(Var("sort"), [Var("arr"), Var("len")]), App(Var("output"), [Var("arr"), Int(0), Var("len")])))))
// [Typer] infer: Array(Var("len"), Int(0))
// [Typer] infer: Int(0)
// [Typer] check: Var("len") against Int
// [Typer] inst: TypeScheme(([], Var({val: Some(Int)})))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] unify: Var({val: None}) and Array(Int)
// [Typer] union: Var({val: None}) and Array(Int)
// [Typer] infer: LetRec({tyvars: [], name: ("input", Var({val: None})), args: [("i", Int)], body: If(LE(Var("i"), Prim(Var("len"), Int(1), Sub, kind=None)), Let(("_", Var({val: None})), Put(Var("arr"), Var("i"), App(Var("read_int"), [])), App(Var("input"), [Prim(Var("i"), Int(1), Add, kind=None)])), Unit)}, Let(("_", Var({val: None})), App(Var("input"), [Int(0)]), Let(("_", Var({val: None})), App(Var("sort"), [Var("arr"), Var("len")]), App(Var("output"), [Var("arr"), Int(0), Var("len")]))))
// [Typer] typevars: []
// [Typer] infer: If(LE(Var("i"), Prim(Var("len"), Int(1), Sub, kind=None)), Let(("_", Var({val: None})), Put(Var("arr"), Var("i"), App(Var("read_int"), [])), App(Var("input"), [Prim(Var("i"), Int(1), Add, kind=None)])), Unit)
// [Typer] check: LE(Var("i"), Prim(Var("len"), Int(1), Sub, kind=None)) against Bool
// [Typer] infer: Var("i")
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] infer: Prim(Var("len"), Int(1), Sub, kind=None)
// [Typer] infer: Var("len")
// [Typer] inst: TypeScheme(([], Var({val: Some(Int)})))
// [Typer] inst result: Int
// [Typer] infer: Int(1)
// [Typer] unify: Int and Int
// [Typer] unify: Int and Int
// [Typer] infer: Let(("_", Var({val: None})), Put(Var("arr"), Var("i"), App(Var("read_int"), [])), App(Var("input"), [Prim(Var("i"), Int(1), Add, kind=None)]))
// [Typer] infer: Put(Var("arr"), Var("i"), App(Var("read_int"), []))
// [Typer] infer: App(Var("read_int"), [])
// [Typer] infer: Var("read_int")
// [Typer] inst: TypeScheme(([], Fun([], Int)))
// [Typer] inst result: Fun([], Int)
// [Typer] check: Var("arr") against Array(Int)
// [Typer] inst: TypeScheme(([], Var({val: Some(Array(Int))})))
// [Typer] inst result: Array(Int)
// [Typer] unify: Array(Int) and Array(Int)
// [Typer] unify: Int and Int
// [Typer] check: Var("i") against Int
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] unify: Var({val: None}) and Unit
// [Typer] union: Var({val: None}) and Unit
// [Typer] infer: App(Var("input"), [Prim(Var("i"), Int(1), Add, kind=None)])
// [Typer] infer: Var("input")
// [Typer] inst: TypeScheme(([], Fun([Int], Var({val: None}))))
// [Typer] inst result: Fun([Int], Var({val: None}))
// [Typer] check: Prim(Var("i"), Int(1), Add, kind=None) against Int
// [Typer] check: Var("i") against Int
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] check: Int(1) against Int
// [Typer] infer: Unit
// [Typer] unify: Var({val: None}) and Unit
// [Typer] union: Var({val: None}) and Unit
// [Typer] unify: Unit and Var({val: Some(Unit)})
// [Typer] infer: Let(("_", Var({val: None})), App(Var("input"), [Int(0)]), Let(("_", Var({val: None})), App(Var("sort"), [Var("arr"), Var("len")]), App(Var("output"), [Var("arr"), Int(0), Var("len")])))
// [Typer] infer: App(Var("input"), [Int(0)])
// [Typer] infer: Var("input")
// [Typer] inst: TypeScheme(([], Fun([Int], Var({val: Some(Unit)}))))
// [Typer] inst result: Fun([Int], Unit)
// [Typer] check: Int(0) against Int
// [Typer] unify: Var({val: None}) and Unit
// [Typer] union: Var({val: None}) and Unit
// [Typer] infer: Let(("_", Var({val: None})), App(Var("sort"), [Var("arr"), Var("len")]), App(Var("output"), [Var("arr"), Int(0), Var("len")]))
// [Typer] infer: App(Var("sort"), [Var("arr"), Var("len")])
// [Typer] infer: Var("sort")
// [Typer] inst: TypeScheme(([], Fun([Array(Int), Int], Unit)))
// [Typer] inst result: Fun([Array(Int), Int], Unit)
// [Typer] check: Var("arr") against Array(Int)
// [Typer] inst: TypeScheme(([], Var({val: Some(Array(Int))})))
// [Typer] inst result: Array(Int)
// [Typer] unify: Array(Int) and Array(Int)
// [Typer] unify: Int and Int
// [Typer] check: Var("len") against Int
// [Typer] inst: TypeScheme(([], Var({val: Some(Int)})))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] unify: Var({val: None}) and Unit
// [Typer] union: Var({val: None}) and Unit
// [Typer] infer: App(Var("output"), [Var("arr"), Int(0), Var("len")])
// [Typer] infer: Var("output")
// [Typer] inst: TypeScheme(([], Fun([Array(Int), Int, Int], Unit)))
// [Typer] inst result: Fun([Array(Int), Int, Int], Unit)
// [Typer] check: Var("arr") against Array(Int)
// [Typer] inst: TypeScheme(([], Var({val: Some(Array(Int))})))
// [Typer] inst result: Array(Int)
// [Typer] unify: Array(Int) and Array(Int)
// [Typer] unify: Int and Int
// [Typer] check: Int(0) against Int
// [Typer] check: Var("len") against Int
// [Typer] inst: TypeScheme(([], Var({val: Some(Int)})))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] unify: Unit and Var({val: None})
// [Typer] union: Unit and Var({val: None})
// [Typer] check: Unit against Unit
// [Parser] flags: []
