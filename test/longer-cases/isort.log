// [Knf] build_knf: LetRec({tyvars: [], name: ("random", Int), args: [("state", Int)], body: Prim(Prim(Var("state"), Int(75), Mul, kind=Some(Int)), Int(74), Add, kind=Some(Int))}, LetRec({tyvars: [], name: ("modulo", Int), args: [("x", Int), ("y", Int)], body: Let(("q", Int), Prim(Var("x"), Var("y"), Div, kind=Some(Int)), Prim(Var("x"), Prim(Var("q"), Var("y"), Mul, kind=Some(Int)), Sub, kind=Some(Int)))}, LetRec({tyvars: [], name: ("fill_buffer", Unit), args: [("arr", Array(Int)), ("n", Int)], body: LetRec({tyvars: [], name: ("aux", Unit), args: [("i", Int), ("state", Int)], body: If(Eq(Var("i"), Var("n")), Unit, Let(("new_state", Int), App(Var("random"), [Var("state")]), Let(("res", Int), App(Var("modulo"), [Var("new_state"), Int(65537)]), Let(("_", Unit), Put(Var("arr"), Var("i"), Var("res")), App(Var("aux"), [Prim(Var("i"), Int(1), Add, kind=Some(Int)), Var("res")])))))}, App(Var("aux"), [Int(0), Int(12345)]))}, LetRec({tyvars: [], name: ("isort", Unit), args: [("arr", Array(Int)), ("n", Int)], body: LetRec({tyvars: [], name: ("insert", Unit), args: [("arr", Array(Int)), ("i", Int)], body: If(Eq(Var("i"), Int(0)), Unit, If(LE(Get(Var("arr"), Prim(Var("i"), Int(1), Sub, kind=Some(Int))), Get(Var("arr"), Var("i"))), Unit, Let(("tmp", Int), Get(Var("arr"), Var("i")), Let(("_", Unit), Put(Var("arr"), Var("i"), Get(Var("arr"), Prim(Var("i"), Int(1), Sub, kind=Some(Int)))), Let(("_", Unit), Put(Var("arr"), Prim(Var("i"), Int(1), Sub, kind=Some(Int)), Var("tmp")), App(Var("insert"), [Var("arr"), Prim(Var("i"), Int(1), Sub, kind=Some(Int))]))))))}, LetRec({tyvars: [], name: ("aux", Unit), args: [("i", Int)], body: If(Eq(Var("i"), Var("n")), Unit, Let(("_", Unit), App(Var("insert"), [Var("arr"), Var("i")]), App(Var("aux"), [Prim(Var("i"), Int(1), Add, kind=Some(Int))])))}, App(Var("aux"), [Int(1)])))}, LetRec({tyvars: [], name: ("print_array", Unit), args: [("arr", Array(Int)), ("n", Int)], body: LetRec({tyvars: [], name: ("aux", Unit), args: [("i", Int)], body: If(Eq(Var("i"), Var("n")), Unit, Let(("_", Unit), App(Var("print_int"), [Get(Var("arr"), Var("i"))]), Let(("_", Unit), App(Var("print_char"), [Int(32)]), App(Var("aux"), [Prim(Var("i"), Int(1), Add, kind=Some(Int))]))))}, App(Var("aux"), [Int(0)]))}, LetRec({tyvars: [], name: ("main", Unit), args: [], body: Let(("n", Int), Int(100), Let(("arr", Array(Int)), Array(Var("n"), Int(0)), Let(("_", Unit), App(Var("fill_buffer"), [Var("arr"), Var("n")]), Let(("_", Unit), App(Var("isort"), [Var("arr"), Var("n")]), App(Var("print_array"), [Var("arr"), Var("n")])))))}, App(Var("main"), [])))))))
// [Knf] build_knf: Prim(Prim(Var("state"), Int(75), Mul, kind=Some(Int)), Int(74), Add, kind=Some(Int))
// [Knf] build_knf: Prim(Var("state"), Int(75), Mul, kind=Some(Int))
// [Knf] build_knf: Var("state")
// [Knf] build_knf: Int(75)
// [Knf] build_knf: Int(74)
// [Knf] build_knf: LetRec({tyvars: [], name: ("modulo", Int), args: [("x", Int), ("y", Int)], body: Let(("q", Int), Prim(Var("x"), Var("y"), Div, kind=Some(Int)), Prim(Var("x"), Prim(Var("q"), Var("y"), Mul, kind=Some(Int)), Sub, kind=Some(Int)))}, LetRec({tyvars: [], name: ("fill_buffer", Unit), args: [("arr", Array(Int)), ("n", Int)], body: LetRec({tyvars: [], name: ("aux", Unit), args: [("i", Int), ("state", Int)], body: If(Eq(Var("i"), Var("n")), Unit, Let(("new_state", Int), App(Var("random"), [Var("state")]), Let(("res", Int), App(Var("modulo"), [Var("new_state"), Int(65537)]), Let(("_", Unit), Put(Var("arr"), Var("i"), Var("res")), App(Var("aux"), [Prim(Var("i"), Int(1), Add, kind=Some(Int)), Var("res")])))))}, App(Var("aux"), [Int(0), Int(12345)]))}, LetRec({tyvars: [], name: ("isort", Unit), args: [("arr", Array(Int)), ("n", Int)], body: LetRec({tyvars: [], name: ("insert", Unit), args: [("arr", Array(Int)), ("i", Int)], body: If(Eq(Var("i"), Int(0)), Unit, If(LE(Get(Var("arr"), Prim(Var("i"), Int(1), Sub, kind=Some(Int))), Get(Var("arr"), Var("i"))), Unit, Let(("tmp", Int), Get(Var("arr"), Var("i")), Let(("_", Unit), Put(Var("arr"), Var("i"), Get(Var("arr"), Prim(Var("i"), Int(1), Sub, kind=Some(Int)))), Let(("_", Unit), Put(Var("arr"), Prim(Var("i"), Int(1), Sub, kind=Some(Int)), Var("tmp")), App(Var("insert"), [Var("arr"), Prim(Var("i"), Int(1), Sub, kind=Some(Int))]))))))}, LetRec({tyvars: [], name: ("aux", Unit), args: [("i", Int)], body: If(Eq(Var("i"), Var("n")), Unit, Let(("_", Unit), App(Var("insert"), [Var("arr"), Var("i")]), App(Var("aux"), [Prim(Var("i"), Int(1), Add, kind=Some(Int))])))}, App(Var("aux"), [Int(1)])))}, LetRec({tyvars: [], name: ("print_array", Unit), args: [("arr", Array(Int)), ("n", Int)], body: LetRec({tyvars: [], name: ("aux", Unit), args: [("i", Int)], body: If(Eq(Var("i"), Var("n")), Unit, Let(("_", Unit), App(Var("print_int"), [Get(Var("arr"), Var("i"))]), Let(("_", Unit), App(Var("print_char"), [Int(32)]), App(Var("aux"), [Prim(Var("i"), Int(1), Add, kind=Some(Int))]))))}, App(Var("aux"), [Int(0)]))}, LetRec({tyvars: [], name: ("main", Unit), args: [], body: Let(("n", Int), Int(100), Let(("arr", Array(Int)), Array(Var("n"), Int(0)), Let(("_", Unit), App(Var("fill_buffer"), [Var("arr"), Var("n")]), Let(("_", Unit), App(Var("isort"), [Var("arr"), Var("n")]), App(Var("print_array"), [Var("arr"), Var("n")])))))}, App(Var("main"), []))))))
// [Knf] build_knf: Let(("q", Int), Prim(Var("x"), Var("y"), Div, kind=Some(Int)), Prim(Var("x"), Prim(Var("q"), Var("y"), Mul, kind=Some(Int)), Sub, kind=Some(Int)))
// [Knf] build_knf: Prim(Var("x"), Var("y"), Div, kind=Some(Int))
// [Knf] build_knf: Var("x")
// [Knf] build_knf: Var("y")
// [Knf] build_knf: Prim(Var("x"), Prim(Var("q"), Var("y"), Mul, kind=Some(Int)), Sub, kind=Some(Int))
// [Knf] build_knf: Var("x")
// [Knf] build_knf: Prim(Var("q"), Var("y"), Mul, kind=Some(Int))
// [Knf] build_knf: Var("q")
// [Knf] build_knf: Var("y")
// [Knf] build_knf: LetRec({tyvars: [], name: ("fill_buffer", Unit), args: [("arr", Array(Int)), ("n", Int)], body: LetRec({tyvars: [], name: ("aux", Unit), args: [("i", Int), ("state", Int)], body: If(Eq(Var("i"), Var("n")), Unit, Let(("new_state", Int), App(Var("random"), [Var("state")]), Let(("res", Int), App(Var("modulo"), [Var("new_state"), Int(65537)]), Let(("_", Unit), Put(Var("arr"), Var("i"), Var("res")), App(Var("aux"), [Prim(Var("i"), Int(1), Add, kind=Some(Int)), Var("res")])))))}, App(Var("aux"), [Int(0), Int(12345)]))}, LetRec({tyvars: [], name: ("isort", Unit), args: [("arr", Array(Int)), ("n", Int)], body: LetRec({tyvars: [], name: ("insert", Unit), args: [("arr", Array(Int)), ("i", Int)], body: If(Eq(Var("i"), Int(0)), Unit, If(LE(Get(Var("arr"), Prim(Var("i"), Int(1), Sub, kind=Some(Int))), Get(Var("arr"), Var("i"))), Unit, Let(("tmp", Int), Get(Var("arr"), Var("i")), Let(("_", Unit), Put(Var("arr"), Var("i"), Get(Var("arr"), Prim(Var("i"), Int(1), Sub, kind=Some(Int)))), Let(("_", Unit), Put(Var("arr"), Prim(Var("i"), Int(1), Sub, kind=Some(Int)), Var("tmp")), App(Var("insert"), [Var("arr"), Prim(Var("i"), Int(1), Sub, kind=Some(Int))]))))))}, LetRec({tyvars: [], name: ("aux", Unit), args: [("i", Int)], body: If(Eq(Var("i"), Var("n")), Unit, Let(("_", Unit), App(Var("insert"), [Var("arr"), Var("i")]), App(Var("aux"), [Prim(Var("i"), Int(1), Add, kind=Some(Int))])))}, App(Var("aux"), [Int(1)])))}, LetRec({tyvars: [], name: ("print_array", Unit), args: [("arr", Array(Int)), ("n", Int)], body: LetRec({tyvars: [], name: ("aux", Unit), args: [("i", Int)], body: If(Eq(Var("i"), Var("n")), Unit, Let(("_", Unit), App(Var("print_int"), [Get(Var("arr"), Var("i"))]), Let(("_", Unit), App(Var("print_char"), [Int(32)]), App(Var("aux"), [Prim(Var("i"), Int(1), Add, kind=Some(Int))]))))}, App(Var("aux"), [Int(0)]))}, LetRec({tyvars: [], name: ("main", Unit), args: [], body: Let(("n", Int), Int(100), Let(("arr", Array(Int)), Array(Var("n"), Int(0)), Let(("_", Unit), App(Var("fill_buffer"), [Var("arr"), Var("n")]), Let(("_", Unit), App(Var("isort"), [Var("arr"), Var("n")]), App(Var("print_array"), [Var("arr"), Var("n")])))))}, App(Var("main"), [])))))
// [Knf] build_knf: LetRec({tyvars: [], name: ("aux", Unit), args: [("i", Int), ("state", Int)], body: If(Eq(Var("i"), Var("n")), Unit, Let(("new_state", Int), App(Var("random"), [Var("state")]), Let(("res", Int), App(Var("modulo"), [Var("new_state"), Int(65537)]), Let(("_", Unit), Put(Var("arr"), Var("i"), Var("res")), App(Var("aux"), [Prim(Var("i"), Int(1), Add, kind=Some(Int)), Var("res")])))))}, App(Var("aux"), [Int(0), Int(12345)]))
// [Knf] build_knf: If(Eq(Var("i"), Var("n")), Unit, Let(("new_state", Int), App(Var("random"), [Var("state")]), Let(("res", Int), App(Var("modulo"), [Var("new_state"), Int(65537)]), Let(("_", Unit), Put(Var("arr"), Var("i"), Var("res")), App(Var("aux"), [Prim(Var("i"), Int(1), Add, kind=Some(Int)), Var("res")])))))
// [Knf] build_knf: Var("i")
// [Knf] build_knf: Var("n")
// [Knf] build_knf: Unit
// [Knf] build_knf: Let(("new_state", Int), App(Var("random"), [Var("state")]), Let(("res", Int), App(Var("modulo"), [Var("new_state"), Int(65537)]), Let(("_", Unit), Put(Var("arr"), Var("i"), Var("res")), App(Var("aux"), [Prim(Var("i"), Int(1), Add, kind=Some(Int)), Var("res")]))))
// [Knf] build_knf: App(Var("random"), [Var("state")])
// [Knf] build_knf: Var("random")
// [Knf] build_knf: Var("state")
// [Knf] build_knf: Let(("res", Int), App(Var("modulo"), [Var("new_state"), Int(65537)]), Let(("_", Unit), Put(Var("arr"), Var("i"), Var("res")), App(Var("aux"), [Prim(Var("i"), Int(1), Add, kind=Some(Int)), Var("res")])))
// [Knf] build_knf: App(Var("modulo"), [Var("new_state"), Int(65537)])
// [Knf] build_knf: Var("modulo")
// [Knf] build_knf: Var("new_state")
// [Knf] build_knf: Int(65537)
// [Knf] build_knf: Let(("_", Unit), Put(Var("arr"), Var("i"), Var("res")), App(Var("aux"), [Prim(Var("i"), Int(1), Add, kind=Some(Int)), Var("res")]))
// [Knf] build_knf: Put(Var("arr"), Var("i"), Var("res"))
// [Knf] build_knf: Var("arr")
// [Knf] build_knf: Var("i")
// [Knf] build_knf: Var("res")
// [Knf] build_knf: App(Var("aux"), [Prim(Var("i"), Int(1), Add, kind=Some(Int)), Var("res")])
// [Knf] build_knf: Var("aux")
// [Knf] build_knf: Prim(Var("i"), Int(1), Add, kind=Some(Int))
// [Knf] build_knf: Var("i")
// [Knf] build_knf: Int(1)
// [Knf] build_knf: Var("res")
// [Knf] build_knf: App(Var("aux"), [Int(0), Int(12345)])
// [Knf] build_knf: Var("aux")
// [Knf] build_knf: Int(0)
// [Knf] build_knf: Int(12345)
// [Knf] build_knf: LetRec({tyvars: [], name: ("isort", Unit), args: [("arr", Array(Int)), ("n", Int)], body: LetRec({tyvars: [], name: ("insert", Unit), args: [("arr", Array(Int)), ("i", Int)], body: If(Eq(Var("i"), Int(0)), Unit, If(LE(Get(Var("arr"), Prim(Var("i"), Int(1), Sub, kind=Some(Int))), Get(Var("arr"), Var("i"))), Unit, Let(("tmp", Int), Get(Var("arr"), Var("i")), Let(("_", Unit), Put(Var("arr"), Var("i"), Get(Var("arr"), Prim(Var("i"), Int(1), Sub, kind=Some(Int)))), Let(("_", Unit), Put(Var("arr"), Prim(Var("i"), Int(1), Sub, kind=Some(Int)), Var("tmp")), App(Var("insert"), [Var("arr"), Prim(Var("i"), Int(1), Sub, kind=Some(Int))]))))))}, LetRec({tyvars: [], name: ("aux", Unit), args: [("i", Int)], body: If(Eq(Var("i"), Var("n")), Unit, Let(("_", Unit), App(Var("insert"), [Var("arr"), Var("i")]), App(Var("aux"), [Prim(Var("i"), Int(1), Add, kind=Some(Int))])))}, App(Var("aux"), [Int(1)])))}, LetRec({tyvars: [], name: ("print_array", Unit), args: [("arr", Array(Int)), ("n", Int)], body: LetRec({tyvars: [], name: ("aux", Unit), args: [("i", Int)], body: If(Eq(Var("i"), Var("n")), Unit, Let(("_", Unit), App(Var("print_int"), [Get(Var("arr"), Var("i"))]), Let(("_", Unit), App(Var("print_char"), [Int(32)]), App(Var("aux"), [Prim(Var("i"), Int(1), Add, kind=Some(Int))]))))}, App(Var("aux"), [Int(0)]))}, LetRec({tyvars: [], name: ("main", Unit), args: [], body: Let(("n", Int), Int(100), Let(("arr", Array(Int)), Array(Var("n"), Int(0)), Let(("_", Unit), App(Var("fill_buffer"), [Var("arr"), Var("n")]), Let(("_", Unit), App(Var("isort"), [Var("arr"), Var("n")]), App(Var("print_array"), [Var("arr"), Var("n")])))))}, App(Var("main"), []))))
// [Knf] build_knf: LetRec({tyvars: [], name: ("insert", Unit), args: [("arr", Array(Int)), ("i", Int)], body: If(Eq(Var("i"), Int(0)), Unit, If(LE(Get(Var("arr"), Prim(Var("i"), Int(1), Sub, kind=Some(Int))), Get(Var("arr"), Var("i"))), Unit, Let(("tmp", Int), Get(Var("arr"), Var("i")), Let(("_", Unit), Put(Var("arr"), Var("i"), Get(Var("arr"), Prim(Var("i"), Int(1), Sub, kind=Some(Int)))), Let(("_", Unit), Put(Var("arr"), Prim(Var("i"), Int(1), Sub, kind=Some(Int)), Var("tmp")), App(Var("insert"), [Var("arr"), Prim(Var("i"), Int(1), Sub, kind=Some(Int))]))))))}, LetRec({tyvars: [], name: ("aux", Unit), args: [("i", Int)], body: If(Eq(Var("i"), Var("n")), Unit, Let(("_", Unit), App(Var("insert"), [Var("arr"), Var("i")]), App(Var("aux"), [Prim(Var("i"), Int(1), Add, kind=Some(Int))])))}, App(Var("aux"), [Int(1)])))
// [Knf] build_knf: If(Eq(Var("i"), Int(0)), Unit, If(LE(Get(Var("arr"), Prim(Var("i"), Int(1), Sub, kind=Some(Int))), Get(Var("arr"), Var("i"))), Unit, Let(("tmp", Int), Get(Var("arr"), Var("i")), Let(("_", Unit), Put(Var("arr"), Var("i"), Get(Var("arr"), Prim(Var("i"), Int(1), Sub, kind=Some(Int)))), Let(("_", Unit), Put(Var("arr"), Prim(Var("i"), Int(1), Sub, kind=Some(Int)), Var("tmp")), App(Var("insert"), [Var("arr"), Prim(Var("i"), Int(1), Sub, kind=Some(Int))]))))))
// [Knf] build_knf: Var("i")
// [Knf] build_knf: Int(0)
// [Knf] build_knf: Unit
// [Knf] build_knf: If(LE(Get(Var("arr"), Prim(Var("i"), Int(1), Sub, kind=Some(Int))), Get(Var("arr"), Var("i"))), Unit, Let(("tmp", Int), Get(Var("arr"), Var("i")), Let(("_", Unit), Put(Var("arr"), Var("i"), Get(Var("arr"), Prim(Var("i"), Int(1), Sub, kind=Some(Int)))), Let(("_", Unit), Put(Var("arr"), Prim(Var("i"), Int(1), Sub, kind=Some(Int)), Var("tmp")), App(Var("insert"), [Var("arr"), Prim(Var("i"), Int(1), Sub, kind=Some(Int))])))))
// [Knf] build_knf: Get(Var("arr"), Prim(Var("i"), Int(1), Sub, kind=Some(Int)))
// [Knf] build_knf: Var("arr")
// [Knf] build_knf: Prim(Var("i"), Int(1), Sub, kind=Some(Int))
// [Knf] build_knf: Var("i")
// [Knf] build_knf: Int(1)
// [Knf] build_knf: Get(Var("arr"), Var("i"))
// [Knf] build_knf: Var("arr")
// [Knf] build_knf: Var("i")
// [Knf] build_knf: Unit
// [Knf] build_knf: Let(("tmp", Int), Get(Var("arr"), Var("i")), Let(("_", Unit), Put(Var("arr"), Var("i"), Get(Var("arr"), Prim(Var("i"), Int(1), Sub, kind=Some(Int)))), Let(("_", Unit), Put(Var("arr"), Prim(Var("i"), Int(1), Sub, kind=Some(Int)), Var("tmp")), App(Var("insert"), [Var("arr"), Prim(Var("i"), Int(1), Sub, kind=Some(Int))]))))
// [Knf] build_knf: Get(Var("arr"), Var("i"))
// [Knf] build_knf: Var("arr")
// [Knf] build_knf: Var("i")
// [Knf] build_knf: Let(("_", Unit), Put(Var("arr"), Var("i"), Get(Var("arr"), Prim(Var("i"), Int(1), Sub, kind=Some(Int)))), Let(("_", Unit), Put(Var("arr"), Prim(Var("i"), Int(1), Sub, kind=Some(Int)), Var("tmp")), App(Var("insert"), [Var("arr"), Prim(Var("i"), Int(1), Sub, kind=Some(Int))])))
// [Knf] build_knf: Put(Var("arr"), Var("i"), Get(Var("arr"), Prim(Var("i"), Int(1), Sub, kind=Some(Int))))
// [Knf] build_knf: Var("arr")
// [Knf] build_knf: Var("i")
// [Knf] build_knf: Get(Var("arr"), Prim(Var("i"), Int(1), Sub, kind=Some(Int)))
// [Knf] build_knf: Var("arr")
// [Knf] build_knf: Prim(Var("i"), Int(1), Sub, kind=Some(Int))
// [Knf] build_knf: Var("i")
// [Knf] build_knf: Int(1)
// [Knf] build_knf: Let(("_", Unit), Put(Var("arr"), Prim(Var("i"), Int(1), Sub, kind=Some(Int)), Var("tmp")), App(Var("insert"), [Var("arr"), Prim(Var("i"), Int(1), Sub, kind=Some(Int))]))
// [Knf] build_knf: Put(Var("arr"), Prim(Var("i"), Int(1), Sub, kind=Some(Int)), Var("tmp"))
// [Knf] build_knf: Var("arr")
// [Knf] build_knf: Prim(Var("i"), Int(1), Sub, kind=Some(Int))
// [Knf] build_knf: Var("i")
// [Knf] build_knf: Int(1)
// [Knf] build_knf: Var("tmp")
// [Knf] build_knf: App(Var("insert"), [Var("arr"), Prim(Var("i"), Int(1), Sub, kind=Some(Int))])
// [Knf] build_knf: Var("insert")
// [Knf] build_knf: Var("arr")
// [Knf] build_knf: Prim(Var("i"), Int(1), Sub, kind=Some(Int))
// [Knf] build_knf: Var("i")
// [Knf] build_knf: Int(1)
// [Knf] build_knf: LetRec({tyvars: [], name: ("aux", Unit), args: [("i", Int)], body: If(Eq(Var("i"), Var("n")), Unit, Let(("_", Unit), App(Var("insert"), [Var("arr"), Var("i")]), App(Var("aux"), [Prim(Var("i"), Int(1), Add, kind=Some(Int))])))}, App(Var("aux"), [Int(1)]))
// [Knf] build_knf: If(Eq(Var("i"), Var("n")), Unit, Let(("_", Unit), App(Var("insert"), [Var("arr"), Var("i")]), App(Var("aux"), [Prim(Var("i"), Int(1), Add, kind=Some(Int))])))
// [Knf] build_knf: Var("i")
// [Knf] build_knf: Var("n")
// [Knf] build_knf: Unit
// [Knf] build_knf: Let(("_", Unit), App(Var("insert"), [Var("arr"), Var("i")]), App(Var("aux"), [Prim(Var("i"), Int(1), Add, kind=Some(Int))]))
// [Knf] build_knf: App(Var("insert"), [Var("arr"), Var("i")])
// [Knf] build_knf: Var("insert")
// [Knf] build_knf: Var("arr")
// [Knf] build_knf: Var("i")
// [Knf] build_knf: App(Var("aux"), [Prim(Var("i"), Int(1), Add, kind=Some(Int))])
// [Knf] build_knf: Var("aux")
// [Knf] build_knf: Prim(Var("i"), Int(1), Add, kind=Some(Int))
// [Knf] build_knf: Var("i")
// [Knf] build_knf: Int(1)
// [Knf] build_knf: App(Var("aux"), [Int(1)])
// [Knf] build_knf: Var("aux")
// [Knf] build_knf: Int(1)
// [Knf] build_knf: LetRec({tyvars: [], name: ("print_array", Unit), args: [("arr", Array(Int)), ("n", Int)], body: LetRec({tyvars: [], name: ("aux", Unit), args: [("i", Int)], body: If(Eq(Var("i"), Var("n")), Unit, Let(("_", Unit), App(Var("print_int"), [Get(Var("arr"), Var("i"))]), Let(("_", Unit), App(Var("print_char"), [Int(32)]), App(Var("aux"), [Prim(Var("i"), Int(1), Add, kind=Some(Int))]))))}, App(Var("aux"), [Int(0)]))}, LetRec({tyvars: [], name: ("main", Unit), args: [], body: Let(("n", Int), Int(100), Let(("arr", Array(Int)), Array(Var("n"), Int(0)), Let(("_", Unit), App(Var("fill_buffer"), [Var("arr"), Var("n")]), Let(("_", Unit), App(Var("isort"), [Var("arr"), Var("n")]), App(Var("print_array"), [Var("arr"), Var("n")])))))}, App(Var("main"), [])))
// [Knf] build_knf: LetRec({tyvars: [], name: ("aux", Unit), args: [("i", Int)], body: If(Eq(Var("i"), Var("n")), Unit, Let(("_", Unit), App(Var("print_int"), [Get(Var("arr"), Var("i"))]), Let(("_", Unit), App(Var("print_char"), [Int(32)]), App(Var("aux"), [Prim(Var("i"), Int(1), Add, kind=Some(Int))]))))}, App(Var("aux"), [Int(0)]))
// [Knf] build_knf: If(Eq(Var("i"), Var("n")), Unit, Let(("_", Unit), App(Var("print_int"), [Get(Var("arr"), Var("i"))]), Let(("_", Unit), App(Var("print_char"), [Int(32)]), App(Var("aux"), [Prim(Var("i"), Int(1), Add, kind=Some(Int))]))))
// [Knf] build_knf: Var("i")
// [Knf] build_knf: Var("n")
// [Knf] build_knf: Unit
// [Knf] build_knf: Let(("_", Unit), App(Var("print_int"), [Get(Var("arr"), Var("i"))]), Let(("_", Unit), App(Var("print_char"), [Int(32)]), App(Var("aux"), [Prim(Var("i"), Int(1), Add, kind=Some(Int))])))
// [Knf] build_knf: App(Var("print_int"), [Get(Var("arr"), Var("i"))])
// [Knf] build_knf: Get(Var("arr"), Var("i"))
// [Knf] build_knf: Var("arr")
// [Knf] build_knf: Var("i")
// [Knf] build_knf: Let(("_", Unit), App(Var("print_char"), [Int(32)]), App(Var("aux"), [Prim(Var("i"), Int(1), Add, kind=Some(Int))]))
// [Knf] build_knf: App(Var("print_char"), [Int(32)])
// [Knf] build_knf: Int(32)
// [Knf] build_knf: App(Var("aux"), [Prim(Var("i"), Int(1), Add, kind=Some(Int))])
// [Knf] build_knf: Var("aux")
// [Knf] build_knf: Prim(Var("i"), Int(1), Add, kind=Some(Int))
// [Knf] build_knf: Var("i")
// [Knf] build_knf: Int(1)
// [Knf] build_knf: App(Var("aux"), [Int(0)])
// [Knf] build_knf: Var("aux")
// [Knf] build_knf: Int(0)
// [Knf] build_knf: LetRec({tyvars: [], name: ("main", Unit), args: [], body: Let(("n", Int), Int(100), Let(("arr", Array(Int)), Array(Var("n"), Int(0)), Let(("_", Unit), App(Var("fill_buffer"), [Var("arr"), Var("n")]), Let(("_", Unit), App(Var("isort"), [Var("arr"), Var("n")]), App(Var("print_array"), [Var("arr"), Var("n")])))))}, App(Var("main"), []))
// [Knf] build_knf: Let(("n", Int), Int(100), Let(("arr", Array(Int)), Array(Var("n"), Int(0)), Let(("_", Unit), App(Var("fill_buffer"), [Var("arr"), Var("n")]), Let(("_", Unit), App(Var("isort"), [Var("arr"), Var("n")]), App(Var("print_array"), [Var("arr"), Var("n")])))))
// [Knf] build_knf: Int(100)
// [Knf] build_knf: Let(("arr", Array(Int)), Array(Var("n"), Int(0)), Let(("_", Unit), App(Var("fill_buffer"), [Var("arr"), Var("n")]), Let(("_", Unit), App(Var("isort"), [Var("arr"), Var("n")]), App(Var("print_array"), [Var("arr"), Var("n")]))))
// [Knf] build_knf: Array(Var("n"), Int(0))
// [Knf] build_knf: Var("n")
// [Knf] build_knf: Int(0)
// [Knf] build_knf: Let(("_", Unit), App(Var("fill_buffer"), [Var("arr"), Var("n")]), Let(("_", Unit), App(Var("isort"), [Var("arr"), Var("n")]), App(Var("print_array"), [Var("arr"), Var("n")])))
// [Knf] build_knf: App(Var("fill_buffer"), [Var("arr"), Var("n")])
// [Knf] build_knf: Var("fill_buffer")
// [Knf] build_knf: Var("arr")
// [Knf] build_knf: Var("n")
// [Knf] build_knf: Let(("_", Unit), App(Var("isort"), [Var("arr"), Var("n")]), App(Var("print_array"), [Var("arr"), Var("n")]))
// [Knf] build_knf: App(Var("isort"), [Var("arr"), Var("n")])
// [Knf] build_knf: Var("isort")
// [Knf] build_knf: Var("arr")
// [Knf] build_knf: Var("n")
// [Knf] build_knf: App(Var("print_array"), [Var("arr"), Var("n")])
// [Knf] build_knf: Var("print_array")
// [Knf] build_knf: Var("arr")
// [Knf] build_knf: Var("n")
// [Knf] build_knf: App(Var("main"), [])
// [Knf] build_knf: Var("main")
// [Main] function thunk_main(k) {
// [Main]   function random_1(state_3, k) {
// [Main]     const _4 = 75;
// [Main]     const _5 = state_3 * _4;
// [Main]     const _6 = 74;
// [Main]     return k(_5 + _6)
// [Main]   }
// [Main]   function modulo_7(x_9, y_11, k) {
// [Main]     const q_12 = x_9 / y_11;
// [Main]     const _13 = q_12 * y_11;
// [Main]     return k(x_9 - _13)
// [Main]   }
// [Main]   function fill_buffer_14(arr_16, n_18, k) {
// [Main]     function aux_19(i_21, state_23, k) {
// [Main]       if (i_21 === n_18) {
// [Main]         return k(null)
// [Main]       } else {
// [Main]         return $thunk(() => random_1(state_23, function (new_state_24) {
// [Main]           const _25 = 65537;
// [Main]           return $thunk(() => modulo_7(new_state_24, _25, function (res_26) {
// [Main]             const _28 = arr_16[i_21] = res_26;
// [Main]             const _29 = 1;
// [Main]             const _30 = i_21 + _29;
// [Main]             return $thunk(() => aux_19(_30, res_26, k))
// [Main]           }
// [Main]           ))
// [Main]         }
// [Main]         ))
// [Main]       }
// [Main]     }
// [Main]     const _31 = 0;
// [Main]     const _32 = 12345;
// [Main]     return $thunk(() => aux_19(_31, _32, k))
// [Main]   }
// [Main]   function isort_33(arr_35, n_37, k) {
// [Main]     function insert_38(arr_40, i_42, k) {
// [Main]       const _43 = 0;
// [Main]       if (i_42 === _43) {
// [Main]         return k(null)
// [Main]       } else {
// [Main]         const _44 = 1;
// [Main]         const _45 = i_42 - _44;
// [Main]         const _46 = arr_40[_45];
// [Main]         const _47 = arr_40[i_42];
// [Main]         if (_46 <= _47) {
// [Main]           return k(null)
// [Main]         } else {
// [Main]           const tmp_48 = arr_40[i_42];
// [Main]           const _49 = 1;
// [Main]           const _50 = i_42 - _49;
// [Main]           const _51 = arr_40[_50];
// [Main]           const _53 = arr_40[i_42] = _51;
// [Main]           const _54 = 1;
// [Main]           const _55 = i_42 - _54;
// [Main]           const _57 = arr_40[_55] = tmp_48;
// [Main]           const _58 = 1;
// [Main]           const _59 = i_42 - _58;
// [Main]           return $thunk(() => insert_38(arr_40, _59, k))
// [Main]         }
// [Main]       }
// [Main]     }
// [Main]     function aux_60(i_62, k) {
// [Main]       if (i_62 === n_37) {
// [Main]         return k(null)
// [Main]       } else {
// [Main]         return $thunk(() => insert_38(arr_35, i_62, function (_64) {
// [Main]           const _65 = 1;
// [Main]           const _66 = i_62 + _65;
// [Main]           return $thunk(() => aux_60(_66, k))
// [Main]         }
// [Main]         ))
// [Main]       }
// [Main]     }
// [Main]     const _67 = 1;
// [Main]     return $thunk(() => aux_60(_67, k))
// [Main]   }
// [Main]   function print_array_68(arr_70, n_72, k) {
// [Main]     function aux_73(i_75, k) {
// [Main]       if (i_75 === n_72) {
// [Main]         return k(null)
// [Main]       } else {
// [Main]         const _76 = arr_70[i_75];
// [Main]         const _78 = minimbt_print_int($force(_76));
// [Main]         const _79 = 32;
// [Main]         const _81 = minimbt_print_char($force(_79));
// [Main]         const _82 = 1;
// [Main]         const _83 = i_75 + _82;
// [Main]         return $thunk(() => aux_73(_83, k))
// [Main]       }
// [Main]     }
// [Main]     const _84 = 0;
// [Main]     return $thunk(() => aux_73(_84, k))
// [Main]   }
// [Main]   function main_85(k) {
// [Main]     const n_86 = 100;
// [Main]     const _87 = 0;
// [Main]     const arr_88 = minimbt_create_array($force(n_86), $force(_87));
// [Main]     return $thunk(() => fill_buffer_14(arr_88, n_86, function (_90) {
// [Main]       return $thunk(() => isort_33(arr_88, n_86, function (_92) {
// [Main]         return $thunk(() => print_array_68(arr_88, n_86, k))
// [Main]       }
// [Main]       ))
// [Main]     }
// [Main]     ))
// [Main]   }
// [Main]   return $thunk(() => main_85(k))
// [Main] }
// [Main] 
// [Main] function $thunk(lambda) {
// [Main]   return { thunk: lambda };
// [Main] }
// [Main] function $is_thunk(x) {
// [Main]   return x && x.hasOwnProperty('thunk') && x.thunk !== undefined;
// [Main] }
// [Main] function $force(x) {
// [Main]   while ($is_thunk(x)) {
// [Main]     x = x.thunk();
// [Main]   }
// [Main]   return x;
// [Main] }
// [Main] function $trampoline(f, ...args) {
// [Main]   let x = f(...args);
// [Main]   return $force(x);
// [Main] }
// [Main] export default () => $trampoline(thunk_main, x => x);
// [Typer] check: LetRec({tyvars: [], name: ("random", Int), args: [("state", Int)], body: Prim(Prim(Var("state"), Int(75), Mul, kind=None), Int(74), Add, kind=None)}, LetRec({tyvars: [], name: ("modulo", Int), args: [("x", Int), ("y", Int)], body: Let(("q", Var({val: None})), Prim(Var("x"), Var("y"), Div, kind=None), Prim(Var("x"), Prim(Var("q"), Var("y"), Mul, kind=None), Sub, kind=None))}, LetRec({tyvars: [], name: ("fill_buffer", Unit), args: [("arr", Array(Int)), ("n", Int)], body: LetRec({tyvars: [], name: ("aux", Unit), args: [("i", Int), ("state", Int)], body: If(Eq(Var("i"), Var("n")), Unit, Let(("new_state", Var({val: None})), App(Var("random"), [Var("state")]), Let(("res", Var({val: None})), App(Var("modulo"), [Var("new_state"), Int(65537)]), Let(("_", Var({val: None})), Put(Var("arr"), Var("i"), Var("res")), App(Var("aux"), [Prim(Var("i"), Int(1), Add, kind=None), Var("res")])))))}, App(Var("aux"), [Int(0), Int(12345)]))}, LetRec({tyvars: [], name: ("isort", Unit), args: [("arr", Array(Int)), ("n", Int)], body: LetRec({tyvars: [], name: ("insert", Unit), args: [("arr", Array(Int)), ("i", Int)], body: If(Eq(Var("i"), Int(0)), Unit, If(LE(Get(Var("arr"), Prim(Var("i"), Int(1), Sub, kind=None)), Get(Var("arr"), Var("i"))), Unit, Let(("tmp", Var({val: None})), Get(Var("arr"), Var("i")), Let(("_", Var({val: None})), Put(Var("arr"), Var("i"), Get(Var("arr"), Prim(Var("i"), Int(1), Sub, kind=None))), Let(("_", Var({val: None})), Put(Var("arr"), Prim(Var("i"), Int(1), Sub, kind=None), Var("tmp")), App(Var("insert"), [Var("arr"), Prim(Var("i"), Int(1), Sub, kind=None)]))))))}, LetRec({tyvars: [], name: ("aux", Unit), args: [("i", Int)], body: If(Eq(Var("i"), Var("n")), Unit, Let(("_", Var({val: None})), App(Var("insert"), [Var("arr"), Var("i")]), App(Var("aux"), [Prim(Var("i"), Int(1), Add, kind=None)])))}, App(Var("aux"), [Int(1)])))}, LetRec({tyvars: [], name: ("print_array", Unit), args: [("arr", Array(Int)), ("n", Int)], body: LetRec({tyvars: [], name: ("aux", Unit), args: [("i", Int)], body: If(Eq(Var("i"), Var("n")), Unit, Let(("_", Var({val: None})), App(Var("print_int"), [Get(Var("arr"), Var("i"))]), Let(("_", Var({val: None})), App(Var("print_char"), [Int(32)]), App(Var("aux"), [Prim(Var("i"), Int(1), Add, kind=None)]))))}, App(Var("aux"), [Int(0)]))}, LetRec({tyvars: [], name: ("main", Var({val: None})), args: [], body: Let(("n", Var({val: None})), Int(100), Let(("arr", Var({val: None})), Array(Var("n"), Int(0)), Let(("_", Var({val: None})), App(Var("fill_buffer"), [Var("arr"), Var("n")]), Let(("_", Var({val: None})), App(Var("isort"), [Var("arr"), Var("n")]), App(Var("print_array"), [Var("arr"), Var("n")])))))}, Unit)))))) against Unit
// [Typer] typevars: []
// [Typer] check: Prim(Prim(Var("state"), Int(75), Mul, kind=None), Int(74), Add, kind=None) against Int
// [Typer] check: Prim(Var("state"), Int(75), Mul, kind=None) against Int
// [Typer] check: Var("state") against Int
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] check: Int(75) against Int
// [Typer] check: Int(74) against Int
// [Typer] check: LetRec({tyvars: [], name: ("modulo", Int), args: [("x", Int), ("y", Int)], body: Let(("q", Var({val: None})), Prim(Var("x"), Var("y"), Div, kind=None), Prim(Var("x"), Prim(Var("q"), Var("y"), Mul, kind=None), Sub, kind=None))}, LetRec({tyvars: [], name: ("fill_buffer", Unit), args: [("arr", Array(Int)), ("n", Int)], body: LetRec({tyvars: [], name: ("aux", Unit), args: [("i", Int), ("state", Int)], body: If(Eq(Var("i"), Var("n")), Unit, Let(("new_state", Var({val: None})), App(Var("random"), [Var("state")]), Let(("res", Var({val: None})), App(Var("modulo"), [Var("new_state"), Int(65537)]), Let(("_", Var({val: None})), Put(Var("arr"), Var("i"), Var("res")), App(Var("aux"), [Prim(Var("i"), Int(1), Add, kind=None), Var("res")])))))}, App(Var("aux"), [Int(0), Int(12345)]))}, LetRec({tyvars: [], name: ("isort", Unit), args: [("arr", Array(Int)), ("n", Int)], body: LetRec({tyvars: [], name: ("insert", Unit), args: [("arr", Array(Int)), ("i", Int)], body: If(Eq(Var("i"), Int(0)), Unit, If(LE(Get(Var("arr"), Prim(Var("i"), Int(1), Sub, kind=None)), Get(Var("arr"), Var("i"))), Unit, Let(("tmp", Var({val: None})), Get(Var("arr"), Var("i")), Let(("_", Var({val: None})), Put(Var("arr"), Var("i"), Get(Var("arr"), Prim(Var("i"), Int(1), Sub, kind=None))), Let(("_", Var({val: None})), Put(Var("arr"), Prim(Var("i"), Int(1), Sub, kind=None), Var("tmp")), App(Var("insert"), [Var("arr"), Prim(Var("i"), Int(1), Sub, kind=None)]))))))}, LetRec({tyvars: [], name: ("aux", Unit), args: [("i", Int)], body: If(Eq(Var("i"), Var("n")), Unit, Let(("_", Var({val: None})), App(Var("insert"), [Var("arr"), Var("i")]), App(Var("aux"), [Prim(Var("i"), Int(1), Add, kind=None)])))}, App(Var("aux"), [Int(1)])))}, LetRec({tyvars: [], name: ("print_array", Unit), args: [("arr", Array(Int)), ("n", Int)], body: LetRec({tyvars: [], name: ("aux", Unit), args: [("i", Int)], body: If(Eq(Var("i"), Var("n")), Unit, Let(("_", Var({val: None})), App(Var("print_int"), [Get(Var("arr"), Var("i"))]), Let(("_", Var({val: None})), App(Var("print_char"), [Int(32)]), App(Var("aux"), [Prim(Var("i"), Int(1), Add, kind=None)]))))}, App(Var("aux"), [Int(0)]))}, LetRec({tyvars: [], name: ("main", Var({val: None})), args: [], body: Let(("n", Var({val: None})), Int(100), Let(("arr", Var({val: None})), Array(Var("n"), Int(0)), Let(("_", Var({val: None})), App(Var("fill_buffer"), [Var("arr"), Var("n")]), Let(("_", Var({val: None})), App(Var("isort"), [Var("arr"), Var("n")]), App(Var("print_array"), [Var("arr"), Var("n")])))))}, Unit))))) against Unit
// [Typer] typevars: []
// [Typer] check: Let(("q", Var({val: None})), Prim(Var("x"), Var("y"), Div, kind=None), Prim(Var("x"), Prim(Var("q"), Var("y"), Mul, kind=None), Sub, kind=None)) against Int
// [Typer] infer: Prim(Var("x"), Var("y"), Div, kind=None)
// [Typer] infer: Var("x")
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] infer: Var("y")
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] unify: Var({val: None}) and Int
// [Typer] union: Var({val: None}) and Int
// [Typer] check: Prim(Var("x"), Prim(Var("q"), Var("y"), Mul, kind=None), Sub, kind=None) against Int
// [Typer] check: Var("x") against Int
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] check: Prim(Var("q"), Var("y"), Mul, kind=None) against Int
// [Typer] check: Var("q") against Int
// [Typer] inst: TypeScheme(([], Var({val: Some(Int)})))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] check: Var("y") against Int
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] check: LetRec({tyvars: [], name: ("fill_buffer", Unit), args: [("arr", Array(Int)), ("n", Int)], body: LetRec({tyvars: [], name: ("aux", Unit), args: [("i", Int), ("state", Int)], body: If(Eq(Var("i"), Var("n")), Unit, Let(("new_state", Var({val: None})), App(Var("random"), [Var("state")]), Let(("res", Var({val: None})), App(Var("modulo"), [Var("new_state"), Int(65537)]), Let(("_", Var({val: None})), Put(Var("arr"), Var("i"), Var("res")), App(Var("aux"), [Prim(Var("i"), Int(1), Add, kind=None), Var("res")])))))}, App(Var("aux"), [Int(0), Int(12345)]))}, LetRec({tyvars: [], name: ("isort", Unit), args: [("arr", Array(Int)), ("n", Int)], body: LetRec({tyvars: [], name: ("insert", Unit), args: [("arr", Array(Int)), ("i", Int)], body: If(Eq(Var("i"), Int(0)), Unit, If(LE(Get(Var("arr"), Prim(Var("i"), Int(1), Sub, kind=None)), Get(Var("arr"), Var("i"))), Unit, Let(("tmp", Var({val: None})), Get(Var("arr"), Var("i")), Let(("_", Var({val: None})), Put(Var("arr"), Var("i"), Get(Var("arr"), Prim(Var("i"), Int(1), Sub, kind=None))), Let(("_", Var({val: None})), Put(Var("arr"), Prim(Var("i"), Int(1), Sub, kind=None), Var("tmp")), App(Var("insert"), [Var("arr"), Prim(Var("i"), Int(1), Sub, kind=None)]))))))}, LetRec({tyvars: [], name: ("aux", Unit), args: [("i", Int)], body: If(Eq(Var("i"), Var("n")), Unit, Let(("_", Var({val: None})), App(Var("insert"), [Var("arr"), Var("i")]), App(Var("aux"), [Prim(Var("i"), Int(1), Add, kind=None)])))}, App(Var("aux"), [Int(1)])))}, LetRec({tyvars: [], name: ("print_array", Unit), args: [("arr", Array(Int)), ("n", Int)], body: LetRec({tyvars: [], name: ("aux", Unit), args: [("i", Int)], body: If(Eq(Var("i"), Var("n")), Unit, Let(("_", Var({val: None})), App(Var("print_int"), [Get(Var("arr"), Var("i"))]), Let(("_", Var({val: None})), App(Var("print_char"), [Int(32)]), App(Var("aux"), [Prim(Var("i"), Int(1), Add, kind=None)]))))}, App(Var("aux"), [Int(0)]))}, LetRec({tyvars: [], name: ("main", Var({val: None})), args: [], body: Let(("n", Var({val: None})), Int(100), Let(("arr", Var({val: None})), Array(Var("n"), Int(0)), Let(("_", Var({val: None})), App(Var("fill_buffer"), [Var("arr"), Var("n")]), Let(("_", Var({val: None})), App(Var("isort"), [Var("arr"), Var("n")]), App(Var("print_array"), [Var("arr"), Var("n")])))))}, Unit)))) against Unit
// [Typer] typevars: []
// [Typer] check: LetRec({tyvars: [], name: ("aux", Unit), args: [("i", Int), ("state", Int)], body: If(Eq(Var("i"), Var("n")), Unit, Let(("new_state", Var({val: None})), App(Var("random"), [Var("state")]), Let(("res", Var({val: None})), App(Var("modulo"), [Var("new_state"), Int(65537)]), Let(("_", Var({val: None})), Put(Var("arr"), Var("i"), Var("res")), App(Var("aux"), [Prim(Var("i"), Int(1), Add, kind=None), Var("res")])))))}, App(Var("aux"), [Int(0), Int(12345)])) against Unit
// [Typer] typevars: []
// [Typer] check: If(Eq(Var("i"), Var("n")), Unit, Let(("new_state", Var({val: None})), App(Var("random"), [Var("state")]), Let(("res", Var({val: None})), App(Var("modulo"), [Var("new_state"), Int(65537)]), Let(("_", Var({val: None})), Put(Var("arr"), Var("i"), Var("res")), App(Var("aux"), [Prim(Var("i"), Int(1), Add, kind=None), Var("res")]))))) against Unit
// [Typer] check: Eq(Var("i"), Var("n")) against Bool
// [Typer] infer: Var("i")
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] infer: Var("n")
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] check: Unit against Unit
// [Typer] check: Let(("new_state", Var({val: None})), App(Var("random"), [Var("state")]), Let(("res", Var({val: None})), App(Var("modulo"), [Var("new_state"), Int(65537)]), Let(("_", Var({val: None})), Put(Var("arr"), Var("i"), Var("res")), App(Var("aux"), [Prim(Var("i"), Int(1), Add, kind=None), Var("res")])))) against Unit
// [Typer] infer: App(Var("random"), [Var("state")])
// [Typer] infer: Var("random")
// [Typer] inst: TypeScheme(([], Fun([Int], Int)))
// [Typer] inst result: Fun([Int], Int)
// [Typer] check: Var("state") against Int
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] unify: Var({val: None}) and Int
// [Typer] union: Var({val: None}) and Int
// [Typer] check: Let(("res", Var({val: None})), App(Var("modulo"), [Var("new_state"), Int(65537)]), Let(("_", Var({val: None})), Put(Var("arr"), Var("i"), Var("res")), App(Var("aux"), [Prim(Var("i"), Int(1), Add, kind=None), Var("res")]))) against Unit
// [Typer] infer: App(Var("modulo"), [Var("new_state"), Int(65537)])
// [Typer] infer: Var("modulo")
// [Typer] inst: TypeScheme(([], Fun([Int, Int], Int)))
// [Typer] inst result: Fun([Int, Int], Int)
// [Typer] check: Var("new_state") against Int
// [Typer] inst: TypeScheme(([], Var({val: Some(Int)})))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] check: Int(65537) against Int
// [Typer] unify: Var({val: None}) and Int
// [Typer] union: Var({val: None}) and Int
// [Typer] check: Let(("_", Var({val: None})), Put(Var("arr"), Var("i"), Var("res")), App(Var("aux"), [Prim(Var("i"), Int(1), Add, kind=None), Var("res")])) against Unit
// [Typer] infer: Put(Var("arr"), Var("i"), Var("res"))
// [Typer] infer: Var("res")
// [Typer] inst: TypeScheme(([], Var({val: Some(Int)})))
// [Typer] inst result: Int
// [Typer] check: Var("arr") against Array(Int)
// [Typer] inst: TypeScheme(([], Array(Int)))
// [Typer] inst result: Array(Int)
// [Typer] unify: Array(Int) and Array(Int)
// [Typer] unify: Int and Int
// [Typer] check: Var("i") against Int
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] unify: Var({val: None}) and Unit
// [Typer] union: Var({val: None}) and Unit
// [Typer] check: App(Var("aux"), [Prim(Var("i"), Int(1), Add, kind=None), Var("res")]) against Unit
// [Typer] infer: Prim(Var("i"), Int(1), Add, kind=None)
// [Typer] infer: Var("i")
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] infer: Int(1)
// [Typer] unify: Int and Int
// [Typer] infer: Var("res")
// [Typer] inst: TypeScheme(([], Var({val: Some(Int)})))
// [Typer] inst result: Int
// [Typer] check: Var("aux") against Fun([Int, Int], Unit)
// [Typer] inst: TypeScheme(([], Fun([Int, Int], Unit)))
// [Typer] inst result: Fun([Int, Int], Unit)
// [Typer] unify: Fun([Int, Int], Unit) and Fun([Int, Int], Unit)
// [Typer] unify: Int and Int
// [Typer] unify: Int and Int
// [Typer] unify: Unit and Unit
// [Typer] check: App(Var("aux"), [Int(0), Int(12345)]) against Unit
// [Typer] infer: Int(0)
// [Typer] infer: Int(12345)
// [Typer] check: Var("aux") against Fun([Int, Int], Unit)
// [Typer] inst: TypeScheme(([], Fun([Int, Int], Unit)))
// [Typer] inst result: Fun([Int, Int], Unit)
// [Typer] unify: Fun([Int, Int], Unit) and Fun([Int, Int], Unit)
// [Typer] unify: Int and Int
// [Typer] unify: Int and Int
// [Typer] unify: Unit and Unit
// [Typer] check: LetRec({tyvars: [], name: ("isort", Unit), args: [("arr", Array(Int)), ("n", Int)], body: LetRec({tyvars: [], name: ("insert", Unit), args: [("arr", Array(Int)), ("i", Int)], body: If(Eq(Var("i"), Int(0)), Unit, If(LE(Get(Var("arr"), Prim(Var("i"), Int(1), Sub, kind=None)), Get(Var("arr"), Var("i"))), Unit, Let(("tmp", Var({val: None})), Get(Var("arr"), Var("i")), Let(("_", Var({val: None})), Put(Var("arr"), Var("i"), Get(Var("arr"), Prim(Var("i"), Int(1), Sub, kind=None))), Let(("_", Var({val: None})), Put(Var("arr"), Prim(Var("i"), Int(1), Sub, kind=None), Var("tmp")), App(Var("insert"), [Var("arr"), Prim(Var("i"), Int(1), Sub, kind=None)]))))))}, LetRec({tyvars: [], name: ("aux", Unit), args: [("i", Int)], body: If(Eq(Var("i"), Var("n")), Unit, Let(("_", Var({val: None})), App(Var("insert"), [Var("arr"), Var("i")]), App(Var("aux"), [Prim(Var("i"), Int(1), Add, kind=None)])))}, App(Var("aux"), [Int(1)])))}, LetRec({tyvars: [], name: ("print_array", Unit), args: [("arr", Array(Int)), ("n", Int)], body: LetRec({tyvars: [], name: ("aux", Unit), args: [("i", Int)], body: If(Eq(Var("i"), Var("n")), Unit, Let(("_", Var({val: None})), App(Var("print_int"), [Get(Var("arr"), Var("i"))]), Let(("_", Var({val: None})), App(Var("print_char"), [Int(32)]), App(Var("aux"), [Prim(Var("i"), Int(1), Add, kind=None)]))))}, App(Var("aux"), [Int(0)]))}, LetRec({tyvars: [], name: ("main", Var({val: None})), args: [], body: Let(("n", Var({val: None})), Int(100), Let(("arr", Var({val: None})), Array(Var("n"), Int(0)), Let(("_", Var({val: None})), App(Var("fill_buffer"), [Var("arr"), Var("n")]), Let(("_", Var({val: None})), App(Var("isort"), [Var("arr"), Var("n")]), App(Var("print_array"), [Var("arr"), Var("n")])))))}, Unit))) against Unit
// [Typer] typevars: []
// [Typer] check: LetRec({tyvars: [], name: ("insert", Unit), args: [("arr", Array(Int)), ("i", Int)], body: If(Eq(Var("i"), Int(0)), Unit, If(LE(Get(Var("arr"), Prim(Var("i"), Int(1), Sub, kind=None)), Get(Var("arr"), Var("i"))), Unit, Let(("tmp", Var({val: None})), Get(Var("arr"), Var("i")), Let(("_", Var({val: None})), Put(Var("arr"), Var("i"), Get(Var("arr"), Prim(Var("i"), Int(1), Sub, kind=None))), Let(("_", Var({val: None})), Put(Var("arr"), Prim(Var("i"), Int(1), Sub, kind=None), Var("tmp")), App(Var("insert"), [Var("arr"), Prim(Var("i"), Int(1), Sub, kind=None)]))))))}, LetRec({tyvars: [], name: ("aux", Unit), args: [("i", Int)], body: If(Eq(Var("i"), Var("n")), Unit, Let(("_", Var({val: None})), App(Var("insert"), [Var("arr"), Var("i")]), App(Var("aux"), [Prim(Var("i"), Int(1), Add, kind=None)])))}, App(Var("aux"), [Int(1)]))) against Unit
// [Typer] typevars: []
// [Typer] check: If(Eq(Var("i"), Int(0)), Unit, If(LE(Get(Var("arr"), Prim(Var("i"), Int(1), Sub, kind=None)), Get(Var("arr"), Var("i"))), Unit, Let(("tmp", Var({val: None})), Get(Var("arr"), Var("i")), Let(("_", Var({val: None})), Put(Var("arr"), Var("i"), Get(Var("arr"), Prim(Var("i"), Int(1), Sub, kind=None))), Let(("_", Var({val: None})), Put(Var("arr"), Prim(Var("i"), Int(1), Sub, kind=None), Var("tmp")), App(Var("insert"), [Var("arr"), Prim(Var("i"), Int(1), Sub, kind=None)])))))) against Unit
// [Typer] check: Eq(Var("i"), Int(0)) against Bool
// [Typer] infer: Var("i")
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] infer: Int(0)
// [Typer] unify: Int and Int
// [Typer] check: Unit against Unit
// [Typer] check: If(LE(Get(Var("arr"), Prim(Var("i"), Int(1), Sub, kind=None)), Get(Var("arr"), Var("i"))), Unit, Let(("tmp", Var({val: None})), Get(Var("arr"), Var("i")), Let(("_", Var({val: None})), Put(Var("arr"), Var("i"), Get(Var("arr"), Prim(Var("i"), Int(1), Sub, kind=None))), Let(("_", Var({val: None})), Put(Var("arr"), Prim(Var("i"), Int(1), Sub, kind=None), Var("tmp")), App(Var("insert"), [Var("arr"), Prim(Var("i"), Int(1), Sub, kind=None)]))))) against Unit
// [Typer] check: LE(Get(Var("arr"), Prim(Var("i"), Int(1), Sub, kind=None)), Get(Var("arr"), Var("i"))) against Bool
// [Typer] infer: Get(Var("arr"), Prim(Var("i"), Int(1), Sub, kind=None))
// [Typer] infer: Var("arr")
// [Typer] inst: TypeScheme(([], Array(Int)))
// [Typer] inst result: Array(Int)
// [Typer] check: Prim(Var("i"), Int(1), Sub, kind=None) against Int
// [Typer] check: Var("i") against Int
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] check: Int(1) against Int
// [Typer] infer: Get(Var("arr"), Var("i"))
// [Typer] infer: Var("arr")
// [Typer] inst: TypeScheme(([], Array(Int)))
// [Typer] inst result: Array(Int)
// [Typer] check: Var("i") against Int
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] unify: Int and Int
// [Typer] check: Unit against Unit
// [Typer] check: Let(("tmp", Var({val: None})), Get(Var("arr"), Var("i")), Let(("_", Var({val: None})), Put(Var("arr"), Var("i"), Get(Var("arr"), Prim(Var("i"), Int(1), Sub, kind=None))), Let(("_", Var({val: None})), Put(Var("arr"), Prim(Var("i"), Int(1), Sub, kind=None), Var("tmp")), App(Var("insert"), [Var("arr"), Prim(Var("i"), Int(1), Sub, kind=None)])))) against Unit
// [Typer] infer: Get(Var("arr"), Var("i"))
// [Typer] infer: Var("arr")
// [Typer] inst: TypeScheme(([], Array(Int)))
// [Typer] inst result: Array(Int)
// [Typer] check: Var("i") against Int
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] unify: Var({val: None}) and Int
// [Typer] union: Var({val: None}) and Int
// [Typer] check: Let(("_", Var({val: None})), Put(Var("arr"), Var("i"), Get(Var("arr"), Prim(Var("i"), Int(1), Sub, kind=None))), Let(("_", Var({val: None})), Put(Var("arr"), Prim(Var("i"), Int(1), Sub, kind=None), Var("tmp")), App(Var("insert"), [Var("arr"), Prim(Var("i"), Int(1), Sub, kind=None)]))) against Unit
// [Typer] infer: Put(Var("arr"), Var("i"), Get(Var("arr"), Prim(Var("i"), Int(1), Sub, kind=None)))
// [Typer] infer: Get(Var("arr"), Prim(Var("i"), Int(1), Sub, kind=None))
// [Typer] infer: Var("arr")
// [Typer] inst: TypeScheme(([], Array(Int)))
// [Typer] inst result: Array(Int)
// [Typer] check: Prim(Var("i"), Int(1), Sub, kind=None) against Int
// [Typer] check: Var("i") against Int
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] check: Int(1) against Int
// [Typer] check: Var("arr") against Array(Int)
// [Typer] inst: TypeScheme(([], Array(Int)))
// [Typer] inst result: Array(Int)
// [Typer] unify: Array(Int) and Array(Int)
// [Typer] unify: Int and Int
// [Typer] check: Var("i") against Int
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] unify: Var({val: None}) and Unit
// [Typer] union: Var({val: None}) and Unit
// [Typer] check: Let(("_", Var({val: None})), Put(Var("arr"), Prim(Var("i"), Int(1), Sub, kind=None), Var("tmp")), App(Var("insert"), [Var("arr"), Prim(Var("i"), Int(1), Sub, kind=None)])) against Unit
// [Typer] infer: Put(Var("arr"), Prim(Var("i"), Int(1), Sub, kind=None), Var("tmp"))
// [Typer] infer: Var("tmp")
// [Typer] inst: TypeScheme(([], Var({val: Some(Int)})))
// [Typer] inst result: Int
// [Typer] check: Var("arr") against Array(Int)
// [Typer] inst: TypeScheme(([], Array(Int)))
// [Typer] inst result: Array(Int)
// [Typer] unify: Array(Int) and Array(Int)
// [Typer] unify: Int and Int
// [Typer] check: Prim(Var("i"), Int(1), Sub, kind=None) against Int
// [Typer] check: Var("i") against Int
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] check: Int(1) against Int
// [Typer] unify: Var({val: None}) and Unit
// [Typer] union: Var({val: None}) and Unit
// [Typer] check: App(Var("insert"), [Var("arr"), Prim(Var("i"), Int(1), Sub, kind=None)]) against Unit
// [Typer] infer: Var("arr")
// [Typer] inst: TypeScheme(([], Array(Int)))
// [Typer] inst result: Array(Int)
// [Typer] infer: Prim(Var("i"), Int(1), Sub, kind=None)
// [Typer] infer: Var("i")
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] infer: Int(1)
// [Typer] unify: Int and Int
// [Typer] check: Var("insert") against Fun([Array(Int), Int], Unit)
// [Typer] inst: TypeScheme(([], Fun([Array(Int), Int], Unit)))
// [Typer] inst result: Fun([Array(Int), Int], Unit)
// [Typer] unify: Fun([Array(Int), Int], Unit) and Fun([Array(Int), Int], Unit)
// [Typer] unify: Array(Int) and Array(Int)
// [Typer] unify: Int and Int
// [Typer] unify: Int and Int
// [Typer] unify: Unit and Unit
// [Typer] check: LetRec({tyvars: [], name: ("aux", Unit), args: [("i", Int)], body: If(Eq(Var("i"), Var("n")), Unit, Let(("_", Var({val: None})), App(Var("insert"), [Var("arr"), Var("i")]), App(Var("aux"), [Prim(Var("i"), Int(1), Add, kind=None)])))}, App(Var("aux"), [Int(1)])) against Unit
// [Typer] typevars: []
// [Typer] check: If(Eq(Var("i"), Var("n")), Unit, Let(("_", Var({val: None})), App(Var("insert"), [Var("arr"), Var("i")]), App(Var("aux"), [Prim(Var("i"), Int(1), Add, kind=None)]))) against Unit
// [Typer] check: Eq(Var("i"), Var("n")) against Bool
// [Typer] infer: Var("i")
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] infer: Var("n")
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] check: Unit against Unit
// [Typer] check: Let(("_", Var({val: None})), App(Var("insert"), [Var("arr"), Var("i")]), App(Var("aux"), [Prim(Var("i"), Int(1), Add, kind=None)])) against Unit
// [Typer] infer: App(Var("insert"), [Var("arr"), Var("i")])
// [Typer] infer: Var("insert")
// [Typer] inst: TypeScheme(([], Fun([Array(Int), Int], Unit)))
// [Typer] inst result: Fun([Array(Int), Int], Unit)
// [Typer] check: Var("arr") against Array(Int)
// [Typer] inst: TypeScheme(([], Array(Int)))
// [Typer] inst result: Array(Int)
// [Typer] unify: Array(Int) and Array(Int)
// [Typer] unify: Int and Int
// [Typer] check: Var("i") against Int
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] unify: Var({val: None}) and Unit
// [Typer] union: Var({val: None}) and Unit
// [Typer] check: App(Var("aux"), [Prim(Var("i"), Int(1), Add, kind=None)]) against Unit
// [Typer] infer: Prim(Var("i"), Int(1), Add, kind=None)
// [Typer] infer: Var("i")
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] infer: Int(1)
// [Typer] unify: Int and Int
// [Typer] check: Var("aux") against Fun([Int], Unit)
// [Typer] inst: TypeScheme(([], Fun([Int], Unit)))
// [Typer] inst result: Fun([Int], Unit)
// [Typer] unify: Fun([Int], Unit) and Fun([Int], Unit)
// [Typer] unify: Int and Int
// [Typer] unify: Unit and Unit
// [Typer] check: App(Var("aux"), [Int(1)]) against Unit
// [Typer] infer: Int(1)
// [Typer] check: Var("aux") against Fun([Int], Unit)
// [Typer] inst: TypeScheme(([], Fun([Int], Unit)))
// [Typer] inst result: Fun([Int], Unit)
// [Typer] unify: Fun([Int], Unit) and Fun([Int], Unit)
// [Typer] unify: Int and Int
// [Typer] unify: Unit and Unit
// [Typer] check: LetRec({tyvars: [], name: ("print_array", Unit), args: [("arr", Array(Int)), ("n", Int)], body: LetRec({tyvars: [], name: ("aux", Unit), args: [("i", Int)], body: If(Eq(Var("i"), Var("n")), Unit, Let(("_", Var({val: None})), App(Var("print_int"), [Get(Var("arr"), Var("i"))]), Let(("_", Var({val: None})), App(Var("print_char"), [Int(32)]), App(Var("aux"), [Prim(Var("i"), Int(1), Add, kind=None)]))))}, App(Var("aux"), [Int(0)]))}, LetRec({tyvars: [], name: ("main", Var({val: None})), args: [], body: Let(("n", Var({val: None})), Int(100), Let(("arr", Var({val: None})), Array(Var("n"), Int(0)), Let(("_", Var({val: None})), App(Var("fill_buffer"), [Var("arr"), Var("n")]), Let(("_", Var({val: None})), App(Var("isort"), [Var("arr"), Var("n")]), App(Var("print_array"), [Var("arr"), Var("n")])))))}, Unit)) against Unit
// [Typer] typevars: []
// [Typer] check: LetRec({tyvars: [], name: ("aux", Unit), args: [("i", Int)], body: If(Eq(Var("i"), Var("n")), Unit, Let(("_", Var({val: None})), App(Var("print_int"), [Get(Var("arr"), Var("i"))]), Let(("_", Var({val: None})), App(Var("print_char"), [Int(32)]), App(Var("aux"), [Prim(Var("i"), Int(1), Add, kind=None)]))))}, App(Var("aux"), [Int(0)])) against Unit
// [Typer] typevars: []
// [Typer] check: If(Eq(Var("i"), Var("n")), Unit, Let(("_", Var({val: None})), App(Var("print_int"), [Get(Var("arr"), Var("i"))]), Let(("_", Var({val: None})), App(Var("print_char"), [Int(32)]), App(Var("aux"), [Prim(Var("i"), Int(1), Add, kind=None)])))) against Unit
// [Typer] check: Eq(Var("i"), Var("n")) against Bool
// [Typer] infer: Var("i")
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] infer: Var("n")
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] check: Unit against Unit
// [Typer] check: Let(("_", Var({val: None})), App(Var("print_int"), [Get(Var("arr"), Var("i"))]), Let(("_", Var({val: None})), App(Var("print_char"), [Int(32)]), App(Var("aux"), [Prim(Var("i"), Int(1), Add, kind=None)]))) against Unit
// [Typer] infer: App(Var("print_int"), [Get(Var("arr"), Var("i"))])
// [Typer] infer: Var("print_int")
// [Typer] inst: TypeScheme(([], Fun([Int], Unit)))
// [Typer] inst result: Fun([Int], Unit)
// [Typer] check: Get(Var("arr"), Var("i")) against Int
// [Typer] check: Var("arr") against Array(Int)
// [Typer] inst: TypeScheme(([], Array(Int)))
// [Typer] inst result: Array(Int)
// [Typer] unify: Array(Int) and Array(Int)
// [Typer] unify: Int and Int
// [Typer] check: Var("i") against Int
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] unify: Var({val: None}) and Unit
// [Typer] union: Var({val: None}) and Unit
// [Typer] check: Let(("_", Var({val: None})), App(Var("print_char"), [Int(32)]), App(Var("aux"), [Prim(Var("i"), Int(1), Add, kind=None)])) against Unit
// [Typer] infer: App(Var("print_char"), [Int(32)])
// [Typer] infer: Var("print_char")
// [Typer] inst: TypeScheme(([], Fun([Int], Unit)))
// [Typer] inst result: Fun([Int], Unit)
// [Typer] check: Int(32) against Int
// [Typer] unify: Var({val: None}) and Unit
// [Typer] union: Var({val: None}) and Unit
// [Typer] check: App(Var("aux"), [Prim(Var("i"), Int(1), Add, kind=None)]) against Unit
// [Typer] infer: Prim(Var("i"), Int(1), Add, kind=None)
// [Typer] infer: Var("i")
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] infer: Int(1)
// [Typer] unify: Int and Int
// [Typer] check: Var("aux") against Fun([Int], Unit)
// [Typer] inst: TypeScheme(([], Fun([Int], Unit)))
// [Typer] inst result: Fun([Int], Unit)
// [Typer] unify: Fun([Int], Unit) and Fun([Int], Unit)
// [Typer] unify: Int and Int
// [Typer] unify: Unit and Unit
// [Typer] check: App(Var("aux"), [Int(0)]) against Unit
// [Typer] infer: Int(0)
// [Typer] check: Var("aux") against Fun([Int], Unit)
// [Typer] inst: TypeScheme(([], Fun([Int], Unit)))
// [Typer] inst result: Fun([Int], Unit)
// [Typer] unify: Fun([Int], Unit) and Fun([Int], Unit)
// [Typer] unify: Int and Int
// [Typer] unify: Unit and Unit
// [Typer] check: LetRec({tyvars: [], name: ("main", Var({val: None})), args: [], body: Let(("n", Var({val: None})), Int(100), Let(("arr", Var({val: None})), Array(Var("n"), Int(0)), Let(("_", Var({val: None})), App(Var("fill_buffer"), [Var("arr"), Var("n")]), Let(("_", Var({val: None})), App(Var("isort"), [Var("arr"), Var("n")]), App(Var("print_array"), [Var("arr"), Var("n")])))))}, Unit) against Unit
// [Typer] typevars: []
// [Typer] infer: Let(("n", Var({val: None})), Int(100), Let(("arr", Var({val: None})), Array(Var("n"), Int(0)), Let(("_", Var({val: None})), App(Var("fill_buffer"), [Var("arr"), Var("n")]), Let(("_", Var({val: None})), App(Var("isort"), [Var("arr"), Var("n")]), App(Var("print_array"), [Var("arr"), Var("n")])))))
// [Typer] infer: Int(100)
// [Typer] unify: Var({val: None}) and Int
// [Typer] union: Var({val: None}) and Int
// [Typer] infer: Let(("arr", Var({val: None})), Array(Var("n"), Int(0)), Let(("_", Var({val: None})), App(Var("fill_buffer"), [Var("arr"), Var("n")]), Let(("_", Var({val: None})), App(Var("isort"), [Var("arr"), Var("n")]), App(Var("print_array"), [Var("arr"), Var("n")]))))
// [Typer] infer: Array(Var("n"), Int(0))
// [Typer] infer: Int(0)
// [Typer] check: Var("n") against Int
// [Typer] inst: TypeScheme(([], Var({val: Some(Int)})))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] unify: Var({val: None}) and Array(Int)
// [Typer] union: Var({val: None}) and Array(Int)
// [Typer] infer: Let(("_", Var({val: None})), App(Var("fill_buffer"), [Var("arr"), Var("n")]), Let(("_", Var({val: None})), App(Var("isort"), [Var("arr"), Var("n")]), App(Var("print_array"), [Var("arr"), Var("n")])))
// [Typer] infer: App(Var("fill_buffer"), [Var("arr"), Var("n")])
// [Typer] infer: Var("fill_buffer")
// [Typer] inst: TypeScheme(([], Fun([Array(Int), Int], Unit)))
// [Typer] inst result: Fun([Array(Int), Int], Unit)
// [Typer] check: Var("arr") against Array(Int)
// [Typer] inst: TypeScheme(([], Var({val: Some(Array(Int))})))
// [Typer] inst result: Array(Int)
// [Typer] unify: Array(Int) and Array(Int)
// [Typer] unify: Int and Int
// [Typer] check: Var("n") against Int
// [Typer] inst: TypeScheme(([], Var({val: Some(Int)})))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] unify: Var({val: None}) and Unit
// [Typer] union: Var({val: None}) and Unit
// [Typer] infer: Let(("_", Var({val: None})), App(Var("isort"), [Var("arr"), Var("n")]), App(Var("print_array"), [Var("arr"), Var("n")]))
// [Typer] infer: App(Var("isort"), [Var("arr"), Var("n")])
// [Typer] infer: Var("isort")
// [Typer] inst: TypeScheme(([], Fun([Array(Int), Int], Unit)))
// [Typer] inst result: Fun([Array(Int), Int], Unit)
// [Typer] check: Var("arr") against Array(Int)
// [Typer] inst: TypeScheme(([], Var({val: Some(Array(Int))})))
// [Typer] inst result: Array(Int)
// [Typer] unify: Array(Int) and Array(Int)
// [Typer] unify: Int and Int
// [Typer] check: Var("n") against Int
// [Typer] inst: TypeScheme(([], Var({val: Some(Int)})))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] unify: Var({val: None}) and Unit
// [Typer] union: Var({val: None}) and Unit
// [Typer] infer: App(Var("print_array"), [Var("arr"), Var("n")])
// [Typer] infer: Var("print_array")
// [Typer] inst: TypeScheme(([], Fun([Array(Int), Int], Unit)))
// [Typer] inst result: Fun([Array(Int), Int], Unit)
// [Typer] check: Var("arr") against Array(Int)
// [Typer] inst: TypeScheme(([], Var({val: Some(Array(Int))})))
// [Typer] inst result: Array(Int)
// [Typer] unify: Array(Int) and Array(Int)
// [Typer] unify: Int and Int
// [Typer] check: Var("n") against Int
// [Typer] inst: TypeScheme(([], Var({val: Some(Int)})))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] unify: Unit and Var({val: None})
// [Typer] union: Unit and Var({val: None})
// [Typer] check: Unit against Unit
// [Parser] flags: []
