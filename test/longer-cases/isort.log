// [Main] function thunk_main(k) {
// [Main]   function random_1(state_3, k) {
// [Main]     const _4 = 75;
// [Main]     const _5 = state_3 * _4;
// [Main]     const _6 = 74;
// [Main]     return $thunk(() => k(_5 + _6))
// [Main]   }
// [Main]   function modulo_7(x_9, y_11, k) {
// [Main]     const q_12 = ~~(x_9 / y_11);
// [Main]     const _13 = q_12 * y_11;
// [Main]     return $thunk(() => k(x_9 - _13))
// [Main]   }
// [Main]   function fill_buffer_14(arr_16, n_18, k) {
// [Main]     function aux_19(i_21, state_23, k) {
// [Main]       if (i_21 === n_18) {
// [Main]         return $thunk(() => k(null))
// [Main]       } else {
// [Main]         return $thunk(() => random_1(state_23, function (new_state_24) {
// [Main]           const _25 = 65537;
// [Main]           return $thunk(() => modulo_7(new_state_24, _25, function (res_26) {
// [Main]             const _28 = arr_16[i_21] = res_26;
// [Main]             const _29 = 1;
// [Main]             const _30 = i_21 + _29;
// [Main]             return $thunk(() => aux_19(_30, res_26, function (x) {
// [Main]               return $thunk(() => k(x))
// [Main]             }
// [Main]             ))
// [Main]           }
// [Main]           ))
// [Main]         }
// [Main]         ))
// [Main]       }
// [Main]     }
// [Main]     const _31 = 0;
// [Main]     const _32 = 12345;
// [Main]     return $thunk(() => aux_19(_31, _32, function (x) {
// [Main]       return $thunk(() => k(x))
// [Main]     }
// [Main]     ))
// [Main]   }
// [Main]   function isort_33(arr_35, n_37, k) {
// [Main]     function insert_38(arr_40, i_42, k) {
// [Main]       const _43 = 0;
// [Main]       if (i_42 === _43) {
// [Main]         return $thunk(() => k(null))
// [Main]       } else {
// [Main]         const _44 = 1;
// [Main]         const _45 = i_42 - _44;
// [Main]         const _46 = arr_40[_45];
// [Main]         const _47 = arr_40[i_42];
// [Main]         if (_46 <= _47) {
// [Main]           return $thunk(() => k(null))
// [Main]         } else {
// [Main]           const tmp_48 = arr_40[i_42];
// [Main]           const _49 = 1;
// [Main]           const _50 = i_42 - _49;
// [Main]           const _51 = arr_40[_50];
// [Main]           const _53 = arr_40[i_42] = _51;
// [Main]           const _54 = 1;
// [Main]           const _55 = i_42 - _54;
// [Main]           const _57 = arr_40[_55] = tmp_48;
// [Main]           const _58 = 1;
// [Main]           const _59 = i_42 - _58;
// [Main]           return $thunk(() => insert_38(arr_40, _59, function (x) {
// [Main]             return $thunk(() => k(x))
// [Main]           }
// [Main]           ))
// [Main]         }
// [Main]       }
// [Main]     }
// [Main]     function aux_60(i_62, k) {
// [Main]       if (i_62 === n_37) {
// [Main]         return $thunk(() => k(null))
// [Main]       } else {
// [Main]         return $thunk(() => insert_38(arr_35, i_62, function (_64) {
// [Main]           const _65 = 1;
// [Main]           const _66 = i_62 + _65;
// [Main]           return $thunk(() => aux_60(_66, function (x) {
// [Main]             return $thunk(() => k(x))
// [Main]           }
// [Main]           ))
// [Main]         }
// [Main]         ))
// [Main]       }
// [Main]     }
// [Main]     const _67 = 1;
// [Main]     return $thunk(() => aux_60(_67, function (x) {
// [Main]       return $thunk(() => k(x))
// [Main]     }
// [Main]     ))
// [Main]   }
// [Main]   function print_array_68(arr_70, n_72, k) {
// [Main]     function aux_73(i_75, k) {
// [Main]       if (i_75 === n_72) {
// [Main]         return $thunk(() => k(null))
// [Main]       } else {
// [Main]         const _76 = arr_70[i_75];
// [Main]         return $thunk(() => $external(minimbt_print_int, function (_78) {
// [Main]           const _79 = 32;
// [Main]           return $thunk(() => $external(minimbt_print_char, function (_81) {
// [Main]             const _82 = 1;
// [Main]             const _83 = i_75 + _82;
// [Main]             return $thunk(() => aux_73(_83, function (x) {
// [Main]               return $thunk(() => k(x))
// [Main]             }
// [Main]             ))
// [Main]           }
// [Main]           , _79))
// [Main]         }
// [Main]         , _76))
// [Main]       }
// [Main]     }
// [Main]     const _84 = 0;
// [Main]     return $thunk(() => aux_73(_84, function (x) {
// [Main]       return $thunk(() => k(x))
// [Main]     }
// [Main]     ))
// [Main]   }
// [Main]   function main_85(k) {
// [Main]     const n_86 = 100;
// [Main]     const _87 = 0;
// [Main]     return $thunk(() => $external(minimbt_create_array, function (arr_88) {
// [Main]       return $thunk(() => fill_buffer_14(arr_88, n_86, function (_90) {
// [Main]         return $thunk(() => isort_33(arr_88, n_86, function (_92) {
// [Main]           return $thunk(() => print_array_68(arr_88, n_86, function (x) {
// [Main]             return $thunk(() => k(x))
// [Main]           }
// [Main]           ))
// [Main]         }
// [Main]         ))
// [Main]       }
// [Main]       ))
// [Main]     }
// [Main]     , n_86, _87))
// [Main]   }
// [Main]   return $thunk(() => main_85(function (x) {
// [Main]     return $thunk(() => k(x))
// [Main]   }
// [Main]   ))
// [Main] }
// [Main] 
// [Main] function $thunk(lambda) {
// [Main]   return { thunk: lambda };
// [Main] }
// [Main] function $is_thunk(x) {
// [Main]   return x && x.hasOwnProperty('thunk') && x.thunk !== undefined;
// [Main] }
// [Main] function $force(x) {
// [Main]   while ($is_thunk(x)) {
// [Main]     x = x.thunk();
// [Main]   }
// [Main]   return x;
// [Main] }
// [Main] function $external(f, k, ...args) {
// [Main]   let x = f(...args);
// [Main]   return $thunk(() => k(x));
// [Main] }
// [Main] function $trampoline(f, ...args) {
// [Main]   let x = f(...args);
// [Main]   return $force(x);
// [Main] }
// [Main] export default () => $trampoline(thunk_main, x => x);
// [Typer] check: LetRec({tyvars: [], name: ("random", Int), args: [("state", Int)], body: Prim(Prim(Var("state"), Int(75), Mul, kind=None), Int(74), Add, kind=None)}, LetRec({tyvars: [], name: ("modulo", Int), args: [("x", Int), ("y", Int)], body: Let(("q", Var(None)), Prim(Var("x"), Var("y"), Div, kind=None), Prim(Var("x"), Prim(Var("q"), Var("y"), Mul, kind=None), Sub, kind=None))}, LetRec({tyvars: [], name: ("fill_buffer", Unit), args: [("arr", Array[Int]), ("n", Int)], body: LetRec({tyvars: [], name: ("aux", Unit), args: [("i", Int), ("state", Int)], body: If(Eq(Var("i"), Var("n")), Unit, Let(("new_state", Var(None)), App(Var("random"), [Var("state")]), Let(("res", Var(None)), App(Var("modulo"), [Var("new_state"), Int(65537)]), Let(("_", Var(None)), Put(Var("arr"), Var("i"), Var("res")), App(Var("aux"), [Prim(Var("i"), Int(1), Add, kind=None), Var("res")])))))}, App(Var("aux"), [Int(0), Int(12345)]))}, LetRec({tyvars: [], name: ("isort", Unit), args: [("arr", Array[Int]), ("n", Int)], body: LetRec({tyvars: [], name: ("insert", Unit), args: [("arr", Array[Int]), ("i", Int)], body: If(Eq(Var("i"), Int(0)), Unit, If(LE(Get(Var("arr"), Prim(Var("i"), Int(1), Sub, kind=None)), Get(Var("arr"), Var("i"))), Unit, Let(("tmp", Var(None)), Get(Var("arr"), Var("i")), Let(("_", Var(None)), Put(Var("arr"), Var("i"), Get(Var("arr"), Prim(Var("i"), Int(1), Sub, kind=None))), Let(("_", Var(None)), Put(Var("arr"), Prim(Var("i"), Int(1), Sub, kind=None), Var("tmp")), App(Var("insert"), [Var("arr"), Prim(Var("i"), Int(1), Sub, kind=None)]))))))}, LetRec({tyvars: [], name: ("aux", Unit), args: [("i", Int)], body: If(Eq(Var("i"), Var("n")), Unit, Let(("_", Var(None)), App(Var("insert"), [Var("arr"), Var("i")]), App(Var("aux"), [Prim(Var("i"), Int(1), Add, kind=None)])))}, App(Var("aux"), [Int(1)])))}, LetRec({tyvars: [], name: ("print_array", Unit), args: [("arr", Array[Int]), ("n", Int)], body: LetRec({tyvars: [], name: ("aux", Unit), args: [("i", Int)], body: If(Eq(Var("i"), Var("n")), Unit, Let(("_", Var(None)), App(Var("print_int"), [Get(Var("arr"), Var("i"))]), Let(("_", Var(None)), App(Var("print_char"), [Int(32)]), App(Var("aux"), [Prim(Var("i"), Int(1), Add, kind=None)]))))}, App(Var("aux"), [Int(0)]))}, LetRec({tyvars: [], name: ("main", Var(None)), args: [], body: Let(("n", Var(None)), Int(100), Let(("arr", Var(None)), Array(Var("n"), Int(0)), Let(("_", Var(None)), App(Var("fill_buffer"), [Var("arr"), Var("n")]), Let(("_", Var(None)), App(Var("isort"), [Var("arr"), Var("n")]), App(Var("print_array"), [Var("arr"), Var("n")])))))}, Unit)))))) against Unit
// [Typer] typevars: []
// [Typer] check: Prim(Prim(Var("state"), Int(75), Mul, kind=None), Int(74), Add, kind=None) against Int
// [Typer] check: Prim(Var("state"), Int(75), Mul, kind=None) against Int
// [Typer] check: Var("state") against Int
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] check: Int(75) against Int
// [Typer] check: Int(74) against Int
// [Typer] check: LetRec({tyvars: [], name: ("modulo", Int), args: [("x", Int), ("y", Int)], body: Let(("q", Var(None)), Prim(Var("x"), Var("y"), Div, kind=None), Prim(Var("x"), Prim(Var("q"), Var("y"), Mul, kind=None), Sub, kind=None))}, LetRec({tyvars: [], name: ("fill_buffer", Unit), args: [("arr", Array[Int]), ("n", Int)], body: LetRec({tyvars: [], name: ("aux", Unit), args: [("i", Int), ("state", Int)], body: If(Eq(Var("i"), Var("n")), Unit, Let(("new_state", Var(None)), App(Var("random"), [Var("state")]), Let(("res", Var(None)), App(Var("modulo"), [Var("new_state"), Int(65537)]), Let(("_", Var(None)), Put(Var("arr"), Var("i"), Var("res")), App(Var("aux"), [Prim(Var("i"), Int(1), Add, kind=None), Var("res")])))))}, App(Var("aux"), [Int(0), Int(12345)]))}, LetRec({tyvars: [], name: ("isort", Unit), args: [("arr", Array[Int]), ("n", Int)], body: LetRec({tyvars: [], name: ("insert", Unit), args: [("arr", Array[Int]), ("i", Int)], body: If(Eq(Var("i"), Int(0)), Unit, If(LE(Get(Var("arr"), Prim(Var("i"), Int(1), Sub, kind=None)), Get(Var("arr"), Var("i"))), Unit, Let(("tmp", Var(None)), Get(Var("arr"), Var("i")), Let(("_", Var(None)), Put(Var("arr"), Var("i"), Get(Var("arr"), Prim(Var("i"), Int(1), Sub, kind=None))), Let(("_", Var(None)), Put(Var("arr"), Prim(Var("i"), Int(1), Sub, kind=None), Var("tmp")), App(Var("insert"), [Var("arr"), Prim(Var("i"), Int(1), Sub, kind=None)]))))))}, LetRec({tyvars: [], name: ("aux", Unit), args: [("i", Int)], body: If(Eq(Var("i"), Var("n")), Unit, Let(("_", Var(None)), App(Var("insert"), [Var("arr"), Var("i")]), App(Var("aux"), [Prim(Var("i"), Int(1), Add, kind=None)])))}, App(Var("aux"), [Int(1)])))}, LetRec({tyvars: [], name: ("print_array", Unit), args: [("arr", Array[Int]), ("n", Int)], body: LetRec({tyvars: [], name: ("aux", Unit), args: [("i", Int)], body: If(Eq(Var("i"), Var("n")), Unit, Let(("_", Var(None)), App(Var("print_int"), [Get(Var("arr"), Var("i"))]), Let(("_", Var(None)), App(Var("print_char"), [Int(32)]), App(Var("aux"), [Prim(Var("i"), Int(1), Add, kind=None)]))))}, App(Var("aux"), [Int(0)]))}, LetRec({tyvars: [], name: ("main", Var(None)), args: [], body: Let(("n", Var(None)), Int(100), Let(("arr", Var(None)), Array(Var("n"), Int(0)), Let(("_", Var(None)), App(Var("fill_buffer"), [Var("arr"), Var("n")]), Let(("_", Var(None)), App(Var("isort"), [Var("arr"), Var("n")]), App(Var("print_array"), [Var("arr"), Var("n")])))))}, Unit))))) against Unit
// [Typer] typevars: []
// [Typer] check: Let(("q", Var(None)), Prim(Var("x"), Var("y"), Div, kind=None), Prim(Var("x"), Prim(Var("q"), Var("y"), Mul, kind=None), Sub, kind=None)) against Int
// [Typer] infer: Prim(Var("x"), Var("y"), Div, kind=None)
// [Typer] infer: Var("x")
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] infer: Var("y")
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] unify: Var(None) and Int
// [Typer] union: Var(None) and Int
// [Typer] check: Prim(Var("x"), Prim(Var("q"), Var("y"), Mul, kind=None), Sub, kind=None) against Int
// [Typer] check: Var("x") against Int
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] check: Prim(Var("q"), Var("y"), Mul, kind=None) against Int
// [Typer] check: Var("q") against Int
// [Typer] inst: TypeScheme(([], Var(Int)))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] check: Var("y") against Int
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] check: LetRec({tyvars: [], name: ("fill_buffer", Unit), args: [("arr", Array[Int]), ("n", Int)], body: LetRec({tyvars: [], name: ("aux", Unit), args: [("i", Int), ("state", Int)], body: If(Eq(Var("i"), Var("n")), Unit, Let(("new_state", Var(None)), App(Var("random"), [Var("state")]), Let(("res", Var(None)), App(Var("modulo"), [Var("new_state"), Int(65537)]), Let(("_", Var(None)), Put(Var("arr"), Var("i"), Var("res")), App(Var("aux"), [Prim(Var("i"), Int(1), Add, kind=None), Var("res")])))))}, App(Var("aux"), [Int(0), Int(12345)]))}, LetRec({tyvars: [], name: ("isort", Unit), args: [("arr", Array[Int]), ("n", Int)], body: LetRec({tyvars: [], name: ("insert", Unit), args: [("arr", Array[Int]), ("i", Int)], body: If(Eq(Var("i"), Int(0)), Unit, If(LE(Get(Var("arr"), Prim(Var("i"), Int(1), Sub, kind=None)), Get(Var("arr"), Var("i"))), Unit, Let(("tmp", Var(None)), Get(Var("arr"), Var("i")), Let(("_", Var(None)), Put(Var("arr"), Var("i"), Get(Var("arr"), Prim(Var("i"), Int(1), Sub, kind=None))), Let(("_", Var(None)), Put(Var("arr"), Prim(Var("i"), Int(1), Sub, kind=None), Var("tmp")), App(Var("insert"), [Var("arr"), Prim(Var("i"), Int(1), Sub, kind=None)]))))))}, LetRec({tyvars: [], name: ("aux", Unit), args: [("i", Int)], body: If(Eq(Var("i"), Var("n")), Unit, Let(("_", Var(None)), App(Var("insert"), [Var("arr"), Var("i")]), App(Var("aux"), [Prim(Var("i"), Int(1), Add, kind=None)])))}, App(Var("aux"), [Int(1)])))}, LetRec({tyvars: [], name: ("print_array", Unit), args: [("arr", Array[Int]), ("n", Int)], body: LetRec({tyvars: [], name: ("aux", Unit), args: [("i", Int)], body: If(Eq(Var("i"), Var("n")), Unit, Let(("_", Var(None)), App(Var("print_int"), [Get(Var("arr"), Var("i"))]), Let(("_", Var(None)), App(Var("print_char"), [Int(32)]), App(Var("aux"), [Prim(Var("i"), Int(1), Add, kind=None)]))))}, App(Var("aux"), [Int(0)]))}, LetRec({tyvars: [], name: ("main", Var(None)), args: [], body: Let(("n", Var(None)), Int(100), Let(("arr", Var(None)), Array(Var("n"), Int(0)), Let(("_", Var(None)), App(Var("fill_buffer"), [Var("arr"), Var("n")]), Let(("_", Var(None)), App(Var("isort"), [Var("arr"), Var("n")]), App(Var("print_array"), [Var("arr"), Var("n")])))))}, Unit)))) against Unit
// [Typer] typevars: []
// [Typer] check: LetRec({tyvars: [], name: ("aux", Unit), args: [("i", Int), ("state", Int)], body: If(Eq(Var("i"), Var("n")), Unit, Let(("new_state", Var(None)), App(Var("random"), [Var("state")]), Let(("res", Var(None)), App(Var("modulo"), [Var("new_state"), Int(65537)]), Let(("_", Var(None)), Put(Var("arr"), Var("i"), Var("res")), App(Var("aux"), [Prim(Var("i"), Int(1), Add, kind=None), Var("res")])))))}, App(Var("aux"), [Int(0), Int(12345)])) against Unit
// [Typer] typevars: []
// [Typer] check: If(Eq(Var("i"), Var("n")), Unit, Let(("new_state", Var(None)), App(Var("random"), [Var("state")]), Let(("res", Var(None)), App(Var("modulo"), [Var("new_state"), Int(65537)]), Let(("_", Var(None)), Put(Var("arr"), Var("i"), Var("res")), App(Var("aux"), [Prim(Var("i"), Int(1), Add, kind=None), Var("res")]))))) against Unit
// [Typer] check: Eq(Var("i"), Var("n")) against Bool
// [Typer] infer: Var("i")
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] infer: Var("n")
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] check: Unit against Unit
// [Typer] check: Let(("new_state", Var(None)), App(Var("random"), [Var("state")]), Let(("res", Var(None)), App(Var("modulo"), [Var("new_state"), Int(65537)]), Let(("_", Var(None)), Put(Var("arr"), Var("i"), Var("res")), App(Var("aux"), [Prim(Var("i"), Int(1), Add, kind=None), Var("res")])))) against Unit
// [Typer] infer: App(Var("random"), [Var("state")])
// [Typer] infer: Var("random")
// [Typer] inst: TypeScheme(([], (Int) -> Int))
// [Typer] inst result: (Int) -> Int
// [Typer] check: Var("state") against Int
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] unify: Var(None) and Int
// [Typer] union: Var(None) and Int
// [Typer] check: Let(("res", Var(None)), App(Var("modulo"), [Var("new_state"), Int(65537)]), Let(("_", Var(None)), Put(Var("arr"), Var("i"), Var("res")), App(Var("aux"), [Prim(Var("i"), Int(1), Add, kind=None), Var("res")]))) against Unit
// [Typer] infer: App(Var("modulo"), [Var("new_state"), Int(65537)])
// [Typer] infer: Var("modulo")
// [Typer] inst: TypeScheme(([], (Int, Int) -> Int))
// [Typer] inst result: (Int, Int) -> Int
// [Typer] check: Var("new_state") against Int
// [Typer] inst: TypeScheme(([], Var(Int)))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] check: Int(65537) against Int
// [Typer] unify: Var(None) and Int
// [Typer] union: Var(None) and Int
// [Typer] check: Let(("_", Var(None)), Put(Var("arr"), Var("i"), Var("res")), App(Var("aux"), [Prim(Var("i"), Int(1), Add, kind=None), Var("res")])) against Unit
// [Typer] infer: Put(Var("arr"), Var("i"), Var("res"))
// [Typer] infer: Var("res")
// [Typer] inst: TypeScheme(([], Var(Int)))
// [Typer] inst result: Int
// [Typer] check: Var("arr") against Array[Int]
// [Typer] inst: TypeScheme(([], Array[Int]))
// [Typer] inst result: Array[Int]
// [Typer] unify: Array[Int] and Array[Int]
// [Typer] unify: Int and Int
// [Typer] check: Var("i") against Int
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] unify: Var(None) and Unit
// [Typer] union: Var(None) and Unit
// [Typer] check: App(Var("aux"), [Prim(Var("i"), Int(1), Add, kind=None), Var("res")]) against Unit
// [Typer] infer: Prim(Var("i"), Int(1), Add, kind=None)
// [Typer] infer: Var("i")
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] infer: Int(1)
// [Typer] unify: Int and Int
// [Typer] infer: Var("res")
// [Typer] inst: TypeScheme(([], Var(Int)))
// [Typer] inst result: Int
// [Typer] check: Var("aux") against (Int, Int) -> Unit
// [Typer] inst: TypeScheme(([], (Int, Int) -> Unit))
// [Typer] inst result: (Int, Int) -> Unit
// [Typer] unify: (Int, Int) -> Unit and (Int, Int) -> Unit
// [Typer] unify: Int and Int
// [Typer] unify: Int and Int
// [Typer] unify: Unit and Unit
// [Typer] check: App(Var("aux"), [Int(0), Int(12345)]) against Unit
// [Typer] infer: Int(0)
// [Typer] infer: Int(12345)
// [Typer] check: Var("aux") against (Int, Int) -> Unit
// [Typer] inst: TypeScheme(([], (Int, Int) -> Unit))
// [Typer] inst result: (Int, Int) -> Unit
// [Typer] unify: (Int, Int) -> Unit and (Int, Int) -> Unit
// [Typer] unify: Int and Int
// [Typer] unify: Int and Int
// [Typer] unify: Unit and Unit
// [Typer] check: LetRec({tyvars: [], name: ("isort", Unit), args: [("arr", Array[Int]), ("n", Int)], body: LetRec({tyvars: [], name: ("insert", Unit), args: [("arr", Array[Int]), ("i", Int)], body: If(Eq(Var("i"), Int(0)), Unit, If(LE(Get(Var("arr"), Prim(Var("i"), Int(1), Sub, kind=None)), Get(Var("arr"), Var("i"))), Unit, Let(("tmp", Var(None)), Get(Var("arr"), Var("i")), Let(("_", Var(None)), Put(Var("arr"), Var("i"), Get(Var("arr"), Prim(Var("i"), Int(1), Sub, kind=None))), Let(("_", Var(None)), Put(Var("arr"), Prim(Var("i"), Int(1), Sub, kind=None), Var("tmp")), App(Var("insert"), [Var("arr"), Prim(Var("i"), Int(1), Sub, kind=None)]))))))}, LetRec({tyvars: [], name: ("aux", Unit), args: [("i", Int)], body: If(Eq(Var("i"), Var("n")), Unit, Let(("_", Var(None)), App(Var("insert"), [Var("arr"), Var("i")]), App(Var("aux"), [Prim(Var("i"), Int(1), Add, kind=None)])))}, App(Var("aux"), [Int(1)])))}, LetRec({tyvars: [], name: ("print_array", Unit), args: [("arr", Array[Int]), ("n", Int)], body: LetRec({tyvars: [], name: ("aux", Unit), args: [("i", Int)], body: If(Eq(Var("i"), Var("n")), Unit, Let(("_", Var(None)), App(Var("print_int"), [Get(Var("arr"), Var("i"))]), Let(("_", Var(None)), App(Var("print_char"), [Int(32)]), App(Var("aux"), [Prim(Var("i"), Int(1), Add, kind=None)]))))}, App(Var("aux"), [Int(0)]))}, LetRec({tyvars: [], name: ("main", Var(None)), args: [], body: Let(("n", Var(None)), Int(100), Let(("arr", Var(None)), Array(Var("n"), Int(0)), Let(("_", Var(None)), App(Var("fill_buffer"), [Var("arr"), Var("n")]), Let(("_", Var(None)), App(Var("isort"), [Var("arr"), Var("n")]), App(Var("print_array"), [Var("arr"), Var("n")])))))}, Unit))) against Unit
// [Typer] typevars: []
// [Typer] check: LetRec({tyvars: [], name: ("insert", Unit), args: [("arr", Array[Int]), ("i", Int)], body: If(Eq(Var("i"), Int(0)), Unit, If(LE(Get(Var("arr"), Prim(Var("i"), Int(1), Sub, kind=None)), Get(Var("arr"), Var("i"))), Unit, Let(("tmp", Var(None)), Get(Var("arr"), Var("i")), Let(("_", Var(None)), Put(Var("arr"), Var("i"), Get(Var("arr"), Prim(Var("i"), Int(1), Sub, kind=None))), Let(("_", Var(None)), Put(Var("arr"), Prim(Var("i"), Int(1), Sub, kind=None), Var("tmp")), App(Var("insert"), [Var("arr"), Prim(Var("i"), Int(1), Sub, kind=None)]))))))}, LetRec({tyvars: [], name: ("aux", Unit), args: [("i", Int)], body: If(Eq(Var("i"), Var("n")), Unit, Let(("_", Var(None)), App(Var("insert"), [Var("arr"), Var("i")]), App(Var("aux"), [Prim(Var("i"), Int(1), Add, kind=None)])))}, App(Var("aux"), [Int(1)]))) against Unit
// [Typer] typevars: []
// [Typer] check: If(Eq(Var("i"), Int(0)), Unit, If(LE(Get(Var("arr"), Prim(Var("i"), Int(1), Sub, kind=None)), Get(Var("arr"), Var("i"))), Unit, Let(("tmp", Var(None)), Get(Var("arr"), Var("i")), Let(("_", Var(None)), Put(Var("arr"), Var("i"), Get(Var("arr"), Prim(Var("i"), Int(1), Sub, kind=None))), Let(("_", Var(None)), Put(Var("arr"), Prim(Var("i"), Int(1), Sub, kind=None), Var("tmp")), App(Var("insert"), [Var("arr"), Prim(Var("i"), Int(1), Sub, kind=None)])))))) against Unit
// [Typer] check: Eq(Var("i"), Int(0)) against Bool
// [Typer] infer: Var("i")
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] infer: Int(0)
// [Typer] unify: Int and Int
// [Typer] check: Unit against Unit
// [Typer] check: If(LE(Get(Var("arr"), Prim(Var("i"), Int(1), Sub, kind=None)), Get(Var("arr"), Var("i"))), Unit, Let(("tmp", Var(None)), Get(Var("arr"), Var("i")), Let(("_", Var(None)), Put(Var("arr"), Var("i"), Get(Var("arr"), Prim(Var("i"), Int(1), Sub, kind=None))), Let(("_", Var(None)), Put(Var("arr"), Prim(Var("i"), Int(1), Sub, kind=None), Var("tmp")), App(Var("insert"), [Var("arr"), Prim(Var("i"), Int(1), Sub, kind=None)]))))) against Unit
// [Typer] check: LE(Get(Var("arr"), Prim(Var("i"), Int(1), Sub, kind=None)), Get(Var("arr"), Var("i"))) against Bool
// [Typer] infer: Get(Var("arr"), Prim(Var("i"), Int(1), Sub, kind=None))
// [Typer] infer: Var("arr")
// [Typer] inst: TypeScheme(([], Array[Int]))
// [Typer] inst result: Array[Int]
// [Typer] check: Prim(Var("i"), Int(1), Sub, kind=None) against Int
// [Typer] check: Var("i") against Int
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] check: Int(1) against Int
// [Typer] infer: Get(Var("arr"), Var("i"))
// [Typer] infer: Var("arr")
// [Typer] inst: TypeScheme(([], Array[Int]))
// [Typer] inst result: Array[Int]
// [Typer] check: Var("i") against Int
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] unify: Int and Int
// [Typer] check: Unit against Unit
// [Typer] check: Let(("tmp", Var(None)), Get(Var("arr"), Var("i")), Let(("_", Var(None)), Put(Var("arr"), Var("i"), Get(Var("arr"), Prim(Var("i"), Int(1), Sub, kind=None))), Let(("_", Var(None)), Put(Var("arr"), Prim(Var("i"), Int(1), Sub, kind=None), Var("tmp")), App(Var("insert"), [Var("arr"), Prim(Var("i"), Int(1), Sub, kind=None)])))) against Unit
// [Typer] infer: Get(Var("arr"), Var("i"))
// [Typer] infer: Var("arr")
// [Typer] inst: TypeScheme(([], Array[Int]))
// [Typer] inst result: Array[Int]
// [Typer] check: Var("i") against Int
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] unify: Var(None) and Int
// [Typer] union: Var(None) and Int
// [Typer] check: Let(("_", Var(None)), Put(Var("arr"), Var("i"), Get(Var("arr"), Prim(Var("i"), Int(1), Sub, kind=None))), Let(("_", Var(None)), Put(Var("arr"), Prim(Var("i"), Int(1), Sub, kind=None), Var("tmp")), App(Var("insert"), [Var("arr"), Prim(Var("i"), Int(1), Sub, kind=None)]))) against Unit
// [Typer] infer: Put(Var("arr"), Var("i"), Get(Var("arr"), Prim(Var("i"), Int(1), Sub, kind=None)))
// [Typer] infer: Get(Var("arr"), Prim(Var("i"), Int(1), Sub, kind=None))
// [Typer] infer: Var("arr")
// [Typer] inst: TypeScheme(([], Array[Int]))
// [Typer] inst result: Array[Int]
// [Typer] check: Prim(Var("i"), Int(1), Sub, kind=None) against Int
// [Typer] check: Var("i") against Int
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] check: Int(1) against Int
// [Typer] check: Var("arr") against Array[Int]
// [Typer] inst: TypeScheme(([], Array[Int]))
// [Typer] inst result: Array[Int]
// [Typer] unify: Array[Int] and Array[Int]
// [Typer] unify: Int and Int
// [Typer] check: Var("i") against Int
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] unify: Var(None) and Unit
// [Typer] union: Var(None) and Unit
// [Typer] check: Let(("_", Var(None)), Put(Var("arr"), Prim(Var("i"), Int(1), Sub, kind=None), Var("tmp")), App(Var("insert"), [Var("arr"), Prim(Var("i"), Int(1), Sub, kind=None)])) against Unit
// [Typer] infer: Put(Var("arr"), Prim(Var("i"), Int(1), Sub, kind=None), Var("tmp"))
// [Typer] infer: Var("tmp")
// [Typer] inst: TypeScheme(([], Var(Int)))
// [Typer] inst result: Int
// [Typer] check: Var("arr") against Array[Int]
// [Typer] inst: TypeScheme(([], Array[Int]))
// [Typer] inst result: Array[Int]
// [Typer] unify: Array[Int] and Array[Int]
// [Typer] unify: Int and Int
// [Typer] check: Prim(Var("i"), Int(1), Sub, kind=None) against Int
// [Typer] check: Var("i") against Int
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] check: Int(1) against Int
// [Typer] unify: Var(None) and Unit
// [Typer] union: Var(None) and Unit
// [Typer] check: App(Var("insert"), [Var("arr"), Prim(Var("i"), Int(1), Sub, kind=None)]) against Unit
// [Typer] infer: Var("arr")
// [Typer] inst: TypeScheme(([], Array[Int]))
// [Typer] inst result: Array[Int]
// [Typer] infer: Prim(Var("i"), Int(1), Sub, kind=None)
// [Typer] infer: Var("i")
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] infer: Int(1)
// [Typer] unify: Int and Int
// [Typer] check: Var("insert") against (Array[Int], Int) -> Unit
// [Typer] inst: TypeScheme(([], (Array[Int], Int) -> Unit))
// [Typer] inst result: (Array[Int], Int) -> Unit
// [Typer] unify: (Array[Int], Int) -> Unit and (Array[Int], Int) -> Unit
// [Typer] unify: Array[Int] and Array[Int]
// [Typer] unify: Int and Int
// [Typer] unify: Int and Int
// [Typer] unify: Unit and Unit
// [Typer] check: LetRec({tyvars: [], name: ("aux", Unit), args: [("i", Int)], body: If(Eq(Var("i"), Var("n")), Unit, Let(("_", Var(None)), App(Var("insert"), [Var("arr"), Var("i")]), App(Var("aux"), [Prim(Var("i"), Int(1), Add, kind=None)])))}, App(Var("aux"), [Int(1)])) against Unit
// [Typer] typevars: []
// [Typer] check: If(Eq(Var("i"), Var("n")), Unit, Let(("_", Var(None)), App(Var("insert"), [Var("arr"), Var("i")]), App(Var("aux"), [Prim(Var("i"), Int(1), Add, kind=None)]))) against Unit
// [Typer] check: Eq(Var("i"), Var("n")) against Bool
// [Typer] infer: Var("i")
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] infer: Var("n")
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] check: Unit against Unit
// [Typer] check: Let(("_", Var(None)), App(Var("insert"), [Var("arr"), Var("i")]), App(Var("aux"), [Prim(Var("i"), Int(1), Add, kind=None)])) against Unit
// [Typer] infer: App(Var("insert"), [Var("arr"), Var("i")])
// [Typer] infer: Var("insert")
// [Typer] inst: TypeScheme(([], (Array[Int], Int) -> Unit))
// [Typer] inst result: (Array[Int], Int) -> Unit
// [Typer] check: Var("arr") against Array[Int]
// [Typer] inst: TypeScheme(([], Array[Int]))
// [Typer] inst result: Array[Int]
// [Typer] unify: Array[Int] and Array[Int]
// [Typer] unify: Int and Int
// [Typer] check: Var("i") against Int
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] unify: Var(None) and Unit
// [Typer] union: Var(None) and Unit
// [Typer] check: App(Var("aux"), [Prim(Var("i"), Int(1), Add, kind=None)]) against Unit
// [Typer] infer: Prim(Var("i"), Int(1), Add, kind=None)
// [Typer] infer: Var("i")
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] infer: Int(1)
// [Typer] unify: Int and Int
// [Typer] check: Var("aux") against (Int) -> Unit
// [Typer] inst: TypeScheme(([], (Int) -> Unit))
// [Typer] inst result: (Int) -> Unit
// [Typer] unify: (Int) -> Unit and (Int) -> Unit
// [Typer] unify: Int and Int
// [Typer] unify: Unit and Unit
// [Typer] check: App(Var("aux"), [Int(1)]) against Unit
// [Typer] infer: Int(1)
// [Typer] check: Var("aux") against (Int) -> Unit
// [Typer] inst: TypeScheme(([], (Int) -> Unit))
// [Typer] inst result: (Int) -> Unit
// [Typer] unify: (Int) -> Unit and (Int) -> Unit
// [Typer] unify: Int and Int
// [Typer] unify: Unit and Unit
// [Typer] check: LetRec({tyvars: [], name: ("print_array", Unit), args: [("arr", Array[Int]), ("n", Int)], body: LetRec({tyvars: [], name: ("aux", Unit), args: [("i", Int)], body: If(Eq(Var("i"), Var("n")), Unit, Let(("_", Var(None)), App(Var("print_int"), [Get(Var("arr"), Var("i"))]), Let(("_", Var(None)), App(Var("print_char"), [Int(32)]), App(Var("aux"), [Prim(Var("i"), Int(1), Add, kind=None)]))))}, App(Var("aux"), [Int(0)]))}, LetRec({tyvars: [], name: ("main", Var(None)), args: [], body: Let(("n", Var(None)), Int(100), Let(("arr", Var(None)), Array(Var("n"), Int(0)), Let(("_", Var(None)), App(Var("fill_buffer"), [Var("arr"), Var("n")]), Let(("_", Var(None)), App(Var("isort"), [Var("arr"), Var("n")]), App(Var("print_array"), [Var("arr"), Var("n")])))))}, Unit)) against Unit
// [Typer] typevars: []
// [Typer] check: LetRec({tyvars: [], name: ("aux", Unit), args: [("i", Int)], body: If(Eq(Var("i"), Var("n")), Unit, Let(("_", Var(None)), App(Var("print_int"), [Get(Var("arr"), Var("i"))]), Let(("_", Var(None)), App(Var("print_char"), [Int(32)]), App(Var("aux"), [Prim(Var("i"), Int(1), Add, kind=None)]))))}, App(Var("aux"), [Int(0)])) against Unit
// [Typer] typevars: []
// [Typer] check: If(Eq(Var("i"), Var("n")), Unit, Let(("_", Var(None)), App(Var("print_int"), [Get(Var("arr"), Var("i"))]), Let(("_", Var(None)), App(Var("print_char"), [Int(32)]), App(Var("aux"), [Prim(Var("i"), Int(1), Add, kind=None)])))) against Unit
// [Typer] check: Eq(Var("i"), Var("n")) against Bool
// [Typer] infer: Var("i")
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] infer: Var("n")
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] check: Unit against Unit
// [Typer] check: Let(("_", Var(None)), App(Var("print_int"), [Get(Var("arr"), Var("i"))]), Let(("_", Var(None)), App(Var("print_char"), [Int(32)]), App(Var("aux"), [Prim(Var("i"), Int(1), Add, kind=None)]))) against Unit
// [Typer] infer: App(Var("print_int"), [Get(Var("arr"), Var("i"))])
// [Typer] infer: Var("print_int")
// [Typer] inst: TypeScheme(([], (Int) -> Unit))
// [Typer] inst result: (Int) -> Unit
// [Typer] check: Get(Var("arr"), Var("i")) against Int
// [Typer] check: Var("arr") against Array[Int]
// [Typer] inst: TypeScheme(([], Array[Int]))
// [Typer] inst result: Array[Int]
// [Typer] unify: Array[Int] and Array[Int]
// [Typer] unify: Int and Int
// [Typer] check: Var("i") against Int
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] unify: Var(None) and Unit
// [Typer] union: Var(None) and Unit
// [Typer] check: Let(("_", Var(None)), App(Var("print_char"), [Int(32)]), App(Var("aux"), [Prim(Var("i"), Int(1), Add, kind=None)])) against Unit
// [Typer] infer: App(Var("print_char"), [Int(32)])
// [Typer] infer: Var("print_char")
// [Typer] inst: TypeScheme(([], (Int) -> Unit))
// [Typer] inst result: (Int) -> Unit
// [Typer] check: Int(32) against Int
// [Typer] unify: Var(None) and Unit
// [Typer] union: Var(None) and Unit
// [Typer] check: App(Var("aux"), [Prim(Var("i"), Int(1), Add, kind=None)]) against Unit
// [Typer] infer: Prim(Var("i"), Int(1), Add, kind=None)
// [Typer] infer: Var("i")
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] infer: Int(1)
// [Typer] unify: Int and Int
// [Typer] check: Var("aux") against (Int) -> Unit
// [Typer] inst: TypeScheme(([], (Int) -> Unit))
// [Typer] inst result: (Int) -> Unit
// [Typer] unify: (Int) -> Unit and (Int) -> Unit
// [Typer] unify: Int and Int
// [Typer] unify: Unit and Unit
// [Typer] check: App(Var("aux"), [Int(0)]) against Unit
// [Typer] infer: Int(0)
// [Typer] check: Var("aux") against (Int) -> Unit
// [Typer] inst: TypeScheme(([], (Int) -> Unit))
// [Typer] inst result: (Int) -> Unit
// [Typer] unify: (Int) -> Unit and (Int) -> Unit
// [Typer] unify: Int and Int
// [Typer] unify: Unit and Unit
// [Typer] check: LetRec({tyvars: [], name: ("main", Var(None)), args: [], body: Let(("n", Var(None)), Int(100), Let(("arr", Var(None)), Array(Var("n"), Int(0)), Let(("_", Var(None)), App(Var("fill_buffer"), [Var("arr"), Var("n")]), Let(("_", Var(None)), App(Var("isort"), [Var("arr"), Var("n")]), App(Var("print_array"), [Var("arr"), Var("n")])))))}, Unit) against Unit
// [Typer] typevars: []
// [Typer] infer: Let(("n", Var(None)), Int(100), Let(("arr", Var(None)), Array(Var("n"), Int(0)), Let(("_", Var(None)), App(Var("fill_buffer"), [Var("arr"), Var("n")]), Let(("_", Var(None)), App(Var("isort"), [Var("arr"), Var("n")]), App(Var("print_array"), [Var("arr"), Var("n")])))))
// [Typer] infer: Int(100)
// [Typer] unify: Var(None) and Int
// [Typer] union: Var(None) and Int
// [Typer] infer: Let(("arr", Var(None)), Array(Var("n"), Int(0)), Let(("_", Var(None)), App(Var("fill_buffer"), [Var("arr"), Var("n")]), Let(("_", Var(None)), App(Var("isort"), [Var("arr"), Var("n")]), App(Var("print_array"), [Var("arr"), Var("n")]))))
// [Typer] infer: Array(Var("n"), Int(0))
// [Typer] infer: Int(0)
// [Typer] check: Var("n") against Int
// [Typer] inst: TypeScheme(([], Var(Int)))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] unify: Var(None) and Array[Int]
// [Typer] union: Var(None) and Array[Int]
// [Typer] infer: Let(("_", Var(None)), App(Var("fill_buffer"), [Var("arr"), Var("n")]), Let(("_", Var(None)), App(Var("isort"), [Var("arr"), Var("n")]), App(Var("print_array"), [Var("arr"), Var("n")])))
// [Typer] infer: App(Var("fill_buffer"), [Var("arr"), Var("n")])
// [Typer] infer: Var("fill_buffer")
// [Typer] inst: TypeScheme(([], (Array[Int], Int) -> Unit))
// [Typer] inst result: (Array[Int], Int) -> Unit
// [Typer] check: Var("arr") against Array[Int]
// [Typer] inst: TypeScheme(([], Var(Array[Int])))
// [Typer] inst result: Array[Int]
// [Typer] unify: Array[Int] and Array[Int]
// [Typer] unify: Int and Int
// [Typer] check: Var("n") against Int
// [Typer] inst: TypeScheme(([], Var(Int)))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] unify: Var(None) and Unit
// [Typer] union: Var(None) and Unit
// [Typer] infer: Let(("_", Var(None)), App(Var("isort"), [Var("arr"), Var("n")]), App(Var("print_array"), [Var("arr"), Var("n")]))
// [Typer] infer: App(Var("isort"), [Var("arr"), Var("n")])
// [Typer] infer: Var("isort")
// [Typer] inst: TypeScheme(([], (Array[Int], Int) -> Unit))
// [Typer] inst result: (Array[Int], Int) -> Unit
// [Typer] check: Var("arr") against Array[Int]
// [Typer] inst: TypeScheme(([], Var(Array[Int])))
// [Typer] inst result: Array[Int]
// [Typer] unify: Array[Int] and Array[Int]
// [Typer] unify: Int and Int
// [Typer] check: Var("n") against Int
// [Typer] inst: TypeScheme(([], Var(Int)))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] unify: Var(None) and Unit
// [Typer] union: Var(None) and Unit
// [Typer] infer: App(Var("print_array"), [Var("arr"), Var("n")])
// [Typer] infer: Var("print_array")
// [Typer] inst: TypeScheme(([], (Array[Int], Int) -> Unit))
// [Typer] inst result: (Array[Int], Int) -> Unit
// [Typer] check: Var("arr") against Array[Int]
// [Typer] inst: TypeScheme(([], Var(Array[Int])))
// [Typer] inst result: Array[Int]
// [Typer] unify: Array[Int] and Array[Int]
// [Typer] unify: Int and Int
// [Typer] check: Var("n") against Int
// [Typer] inst: TypeScheme(([], Var(Int)))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] unify: Unit and Var(None)
// [Typer] union: Unit and Var(None)
// [Typer] check: Unit against Unit
// [Parser] flags: []
