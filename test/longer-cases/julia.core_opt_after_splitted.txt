# name conventions used in the core ir:
# - functions: f<id>
# - blocks: b<id>
# - instructions: %<id>
# - memory: m<id>
# - free variables: ^<id>
# - function parameters: $f<pid>
# - block parameters: $b<bid>.<pid>
.core
.fn T$iter.3 #f4 : fn() -> int32
.freevars ()
.entry b0 {
  .bb #b0 () {
    return 300
  }
}
.fn T$c_re.5 #f8 : fn() -> double
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: double = load_symbol ::3
    let %1: double = neg(%0)
    return %1
  }
}
.fn T$limit.1 #f0 : fn() -> double
.freevars ()
.entry b0 {
  .bb #b0 () {
    return 2
  }
}
.fn T$_4 #f6 : fn() -> double
.freevars ()
.entry b0 {
  .bb #b0 () {
    return 0.123
  }
}
.fn T$c_im.6 #f10 : fn() -> double
.freevars ()
.entry b0 {
  .bb #b0 () {
    return 0.745
  }
}
.fn T$limit_sq.2 #f2 : fn() -> double
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: double = load_symbol ::0
    let %1: double = load_symbol ::0
    let %2: double = mul(%0, %1)
    return %2
  }
}
.fn main_loop.177 #f12 : fn(int32, int32, int32, int32, array[int32], double, double, int32, double) -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    jump b1($f0, $f1, $f2, $f3, $f4)
  }
  .loop #b1 pre #Some(b0) header #b2 {
    .block #b3
    .block #b4
    .block #b5
    .block #b6
    .block #b27
    .block #b28
  }
  .bb #b2 (int32, int32, int32, int32, array[int32]) {
    let %0: bool = eq($b2.3, $b2.1)
    br %0 b3() b4()
  }
  .bb #b3 () {
    jump b28(())
  }
  .bb #b4 () {
    let %1: bool = eq($b2.2, $b2.0)
    br %1 b5() b6()
  }
  .bb #b5 () {
    let %2: int32 = add($b2.3, 1)
    jump b2($b2.0, $b2.1, 0, %2, $b2.4)
  }
  .bb #b6 () {
    let %3: double = conv.i2d($b2.2)
    let %4: double = mul(3, %3)
    let %5: double = conv.i2d($b2.0)
    let %6: double = div(%4, %5)
    let %7: double = sub(%6, 1.5)
    let %8: double = neg(%7)
    let %9: double = conv.i2d($b2.3)
    let %10: double = mul(3, %9)
    let %11: double = conv.i2d($b2.1)
    let %12: double = div(%10, %11)
    let %13: double = sub(%12, 1.5)
    jump b7(%8, %13, 0)
  }
  .loop #b7 pre #Some(b6) header #b8 {
    .block #b9
    .block #b10
    .block #b11
    .block #b12
    .block #b13
    .block #b14
    .block #b15
    .block #b16
    .block #b17
    .block #b18
    .block #b19
    .block #b20
    .block #b21
    .block #b22
    .block #b23
    .block #b24
    .block #b25
    .block #b26
  }
  .bb #b8 (double, double, int32) {
    let %14: double = mul($b8.0, $b8.0)
    let %15: double = mul($b8.1, $b8.1)
    let %16: int32 = load_symbol ::2
    let %17: bool = eq($b8.2, %16)
    br %17 b9() b10()
  }
  .bb #b9 () {
    let %18: int32 = mul($b2.3, $b2.0)
    let %19: int32 = add(%18, $b2.2)
    let %20: int32 = load_symbol ::2
    let %21: bool = le(%20, 0)
    br %21 b11() b12()
  }
  .bb #b10 () {
    let %31: double = add(%14, %15)
    let %32: double = load_symbol ::1
    let %33: bool = le(%32, %31)
    br %33 b17() b18()
  }
  .bb #b11 () {
    let _ = store int32 offset($b2.4, %19 * @32) <- 0
    let %23: int32 = add($b2.2, 1)
    jump b2($b2.0, $b2.1, %23, $b2.3, $b2.4)
  }
  .bb #b12 () {
    let %24: int32 = load_symbol ::2
    let %25: bool = le(48, %24)
    br %25 b13() b14()
  }
  .bb #b13 () {
    let _ = store int32 offset($b2.4, %19 * @32) <- 48
    let %27: int32 = add($b2.2, 1)
    jump b2($b2.0, $b2.1, %27, $b2.3, $b2.4)
  }
  .bb #b14 () {
    let %28: int32 = load_symbol ::2
    let _ = store int32 offset($b2.4, %19 * @32) <- %28
    let %30: int32 = add($b2.2, 1)
    jump b2($b2.0, $b2.1, %30, $b2.3, $b2.4)
  }
  .bb #b15 (any) {
    jump b16($b15.0)
  }
  .bb #b16 (any) {
    jump b26($b16.0)
  }
  .bb #b17 () {
    let %34: int32 = mul($b2.3, $b2.0)
    let %35: int32 = add(%34, $b2.2)
    let %36: bool = le($b8.2, 0)
    br %36 b19() b20()
  }
  .bb #b18 () {
    let %44: double = mul(2, $b8.0)
    let %45: double = mul(%44, $b8.1)
    let %46: double = load_symbol ::5
    let %47: double = add(%45, %46)
    let %48: double = sub(%14, %15)
    let %49: double = load_symbol ::4
    let %50: double = add(%48, %49)
    let %51: int32 = add($b8.2, 1)
    jump b8(%50, %47, %51)
  }
  .bb #b19 () {
    let _ = store int32 offset($b2.4, %35 * @32) <- 0
    let %38: int32 = add($b2.2, 1)
    jump b2($b2.0, $b2.1, %38, $b2.3, $b2.4)
  }
  .bb #b20 () {
    let %39: bool = le(48, $b8.2)
    br %39 b21() b22()
  }
  .bb #b21 () {
    let _ = store int32 offset($b2.4, %35 * @32) <- 48
    let %41: int32 = add($b2.2, 1)
    jump b2($b2.0, $b2.1, %41, $b2.3, $b2.4)
  }
  .bb #b22 () {
    let _ = store int32 offset($b2.4, %35 * @32) <- $b8.2
    let %43: int32 = add($b2.2, 1)
    jump b2($b2.0, $b2.1, %43, $b2.3, $b2.4)
  }
  .bb #b23 (any) {
    jump b24($b23.0)
  }
  .bb #b24 (any) {
    jump b25($b24.0)
  }
  .bb #b25 (any) {
    jump b26($b25.0)
  }
  .bb #b26 (any) {
    return $b26.0
  }
  .bb #b27 (any) {
    jump b28($b27.0)
  }
  .bb #b28 (unit) {
    return $b28.0
  }
}
.fn print_loop.178 #f13 : fn(int32, int32, int32, int32, array[int32]) -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    jump b1($f0, $f1, $f2, $f3, $f4)
  }
  .loop #b1 pre #Some(b0) header #b2 {
    .block #b3
    .block #b4
    .block #b5
    .block #b6
    .block #b7
    .block #b8
  }
  .bb #b2 (int32, int32, int32, int32, array[int32]) {
    let %0: bool = eq($b2.3, $b2.1)
    br %0 b3() b4()
  }
  .bb #b3 () {
    jump b8(())
  }
  .bb #b4 () {
    let %1: bool = eq($b2.2, $b2.0)
    br %1 b5() b6()
  }
  .bb #b5 () {
    let %2: unit = ext_call minimbt_print_char(10)
    let %3: int32 = add($b2.3, 1)
    jump b2($b2.0, $b2.1, 0, %3, $b2.4)
  }
  .bb #b6 () {
    let %4: int32 = mul($b2.3, $b2.0)
    let %5: int32 = add(%4, $b2.2)
    let %6: int32 = load int32 offset($b2.4, %5 * @32)
    let %7: int32 = add(48, %6)
    let %8: unit = ext_call minimbt_print_char(%7)
    let %9: int32 = add($b2.2, 1)
    jump b2($b2.0, $b2.1, %9, $b2.3, $b2.4)
  }
  .bb #b7 (any) {
    jump b8($b7.0)
  }
  .bb #b8 (unit) {
    return $b8.0
  }
}
.fn main.179 #f14 : fn(double, double, int32, double) -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: int32 = ext_call minimbt_read_int()
    let %1: int32 = mul(%0, 2)
    let %2: int32 = mul(%1, %0)
    let _ = alloc <m0: array[int32] heap(%2)> <- [..] = 0
    let %4: double = load_symbol ::5
    let %5: double = load_symbol ::4
    let %6: int32 = load_symbol ::2
    let %7: double = load_symbol ::1
    let %8: unit = call f12(%1, %0, 0, 0, f14.m0, %4, %5, %6, %7)
    let %9: unit = call f13(%1, %0, 0, 0, f14.m0)
    return ()
  }
}
.fn T$start #f18 : fn() -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: double = load_symbol ::5
    let %1: double = load_symbol ::4
    let %2: int32 = load_symbol ::2
    let %3: double = load_symbol ::1
    let %4: unit = call f14(%0, %1, %2, %3)
    return %4
  }
}
.thunk ::0 limit.1
.thunk ::1 limit_sq.2
.thunk ::2 iter.3
.thunk ::3 _4
.thunk ::4 c_re.5
.thunk ::5 c_im.6
.thunk ::6 start
