let rec iter: (arr: Array[Int], len: Int) -> ((Int) -> Bool) -> Bool {
  let rec do: (yield: Var((Int) -> Bool)) -> Bool {
    let rec next: (i: Var(Int)) -> Bool {
      if (LE(Var("i"), Prim(Var("len"), Int(1), Sub, kind=Some(Int)))) then {
        if (App(Var("yield"), [Get(Var("arr"), Var("i"))])) then {
          Apply(Var("next"), [Prim(Var("i"), Int(1), Add, kind=Some(Int)), ])
        } else {
          Bool(false)
        }
      } else {
        Bool(false)
      }
    }
    Apply(Var("next"), [Int(0), ])
  }
  Var(do)
}
let rec each: (iter: ((Int) -> Bool) -> Bool, f: (Int) -> Unit) -> Unit {
  let rec yield: (x: Var(Int)) -> Bool {
    let _: Var(Unit) = Apply(Var("f"), [Var("x"), ])
    Bool(true)
  }
  let rec do: () -> Var(Unit) {
    if (App(Var("iter"), [Var("yield")])) then {
      Apply(Var("do"), [])
    } else {
      Unit
    }
  }
  Apply(Var("do"), [])
}
let rec main: () -> Var(Unit) {
  let arr: Var(Array[Int]) = Array::make(Int(5), Int(1))
  let _: Var(Unit) = Put Var("arr")[Int(0)] = Int(1)
  let _: Var(Unit) = Put Var("arr")[Int(1)] = Int(2)
  let _: Var(Unit) = Put Var("arr")[Int(2)] = Int(3)
  let _: Var(Unit) = Put Var("arr")[Int(3)] = Int(4)
  let _: Var(Unit) = Put Var("arr")[Int(4)] = Int(5)
  let f: Var(((Int) -> Bool) -> Bool) = Apply(Var("iter"), [Var("arr"), Int(5), ])
  let rec print: (x: Var(Int)) -> Unit {
    Apply(Var("print_int"), [Var("x"), ])
  }
  Apply(Var("each"), [Var("f"), Var("print"), ])
}
Unit
