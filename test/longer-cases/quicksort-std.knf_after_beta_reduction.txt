let rec insertion_sort.20: Unit = (arr.21: Array(Int), low.22: Int, high.23: Int) {
  let rec g.24: Unit = (j.25: Int) {
    let join g.212: Unit = (j.213: Int) {
      let _214: Int = Int(1)
      let _215: Int = Add(_214, low.22)
      if (_215 <= j.213) then {
        let _216: Int = Get arr.21[j.213]
        let _217: Int = Int(1)
        let _218: Int = Sub(j.213, _217)
        let _219: Int = Get arr.21[_218]
        let _220: Int = Int(1)
        let _221: Int = Sub(_219, _220)
        if (_216 <= _221) then {
          let _222: Int = Int(1)
          let _223: Int = Sub(j.213, _222)
          let tmp.266: Int = Get arr.21[j.213]
          let _267: Int = Get arr.21[_223]
          let _268: Unit = Put arr.21[j.213] = _267
          let _269: Unit = Put arr.21[_223] = tmp.266
          let _224: Unit = Unit
          let _225: Int = Int(1)
          let _226: Int = Sub(j.213, _225)
          Jump(g.212, [_226, ])
        } else {
          Unit
        }
      } else {
        Unit
      }
    }
    Jump(g.212, [j.25, ])
  }
  let _46: Int = Int(1)
  let _47: Int = Add(low.22, _46)
  let join f.270: Unit = (i.271: Int) {
    let _272: Int = Int(1)
    let _273: Int = Sub(high.23, _272)
    if (i.271 <= _273) then {
      let _274: Unit = Apply(g.24, [i.271, ])
      let _275: Int = Int(1)
      let _276: Int = Add(i.271, _275)
      Jump(f.270, [_276, ])
    } else {
      Unit
    }
  }
  Jump(f.270, [_47, ])
}
let rec partition.48: Tuple([Int, Bool]) = (arr.49: Array(Int), pivot_index.50: Int, low.51: Int, high.52: Int) {
  let _53: Int = Int(1)
  let _54: Int = Sub(high.52, _53)
  let tmp.285: Int = Get arr.49[pivot_index.50]
  let _286: Int = Get arr.49[_54]
  let _287: Unit = Put arr.49[pivot_index.50] = _286
  let _288: Unit = Put arr.49[_54] = tmp.285
  let _55: Unit = Unit
  let _56: Int = Int(1)
  let _57: Int = Sub(high.52, _56)
  let pivot.58: Int = Get arr.49[_57]
  let _59: Int = Int(1)
  let i.60: Array(Int) = ExtApply(minimbt_create_array, [_59, low.51, ])
  let _61: Int = Int(1)
  let _62: Int = Int(1)
  let partitioned.63: Array(Int) = ExtApply(minimbt_create_array, [_61, _62, ])
  let rec aux.64: Var({val: Some(Unit)}) = (j.65: Int) {
    let join aux.234: Var({val: Some(Unit)}) = (j.235: Int) {
      let _236: Int = Int(2)
      let _237: Int = Sub(high.52, _236)
      if (j.235 <= _237) then {
        let _238: Int = Get arr.49[j.235]
        let _239: Int = Int(1)
        let _240: Int = Sub(pivot.58, _239)
        if (_238 <= _240) then {
          let _242: Int = Int(0)
          let _243: Int = Get i.60[_242]
          if (_243 == j.235) then {
            let _244: Unit = Unit
            let _250: Int = Int(0)
            let _251: Int = Int(0)
            let _252: Int = Get i.60[_251]
            let _253: Int = Int(1)
            let _254: Int = Add(_252, _253)
            let _255: Unit = Put i.60[_250] = _254
            let _241: Unit = Unit
            let _256: Int = Int(1)
            let _257: Int = Add(j.235, _256)
            Jump(aux.234, [_257, ])
          } else {
            let _245: Int = Int(0)
            let _246: Int = Get i.60[_245]
            let tmp.289: Int = Get arr.49[_246]
            let _290: Int = Get arr.49[j.235]
            let _291: Unit = Put arr.49[_246] = _290
            let _292: Unit = Put arr.49[j.235] = tmp.289
            let _247: Unit = Unit
            let _248: Int = Int(0)
            let _249: Int = Int(0)
            let _244: Unit = Put partitioned.63[_248] = _249
            let _250: Int = Int(0)
            let _251: Int = Int(0)
            let _252: Int = Get i.60[_251]
            let _253: Int = Int(1)
            let _254: Int = Add(_252, _253)
            let _255: Unit = Put i.60[_250] = _254
            let _241: Unit = Unit
            let _256: Int = Int(1)
            let _257: Int = Add(j.235, _256)
            Jump(aux.234, [_257, ])
          }
        } else {
          let _241: Unit = Unit
          let _256: Int = Int(1)
          let _257: Int = Add(j.235, _256)
          Jump(aux.234, [_257, ])
        }
      } else {
        Unit
      }
    }
    Jump(aux.234, [j.65, ])
  }
  let _88: Var({val: Some(Unit)}) = Apply(aux.64, [low.51, ])
  let _89: Int = Int(0)
  let _90: Int = Get i.60[_89]
  let _91: Int = Int(1)
  let _92: Int = Sub(high.52, _91)
  let tmp.293: Int = Get arr.49[_90]
  let _294: Int = Get arr.49[_92]
  let _295: Unit = Put arr.49[_90] = _294
  let _296: Unit = Put arr.49[_92] = tmp.293
  let _93: Unit = Unit
  let _94: Int = Int(0)
  let _95: Int = Get i.60[_94]
  let _96: Int = Int(0)
  let _97: Int = Get partitioned.63[_96]
  let _98: Int = Int(1)
  if (_97 == _98) then {
    let _99: Int = Bool(true)
    Tuple([_95, _99, ])
  } else {
    let _99: Int = Bool(false)
    Tuple([_95, _99, ])
  }
}
let rec choose_pivot.100: Tuple([Int, Bool]) = (arr.101: Array(Int), low.102: Int, high.103: Int) {
  let use_median_of_medians.104: Int = Int(50)
  let _105: Int = Int(1)
  let _106: Int = Int(0)
  let swaps.107: Array(Int) = ExtApply(minimbt_create_array, [_105, _106, ])
  let len.108: Int = Sub(high.103, low.102)
  let _109: Int = Int(4)
  let _110: Int = Div(len.108, _109)
  let _111: Int = Int(2)
  let _112: Int = Mul(_110, _111)
  let b.113: Int = Add(low.102, _112)
  let _114: Int = Int(8)
  if (_114 <= len.108) then {
    let _115: Int = Int(4)
    let _116: Int = Div(len.108, _115)
    let _117: Int = Int(1)
    let _118: Int = Mul(_116, _117)
    let a.119: Int = Add(low.102, _118)
    let _120: Int = Int(4)
    let _121: Int = Div(len.108, _120)
    let _122: Int = Int(3)
    let _123: Int = Mul(_121, _122)
    let c.124: Int = Add(low.102, _123)
    let rec sort_2.125: Var({val: Some(Unit)}) = (a.126: Int, b.127: Int) {
      let _128: Int = Get arr.101[b.127]
      let _129: Int = Get arr.101[a.126]
      let _130: Int = Int(1)
      let _131: Int = Sub(_129, _130)
      if (_128 <= _131) then {
        let tmp.297: Int = Get arr.101[a.126]
        let _298: Int = Get arr.101[b.127]
        let _299: Unit = Put arr.101[a.126] = _298
        let _300: Unit = Put arr.101[b.127] = tmp.297
        let _132: Unit = Unit
        let _133: Int = Int(0)
        let _134: Int = Int(0)
        let _135: Int = Get swaps.107[_134]
        let _136: Int = Int(1)
        let _137: Int = Add(_135, _136)
        Put swaps.107[_133] = _137
      } else {
        Unit
      }
    }
    let _144: Int = Int(1)
    let _145: Int = Sub(len.108, _144)
    if (use_median_of_medians.104 <= _145) then {
      let _146: Int = Int(1)
      let _147: Int = Sub(a.119, _146)
      let _148: Int = Int(1)
      let _149: Int = Add(a.119, _148)
      let _315: Var({val: Some(Unit)}) = Apply(sort_2.125, [_147, a.119, ])
      let _316: Var({val: Some(Unit)}) = Apply(sort_2.125, [a.119, _149, ])
      let _150: Var({val: Some(Unit)}) = Apply(sort_2.125, [_147, a.119, ])
      let _151: Int = Int(1)
      let _152: Int = Sub(b.113, _151)
      let _153: Int = Int(1)
      let _154: Int = Add(b.113, _153)
      let _323: Var({val: Some(Unit)}) = Apply(sort_2.125, [_152, b.113, ])
      let _324: Var({val: Some(Unit)}) = Apply(sort_2.125, [b.113, _154, ])
      let _155: Var({val: Some(Unit)}) = Apply(sort_2.125, [_152, b.113, ])
      let _156: Int = Int(1)
      let _157: Int = Sub(c.124, _156)
      let _158: Int = Int(1)
      let _159: Int = Add(c.124, _158)
      let _327: Var({val: Some(Unit)}) = Apply(sort_2.125, [_157, c.124, ])
      let _328: Var({val: Some(Unit)}) = Apply(sort_2.125, [c.124, _159, ])
      let _160: Var({val: Some(Unit)}) = Apply(sort_2.125, [_157, c.124, ])
      let _329: Var({val: Some(Unit)}) = Apply(sort_2.125, [a.119, b.113, ])
      let _330: Var({val: Some(Unit)}) = Apply(sort_2.125, [b.113, c.124, ])
      let _161: Var({val: Some(Unit)}) = Apply(sort_2.125, [a.119, b.113, ])
      let _162: Int = Int(0)
      let _163: Int = Get swaps.107[_162]
      let _164: Int = Int(0)
      if (_163 == _164) then {
        let _165: Int = Bool(true)
        Tuple([b.113, _165, ])
      } else {
        let _165: Int = Bool(false)
        Tuple([b.113, _165, ])
      }
    } else {
      let _160: Var({val: Some(Unit)}) = Unit
      let _331: Var({val: Some(Unit)}) = Apply(sort_2.125, [a.119, b.113, ])
      let _332: Var({val: Some(Unit)}) = Apply(sort_2.125, [b.113, c.124, ])
      let _161: Var({val: Some(Unit)}) = Apply(sort_2.125, [a.119, b.113, ])
      let _162: Int = Int(0)
      let _163: Int = Get swaps.107[_162]
      let _164: Int = Int(0)
      if (_163 == _164) then {
        let _165: Int = Bool(true)
        Tuple([b.113, _165, ])
      } else {
        let _165: Int = Bool(false)
        Tuple([b.113, _165, ])
      }
    }
  } else {
    let _161: Var({val: Some(Unit)}) = Unit
    let _162: Int = Int(0)
    let _163: Int = Get swaps.107[_162]
    let _164: Int = Int(0)
    if (_163 == _164) then {
      let _165: Int = Bool(true)
      Tuple([b.113, _165, ])
    } else {
      let _165: Int = Bool(false)
      Tuple([b.113, _165, ])
    }
  }
}
let rec quick_sort.166: Unit = (arr.167: Array(Int), low.168: Int, high.169: Int) {
  let len.170: Int = Sub(high.169, low.168)
  let _171: Int = Int(16)
  if (len.170 <= _171) then {
    Apply(insertion_sort.20, [arr.167, low.168, high.169, ])
  } else {
    let _172: Tuple([Int, Bool]) = Apply(choose_pivot.100, [arr.167, low.168, high.169, ])
    let (pivot_index.173: Var({val: Some(Int)}), likely_sorted.174: Var({val: Some(Bool)})) = _172
    let _175: Tuple([Int, Bool]) = Apply(partition.48, [arr.167, pivot_index.173, low.168, high.169, ])
    let (pivot.176: Var({val: Some(Int)}), partitioned.177: Var({val: Some(Bool)})) = _175
    let _178: Unit = Apply(quick_sort.166, [arr.167, low.168, pivot.176, ])
    let _179: Int = Int(1)
    let _180: Int = Add(pivot.176, _179)
    Apply(quick_sort.166, [arr.167, _180, high.169, ])
  }
}
let rec main.185: Var({val: Some(Unit)}) = () {
  let len.186: Int = ExtApply(minimbt_read_int, [])
  let _187: Int = Int(0)
  let arr.188: Array(Int) = ExtApply(minimbt_create_array, [len.186, _187, ])
  let _197: Int = Int(0)
  let join input.356: Var({val: Some(Unit)}) = (i.357: Int) {
    let _358: Int = Int(1)
    let _359: Int = Sub(len.186, _358)
    if (i.357 <= _359) then {
      let _360: Int = ExtApply(minimbt_read_int, [])
      let _361: Unit = Put arr.188[i.357] = _360
      let _362: Int = Int(1)
      let _363: Int = Add(i.357, _362)
      Jump(input.356, [_363, ])
    } else {
      let _198: Var({val: Some(Unit)}) = Unit
      let _375: Int = Int(0)
      let _199: Unit = Apply(quick_sort.166, [arr.188, _375, len.186, ])
      let _200: Int = Int(0)
      let join output.376: Unit = (arr.377: Array(Int), i.378: Int, len.379: Int) {
        let _380: Int = Int(1)
        let _381: Int = Sub(len.379, _380)
        if (i.378 <= _381) then {
          let _382: Int = Get arr.377[i.378]
          let _383: Unit = ExtApply(minimbt_print_int, [_382, ])
          let _384: Unit = ExtApply(minimbt_print_endline, [])
          let _385: Int = Int(1)
          let _386: Int = Add(i.378, _385)
          Jump(output.376, [arr.377, _386, len.379, ])
        } else {
          Unit
        }
      }
      Jump(output.376, [arr.188, _200, len.186, ])
    }
  }
  Jump(input.356, [_197, ])
}
Apply(main.185, [])let rec insertion_sort.20: Unit = (arr.21: Array(Int), low.22: Int, high.23: Int) {
  let rec g.24: Unit = (j.25: Int) {
    let join g.212: Unit = (j.213: Int) {
      let _214: Int = Int(1)
      let _215: Int = Add(_214, low.22)
      if (_215 <= j.213) then {
        let _216: Int = Get arr.21[j.213]
        let _217: Int = Int(1)
        let _218: Int = Sub(j.213, _217)
        let _219: Int = Get arr.21[_218]
        let _220: Int = Int(1)
        let _221: Int = Sub(_219, _220)
        if (_216 <= _221) then {
          let _222: Int = Int(1)
          let _223: Int = Sub(j.213, _222)
          let tmp.266: Int = Get arr.21[j.213]
          let _267: Int = Get arr.21[_223]
          let _268: Unit = Put arr.21[j.213] = _267
          let _269: Unit = Put arr.21[_223] = tmp.266
          let _224: Unit = Unit
          let _225: Int = Int(1)
          let _226: Int = Sub(j.213, _225)
          Jump(g.212, [_226, ])
        } else {
          Unit
        }
      } else {
        Unit
      }
    }
    Jump(g.212, [j.25, ])
  }
  let _46: Int = Int(1)
  let _47: Int = Add(low.22, _46)
  let join f.270: Unit = (i.271: Int) {
    let _272: Int = Int(1)
    let _273: Int = Sub(high.23, _272)
    if (i.271 <= _273) then {
      let _274: Unit = Apply(g.24, [i.271, ])
      let _275: Int = Int(1)
      let _276: Int = Add(i.271, _275)
      Jump(f.270, [_276, ])
    } else {
      Unit
    }
  }
  Jump(f.270, [_47, ])
}
let rec partition.48: Tuple([Int, Bool]) = (arr.49: Array(Int), pivot_index.50: Int, low.51: Int, high.52: Int) {
  let _53: Int = Int(1)
  let _54: Int = Sub(high.52, _53)
  let tmp.285: Int = Get arr.49[pivot_index.50]
  let _286: Int = Get arr.49[_54]
  let _287: Unit = Put arr.49[pivot_index.50] = _286
  let _288: Unit = Put arr.49[_54] = tmp.285
  let _55: Unit = Unit
  let _56: Int = Int(1)
  let _57: Int = Sub(high.52, _56)
  let pivot.58: Int = Get arr.49[_57]
  let _59: Int = Int(1)
  let i.60: Array(Int) = ExtApply(minimbt_create_array, [_59, low.51, ])
  let _61: Int = Int(1)
  let _62: Int = Int(1)
  let partitioned.63: Array(Int) = ExtApply(minimbt_create_array, [_61, _62, ])
  let rec aux.64: Var({val: Some(Unit)}) = (j.65: Int) {
    let join aux.234: Var({val: Some(Unit)}) = (j.235: Int) {
      let _236: Int = Int(2)
      let _237: Int = Sub(high.52, _236)
      if (j.235 <= _237) then {
        let _238: Int = Get arr.49[j.235]
        let _239: Int = Int(1)
        let _240: Int = Sub(pivot.58, _239)
        if (_238 <= _240) then {
          let _242: Int = Int(0)
          let _243: Int = Get i.60[_242]
          if (_243 == j.235) then {
            let _244: Unit = Unit
            let _250: Int = Int(0)
            let _251: Int = Int(0)
            let _252: Int = Get i.60[_251]
            let _253: Int = Int(1)
            let _254: Int = Add(_252, _253)
            let _255: Unit = Put i.60[_250] = _254
            let _241: Unit = Unit
            let _256: Int = Int(1)
            let _257: Int = Add(j.235, _256)
            Jump(aux.234, [_257, ])
          } else {
            let _245: Int = Int(0)
            let _246: Int = Get i.60[_245]
            let tmp.289: Int = Get arr.49[_246]
            let _290: Int = Get arr.49[j.235]
            let _291: Unit = Put arr.49[_246] = _290
            let _292: Unit = Put arr.49[j.235] = tmp.289
            let _247: Unit = Unit
            let _248: Int = Int(0)
            let _249: Int = Int(0)
            let _244: Unit = Put partitioned.63[_248] = _249
            let _250: Int = Int(0)
            let _251: Int = Int(0)
            let _252: Int = Get i.60[_251]
            let _253: Int = Int(1)
            let _254: Int = Add(_252, _253)
            let _255: Unit = Put i.60[_250] = _254
            let _241: Unit = Unit
            let _256: Int = Int(1)
            let _257: Int = Add(j.235, _256)
            Jump(aux.234, [_257, ])
          }
        } else {
          let _241: Unit = Unit
          let _256: Int = Int(1)
          let _257: Int = Add(j.235, _256)
          Jump(aux.234, [_257, ])
        }
      } else {
        Unit
      }
    }
    Jump(aux.234, [j.65, ])
  }
  let _88: Var({val: Some(Unit)}) = Apply(aux.64, [low.51, ])
  let _89: Int = Int(0)
  let _90: Int = Get i.60[_89]
  let _91: Int = Int(1)
  let _92: Int = Sub(high.52, _91)
  let tmp.293: Int = Get arr.49[_90]
  let _294: Int = Get arr.49[_92]
  let _295: Unit = Put arr.49[_90] = _294
  let _296: Unit = Put arr.49[_92] = tmp.293
  let _93: Unit = Unit
  let _94: Int = Int(0)
  let _95: Int = Get i.60[_94]
  let _96: Int = Int(0)
  let _97: Int = Get partitioned.63[_96]
  let _98: Int = Int(1)
  if (_97 == _98) then {
    let _99: Int = Bool(true)
    Tuple([_95, _99, ])
  } else {
    let _99: Int = Bool(false)
    Tuple([_95, _99, ])
  }
}
let rec choose_pivot.100: Tuple([Int, Bool]) = (arr.101: Array(Int), low.102: Int, high.103: Int) {
  let use_median_of_medians.104: Int = Int(50)
  let _105: Int = Int(1)
  let _106: Int = Int(0)
  let swaps.107: Array(Int) = ExtApply(minimbt_create_array, [_105, _106, ])
  let len.108: Int = Sub(high.103, low.102)
  let _109: Int = Int(4)
  let _110: Int = Div(len.108, _109)
  let _111: Int = Int(2)
  let _112: Int = Mul(_110, _111)
  let b.113: Int = Add(low.102, _112)
  let _114: Int = Int(8)
  if (_114 <= len.108) then {
    let _115: Int = Int(4)
    let _116: Int = Div(len.108, _115)
    let _117: Int = Int(1)
    let _118: Int = Mul(_116, _117)
    let a.119: Int = Add(low.102, _118)
    let _120: Int = Int(4)
    let _121: Int = Div(len.108, _120)
    let _122: Int = Int(3)
    let _123: Int = Mul(_121, _122)
    let c.124: Int = Add(low.102, _123)
    let rec sort_2.125: Var({val: Some(Unit)}) = (a.126: Int, b.127: Int) {
      let _128: Int = Get arr.101[b.127]
      let _129: Int = Get arr.101[a.126]
      let _130: Int = Int(1)
      let _131: Int = Sub(_129, _130)
      if (_128 <= _131) then {
        let tmp.297: Int = Get arr.101[a.126]
        let _298: Int = Get arr.101[b.127]
        let _299: Unit = Put arr.101[a.126] = _298
        let _300: Unit = Put arr.101[b.127] = tmp.297
        let _132: Unit = Unit
        let _133: Int = Int(0)
        let _134: Int = Int(0)
        let _135: Int = Get swaps.107[_134]
        let _136: Int = Int(1)
        let _137: Int = Add(_135, _136)
        Put swaps.107[_133] = _137
      } else {
        Unit
      }
    }
    let _144: Int = Int(1)
    let _145: Int = Sub(len.108, _144)
    if (use_median_of_medians.104 <= _145) then {
      let _146: Int = Int(1)
      let _147: Int = Sub(a.119, _146)
      let _148: Int = Int(1)
      let _149: Int = Add(a.119, _148)
      let _315: Var({val: Some(Unit)}) = Apply(sort_2.125, [_147, a.119, ])
      let _316: Var({val: Some(Unit)}) = Apply(sort_2.125, [a.119, _149, ])
      let _150: Var({val: Some(Unit)}) = Apply(sort_2.125, [_147, a.119, ])
      let _151: Int = Int(1)
      let _152: Int = Sub(b.113, _151)
      let _153: Int = Int(1)
      let _154: Int = Add(b.113, _153)
      let _323: Var({val: Some(Unit)}) = Apply(sort_2.125, [_152, b.113, ])
      let _324: Var({val: Some(Unit)}) = Apply(sort_2.125, [b.113, _154, ])
      let _155: Var({val: Some(Unit)}) = Apply(sort_2.125, [_152, b.113, ])
      let _156: Int = Int(1)
      let _157: Int = Sub(c.124, _156)
      let _158: Int = Int(1)
      let _159: Int = Add(c.124, _158)
      let _327: Var({val: Some(Unit)}) = Apply(sort_2.125, [_157, c.124, ])
      let _328: Var({val: Some(Unit)}) = Apply(sort_2.125, [c.124, _159, ])
      let _160: Var({val: Some(Unit)}) = Apply(sort_2.125, [_157, c.124, ])
      let _329: Var({val: Some(Unit)}) = Apply(sort_2.125, [a.119, b.113, ])
      let _330: Var({val: Some(Unit)}) = Apply(sort_2.125, [b.113, c.124, ])
      let _161: Var({val: Some(Unit)}) = Apply(sort_2.125, [a.119, b.113, ])
      let _162: Int = Int(0)
      let _163: Int = Get swaps.107[_162]
      let _164: Int = Int(0)
      if (_163 == _164) then {
        let _165: Int = Bool(true)
        Tuple([b.113, _165, ])
      } else {
        let _165: Int = Bool(false)
        Tuple([b.113, _165, ])
      }
    } else {
      let _160: Var({val: Some(Unit)}) = Unit
      let _331: Var({val: Some(Unit)}) = Apply(sort_2.125, [a.119, b.113, ])
      let _332: Var({val: Some(Unit)}) = Apply(sort_2.125, [b.113, c.124, ])
      let _161: Var({val: Some(Unit)}) = Apply(sort_2.125, [a.119, b.113, ])
      let _162: Int = Int(0)
      let _163: Int = Get swaps.107[_162]
      let _164: Int = Int(0)
      if (_163 == _164) then {
        let _165: Int = Bool(true)
        Tuple([b.113, _165, ])
      } else {
        let _165: Int = Bool(false)
        Tuple([b.113, _165, ])
      }
    }
  } else {
    let _161: Var({val: Some(Unit)}) = Unit
    let _162: Int = Int(0)
    let _163: Int = Get swaps.107[_162]
    let _164: Int = Int(0)
    if (_163 == _164) then {
      let _165: Int = Bool(true)
      Tuple([b.113, _165, ])
    } else {
      let _165: Int = Bool(false)
      Tuple([b.113, _165, ])
    }
  }
}
let rec quick_sort.166: Unit = (arr.167: Array(Int), low.168: Int, high.169: Int) {
  let len.170: Int = Sub(high.169, low.168)
  let _171: Int = Int(16)
  if (len.170 <= _171) then {
    Apply(insertion_sort.20, [arr.167, low.168, high.169, ])
  } else {
    let _172: Tuple([Int, Bool]) = Apply(choose_pivot.100, [arr.167, low.168, high.169, ])
    let (pivot_index.173: Var({val: Some(Int)}), likely_sorted.174: Var({val: Some(Bool)})) = _172
    let _175: Tuple([Int, Bool]) = Apply(partition.48, [arr.167, pivot_index.173, low.168, high.169, ])
    let (pivot.176: Var({val: Some(Int)}), partitioned.177: Var({val: Some(Bool)})) = _175
    let _178: Unit = Apply(quick_sort.166, [arr.167, low.168, pivot.176, ])
    let _179: Int = Int(1)
    let _180: Int = Add(pivot.176, _179)
    Apply(quick_sort.166, [arr.167, _180, high.169, ])
  }
}
let rec main.185: Var({val: Some(Unit)}) = () {
  let len.186: Int = ExtApply(minimbt_read_int, [])
  let _187: Int = Int(0)
  let arr.188: Array(Int) = ExtApply(minimbt_create_array, [len.186, _187, ])
  let _197: Int = Int(0)
  let join input.356: Var({val: Some(Unit)}) = (i.357: Int) {
    let _358: Int = Int(1)
    let _359: Int = Sub(len.186, _358)
    if (i.357 <= _359) then {
      let _360: Int = ExtApply(minimbt_read_int, [])
      let _361: Unit = Put arr.188[i.357] = _360
      let _362: Int = Int(1)
      let _363: Int = Add(i.357, _362)
      Jump(input.356, [_363, ])
    } else {
      let _198: Var({val: Some(Unit)}) = Unit
      let _375: Int = Int(0)
      let _199: Unit = Apply(quick_sort.166, [arr.188, _375, len.186, ])
      let _200: Int = Int(0)
      let join output.376: Unit = (arr.377: Array(Int), i.378: Int, len.379: Int) {
        let _380: Int = Int(1)
        let _381: Int = Sub(len.379, _380)
        if (i.378 <= _381) then {
          let _382: Int = Get arr.377[i.378]
          let _383: Unit = ExtApply(minimbt_print_int, [_382, ])
          let _384: Unit = ExtApply(minimbt_print_endline, [])
          let _385: Int = Int(1)
          let _386: Int = Add(i.378, _385)
          Jump(output.376, [arr.377, _386, len.379, ])
        } else {
          Unit
        }
      }
      Jump(output.376, [arr.188, _200, len.186, ])
    }
  }
  Jump(input.356, [_197, ])
}
Apply(main.185, [])