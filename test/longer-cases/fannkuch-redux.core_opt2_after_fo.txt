# name conventions used in the core ir:
# - functions: f<id>
# - blocks: b<id>
# - instructions: %<id>
# - memory: m<id>
# - free variables: ^<id>
# - function parameters: $f<pid>
# - block parameters: $b<bid>.<pid>
.core
.fn move_perm1_forward.238 #f6 : fn(int32, array[int32], array[int32]) -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: int32 = load int32 field($f1, 0 * @32)
    let %1: int32 = sub(%0, 1)
    let %2: bool = le($f0, %1)
    br %2 b1() b2()
  }
  .bb #b1 () {
    let %3: int32 = add($f0, 1)
    let %10: ptr = compute_address unit offset(0, %3 * @32)
    let %4: int32 = load int32 raw($f2, %10)
    let %9: ptr = compute_address unit offset(0, $f0 * @32)
    let _ = store int32 raw($f2, %9) <- %4
    let %7: unit = call f6(%3, $f1, $f2)
    jump b3(())
  }
  .bb #b2 () {
    jump b3(())
  }
  .bb #b3 (unit) {
    return $b3.0
  }
}
.fn fannkuch.229 #f11 : fn(int32) -> (int32, int32)
.freevars ()
.entry b0 {
  .bb #b0 () {
    jump b12()
  }
  .bb #b1 (array[int32]) {
    let _ = alloc <m0: array[int32] heap($f0)> <- [..] = 0
    let _ = alloc <m1: array[int32] heap($f0)> <- [..] = 0
    let _ = alloc <m2: array[int32] heap(1)> <- [..] = 0
    let _ = alloc <m3: array[int32] heap(1)> <- [..] = 0
    let _ = alloc <m4: array[int32] heap(1)> <- [..] = 0
    let _ = alloc <m5: array[int32] heap(1)> <- [..] = 0
    let _ = alloc <m6: array[int32] heap(1)> <- [..] = $f0
    jump b22()
  }
  .bb #b2 (unit) {
    let %9: int32 = load int32 field(f11.m3, 0 * @32)
    let %10: int32 = load int32 field(f11.m4, 0 * @32)
    let _ = alloc <m7: (int32, int32) heap(2)> <- [0] = %9, [1] = %10
    return f11.m7
  }
  .bb #b12 () {
    let _ = alloc <m12: array[int32] heap($f0)> <- [..] = 0
    let %13: unit = call f0(0, f11.m12, $f0)
    jump b1(f11.m12)
  }
  .bb #b14 (array[int32], int32, array[int32], array[int32], array[int32], array[int32], array[int32], array[int32], array[int32]) {
    let %14: int32 = load int32 field($b14.0, 0 * @32)
    let %15: bool = le(1, %14)
    br %15 b15() b16()
  }
  .bb #b15 () {
    jump b95()
  }
  .bb #b16 () {
    jump b20(())
  }
  .bb #b17 () {
    let %25: int32 = load int32 field($b14.4, 0 * @32)
    let _ = store int32 field($b14.8, 0 * @32) <- %25
    let %27: int32 = load int32 field($b14.7, 0 * @32)
    let %28: int32 = load int32 field($b14.4, 0 * @32)
    let %29: int32 = load int32 field($b14.5, 0 * @32)
    let %31: int32 = div(%29, 2)
    let %32: int32 = mul(%31, 2)
    let %33: int32 = sub(%29, %32)
    let %34: int32 = mul(%33, 2)
    let %35: int32 = sub(1, %34)
    let %36: int32 = mul(%28, %35)
    let %37: int32 = add(%27, %36)
    let _ = store int32 field($b14.7, 0 * @32) <- %37
    let _ = alloc <m15: array[int32] heap(1)> <- [..] = true
    let _ = alloc <m16: array[int32] heap(1)> <- [..] = 0
    jump b115()
  }
  .bb #b18 () {
    let %46: int32 = load int32 field($b14.7, 0 * @32)
    let %47: int32 = load int32 field($b14.4, 0 * @32)
    let %48: int32 = load int32 field($b14.5, 0 * @32)
    let %50: int32 = div(%48, 2)
    let %51: int32 = mul(%50, 2)
    let %52: int32 = sub(%48, %51)
    let %53: int32 = mul(%52, 2)
    let %54: int32 = sub(1, %53)
    let %55: int32 = mul(%47, %54)
    let %56: int32 = add(%46, %55)
    let _ = store int32 field($b14.7, 0 * @32) <- %56
    let _ = alloc <m17: array[int32] heap(1)> <- [..] = true
    let _ = alloc <m18: array[int32] heap(1)> <- [..] = 0
    jump b75()
  }
  .bb #b19 (unit) {
    jump b20($b19.0)
  }
  .bb #b20 (unit) {
    jump b2($b20.0)
  }
  .loop #b21 pre #Some(b22) header #b14 {
    .block #b20
    .block #b18
    .block #b15
    .block #b19
    .block #b16
    .block #b17
  }
  .bb #b22 () {
    jump b21(f11.m6, $f0, f11.m0, f11.m1, f11.m2, f11.m5, $b1.0, f11.m4, f11.m3)
  }
  .bb #b23 (unit) {
    let %61: int32 = load int32 field($b14.5, 0 * @32)
    let %62: int32 = add(%61, 1)
    let _ = store int32 field($b14.5, 0 * @32) <- %62
    jump b14($b14.0, $b14.1, $b14.2, $b14.3, $b14.4, $b14.5, $b14.6, $b14.7, $b14.8)
  }
  .bb #b24 (unit) {
    let %17: unit = call f3($b14.0, $b14.3)
    let _ = store int32 field($b14.4, 0 * @32) <- 0
    let %19: int32 = load int32 field($b14.2, 0 * @32)
    let _ = alloc <m14: array[int32] heap(1)> <- [..] = %19
    jump b101()
  }
  .bb #b25 (unit) {
    let %22: int32 = load int32 field($b14.8, 0 * @32)
    let %23: int32 = load int32 field($b14.4, 0 * @32)
    let %24: bool = le(%22, %23)
    br %24 b17() b18()
  }
  .bb #b26 (unit) {
    let %42: int32 = load int32 field($b14.5, 0 * @32)
    let %43: int32 = add(%42, 1)
    let _ = store int32 field($b14.5, 0 * @32) <- %43
    jump b14($b14.0, $b14.1, $b14.2, $b14.3, $b14.4, $b14.5, $b14.6, $b14.7, $b14.8)
  }
  .bb #b64 (int32, array[int32], array[int32], array[bool], array[int32], array[int32]) {
    let %64: bool = load bool field($b64.3, 0 * @32)
    let %65: bool = eq(%64, true)
    br %65 b65() b66()
  }
  .bb #b65 () {
    let %66: int32 = load int32 field($b64.1, 0 * @32)
    let %67: bool = eq(%66, $b64.0)
    br %67 b67() b68()
  }
  .bb #b66 () {
    jump b73(())
  }
  .bb #b67 () {
    let _ = store bool field($b64.3, 0 * @32) <- false
    let _ = store int32 field($b64.1, 0 * @32) <- 0
    jump b64($b64.0, $b64.1, $b64.2, $b64.3, $b64.4, $b64.5)
  }
  .bb #b68 () {
    let %71: int32 = load int32 field($b64.5, 0 * @32)
    let _ = store int32 field($b64.2, 0 * @32) <- %71
    let %73: unit = call f8(0, $b64.1, $b64.5)
    let %74: int32 = load int32 field($b64.1, 0 * @32)
    let %75: int32 = load int32 field($b64.2, 0 * @32)
    let %149: ptr = compute_address unit offset(0, %74 * @32)
    let _ = store int32 raw($b64.5, %149) <- %75
    let %77: int32 = load int32 field($b64.1, 0 * @32)
    let %148: ptr = compute_address unit offset(0, %77 * @32)
    let %79: int32 = load int32 raw($b64.4, %148)
    let %80: int32 = sub(%79, 1)
    let %146: ptr = compute_address unit offset(0, %77 * @32)
    let _ = store int32 raw($b64.4, %146) <- %80
    let %82: int32 = load int32 field($b64.1, 0 * @32)
    let %143: ptr = compute_address unit offset(0, %82 * @32)
    let %83: int32 = load int32 raw($b64.4, %143)
    let %84: bool = le(1, %83)
    br %84 b69() b70()
  }
  .bb #b69 () {
    let _ = store bool field($b64.3, 0 * @32) <- false
    jump b64($b64.0, $b64.1, $b64.2, $b64.3, $b64.4, $b64.5)
  }
  .bb #b70 () {
    let %87: int32 = load int32 field($b64.1, 0 * @32)
    let %88: int32 = add(%87, 1)
    let _ = store int32 field($b64.1, 0 * @32) <- %88
    jump b64($b64.0, $b64.1, $b64.2, $b64.3, $b64.4, $b64.5)
  }
  .bb #b71 (unit) {
    jump b72($b71.0)
  }
  .bb #b72 (unit) {
    jump b73($b72.0)
  }
  .bb #b73 (unit) {
    jump b23($b73.0)
  }
  .loop #b74 pre #Some(b75) header #b64 {
    .block #b70
    .block #b68
    .block #b72
    .block #b73
    .block #b65
    .block #b69
    .block #b66
    .block #b67
    .block #b71
  }
  .bb #b75 () {
    jump b74($b14.1, $b14.0, f11.m18, f11.m17, $b14.3, $b14.6)
  }
  .bb #b90 (int32, int32, array[int32], array[int32]) {
    let %90: int32 = sub($b90.1, 1)
    let %91: bool = le($b90.0, %90)
    br %91 b91() b92()
  }
  .bb #b91 () {
    let %152: ptr = compute_address unit offset(0, $b90.0 * @32)
    let %92: int32 = load int32 raw($b90.3, %152)
    let %151: ptr = compute_address unit offset(0, $b90.0 * @32)
    let _ = store int32 raw($b90.2, %151) <- %92
    let %94: int32 = add($b90.0, 1)
    jump b90(%94, $b90.1, $b90.2, $b90.3)
  }
  .bb #b92 () {
    jump b93(())
  }
  .bb #b93 (unit) {
    jump b24($b93.0)
  }
  .loop #b94 pre #Some(b95) header #b90 {
    .block #b91
    .block #b92
    .block #b93
  }
  .bb #b95 () {
    jump b94(0, $b14.1, $b14.2, $b14.6)
  }
  .bb #b96 (array[int32], array[int32], array[int32]) {
    let %95: int32 = load int32 field($b96.0, 0 * @32)
    let %96: bool = eq(%95, 0)
    br %96 b97() b98()
  }
  .bb #b97 () {
    jump b99(())
  }
  .bb #b98 () {
    let _ = alloc <m96: array[int32] heap(1)> <- [..] = 0
    let %98: unit = call f4(0, $b96.0, f11.m96, $b96.1)
    jump b102(%98)
  }
  .bb #b99 (unit) {
    jump b25($b99.0)
  }
  .loop #b100 pre #Some(b101) header #b96 {
    .block #b97
    .block #b98
    .block #b99
  }
  .bb #b101 () {
    jump b100(f11.m14, $b14.2, $b14.4)
  }
  .bb #b102 (unit) {
    let %99: int32 = load int32 field($b96.1, 0 * @32)
    let _ = store int32 field($b96.0, 0 * @32) <- %99
    let %101: int32 = load int32 field($b96.2, 0 * @32)
    let %102: int32 = add(%101, 1)
    let _ = store int32 field($b96.2, 0 * @32) <- %102
    jump b96($b96.0, $b96.1, $b96.2)
  }
  .bb #b104 (int32, array[int32], array[int32], array[bool], array[int32], array[int32]) {
    let %104: bool = load bool field($b104.3, 0 * @32)
    let %105: bool = eq(%104, true)
    br %105 b105() b106()
  }
  .bb #b105 () {
    let %106: int32 = load int32 field($b104.1, 0 * @32)
    let %107: bool = eq(%106, $b104.0)
    br %107 b107() b108()
  }
  .bb #b106 () {
    jump b113(())
  }
  .bb #b107 () {
    let _ = store bool field($b104.3, 0 * @32) <- false
    let _ = store int32 field($b104.1, 0 * @32) <- 0
    jump b104($b104.0, $b104.1, $b104.2, $b104.3, $b104.4, $b104.5)
  }
  .bb #b108 () {
    let %111: int32 = load int32 field($b104.5, 0 * @32)
    let _ = store int32 field($b104.2, 0 * @32) <- %111
    let %113: unit = call f6(0, $b104.1, $b104.5)
    let %114: int32 = load int32 field($b104.1, 0 * @32)
    let %115: int32 = load int32 field($b104.2, 0 * @32)
    let %139: ptr = compute_address unit offset(0, %114 * @32)
    let _ = store int32 raw($b104.5, %139) <- %115
    let %117: int32 = load int32 field($b104.1, 0 * @32)
    let %138: ptr = compute_address unit offset(0, %117 * @32)
    let %119: int32 = load int32 raw($b104.4, %138)
    let %120: int32 = sub(%119, 1)
    let %136: ptr = compute_address unit offset(0, %117 * @32)
    let _ = store int32 raw($b104.4, %136) <- %120
    let %122: int32 = load int32 field($b104.1, 0 * @32)
    let %133: ptr = compute_address unit offset(0, %122 * @32)
    let %123: int32 = load int32 raw($b104.4, %133)
    let %124: bool = le(1, %123)
    br %124 b109() b110()
  }
  .bb #b109 () {
    let _ = store bool field($b104.3, 0 * @32) <- false
    jump b104($b104.0, $b104.1, $b104.2, $b104.3, $b104.4, $b104.5)
  }
  .bb #b110 () {
    let %127: int32 = load int32 field($b104.1, 0 * @32)
    let %128: int32 = add(%127, 1)
    let _ = store int32 field($b104.1, 0 * @32) <- %128
    jump b104($b104.0, $b104.1, $b104.2, $b104.3, $b104.4, $b104.5)
  }
  .bb #b111 (unit) {
    jump b112($b111.0)
  }
  .bb #b112 (unit) {
    jump b113($b112.0)
  }
  .bb #b113 (unit) {
    jump b26($b113.0)
  }
  .loop #b114 pre #Some(b115) header #b104 {
    .block #b110
    .block #b108
    .block #b112
    .block #b113
    .block #b105
    .block #b109
    .block #b106
    .block #b107
    .block #b111
  }
  .bb #b115 () {
    jump b114($b14.1, $b14.0, f11.m16, f11.m15, $b14.3, $b14.6)
  }
}
.fn move_perm1_forward.240 #f8 : fn(int32, array[int32], array[int32]) -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: int32 = load int32 field($f1, 0 * @32)
    let %1: int32 = sub(%0, 1)
    let %2: bool = le($f0, %1)
    br %2 b1() b2()
  }
  .bb #b1 () {
    let %3: int32 = add($f0, 1)
    let %10: ptr = compute_address unit offset(0, %3 * @32)
    let %4: int32 = load int32 raw($f2, %10)
    let %9: ptr = compute_address unit offset(0, $f0 * @32)
    let _ = store int32 raw($f2, %9) <- %4
    let %7: unit = call f8(%3, $f1, $f2)
    jump b3(())
  }
  .bb #b2 () {
    jump b3(())
  }
  .bb #b3 (unit) {
    return $b3.0
  }
}
.fn init_arr.231 #f0 : fn(int32, array[int32], int32) -> unit
.freevars ()
.entry b5 {
  .bb #b0 (int32, array[int32], int32) {
    let %0: int32 = sub($b0.2, 1)
    let %1: bool = le($b0.0, %0)
    br %1 b1() b2()
  }
  .bb #b1 () {
    let %4: ptr = compute_address unit offset(0, $b0.0 * @32)
    let _ = store int32 raw($b0.1, %4) <- $b0.0
    let %3: int32 = add($b0.0, 1)
    jump b0(%3, $b0.1, $b0.2)
  }
  .bb #b2 () {
    jump b3(())
  }
  .bb #b3 (unit) {
    return $b3.0
  }
  .loop #b4 pre #Some(b5) header #b0 {
    .block #b1
    .block #b2
    .block #b3
  }
  .bb #b5 () {
    jump b4($f0, $f1, $f2)
  }
}
.fn init_count.234 #f3 : fn(array[int32], array[int32]) -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: int32 = load int32 field($f0, 0 * @32)
    let %1: bool = eq(%0, 1)
    br %1 b1() b2()
  }
  .bb #b1 () {
    jump b3(())
  }
  .bb #b2 () {
    let %2: int32 = load int32 field($f0, 0 * @32)
    let %3: int32 = sub(%2, 1)
    let %10: ptr = compute_address unit offset(0, %3 * @32)
    let _ = store int32 raw($f1, %10) <- %2
    let %6: int32 = load int32 field($f0, 0 * @32)
    let %7: int32 = sub(%6, 1)
    let _ = store int32 field($f0, 0 * @32) <- %7
    let %9: unit = call f3($f0, $f1)
    jump b3(())
  }
  .bb #b3 (unit) {
    return $b3.0
  }
}
.fn main.241 #f12 : fn() -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: (int32, int32) = call f11(9)
    let %1: int32 = load int32 field(%0, 0 * @(@32, @(@32, @32)))
    let %2: int32 = load int32 field(%0, 1 * @(@32, @(@32, @32)))
    let %3: unit = ext_call minimbt_print_int(%2)
    let %4: unit = ext_call minimbt_print_int(%1)
    return %4
  }
}
.fn flip_loop.236 #f4 : fn(int32, array[int32], array[int32], array[int32]) -> unit
.freevars ()
.entry b5 {
  .bb #b0 (int32, array[int32], array[int32], array[int32]) {
    let %0: int32 = load int32 field($b0.1, 0 * @32)
    let %1: int32 = div(%0, 2)
    let %2: bool = le($b0.0, %1)
    br %2 b1() b2()
  }
  .bb #b1 () {
    let %23: ptr = compute_address unit offset(0, $b0.0 * @32)
    let %3: int32 = load int32 raw($b0.3, %23)
    let _ = store int32 field($b0.2, 0 * @32) <- %3
    let %5: int32 = load int32 field($b0.1, 0 * @32)
    let %6: int32 = sub(%5, $b0.0)
    let %22: ptr = compute_address unit offset(0, %6 * @32)
    let %7: int32 = load int32 raw($b0.3, %22)
    let %20: ptr = compute_address unit offset(0, $b0.0 * @32)
    let _ = store int32 raw($b0.3, %20) <- %7
    let %9: int32 = load int32 field($b0.1, 0 * @32)
    let %10: int32 = sub(%9, $b0.0)
    let %11: int32 = load int32 field($b0.2, 0 * @32)
    let %17: ptr = compute_address unit offset(0, %10 * @32)
    let _ = store int32 raw($b0.3, %17) <- %11
    let %13: int32 = add($b0.0, 1)
    jump b0(%13, $b0.1, $b0.2, $b0.3)
  }
  .bb #b2 () {
    jump b3(())
  }
  .bb #b3 (unit) {
    return $b3.0
  }
  .loop #b4 pre #Some(b5) header #b0 {
    .block #b1
    .block #b2
    .block #b3
  }
  .bb #b5 () {
    jump b4($f0, $f1, $f2, $f3)
  }
}
.fn T$start #f26 : fn() -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: unit = call f12()
    return %0
  }
}
.thunk ::0 start
