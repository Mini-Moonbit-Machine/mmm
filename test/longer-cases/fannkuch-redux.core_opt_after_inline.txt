# name conventions used in the core ir:
# - functions: f<id>
# - blocks: b<id>
# - instructions: %<id>
# - memory: m<id>
# - free variables: ^<id>
# - function parameters: $f<pid>
# - block parameters: $b<bid>.<pid>
.core
.fn flip_loop.246 #f3 : fn(int32, array[int32], array[int32], array[int32]) -> unit
.freevars ()
.entry b5 {
  .bb #b0 (int32, array[int32], array[int32], array[int32]) {
    let %0: int32 = load int32 field($b0.1, 0 * @32)
    let %1: int32 = div(%0, 2)
    let %2: bool = le($b0.0, %1)
    br %2 b1() b2()
  }
  .bb #b1 () {
    let %3: int32 = load int32 offset($b0.3, $b0.0 * @32)
    let _ = store int32 field($b0.2, 0 * @32) <- %3
    let %5: int32 = load int32 field($b0.1, 0 * @32)
    let %6: int32 = sub(%5, $b0.0)
    let %7: int32 = load int32 offset($b0.3, %6 * @32)
    let _ = store int32 offset($b0.3, $b0.0 * @32) <- %7
    let %9: int32 = load int32 field($b0.1, 0 * @32)
    let %10: int32 = sub(%9, $b0.0)
    let %11: int32 = load int32 field($b0.2, 0 * @32)
    let _ = store int32 offset($b0.3, %10 * @32) <- %11
    let %13: int32 = add($b0.0, 1)
    jump b0(%13, $b0.1, $b0.2, $b0.3)
  }
  .bb #b2 () {
    jump b3(())
  }
  .bb #b3 (unit) {
    return $b3.0
  }
  .loop #b4 pre #Some(b5) header #b0 {
    .block #b1
    .block #b2
    .block #b3
  }
  .bb #b5 () {
    jump b4($f0, $f1, $f2, $f3)
  }
}
.fn go_loop.247 #f6 : fn(int32, array[int32], array[int32], array[bool], array[int32], array[int32]) -> unit
.freevars ()
.entry b11 {
  .bb #b0 (int32, array[int32], array[int32], array[bool], array[int32], array[int32]) {
    let %0: bool = load bool field($b0.3, 0 * @32)
    let %1: bool = eq(%0, true)
    br %1 b1() b2()
  }
  .bb #b1 () {
    let %2: int32 = load int32 field($b0.1, 0 * @32)
    let %3: bool = eq(%2, $b0.0)
    br %3 b3() b4()
  }
  .bb #b2 () {
    jump b9(())
  }
  .bb #b3 () {
    let _ = store bool field($b0.3, 0 * @32) <- false
    let _ = store int32 field($b0.1, 0 * @32) <- 0
    jump b0($b0.0, $b0.1, $b0.2, $b0.3, $b0.4, $b0.5)
  }
  .bb #b4 () {
    let %7: int32 = load int32 field($b0.4, 0 * @32)
    let _ = store int32 field($b0.2, 0 * @32) <- %7
    let %9: unit = call f5(0, $b0.1, $b0.4)
    let %10: int32 = load int32 field($b0.1, 0 * @32)
    let %11: int32 = load int32 field($b0.2, 0 * @32)
    let _ = store int32 offset($b0.4, %10 * @32) <- %11
    let %13: int32 = load int32 field($b0.1, 0 * @32)
    let %14: int32 = load int32 field($b0.1, 0 * @32)
    let %15: int32 = load int32 offset($b0.5, %14 * @32)
    let %16: int32 = sub(%15, 1)
    let _ = store int32 offset($b0.5, %13 * @32) <- %16
    let %18: int32 = load int32 field($b0.1, 0 * @32)
    let %19: int32 = load int32 offset($b0.5, %18 * @32)
    let %20: bool = le(1, %19)
    br %20 b5() b6()
  }
  .bb #b5 () {
    let _ = store bool field($b0.3, 0 * @32) <- false
    jump b0($b0.0, $b0.1, $b0.2, $b0.3, $b0.4, $b0.5)
  }
  .bb #b6 () {
    let %23: int32 = load int32 field($b0.1, 0 * @32)
    let %24: int32 = add(%23, 1)
    let _ = store int32 field($b0.1, 0 * @32) <- %24
    jump b0($b0.0, $b0.1, $b0.2, $b0.3, $b0.4, $b0.5)
  }
  .bb #b7 (unit) {
    jump b8($b7.0)
  }
  .bb #b8 (unit) {
    jump b9($b8.0)
  }
  .bb #b9 (unit) {
    return $b9.0
  }
  .loop #b10 pre #Some(b11) header #b0 {
    .block #b6
    .block #b4
    .block #b8
    .block #b9
    .block #b1
    .block #b5
    .block #b2
    .block #b3
    .block #b7
  }
  .bb #b11 () {
    jump b10($f0, $f1, $f2, $f3, $f4, $f5)
  }
}
.fn move_perm1_forward.248 #f5 : fn(int32, array[int32], array[int32]) -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: int32 = load int32 field($f1, 0 * @32)
    let %1: int32 = sub(%0, 1)
    let %2: bool = le($f0, %1)
    br %2 b1() b2()
  }
  .bb #b1 () {
    let %3: int32 = add($f0, 1)
    let %4: int32 = load int32 offset($f2, %3 * @32)
    let _ = store int32 offset($f2, $f0 * @32) <- %4
    let %6: int32 = add($f0, 1)
    let %7: unit = call f5(%6, $f1, $f2)
    jump b3(())
  }
  .bb #b2 () {
    jump b3(())
  }
  .bb #b3 (unit) {
    return $b3.0
  }
}
.fn go_loop.249 #f8 : fn(int32, array[int32], array[int32], array[bool], array[int32], array[int32]) -> unit
.freevars ()
.entry b11 {
  .bb #b0 (int32, array[int32], array[int32], array[bool], array[int32], array[int32]) {
    let %0: bool = load bool field($b0.3, 0 * @32)
    let %1: bool = eq(%0, true)
    br %1 b1() b2()
  }
  .bb #b1 () {
    let %2: int32 = load int32 field($b0.1, 0 * @32)
    let %3: bool = eq(%2, $b0.0)
    br %3 b3() b4()
  }
  .bb #b2 () {
    jump b9(())
  }
  .bb #b3 () {
    let _ = store bool field($b0.3, 0 * @32) <- false
    let _ = store int32 field($b0.1, 0 * @32) <- 0
    jump b0($b0.0, $b0.1, $b0.2, $b0.3, $b0.4, $b0.5)
  }
  .bb #b4 () {
    let %7: int32 = load int32 field($b0.4, 0 * @32)
    let _ = store int32 field($b0.2, 0 * @32) <- %7
    let %9: unit = call f7(0, $b0.1, $b0.4)
    let %10: int32 = load int32 field($b0.1, 0 * @32)
    let %11: int32 = load int32 field($b0.2, 0 * @32)
    let _ = store int32 offset($b0.4, %10 * @32) <- %11
    let %13: int32 = load int32 field($b0.1, 0 * @32)
    let %14: int32 = load int32 field($b0.1, 0 * @32)
    let %15: int32 = load int32 offset($b0.5, %14 * @32)
    let %16: int32 = sub(%15, 1)
    let _ = store int32 offset($b0.5, %13 * @32) <- %16
    let %18: int32 = load int32 field($b0.1, 0 * @32)
    let %19: int32 = load int32 offset($b0.5, %18 * @32)
    let %20: bool = le(1, %19)
    br %20 b5() b6()
  }
  .bb #b5 () {
    let _ = store bool field($b0.3, 0 * @32) <- false
    jump b0($b0.0, $b0.1, $b0.2, $b0.3, $b0.4, $b0.5)
  }
  .bb #b6 () {
    let %23: int32 = load int32 field($b0.1, 0 * @32)
    let %24: int32 = add(%23, 1)
    let _ = store int32 field($b0.1, 0 * @32) <- %24
    jump b0($b0.0, $b0.1, $b0.2, $b0.3, $b0.4, $b0.5)
  }
  .bb #b7 (unit) {
    jump b8($b7.0)
  }
  .bb #b8 (unit) {
    jump b9($b8.0)
  }
  .bb #b9 (unit) {
    return $b9.0
  }
  .loop #b10 pre #Some(b11) header #b0 {
    .block #b6
    .block #b4
    .block #b8
    .block #b9
    .block #b1
    .block #b5
    .block #b2
    .block #b3
    .block #b7
  }
  .bb #b11 () {
    jump b10($f0, $f1, $f2, $f3, $f4, $f5)
  }
}
.fn main.251 #f11 : fn() -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: (int32, int32) = call f10(9)
    let %1: int32 = load int32 field(%0, 0 * @(@32, @(@32, @32)))
    let %2: int32 = load int32 field(%0, 1 * @(@32, @(@32, @32)))
    let %3: unit = ext_call minimbt_print_int(%2)
    let %4: unit = ext_call minimbt_print_int(%1)
    return %4
  }
}
.fn init_arr.241 #f0 : fn(int32, int32, array[int32]) -> unit
.freevars ()
.entry b5 {
  .bb #b0 (int32, int32, array[int32]) {
    let %0: int32 = sub($b0.1, 1)
    let %1: bool = le($b0.0, %0)
    br %1 b1() b2()
  }
  .bb #b1 () {
    let _ = store int32 offset($b0.2, $b0.0 * @32) <- $b0.0
    let %3: int32 = add($b0.0, 1)
    jump b0(%3, $b0.1, $b0.2)
  }
  .bb #b2 () {
    jump b3(())
  }
  .bb #b3 (unit) {
    return $b3.0
  }
  .loop #b4 pre #Some(b5) header #b0 {
    .block #b1
    .block #b2
    .block #b3
  }
  .bb #b5 () {
    jump b4($f0, $f1, $f2)
  }
}
.fn init_count.244 #f2 : fn(array[int32], array[int32]) -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: int32 = load int32 field($f0, 0 * @32)
    let %1: bool = eq(%0, 1)
    br %1 b1() b2()
  }
  .bb #b1 () {
    jump b3(())
  }
  .bb #b2 () {
    let %2: int32 = load int32 field($f0, 0 * @32)
    let %3: int32 = sub(%2, 1)
    let %4: int32 = load int32 field($f0, 0 * @32)
    let _ = store int32 offset($f1, %3 * @32) <- %4
    let %6: int32 = load int32 field($f0, 0 * @32)
    let %7: int32 = sub(%6, 1)
    let _ = store int32 field($f0, 0 * @32) <- %7
    let %9: unit = call f2($f0, $f1)
    jump b3(())
  }
  .bb #b3 (unit) {
    return $b3.0
  }
}
.fn fannkuch.240 #f10 : fn(int32) -> (int32, int32)
.freevars ()
.entry b0 {
  .bb #b0 () {
    let _ = alloc <m0: array[int32] heap($f0)> <- [..] = 0
    jump b18()
  }
  .bb #b1 (unit) {
    let _ = alloc <m1: array[int32] heap($f0)> <- [..] = 0
    let _ = alloc <m2: array[int32] heap($f0)> <- [..] = 0
    let _ = alloc <m3: array[int32] heap(1)> <- [..] = 0
    let _ = alloc <m4: array[int32] heap(1)> <- [..] = 0
    let _ = alloc <m5: array[int32] heap(1)> <- [..] = 0
    let _ = alloc <m6: array[int32] heap(1)> <- [..] = 0
    let _ = alloc <m7: array[int32] heap(1)> <- [..] = $f0
    jump b27()
  }
  .bb #b2 (unit) {
    let %10: int32 = load int32 field(f10.m4, 0 * @32)
    let %11: int32 = load int32 field(f10.m5, 0 * @32)
    let _ = alloc <m8: (int32, int32) heap(2)> <- [0] = %10, [1] = %11
    return f10.m8
  }
  .bb #b13 (int32, int32, array[int32]) {
    let %13: int32 = sub($b13.1, 1)
    let %14: bool = le($b13.0, %13)
    br %14 b14() b15()
  }
  .bb #b14 () {
    let _ = store int32 offset($b13.2, $b13.0 * @32) <- $b13.0
    let %16: int32 = add($b13.0, 1)
    jump b13(%16, $b13.1, $b13.2)
  }
  .bb #b15 () {
    jump b16(())
  }
  .bb #b16 (unit) {
    jump b1($b16.0)
  }
  .loop #b17 pre #Some(b18) header #b13 {
    .block #b14
    .block #b15
    .block #b16
  }
  .bb #b18 () {
    jump b17(0, $f0, f10.m0)
  }
  .bb #b24 (unit) {
    jump b25($b24.0)
  }
  .bb #b20 () {
    jump b100()
  }
  .bb #b27 () {
    jump b26(f10.m7, $f0, f10.m0, f10.m1, f10.m2, f10.m3, f10.m6, f10.m5, f10.m4)
  }
  .loop #b26 pre #Some(b27) header #b19 {
    .block #b25
    .block #b23
    .block #b20
    .block #b24
    .block #b21
    .block #b22
  }
  .bb #b28 (unit) {
    let %64: int32 = load int32 field($b19.6, 0 * @32)
    let %65: int32 = add(%64, 1)
    let _ = store int32 field($b19.6, 0 * @32) <- %65
    jump b19($b19.0, $b19.1, $b19.2, $b19.3, $b19.4, $b19.5, $b19.6, $b19.7, $b19.8)
  }
  .bb #b22 () {
    let %28: int32 = load int32 field($b19.5, 0 * @32)
    let _ = store int32 field($b19.8, 0 * @32) <- %28
    let %30: int32 = load int32 field($b19.7, 0 * @32)
    let %31: int32 = load int32 field($b19.5, 0 * @32)
    let %32: int32 = load int32 field($b19.6, 0 * @32)
    let %33: int32 = load int32 field($b19.6, 0 * @32)
    let %34: int32 = div(%33, 2)
    let %35: int32 = mul(%34, 2)
    let %36: int32 = sub(%32, %35)
    let %37: int32 = mul(%36, 2)
    let %38: int32 = sub(1, %37)
    let %39: int32 = mul(%31, %38)
    let %40: int32 = add(%30, %39)
    let _ = store int32 field($b19.7, 0 * @32) <- %40
    let _ = alloc <m20: array[int32] heap(1)> <- [..] = true
    let _ = alloc <m21: array[int32] heap(1)> <- [..] = 0
    jump b134()
  }
  .bb #b25 (unit) {
    jump b2($b25.0)
  }
  .bb #b29 (unit) {
    let %20: unit = call f2($b19.0, $b19.4)
    let _ = store int32 field($b19.5, 0 * @32) <- 0
    let %22: int32 = load int32 field($b19.3, 0 * @32)
    let _ = alloc <m19: array[int32] heap(1)> <- [..] = %22
    jump b106()
  }
  .bb #b30 (unit) {
    let %25: int32 = load int32 field($b19.8, 0 * @32)
    let %26: int32 = load int32 field($b19.5, 0 * @32)
    let %27: bool = le(%25, %26)
    br %27 b22() b23()
  }
  .bb #b19 (array[int32], int32, array[int32], array[int32], array[int32], array[int32], array[int32], array[int32], array[int32]) {
    let %17: int32 = load int32 field($b19.0, 0 * @32)
    let %18: bool = le(1, %17)
    br %18 b20() b21()
  }
  .bb #b21 () {
    jump b25(())
  }
  .bb #b23 () {
    let %49: int32 = load int32 field($b19.7, 0 * @32)
    let %50: int32 = load int32 field($b19.5, 0 * @32)
    let %51: int32 = load int32 field($b19.6, 0 * @32)
    let %52: int32 = load int32 field($b19.6, 0 * @32)
    let %53: int32 = div(%52, 2)
    let %54: int32 = mul(%53, 2)
    let %55: int32 = sub(%51, %54)
    let %56: int32 = mul(%55, 2)
    let %57: int32 = sub(1, %56)
    let %58: int32 = mul(%50, %57)
    let %59: int32 = add(%49, %58)
    let _ = store int32 field($b19.7, 0 * @32) <- %59
    let _ = alloc <m22: array[int32] heap(1)> <- [..] = true
    let _ = alloc <m23: array[int32] heap(1)> <- [..] = 0
    jump b80()
  }
  .bb #b31 (unit) {
    let %45: int32 = load int32 field($b19.6, 0 * @32)
    let %46: int32 = add(%45, 1)
    let _ = store int32 field($b19.6, 0 * @32) <- %46
    jump b19($b19.0, $b19.1, $b19.2, $b19.3, $b19.4, $b19.5, $b19.6, $b19.7, $b19.8)
  }
  .bb #b69 (int32, array[int32], array[int32], array[bool], array[int32], array[int32]) {
    let %67: bool = load bool field($b69.3, 0 * @32)
    let %68: bool = eq(%67, true)
    br %68 b70() b71()
  }
  .bb #b70 () {
    let %69: int32 = load int32 field($b69.1, 0 * @32)
    let %70: bool = eq(%69, $b69.0)
    br %70 b72() b73()
  }
  .bb #b71 () {
    jump b78(())
  }
  .bb #b72 () {
    let _ = store bool field($b69.3, 0 * @32) <- false
    let _ = store int32 field($b69.1, 0 * @32) <- 0
    jump b69($b69.0, $b69.1, $b69.2, $b69.3, $b69.4, $b69.5)
  }
  .bb #b73 () {
    let %74: int32 = load int32 field($b69.4, 0 * @32)
    let _ = store int32 field($b69.2, 0 * @32) <- %74
    let %76: unit = call f7(0, $b69.1, $b69.4)
    let %77: int32 = load int32 field($b69.1, 0 * @32)
    let %78: int32 = load int32 field($b69.2, 0 * @32)
    let _ = store int32 offset($b69.4, %77 * @32) <- %78
    let %80: int32 = load int32 field($b69.1, 0 * @32)
    let %81: int32 = load int32 field($b69.1, 0 * @32)
    let %82: int32 = load int32 offset($b69.5, %81 * @32)
    let %83: int32 = sub(%82, 1)
    let _ = store int32 offset($b69.5, %80 * @32) <- %83
    let %85: int32 = load int32 field($b69.1, 0 * @32)
    let %86: int32 = load int32 offset($b69.5, %85 * @32)
    let %87: bool = le(1, %86)
    br %87 b74() b75()
  }
  .bb #b74 () {
    let _ = store bool field($b69.3, 0 * @32) <- false
    jump b69($b69.0, $b69.1, $b69.2, $b69.3, $b69.4, $b69.5)
  }
  .bb #b75 () {
    let %90: int32 = load int32 field($b69.1, 0 * @32)
    let %91: int32 = add(%90, 1)
    let _ = store int32 field($b69.1, 0 * @32) <- %91
    jump b69($b69.0, $b69.1, $b69.2, $b69.3, $b69.4, $b69.5)
  }
  .bb #b76 (unit) {
    jump b77($b76.0)
  }
  .bb #b77 (unit) {
    jump b78($b77.0)
  }
  .bb #b78 (unit) {
    jump b28($b78.0)
  }
  .loop #b79 pre #Some(b80) header #b69 {
    .block #b75
    .block #b73
    .block #b77
    .block #b78
    .block #b70
    .block #b74
    .block #b71
    .block #b72
    .block #b76
  }
  .bb #b80 () {
    jump b79($b19.1, $b19.0, f10.m23, f10.m22, $b19.2, $b19.4)
  }
  .bb #b95 (int32, int32, array[int32], array[int32]) {
    let %93: int32 = sub($b95.1, 1)
    let %94: bool = le($b95.0, %93)
    br %94 b96() b97()
  }
  .bb #b96 () {
    let %95: int32 = load int32 offset($b95.2, $b95.0 * @32)
    let _ = store int32 offset($b95.3, $b95.0 * @32) <- %95
    let %97: int32 = add($b95.0, 1)
    jump b95(%97, $b95.1, $b95.2, $b95.3)
  }
  .bb #b97 () {
    jump b98(())
  }
  .bb #b98 (unit) {
    jump b29($b98.0)
  }
  .loop #b99 pre #Some(b100) header #b95 {
    .block #b96
    .block #b97
    .block #b98
  }
  .bb #b100 () {
    jump b99(0, $b19.1, $b19.2, $b19.3)
  }
  .bb #b101 (array[int32], array[int32], array[int32]) {
    let %98: int32 = load int32 field($b101.0, 0 * @32)
    let %99: bool = eq(%98, 0)
    br %99 b102() b103()
  }
  .bb #b102 () {
    jump b104(())
  }
  .bb #b103 () {
    let _ = alloc <m101: array[int32] heap(1)> <- [..] = 0
    jump b115()
  }
  .bb #b104 (unit) {
    jump b30($b104.0)
  }
  .loop #b105 pre #Some(b106) header #b101 {
    .block #b102
    .block #b103
    .block #b104
  }
  .bb #b106 () {
    jump b105(f10.m19, $b19.3, $b19.5)
  }
  .bb #b107 (unit) {
    let %102: int32 = load int32 field($b101.1, 0 * @32)
    let _ = store int32 field($b101.0, 0 * @32) <- %102
    let %104: int32 = load int32 field($b101.2, 0 * @32)
    let %105: int32 = add(%104, 1)
    let _ = store int32 field($b101.2, 0 * @32) <- %105
    jump b101($b101.0, $b101.1, $b101.2)
  }
  .bb #b110 (int32, array[int32], array[int32], array[int32]) {
    let %107: int32 = load int32 field($b110.1, 0 * @32)
    let %108: int32 = div(%107, 2)
    let %109: bool = le($b110.0, %108)
    br %109 b111() b112()
  }
  .bb #b111 () {
    let %110: int32 = load int32 offset($b110.3, $b110.0 * @32)
    let _ = store int32 field($b110.2, 0 * @32) <- %110
    let %112: int32 = load int32 field($b110.1, 0 * @32)
    let %113: int32 = sub(%112, $b110.0)
    let %114: int32 = load int32 offset($b110.3, %113 * @32)
    let _ = store int32 offset($b110.3, $b110.0 * @32) <- %114
    let %116: int32 = load int32 field($b110.1, 0 * @32)
    let %117: int32 = sub(%116, $b110.0)
    let %118: int32 = load int32 field($b110.2, 0 * @32)
    let _ = store int32 offset($b110.3, %117 * @32) <- %118
    let %120: int32 = add($b110.0, 1)
    jump b110(%120, $b110.1, $b110.2, $b110.3)
  }
  .bb #b112 () {
    jump b113(())
  }
  .bb #b113 (unit) {
    jump b107($b113.0)
  }
  .loop #b114 pre #Some(b115) header #b110 {
    .block #b111
    .block #b112
    .block #b113
  }
  .bb #b115 () {
    jump b114(0, $b101.0, f10.m101, $b101.1)
  }
  .bb #b123 (int32, array[int32], array[int32], array[bool], array[int32], array[int32]) {
    let %121: bool = load bool field($b123.3, 0 * @32)
    let %122: bool = eq(%121, true)
    br %122 b124() b125()
  }
  .bb #b124 () {
    let %123: int32 = load int32 field($b123.1, 0 * @32)
    let %124: bool = eq(%123, $b123.0)
    br %124 b126() b127()
  }
  .bb #b125 () {
    jump b132(())
  }
  .bb #b126 () {
    let _ = store bool field($b123.3, 0 * @32) <- false
    let _ = store int32 field($b123.1, 0 * @32) <- 0
    jump b123($b123.0, $b123.1, $b123.2, $b123.3, $b123.4, $b123.5)
  }
  .bb #b127 () {
    let %128: int32 = load int32 field($b123.4, 0 * @32)
    let _ = store int32 field($b123.2, 0 * @32) <- %128
    let %130: unit = call f5(0, $b123.1, $b123.4)
    let %131: int32 = load int32 field($b123.1, 0 * @32)
    let %132: int32 = load int32 field($b123.2, 0 * @32)
    let _ = store int32 offset($b123.4, %131 * @32) <- %132
    let %134: int32 = load int32 field($b123.1, 0 * @32)
    let %135: int32 = load int32 field($b123.1, 0 * @32)
    let %136: int32 = load int32 offset($b123.5, %135 * @32)
    let %137: int32 = sub(%136, 1)
    let _ = store int32 offset($b123.5, %134 * @32) <- %137
    let %139: int32 = load int32 field($b123.1, 0 * @32)
    let %140: int32 = load int32 offset($b123.5, %139 * @32)
    let %141: bool = le(1, %140)
    br %141 b128() b129()
  }
  .bb #b128 () {
    let _ = store bool field($b123.3, 0 * @32) <- false
    jump b123($b123.0, $b123.1, $b123.2, $b123.3, $b123.4, $b123.5)
  }
  .bb #b129 () {
    let %144: int32 = load int32 field($b123.1, 0 * @32)
    let %145: int32 = add(%144, 1)
    let _ = store int32 field($b123.1, 0 * @32) <- %145
    jump b123($b123.0, $b123.1, $b123.2, $b123.3, $b123.4, $b123.5)
  }
  .bb #b130 (unit) {
    jump b131($b130.0)
  }
  .bb #b131 (unit) {
    jump b132($b131.0)
  }
  .bb #b132 (unit) {
    jump b31($b132.0)
  }
  .loop #b133 pre #Some(b134) header #b123 {
    .block #b129
    .block #b127
    .block #b131
    .block #b132
    .block #b124
    .block #b128
    .block #b125
    .block #b126
    .block #b130
  }
  .bb #b134 () {
    jump b133($b19.1, $b19.0, f10.m21, f10.m20, $b19.2, $b19.4)
  }
}
.fn move_perm1_forward.250 #f7 : fn(int32, array[int32], array[int32]) -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: int32 = load int32 field($f1, 0 * @32)
    let %1: int32 = sub(%0, 1)
    let %2: bool = le($f0, %1)
    br %2 b1() b2()
  }
  .bb #b1 () {
    let %3: int32 = add($f0, 1)
    let %4: int32 = load int32 offset($f2, %3 * @32)
    let _ = store int32 offset($f2, $f0 * @32) <- %4
    let %6: int32 = add($f0, 1)
    let %7: unit = call f7(%6, $f1, $f2)
    jump b3(())
  }
  .bb #b2 () {
    jump b3(())
  }
  .bb #b3 (unit) {
    return $b3.0
  }
}
.fn do_flip.245 #f4 : fn(array[int32], array[int32], array[int32]) -> unit
.freevars ()
.entry b5 {
  .bb #b0 (array[int32], array[int32], array[int32]) {
    let %0: int32 = load int32 field($b0.0, 0 * @32)
    let %1: bool = eq(%0, 0)
    br %1 b1() b2()
  }
  .bb #b1 () {
    jump b3(())
  }
  .bb #b2 () {
    let _ = alloc <m0: array[int32] heap(1)> <- [..] = 0
    jump b14()
  }
  .bb #b3 (unit) {
    return $b3.0
  }
  .loop #b4 pre #Some(b5) header #b0 {
    .block #b1
    .block #b2
    .block #b3
  }
  .bb #b5 () {
    jump b4($f0, $f1, $f2)
  }
  .bb #b6 (unit) {
    let %4: int32 = load int32 field($b0.1, 0 * @32)
    let _ = store int32 field($b0.0, 0 * @32) <- %4
    let %6: int32 = load int32 field($b0.2, 0 * @32)
    let %7: int32 = add(%6, 1)
    let _ = store int32 field($b0.2, 0 * @32) <- %7
    jump b0($b0.0, $b0.1, $b0.2)
  }
  .bb #b9 (int32, array[int32], array[int32], array[int32]) {
    let %9: int32 = load int32 field($b9.1, 0 * @32)
    let %10: int32 = div(%9, 2)
    let %11: bool = le($b9.0, %10)
    br %11 b10() b11()
  }
  .bb #b10 () {
    let %12: int32 = load int32 offset($b9.3, $b9.0 * @32)
    let _ = store int32 field($b9.2, 0 * @32) <- %12
    let %14: int32 = load int32 field($b9.1, 0 * @32)
    let %15: int32 = sub(%14, $b9.0)
    let %16: int32 = load int32 offset($b9.3, %15 * @32)
    let _ = store int32 offset($b9.3, $b9.0 * @32) <- %16
    let %18: int32 = load int32 field($b9.1, 0 * @32)
    let %19: int32 = sub(%18, $b9.0)
    let %20: int32 = load int32 field($b9.2, 0 * @32)
    let _ = store int32 offset($b9.3, %19 * @32) <- %20
    let %22: int32 = add($b9.0, 1)
    jump b9(%22, $b9.1, $b9.2, $b9.3)
  }
  .bb #b11 () {
    jump b12(())
  }
  .bb #b12 (unit) {
    jump b6($b12.0)
  }
  .loop #b13 pre #Some(b14) header #b9 {
    .block #b10
    .block #b11
    .block #b12
  }
  .bb #b14 () {
    jump b13(0, $b0.0, f4.m0, $b0.1)
  }
}
.fn compute.242 #f9 : fn(array[int32], int32, array[int32], array[int32], array[int32], array[int32], array[int32], array[int32], array[int32]) -> unit
.freevars ()
.entry b8 {
  .bb #b0 (array[int32], int32, array[int32], array[int32], array[int32], array[int32], array[int32], array[int32], array[int32]) {
    let %0: int32 = load int32 field($b0.0, 0 * @32)
    let %1: bool = le(1, %0)
    br %1 b1() b2()
  }
  .bb #b1 () {
    jump b81()
  }
  .bb #b2 () {
    jump b6(())
  }
  .bb #b3 () {
    let %11: int32 = load int32 field($b0.5, 0 * @32)
    let _ = store int32 field($b0.8, 0 * @32) <- %11
    let %13: int32 = load int32 field($b0.7, 0 * @32)
    let %14: int32 = load int32 field($b0.5, 0 * @32)
    let %15: int32 = load int32 field($b0.6, 0 * @32)
    let %16: int32 = load int32 field($b0.6, 0 * @32)
    let %17: int32 = div(%16, 2)
    let %18: int32 = mul(%17, 2)
    let %19: int32 = sub(%15, %18)
    let %20: int32 = mul(%19, 2)
    let %21: int32 = sub(1, %20)
    let %22: int32 = mul(%14, %21)
    let %23: int32 = add(%13, %22)
    let _ = store int32 field($b0.7, 0 * @32) <- %23
    let _ = alloc <m1: array[int32] heap(1)> <- [..] = true
    let _ = alloc <m2: array[int32] heap(1)> <- [..] = 0
    jump b115()
  }
  .bb #b4 () {
    let %32: int32 = load int32 field($b0.7, 0 * @32)
    let %33: int32 = load int32 field($b0.5, 0 * @32)
    let %34: int32 = load int32 field($b0.6, 0 * @32)
    let %35: int32 = load int32 field($b0.6, 0 * @32)
    let %36: int32 = div(%35, 2)
    let %37: int32 = mul(%36, 2)
    let %38: int32 = sub(%34, %37)
    let %39: int32 = mul(%38, 2)
    let %40: int32 = sub(1, %39)
    let %41: int32 = mul(%33, %40)
    let %42: int32 = add(%32, %41)
    let _ = store int32 field($b0.7, 0 * @32) <- %42
    let _ = alloc <m3: array[int32] heap(1)> <- [..] = true
    let _ = alloc <m4: array[int32] heap(1)> <- [..] = 0
    jump b61()
  }
  .bb #b5 (unit) {
    jump b6($b5.0)
  }
  .bb #b6 (unit) {
    return $b6.0
  }
  .loop #b7 pre #Some(b8) header #b0 {
    .block #b6
    .block #b4
    .block #b1
    .block #b5
    .block #b2
    .block #b3
  }
  .bb #b8 () {
    jump b7($f0, $f1, $f2, $f3, $f4, $f5, $f6, $f7, $f8)
  }
  .bb #b9 (unit) {
    let %47: int32 = load int32 field($b0.6, 0 * @32)
    let %48: int32 = add(%47, 1)
    let _ = store int32 field($b0.6, 0 * @32) <- %48
    jump b0($b0.0, $b0.1, $b0.2, $b0.3, $b0.4, $b0.5, $b0.6, $b0.7, $b0.8)
  }
  .bb #b10 (unit) {
    let %3: unit = call f2($b0.0, $b0.4)
    let _ = store int32 field($b0.5, 0 * @32) <- 0
    let %5: int32 = load int32 field($b0.3, 0 * @32)
    let _ = alloc <m0: array[int32] heap(1)> <- [..] = %5
    jump b87()
  }
  .bb #b11 (unit) {
    let %8: int32 = load int32 field($b0.8, 0 * @32)
    let %9: int32 = load int32 field($b0.5, 0 * @32)
    let %10: bool = le(%8, %9)
    br %10 b3() b4()
  }
  .bb #b12 (unit) {
    let %28: int32 = load int32 field($b0.6, 0 * @32)
    let %29: int32 = add(%28, 1)
    let _ = store int32 field($b0.6, 0 * @32) <- %29
    jump b0($b0.0, $b0.1, $b0.2, $b0.3, $b0.4, $b0.5, $b0.6, $b0.7, $b0.8)
  }
  .bb #b50 (int32, array[int32], array[int32], array[bool], array[int32], array[int32]) {
    let %50: bool = load bool field($b50.3, 0 * @32)
    let %51: bool = eq(%50, true)
    br %51 b51() b52()
  }
  .bb #b51 () {
    let %52: int32 = load int32 field($b50.1, 0 * @32)
    let %53: bool = eq(%52, $b50.0)
    br %53 b53() b54()
  }
  .bb #b52 () {
    jump b59(())
  }
  .bb #b53 () {
    let _ = store bool field($b50.3, 0 * @32) <- false
    let _ = store int32 field($b50.1, 0 * @32) <- 0
    jump b50($b50.0, $b50.1, $b50.2, $b50.3, $b50.4, $b50.5)
  }
  .bb #b54 () {
    let %57: int32 = load int32 field($b50.4, 0 * @32)
    let _ = store int32 field($b50.2, 0 * @32) <- %57
    let %59: unit = call f7(0, $b50.1, $b50.4)
    let %60: int32 = load int32 field($b50.1, 0 * @32)
    let %61: int32 = load int32 field($b50.2, 0 * @32)
    let _ = store int32 offset($b50.4, %60 * @32) <- %61
    let %63: int32 = load int32 field($b50.1, 0 * @32)
    let %64: int32 = load int32 field($b50.1, 0 * @32)
    let %65: int32 = load int32 offset($b50.5, %64 * @32)
    let %66: int32 = sub(%65, 1)
    let _ = store int32 offset($b50.5, %63 * @32) <- %66
    let %68: int32 = load int32 field($b50.1, 0 * @32)
    let %69: int32 = load int32 offset($b50.5, %68 * @32)
    let %70: bool = le(1, %69)
    br %70 b55() b56()
  }
  .bb #b55 () {
    let _ = store bool field($b50.3, 0 * @32) <- false
    jump b50($b50.0, $b50.1, $b50.2, $b50.3, $b50.4, $b50.5)
  }
  .bb #b56 () {
    let %73: int32 = load int32 field($b50.1, 0 * @32)
    let %74: int32 = add(%73, 1)
    let _ = store int32 field($b50.1, 0 * @32) <- %74
    jump b50($b50.0, $b50.1, $b50.2, $b50.3, $b50.4, $b50.5)
  }
  .bb #b57 (unit) {
    jump b58($b57.0)
  }
  .bb #b58 (unit) {
    jump b59($b58.0)
  }
  .bb #b59 (unit) {
    jump b9($b59.0)
  }
  .loop #b60 pre #Some(b61) header #b50 {
    .block #b56
    .block #b54
    .block #b58
    .block #b59
    .block #b51
    .block #b55
    .block #b52
    .block #b53
    .block #b57
  }
  .bb #b61 () {
    jump b60($b0.1, $b0.0, f9.m4, f9.m3, $b0.2, $b0.4)
  }
  .bb #b76 (int32, int32, array[int32], array[int32]) {
    let %76: int32 = sub($b76.1, 1)
    let %77: bool = le($b76.0, %76)
    br %77 b77() b78()
  }
  .bb #b77 () {
    let %78: int32 = load int32 offset($b76.2, $b76.0 * @32)
    let _ = store int32 offset($b76.3, $b76.0 * @32) <- %78
    let %80: int32 = add($b76.0, 1)
    jump b76(%80, $b76.1, $b76.2, $b76.3)
  }
  .bb #b78 () {
    jump b79(())
  }
  .bb #b79 (unit) {
    jump b10($b79.0)
  }
  .loop #b80 pre #Some(b81) header #b76 {
    .block #b77
    .block #b78
    .block #b79
  }
  .bb #b81 () {
    jump b80(0, $b0.1, $b0.2, $b0.3)
  }
  .bb #b82 (array[int32], array[int32], array[int32]) {
    let %81: int32 = load int32 field($b82.0, 0 * @32)
    let %82: bool = eq(%81, 0)
    br %82 b83() b84()
  }
  .bb #b83 () {
    jump b85(())
  }
  .bb #b84 () {
    let _ = alloc <m82: array[int32] heap(1)> <- [..] = 0
    jump b96()
  }
  .bb #b85 (unit) {
    jump b11($b85.0)
  }
  .loop #b86 pre #Some(b87) header #b82 {
    .block #b83
    .block #b84
    .block #b85
  }
  .bb #b87 () {
    jump b86(f9.m0, $b0.3, $b0.5)
  }
  .bb #b88 (unit) {
    let %85: int32 = load int32 field($b82.1, 0 * @32)
    let _ = store int32 field($b82.0, 0 * @32) <- %85
    let %87: int32 = load int32 field($b82.2, 0 * @32)
    let %88: int32 = add(%87, 1)
    let _ = store int32 field($b82.2, 0 * @32) <- %88
    jump b82($b82.0, $b82.1, $b82.2)
  }
  .bb #b91 (int32, array[int32], array[int32], array[int32]) {
    let %90: int32 = load int32 field($b91.1, 0 * @32)
    let %91: int32 = div(%90, 2)
    let %92: bool = le($b91.0, %91)
    br %92 b92() b93()
  }
  .bb #b92 () {
    let %93: int32 = load int32 offset($b91.3, $b91.0 * @32)
    let _ = store int32 field($b91.2, 0 * @32) <- %93
    let %95: int32 = load int32 field($b91.1, 0 * @32)
    let %96: int32 = sub(%95, $b91.0)
    let %97: int32 = load int32 offset($b91.3, %96 * @32)
    let _ = store int32 offset($b91.3, $b91.0 * @32) <- %97
    let %99: int32 = load int32 field($b91.1, 0 * @32)
    let %100: int32 = sub(%99, $b91.0)
    let %101: int32 = load int32 field($b91.2, 0 * @32)
    let _ = store int32 offset($b91.3, %100 * @32) <- %101
    let %103: int32 = add($b91.0, 1)
    jump b91(%103, $b91.1, $b91.2, $b91.3)
  }
  .bb #b93 () {
    jump b94(())
  }
  .bb #b94 (unit) {
    jump b88($b94.0)
  }
  .loop #b95 pre #Some(b96) header #b91 {
    .block #b92
    .block #b93
    .block #b94
  }
  .bb #b96 () {
    jump b95(0, $b82.0, f9.m82, $b82.1)
  }
  .bb #b104 (int32, array[int32], array[int32], array[bool], array[int32], array[int32]) {
    let %104: bool = load bool field($b104.3, 0 * @32)
    let %105: bool = eq(%104, true)
    br %105 b105() b106()
  }
  .bb #b105 () {
    let %106: int32 = load int32 field($b104.1, 0 * @32)
    let %107: bool = eq(%106, $b104.0)
    br %107 b107() b108()
  }
  .bb #b106 () {
    jump b113(())
  }
  .bb #b107 () {
    let _ = store bool field($b104.3, 0 * @32) <- false
    let _ = store int32 field($b104.1, 0 * @32) <- 0
    jump b104($b104.0, $b104.1, $b104.2, $b104.3, $b104.4, $b104.5)
  }
  .bb #b108 () {
    let %111: int32 = load int32 field($b104.4, 0 * @32)
    let _ = store int32 field($b104.2, 0 * @32) <- %111
    let %113: unit = call f5(0, $b104.1, $b104.4)
    let %114: int32 = load int32 field($b104.1, 0 * @32)
    let %115: int32 = load int32 field($b104.2, 0 * @32)
    let _ = store int32 offset($b104.4, %114 * @32) <- %115
    let %117: int32 = load int32 field($b104.1, 0 * @32)
    let %118: int32 = load int32 field($b104.1, 0 * @32)
    let %119: int32 = load int32 offset($b104.5, %118 * @32)
    let %120: int32 = sub(%119, 1)
    let _ = store int32 offset($b104.5, %117 * @32) <- %120
    let %122: int32 = load int32 field($b104.1, 0 * @32)
    let %123: int32 = load int32 offset($b104.5, %122 * @32)
    let %124: bool = le(1, %123)
    br %124 b109() b110()
  }
  .bb #b109 () {
    let _ = store bool field($b104.3, 0 * @32) <- false
    jump b104($b104.0, $b104.1, $b104.2, $b104.3, $b104.4, $b104.5)
  }
  .bb #b110 () {
    let %127: int32 = load int32 field($b104.1, 0 * @32)
    let %128: int32 = add(%127, 1)
    let _ = store int32 field($b104.1, 0 * @32) <- %128
    jump b104($b104.0, $b104.1, $b104.2, $b104.3, $b104.4, $b104.5)
  }
  .bb #b111 (unit) {
    jump b112($b111.0)
  }
  .bb #b112 (unit) {
    jump b113($b112.0)
  }
  .bb #b113 (unit) {
    jump b12($b113.0)
  }
  .loop #b114 pre #Some(b115) header #b104 {
    .block #b110
    .block #b108
    .block #b112
    .block #b113
    .block #b105
    .block #b109
    .block #b106
    .block #b107
    .block #b111
  }
  .bb #b115 () {
    jump b114($b0.1, $b0.0, f9.m2, f9.m1, $b0.2, $b0.4)
  }
}
.fn T$start #f24 : fn() -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: unit = call f11()
    return %0
  }
}
.fn copy_perm.243 #f1 : fn(int32, int32, array[int32], array[int32]) -> unit
.freevars ()
.entry b5 {
  .bb #b0 (int32, int32, array[int32], array[int32]) {
    let %0: int32 = sub($b0.1, 1)
    let %1: bool = le($b0.0, %0)
    br %1 b1() b2()
  }
  .bb #b1 () {
    let %2: int32 = load int32 offset($b0.2, $b0.0 * @32)
    let _ = store int32 offset($b0.3, $b0.0 * @32) <- %2
    let %4: int32 = add($b0.0, 1)
    jump b0(%4, $b0.1, $b0.2, $b0.3)
  }
  .bb #b2 () {
    jump b3(())
  }
  .bb #b3 (unit) {
    return $b3.0
  }
  .loop #b4 pre #Some(b5) header #b0 {
    .block #b1
    .block #b2
    .block #b3
  }
  .bb #b5 () {
    jump b4($f0, $f1, $f2, $f3)
  }
}
.thunk ::0 start
