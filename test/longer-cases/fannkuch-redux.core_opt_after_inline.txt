# name conventions used in the core ir:
# - functions: f<id>
# - blocks: b<id>
# - instructions: %<id>
# - memory: m<id>
# - free variables: ^<id>
# - function parameters: $f<pid>
# - block parameters: $b<bid>.<pid>
.core
.fn move_perm1_forward.238 #f6 : fn(int32, array[int32], array[int32]) -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: int32 = load int32 field($f1, 0 * @32)
    let %1: int32 = sub(%0, 1)
    let %2: bool = le($f0, %1)
    br %2 b1() b2()
  }
  .bb #b1 () {
    let %3: int32 = add($f0, 1)
    let %4: int32 = load int32 offset($f2, %3 * @32)
    let _ = store int32 offset($f2, $f0 * @32) <- %4
    let %6: int32 = add($f0, 1)
    let %7: unit = call f6(%6, $f1, $f2)
    jump b3(())
  }
  .bb #b2 () {
    jump b3(())
  }
  .bb #b3 (unit) {
    return $b3.0
  }
}
.fn gen_perm1.230 #f1 : fn(int32) -> array[int32]
.freevars ()
.entry b0 {
  .bb #b0 () {
    let _ = alloc <m0: array[int32] heap($f0)> <- [..] = 0
    let %1: unit = call f0(0, f1.m0, $f0)
    return f1.m0
  }
}
.fn copy_perm.233 #f2 : fn(int32, int32, array[int32], array[int32]) -> unit
.freevars ()
.entry b5 {
  .bb #b0 (int32, int32, array[int32], array[int32]) {
    let %0: int32 = sub($b0.1, 1)
    let %1: bool = le($b0.0, %0)
    br %1 b1() b2()
  }
  .bb #b1 () {
    let %2: int32 = load int32 offset($b0.3, $b0.0 * @32)
    let _ = store int32 offset($b0.2, $b0.0 * @32) <- %2
    let %4: int32 = add($b0.0, 1)
    jump b0(%4, $b0.1, $b0.2, $b0.3)
  }
  .bb #b2 () {
    jump b3(())
  }
  .bb #b3 (unit) {
    return $b3.0
  }
  .loop #b4 pre #Some(b5) header #b0 {
    .block #b1
    .block #b2
    .block #b3
  }
  .bb #b5 () {
    jump b4($f0, $f1, $f2, $f3)
  }
}
.fn fannkuch.229 #f11 : fn(int32) -> (int32, int32)
.freevars ()
.entry b0 {
  .bb #b0 () {
    jump b12()
  }
  .bb #b1 (array[int32]) {
    let _ = alloc <m0: array[int32] heap($f0)> <- [..] = 0
    let _ = alloc <m1: array[int32] heap($f0)> <- [..] = 0
    let _ = alloc <m2: array[int32] heap(1)> <- [..] = 0
    let _ = alloc <m3: array[int32] heap(1)> <- [..] = 0
    let _ = alloc <m4: array[int32] heap(1)> <- [..] = 0
    let _ = alloc <m5: array[int32] heap(1)> <- [..] = 0
    let _ = alloc <m6: array[int32] heap(1)> <- [..] = $f0
    jump b22()
  }
  .bb #b2 (unit) {
    let %9: int32 = load int32 field(f11.m3, 0 * @32)
    let %10: int32 = load int32 field(f11.m4, 0 * @32)
    let _ = alloc <m7: (int32, int32) heap(2)> <- [0] = %9, [1] = %10
    return f11.m7
  }
  .bb #b12 () {
    let _ = alloc <m12: array[int32] heap($f0)> <- [..] = 0
    let %13: unit = call f0(0, f11.m12, $f0)
    jump b1(f11.m12)
  }
  .bb #b14 (array[int32], int32, array[int32], array[int32], array[int32], array[int32], array[int32], array[int32], array[int32]) {
    let %14: int32 = load int32 field($b14.0, 0 * @32)
    let %15: bool = le(1, %14)
    br %15 b15() b16()
  }
  .bb #b15 () {
    jump b95()
  }
  .bb #b16 () {
    jump b20(())
  }
  .bb #b17 () {
    let %25: int32 = load int32 field($b14.4, 0 * @32)
    let _ = store int32 field($b14.8, 0 * @32) <- %25
    let %27: int32 = load int32 field($b14.7, 0 * @32)
    let %28: int32 = load int32 field($b14.4, 0 * @32)
    let %29: int32 = load int32 field($b14.5, 0 * @32)
    let %30: int32 = load int32 field($b14.5, 0 * @32)
    let %31: int32 = div(%30, 2)
    let %32: int32 = mul(%31, 2)
    let %33: int32 = sub(%29, %32)
    let %34: int32 = mul(%33, 2)
    let %35: int32 = sub(1, %34)
    let %36: int32 = mul(%28, %35)
    let %37: int32 = add(%27, %36)
    let _ = store int32 field($b14.7, 0 * @32) <- %37
    let _ = alloc <m15: array[int32] heap(1)> <- [..] = true
    let _ = alloc <m16: array[int32] heap(1)> <- [..] = 0
    jump b115()
  }
  .bb #b18 () {
    let %46: int32 = load int32 field($b14.7, 0 * @32)
    let %47: int32 = load int32 field($b14.4, 0 * @32)
    let %48: int32 = load int32 field($b14.5, 0 * @32)
    let %49: int32 = load int32 field($b14.5, 0 * @32)
    let %50: int32 = div(%49, 2)
    let %51: int32 = mul(%50, 2)
    let %52: int32 = sub(%48, %51)
    let %53: int32 = mul(%52, 2)
    let %54: int32 = sub(1, %53)
    let %55: int32 = mul(%47, %54)
    let %56: int32 = add(%46, %55)
    let _ = store int32 field($b14.7, 0 * @32) <- %56
    let _ = alloc <m17: array[int32] heap(1)> <- [..] = true
    let _ = alloc <m18: array[int32] heap(1)> <- [..] = 0
    jump b75()
  }
  .bb #b19 (unit) {
    jump b20($b19.0)
  }
  .bb #b20 (unit) {
    jump b2($b20.0)
  }
  .loop #b21 pre #Some(b22) header #b14 {
    .block #b20
    .block #b18
    .block #b15
    .block #b19
    .block #b16
    .block #b17
  }
  .bb #b22 () {
    jump b21(f11.m6, $f0, f11.m0, f11.m1, f11.m2, f11.m5, $b1.0, f11.m4, f11.m3)
  }
  .bb #b23 (unit) {
    let %61: int32 = load int32 field($b14.5, 0 * @32)
    let %62: int32 = add(%61, 1)
    let _ = store int32 field($b14.5, 0 * @32) <- %62
    jump b14($b14.0, $b14.1, $b14.2, $b14.3, $b14.4, $b14.5, $b14.6, $b14.7, $b14.8)
  }
  .bb #b24 (unit) {
    let %17: unit = call f3($b14.0, $b14.3)
    let _ = store int32 field($b14.4, 0 * @32) <- 0
    let %19: int32 = load int32 field($b14.2, 0 * @32)
    let _ = alloc <m14: array[int32] heap(1)> <- [..] = %19
    jump b101()
  }
  .bb #b25 (unit) {
    let %22: int32 = load int32 field($b14.8, 0 * @32)
    let %23: int32 = load int32 field($b14.4, 0 * @32)
    let %24: bool = le(%22, %23)
    br %24 b17() b18()
  }
  .bb #b26 (unit) {
    let %42: int32 = load int32 field($b14.5, 0 * @32)
    let %43: int32 = add(%42, 1)
    let _ = store int32 field($b14.5, 0 * @32) <- %43
    jump b14($b14.0, $b14.1, $b14.2, $b14.3, $b14.4, $b14.5, $b14.6, $b14.7, $b14.8)
  }
  .bb #b64 (int32, array[int32], array[int32], array[bool], array[int32], array[int32]) {
    let %64: bool = load bool field($b64.3, 0 * @32)
    let %65: bool = eq(%64, true)
    br %65 b65() b66()
  }
  .bb #b65 () {
    let %66: int32 = load int32 field($b64.1, 0 * @32)
    let %67: bool = eq(%66, $b64.0)
    br %67 b67() b68()
  }
  .bb #b66 () {
    jump b73(())
  }
  .bb #b67 () {
    let _ = store bool field($b64.3, 0 * @32) <- false
    let _ = store int32 field($b64.1, 0 * @32) <- 0
    jump b64($b64.0, $b64.1, $b64.2, $b64.3, $b64.4, $b64.5)
  }
  .bb #b68 () {
    let %71: int32 = load int32 field($b64.5, 0 * @32)
    let _ = store int32 field($b64.2, 0 * @32) <- %71
    let %73: unit = call f8(0, $b64.1, $b64.5)
    let %74: int32 = load int32 field($b64.1, 0 * @32)
    let %75: int32 = load int32 field($b64.2, 0 * @32)
    let _ = store int32 offset($b64.5, %74 * @32) <- %75
    let %77: int32 = load int32 field($b64.1, 0 * @32)
    let %78: int32 = load int32 field($b64.1, 0 * @32)
    let %79: int32 = load int32 offset($b64.4, %78 * @32)
    let %80: int32 = sub(%79, 1)
    let _ = store int32 offset($b64.4, %77 * @32) <- %80
    let %82: int32 = load int32 field($b64.1, 0 * @32)
    let %83: int32 = load int32 offset($b64.4, %82 * @32)
    let %84: bool = le(1, %83)
    br %84 b69() b70()
  }
  .bb #b69 () {
    let _ = store bool field($b64.3, 0 * @32) <- false
    jump b64($b64.0, $b64.1, $b64.2, $b64.3, $b64.4, $b64.5)
  }
  .bb #b70 () {
    let %87: int32 = load int32 field($b64.1, 0 * @32)
    let %88: int32 = add(%87, 1)
    let _ = store int32 field($b64.1, 0 * @32) <- %88
    jump b64($b64.0, $b64.1, $b64.2, $b64.3, $b64.4, $b64.5)
  }
  .bb #b71 (unit) {
    jump b72($b71.0)
  }
  .bb #b72 (unit) {
    jump b73($b72.0)
  }
  .bb #b73 (unit) {
    jump b23($b73.0)
  }
  .loop #b74 pre #Some(b75) header #b64 {
    .block #b70
    .block #b68
    .block #b72
    .block #b73
    .block #b65
    .block #b69
    .block #b66
    .block #b67
    .block #b71
  }
  .bb #b75 () {
    jump b74($b14.1, $b14.0, f11.m18, f11.m17, $b14.3, $b14.6)
  }
  .bb #b90 (int32, int32, array[int32], array[int32]) {
    let %90: int32 = sub($b90.1, 1)
    let %91: bool = le($b90.0, %90)
    br %91 b91() b92()
  }
  .bb #b91 () {
    let %92: int32 = load int32 offset($b90.3, $b90.0 * @32)
    let _ = store int32 offset($b90.2, $b90.0 * @32) <- %92
    let %94: int32 = add($b90.0, 1)
    jump b90(%94, $b90.1, $b90.2, $b90.3)
  }
  .bb #b92 () {
    jump b93(())
  }
  .bb #b93 (unit) {
    jump b24($b93.0)
  }
  .loop #b94 pre #Some(b95) header #b90 {
    .block #b91
    .block #b92
    .block #b93
  }
  .bb #b95 () {
    jump b94(0, $b14.1, $b14.2, $b14.6)
  }
  .bb #b96 (array[int32], array[int32], array[int32]) {
    let %95: int32 = load int32 field($b96.0, 0 * @32)
    let %96: bool = eq(%95, 0)
    br %96 b97() b98()
  }
  .bb #b97 () {
    jump b99(())
  }
  .bb #b98 () {
    let _ = alloc <m96: array[int32] heap(1)> <- [..] = 0
    let %98: unit = call f4(0, $b96.0, f11.m96, $b96.1)
    jump b102(%98)
  }
  .bb #b99 (unit) {
    jump b25($b99.0)
  }
  .loop #b100 pre #Some(b101) header #b96 {
    .block #b97
    .block #b98
    .block #b99
  }
  .bb #b101 () {
    jump b100(f11.m14, $b14.2, $b14.4)
  }
  .bb #b102 (unit) {
    let %99: int32 = load int32 field($b96.1, 0 * @32)
    let _ = store int32 field($b96.0, 0 * @32) <- %99
    let %101: int32 = load int32 field($b96.2, 0 * @32)
    let %102: int32 = add(%101, 1)
    let _ = store int32 field($b96.2, 0 * @32) <- %102
    jump b96($b96.0, $b96.1, $b96.2)
  }
  .bb #b104 (int32, array[int32], array[int32], array[bool], array[int32], array[int32]) {
    let %104: bool = load bool field($b104.3, 0 * @32)
    let %105: bool = eq(%104, true)
    br %105 b105() b106()
  }
  .bb #b105 () {
    let %106: int32 = load int32 field($b104.1, 0 * @32)
    let %107: bool = eq(%106, $b104.0)
    br %107 b107() b108()
  }
  .bb #b106 () {
    jump b113(())
  }
  .bb #b107 () {
    let _ = store bool field($b104.3, 0 * @32) <- false
    let _ = store int32 field($b104.1, 0 * @32) <- 0
    jump b104($b104.0, $b104.1, $b104.2, $b104.3, $b104.4, $b104.5)
  }
  .bb #b108 () {
    let %111: int32 = load int32 field($b104.5, 0 * @32)
    let _ = store int32 field($b104.2, 0 * @32) <- %111
    let %113: unit = call f6(0, $b104.1, $b104.5)
    let %114: int32 = load int32 field($b104.1, 0 * @32)
    let %115: int32 = load int32 field($b104.2, 0 * @32)
    let _ = store int32 offset($b104.5, %114 * @32) <- %115
    let %117: int32 = load int32 field($b104.1, 0 * @32)
    let %118: int32 = load int32 field($b104.1, 0 * @32)
    let %119: int32 = load int32 offset($b104.4, %118 * @32)
    let %120: int32 = sub(%119, 1)
    let _ = store int32 offset($b104.4, %117 * @32) <- %120
    let %122: int32 = load int32 field($b104.1, 0 * @32)
    let %123: int32 = load int32 offset($b104.4, %122 * @32)
    let %124: bool = le(1, %123)
    br %124 b109() b110()
  }
  .bb #b109 () {
    let _ = store bool field($b104.3, 0 * @32) <- false
    jump b104($b104.0, $b104.1, $b104.2, $b104.3, $b104.4, $b104.5)
  }
  .bb #b110 () {
    let %127: int32 = load int32 field($b104.1, 0 * @32)
    let %128: int32 = add(%127, 1)
    let _ = store int32 field($b104.1, 0 * @32) <- %128
    jump b104($b104.0, $b104.1, $b104.2, $b104.3, $b104.4, $b104.5)
  }
  .bb #b111 (unit) {
    jump b112($b111.0)
  }
  .bb #b112 (unit) {
    jump b113($b112.0)
  }
  .bb #b113 (unit) {
    jump b26($b113.0)
  }
  .loop #b114 pre #Some(b115) header #b104 {
    .block #b110
    .block #b108
    .block #b112
    .block #b113
    .block #b105
    .block #b109
    .block #b106
    .block #b107
    .block #b111
  }
  .bb #b115 () {
    jump b114($b14.1, $b14.0, f11.m16, f11.m15, $b14.3, $b14.6)
  }
}
.fn move_perm1_forward.240 #f8 : fn(int32, array[int32], array[int32]) -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: int32 = load int32 field($f1, 0 * @32)
    let %1: int32 = sub(%0, 1)
    let %2: bool = le($f0, %1)
    br %2 b1() b2()
  }
  .bb #b1 () {
    let %3: int32 = add($f0, 1)
    let %4: int32 = load int32 offset($f2, %3 * @32)
    let _ = store int32 offset($f2, $f0 * @32) <- %4
    let %6: int32 = add($f0, 1)
    let %7: unit = call f8(%6, $f1, $f2)
    jump b3(())
  }
  .bb #b2 () {
    jump b3(())
  }
  .bb #b3 (unit) {
    return $b3.0
  }
}
.fn init_arr.231 #f0 : fn(int32, array[int32], int32) -> unit
.freevars ()
.entry b5 {
  .bb #b0 (int32, array[int32], int32) {
    let %0: int32 = sub($b0.2, 1)
    let %1: bool = le($b0.0, %0)
    br %1 b1() b2()
  }
  .bb #b1 () {
    let _ = store int32 offset($b0.1, $b0.0 * @32) <- $b0.0
    let %3: int32 = add($b0.0, 1)
    jump b0(%3, $b0.1, $b0.2)
  }
  .bb #b2 () {
    jump b3(())
  }
  .bb #b3 (unit) {
    return $b3.0
  }
  .loop #b4 pre #Some(b5) header #b0 {
    .block #b1
    .block #b2
    .block #b3
  }
  .bb #b5 () {
    jump b4($f0, $f1, $f2)
  }
}
.fn compute.232 #f10 : fn(array[int32], int32, array[int32], array[int32], array[int32], array[int32], array[int32], array[int32], array[int32]) -> unit
.freevars ()
.entry b8 {
  .bb #b0 (array[int32], int32, array[int32], array[int32], array[int32], array[int32], array[int32], array[int32], array[int32]) {
    let %0: int32 = load int32 field($b0.0, 0 * @32)
    let %1: bool = le(1, %0)
    br %1 b1() b2()
  }
  .bb #b1 () {
    jump b81()
  }
  .bb #b2 () {
    jump b6(())
  }
  .bb #b3 () {
    let %11: int32 = load int32 field($b0.4, 0 * @32)
    let _ = store int32 field($b0.8, 0 * @32) <- %11
    let %13: int32 = load int32 field($b0.7, 0 * @32)
    let %14: int32 = load int32 field($b0.4, 0 * @32)
    let %15: int32 = load int32 field($b0.5, 0 * @32)
    let %16: int32 = load int32 field($b0.5, 0 * @32)
    let %17: int32 = div(%16, 2)
    let %18: int32 = mul(%17, 2)
    let %19: int32 = sub(%15, %18)
    let %20: int32 = mul(%19, 2)
    let %21: int32 = sub(1, %20)
    let %22: int32 = mul(%14, %21)
    let %23: int32 = add(%13, %22)
    let _ = store int32 field($b0.7, 0 * @32) <- %23
    let _ = alloc <m1: array[int32] heap(1)> <- [..] = true
    let _ = alloc <m2: array[int32] heap(1)> <- [..] = 0
    jump b101()
  }
  .bb #b4 () {
    let %32: int32 = load int32 field($b0.7, 0 * @32)
    let %33: int32 = load int32 field($b0.4, 0 * @32)
    let %34: int32 = load int32 field($b0.5, 0 * @32)
    let %35: int32 = load int32 field($b0.5, 0 * @32)
    let %36: int32 = div(%35, 2)
    let %37: int32 = mul(%36, 2)
    let %38: int32 = sub(%34, %37)
    let %39: int32 = mul(%38, 2)
    let %40: int32 = sub(1, %39)
    let %41: int32 = mul(%33, %40)
    let %42: int32 = add(%32, %41)
    let _ = store int32 field($b0.7, 0 * @32) <- %42
    let _ = alloc <m3: array[int32] heap(1)> <- [..] = true
    let _ = alloc <m4: array[int32] heap(1)> <- [..] = 0
    jump b61()
  }
  .bb #b5 (unit) {
    jump b6($b5.0)
  }
  .bb #b6 (unit) {
    return $b6.0
  }
  .loop #b7 pre #Some(b8) header #b0 {
    .block #b6
    .block #b4
    .block #b1
    .block #b5
    .block #b2
    .block #b3
  }
  .bb #b8 () {
    jump b7($f0, $f1, $f2, $f3, $f4, $f5, $f6, $f7, $f8)
  }
  .bb #b9 (unit) {
    let %47: int32 = load int32 field($b0.5, 0 * @32)
    let %48: int32 = add(%47, 1)
    let _ = store int32 field($b0.5, 0 * @32) <- %48
    jump b0($b0.0, $b0.1, $b0.2, $b0.3, $b0.4, $b0.5, $b0.6, $b0.7, $b0.8)
  }
  .bb #b10 (unit) {
    let %3: unit = call f3($b0.0, $b0.3)
    let _ = store int32 field($b0.4, 0 * @32) <- 0
    let %5: int32 = load int32 field($b0.2, 0 * @32)
    let _ = alloc <m0: array[int32] heap(1)> <- [..] = %5
    jump b87()
  }
  .bb #b11 (unit) {
    let %8: int32 = load int32 field($b0.8, 0 * @32)
    let %9: int32 = load int32 field($b0.4, 0 * @32)
    let %10: bool = le(%8, %9)
    br %10 b3() b4()
  }
  .bb #b12 (unit) {
    let %28: int32 = load int32 field($b0.5, 0 * @32)
    let %29: int32 = add(%28, 1)
    let _ = store int32 field($b0.5, 0 * @32) <- %29
    jump b0($b0.0, $b0.1, $b0.2, $b0.3, $b0.4, $b0.5, $b0.6, $b0.7, $b0.8)
  }
  .bb #b50 (int32, array[int32], array[int32], array[bool], array[int32], array[int32]) {
    let %50: bool = load bool field($b50.3, 0 * @32)
    let %51: bool = eq(%50, true)
    br %51 b51() b52()
  }
  .bb #b51 () {
    let %52: int32 = load int32 field($b50.1, 0 * @32)
    let %53: bool = eq(%52, $b50.0)
    br %53 b53() b54()
  }
  .bb #b52 () {
    jump b59(())
  }
  .bb #b53 () {
    let _ = store bool field($b50.3, 0 * @32) <- false
    let _ = store int32 field($b50.1, 0 * @32) <- 0
    jump b50($b50.0, $b50.1, $b50.2, $b50.3, $b50.4, $b50.5)
  }
  .bb #b54 () {
    let %57: int32 = load int32 field($b50.5, 0 * @32)
    let _ = store int32 field($b50.2, 0 * @32) <- %57
    let %59: unit = call f8(0, $b50.1, $b50.5)
    let %60: int32 = load int32 field($b50.1, 0 * @32)
    let %61: int32 = load int32 field($b50.2, 0 * @32)
    let _ = store int32 offset($b50.5, %60 * @32) <- %61
    let %63: int32 = load int32 field($b50.1, 0 * @32)
    let %64: int32 = load int32 field($b50.1, 0 * @32)
    let %65: int32 = load int32 offset($b50.4, %64 * @32)
    let %66: int32 = sub(%65, 1)
    let _ = store int32 offset($b50.4, %63 * @32) <- %66
    let %68: int32 = load int32 field($b50.1, 0 * @32)
    let %69: int32 = load int32 offset($b50.4, %68 * @32)
    let %70: bool = le(1, %69)
    br %70 b55() b56()
  }
  .bb #b55 () {
    let _ = store bool field($b50.3, 0 * @32) <- false
    jump b50($b50.0, $b50.1, $b50.2, $b50.3, $b50.4, $b50.5)
  }
  .bb #b56 () {
    let %73: int32 = load int32 field($b50.1, 0 * @32)
    let %74: int32 = add(%73, 1)
    let _ = store int32 field($b50.1, 0 * @32) <- %74
    jump b50($b50.0, $b50.1, $b50.2, $b50.3, $b50.4, $b50.5)
  }
  .bb #b57 (unit) {
    jump b58($b57.0)
  }
  .bb #b58 (unit) {
    jump b59($b58.0)
  }
  .bb #b59 (unit) {
    jump b9($b59.0)
  }
  .loop #b60 pre #Some(b61) header #b50 {
    .block #b56
    .block #b54
    .block #b58
    .block #b59
    .block #b51
    .block #b55
    .block #b52
    .block #b53
    .block #b57
  }
  .bb #b61 () {
    jump b60($b0.1, $b0.0, f10.m4, f10.m3, $b0.3, $b0.6)
  }
  .bb #b76 (int32, int32, array[int32], array[int32]) {
    let %76: int32 = sub($b76.1, 1)
    let %77: bool = le($b76.0, %76)
    br %77 b77() b78()
  }
  .bb #b77 () {
    let %78: int32 = load int32 offset($b76.3, $b76.0 * @32)
    let _ = store int32 offset($b76.2, $b76.0 * @32) <- %78
    let %80: int32 = add($b76.0, 1)
    jump b76(%80, $b76.1, $b76.2, $b76.3)
  }
  .bb #b78 () {
    jump b79(())
  }
  .bb #b79 (unit) {
    jump b10($b79.0)
  }
  .loop #b80 pre #Some(b81) header #b76 {
    .block #b77
    .block #b78
    .block #b79
  }
  .bb #b81 () {
    jump b80(0, $b0.1, $b0.2, $b0.6)
  }
  .bb #b82 (array[int32], array[int32], array[int32]) {
    let %81: int32 = load int32 field($b82.0, 0 * @32)
    let %82: bool = eq(%81, 0)
    br %82 b83() b84()
  }
  .bb #b83 () {
    jump b85(())
  }
  .bb #b84 () {
    let _ = alloc <m82: array[int32] heap(1)> <- [..] = 0
    let %84: unit = call f4(0, $b82.0, f10.m82, $b82.1)
    jump b88(%84)
  }
  .bb #b85 (unit) {
    jump b11($b85.0)
  }
  .loop #b86 pre #Some(b87) header #b82 {
    .block #b83
    .block #b84
    .block #b85
  }
  .bb #b87 () {
    jump b86(f10.m0, $b0.2, $b0.4)
  }
  .bb #b88 (unit) {
    let %85: int32 = load int32 field($b82.1, 0 * @32)
    let _ = store int32 field($b82.0, 0 * @32) <- %85
    let %87: int32 = load int32 field($b82.2, 0 * @32)
    let %88: int32 = add(%87, 1)
    let _ = store int32 field($b82.2, 0 * @32) <- %88
    jump b82($b82.0, $b82.1, $b82.2)
  }
  .bb #b90 (int32, array[int32], array[int32], array[bool], array[int32], array[int32]) {
    let %90: bool = load bool field($b90.3, 0 * @32)
    let %91: bool = eq(%90, true)
    br %91 b91() b92()
  }
  .bb #b91 () {
    let %92: int32 = load int32 field($b90.1, 0 * @32)
    let %93: bool = eq(%92, $b90.0)
    br %93 b93() b94()
  }
  .bb #b92 () {
    jump b99(())
  }
  .bb #b93 () {
    let _ = store bool field($b90.3, 0 * @32) <- false
    let _ = store int32 field($b90.1, 0 * @32) <- 0
    jump b90($b90.0, $b90.1, $b90.2, $b90.3, $b90.4, $b90.5)
  }
  .bb #b94 () {
    let %97: int32 = load int32 field($b90.5, 0 * @32)
    let _ = store int32 field($b90.2, 0 * @32) <- %97
    let %99: unit = call f6(0, $b90.1, $b90.5)
    let %100: int32 = load int32 field($b90.1, 0 * @32)
    let %101: int32 = load int32 field($b90.2, 0 * @32)
    let _ = store int32 offset($b90.5, %100 * @32) <- %101
    let %103: int32 = load int32 field($b90.1, 0 * @32)
    let %104: int32 = load int32 field($b90.1, 0 * @32)
    let %105: int32 = load int32 offset($b90.4, %104 * @32)
    let %106: int32 = sub(%105, 1)
    let _ = store int32 offset($b90.4, %103 * @32) <- %106
    let %108: int32 = load int32 field($b90.1, 0 * @32)
    let %109: int32 = load int32 offset($b90.4, %108 * @32)
    let %110: bool = le(1, %109)
    br %110 b95() b96()
  }
  .bb #b95 () {
    let _ = store bool field($b90.3, 0 * @32) <- false
    jump b90($b90.0, $b90.1, $b90.2, $b90.3, $b90.4, $b90.5)
  }
  .bb #b96 () {
    let %113: int32 = load int32 field($b90.1, 0 * @32)
    let %114: int32 = add(%113, 1)
    let _ = store int32 field($b90.1, 0 * @32) <- %114
    jump b90($b90.0, $b90.1, $b90.2, $b90.3, $b90.4, $b90.5)
  }
  .bb #b97 (unit) {
    jump b98($b97.0)
  }
  .bb #b98 (unit) {
    jump b99($b98.0)
  }
  .bb #b99 (unit) {
    jump b12($b99.0)
  }
  .loop #b100 pre #Some(b101) header #b90 {
    .block #b96
    .block #b94
    .block #b98
    .block #b99
    .block #b91
    .block #b95
    .block #b92
    .block #b93
    .block #b97
  }
  .bb #b101 () {
    jump b100($b0.1, $b0.0, f10.m2, f10.m1, $b0.3, $b0.6)
  }
}
.fn init_count.234 #f3 : fn(array[int32], array[int32]) -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: int32 = load int32 field($f0, 0 * @32)
    let %1: bool = eq(%0, 1)
    br %1 b1() b2()
  }
  .bb #b1 () {
    jump b3(())
  }
  .bb #b2 () {
    let %2: int32 = load int32 field($f0, 0 * @32)
    let %3: int32 = sub(%2, 1)
    let %4: int32 = load int32 field($f0, 0 * @32)
    let _ = store int32 offset($f1, %3 * @32) <- %4
    let %6: int32 = load int32 field($f0, 0 * @32)
    let %7: int32 = sub(%6, 1)
    let _ = store int32 field($f0, 0 * @32) <- %7
    let %9: unit = call f3($f0, $f1)
    jump b3(())
  }
  .bb #b3 (unit) {
    return $b3.0
  }
}
.fn go_loop.237 #f7 : fn(int32, array[int32], array[int32], array[bool], array[int32], array[int32]) -> unit
.freevars ()
.entry b11 {
  .bb #b0 (int32, array[int32], array[int32], array[bool], array[int32], array[int32]) {
    let %0: bool = load bool field($b0.3, 0 * @32)
    let %1: bool = eq(%0, true)
    br %1 b1() b2()
  }
  .bb #b1 () {
    let %2: int32 = load int32 field($b0.1, 0 * @32)
    let %3: bool = eq(%2, $b0.0)
    br %3 b3() b4()
  }
  .bb #b2 () {
    jump b9(())
  }
  .bb #b3 () {
    let _ = store bool field($b0.3, 0 * @32) <- false
    let _ = store int32 field($b0.1, 0 * @32) <- 0
    jump b0($b0.0, $b0.1, $b0.2, $b0.3, $b0.4, $b0.5)
  }
  .bb #b4 () {
    let %7: int32 = load int32 field($b0.5, 0 * @32)
    let _ = store int32 field($b0.2, 0 * @32) <- %7
    let %9: unit = call f6(0, $b0.1, $b0.5)
    let %10: int32 = load int32 field($b0.1, 0 * @32)
    let %11: int32 = load int32 field($b0.2, 0 * @32)
    let _ = store int32 offset($b0.5, %10 * @32) <- %11
    let %13: int32 = load int32 field($b0.1, 0 * @32)
    let %14: int32 = load int32 field($b0.1, 0 * @32)
    let %15: int32 = load int32 offset($b0.4, %14 * @32)
    let %16: int32 = sub(%15, 1)
    let _ = store int32 offset($b0.4, %13 * @32) <- %16
    let %18: int32 = load int32 field($b0.1, 0 * @32)
    let %19: int32 = load int32 offset($b0.4, %18 * @32)
    let %20: bool = le(1, %19)
    br %20 b5() b6()
  }
  .bb #b5 () {
    let _ = store bool field($b0.3, 0 * @32) <- false
    jump b0($b0.0, $b0.1, $b0.2, $b0.3, $b0.4, $b0.5)
  }
  .bb #b6 () {
    let %23: int32 = load int32 field($b0.1, 0 * @32)
    let %24: int32 = add(%23, 1)
    let _ = store int32 field($b0.1, 0 * @32) <- %24
    jump b0($b0.0, $b0.1, $b0.2, $b0.3, $b0.4, $b0.5)
  }
  .bb #b7 (unit) {
    jump b8($b7.0)
  }
  .bb #b8 (unit) {
    jump b9($b8.0)
  }
  .bb #b9 (unit) {
    return $b9.0
  }
  .loop #b10 pre #Some(b11) header #b0 {
    .block #b6
    .block #b4
    .block #b8
    .block #b9
    .block #b1
    .block #b5
    .block #b2
    .block #b3
    .block #b7
  }
  .bb #b11 () {
    jump b10($f0, $f1, $f2, $f3, $f4, $f5)
  }
}
.fn main.241 #f12 : fn() -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: (int32, int32) = call f11(9)
    let %1: int32 = load int32 field(%0, 0 * @(@32, @(@32, @32)))
    let %2: int32 = load int32 field(%0, 1 * @(@32, @(@32, @32)))
    let %3: unit = ext_call minimbt_print_int(%2)
    let %4: unit = ext_call minimbt_print_int(%1)
    return %4
  }
}
.fn flip_loop.236 #f4 : fn(int32, array[int32], array[int32], array[int32]) -> unit
.freevars ()
.entry b5 {
  .bb #b0 (int32, array[int32], array[int32], array[int32]) {
    let %0: int32 = load int32 field($b0.1, 0 * @32)
    let %1: int32 = div(%0, 2)
    let %2: bool = le($b0.0, %1)
    br %2 b1() b2()
  }
  .bb #b1 () {
    let %3: int32 = load int32 offset($b0.3, $b0.0 * @32)
    let _ = store int32 field($b0.2, 0 * @32) <- %3
    let %5: int32 = load int32 field($b0.1, 0 * @32)
    let %6: int32 = sub(%5, $b0.0)
    let %7: int32 = load int32 offset($b0.3, %6 * @32)
    let _ = store int32 offset($b0.3, $b0.0 * @32) <- %7
    let %9: int32 = load int32 field($b0.1, 0 * @32)
    let %10: int32 = sub(%9, $b0.0)
    let %11: int32 = load int32 field($b0.2, 0 * @32)
    let _ = store int32 offset($b0.3, %10 * @32) <- %11
    let %13: int32 = add($b0.0, 1)
    jump b0(%13, $b0.1, $b0.2, $b0.3)
  }
  .bb #b2 () {
    jump b3(())
  }
  .bb #b3 (unit) {
    return $b3.0
  }
  .loop #b4 pre #Some(b5) header #b0 {
    .block #b1
    .block #b2
    .block #b3
  }
  .bb #b5 () {
    jump b4($f0, $f1, $f2, $f3)
  }
}
.fn do_flip.235 #f5 : fn(array[int32], array[int32], array[int32]) -> unit
.freevars ()
.entry b5 {
  .bb #b0 (array[int32], array[int32], array[int32]) {
    let %0: int32 = load int32 field($b0.0, 0 * @32)
    let %1: bool = eq(%0, 0)
    br %1 b1() b2()
  }
  .bb #b1 () {
    jump b3(())
  }
  .bb #b2 () {
    let _ = alloc <m0: array[int32] heap(1)> <- [..] = 0
    jump b14()
  }
  .bb #b3 (unit) {
    return $b3.0
  }
  .loop #b4 pre #Some(b5) header #b0 {
    .block #b1
    .block #b2
    .block #b3
  }
  .bb #b5 () {
    jump b4($f0, $f1, $f2)
  }
  .bb #b6 (unit) {
    let %4: int32 = load int32 field($b0.1, 0 * @32)
    let _ = store int32 field($b0.0, 0 * @32) <- %4
    let %6: int32 = load int32 field($b0.2, 0 * @32)
    let %7: int32 = add(%6, 1)
    let _ = store int32 field($b0.2, 0 * @32) <- %7
    jump b0($b0.0, $b0.1, $b0.2)
  }
  .bb #b9 (int32, array[int32], array[int32], array[int32]) {
    let %9: int32 = load int32 field($b9.1, 0 * @32)
    let %10: int32 = div(%9, 2)
    let %11: bool = le($b9.0, %10)
    br %11 b10() b11()
  }
  .bb #b10 () {
    let %12: int32 = load int32 offset($b9.3, $b9.0 * @32)
    let _ = store int32 field($b9.2, 0 * @32) <- %12
    let %14: int32 = load int32 field($b9.1, 0 * @32)
    let %15: int32 = sub(%14, $b9.0)
    let %16: int32 = load int32 offset($b9.3, %15 * @32)
    let _ = store int32 offset($b9.3, $b9.0 * @32) <- %16
    let %18: int32 = load int32 field($b9.1, 0 * @32)
    let %19: int32 = sub(%18, $b9.0)
    let %20: int32 = load int32 field($b9.2, 0 * @32)
    let _ = store int32 offset($b9.3, %19 * @32) <- %20
    let %22: int32 = add($b9.0, 1)
    jump b9(%22, $b9.1, $b9.2, $b9.3)
  }
  .bb #b11 () {
    jump b12(())
  }
  .bb #b12 (unit) {
    jump b6($b12.0)
  }
  .loop #b13 pre #Some(b14) header #b9 {
    .block #b10
    .block #b11
    .block #b12
  }
  .bb #b14 () {
    jump b13(0, $b0.0, f5.m0, $b0.1)
  }
}
.fn T$start #f26 : fn() -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: unit = call f12()
    return %0
  }
}
.fn go_loop.239 #f9 : fn(int32, array[int32], array[int32], array[bool], array[int32], array[int32]) -> unit
.freevars ()
.entry b11 {
  .bb #b0 (int32, array[int32], array[int32], array[bool], array[int32], array[int32]) {
    let %0: bool = load bool field($b0.3, 0 * @32)
    let %1: bool = eq(%0, true)
    br %1 b1() b2()
  }
  .bb #b1 () {
    let %2: int32 = load int32 field($b0.1, 0 * @32)
    let %3: bool = eq(%2, $b0.0)
    br %3 b3() b4()
  }
  .bb #b2 () {
    jump b9(())
  }
  .bb #b3 () {
    let _ = store bool field($b0.3, 0 * @32) <- false
    let _ = store int32 field($b0.1, 0 * @32) <- 0
    jump b0($b0.0, $b0.1, $b0.2, $b0.3, $b0.4, $b0.5)
  }
  .bb #b4 () {
    let %7: int32 = load int32 field($b0.5, 0 * @32)
    let _ = store int32 field($b0.2, 0 * @32) <- %7
    let %9: unit = call f8(0, $b0.1, $b0.5)
    let %10: int32 = load int32 field($b0.1, 0 * @32)
    let %11: int32 = load int32 field($b0.2, 0 * @32)
    let _ = store int32 offset($b0.5, %10 * @32) <- %11
    let %13: int32 = load int32 field($b0.1, 0 * @32)
    let %14: int32 = load int32 field($b0.1, 0 * @32)
    let %15: int32 = load int32 offset($b0.4, %14 * @32)
    let %16: int32 = sub(%15, 1)
    let _ = store int32 offset($b0.4, %13 * @32) <- %16
    let %18: int32 = load int32 field($b0.1, 0 * @32)
    let %19: int32 = load int32 offset($b0.4, %18 * @32)
    let %20: bool = le(1, %19)
    br %20 b5() b6()
  }
  .bb #b5 () {
    let _ = store bool field($b0.3, 0 * @32) <- false
    jump b0($b0.0, $b0.1, $b0.2, $b0.3, $b0.4, $b0.5)
  }
  .bb #b6 () {
    let %23: int32 = load int32 field($b0.1, 0 * @32)
    let %24: int32 = add(%23, 1)
    let _ = store int32 field($b0.1, 0 * @32) <- %24
    jump b0($b0.0, $b0.1, $b0.2, $b0.3, $b0.4, $b0.5)
  }
  .bb #b7 (unit) {
    jump b8($b7.0)
  }
  .bb #b8 (unit) {
    jump b9($b8.0)
  }
  .bb #b9 (unit) {
    return $b9.0
  }
  .loop #b10 pre #Some(b11) header #b0 {
    .block #b6
    .block #b4
    .block #b8
    .block #b9
    .block #b1
    .block #b5
    .block #b2
    .block #b3
    .block #b7
  }
  .bb #b11 () {
    jump b10($f0, $f1, $f2, $f3, $f4, $f5)
  }
}
.thunk ::0 start
