// [Asm] pre_assigned_registers: FnParam(fref=f8, fpref=$f.3) -> v5, BlockParam(bref=b2, bpref=$b.0) -> v16, Insn(iref=%15) -> v35, FnParam(fref=f8, fpref=$f.0) -> v2, FnParam(fref=f8, fpref=$f.5) -> v7, FnParam(fref=f8, fpref=$f.7) -> v9, BlockParam(bref=b7, bpref=$b.0) -> v49, Mem(fref=f8, mref=m15) -> v15, BlockParam(bref=b10, bpref=$b.0) -> v40, Insn(iref=%8) -> v44, Insn(iref=%10) -> v29, BlockParam(bref=b34, bpref=$b.0) -> v19, BlockParam(bref=b14, bpref=$b.0) -> v45, BlockParam(bref=b35, bpref=$b.0) -> v24, Mem(fref=f8, mref=m16) -> v11, Insn(iref=%4) -> v50, BlockParam(bref=b25, bpref=$b.0) -> v28, Mem(fref=f8, mref=m0) -> v12, FnParam(fref=f8, fpref=$f.6) -> v8, Insn(iref=%1) -> v41, Insn(iref=%11) -> v30, BlockParam(bref=b23, bpref=$b.0) -> v39, BlockParam(bref=b24, bpref=$b.0) -> v34, Insn(iref=%6) -> v47, BlockParam(bref=b9, bpref=$b.0) -> v46, FnParam(fref=f8, fpref=$f.2) -> v4, BlockParam(bref=b29, bpref=$b.0) -> v33, Mem(fref=f8, mref=m31) -> v13, BlockParam(bref=b22, bpref=$b.0) -> v37, FnParam(fref=f8, fpref=$f.1) -> v3, BlockParam(bref=b17, bpref=$b.0) -> v17, Insn(iref=%24) -> v25, Insn(iref=%16) -> v36, BlockParam(bref=b8, bpref=$b.0) -> v51, Mem(fref=f8, mref=m1) -> v10, Insn(iref=%19) -> v20, Insn(iref=%18) -> v18, Insn(iref=%3) -> v43, Insn(iref=%13) -> v38, Mem(fref=f8, mref=m30) -> v14, BlockParam(bref=b33, bpref=$b.0) -> v27, Insn(iref=%7) -> v48, Insn(iref=%22) -> v26, Insn(iref=%23) -> v23, Insn(iref=%17) -> v32, Insn(iref=%2) -> v42, Insn(iref=%20) -> v21, FnParam(fref=f8, fpref=$f.4) -> v6, Insn(iref=%21) -> v22, Self(fref=f8) -> v0, Insn(iref=%12) -> v31
// [Asm] skipping Op(ty=Bool, op=Eq, args=[BlockParam(bref=b9, bpref=$b.0), Int32(val=0)])
// [Asm] skipping Op(ty=Bool, op=Le, args=[Insn(iref=%2), FnParam(fref=f8, fpref=$f.5)])
// [Asm] skipping Op(ty=Bool, op=Eq, args=[Insn(iref=%1), Int32(val=0)])
// [Asm] skipping Op(ty=Bool, op=Eq, args=[BlockParam(bref=b24, bpref=$b.0), Int32(val=0)])
// [Asm] skipping Op(ty=Bool, op=Le, args=[FnParam(fref=f8, fpref=$f.4), Insn(iref=%11)])
// [Asm] skipping Op(ty=Bool, op=Eq, args=[Insn(iref=%10), Int32(val=0)])
// [Asm] skipping Op(ty=Bool, op=Eq, args=[Insn(iref=%19), Int32(val=0)])
// [Asm] defs: []
// [Asm] live_set: [v5, zero, v30, v7, v8, v4, v6, s11, v9, v3]
// [Asm] move_origin: []
// [Asm] defs: [v20]
// [Asm] live_set: [v5, zero, v20, v8, v7, v19, v4, v6, s11, v9, v3]
// [Asm] move_origin: []
// [Asm] defined: v20 is X
// [Asm] defs: [v21]
// [Asm] live_set: [v5, v21, zero, v20, v8, v7, v4, v6, s11, v9, v3]
// [Asm] move_origin: []
// [Asm] defined: v21 is X
// [Asm] defs: []
// [Asm] live_set: [v5, v21, zero, v8, v7, v4, v6, s11, v9, v3]
// [Asm] move_origin: []
// [Asm] defs: [v13]
// [Asm] live_set: [v5, zero, v13, v7, v8, v4, v6, v24, v9, v3]
// [Asm] move_origin: []
// [Asm] defined: v13 is X
// [Asm] defs: [s11]
// [Asm] live_set: [v5, zero, v13, v7, v8, v4, v6, s11, v24, v9, v3]
// [Asm] move_origin: []
// [Asm] defined: s11 is X
// [Asm] defs: [v66]
// [Asm] live_set: [v66, v5, zero, v13, v7, v8, v4, v6, s11, v24, v9, v3]
// [Asm] move_origin: []
// [Asm] defined: v66 is X
// [Asm] defs: []
// [Asm] live_set: [v5, zero, v13, v7, v8, v4, v6, s11, v24, v9, v3]
// [Asm] move_origin: []
// [Asm] defs: []
// [Asm] live_set: [v5, zero, v13, v7, v8, v4, v6, s11, v9, v3]
// [Asm] move_origin: []
// [Asm] defs: [v27]
// [Asm] live_set: [v5, zero, v27, v7, v8, v4, v6, s11, v9, v3]
// [Asm] move_origin: [v13]
// [Asm] defined: v27 is X
// [Asm] defs: []
// [Asm] live_set: [v5, zero, v27, v7, v8, v4, v6, s11, v9, v3]
// [Asm] move_origin: []
// [Asm] defs: []
// [Asm] live_set: [v5, zero, v30, v7, v8, v4, v6, s11, v9, v3]
// [Asm] move_origin: []
// [Asm] defs: []
// [Asm] live_set: [v5, v42, zero, v7, v8, v4, v6, s11, v9, v3]
// [Asm] move_origin: []
// [Asm] defs: [v61]
// [Asm] live_set: [v5, zero, v30, v7, v8, v4, v6, s11, v61, v9, v3]
// [Asm] move_origin: []
// [Asm] defined: v61 is X
// [Asm] defs: [v33]
// [Asm] live_set: [v5, zero, v30, v7, v8, v4, v6, s11, v33, v9, v3]
// [Asm] move_origin: [v61]
// [Asm] defined: v33 is X
// [Asm] defs: []
// [Asm] live_set: [v5, zero, v30, v7, v8, v4, v6, s11, v33, v9, v3]
// [Asm] move_origin: []
// [Asm] defs: []
// [Asm] live_set: [v5, zero, v42, v7, v8, v4, v6, s11, v9, v3]
// [Asm] move_origin: []
// [Asm] defs: [v29]
// [Asm] live_set: [v5, zero, v29, v8, v7, v4, v6, s11, v28, v9, v3]
// [Asm] move_origin: []
// [Asm] defined: v29 is X
// [Asm] defs: [v30]
// [Asm] live_set: [v5, zero, v29, v30, v8, v7, v4, v6, s11, v9, v3]
// [Asm] move_origin: []
// [Asm] defined: v30 is X
// [Asm] defs: []
// [Asm] live_set: [v5, zero, v30, v7, v8, v4, v6, s11, v9, v3]
// [Asm] move_origin: []
// [Asm] defs: [v17]
// [Asm] live_set: [v5, zero, v7, v8, v4, v17, v6, s11, v9, v3]
// [Asm] move_origin: [zero]
// [Asm] defined: v17 is X
// [Asm] defs: [v45]
// [Asm] live_set: [v5, zero, v42, v45, v7, v8, v4, v6, s11, v9, v3]
// [Asm] move_origin: [zero]
// [Asm] defined: v45 is X
// [Asm] defs: [v15]
// [Asm] live_set: [v5, zero, v7, v8, v4, v6, v15, v9, v3]
// [Asm] move_origin: []
// [Asm] defined: v15 is X
// [Asm] defs: [s11]
// [Asm] live_set: [v5, zero, v7, v8, v4, v6, s11, v15, v9, v3]
// [Asm] move_origin: []
// [Asm] defined: s11 is X
// [Asm] defs: []
// [Asm] live_set: [v5, zero, v7, v8, v4, v6, s11, v15, v9, v3]
// [Asm] move_origin: []
// [Asm] defs: []
// [Asm] live_set: [v5, zero, v7, v8, v4, v6, s11, v15, v9, v3]
// [Asm] move_origin: []
// [Asm] defs: [v39]
// [Asm] live_set: [v5, zero, v7, v8, v4, v6, s11, v9, v39, v3]
// [Asm] move_origin: [v15]
// [Asm] defined: v39 is X
// [Asm] defs: [v41]
// [Asm] live_set: [v40, v5, zero, v7, v8, v4, v41, v6, s11, v9, v3]
// [Asm] move_origin: []
// [Asm] defined: v41 is X
// [Asm] defs: [v42]
// [Asm] live_set: [v5, zero, v42, v7, v8, v4, v41, v6, s11, v9, v3]
// [Asm] move_origin: []
// [Asm] defined: v42 is X
// [Asm] defs: []
// [Asm] live_set: [v5, zero, v42, v7, v8, v4, v6, s11, v9, v3]
// [Asm] move_origin: []
// [Asm] defs: [v34]
// [Asm] live_set: [v5, zero, v30, v7, v8, v4, v6, s11, v34, v9, v3]
// [Asm] move_origin: [v33]
// [Asm] defined: v34 is X
// [Asm] defs: [v14]
// [Asm] live_set: [v5, v14, zero, v7, v8, v4, v6, v9, v3]
// [Asm] move_origin: []
// [Asm] defined: v14 is X
// [Asm] defs: [s11]
// [Asm] live_set: [v5, v14, zero, v7, v8, v4, v6, s11, v9, v3]
// [Asm] move_origin: []
// [Asm] defined: s11 is X
// [Asm] defs: []
// [Asm] live_set: [v5, v14, zero, v7, v8, v4, v6, s11, v9, v3]
// [Asm] move_origin: []
// [Asm] defs: []
// [Asm] live_set: [v5, v14, zero, v7, v8, v4, v6, s11, v9, v3]
// [Asm] move_origin: []
// [Asm] defs: [v27]
// [Asm] live_set: [v5, zero, v27, v7, v8, v4, v6, s11, v9, v3]
// [Asm] move_origin: [v14]
// [Asm] defined: v27 is X
// [Asm] defs: [v17]
// [Asm] live_set: [v5, zero, v7, v8, v4, v17, v6, s11, v9, v3]
// [Asm] move_origin: [zero]
// [Asm] defined: v17 is X
// [Asm] defs: []
// [Asm] live_set: [v5, zero, v7, v8, v4, v17, v6, s11, v9, v3]
// [Asm] move_origin: []
// [Asm] defs: [v40]
// [Asm] live_set: [v3, v5, zero, v7, v8, v4, v6, s11, v9, v40]
// [Asm] move_origin: [v39]
// [Asm] defined: v40 is X
// [Asm] defs: [v11]
// [Asm] live_set: [v11, v5, zero, v30, v7, v8, v4, v6, v9, v3]
// [Asm] move_origin: []
// [Asm] defined: v11 is X
// [Asm] defs: [s11]
// [Asm] live_set: [v11, v5, zero, v30, v7, v8, v4, v6, s11, v9, v3]
// [Asm] move_origin: []
// [Asm] defined: s11 is X
// [Asm] defs: [v60]
// [Asm] live_set: [v11, v5, zero, v30, v7, v8, v4, v6, s11, v9, v60, v3]
// [Asm] move_origin: []
// [Asm] defined: v60 is X
// [Asm] defs: []
// [Asm] live_set: [v11, v5, zero, v30, v7, v8, v4, v6, s11, v9, v3]
// [Asm] move_origin: []
// [Asm] defs: []
// [Asm] live_set: [v11, v5, zero, v7, v8, v4, v6, s11, v9, v3]
// [Asm] move_origin: []
// [Asm] defs: [v37]
// [Asm] live_set: [v5, zero, v7, v8, v37, v4, v6, s11, v9, v3]
// [Asm] move_origin: [v11]
// [Asm] defined: v37 is X
// [Asm] defs: [v33]
// [Asm] live_set: [v5, zero, v30, v7, v8, v4, v6, s11, v33, v9, v3]
// [Asm] move_origin: [zero]
// [Asm] defined: v33 is X
// [Asm] defs: []
// [Asm] live_set: [a7, a5, zero, a0, a4, a6, a2, a1, s11, a3]
// [Asm] move_origin: []
// [Asm] defs: [v2]
// [Asm] live_set: [a7, a5, zero, a4, a6, a2, a1, s11, a3, v2]
// [Asm] move_origin: [a0]
// [Asm] defined: v2 is X
// [Asm] defs: [v3]
// [Asm] live_set: [v2, a7, a5, zero, a4, a6, a2, s11, a3, v3]
// [Asm] move_origin: [a1]
// [Asm] defined: v3 is X
// [Asm] defs: [v4]
// [Asm] live_set: [v2, a7, a5, zero, a4, a6, v4, s11, a3, v3]
// [Asm] move_origin: [a2]
// [Asm] defined: v4 is X
// [Asm] defs: [v5]
// [Asm] live_set: [v2, a7, v5, a5, zero, a4, a6, v4, s11, v3]
// [Asm] move_origin: [a3]
// [Asm] defined: v5 is X
// [Asm] defs: [v6]
// [Asm] live_set: [v2, a7, v5, a5, zero, a6, v4, v6, s11, v3]
// [Asm] move_origin: [a4]
// [Asm] defined: v6 is X
// [Asm] defs: [v7]
// [Asm] live_set: [v2, a7, v5, zero, v7, a6, v4, v6, s11, v3]
// [Asm] move_origin: [a5]
// [Asm] defined: v7 is X
// [Asm] defs: [v8]
// [Asm] live_set: [v2, a7, v5, zero, v7, v8, v4, v6, s11, v3]
// [Asm] move_origin: [a6]
// [Asm] defined: v8 is X
// [Asm] defs: [v9]
// [Asm] live_set: [v2, v5, zero, v7, v8, v4, v6, s11, v9, v3]
// [Asm] move_origin: [a7]
// [Asm] defined: v9 is X
// [Asm] defs: [v16]
// [Asm] live_set: [v16, v5, zero, v7, v8, v4, v6, s11, v9, v3]
// [Asm] move_origin: [v2]
// [Asm] defined: v16 is X
// [Asm] defs: [v16]
// [Asm] live_set: [v16, v5, zero, v7, v8, v4, v6, s11, v9, v3]
// [Asm] move_origin: [zero]
// [Asm] defined: v16 is X
// [Asm] defs: []
// [Asm] live_set: [v16, v5, zero, v7, v8, v4, v6, s11, v9, v3]
// [Asm] move_origin: []
// [Asm] defs: [v10]
// [Asm] live_set: [v10, v42]
// [Asm] move_origin: []
// [Asm] defined: v10 is X
// [Asm] defs: [s11]
// [Asm] live_set: [v10, v42]
// [Asm] move_origin: []
// [Asm] defined: s11 is X
// [Asm] defs: [v54]
// [Asm] live_set: [v10, v42, v54]
// [Asm] move_origin: []
// [Asm] defined: v54 is X
// [Asm] defs: []
// [Asm] live_set: [v10, v42]
// [Asm] move_origin: []
// [Asm] defs: []
// [Asm] live_set: [v10]
// [Asm] move_origin: []
// [Asm] defs: [v49]
// [Asm] live_set: [v49]
// [Asm] move_origin: [v10]
// [Asm] defined: v49 is X
// [Asm] defs: [v51]
// [Asm] live_set: [v51]
// [Asm] move_origin: [v49]
// [Asm] defined: v51 is X
// [Asm] defs: []
// [Asm] live_set: [v51]
// [Asm] move_origin: []
// [Asm] defs: [v39]
// [Asm] live_set: [v5, zero, v7, v8, v4, v6, s11, v9, v39, v3]
// [Asm] move_origin: [v37]
// [Asm] defined: v39 is X
// [Asm] defs: []
// [Asm] live_set: [v5, zero, v7, v8, v4, v6, s11, v9, v39, v3]
// [Asm] move_origin: []
// [Asm] defs: [a0]
// [Asm] live_set: [a0]
// [Asm] move_origin: [v51]
// [Asm] defined: a0 is X
// [Asm] defs: []
// [Asm] live_set: [a0]
// [Asm] move_origin: []
// [Asm] defs: []
// [Asm] live_set: []
// [Asm] move_origin: []
// [Asm] defs: [v12]
// [Asm] live_set: [v12, zero]
// [Asm] move_origin: []
// [Asm] defined: v12 is X
// [Asm] defs: [s11]
// [Asm] live_set: [v12, zero]
// [Asm] move_origin: []
// [Asm] defined: s11 is X
// [Asm] defs: []
// [Asm] live_set: [v12, zero]
// [Asm] move_origin: []
// [Asm] defs: []
// [Asm] live_set: [v12]
// [Asm] move_origin: []
// [Asm] defs: [v51]
// [Asm] live_set: [v51]
// [Asm] move_origin: [v12]
// [Asm] defined: v51 is X
// [Asm] defs: []
// [Asm] live_set: [v5, a0, v7, s11, v9, zero, v8, v4, v6, v3]
// [Asm] move_origin: []
// [Asm] defs: [a1]
// [Asm] live_set: [v5, a0, v7, a1, s11, v9, zero, v8, v4, v6, v3]
// [Asm] move_origin: [v3]
// [Asm] defined: a1 is X
// [Asm] defs: [a2]
// [Asm] live_set: [v5, a0, v7, a2, a1, s11, v9, zero, v8, v4, v6, v3]
// [Asm] move_origin: [v4]
// [Asm] defined: a2 is X
// [Asm] defs: [a3]
// [Asm] live_set: [v5, a0, v7, a2, a1, s11, a3, v9, zero, v8, v4, v6, v3]
// [Asm] move_origin: [v8]
// [Asm] defined: a3 is X
// [Asm] defs: [a4]
// [Asm] live_set: [v5, a0, v7, a2, a1, s11, a3, v9, zero, a4, v8, v4, v6, v3]
// [Asm] move_origin: [v9]
// [Asm] defined: a4 is X
// [Asm] defs: [a0, a1, a2, a3, a4, a5, a6, a7, t0, t1, t2, t3, t4, ft0, ft1, ft2, ft3, ft4, ft5, ft6, ft7, ft8, ft9, ft10, fa0, fa1, fa2, fa3, fa4, fa5, fa6, fa7]
// [Asm] live_set: [v5, zero, a0, v8, v7, v4, v6, s11, v9, v3]
// [Asm] move_origin: []
// [Asm] defined: a0 is X
// [Asm] defined: a1 is X
// [Asm] defined: a2 is X
// [Asm] defined: a3 is X
// [Asm] defined: a4 is X
// [Asm] defined: a5 is X
// [Asm] defined: a6 is X
// [Asm] defined: a7 is X
// [Asm] defined: t0 is X
// [Asm] defined: t1 is X
// [Asm] defined: t2 is X
// [Asm] defined: t3 is X
// [Asm] defined: t4 is X
// [Asm] defined: ft0 is F
// [Asm] defined: ft1 is F
// [Asm] defined: ft2 is F
// [Asm] defined: ft3 is F
// [Asm] defined: ft4 is F
// [Asm] defined: ft5 is F
// [Asm] defined: ft6 is F
// [Asm] defined: ft7 is F
// [Asm] defined: ft8 is F
// [Asm] defined: ft9 is F
// [Asm] defined: ft10 is F
// [Asm] defined: fa0 is F
// [Asm] defined: fa1 is F
// [Asm] defined: fa2 is F
// [Asm] defined: fa3 is F
// [Asm] defined: fa4 is F
// [Asm] defined: fa5 is F
// [Asm] defined: fa6 is F
// [Asm] defined: fa7 is F
// [Asm] defs: [v18]
// [Asm] live_set: [v5, v18, zero, v8, v7, v4, v6, s11, v9, v3]
// [Asm] move_origin: [a0]
// [Asm] defined: v18 is X
// [Asm] defs: []
// [Asm] live_set: [v5, v18, zero, v8, v7, v4, v6, s11, v9, v3]
// [Asm] move_origin: []
// [Asm] defs: [v19]
// [Asm] live_set: [v5, zero, v8, v7, v19, v4, v6, s11, v9, v3]
// [Asm] move_origin: [v18]
// [Asm] defined: v19 is X
// [Asm] defs: [v55]
// [Asm] live_set: [v5, zero, v42, v7, v8, v4, v6, s11, v9, v55, v3]
// [Asm] move_origin: []
// [Asm] defined: v55 is X
// [Asm] defs: [v45]
// [Asm] live_set: [v5, zero, v42, v45, v7, v8, v4, v6, s11, v9, v3]
// [Asm] move_origin: [v55]
// [Asm] defined: v45 is X
// [Asm] defs: []
// [Asm] live_set: [v5, zero, v42, v45, v7, v8, v4, v6, s11, v9, v3]
// [Asm] move_origin: []
// [Asm] defs: []
// [Asm] live_set: [v5, v21, zero, v7, v8, v4, v6, s11, v9, v3]
// [Asm] move_origin: []
// [Asm] defs: [a0]
// [Asm] live_set: [v5, zero, a0, v7, v8, v4, v6, s11, v9, v3]
// [Asm] move_origin: [v21]
// [Asm] defined: a0 is X
// [Asm] defs: [a1]
// [Asm] live_set: [v5, zero, a0, v7, v8, v4, v6, a1, s11, v9, v3]
// [Asm] move_origin: [v5]
// [Asm] defined: a1 is X
// [Asm] defs: [a0, a1, a2, a3, a4, a5, a6, a7, t0, t1, t2, t3, t4, ft0, ft1, ft2, ft3, ft4, ft5, ft6, ft7, ft8, ft9, ft10, fa0, fa1, fa2, fa3, fa4, fa5, fa6, fa7]
// [Asm] live_set: [v5, zero, a0, v7, v8, v4, v6, s11, v9, v3]
// [Asm] move_origin: []
// [Asm] defined: a0 is X
// [Asm] defined: a1 is X
// [Asm] defined: a2 is X
// [Asm] defined: a3 is X
// [Asm] defined: a4 is X
// [Asm] defined: a5 is X
// [Asm] defined: a6 is X
// [Asm] defined: a7 is X
// [Asm] defined: t0 is X
// [Asm] defined: t1 is X
// [Asm] defined: t2 is X
// [Asm] defined: t3 is X
// [Asm] defined: t4 is X
// [Asm] defined: ft0 is F
// [Asm] defined: ft1 is F
// [Asm] defined: ft2 is F
// [Asm] defined: ft3 is F
// [Asm] defined: ft4 is F
// [Asm] defined: ft5 is F
// [Asm] defined: ft6 is F
// [Asm] defined: ft7 is F
// [Asm] defined: ft8 is F
// [Asm] defined: ft9 is F
// [Asm] defined: ft10 is F
// [Asm] defined: fa0 is F
// [Asm] defined: fa1 is F
// [Asm] defined: fa2 is F
// [Asm] defined: fa3 is F
// [Asm] defined: fa4 is F
// [Asm] defined: fa5 is F
// [Asm] defined: fa6 is F
// [Asm] defined: fa7 is F
// [Asm] defs: [v23]
// [Asm] live_set: [v5, zero, v23, v7, v8, v4, v6, s11, v9, v3]
// [Asm] move_origin: [a0]
// [Asm] defined: v23 is X
// [Asm] defs: []
// [Asm] live_set: [v5, zero, v23, v7, v8, v4, v6, s11, v9, v3]
// [Asm] move_origin: []
// [Asm] defs: [v24]
// [Asm] live_set: [v5, zero, v7, v8, v4, v6, v24, s11, v9, v3]
// [Asm] move_origin: [v23]
// [Asm] defined: v24 is X
// [Asm] defs: [v46]
// [Asm] live_set: [v46, v5, zero, v42, v7, v8, v4, v6, s11, v9, v3]
// [Asm] move_origin: [v45]
// [Asm] defined: v46 is X
// [Asm] defs: [v28]
// [Asm] live_set: [v5, zero, v7, v8, v4, v6, s11, v28, v9, v3]
// [Asm] move_origin: [v27]
// [Asm] defined: v28 is X
// [Asm] graph G {
// [Asm]   graph [label="integer interference graph of aux.12705"];
// [Asm]   r0 [label="v20 ← a0", color=green];
// [Asm]   r46 [label="a0", color=blue];
// [Asm]   r38 [label="a2", color=blue];
// [Asm]   r33 [label="v2 ← a0", color=green];
// [Asm]   r9 [label="v9 ← s5", color=green];
// [Asm]   r26 [label="v41 ← a0", color=green];
// [Asm]   r47 [label="v12 ← a0", color=green];
// [Asm]   r6 [label="v4 ← s3", color=green];
// [Asm]   r44 [label="v49 ← a0", color=green];
// [Asm]   r13 [label="v24 ← a1", color=green];
// [Asm]   r53 [label="v18 ← a0", color=green];
// [Asm]   r42 [label="v10 ← a0", color=green];
// [Asm]   r4 [label="v7 ← s2", color=green];
// [Asm]   r29 [label="v14 ← a0", color=green];
// [Asm]   r35 [label="a5", color=blue];
// [Asm]   r56 [label="v46 ← a0", color=green];
// [Asm]   r7 [label="v6 ← s4", color=green];
// [Asm]   r10 [label="v3 ← s6", color=green];
// [Asm]   r8 [label="s11", color=blue];
// [Asm]   r5 [label="v19 ← a1", color=green];
// [Asm]   r36 [label="a4", color=blue];
// [Asm]   r54 [label="v55 ← a0", color=green];
// [Asm]   r24 [label="v15 ← a0", color=green];
// [Asm]   r15 [label="v27 ← a0", color=green];
// [Asm]   r32 [label="v37 ← a0", color=green];
// [Asm]   r49 [label="t1", color=blue];
// [Asm]   r43 [label="v54 ← a2", color=green];
// [Asm]   r31 [label="v60 ← a2", color=green];
// [Asm]   r39 [label="a1", color=blue];
// [Asm]   r17 [label="v30 ← a1", color=green];
// [Asm]   r52 [label="t4", color=blue];
// [Asm]   r12 [label="v13 ← a0", color=green];
// [Asm]   r48 [label="t0", color=blue];
// [Asm]   r37 [label="a6", color=blue];
// [Asm]   r20 [label="v28 ← a1", color=green];
// [Asm]   r23 [label="v42 ← a1", color=green];
// [Asm]   r3 [label="v8 ← s1", color=green];
// [Asm]   r27 [label="v40 ← a1", color=green];
// [Asm]   r40 [label="a3", color=blue];
// [Asm]   r1 [label="v5 ← s0", color=green];
// [Asm]   r41 [label="v16 ← a0", color=green];
// [Asm]   r28 [label="v34 ← a0", color=green];
// [Asm]   r11 [label="v21 ← a1", color=green];
// [Asm]   r34 [label="a7", color=blue];
// [Asm]   r22 [label="v45 ← a0", color=green];
// [Asm]   r14 [label="v66 ← a2", color=green];
// [Asm]   r50 [label="t2", color=blue];
// [Asm]   r51 [label="t3", color=blue];
// [Asm]   r30 [label="v11 ← a0", color=green];
// [Asm]   r45 [label="v51 ← a0", color=green];
// [Asm]   r25 [label="v39 ← a0", color=green];
// [Asm]   r55 [label="v23 ← a0", color=green];
// [Asm]   r2 [label="zero", color=blue];
// [Asm]   r16 [label="v61 ← a0", color=green];
// [Asm]   r18 [label="v33 ← a0", color=green];
// [Asm]   r19 [label="v29 ← a0", color=green];
// [Asm]   r21 [label="v17 ← a0", color=green];
// [Asm]   r3 -- r52;
// [Asm]   r2 -- r38;
// [Asm]   r2 -- r31;
// [Asm]   r6 -- r48;
// [Asm]   r10 -- r53;
// [Asm]   r9 -- r53;
// [Asm]   r1 -- r26;
// [Asm]   r3 -- r15;
// [Asm]   r4 -- r51;
// [Asm]   r3 -- r16;
// [Asm]   r3 -- r53;
// [Asm]   r8 -- r36;
// [Asm]   r2 -- r49;
// [Asm]   r7 -- r25;
// [Asm]   r23 -- r56;
// [Asm]   r3 -- r9;
// [Asm]   r3 -- r11;
// [Asm]   r4 -- r48;
// [Asm]   r9 -- r26;
// [Asm]   r2 -- r51;
// [Asm]   r2 -- r7;
// [Asm]   r3 -- r26;
// [Asm]   r3 -- r31;
// [Asm]   r2 -- r41;
// [Asm]   r7 -- r35;
// [Asm]   r7 -- r32;
// [Asm]   r17 -- r19;
// [Asm]   r1 -- r50;
// [Asm]   r0 -- r6;
// [Asm]   r3 -- r48;
// [Asm]   r9 -- r14;
// [Asm]   r8 -- r34;
// [Asm]   r3 -- r8;
// [Asm]   r9 -- r56;
// [Asm]   r1 -- r9;
// [Asm]   r26 -- r27;
// [Asm]   r5 -- r6;
// [Asm]   r8 -- r16;
// [Asm]   r1 -- r48;
// [Asm]   r2 -- r48;
// [Asm]   r10 -- r18;
// [Asm]   r3 -- r39;
// [Asm]   r10 -- r33;
// [Asm]   r9 -- r12;
// [Asm]   r8 -- r23;
// [Asm]   r10 -- r22;
// [Asm]   r1 -- r2;
// [Asm]   r4 -- r29;
// [Asm]   r3 -- r33;
// [Asm]   r2 -- r5;
// [Asm]   r2 -- r13;
// [Asm]   r1 -- r51;
// [Asm]   r3 -- r17;
// [Asm]   r1 -- r11;
// [Asm]   r39 -- r40;
// [Asm]   r1 -- r38;
// [Asm]   r1 -- r41;
// [Asm]   r6 -- r50;
// [Asm]   r3 -- r35;
// [Asm]   r2 -- r22;
// [Asm]   r1 -- r5;
// [Asm]   r8 -- r32;
// [Asm]   r1 -- r35;
// [Asm]   r6 -- r56;
// [Asm]   r9 -- r39;
// [Asm]   r6 -- r25;
// [Asm]   r4 -- r13;
// [Asm]   r36 -- r40;
// [Asm]   r3 -- r25;
// [Asm]   r2 -- r4;
// [Asm]   r6 -- r41;
// [Asm]   r1 -- r55;
// [Asm]   r9 -- r40;
// [Asm]   r7 -- r20;
// [Asm]   r2 -- r50;
// [Asm]   r6 -- r46;
// [Asm]   r6 -- r53;
// [Asm]   r9 -- r30;
// [Asm]   r33 -- r35;
// [Asm]   r4 -- r18;
// [Asm]   r2 -- r11;
// [Asm]   r8 -- r42;
// [Asm]   r8 -- r25;
// [Asm]   r10 -- r16;
// [Asm]   r3 -- r22;
// [Asm]   r23 -- r26;
// [Asm]   r6 -- r19;
// [Asm]   r7 -- r22;
// [Asm]   r9 -- r11;
// [Asm]   r4 -- r55;
// [Asm]   r7 -- r19;
// [Asm]   r2 -- r14;
// [Asm]   r38 -- r40;
// [Asm]   r9 -- r24;
// [Asm]   r10 -- r15;
// [Asm]   r13 -- r14;
// [Asm]   r33 -- r37;
// [Asm]   r8 -- r35;
// [Asm]   r8 -- r18;
// [Asm]   r9 -- r36;
// [Asm]   r3 -- r29;
// [Asm]   r7 -- r36;
// [Asm]   r23 -- r42;
// [Asm]   r4 -- r36;
// [Asm]   r4 -- r7;
// [Asm]   r6 -- r39;
// [Asm]   r10 -- r36;
// [Asm]   r9 -- r46;
// [Asm]   r6 -- r38;
// [Asm]   r10 -- r32;
// [Asm]   r4 -- r10;
// [Asm]   r3 -- r23;
// [Asm]   r2 -- r27;
// [Asm]   r7 -- r46;
// [Asm]   r9 -- r21;
// [Asm]   r6 -- r52;
// [Asm]   r1 -- r24;
// [Asm]   r36 -- r38;
// [Asm]   r9 -- r25;
// [Asm]   r4 -- r41;
// [Asm]   r6 -- r36;
// [Asm]   r1 -- r37;
// [Asm]   r2 -- r15;
// [Asm]   r5 -- r8;
// [Asm]   r34 -- r46;
// [Asm]   r3 -- r56;
// [Asm]   r7 -- r56;
// [Asm]   r1 -- r19;
// [Asm]   r1 -- r10;
// [Asm]   r4 -- r54;
// [Asm]   r10 -- r13;
// [Asm]   r10 -- r19;
// [Asm]   r3 -- r32;
// [Asm]   r6 -- r54;
// [Asm]   r1 -- r17;
// [Asm]   r9 -- r31;
// [Asm]   r2 -- r16;
// [Asm]   r42 -- r43;
// [Asm]   r4 -- r22;
// [Asm]   r3 -- r18;
// [Asm]   r9 -- r41;
// [Asm]   r4 -- r35;
// [Asm]   r1 -- r31;
// [Asm]   r2 -- r54;
// [Asm]   r4 -- r33;
// [Asm]   r10 -- r56;
// [Asm]   r10 -- r20;
// [Asm]   r3 -- r30;
// [Asm]   r9 -- r28;
// [Asm]   r2 -- r46;
// [Asm]   r3 -- r13;
// [Asm]   r6 -- r18;
// [Asm]   r6 -- r10;
// [Asm]   r4 -- r28;
// [Asm]   r3 -- r40;
// [Asm]   r3 -- r10;
// [Asm]   r4 -- r12;
// [Asm]   r3 -- r27;
// [Asm]   r8 -- r29;
// [Asm]   r5 -- r7;
// [Asm]   r0 -- r11;
// [Asm]   r8 -- r11;
// [Asm]   r3 -- r7;
// [Asm]   r10 -- r25;
// [Asm]   r1 -- r6;
// [Asm]   r4 -- r49;
// [Asm]   r10 -- r35;
// [Asm]   r7 -- r54;
// [Asm]   r2 -- r23;
// [Asm]   r6 -- r32;
// [Asm]   r10 -- r17;
// [Asm]   r4 -- r16;
// [Asm]   r7 -- r52;
// [Asm]   r6 -- r11;
// [Asm]   r4 -- r5;
// [Asm]   r8 -- r56;
// [Asm]   r6 -- r49;
// [Asm]   r1 -- r23;
// [Asm]   r6 -- r14;
// [Asm]   r1 -- r53;
// [Asm]   r9 -- r29;
// [Asm]   r8 -- r19;
// [Asm]   r1 -- r15;
// [Asm]   r4 -- r20;
// [Asm]   r6 -- r16;
// [Asm]   r33 -- r39;
// [Asm]   r10 -- r41;
// [Asm]   r4 -- r30;
// [Asm]   r2 -- r55;
// [Asm]   r10 -- r27;
// [Asm]   r6 -- r12;
// [Asm]   r6 -- r24;
// [Asm]   r1 -- r39;
// [Asm]   r9 -- r51;
// [Asm]   r8 -- r54;
// [Asm]   r2 -- r28;
// [Asm]   r2 -- r29;
// [Asm]   r7 -- r37;
// [Asm]   r6 -- r37;
// [Asm]   r4 -- r11;
// [Asm]   r10 -- r28;
// [Asm]   r9 -- r34;
// [Asm]   r9 -- r38;
// [Asm]   r8 -- r52;
// [Asm]   r0 -- r8;
// [Asm]   r7 -- r33;
// [Asm]   r9 -- r33;
// [Asm]   r6 -- r28;
// [Asm]   r10 -- r23;
// [Asm]   r22 -- r23;
// [Asm]   r3 -- r55;
// [Asm]   r7 -- r11;
// [Asm]   r9 -- r37;
// [Asm]   r7 -- r39;
// [Asm]   r9 -- r16;
// [Asm]   r9 -- r32;
// [Asm]   r4 -- r39;
// [Asm]   r3 -- r36;
// [Asm]   r12 -- r14;
// [Asm]   r9 -- r19;
// [Asm]   r7 -- r50;
// [Asm]   r3 -- r54;
// [Asm]   r1 -- r3;
// [Asm]   r0 -- r7;
// [Asm]   r9 -- r54;
// [Asm]   r10 -- r21;
// [Asm]   r9 -- r50;
// [Asm]   r4 -- r52;
// [Asm]   r33 -- r38;
// [Asm]   r4 -- r19;
// [Asm]   r4 -- r53;
// [Asm]   r8 -- r31;
// [Asm]   r7 -- r51;
// [Asm]   r2 -- r32;
// [Asm]   r33 -- r40;
// [Asm]   r8 -- r51;
// [Asm]   r4 -- r34;
// [Asm]   r6 -- r35;
// [Asm]   r1 -- r30;
// [Asm]   r5 -- r10;
// [Asm]   r3 -- r6;
// [Asm]   r36 -- r46;
// [Asm]   r38 -- r46;
// [Asm]   r1 -- r52;
// [Asm]   r3 -- r37;
// [Asm]   r2 -- r37;
// [Asm]   r9 -- r17;
// [Asm]   r1 -- r16;
// [Asm]   r1 -- r33;
// [Asm]   r10 -- r40;
// [Asm]   r9 -- r49;
// [Asm]   r7 -- r27;
// [Asm]   r3 -- r5;
// [Asm]   r4 -- r31;
// [Asm]   r8 -- r12;
// [Asm]   r2 -- r34;
// [Asm]   r8 -- r24;
// [Asm]   r2 -- r25;
// [Asm]   r40 -- r46;
// [Asm]   r2 -- r6;
// [Asm]   r10 -- r38;
// [Asm]   r10 -- r12;
// [Asm]   r0 -- r9;
// [Asm]   r9 -- r23;
// [Asm]   r7 -- r38;
// [Asm]   r1 -- r40;
// [Asm]   r2 -- r12;
// [Asm]   r46 -- r52;
// [Asm]   r23 -- r54;
// [Asm]   r8 -- r48;
// [Asm]   r10 -- r31;
// [Asm]   r4 -- r56;
// [Asm]   r0 -- r1;
// [Asm]   r9 -- r20;
// [Asm]   r0 -- r10;
// [Asm]   r4 -- r25;
// [Asm]   r3 -- r49;
// [Asm]   r2 -- r36;
// [Asm]   r6 -- r55;
// [Asm]   r17 -- r31;
// [Asm]   r6 -- r23;
// [Asm]   r0 -- r4;
// [Asm]   r3 -- r46;
// [Asm]   r4 -- r14;
// [Asm]   r8 -- r30;
// [Asm]   r46 -- r50;
// [Asm]   r3 -- r19;
// [Asm]   r7 -- r29;
// [Asm]   r2 -- r26;
// [Asm]   r1 -- r8;
// [Asm]   r4 -- r23;
// [Asm]   r3 -- r38;
// [Asm]   r1 -- r34;
// [Asm]   r8 -- r27;
// [Asm]   r7 -- r24;
// [Asm]   r8 -- r9;
// [Asm]   r6 -- r33;
// [Asm]   r6 -- r30;
// [Asm]   r1 -- r22;
// [Asm]   r2 -- r52;
// [Asm]   r33 -- r36;
// [Asm]   r46 -- r51;
// [Asm]   r10 -- r29;
// [Asm]   r1 -- r13;
// [Asm]   r10 -- r48;
// [Asm]   r7 -- r48;
// [Asm]   r6 -- r22;
// [Asm]   r7 -- r49;
// [Asm]   r8 -- r20;
// [Asm]   r8 -- r47;
// [Asm]   r6 -- r20;
// [Asm]   r10 -- r51;
// [Asm]   r9 -- r52;
// [Asm]   r3 -- r50;
// [Asm]   r7 -- r17;
// [Asm]   r8 -- r41;
// [Asm]   r6 -- r27;
// [Asm]   r2 -- r40;
// [Asm]   r4 -- r15;
// [Asm]   r39 -- r46;
// [Asm]   r12 -- r13;
// [Asm]   r8 -- r53;
// [Asm]   r3 -- r21;
// [Asm]   r5 -- r9;
// [Asm]   r8 -- r15;
// [Asm]   r0 -- r3;
// [Asm]   r4 -- r32;
// [Asm]   r1 -- r29;
// [Asm]   r7 -- r15;
// [Asm]   r10 -- r11;
// [Asm]   r3 -- r20;
// [Asm]   r0 -- r5;
// [Asm]   r35 -- r46;
// [Asm]   r1 -- r25;
// [Asm]   r10 -- r46;
// [Asm]   r7 -- r41;
// [Asm]   r2 -- r17;
// [Asm]   r8 -- r10;
// [Asm]   r2 -- r30;
// [Asm]   r8 -- r26;
// [Asm]   r10 -- r54;
// [Asm]   r7 -- r16;
// [Asm]   r9 -- r48;
// [Asm]   r7 -- r18;
// [Asm]   r2 -- r35;
// [Asm]   r2 -- r9;
// [Asm]   r4 -- r6;
// [Asm]   r7 -- r12;
// [Asm]   r9 -- r13;
// [Asm]   r7 -- r14;
// [Asm]   r1 -- r54;
// [Asm]   r8 -- r50;
// [Asm]   r2 -- r39;
// [Asm]   r46 -- r49;
// [Asm]   r2 -- r20;
// [Asm]   r6 -- r21;
// [Asm]   r4 -- r38;
// [Asm]   r37 -- r46;
// [Asm]   r1 -- r12;
// [Asm]   r7 -- r21;
// [Asm]   r9 -- r27;
// [Asm]   r7 -- r40;
// [Asm]   r10 -- r26;
// [Asm]   r1 -- r4;
// [Asm]   r1 -- r7;
// [Asm]   r1 -- r18;
// [Asm]   r1 -- r56;
// [Asm]   r30 -- r31;
// [Asm]   r6 -- r29;
// [Asm]   r2 -- r10;
// [Asm]   r7 -- r53;
// [Asm]   r1 -- r20;
// [Asm]   r4 -- r27;
// [Asm]   r3 -- r24;
// [Asm]   r4 -- r40;
// [Asm]   r3 -- r51;
// [Asm]   r3 -- r34;
// [Asm]   r16 -- r17;
// [Asm]   r9 -- r18;
// [Asm]   r46 -- r48;
// [Asm]   r1 -- r46;
// [Asm]   r4 -- r21;
// [Asm]   r6 -- r13;
// [Asm]   r10 -- r49;
// [Asm]   r7 -- r34;
// [Asm]   r2 -- r33;
// [Asm]   r7 -- r55;
// [Asm]   r10 -- r37;
// [Asm]   r8 -- r17;
// [Asm]   r3 -- r4;
// [Asm]   r0 -- r2;
// [Asm]   r1 -- r21;
// [Asm]   r8 -- r37;
// [Asm]   r7 -- r10;
// [Asm]   r2 -- r47;
// [Asm]   r2 -- r8;
// [Asm]   r1 -- r27;
// [Asm]   r6 -- r31;
// [Asm]   r8 -- r39;
// [Asm]   r10 -- r30;
// [Asm]   r8 -- r22;
// [Asm]   r4 -- r50;
// [Asm]   r8 -- r21;
// [Asm]   r4 -- r8;
// [Asm]   r9 -- r10;
// [Asm]   r1 -- r49;
// [Asm]   r2 -- r24;
// [Asm]   r8 -- r14;
// [Asm]   r7 -- r8;
// [Asm]   r10 -- r55;
// [Asm]   r4 -- r9;
// [Asm]   r2 -- r53;
// [Asm]   r6 -- r7;
// [Asm]   r6 -- r9;
// [Asm]   r17 -- r18;
// [Asm]   r4 -- r24;
// [Asm]   r6 -- r15;
// [Asm]   r9 -- r35;
// [Asm]   r9 -- r15;
// [Asm]   r2 -- r18;
// [Asm]   r4 -- r37;
// [Asm]   r36 -- r39;
// [Asm]   r3 -- r12;
// [Asm]   r7 -- r26;
// [Asm]   r1 -- r32;
// [Asm]   r7 -- r13;
// [Asm]   r6 -- r51;
// [Asm]   r8 -- r55;
// [Asm]   r3 -- r28;
// [Asm]   r7 -- r30;
// [Asm]   r8 -- r38;
// [Asm]   r8 -- r33;
// [Asm]   r7 -- r9;
// [Asm]   r6 -- r26;
// [Asm]   r10 -- r34;
// [Asm]   r6 -- r40;
// [Asm]   r8 -- r49;
// [Asm]   r1 -- r28;
// [Asm]   r7 -- r28;
// [Asm]   r6 -- r8;
// [Asm]   r33 -- r34;
// [Asm]   r6 -- r34;
// [Asm]   r8 -- r28;
// [Asm]   r9 -- r22;
// [Asm]   r10 -- r50;
// [Asm]   r4 -- r46;
// [Asm]   r8 -- r13;
// [Asm]   r2 -- r56;
// [Asm]   r8 -- r40;
// [Asm]   r10 -- r52;
// [Asm]   r10 -- r39;
// [Asm]   r3 -- r41;
// [Asm]   r6 -- r17;
// [Asm]   r3 -- r14;
// [Asm]   r9 -- r55;
// [Asm]   r7 -- r31;
// [Asm]   r23 -- r43;
// [Asm]   r4 -- r17;
// [Asm]   r38 -- r39;
// [Asm]   r17 -- r30;
// [Asm]   r7 -- r23;
// [Asm]   r1 -- r36;
// [Asm]   r1 -- r14;
// [Asm]   r4 -- r26;
// [Asm]   r2 -- r19;
// [Asm]   r2 -- r3;
// [Asm]   r10 -- r24;
// [Asm]   r8 -- r46;
// [Asm]   r17 -- r28;
// [Asm]   r19 -- r20;
// [Asm]   r10 -- r14;
// [Asm]   comment = "0:v20-> 1:v5-> 2:zero-> 3:v8-> 4:v7-> 5:v19-> 6:v4-> 7:v6-> 8:s11-> 9:v9-> 10:v3-> 11:v21-> 12:v13-> 13:v24-> 14:v66-> 15:v27-> 16:v61-> 17:v30-> 18:v33-> 19:v29-> 20:v28-> 28:v34-> 30:v11-> 31:v60-> 22:v45-> 23:v42-> 26:v41-> 27:v40-> 54:v55-> 56:v46-> 24:v15-> 25:v39-> 29:v14-> 32:v37-> 33:v2-> 34:a7-> 35:a5-> 46:a0-> 36:a4-> 38:a2-> 39:a1-> 40:a3-> 37:a6-> 48:t0-> 49:t1-> 50:t2-> 51:t3-> 52:t4-> 41:v16-> 53:v18-> 55:v23-> 21:v17-> 42:v10-> 43:v54-> 47:v12-> 44:v49-> 45:v51"
// [Asm]   comment = "v20<-a0;v2<-a0;v9<-s5;v41<-a0;v12<-a0;v4<-s3;v49<-a0;v24<-a1;v18<-a0;v10<-a0;v7<-s2;v14<-a0;v46<-a0;v6<-s4;v3<-s6;v19<-a1;v55<-a0;v15<-a0;v27<-a0;v37<-a0;v54<-a2;v60<-a2;v30<-a1;v13<-a0;v28<-a1;v42<-a1;v8<-s1;v40<-a1;v5<-s0;v16<-a0;v34<-a0;v21<-a1;v45<-a0;v66<-a2;v11<-a0;v51<-a0;v39<-a0;v23<-a0;v61<-a0;v33<-a0;v29<-a0;v17<-a0;"
// [Asm] }
// [Asm] 
// [Asm] graph G {
// [Asm]   graph [label="float interference graph of aux.12705"];
// [Asm]   r0 [label="ft0", color=blue];
// [Asm]   r3 [label="ft3", color=blue];
// [Asm]   r9 [label="ft9", color=blue];
// [Asm]   r6 [label="ft6", color=blue];
// [Asm]   r13 [label="fa2", color=blue];
// [Asm]   r4 [label="ft4", color=blue];
// [Asm]   r1 [label="ft1", color=blue];
// [Asm]   r11 [label="fa0", color=blue];
// [Asm]   r7 [label="ft7", color=blue];
// [Asm]   r10 [label="ft10", color=blue];
// [Asm]   r14 [label="fa3", color=blue];
// [Asm]   r8 [label="ft8", color=blue];
// [Asm]   r5 [label="ft5", color=blue];
// [Asm]   r15 [label="fa4", color=blue];
// [Asm]   r2 [label="ft2", color=blue];
// [Asm]   r16 [label="fa5", color=blue];
// [Asm]   r18 [label="fa7", color=blue];
// [Asm]   r17 [label="fa6", color=blue];
// [Asm]   r12 [label="fa1", color=blue];
// [Asm]   comment = "0:ft0-> 1:ft1-> 2:ft2-> 3:ft3-> 4:ft4-> 5:ft5-> 6:ft6-> 7:ft7-> 8:ft8-> 9:ft9-> 10:ft10-> 11:fa0-> 12:fa1-> 13:fa2-> 14:fa3-> 15:fa4-> 16:fa5-> 17:fa6-> 18:fa7"
// [Asm]   comment = ""
// [Asm] }
// [Asm] 
// [Asm] subst   bne v34, zero, .aux.12705_21 ->   bne a0, zero, .aux.12705_21
// [Asm] subst   lw v20, 0(v19) ->   lw a0, 0(a1)
// [Asm] subst   lw v21, 4(v19) ->   lw a1, 4(a1)
// [Asm] subst   bne v20, zero, .aux.12705_32 ->   bne a0, zero, .aux.12705_32
// [Asm] subst   addi v13, s11, -8 ->   addi a0, s11, -8
// [Asm] subst   andi s11, v13, -8 ->   andi s11, a0, -8
// [Asm] subst   li v66, 1 ->   li a2, 1
// [Asm] subst   sw v66, 0(v13) ->   sw a2, 0(a0)
// [Asm] subst   sw v24, 4(v13) ->   sw a1, 4(a0)
// [Asm] subst   j .aux.12705_33 ->   j .aux.12705_33
// [Asm] subst   blt v30, v6, .aux.12705_28 ->   blt a1, s4, .aux.12705_28
// [Asm] subst   bne v46, zero, .aux.12705_6 ->   bne a0, zero, .aux.12705_6
// [Asm] subst   li v61, 1 ->   li a0, 1
// [Asm] subst   j .aux.12705_29 ->   j .aux.12705_29
// [Asm] subst   blt v7, v42, .aux.12705_13 ->   blt s2, a1, .aux.12705_13
// [Asm] subst   lw v29, 0(v28) ->   lw a0, 0(a1)
// [Asm] subst   lw v30, 4(v28) ->   lw a1, 4(a1)
// [Asm] subst   bne v29, zero, .aux.12705_19 ->   bne a0, zero, .aux.12705_19
// [Asm] subst   mv v17, zero ->   mv a0, zero
// [Asm] subst   mv v45, zero ->   mv a0, zero
// [Asm] subst   addi v15, s11, -8 ->   addi a0, s11, -8
// [Asm] subst   andi s11, v15, -8 ->   andi s11, a0, -8
// [Asm] subst   sw zero, 0(v15) ->   sw zero, 0(a0)
// [Asm] subst   sw zero, 4(v15) ->   sw zero, 4(a0)
// [Asm] subst   lw v41, 0(v40) ->   lw a0, 0(a1)
// [Asm] subst   lw v42, 4(v40) ->   lw a1, 4(a1)
// [Asm] subst   bne v41, zero, .aux.12705_4 ->   bne a0, zero, .aux.12705_4
// [Asm] subst   mv v17, zero ->   mv a0, zero
// [Asm] subst   j .aux.12705_17 ->   j .aux.12705_17
// [Asm] subst   addi v14, s11, -8 ->   addi a0, s11, -8
// [Asm] subst   andi s11, v14, -8 ->   andi s11, a0, -8
// [Asm] subst   sw zero, 0(v14) ->   sw zero, 0(a0)
// [Asm] subst   sw zero, 4(v14) ->   sw zero, 4(a0)
// [Asm] subst   mv v40, v39 ->   mv a1, a0
// [Asm] subst   addi v11, s11, -8 ->   addi a0, s11, -8
// [Asm] subst   andi s11, v11, -8 ->   andi s11, a0, -8
// [Asm] subst   li v60, 1 ->   li a2, 1
// [Asm] subst   sw v60, 0(v11) ->   sw a2, 0(a0)
// [Asm] subst   sw v30, 4(v11) ->   sw a1, 4(a0)
// [Asm] subst   mv v33, zero ->   mv a0, zero
// [Asm] subst   mv v3, a1 ->   mv s6, a1
// [Asm] subst   mv v4, a2 ->   mv s3, a2
// [Asm] subst   mv v5, a3 ->   mv s0, a3
// [Asm] subst   mv v6, a4 ->   mv s4, a4
// [Asm] subst   mv v7, a5 ->   mv s2, a5
// [Asm] subst   mv v8, a6 ->   mv s1, a6
// [Asm] subst   mv v9, a7 ->   mv s5, a7
// [Asm] subst   mv v16, zero ->   mv a0, zero
// [Asm] subst   j .aux.12705_2 ->   j .aux.12705_2
// [Asm] subst   addi v10, s11, -8 ->   addi a0, s11, -8
// [Asm] subst   andi s11, v10, -8 ->   andi s11, a0, -8
// [Asm] subst   li v54, 1 ->   li a2, 1
// [Asm] subst   sw v54, 0(v10) ->   sw a2, 0(a0)
// [Asm] subst   sw v42, 4(v10) ->   sw a1, 4(a0)
// [Asm] subst   j .aux.12705_8 ->   j .aux.12705_8
// [Asm] subst   j .aux.12705_23 ->   j .aux.12705_23
// [Asm] subst   ret ->   ret
// [Asm] subst   addi v12, s11, -8 ->   addi a0, s11, -8
// [Asm] subst   andi s11, v12, -8 ->   andi s11, a0, -8
// [Asm] subst   sw zero, 0(v12) ->   sw zero, 0(a0)
// [Asm] subst   sw zero, 4(v12) ->   sw zero, 4(a0)
// [Asm] subst   mv a1, v3 ->   mv a1, s6
// [Asm] subst   mv a2, v4 ->   mv a2, s3
// [Asm] subst   mv a3, v8 ->   mv a3, s1
// [Asm] subst   mv a4, v9 ->   mv a4, s5
// [Asm] subst   call aux.12699 ->   call aux.12699
// [Asm] subst   mv v19, v18 ->   mv a1, a0
// [Asm] subst   li v55, 1 ->   li a0, 1
// [Asm] subst   j .aux.12705_14 ->   j .aux.12705_14
// [Asm] subst   mv a0, v21 ->   mv a0, a1
// [Asm] subst   mv a1, v5 ->   mv a1, s0
// [Asm] subst   call aux.12700 ->   call aux.12700
// [Asm] subst   mv v24, v23 ->   mv a1, a0
// [Asm] subst   mv v28, v27 ->   mv a1, a0
// [Asm] pre_assigned_registers: FnParam(fref=f9, fpref=$f.1) -> v3, Self(fref=f9) -> v0, FnParam(fref=f9, fpref=$f.0) -> v2, Insn(iref=%0) -> v4
// [Asm] defs: []
// [Asm] live_set: [a1, a0]
// [Asm] move_origin: []
// [Asm] defs: [v2]
// [Asm] live_set: [a1, v2]
// [Asm] move_origin: [a0]
// [Asm] defined: v2 is X
// [Asm] defs: [v3]
// [Asm] live_set: [v3, v2]
// [Asm] move_origin: [a1]
// [Asm] defined: v3 is X
// [Asm] defs: [v4]
// [Asm] live_set: [v4]
// [Asm] move_origin: []
// [Asm] defined: v4 is X
// [Asm] defs: [a0]
// [Asm] live_set: [a0]
// [Asm] move_origin: [v4]
// [Asm] defined: a0 is X
// [Asm] defs: []
// [Asm] live_set: [a0]
// [Asm] move_origin: []
// [Asm] defs: []
// [Asm] live_set: []
// [Asm] move_origin: []
// [Asm] graph G {
// [Asm]   graph [label="integer interference graph of add.12706"];
// [Asm]   r0 [label="v2 ← a0", color=green];
// [Asm]   r4 [label="a0", color=blue];
// [Asm]   r1 [label="a1", color=blue];
// [Asm]   r3 [label="v4 ← a0", color=green];
// [Asm]   r2 [label="v3 ← a1", color=green];
// [Asm]   r0 -- r1;
// [Asm]   r0 -- r2;
// [Asm]   comment = "0:v2-> 1:a1-> 2:v3-> 3:v4-> 4:a0"
// [Asm]   comment = "v2<-a0;v4<-a0;v3<-a1;"
// [Asm] }
// [Asm] 
// [Asm] graph G {
// [Asm]   graph [label="float interference graph of add.12706"];
// [Asm]   comment = ""
// [Asm]   comment = ""
// [Asm] }
// [Asm] 
// [Asm] subst   add v4, v2, v3 ->   add a0, a0, a1
// [Asm] subst   ret ->   ret
// [Asm] pre_assigned_registers: Insn(iref=%3) -> v9, FnParam(fref=f0, fpref=$f.1) -> v3, FnParam(fref=f0, fpref=$f.2) -> v4, Mem(fref=f0, mref=m1) -> v6, Self(fref=f0) -> v0, BlockParam(bref=b3, bpref=$b.0) -> v13, Mem(fref=f0, mref=m0) -> v5, Insn(iref=%2) -> v12, Insn(iref=%1) -> v8, FnParam(fref=f0, fpref=$f.0) -> v2, Insn(iref=%5) -> v11, Insn(iref=%0) -> v7, Insn(iref=%4) -> v10
// [Asm] skipping Op(ty=Bool, op=Eq, args=[Insn(iref=%0), FnParam(fref=f0, fpref=$f.1)])
// [Asm] defs: [v9]
// [Asm] live_set: [v4, s11, v9, v7]
// [Asm] move_origin: []
// [Asm] defined: v9 is X
// [Asm] defs: []
// [Asm] live_set: [s11, v7]
// [Asm] move_origin: []
// [Asm] defs: [v6]
// [Asm] live_set: [v6, v7]
// [Asm] move_origin: []
// [Asm] defined: v6 is X
// [Asm] defs: [s11]
// [Asm] live_set: [v6, v7]
// [Asm] move_origin: []
// [Asm] defined: s11 is X
// [Asm] defs: [v16]
// [Asm] live_set: [v6, v16, v7]
// [Asm] move_origin: []
// [Asm] defined: v16 is X
// [Asm] defs: []
// [Asm] live_set: [v6, v7]
// [Asm] move_origin: []
// [Asm] defs: []
// [Asm] live_set: [v6]
// [Asm] move_origin: []
// [Asm] defs: [v13]
// [Asm] live_set: [v13]
// [Asm] move_origin: [v6]
// [Asm] defined: v13 is X
// [Asm] defs: [v5]
// [Asm] live_set: [v5, zero]
// [Asm] move_origin: []
// [Asm] defined: v5 is X
// [Asm] defs: [s11]
// [Asm] live_set: [v5, zero]
// [Asm] move_origin: []
// [Asm] defined: s11 is X
// [Asm] defs: []
// [Asm] live_set: [v5, zero]
// [Asm] move_origin: []
// [Asm] defs: []
// [Asm] live_set: [v5]
// [Asm] move_origin: []
// [Asm] defs: [v13]
// [Asm] live_set: [v13]
// [Asm] move_origin: [v5]
// [Asm] defined: v13 is X
// [Asm] defs: []
// [Asm] live_set: [v13]
// [Asm] move_origin: []
// [Asm] defs: []
// [Asm] live_set: [a2, a1, s11, zero, a0]
// [Asm] move_origin: []
// [Asm] defs: [v2]
// [Asm] live_set: [a2, a1, s11, zero]
// [Asm] move_origin: [a0]
// [Asm] defined: v2 is X
// [Asm] defs: [v3]
// [Asm] live_set: [a2, s11, zero, v3]
// [Asm] move_origin: [a1]
// [Asm] defined: v3 is X
// [Asm] defs: [v4]
// [Asm] live_set: [v4, s11, zero, v3]
// [Asm] move_origin: [a2]
// [Asm] defined: v4 is X
// [Asm] defs: [v7]
// [Asm] live_set: [v3, v4, s11, zero, v7]
// [Asm] move_origin: []
// [Asm] defined: v7 is X
// [Asm] defs: []
// [Asm] live_set: [v4, s11, zero, v7]
// [Asm] move_origin: []
// [Asm] defs: [a0]
// [Asm] live_set: [a0]
// [Asm] move_origin: [v13]
// [Asm] defined: a0 is X
// [Asm] defs: []
// [Asm] live_set: [a0]
// [Asm] move_origin: []
// [Asm] defs: []
// [Asm] live_set: []
// [Asm] move_origin: []
// [Asm] graph G {
// [Asm]   graph [label="integer interference graph of aux.12697"];
// [Asm]   r0 [label="v9 ← a0", color=green];
// [Asm]   r5 [label="v16 ← a1", color=green];
// [Asm]   r3 [label="v7 ← a2", color=green];
// [Asm]   r2 [label="s11", color=blue];
// [Asm]   r9 [label="v2 ← a0", color=green];
// [Asm]   r6 [label="v13 ← a0", color=green];
// [Asm]   r13 [label="a0", color=blue];
// [Asm]   r4 [label="v6 ← a0", color=green];
// [Asm]   r1 [label="v4 ← a1", color=green];
// [Asm]   r11 [label="a1", color=blue];
// [Asm]   r7 [label="v5 ← a0", color=green];
// [Asm]   r10 [label="a2", color=blue];
// [Asm]   r12 [label="v3 ← a0", color=green];
// [Asm]   r8 [label="zero", color=blue];
// [Asm]   r0 -- r1;
// [Asm]   r9 -- r11;
// [Asm]   r3 -- r4;
// [Asm]   r9 -- r10;
// [Asm]   r1 -- r12;
// [Asm]   r4 -- r5;
// [Asm]   r2 -- r7;
// [Asm]   r0 -- r2;
// [Asm]   r1 -- r8;
// [Asm]   r2 -- r4;
// [Asm]   r2 -- r9;
// [Asm]   r10 -- r12;
// [Asm]   r0 -- r3;
// [Asm]   r7 -- r8;
// [Asm]   r1 -- r3;
// [Asm]   r2 -- r3;
// [Asm]   r3 -- r5;
// [Asm]   r2 -- r12;
// [Asm]   r2 -- r8;
// [Asm]   r8 -- r12;
// [Asm]   r8 -- r9;
// [Asm]   r3 -- r12;
// [Asm]   r3 -- r8;
// [Asm]   r1 -- r2;
// [Asm]   comment = "0:v9-> 1:v4-> 2:s11-> 3:v7-> 8:zero-> 12:v3-> 4:v6-> 5:v16-> 7:v5-> 9:v2-> 10:a2-> 11:a1-> 6:v13-> 13:a0"
// [Asm]   comment = "v9<-a0;v16<-a1;v7<-a2;v2<-a0;v13<-a0;v6<-a0;v4<-a1;v5<-a0;v3<-a0;"
// [Asm] }
// [Asm] 
// [Asm] graph G {
// [Asm]   graph [label="float interference graph of aux.12697"];
// [Asm]   comment = ""
// [Asm]   comment = ""
// [Asm] }
// [Asm] 
// [Asm] subst   addi v9, v7, 1 ->   addi a0, a2, 1
// [Asm] subst   sw v9, 0(v4) ->   sw a0, 0(a1)
// [Asm] subst   addi v6, s11, -8 ->   addi a0, s11, -8
// [Asm] subst   andi s11, v6, -8 ->   andi s11, a0, -8
// [Asm] subst   li v16, 1 ->   li a1, 1
// [Asm] subst   sw v16, 0(v6) ->   sw a1, 0(a0)
// [Asm] subst   sw v7, 4(v6) ->   sw a2, 4(a0)
// [Asm] subst   addi v5, s11, -8 ->   addi a0, s11, -8
// [Asm] subst   andi s11, v5, -8 ->   andi s11, a0, -8
// [Asm] subst   sw zero, 0(v5) ->   sw zero, 0(a0)
// [Asm] subst   sw zero, 4(v5) ->   sw zero, 4(a0)
// [Asm] subst   j .aux.12697_3 ->   j .aux.12697_3
// [Asm] subst   mv v3, a1 ->   mv a0, a1
// [Asm] subst   mv v4, a2 ->   mv a1, a2
// [Asm] subst   lw v7, 0(v4) ->   lw a2, 0(a1)
// [Asm] subst   beq v7, v3, .aux.12697_1 ->   beq a2, a0, .aux.12697_1
// [Asm] subst   ret ->   ret
// [Asm] pre_assigned_registers: Self(fref=f26) -> v0, Insn(iref=%0) -> v2
// [Asm] defs: []
// [Asm] live_set: []
// [Asm] move_origin: []
// [Asm] defs: []
// [Asm] live_set: []
// [Asm] move_origin: []
// [Asm] defs: [a0, a1, a2, a3, a4, a5, a6, a7, t0, t1, t2, t3, t4, ft0, ft1, ft2, ft3, ft4, ft5, ft6, ft7, ft8, ft9, ft10, fa0, fa1, fa2, fa3, fa4, fa5, fa6, fa7]
// [Asm] live_set: [a0]
// [Asm] move_origin: []
// [Asm] defined: a0 is X
// [Asm] defined: a1 is X
// [Asm] defined: a2 is X
// [Asm] defined: a3 is X
// [Asm] defined: a4 is X
// [Asm] defined: a5 is X
// [Asm] defined: a6 is X
// [Asm] defined: a7 is X
// [Asm] defined: t0 is X
// [Asm] defined: t1 is X
// [Asm] defined: t2 is X
// [Asm] defined: t3 is X
// [Asm] defined: t4 is X
// [Asm] defined: ft0 is F
// [Asm] defined: ft1 is F
// [Asm] defined: ft2 is F
// [Asm] defined: ft3 is F
// [Asm] defined: ft4 is F
// [Asm] defined: ft5 is F
// [Asm] defined: ft6 is F
// [Asm] defined: ft7 is F
// [Asm] defined: ft8 is F
// [Asm] defined: ft9 is F
// [Asm] defined: ft10 is F
// [Asm] defined: fa0 is F
// [Asm] defined: fa1 is F
// [Asm] defined: fa2 is F
// [Asm] defined: fa3 is F
// [Asm] defined: fa4 is F
// [Asm] defined: fa5 is F
// [Asm] defined: fa6 is F
// [Asm] defined: fa7 is F
// [Asm] defs: [v2]
// [Asm] live_set: [v2]
// [Asm] move_origin: [a0]
// [Asm] defined: v2 is X
// [Asm] defs: []
// [Asm] live_set: [v2]
// [Asm] move_origin: []
// [Asm] defs: [a0]
// [Asm] live_set: [a0]
// [Asm] move_origin: [v2]
// [Asm] defined: a0 is X
// [Asm] defs: []
// [Asm] live_set: [a0]
// [Asm] move_origin: []
// [Asm] defs: []
// [Asm] live_set: []
// [Asm] move_origin: []
// [Asm] graph G {
// [Asm]   graph [label="integer interference graph of T$start"];
// [Asm]   r0 [label="a0", color=blue];
// [Asm]   r5 [label="a5", color=blue];
// [Asm]   r3 [label="a3", color=blue];
// [Asm]   r2 [label="a2", color=blue];
// [Asm]   r9 [label="t1", color=blue];
// [Asm]   r6 [label="a6", color=blue];
// [Asm]   r13 [label="v2 ← a0", color=green];
// [Asm]   r4 [label="a4", color=blue];
// [Asm]   r1 [label="a1", color=blue];
// [Asm]   r11 [label="t3", color=blue];
// [Asm]   r7 [label="a7", color=blue];
// [Asm]   r10 [label="t2", color=blue];
// [Asm]   r12 [label="t4", color=blue];
// [Asm]   r8 [label="t0", color=blue];
// [Asm]   r0 -- r3;
// [Asm]   r0 -- r4;
// [Asm]   r0 -- r8;
// [Asm]   r0 -- r9;
// [Asm]   r0 -- r1;
// [Asm]   r0 -- r7;
// [Asm]   r0 -- r10;
// [Asm]   r0 -- r12;
// [Asm]   r0 -- r11;
// [Asm]   r0 -- r5;
// [Asm]   r0 -- r6;
// [Asm]   r0 -- r2;
// [Asm]   comment = "0:a0-> 1:a1-> 2:a2-> 3:a3-> 4:a4-> 5:a5-> 6:a6-> 7:a7-> 8:t0-> 9:t1-> 10:t2-> 11:t3-> 12:t4-> 13:v2"
// [Asm]   comment = "v2<-a0;"
// [Asm] }
// [Asm] 
// [Asm] graph G {
// [Asm]   graph [label="float interference graph of T$start"];
// [Asm]   r0 [label="ft0", color=blue];
// [Asm]   r3 [label="ft3", color=blue];
// [Asm]   r9 [label="ft9", color=blue];
// [Asm]   r6 [label="ft6", color=blue];
// [Asm]   r13 [label="fa2", color=blue];
// [Asm]   r4 [label="ft4", color=blue];
// [Asm]   r1 [label="ft1", color=blue];
// [Asm]   r11 [label="fa0", color=blue];
// [Asm]   r7 [label="ft7", color=blue];
// [Asm]   r10 [label="ft10", color=blue];
// [Asm]   r14 [label="fa3", color=blue];
// [Asm]   r8 [label="ft8", color=blue];
// [Asm]   r5 [label="ft5", color=blue];
// [Asm]   r15 [label="fa4", color=blue];
// [Asm]   r2 [label="ft2", color=blue];
// [Asm]   r16 [label="fa5", color=blue];
// [Asm]   r18 [label="fa7", color=blue];
// [Asm]   r17 [label="fa6", color=blue];
// [Asm]   r12 [label="fa1", color=blue];
// [Asm]   comment = "0:ft0-> 1:ft1-> 2:ft2-> 3:ft3-> 4:ft4-> 5:ft5-> 6:ft6-> 7:ft7-> 8:ft8-> 9:ft9-> 10:ft10-> 11:fa0-> 12:fa1-> 13:fa2-> 14:fa3-> 15:fa4-> 16:fa5-> 17:fa6-> 18:fa7"
// [Asm]   comment = ""
// [Asm] }
// [Asm] 
// [Asm] subst   call main.12696 ->   call main.12696
// [Asm] subst   ret ->   ret
// [Asm] pre_assigned_registers: Insn(iref=%3) -> v9, FnParam(fref=f1, fpref=$f.1) -> v3, FnParam(fref=f1, fpref=$f.0) -> v2, FnParam(fref=f1, fpref=$f.2) -> v4, BlockParam(bref=b3, bpref=$b.0) -> v13, Insn(iref=%2) -> v12, Insn(iref=%1) -> v8, Mem(fref=f1, mref=m0) -> v5, Self(fref=f1) -> v0, Mem(fref=f1, mref=m1) -> v6, Insn(iref=%5) -> v11, Insn(iref=%0) -> v7, Insn(iref=%4) -> v10
// [Asm] skipping Op(ty=Bool, op=Eq, args=[Insn(iref=%0), FnParam(fref=f1, fpref=$f.1)])
// [Asm] defs: []
// [Asm] live_set: [a2, a1, s11, zero, a0]
// [Asm] move_origin: []
// [Asm] defs: [v2]
// [Asm] live_set: [a2, a1, s11, zero]
// [Asm] move_origin: [a0]
// [Asm] defined: v2 is X
// [Asm] defs: [v3]
// [Asm] live_set: [a2, s11, zero, v3]
// [Asm] move_origin: [a1]
// [Asm] defined: v3 is X
// [Asm] defs: [v4]
// [Asm] live_set: [v4, s11, zero, v3]
// [Asm] move_origin: [a2]
// [Asm] defined: v4 is X
// [Asm] defs: [v7]
// [Asm] live_set: [v3, v4, s11, zero, v7]
// [Asm] move_origin: []
// [Asm] defined: v7 is X
// [Asm] defs: []
// [Asm] live_set: [v4, s11, zero, v7]
// [Asm] move_origin: []
// [Asm] defs: [a0]
// [Asm] live_set: [a0]
// [Asm] move_origin: [v13]
// [Asm] defined: a0 is X
// [Asm] defs: []
// [Asm] live_set: [a0]
// [Asm] move_origin: []
// [Asm] defs: []
// [Asm] live_set: []
// [Asm] move_origin: []
// [Asm] defs: [v9]
// [Asm] live_set: [v4, s11, v9, v7]
// [Asm] move_origin: []
// [Asm] defined: v9 is X
// [Asm] defs: []
// [Asm] live_set: [s11, v7]
// [Asm] move_origin: []
// [Asm] defs: [v6]
// [Asm] live_set: [v6, v7]
// [Asm] move_origin: []
// [Asm] defined: v6 is X
// [Asm] defs: [s11]
// [Asm] live_set: [v6, v7]
// [Asm] move_origin: []
// [Asm] defined: s11 is X
// [Asm] defs: [v16]
// [Asm] live_set: [v6, v16, v7]
// [Asm] move_origin: []
// [Asm] defined: v16 is X
// [Asm] defs: []
// [Asm] live_set: [v6, v7]
// [Asm] move_origin: []
// [Asm] defs: []
// [Asm] live_set: [v6]
// [Asm] move_origin: []
// [Asm] defs: [v13]
// [Asm] live_set: [v13]
// [Asm] move_origin: [v6]
// [Asm] defined: v13 is X
// [Asm] defs: [v5]
// [Asm] live_set: [v5, zero]
// [Asm] move_origin: []
// [Asm] defined: v5 is X
// [Asm] defs: [s11]
// [Asm] live_set: [v5, zero]
// [Asm] move_origin: []
// [Asm] defined: s11 is X
// [Asm] defs: []
// [Asm] live_set: [v5, zero]
// [Asm] move_origin: []
// [Asm] defs: []
// [Asm] live_set: [v5]
// [Asm] move_origin: []
// [Asm] defs: [v13]
// [Asm] live_set: [v13]
// [Asm] move_origin: [v5]
// [Asm] defined: v13 is X
// [Asm] defs: []
// [Asm] live_set: [v13]
// [Asm] move_origin: []
// [Asm] graph G {
// [Asm]   graph [label="integer interference graph of aux.12698"];
// [Asm]   r0 [label="v2 ← a0", color=green];
// [Asm]   r5 [label="v3 ← a0", color=green];
// [Asm]   r3 [label="s11", color=blue];
// [Asm]   r2 [label="a1", color=blue];
// [Asm]   r9 [label="v9 ← a0", color=green];
// [Asm]   r6 [label="v4 ← a1", color=green];
// [Asm]   r13 [label="v5 ← a0", color=green];
// [Asm]   r4 [label="zero", color=blue];
// [Asm]   r1 [label="a2", color=blue];
// [Asm]   r11 [label="v16 ← a1", color=green];
// [Asm]   r7 [label="v7 ← a2", color=green];
// [Asm]   r10 [label="v6 ← a0", color=green];
// [Asm]   r12 [label="v13 ← a0", color=green];
// [Asm]   r8 [label="a0", color=blue];
// [Asm]   r6 -- r7;
// [Asm]   r6 -- r9;
// [Asm]   r0 -- r1;
// [Asm]   r3 -- r9;
// [Asm]   r4 -- r13;
// [Asm]   r4 -- r7;
// [Asm]   r5 -- r6;
// [Asm]   r5 -- r7;
// [Asm]   r3 -- r4;
// [Asm]   r4 -- r5;
// [Asm]   r3 -- r7;
// [Asm]   r0 -- r2;
// [Asm]   r1 -- r5;
// [Asm]   r0 -- r4;
// [Asm]   r0 -- r3;
// [Asm]   r7 -- r9;
// [Asm]   r4 -- r6;
// [Asm]   r3 -- r13;
// [Asm]   r3 -- r6;
// [Asm]   r7 -- r10;
// [Asm]   r3 -- r5;
// [Asm]   r10 -- r11;
// [Asm]   r7 -- r11;
// [Asm]   r3 -- r10;
// [Asm]   comment = "0:v2-> 1:a2-> 2:a1-> 3:s11-> 4:zero-> 5:v3-> 6:v4-> 7:v7-> 9:v9-> 10:v6-> 11:v16-> 13:v5-> 8:a0-> 12:v13"
// [Asm]   comment = "v2<-a0;v3<-a0;v9<-a0;v4<-a1;v5<-a0;v16<-a1;v7<-a2;v6<-a0;v13<-a0;"
// [Asm] }
// [Asm] 
// [Asm] graph G {
// [Asm]   graph [label="float interference graph of aux.12698"];
// [Asm]   comment = ""
// [Asm]   comment = ""
// [Asm] }
// [Asm] 
// [Asm] subst   addi v5, s11, -8 ->   addi a0, s11, -8
// [Asm] subst   andi s11, v5, -8 ->   andi s11, a0, -8
// [Asm] subst   sw zero, 0(v5) ->   sw zero, 0(a0)
// [Asm] subst   sw zero, 4(v5) ->   sw zero, 4(a0)
// [Asm] subst   j .aux.12698_3 ->   j .aux.12698_3
// [Asm] subst   mv v3, a1 ->   mv a0, a1
// [Asm] subst   mv v4, a2 ->   mv a1, a2
// [Asm] subst   lw v7, 0(v4) ->   lw a2, 0(a1)
// [Asm] subst   beq v7, v3, .aux.12698_1 ->   beq a2, a0, .aux.12698_1
// [Asm] subst   addi v9, v7, 1 ->   addi a0, a2, 1
// [Asm] subst   sw v9, 0(v4) ->   sw a0, 0(a1)
// [Asm] subst   addi v6, s11, -8 ->   addi a0, s11, -8
// [Asm] subst   andi s11, v6, -8 ->   andi s11, a0, -8
// [Asm] subst   li v16, 1 ->   li a1, 1
// [Asm] subst   sw v16, 0(v6) ->   sw a1, 0(a0)
// [Asm] subst   sw v7, 4(v6) ->   sw a2, 4(a0)
// [Asm] subst   ret ->   ret
// [Asm] pre_assigned_registers: BlockParam(bref=b2, bpref=$b.0) -> v10, Insn(iref=%9) -> v8, BlockParam(bref=b2, bpref=$b.1) -> v11, Insn(iref=%8) -> v17, Insn(iref=%10) -> v9, Self(fref=f10) -> v0, Mem(fref=f10, mref=m3) -> v5, BlockParam(bref=b2, bpref=$b.2) -> v12, Insn(iref=%5) -> v16, Insn(iref=%0) -> v6, Insn(iref=%4) -> v15, Insn(iref=%3) -> v14, Mem(fref=f10, mref=m0) -> v2, Insn(iref=%7) -> v19, BlockParam(bref=b5, bpref=$b.0) -> v20, Mem(fref=f10, mref=m2) -> v4, Insn(iref=%2) -> v13, Insn(iref=%1) -> v7, Mem(fref=f10, mref=m1) -> v3, Insn(iref=%6) -> v18
// [Asm] skipping Op(ty=Bool, op=Eq, args=[Insn(iref=%3), Int32(val=0)])
// [Asm] defs: [a0]
// [Asm] live_set: [a0]
// [Asm] move_origin: [v20]
// [Asm] defined: a0 is X
// [Asm] defs: []
// [Asm] live_set: [a0]
// [Asm] move_origin: []
// [Asm] defs: []
// [Asm] live_set: []
// [Asm] move_origin: []
// [Asm] defs: []
// [Asm] live_set: [v12, zero]
// [Asm] move_origin: []
// [Asm] defs: [a0]
// [Asm] live_set: [zero, a0]
// [Asm] move_origin: [v12]
// [Asm] defined: a0 is X
// [Asm] defs: [a0, a1, a2, a3, a4, a5, a6, a7, t0, t1, t2, t3, t4, ft0, ft1, ft2, ft3, ft4, ft5, ft6, ft7, ft8, ft9, ft10, fa0, fa1, fa2, fa3, fa4, fa5, fa6, fa7]
// [Asm] live_set: [zero, a0]
// [Asm] move_origin: []
// [Asm] defined: a0 is X
// [Asm] defined: a1 is X
// [Asm] defined: a2 is X
// [Asm] defined: a3 is X
// [Asm] defined: a4 is X
// [Asm] defined: a5 is X
// [Asm] defined: a6 is X
// [Asm] defined: a7 is X
// [Asm] defined: t0 is X
// [Asm] defined: t1 is X
// [Asm] defined: t2 is X
// [Asm] defined: t3 is X
// [Asm] defined: t4 is X
// [Asm] defined: ft0 is F
// [Asm] defined: ft1 is F
// [Asm] defined: ft2 is F
// [Asm] defined: ft3 is F
// [Asm] defined: ft4 is F
// [Asm] defined: ft5 is F
// [Asm] defined: ft6 is F
// [Asm] defined: ft7 is F
// [Asm] defined: ft8 is F
// [Asm] defined: ft9 is F
// [Asm] defined: ft10 is F
// [Asm] defined: fa0 is F
// [Asm] defined: fa1 is F
// [Asm] defined: fa2 is F
// [Asm] defined: fa3 is F
// [Asm] defined: fa4 is F
// [Asm] defined: fa5 is F
// [Asm] defined: fa6 is F
// [Asm] defined: fa7 is F
// [Asm] defs: [v18]
// [Asm] live_set: [zero]
// [Asm] move_origin: [a0]
// [Asm] defined: v18 is X
// [Asm] defs: []
// [Asm] live_set: [zero]
// [Asm] move_origin: []
// [Asm] defs: []
// [Asm] live_set: [zero]
// [Asm] move_origin: []
// [Asm] defs: [v21]
// [Asm] live_set: [v21, zero]
// [Asm] move_origin: []
// [Asm] defined: v21 is X
// [Asm] defs: [a0]
// [Asm] live_set: [zero, a0]
// [Asm] move_origin: [v21]
// [Asm] defined: a0 is X
// [Asm] defs: [a0, a1, a2, a3, a4, a5, a6, a7, t0, t1, t2, t3, t4, ft0, ft1, ft2, ft3, ft4, ft5, ft6, ft7, ft8, ft9, ft10, fa0, fa1, fa2, fa3, fa4, fa5, fa6, fa7]
// [Asm] live_set: [zero, a0]
// [Asm] move_origin: []
// [Asm] defined: a0 is X
// [Asm] defined: a1 is X
// [Asm] defined: a2 is X
// [Asm] defined: a3 is X
// [Asm] defined: a4 is X
// [Asm] defined: a5 is X
// [Asm] defined: a6 is X
// [Asm] defined: a7 is X
// [Asm] defined: t0 is X
// [Asm] defined: t1 is X
// [Asm] defined: t2 is X
// [Asm] defined: t3 is X
// [Asm] defined: t4 is X
// [Asm] defined: ft0 is F
// [Asm] defined: ft1 is F
// [Asm] defined: ft2 is F
// [Asm] defined: ft3 is F
// [Asm] defined: ft4 is F
// [Asm] defined: ft5 is F
// [Asm] defined: ft6 is F
// [Asm] defined: ft7 is F
// [Asm] defined: ft8 is F
// [Asm] defined: ft9 is F
// [Asm] defined: ft10 is F
// [Asm] defined: fa0 is F
// [Asm] defined: fa1 is F
// [Asm] defined: fa2 is F
// [Asm] defined: fa3 is F
// [Asm] defined: fa4 is F
// [Asm] defined: fa5 is F
// [Asm] defined: fa6 is F
// [Asm] defined: fa7 is F
// [Asm] defs: [v19]
// [Asm] live_set: [zero]
// [Asm] move_origin: [a0]
// [Asm] defined: v19 is X
// [Asm] defs: []
// [Asm] live_set: [zero]
// [Asm] move_origin: []
// [Asm] defs: [v20]
// [Asm] live_set: [v20]
// [Asm] move_origin: [zero]
// [Asm] defined: v20 is X
// [Asm] defs: [s10]
// [Asm] live_set: [v11, v10, zero, a0, v12]
// [Asm] move_origin: [v10]
// [Asm] defined: s10 is X
// [Asm] defs: [v28]
// [Asm] live_set: [v11, v10, zero, a0, v12, v28]
// [Asm] move_origin: []
// [Asm] defined: v28 is X
// [Asm] defs: []
// [Asm] live_set: [v11, v10, zero, a0, v12, v28]
// [Asm] move_origin: []
// [Asm] defs: [a0, a1, a2, a3, a4, a5, a6, a7, t0, t1, t2, t3, t4, ft0, ft1, ft2, ft3, ft4, ft5, ft6, ft7, ft8, ft9, ft10, fa0, fa1, fa2, fa3, fa4, fa5, fa6, fa7]
// [Asm] live_set: [v11, v10, zero, a0, v12]
// [Asm] move_origin: []
// [Asm] defined: a0 is X
// [Asm] defined: a1 is X
// [Asm] defined: a2 is X
// [Asm] defined: a3 is X
// [Asm] defined: a4 is X
// [Asm] defined: a5 is X
// [Asm] defined: a6 is X
// [Asm] defined: a7 is X
// [Asm] defined: t0 is X
// [Asm] defined: t1 is X
// [Asm] defined: t2 is X
// [Asm] defined: t3 is X
// [Asm] defined: t4 is X
// [Asm] defined: ft0 is F
// [Asm] defined: ft1 is F
// [Asm] defined: ft2 is F
// [Asm] defined: ft3 is F
// [Asm] defined: ft4 is F
// [Asm] defined: ft5 is F
// [Asm] defined: ft6 is F
// [Asm] defined: ft7 is F
// [Asm] defined: ft8 is F
// [Asm] defined: ft9 is F
// [Asm] defined: ft10 is F
// [Asm] defined: fa0 is F
// [Asm] defined: fa1 is F
// [Asm] defined: fa2 is F
// [Asm] defined: fa3 is F
// [Asm] defined: fa4 is F
// [Asm] defined: fa5 is F
// [Asm] defined: fa6 is F
// [Asm] defined: fa7 is F
// [Asm] defs: [v13]
// [Asm] live_set: [v11, v10, zero, v13, v12]
// [Asm] move_origin: [a0]
// [Asm] defined: v13 is X
// [Asm] defs: []
// [Asm] live_set: [v11, v10, zero, v13, v12]
// [Asm] move_origin: []
// [Asm] defs: [v14]
// [Asm] live_set: [v11, v14, v10, zero, v13, v12]
// [Asm] move_origin: []
// [Asm] defined: v14 is X
// [Asm] defs: [v15]
// [Asm] live_set: [v11, v14, v10, zero, v12, v15]
// [Asm] move_origin: []
// [Asm] defined: v15 is X
// [Asm] defs: []
// [Asm] live_set: [v11, v12, v15, v10, zero]
// [Asm] move_origin: []
// [Asm] defs: []
// [Asm] live_set: [zero, s11]
// [Asm] move_origin: []
// [Asm] defs: [v2]
// [Asm] live_set: [zero, v2]
// [Asm] move_origin: []
// [Asm] defined: v2 is X
// [Asm] defs: [s11]
// [Asm] live_set: [zero, s11, v2]
// [Asm] move_origin: []
// [Asm] defined: s11 is X
// [Asm] defs: []
// [Asm] live_set: [zero, s11, v2]
// [Asm] move_origin: []
// [Asm] defs: [v3]
// [Asm] live_set: [v3, zero, v2]
// [Asm] move_origin: []
// [Asm] defined: v3 is X
// [Asm] defs: [s11]
// [Asm] live_set: [v3, zero, s11, v2]
// [Asm] move_origin: []
// [Asm] defined: s11 is X
// [Asm] defs: []
// [Asm] live_set: [v3, zero, s11, v2]
// [Asm] move_origin: []
// [Asm] defs: [v4]
// [Asm] live_set: [v3, zero, v4, v2]
// [Asm] move_origin: []
// [Asm] defined: v4 is X
// [Asm] defs: [s11]
// [Asm] live_set: [v3, zero, v4, s11, v2]
// [Asm] move_origin: []
// [Asm] defined: s11 is X
// [Asm] defs: [v33]
// [Asm] live_set: [v3, zero, v4, s11, v33, v2]
// [Asm] move_origin: []
// [Asm] defined: v33 is X
// [Asm] defs: []
// [Asm] live_set: [v3, zero, v4, s11, v2]
// [Asm] move_origin: []
// [Asm] defs: [v34]
// [Asm] live_set: [v3, zero, v4, s11, v34, v2]
// [Asm] move_origin: []
// [Asm] defined: v34 is X
// [Asm] defs: []
// [Asm] live_set: [v3, zero, v4, s11, v2]
// [Asm] move_origin: []
// [Asm] defs: [v35]
// [Asm] live_set: [v3, zero, v35, v4, s11, v2]
// [Asm] move_origin: []
// [Asm] defined: v35 is X
// [Asm] defs: []
// [Asm] live_set: [v3, zero, v4, s11, v2]
// [Asm] move_origin: []
// [Asm] defs: [v36]
// [Asm] live_set: [v3, zero, v36, v4, s11, v2]
// [Asm] move_origin: []
// [Asm] defined: v36 is X
// [Asm] defs: []
// [Asm] live_set: [v3, zero, v4, s11, v2]
// [Asm] move_origin: []
// [Asm] defs: [v37]
// [Asm] live_set: [v3, zero, v4, v37, s11, v2]
// [Asm] move_origin: []
// [Asm] defined: v37 is X
// [Asm] defs: []
// [Asm] live_set: [v3, zero, v4, s11, v2]
// [Asm] move_origin: []
// [Asm] defs: [v38]
// [Asm] live_set: [v3, zero, v4, v38, s11, v2]
// [Asm] move_origin: []
// [Asm] defined: v38 is X
// [Asm] defs: []
// [Asm] live_set: [v2, v4, s11, zero, v3]
// [Asm] move_origin: []
// [Asm] defs: []
// [Asm] live_set: [v4, s11, zero, v3]
// [Asm] move_origin: []
// [Asm] defs: []
// [Asm] live_set: [v4, s11, zero]
// [Asm] move_origin: []
// [Asm] defs: [v5]
// [Asm] live_set: [v4, v5, zero]
// [Asm] move_origin: []
// [Asm] defined: v5 is X
// [Asm] defs: [s11]
// [Asm] live_set: [v4, v5, zero]
// [Asm] move_origin: []
// [Asm] defined: s11 is X
// [Asm] defs: [v31]
// [Asm] live_set: [v4, v5, v31, zero]
// [Asm] move_origin: []
// [Asm] defined: v31 is X
// [Asm] defs: []
// [Asm] live_set: [v4, v5, zero]
// [Asm] move_origin: []
// [Asm] defs: [v10]
// [Asm] live_set: [v5, v10, zero]
// [Asm] move_origin: [v4]
// [Asm] defined: v10 is X
// [Asm] defs: [v11]
// [Asm] live_set: [v11, v10, zero]
// [Asm] move_origin: [v5]
// [Asm] defined: v11 is X
// [Asm] defs: [v12]
// [Asm] live_set: [v11, v10, v12, zero]
// [Asm] move_origin: [zero]
// [Asm] defined: v12 is X
// [Asm] defs: [s10]
// [Asm] live_set: [v11, v10, v15, v12, zero]
// [Asm] move_origin: [v11]
// [Asm] defined: s10 is X
// [Asm] defs: [v24]
// [Asm] live_set: [v11, v10, v24, v15, v12, zero]
// [Asm] move_origin: []
// [Asm] defined: v24 is X
// [Asm] defs: []
// [Asm] live_set: [v11, v10, v24, v15, v12, zero]
// [Asm] move_origin: []
// [Asm] defs: [a0]
// [Asm] live_set: [v11, v10, v24, v15, a0, zero]
// [Asm] move_origin: [v12]
// [Asm] defined: a0 is X
// [Asm] defs: [a1]
// [Asm] live_set: [v11, a1, v10, v24, zero, a0]
// [Asm] move_origin: [v15]
// [Asm] defined: a1 is X
// [Asm] defs: [a0, a1, a2, a3, a4, a5, a6, a7, t0, t1, t2, t3, t4, ft0, ft1, ft2, ft3, ft4, ft5, ft6, ft7, ft8, ft9, ft10, fa0, fa1, fa2, fa3, fa4, fa5, fa6, fa7]
// [Asm] live_set: [v11, v10, zero, a0]
// [Asm] move_origin: []
// [Asm] defined: a0 is X
// [Asm] defined: a1 is X
// [Asm] defined: a2 is X
// [Asm] defined: a3 is X
// [Asm] defined: a4 is X
// [Asm] defined: a5 is X
// [Asm] defined: a6 is X
// [Asm] defined: a7 is X
// [Asm] defined: t0 is X
// [Asm] defined: t1 is X
// [Asm] defined: t2 is X
// [Asm] defined: t3 is X
// [Asm] defined: t4 is X
// [Asm] defined: ft0 is F
// [Asm] defined: ft1 is F
// [Asm] defined: ft2 is F
// [Asm] defined: ft3 is F
// [Asm] defined: ft4 is F
// [Asm] defined: ft5 is F
// [Asm] defined: ft6 is F
// [Asm] defined: ft7 is F
// [Asm] defined: ft8 is F
// [Asm] defined: ft9 is F
// [Asm] defined: ft10 is F
// [Asm] defined: fa0 is F
// [Asm] defined: fa1 is F
// [Asm] defined: fa2 is F
// [Asm] defined: fa3 is F
// [Asm] defined: fa4 is F
// [Asm] defined: fa5 is F
// [Asm] defined: fa6 is F
// [Asm] defined: fa7 is F
// [Asm] defs: [v17]
// [Asm] live_set: [v11, v17, v10, zero]
// [Asm] move_origin: [a0]
// [Asm] defined: v17 is X
// [Asm] defs: []
// [Asm] live_set: [v11, v17, v10, zero]
// [Asm] move_origin: []
// [Asm] defs: []
// [Asm] live_set: [v11, v17, v10, zero]
// [Asm] move_origin: [v10]
// [Asm] defs: []
// [Asm] live_set: [v11, v17, v10, zero]
// [Asm] move_origin: [v11]
// [Asm] defs: [v12]
// [Asm] live_set: [v11, v10, v12, zero]
// [Asm] move_origin: [v17]
// [Asm] defined: v12 is X
// [Asm] defs: []
// [Asm] live_set: [v11, v10, v12, zero]
// [Asm] move_origin: []
// [Asm] graph G {
// [Asm]   graph [label="integer interference graph of main.12696"];
// [Asm]   r0 [label="a0", color=blue];
// [Asm]   r38 [label="v24 ← a2", color=green];
// [Asm]   r33 [label="v36 ← a3", color=green];
// [Asm]   r9 [label="t0", color=blue];
// [Asm]   r26 [label="v2 ← a0", color=green];
// [Asm]   r6 [label="a5", color=blue];
// [Asm]   r13 [label="t4", color=blue];
// [Asm]   r4 [label="a3", color=blue];
// [Asm]   r29 [label="v4 ← a1", color=green];
// [Asm]   r35 [label="v38 ← a3", color=green];
// [Asm]   r7 [label="a6", color=blue];
// [Asm]   r10 [label="t1", color=blue];
// [Asm]   r8 [label="a7", color=blue];
// [Asm]   r5 [label="a4", color=blue];
// [Asm]   r36 [label="v5 ← a0", color=green];
// [Asm]   r32 [label="v35 ← a3", color=green];
// [Asm]   r24 [label="v14 ← a0", color=green];
// [Asm]   r15 [label="v21 ← a0", color=green];
// [Asm]   r31 [label="v34 ← a3", color=green];
// [Asm]   r39 [label="v17 ← a0", color=green];
// [Asm]   r17 [label="v20 ← a0", color=green];
// [Asm]   r12 [label="t3", color=blue];
// [Asm]   r37 [label="v31 ← a2", color=green];
// [Asm]   r20 [label="v10 ← s1", color=green];
// [Asm]   r23 [label="v13 ← a1", color=green];
// [Asm]   r3 [label="a2", color=blue];
// [Asm]   r27 [label="s11", color=blue];
// [Asm]   r1 [label="zero", color=blue];
// [Asm]   r28 [label="v3 ← a2", color=green];
// [Asm]   r11 [label="t2", color=blue];
// [Asm]   r34 [label="v37 ← a3", color=green];
// [Asm]   r22 [label="v28 ← a1", color=green];
// [Asm]   r14 [label="v18 ← a0", color=green];
// [Asm]   r30 [label="v33 ← a3", color=green];
// [Asm]   r25 [label="v15 ← a1", color=green];
// [Asm]   r2 [label="a1", color=blue];
// [Asm]   r16 [label="v19 ← a0", color=green];
// [Asm]   r18 [label="s10", color=blue];
// [Asm]   r19 [label="v11 ← s0", color=green];
// [Asm]   r21 [label="v12 ← s2", color=green];
// [Asm]   r28 -- r34;
// [Asm]   r2 -- r20;
// [Asm]   r21 -- r24;
// [Asm]   r6 -- r21;
// [Asm]   r26 -- r33;
// [Asm]   r2 -- r38;
// [Asm]   r0 -- r13;
// [Asm]   r5 -- r21;
// [Asm]   r1 -- r12;
// [Asm]   r7 -- r21;
// [Asm]   r1 -- r26;
// [Asm]   r28 -- r32;
// [Asm]   r1 -- r37;
// [Asm]   r1 -- r30;
// [Asm]   r27 -- r29;
// [Asm]   r21 -- r38;
// [Asm]   r1 -- r4;
// [Asm]   r27 -- r36;
// [Asm]   r19 -- r38;
// [Asm]   r1 -- r7;
// [Asm]   r19 -- r39;
// [Asm]   r1 -- r18;
// [Asm]   r18 -- r25;
// [Asm]   r1 -- r19;
// [Asm]   r1 -- r10;
// [Asm]   r28 -- r30;
// [Asm]   r0 -- r25;
// [Asm]   r10 -- r19;
// [Asm]   r27 -- r32;
// [Asm]   r29 -- r31;
// [Asm]   r18 -- r21;
// [Asm]   r1 -- r20;
// [Asm]   r0 -- r22;
// [Asm]   r27 -- r28;
// [Asm]   r1 -- r16;
// [Asm]   r1 -- r33;
// [Asm]   r19 -- r21;
// [Asm]   r20 -- r36;
// [Asm]   r27 -- r34;
// [Asm]   r29 -- r36;
// [Asm]   r12 -- r19;
// [Asm]   r11 -- r19;
// [Asm]   r27 -- r30;
// [Asm]   r0 -- r6;
// [Asm]   r20 -- r23;
// [Asm]   r4 -- r21;
// [Asm]   r1 -- r31;
// [Asm]   r1 -- r9;
// [Asm]   r26 -- r28;
// [Asm]   r26 -- r27;
// [Asm]   r20 -- r22;
// [Asm]   r10 -- r20;
// [Asm]   r25 -- r38;
// [Asm]   r0 -- r2;
// [Asm]   r1 -- r21;
// [Asm]   r0 -- r9;
// [Asm]   r29 -- r33;
// [Asm]   r19 -- r22;
// [Asm]   r1 -- r27;
// [Asm]   r1 -- r2;
// [Asm]   r0 -- r38;
// [Asm]   r28 -- r33;
// [Asm]   r28 -- r29;
// [Asm]   r9 -- r20;
// [Asm]   r0 -- r1;
// [Asm]   r0 -- r10;
// [Asm]   r23 -- r24;
// [Asm]   r1 -- r11;
// [Asm]   r8 -- r21;
// [Asm]   r18 -- r20;
// [Asm]   r0 -- r11;
// [Asm]   r1 -- r38;
// [Asm]   r1 -- r6;
// [Asm]   r27 -- r35;
// [Asm]   r12 -- r21;
// [Asm]   r1 -- r5;
// [Asm]   r0 -- r4;
// [Asm]   r1 -- r35;
// [Asm]   r21 -- r22;
// [Asm]   r13 -- r21;
// [Asm]   r24 -- r25;
// [Asm]   r29 -- r35;
// [Asm]   r27 -- r31;
// [Asm]   r36 -- r37;
// [Asm]   r0 -- r18;
// [Asm]   r26 -- r34;
// [Asm]   r3 -- r19;
// [Asm]   r20 -- r24;
// [Asm]   r29 -- r32;
// [Asm]   r11 -- r20;
// [Asm]   r28 -- r31;
// [Asm]   r20 -- r39;
// [Asm]   r1 -- r8;
// [Asm]   r5 -- r20;
// [Asm]   r1 -- r34;
// [Asm]   r1 -- r23;
// [Asm]   r29 -- r30;
// [Asm]   r8 -- r19;
// [Asm]   r1 -- r22;
// [Asm]   r1 -- r32;
// [Asm]   r7 -- r20;
// [Asm]   r0 -- r21;
// [Asm]   r5 -- r19;
// [Asm]   r1 -- r15;
// [Asm]   r4 -- r20;
// [Asm]   r1 -- r13;
// [Asm]   r19 -- r24;
// [Asm]   r8 -- r20;
// [Asm]   r0 -- r19;
// [Asm]   r13 -- r20;
// [Asm]   r20 -- r25;
// [Asm]   r6 -- r20;
// [Asm]   r13 -- r19;
// [Asm]   r1 -- r28;
// [Asm]   r1 -- r39;
// [Asm]   r21 -- r23;
// [Asm]   r6 -- r19;
// [Asm]   r20 -- r38;
// [Asm]   r12 -- r20;
// [Asm]   r26 -- r35;
// [Asm]   r18 -- r19;
// [Asm]   r7 -- r19;
// [Asm]   r19 -- r23;
// [Asm]   r3 -- r21;
// [Asm]   r0 -- r3;
// [Asm]   r0 -- r8;
// [Asm]   r1 -- r29;
// [Asm]   r29 -- r37;
// [Asm]   r21 -- r25;
// [Asm]   r26 -- r30;
// [Asm]   r3 -- r20;
// [Asm]   r0 -- r5;
// [Asm]   r28 -- r35;
// [Asm]   r1 -- r25;
// [Asm]   r2 -- r21;
// [Asm]   r29 -- r34;
// [Asm]   r0 -- r12;
// [Asm]   r27 -- r33;
// [Asm]   r26 -- r29;
// [Asm]   r9 -- r19;
// [Asm]   r26 -- r31;
// [Asm]   r1 -- r14;
// [Asm]   r1 -- r36;
// [Asm]   r2 -- r19;
// [Asm]   r1 -- r3;
// [Asm]   r0 -- r7;
// [Asm]   r0 -- r20;
// [Asm]   r19 -- r25;
// [Asm]   r20 -- r21;
// [Asm]   r10 -- r21;
// [Asm]   r11 -- r21;
// [Asm]   r26 -- r32;
// [Asm]   r4 -- r19;
// [Asm]   r9 -- r21;
// [Asm]   r1 -- r24;
// [Asm]   r19 -- r20;
// [Asm]   comment = "0:a0-> 1:zero-> 2:a1-> 19:v11-> 20:v10-> 21:v12-> 38:v24-> 25:v15-> 18:s10-> 3:a2-> 4:a3-> 5:a4-> 6:a5-> 7:a6-> 8:a7-> 9:t0-> 10:t1-> 11:t2-> 12:t3-> 13:t4-> 22:v28-> 24:v14-> 23:v13-> 39:v17-> 36:v5-> 27:s11-> 29:v4-> 26:v2-> 28:v3-> 30:v33-> 31:v34-> 32:v35-> 33:v36-> 34:v37-> 35:v38-> 37:v31-> 14:v18-> 15:v21-> 16:v19-> 17:v20"
// [Asm]   comment = "v24<-a2;v36<-a3;v2<-a0;v4<-a1;v38<-a3;v5<-a0;v35<-a3;v14<-a0;v21<-a0;v34<-a3;v17<-a0;v20<-a0;v31<-a2;v10<-s1;v13<-a1;v3<-a2;v37<-a3;v28<-a1;v18<-a0;v33<-a3;v15<-a1;v19<-a0;v11<-s0;v12<-s2;"
// [Asm] }
// [Asm] 
// [Asm] graph G {
// [Asm]   graph [label="float interference graph of main.12696"];
// [Asm]   r0 [label="ft0", color=blue];
// [Asm]   r3 [label="ft3", color=blue];
// [Asm]   r9 [label="ft9", color=blue];
// [Asm]   r6 [label="ft6", color=blue];
// [Asm]   r13 [label="fa2", color=blue];
// [Asm]   r4 [label="ft4", color=blue];
// [Asm]   r1 [label="ft1", color=blue];
// [Asm]   r11 [label="fa0", color=blue];
// [Asm]   r7 [label="ft7", color=blue];
// [Asm]   r10 [label="ft10", color=blue];
// [Asm]   r14 [label="fa3", color=blue];
// [Asm]   r8 [label="ft8", color=blue];
// [Asm]   r5 [label="ft5", color=blue];
// [Asm]   r15 [label="fa4", color=blue];
// [Asm]   r2 [label="ft2", color=blue];
// [Asm]   r16 [label="fa5", color=blue];
// [Asm]   r18 [label="fa7", color=blue];
// [Asm]   r17 [label="fa6", color=blue];
// [Asm]   r12 [label="fa1", color=blue];
// [Asm]   comment = "0:ft0-> 1:ft1-> 2:ft2-> 3:ft3-> 4:ft4-> 5:ft5-> 6:ft6-> 7:ft7-> 8:ft8-> 9:ft9-> 10:ft10-> 11:fa0-> 12:fa1-> 13:fa2-> 14:fa3-> 15:fa4-> 16:fa5-> 17:fa6-> 18:fa7"
// [Asm]   comment = ""
// [Asm] }
// [Asm] 
// [Asm] subst   ret ->   ret
// [Asm] subst   mv a0, v12 ->   mv a0, s2
// [Asm] subst   call minimbt_print_int ->   call minimbt_print_int
// [Asm] subst   li v21, 10 ->   li a0, 10
// [Asm] subst   call minimbt_print_char ->   call minimbt_print_char
// [Asm] subst   mv v20, zero ->   mv a0, zero
// [Asm] subst   mv s10, v10 ->   mv s10, s1
// [Asm] subst   ld v28, 0(v10) ->   ld a1, 0(s1)
// [Asm] subst   jalr v28 ->   jalr a1
// [Asm] subst   mv v13, a0 ->   mv a1, a0
// [Asm] subst   lw v14, 0(v13) ->   lw a0, 0(a1)
// [Asm] subst   lw v15, 4(v13) ->   lw a1, 4(a1)
// [Asm] subst   bne v14, zero, .main.12696_4 ->   bne a0, zero, .main.12696_4
// [Asm] subst   addi v2, s11, -4 ->   addi a0, s11, -4
// [Asm] subst   andi s11, v2, -8 ->   andi s11, a0, -8
// [Asm] subst   sw zero, 0(v2) ->   sw zero, 0(a0)
// [Asm] subst   addi v3, s11, -4 ->   addi a2, s11, -4
// [Asm] subst   andi s11, v3, -8 ->   andi s11, a2, -8
// [Asm] subst   sw zero, 0(v3) ->   sw zero, 0(a2)
// [Asm] subst   addi v4, s11, -64 ->   addi a1, s11, -64
// [Asm] subst   andi s11, v4, -8 ->   andi s11, a1, -8
// [Asm] subst   la v33, aux.12707 ->   la a3, aux.12707
// [Asm] subst   sd v33, 0(v4) ->   sd a3, 0(a1)
// [Asm] subst   li v34, 100 ->   li a3, 100
// [Asm] subst   sd v34, 8(v4) ->   sd a3, 8(a1)
// [Asm] subst   li v35, 1000 ->   li a3, 1000
// [Asm] subst   sd v35, 16(v4) ->   sd a3, 16(a1)
// [Asm] subst   li v36, 1 ->   li a3, 1
// [Asm] subst   sd v36, 24(v4) ->   sd a3, 24(a1)
// [Asm] subst   li v37, 50 ->   li a3, 50
// [Asm] subst   sd v37, 32(v4) ->   sd a3, 32(a1)
// [Asm] subst   li v38, 1200 ->   li a3, 1200
// [Asm] subst   sd v38, 40(v4) ->   sd a3, 40(a1)
// [Asm] subst   sd v2, 48(v4) ->   sd a0, 48(a1)
// [Asm] subst   sd v3, 56(v4) ->   sd a2, 56(a1)
// [Asm] subst   addi v5, s11, -8 ->   addi a0, s11, -8
// [Asm] subst   andi s11, v5, -8 ->   andi s11, a0, -8
// [Asm] subst   la v31, add.12708 ->   la a2, add.12708
// [Asm] subst   sd v31, 0(v5) ->   sd a2, 0(a0)
// [Asm] subst   mv v10, v4 ->   mv s1, a1
// [Asm] subst   mv v11, v5 ->   mv s0, a0
// [Asm] subst   mv v12, zero ->   mv s2, zero
// [Asm] subst   mv s10, v11 ->   mv s10, s0
// [Asm] subst   ld v24, 0(v11) ->   ld a2, 0(s0)
// [Asm] subst   mv a0, v12 ->   mv a0, s2
// [Asm] subst   jalr v24 ->   jalr a2
// [Asm] subst   mv v12, v17 ->   mv s2, a0
// [Asm] subst   j .main.12696_2 ->   j .main.12696_2
// [Asm] pre_assigned_registers: Mem(fref=f2, mref=m7) -> v8, FnParam(fref=f2, fpref=$f.4) -> v6, BlockParam(bref=b3, bpref=$b.0) -> v23, Insn(iref=%9) -> v12, Self(fref=f2) -> v0, Insn(iref=%8) -> v15, Insn(iref=%10) -> v13, Insn(iref=%5) -> v21, Insn(iref=%4) -> v22, Insn(iref=%3) -> v20, Mem(fref=f2, mref=m0) -> v9, Insn(iref=%7) -> v11, Mem(fref=f2, mref=m6) -> v7, Insn(iref=%2) -> v19, FnParam(fref=f2, fpref=$f.1) -> v3, Insn(iref=%1) -> v18, Insn(iref=%11) -> v14, BlockParam(bref=b4, bpref=$b.0) -> v17, Insn(iref=%6) -> v10, FnParam(fref=f2, fpref=$f.0) -> v2, BlockParam(bref=b9, bpref=$b.0) -> v16, FnParam(fref=f2, fpref=$f.2) -> v4, FnParam(fref=f2, fpref=$f.3) -> v5
// [Asm] skipping Op(ty=Bool, op=Eq, args=[Insn(iref=%1), Int32(val=0)])
// [Asm] skipping Op(ty=Bool, op=Eq, args=[Insn(iref=%6), FnParam(fref=f2, fpref=$f.1)])
// [Asm] defs: [v18]
// [Asm] live_set: [v4, v6, v17, v18, s11, zero]
// [Asm] move_origin: []
// [Asm] defined: v18 is X
// [Asm] defs: [v19]
// [Asm] live_set: [v19, v4, v6, s11, v18, zero]
// [Asm] move_origin: []
// [Asm] defined: v19 is X
// [Asm] defs: []
// [Asm] live_set: [v19, v4, v6, s11]
// [Asm] move_origin: []
// [Asm] defs: []
// [Asm] live_set: [v4, v6, a0]
// [Asm] move_origin: []
// [Asm] defs: [a1]
// [Asm] live_set: [a1, v6, a0]
// [Asm] move_origin: [v4]
// [Asm] defined: a1 is X
// [Asm] defs: [a2]
// [Asm] live_set: [a2, a1, a0]
// [Asm] move_origin: [v6]
// [Asm] defined: a2 is X
// [Asm] defs: [a0, a1, a2, a3, a4, a5, a6, a7, t0, t1, t2, t3, t4, ft0, ft1, ft2, ft3, ft4, ft5, ft6, ft7, ft8, ft9, ft10, fa0, fa1, fa2, fa3, fa4, fa5, fa6, fa7]
// [Asm] live_set: [a0]
// [Asm] move_origin: []
// [Asm] defined: a0 is X
// [Asm] defined: a1 is X
// [Asm] defined: a2 is X
// [Asm] defined: a3 is X
// [Asm] defined: a4 is X
// [Asm] defined: a5 is X
// [Asm] defined: a6 is X
// [Asm] defined: a7 is X
// [Asm] defined: t0 is X
// [Asm] defined: t1 is X
// [Asm] defined: t2 is X
// [Asm] defined: t3 is X
// [Asm] defined: t4 is X
// [Asm] defined: ft0 is F
// [Asm] defined: ft1 is F
// [Asm] defined: ft2 is F
// [Asm] defined: ft3 is F
// [Asm] defined: ft4 is F
// [Asm] defined: ft5 is F
// [Asm] defined: ft6 is F
// [Asm] defined: ft7 is F
// [Asm] defined: ft8 is F
// [Asm] defined: ft9 is F
// [Asm] defined: ft10 is F
// [Asm] defined: fa0 is F
// [Asm] defined: fa1 is F
// [Asm] defined: fa2 is F
// [Asm] defined: fa3 is F
// [Asm] defined: fa4 is F
// [Asm] defined: fa5 is F
// [Asm] defined: fa6 is F
// [Asm] defined: fa7 is F
// [Asm] defs: [v22]
// [Asm] live_set: [v22]
// [Asm] move_origin: [a0]
// [Asm] defined: v22 is X
// [Asm] defs: []
// [Asm] live_set: [v22]
// [Asm] move_origin: []
// [Asm] defs: [v23]
// [Asm] live_set: [v23]
// [Asm] move_origin: [v22]
// [Asm] defined: v23 is X
// [Asm] defs: [v10]
// [Asm] live_set: [v5, v10, zero, v4, v6, s11, v3]
// [Asm] move_origin: []
// [Asm] defined: v10 is X
// [Asm] defs: []
// [Asm] live_set: [v4, v5, v6, v10, s11, zero]
// [Asm] move_origin: []
// [Asm] defs: [a0]
// [Asm] live_set: [a0]
// [Asm] move_origin: [v23]
// [Asm] defined: a0 is X
// [Asm] defs: []
// [Asm] live_set: [a0]
// [Asm] move_origin: []
// [Asm] defs: []
// [Asm] live_set: []
// [Asm] move_origin: []
// [Asm] defs: [v17]
// [Asm] live_set: [v4, v17, v6, s11, zero]
// [Asm] move_origin: [v16]
// [Asm] defined: v17 is X
// [Asm] defs: []
// [Asm] live_set: [zero, a0, a4, a2, a1, s11, a3]
// [Asm] move_origin: []
// [Asm] defs: [v2]
// [Asm] live_set: [a2, a1, s11, a3, zero, a4]
// [Asm] move_origin: [a0]
// [Asm] defined: v2 is X
// [Asm] defs: [v3]
// [Asm] live_set: [a2, s11, a3, zero, a4, v3]
// [Asm] move_origin: [a1]
// [Asm] defined: v3 is X
// [Asm] defs: [v4]
// [Asm] live_set: [v4, s11, a3, zero, a4, v3]
// [Asm] move_origin: [a2]
// [Asm] defined: v4 is X
// [Asm] defs: [v5]
// [Asm] live_set: [v4, v5, s11, zero, a4, v3]
// [Asm] move_origin: [a3]
// [Asm] defined: v5 is X
// [Asm] defs: [v6]
// [Asm] live_set: [v4, v5, v6, s11, zero, v3]
// [Asm] move_origin: [a4]
// [Asm] defined: v6 is X
// [Asm] defs: [v7]
// [Asm] live_set: [v4, v6, zero, v7]
// [Asm] move_origin: []
// [Asm] defined: v7 is X
// [Asm] defs: [s11]
// [Asm] live_set: [v4, v6, s11, zero, v7]
// [Asm] move_origin: []
// [Asm] defined: s11 is X
// [Asm] defs: []
// [Asm] live_set: [v4, v6, s11, zero, v7]
// [Asm] move_origin: []
// [Asm] defs: []
// [Asm] live_set: [v4, v6, s11, zero, v7]
// [Asm] move_origin: []
// [Asm] defs: [v16]
// [Asm] live_set: [v4, v16, v6, s11, zero]
// [Asm] move_origin: [v7]
// [Asm] defined: v16 is X
// [Asm] defs: []
// [Asm] live_set: [v4, v16, v6, s11, zero]
// [Asm] move_origin: []
// [Asm] defs: [v12]
// [Asm] live_set: [v5, v10, zero, v4, v6, s11, v12]
// [Asm] move_origin: []
// [Asm] defined: v12 is X
// [Asm] defs: []
// [Asm] live_set: [v10, zero, v4, v6, s11]
// [Asm] move_origin: []
// [Asm] defs: [v8]
// [Asm] live_set: [v10, zero, v8, v4, v6]
// [Asm] move_origin: []
// [Asm] defined: v8 is X
// [Asm] defs: [s11]
// [Asm] live_set: [v10, zero, v8, v4, v6, s11]
// [Asm] move_origin: []
// [Asm] defined: s11 is X
// [Asm] defs: [v31]
// [Asm] live_set: [v10, zero, v8, v4, v6, s11, v31]
// [Asm] move_origin: []
// [Asm] defined: v31 is X
// [Asm] defs: []
// [Asm] live_set: [v10, zero, v8, v4, v6, s11]
// [Asm] move_origin: []
// [Asm] defs: []
// [Asm] live_set: [v4, v6, s11, zero, v8]
// [Asm] move_origin: []
// [Asm] defs: [v16]
// [Asm] live_set: [v4, v16, v6, s11, zero]
// [Asm] move_origin: [v8]
// [Asm] defined: v16 is X
// [Asm] defs: [v9]
// [Asm] live_set: [v19, v9]
// [Asm] move_origin: []
// [Asm] defined: v9 is X
// [Asm] defs: [s11]
// [Asm] live_set: [v19, v9]
// [Asm] move_origin: []
// [Asm] defined: s11 is X
// [Asm] defs: [v26]
// [Asm] live_set: [v19, v9, v26]
// [Asm] move_origin: []
// [Asm] defined: v26 is X
// [Asm] defs: []
// [Asm] live_set: [v19, v9]
// [Asm] move_origin: []
// [Asm] defs: []
// [Asm] live_set: [v9]
// [Asm] move_origin: []
// [Asm] defs: [v23]
// [Asm] live_set: [v23]
// [Asm] move_origin: [v9]
// [Asm] defined: v23 is X
// [Asm] defs: []
// [Asm] live_set: [v23]
// [Asm] move_origin: []
// [Asm] graph G {
// [Asm]   graph [label="integer interference graph of aux.12699"];
// [Asm]   r0 [label="v18 ← a0", color=green];
// [Asm]   r9 [label="a2", color=blue];
// [Asm]   r26 [label="v7 ← a0", color=green];
// [Asm]   r6 [label="v19 ← a3", color=green];
// [Asm]   r13 [label="a6", color=blue];
// [Asm]   r4 [label="s11", color=blue];
// [Asm]   r29 [label="v8 ← a3", color=green];
// [Asm]   r7 [label="a1", color=blue];
// [Asm]   r10 [label="a3", color=blue];
// [Asm]   r8 [label="a0", color=blue];
// [Asm]   r5 [label="zero", color=blue];
// [Asm]   r32 [label="v26 ← a1", color=green];
// [Asm]   r24 [label="v3 ← a5", color=green];
// [Asm]   r15 [label="t0", color=blue];
// [Asm]   r31 [label="v9 ← a0", color=green];
// [Asm]   r17 [label="t2", color=blue];
// [Asm]   r12 [label="a5", color=blue];
// [Asm]   r20 [label="v22 ← a0", color=green];
// [Asm]   r23 [label="v5 ← a3", color=green];
// [Asm]   r3 [label="v17 ← a3", color=green];
// [Asm]   r27 [label="v16 ← a0", color=green];
// [Asm]   r1 [label="v4 ← a1", color=green];
// [Asm]   r28 [label="v12 ← a4", color=green];
// [Asm]   r11 [label="a4", color=blue];
// [Asm]   r22 [label="v10 ← a0", color=green];
// [Asm]   r14 [label="a7", color=blue];
// [Asm]   r30 [label="v31 ← a4", color=green];
// [Asm]   r25 [label="v2 ← a0", color=green];
// [Asm]   r2 [label="v6 ← a2", color=green];
// [Asm]   r16 [label="t1", color=blue];
// [Asm]   r18 [label="t3", color=blue];
// [Asm]   r19 [label="t4", color=blue];
// [Asm]   r21 [label="v23 ← a0", color=green];
// [Asm]   r11 -- r25;
// [Asm]   r1 -- r24;
// [Asm]   r9 -- r25;
// [Asm]   r4 -- r24;
// [Asm]   r1 -- r26;
// [Asm]   r2 -- r26;
// [Asm]   r4 -- r5;
// [Asm]   r1 -- r30;
// [Asm]   r4 -- r23;
// [Asm]   r2 -- r4;
// [Asm]   r1 -- r23;
// [Asm]   r1 -- r4;
// [Asm]   r5 -- r23;
// [Asm]   r5 -- r22;
// [Asm]   r29 -- r30;
// [Asm]   r8 -- r19;
// [Asm]   r8 -- r9;
// [Asm]   r7 -- r25;
// [Asm]   r1 -- r22;
// [Asm]   r1 -- r10;
// [Asm]   r22 -- r29;
// [Asm]   r11 -- r23;
// [Asm]   r5 -- r29;
// [Asm]   r4 -- r27;
// [Asm]   r4 -- r30;
// [Asm]   r11 -- r24;
// [Asm]   r2 -- r7;
// [Asm]   r4 -- r22;
// [Asm]   r7 -- r9;
// [Asm]   r3 -- r5;
// [Asm]   r22 -- r24;
// [Asm]   r1 -- r28;
// [Asm]   r4 -- r31;
// [Asm]   r8 -- r12;
// [Asm]   r0 -- r6;
// [Asm]   r2 -- r28;
// [Asm]   r2 -- r29;
// [Asm]   r2 -- r6;
// [Asm]   r5 -- r6;
// [Asm]   r8 -- r17;
// [Asm]   r3 -- r4;
// [Asm]   r8 -- r16;
// [Asm]   r22 -- r30;
// [Asm]   r5 -- r28;
// [Asm]   r8 -- r13;
// [Asm]   r0 -- r2;
// [Asm]   r5 -- r24;
// [Asm]   r5 -- r26;
// [Asm]   r8 -- r15;
// [Asm]   r0 -- r3;
// [Asm]   r22 -- r28;
// [Asm]   r1 -- r29;
// [Asm]   r4 -- r28;
// [Asm]   r23 -- r28;
// [Asm]   r9 -- r24;
// [Asm]   r8 -- r18;
// [Asm]   r22 -- r23;
// [Asm]   r0 -- r5;
// [Asm]   r1 -- r27;
// [Asm]   r1 -- r2;
// [Asm]   r4 -- r29;
// [Asm]   r6 -- r31;
// [Asm]   r2 -- r5;
// [Asm]   r0 -- r1;
// [Asm]   r8 -- r10;
// [Asm]   r23 -- r24;
// [Asm]   r4 -- r25;
// [Asm]   r1 -- r11;
// [Asm]   r2 -- r30;
// [Asm]   r5 -- r25;
// [Asm]   r8 -- r11;
// [Asm]   r5 -- r27;
// [Asm]   r31 -- r32;
// [Asm]   r10 -- r25;
// [Asm]   r1 -- r6;
// [Asm]   r2 -- r22;
// [Asm]   r1 -- r5;
// [Asm]   r2 -- r24;
// [Asm]   r0 -- r4;
// [Asm]   r8 -- r14;
// [Asm]   r4 -- r6;
// [Asm]   r1 -- r3;
// [Asm]   r4 -- r26;
// [Asm]   r7 -- r8;
// [Asm]   r5 -- r30;
// [Asm]   r2 -- r3;
// [Asm]   r2 -- r27;
// [Asm]   r10 -- r24;
// [Asm]   r2 -- r23;
// [Asm]   r6 -- r32;
// [Asm]   comment = "0:v18-> 1:v4-> 2:v6-> 3:v17-> 4:s11-> 5:zero-> 6:v19-> 22:v10-> 23:v5-> 24:v3-> 28:v12-> 29:v8-> 30:v31-> 26:v7-> 27:v16-> 11:a4-> 25:v2-> 10:a3-> 7:a1-> 8:a0-> 9:a2-> 31:v9-> 32:v26-> 12:a5-> 13:a6-> 14:a7-> 15:t0-> 16:t1-> 17:t2-> 18:t3-> 19:t4-> 20:v22-> 21:v23"
// [Asm]   comment = "v18<-a0;v7<-a0;v19<-a3;v8<-a3;v26<-a1;v3<-a5;v9<-a0;v22<-a0;v5<-a3;v17<-a3;v16<-a0;v4<-a1;v12<-a4;v10<-a0;v31<-a4;v2<-a0;v6<-a2;v23<-a0;"
// [Asm] }
// [Asm] 
// [Asm] graph G {
// [Asm]   graph [label="float interference graph of aux.12699"];
// [Asm]   r0 [label="ft0", color=blue];
// [Asm]   r3 [label="ft3", color=blue];
// [Asm]   r9 [label="ft9", color=blue];
// [Asm]   r6 [label="ft6", color=blue];
// [Asm]   r13 [label="fa2", color=blue];
// [Asm]   r4 [label="ft4", color=blue];
// [Asm]   r1 [label="ft1", color=blue];
// [Asm]   r11 [label="fa0", color=blue];
// [Asm]   r7 [label="ft7", color=blue];
// [Asm]   r10 [label="ft10", color=blue];
// [Asm]   r14 [label="fa3", color=blue];
// [Asm]   r8 [label="ft8", color=blue];
// [Asm]   r5 [label="ft5", color=blue];
// [Asm]   r15 [label="fa4", color=blue];
// [Asm]   r2 [label="ft2", color=blue];
// [Asm]   r16 [label="fa5", color=blue];
// [Asm]   r18 [label="fa7", color=blue];
// [Asm]   r17 [label="fa6", color=blue];
// [Asm]   r12 [label="fa1", color=blue];
// [Asm]   comment = "0:ft0-> 1:ft1-> 2:ft2-> 3:ft3-> 4:ft4-> 5:ft5-> 6:ft6-> 7:ft7-> 8:ft8-> 9:ft9-> 10:ft10-> 11:fa0-> 12:fa1-> 13:fa2-> 14:fa3-> 15:fa4-> 16:fa5-> 17:fa6-> 18:fa7"
// [Asm]   comment = ""
// [Asm] }
// [Asm] 
// [Asm] subst   lw v18, 0(v17) ->   lw a0, 0(a3)
// [Asm] subst   lw v19, 4(v17) ->   lw a3, 4(a3)
// [Asm] subst   bne v18, zero, .aux.12699_2 ->   bne a0, zero, .aux.12699_2
// [Asm] subst   call aux.12698 ->   call aux.12698
// [Asm] subst   lw v10, 0(v5) ->   lw a0, 0(a3)
// [Asm] subst   beq v10, v3, .aux.12699_7 ->   beq a0, a5, .aux.12699_7
// [Asm] subst   ret ->   ret
// [Asm] subst   mv v17, v16 ->   mv a3, a0
// [Asm] subst   mv v3, a1 ->   mv a5, a1
// [Asm] subst   mv v4, a2 ->   mv a1, a2
// [Asm] subst   mv v6, a4 ->   mv a2, a4
// [Asm] subst   addi v7, s11, -8 ->   addi a0, s11, -8
// [Asm] subst   andi s11, v7, -8 ->   andi s11, a0, -8
// [Asm] subst   sw zero, 0(v7) ->   sw zero, 0(a0)
// [Asm] subst   sw zero, 4(v7) ->   sw zero, 4(a0)
// [Asm] subst   j .aux.12699_9 ->   j .aux.12699_9
// [Asm] subst   addi v12, v10, 1 ->   addi a4, a0, 1
// [Asm] subst   sw v12, 0(v5) ->   sw a4, 0(a3)
// [Asm] subst   addi v8, s11, -8 ->   addi a3, s11, -8
// [Asm] subst   andi s11, v8, -8 ->   andi s11, a3, -8
// [Asm] subst   li v31, 1 ->   li a4, 1
// [Asm] subst   sw v31, 0(v8) ->   sw a4, 0(a3)
// [Asm] subst   sw v10, 4(v8) ->   sw a0, 4(a3)
// [Asm] subst   mv v16, v8 ->   mv a0, a3
// [Asm] subst   addi v9, s11, -8 ->   addi a0, s11, -8
// [Asm] subst   andi s11, v9, -8 ->   andi s11, a0, -8
// [Asm] subst   li v26, 1 ->   li a1, 1
// [Asm] subst   sw v26, 0(v9) ->   sw a1, 0(a0)
// [Asm] subst   sw v19, 4(v9) ->   sw a3, 4(a0)
// [Asm] subst   j .aux.12699_3 ->   j .aux.12699_3
// [Asm] pre_assigned_registers: FnParam(fref=f3, fpref=$f.0) -> v2, FnParam(fref=f3, fpref=$f.1) -> v3, Self(fref=f3) -> v0, Insn(iref=%0) -> v4
// [Asm] defs: []
// [Asm] live_set: [a1, a0]
// [Asm] move_origin: []
// [Asm] defs: [v2]
// [Asm] live_set: [a1, v2]
// [Asm] move_origin: [a0]
// [Asm] defined: v2 is X
// [Asm] defs: [v3]
// [Asm] live_set: [v2, v3]
// [Asm] move_origin: [a1]
// [Asm] defined: v3 is X
// [Asm] defs: [v4]
// [Asm] live_set: [v4]
// [Asm] move_origin: []
// [Asm] defined: v4 is X
// [Asm] defs: [a0]
// [Asm] live_set: [a0]
// [Asm] move_origin: [v4]
// [Asm] defined: a0 is X
// [Asm] defs: []
// [Asm] live_set: [a0]
// [Asm] move_origin: []
// [Asm] defs: []
// [Asm] live_set: []
// [Asm] move_origin: []
// [Asm] graph G {
// [Asm]   graph [label="integer interference graph of aux.12700"];
// [Asm]   r0 [label="v2 ← a0", color=green];
// [Asm]   r4 [label="a0", color=blue];
// [Asm]   r1 [label="a1", color=blue];
// [Asm]   r3 [label="v4 ← a0", color=green];
// [Asm]   r2 [label="v3 ← a1", color=green];
// [Asm]   r0 -- r1;
// [Asm]   r0 -- r2;
// [Asm]   comment = "0:v2-> 1:a1-> 2:v3-> 3:v4-> 4:a0"
// [Asm]   comment = "v2<-a0;v4<-a0;v3<-a1;"
// [Asm] }
// [Asm] 
// [Asm] graph G {
// [Asm]   graph [label="float interference graph of aux.12700"];
// [Asm]   comment = ""
// [Asm]   comment = ""
// [Asm] }
// [Asm] 
// [Asm] subst   add v4, v3, v2 ->   add a0, a1, a0
// [Asm] subst   ret ->   ret
// [Asm] pre_assigned_registers: Insn(iref=%0) -> v4, FnParam(fref=f24, fpref=$f.0) -> v2, Self(fref=f24) -> v0, FnParam(fref=f24, fpref=$f.1) -> v3
// [Asm] defs: []
// [Asm] live_set: [a1, a0, s10]
// [Asm] move_origin: []
// [Asm] defs: [v0]
// [Asm] live_set: [a1, a0]
// [Asm] move_origin: [s10]
// [Asm] defined: v0 is X
// [Asm] defs: [v2]
// [Asm] live_set: [a1, v2]
// [Asm] move_origin: [a0]
// [Asm] defined: v2 is X
// [Asm] defs: [v3]
// [Asm] live_set: [v2, v3]
// [Asm] move_origin: [a1]
// [Asm] defined: v3 is X
// [Asm] defs: []
// [Asm] live_set: [v2, v3]
// [Asm] move_origin: []
// [Asm] defs: [a0]
// [Asm] live_set: [a0, v3]
// [Asm] move_origin: [v2]
// [Asm] defined: a0 is X
// [Asm] defs: [a1]
// [Asm] live_set: [a1, a0]
// [Asm] move_origin: [v3]
// [Asm] defined: a1 is X
// [Asm] defs: [a0, a1, a2, a3, a4, a5, a6, a7, t0, t1, t2, t3, t4, ft0, ft1, ft2, ft3, ft4, ft5, ft6, ft7, ft8, ft9, ft10, fa0, fa1, fa2, fa3, fa4, fa5, fa6, fa7]
// [Asm] live_set: [a0]
// [Asm] move_origin: []
// [Asm] defined: a0 is X
// [Asm] defined: a1 is X
// [Asm] defined: a2 is X
// [Asm] defined: a3 is X
// [Asm] defined: a4 is X
// [Asm] defined: a5 is X
// [Asm] defined: a6 is X
// [Asm] defined: a7 is X
// [Asm] defined: t0 is X
// [Asm] defined: t1 is X
// [Asm] defined: t2 is X
// [Asm] defined: t3 is X
// [Asm] defined: t4 is X
// [Asm] defined: ft0 is F
// [Asm] defined: ft1 is F
// [Asm] defined: ft2 is F
// [Asm] defined: ft3 is F
// [Asm] defined: ft4 is F
// [Asm] defined: ft5 is F
// [Asm] defined: ft6 is F
// [Asm] defined: ft7 is F
// [Asm] defined: ft8 is F
// [Asm] defined: ft9 is F
// [Asm] defined: ft10 is F
// [Asm] defined: fa0 is F
// [Asm] defined: fa1 is F
// [Asm] defined: fa2 is F
// [Asm] defined: fa3 is F
// [Asm] defined: fa4 is F
// [Asm] defined: fa5 is F
// [Asm] defined: fa6 is F
// [Asm] defined: fa7 is F
// [Asm] defs: [v4]
// [Asm] live_set: [v4]
// [Asm] move_origin: [a0]
// [Asm] defined: v4 is X
// [Asm] defs: []
// [Asm] live_set: [v4]
// [Asm] move_origin: []
// [Asm] defs: [a0]
// [Asm] live_set: [a0]
// [Asm] move_origin: [v4]
// [Asm] defined: a0 is X
// [Asm] defs: []
// [Asm] live_set: [a0]
// [Asm] move_origin: []
// [Asm] defs: []
// [Asm] live_set: []
// [Asm] move_origin: []
// [Asm] graph G {
// [Asm]   graph [label="integer interference graph of add.12708"];
// [Asm]   r0 [label="v0 ← a2", color=green];
// [Asm]   r3 [label="v2 ← a0", color=green];
// [Asm]   r9 [label="a6", color=blue];
// [Asm]   r6 [label="a3", color=blue];
// [Asm]   r13 [label="t2", color=blue];
// [Asm]   r4 [label="v3 ← a1", color=green];
// [Asm]   r1 [label="a1", color=blue];
// [Asm]   r11 [label="t0", color=blue];
// [Asm]   r7 [label="a4", color=blue];
// [Asm]   r10 [label="a7", color=blue];
// [Asm]   r14 [label="t3", color=blue];
// [Asm]   r8 [label="a5", color=blue];
// [Asm]   r5 [label="a2", color=blue];
// [Asm]   r15 [label="t4", color=blue];
// [Asm]   r2 [label="a0", color=blue];
// [Asm]   r16 [label="v4 ← a0", color=green];
// [Asm]   r12 [label="t1", color=blue];
// [Asm]   r2 -- r5;
// [Asm]   r2 -- r10;
// [Asm]   r0 -- r1;
// [Asm]   r2 -- r13;
// [Asm]   r2 -- r6;
// [Asm]   r3 -- r4;
// [Asm]   r2 -- r7;
// [Asm]   r2 -- r11;
// [Asm]   r2 -- r14;
// [Asm]   r2 -- r15;
// [Asm]   r0 -- r2;
// [Asm]   r2 -- r4;
// [Asm]   r2 -- r9;
// [Asm]   r1 -- r3;
// [Asm]   r2 -- r12;
// [Asm]   r2 -- r8;
// [Asm]   r1 -- r2;
// [Asm]   comment = "0:v0-> 1:a1-> 2:a0-> 3:v2-> 4:v3-> 5:a2-> 6:a3-> 7:a4-> 8:a5-> 9:a6-> 10:a7-> 11:t0-> 12:t1-> 13:t2-> 14:t3-> 15:t4-> 16:v4"
// [Asm]   comment = "v0<-a2;v2<-a0;v3<-a1;v4<-a0;"
// [Asm] }
// [Asm] 
// [Asm] graph G {
// [Asm]   graph [label="float interference graph of add.12708"];
// [Asm]   r0 [label="ft0", color=blue];
// [Asm]   r3 [label="ft3", color=blue];
// [Asm]   r9 [label="ft9", color=blue];
// [Asm]   r6 [label="ft6", color=blue];
// [Asm]   r13 [label="fa2", color=blue];
// [Asm]   r4 [label="ft4", color=blue];
// [Asm]   r1 [label="ft1", color=blue];
// [Asm]   r11 [label="fa0", color=blue];
// [Asm]   r7 [label="ft7", color=blue];
// [Asm]   r10 [label="ft10", color=blue];
// [Asm]   r14 [label="fa3", color=blue];
// [Asm]   r8 [label="ft8", color=blue];
// [Asm]   r5 [label="ft5", color=blue];
// [Asm]   r15 [label="fa4", color=blue];
// [Asm]   r2 [label="ft2", color=blue];
// [Asm]   r16 [label="fa5", color=blue];
// [Asm]   r18 [label="fa7", color=blue];
// [Asm]   r17 [label="fa6", color=blue];
// [Asm]   r12 [label="fa1", color=blue];
// [Asm]   comment = "0:ft0-> 1:ft1-> 2:ft2-> 3:ft3-> 4:ft4-> 5:ft5-> 6:ft6-> 7:ft7-> 8:ft8-> 9:ft9-> 10:ft10-> 11:fa0-> 12:fa1-> 13:fa2-> 14:fa3-> 15:fa4-> 16:fa5-> 17:fa6-> 18:fa7"
// [Asm]   comment = ""
// [Asm] }
// [Asm] 
// [Asm] subst   mv v0, s10 ->   mv a2, s10
// [Asm] subst   call add.12706 ->   call add.12706
// [Asm] subst   ret ->   ret
// [Asm] pre_assigned_registers: FreeVar(fvref=^6) -> v8, FreeVar(fvref=^5) -> v7, Self(fref=f22) -> v0, FreeVar(fvref=^1) -> v3, FreeVar(fvref=^2) -> v4, FnParam(fref=f22, fpref=$f.0) -> v2, FreeVar(fvref=^4) -> v6, FreeVar(fvref=^3) -> v5, FreeVar(fvref=^7) -> v9, Insn(iref=%0) -> v10
// [Asm] defs: []
// [Asm] live_set: [a0, s10]
// [Asm] move_origin: []
// [Asm] defs: [v0]
// [Asm] live_set: [a0, v0]
// [Asm] move_origin: [s10]
// [Asm] defined: v0 is X
// [Asm] defs: [v2]
// [Asm] live_set: [a0, v0]
// [Asm] move_origin: [a0]
// [Asm] defined: v2 is X
// [Asm] defs: [v3]
// [Asm] live_set: [a0, v0, v3]
// [Asm] move_origin: []
// [Asm] defined: v3 is X
// [Asm] defs: [v4]
// [Asm] live_set: [a0, v0, v4, v3]
// [Asm] move_origin: []
// [Asm] defined: v4 is X
// [Asm] defs: [v5]
// [Asm] live_set: [v5, a0, v0, v4, v3]
// [Asm] move_origin: []
// [Asm] defined: v5 is X
// [Asm] defs: [v6]
// [Asm] live_set: [v5, a0, v0, v4, v6, v3]
// [Asm] move_origin: []
// [Asm] defined: v6 is X
// [Asm] defs: [v7]
// [Asm] live_set: [v5, a0, v7, v0, v4, v6, v3]
// [Asm] move_origin: []
// [Asm] defined: v7 is X
// [Asm] defs: [v8]
// [Asm] live_set: [v5, a0, v8, v7, v0, v4, v6, v3]
// [Asm] move_origin: []
// [Asm] defined: v8 is X
// [Asm] defs: [v9]
// [Asm] live_set: [v5, a0, v8, v7, v4, v6, v9, v3]
// [Asm] move_origin: []
// [Asm] defined: v9 is X
// [Asm] defs: []
// [Asm] live_set: [v5, a0, v8, v7, v4, v6, v9, v3]
// [Asm] move_origin: []
// [Asm] defs: [a1]
// [Asm] live_set: [v5, a0, v8, v7, v4, a1, v6, v9]
// [Asm] move_origin: [v3]
// [Asm] defined: a1 is X
// [Asm] defs: [a2]
// [Asm] live_set: [v5, a0, v8, v7, a2, a1, v6, v9]
// [Asm] move_origin: [v4]
// [Asm] defined: a2 is X
// [Asm] defs: [a3]
// [Asm] live_set: [a0, v8, v7, a2, a1, v6, a3, v9]
// [Asm] move_origin: [v5]
// [Asm] defined: a3 is X
// [Asm] defs: [a4]
// [Asm] live_set: [a0, a4, v8, v7, a2, a1, a3, v9]
// [Asm] move_origin: [v6]
// [Asm] defined: a4 is X
// [Asm] defs: [a5]
// [Asm] live_set: [a5, a0, a4, v8, a2, a1, a3, v9]
// [Asm] move_origin: [v7]
// [Asm] defined: a5 is X
// [Asm] defs: [a6]
// [Asm] live_set: [a5, a0, a4, a6, a2, a1, a3, v9]
// [Asm] move_origin: [v8]
// [Asm] defined: a6 is X
// [Asm] defs: [a7]
// [Asm] live_set: [a7, a5, a0, a4, a6, a2, a1, a3]
// [Asm] move_origin: [v9]
// [Asm] defined: a7 is X
// [Asm] defs: [a0, a1, a2, a3, a4, a5, a6, a7, t0, t1, t2, t3, t4, ft0, ft1, ft2, ft3, ft4, ft5, ft6, ft7, ft8, ft9, ft10, fa0, fa1, fa2, fa3, fa4, fa5, fa6, fa7]
// [Asm] live_set: [a0]
// [Asm] move_origin: []
// [Asm] defined: a0 is X
// [Asm] defined: a1 is X
// [Asm] defined: a2 is X
// [Asm] defined: a3 is X
// [Asm] defined: a4 is X
// [Asm] defined: a5 is X
// [Asm] defined: a6 is X
// [Asm] defined: a7 is X
// [Asm] defined: t0 is X
// [Asm] defined: t1 is X
// [Asm] defined: t2 is X
// [Asm] defined: t3 is X
// [Asm] defined: t4 is X
// [Asm] defined: ft0 is F
// [Asm] defined: ft1 is F
// [Asm] defined: ft2 is F
// [Asm] defined: ft3 is F
// [Asm] defined: ft4 is F
// [Asm] defined: ft5 is F
// [Asm] defined: ft6 is F
// [Asm] defined: ft7 is F
// [Asm] defined: ft8 is F
// [Asm] defined: ft9 is F
// [Asm] defined: ft10 is F
// [Asm] defined: fa0 is F
// [Asm] defined: fa1 is F
// [Asm] defined: fa2 is F
// [Asm] defined: fa3 is F
// [Asm] defined: fa4 is F
// [Asm] defined: fa5 is F
// [Asm] defined: fa6 is F
// [Asm] defined: fa7 is F
// [Asm] defs: [v10]
// [Asm] live_set: [v10]
// [Asm] move_origin: [a0]
// [Asm] defined: v10 is X
// [Asm] defs: []
// [Asm] live_set: [v10]
// [Asm] move_origin: []
// [Asm] defs: [a0]
// [Asm] live_set: [a0]
// [Asm] move_origin: [v10]
// [Asm] defined: a0 is X
// [Asm] defs: []
// [Asm] live_set: [a0]
// [Asm] move_origin: []
// [Asm] defs: []
// [Asm] live_set: []
// [Asm] move_origin: []
// [Asm] graph G {
// [Asm]   graph [label="integer interference graph of aux.12707"];
// [Asm]   r0 [label="v0 ← a1", color=green];
// [Asm]   r20 [label="t3", color=blue];
// [Asm]   r3 [label="v3 ← a2", color=green];
// [Asm]   r9 [label="v9 ← t0", color=green];
// [Asm]   r6 [label="v6 ← a5", color=green];
// [Asm]   r13 [label="a4", color=blue];
// [Asm]   r4 [label="v4 ← a3", color=green];
// [Asm]   r1 [label="a0", color=blue];
// [Asm]   r11 [label="a2", color=blue];
// [Asm]   r7 [label="v7 ← a6", color=green];
// [Asm]   r10 [label="a1", color=blue];
// [Asm]   r22 [label="v10 ← a0", color=green];
// [Asm]   r14 [label="a5", color=blue];
// [Asm]   r8 [label="v8 ← a7", color=green];
// [Asm]   r5 [label="v5 ← a4", color=green];
// [Asm]   r15 [label="a6", color=blue];
// [Asm]   r2 [label="v2 ← a0", color=green];
// [Asm]   r16 [label="a7", color=blue];
// [Asm]   r18 [label="t1", color=blue];
// [Asm]   r19 [label="t2", color=blue];
// [Asm]   r17 [label="t0", color=blue];
// [Asm]   r21 [label="t4", color=blue];
// [Asm]   r12 [label="a3", color=blue];
// [Asm]   r6 -- r7;
// [Asm]   r6 -- r9;
// [Asm]   r6 -- r11;
// [Asm]   r13 -- r15;
// [Asm]   r1 -- r12;
// [Asm]   r4 -- r5;
// [Asm]   r14 -- r16;
// [Asm]   r1 -- r8;
// [Asm]   r5 -- r8;
// [Asm]   r5 -- r10;
// [Asm]   r9 -- r15;
// [Asm]   r1 -- r4;
// [Asm]   r3 -- r6;
// [Asm]   r11 -- r14;
// [Asm]   r12 -- r15;
// [Asm]   r1 -- r7;
// [Asm]   r8 -- r9;
// [Asm]   r1 -- r18;
// [Asm]   r11 -- r16;
// [Asm]   r1 -- r19;
// [Asm]   r1 -- r10;
// [Asm]   r7 -- r13;
// [Asm]   r10 -- r13;
// [Asm]   r13 -- r16;
// [Asm]   r3 -- r9;
// [Asm]   r11 -- r12;
// [Asm]   r1 -- r15;
// [Asm]   r1 -- r13;
// [Asm]   r1 -- r17;
// [Asm]   r1 -- r20;
// [Asm]   r1 -- r16;
// [Asm]   r7 -- r9;
// [Asm]   r5 -- r11;
// [Asm]   r6 -- r12;
// [Asm]   r3 -- r5;
// [Asm]   r10 -- r16;
// [Asm]   r8 -- r12;
// [Asm]   r6 -- r8;
// [Asm]   r0 -- r6;
// [Asm]   r9 -- r14;
// [Asm]   r3 -- r8;
// [Asm]   r1 -- r9;
// [Asm]   r9 -- r11;
// [Asm]   r5 -- r6;
// [Asm]   r3 -- r4;
// [Asm]   r12 -- r13;
// [Asm]   r8 -- r13;
// [Asm]   r11 -- r13;
// [Asm]   r0 -- r2;
// [Asm]   r5 -- r9;
// [Asm]   r0 -- r3;
// [Asm]   r10 -- r12;
// [Asm]   r1 -- r21;
// [Asm]   r0 -- r8;
// [Asm]   r6 -- r10;
// [Asm]   r7 -- r10;
// [Asm]   r13 -- r14;
// [Asm]   r10 -- r15;
// [Asm]   r9 -- r12;
// [Asm]   r10 -- r11;
// [Asm]   r7 -- r11;
// [Asm]   r0 -- r5;
// [Asm]   r0 -- r1;
// [Asm]   r8 -- r10;
// [Asm]   r4 -- r7;
// [Asm]   r1 -- r11;
// [Asm]   r5 -- r7;
// [Asm]   r4 -- r8;
// [Asm]   r9 -- r10;
// [Asm]   r11 -- r15;
// [Asm]   r8 -- r11;
// [Asm]   r12 -- r14;
// [Asm]   r12 -- r16;
// [Asm]   r3 -- r7;
// [Asm]   r1 -- r6;
// [Asm]   r1 -- r5;
// [Asm]   r0 -- r4;
// [Asm]   r4 -- r10;
// [Asm]   r1 -- r14;
// [Asm]   r8 -- r14;
// [Asm]   r4 -- r6;
// [Asm]   r7 -- r8;
// [Asm]   r1 -- r3;
// [Asm]   r0 -- r7;
// [Asm]   r7 -- r12;
// [Asm]   r9 -- r13;
// [Asm]   r15 -- r16;
// [Asm]   r4 -- r9;
// [Asm]   r14 -- r15;
// [Asm]   r10 -- r14;
// [Asm]   comment = "0:v0-> 1:a0-> 3:v3-> 4:v4-> 5:v5-> 6:v6-> 7:v7-> 8:v8-> 9:v9-> 10:a1-> 11:a2-> 12:a3-> 13:a4-> 14:a5-> 15:a6-> 16:a7-> 2:v2-> 17:t0-> 18:t1-> 19:t2-> 20:t3-> 21:t4-> 22:v10"
// [Asm]   comment = "v0<-a1;v3<-a2;v9<-t0;v6<-a5;v4<-a3;v7<-a6;v10<-a0;v8<-a7;v5<-a4;v2<-a0;"
// [Asm] }
// [Asm] 
// [Asm] graph G {
// [Asm]   graph [label="float interference graph of aux.12707"];
// [Asm]   r0 [label="ft0", color=blue];
// [Asm]   r3 [label="ft3", color=blue];
// [Asm]   r9 [label="ft9", color=blue];
// [Asm]   r6 [label="ft6", color=blue];
// [Asm]   r13 [label="fa2", color=blue];
// [Asm]   r4 [label="ft4", color=blue];
// [Asm]   r1 [label="ft1", color=blue];
// [Asm]   r11 [label="fa0", color=blue];
// [Asm]   r7 [label="ft7", color=blue];
// [Asm]   r10 [label="ft10", color=blue];
// [Asm]   r14 [label="fa3", color=blue];
// [Asm]   r8 [label="ft8", color=blue];
// [Asm]   r5 [label="ft5", color=blue];
// [Asm]   r15 [label="fa4", color=blue];
// [Asm]   r2 [label="ft2", color=blue];
// [Asm]   r16 [label="fa5", color=blue];
// [Asm]   r18 [label="fa7", color=blue];
// [Asm]   r17 [label="fa6", color=blue];
// [Asm]   r12 [label="fa1", color=blue];
// [Asm]   comment = "0:ft0-> 1:ft1-> 2:ft2-> 3:ft3-> 4:ft4-> 5:ft5-> 6:ft6-> 7:ft7-> 8:ft8-> 9:ft9-> 10:ft10-> 11:fa0-> 12:fa1-> 13:fa2-> 14:fa3-> 15:fa4-> 16:fa5-> 17:fa6-> 18:fa7"
// [Asm]   comment = ""
// [Asm] }
// [Asm] 
// [Asm] subst   mv v0, s10 ->   mv a1, s10
// [Asm] subst   lw v3, 8(v0) ->   lw a2, 8(a1)
// [Asm] subst   lw v4, 16(v0) ->   lw a3, 16(a1)
// [Asm] subst   lw v5, 24(v0) ->   lw a4, 24(a1)
// [Asm] subst   lw v6, 32(v0) ->   lw a5, 32(a1)
// [Asm] subst   lw v7, 40(v0) ->   lw a6, 40(a1)
// [Asm] subst   ld v8, 48(v0) ->   ld a7, 48(a1)
// [Asm] subst   ld v9, 56(v0) ->   ld t0, 56(a1)
// [Asm] subst   mv a1, v3 ->   mv a1, a2
// [Asm] subst   mv a2, v4 ->   mv a2, a3
// [Asm] subst   mv a3, v5 ->   mv a3, a4
// [Asm] subst   mv a4, v6 ->   mv a4, a5
// [Asm] subst   mv a5, v7 ->   mv a5, a6
// [Asm] subst   mv a6, v8 ->   mv a6, a7
// [Asm] subst   mv a7, v9 ->   mv a7, t0
// [Asm] subst   call aux.12705 ->   call aux.12705
// [Asm] subst   ret ->   ret
// [Asm] before colored: # leaf false
// [Asm] aux.12705:
// [Asm] # block info: defs: [v2, v5, v16, v7, v8, v4, v6, v9, v3], uses: [a7, a5, a0, a4, a6, a2, a1, a3, v2], upward_exposed: [a7, a5, a0, a4, a6, a2, a1, a3], params_defs: []
// [Asm] # live_in: [a7, a5, a0, zero, a4, a6, a2, a1, a3, s11], live_out: [v16, v5, zero, v8, v7, v4, v6, s11, v9, v3]
// [Asm] # block parameters: []
// [Asm] .aux.12705_0:
// [Asm]   # save_ctx1  # live: [a7, a5, zero, a0, a4, a6, a2, a1, s11, a3]
// [Asm]   mv v2, a0  # live: [a7, a5, zero, a4, a6, a2, a1, s11, a3, v2]
// [Asm]   mv v3, a1  # live: [v2, a7, a5, zero, a4, a6, a2, s11, a3, v3]
// [Asm]   mv v4, a2  # live: [v2, a7, a5, zero, a4, a6, v4, s11, a3, v3]
// [Asm]   mv v5, a3  # live: [v2, a7, v5, a5, zero, a4, a6, v4, s11, v3]
// [Asm]   mv v6, a4  # live: [v2, a7, v5, a5, zero, a6, v4, v6, s11, v3]
// [Asm]   mv v7, a5  # live: [v2, a7, v5, zero, v7, a6, v4, v6, s11, v3]
// [Asm]   mv v8, a6  # live: [v2, a7, v5, zero, v7, v8, v4, v6, s11, v3]
// [Asm]   mv v9, a7  # live: [v2, v5, zero, v7, v8, v4, v6, s11, v9, v3]
// [Asm] # control
// [Asm]   mv v16, v2  # live: [v16, v5, zero, v7, v8, v4, v6, s11, v9, v3]
// [Asm] 
// [Asm] # block info: defs: [], uses: [], upward_exposed: [], params_defs: [v16]
// [Asm] # live_in: [v16, v5, zero, v8, v7, v4, v6, s11, v9, v3], live_out: [v5, zero, v8, v7, v4, v6, s11, v9, v3]
// [Asm] # block parameters: [v16]
// [Asm] .aux.12705_2:
// [Asm] # control
// [Asm] 
// [Asm] # block info: defs: [v17], uses: [zero], upward_exposed: [zero], params_defs: []
// [Asm] # live_in: [v5, zero, v8, v7, v4, v6, s11, v9, v3], live_out: [v5, zero, v8, v7, v4, v17, v6, s11, v9, v3]
// [Asm] # block parameters: []
// [Asm] .aux.12705_15:
// [Asm] # control
// [Asm]   mv v17, zero  # live: [v5, zero, v7, v8, v4, v17, v6, s11, v9, v3]
// [Asm] 
// [Asm] # block info: defs: [], uses: [], upward_exposed: [], params_defs: [v17]
// [Asm] # live_in: [v5, zero, v8, v7, v4, v17, v6, s11, v9, v3], live_out: [v5, zero, v8, v7, v4, v6, s11, v9, v3]
// [Asm] # block parameters: [v17]
// [Asm] .aux.12705_17:
// [Asm] # control
// [Asm] 
// [Asm] # block info: defs: [t1, ft0, ft1, a1, fa1, fa2, ft6, a4, fa6, a6, v19, ft10, ft5, ft7, ft4, ft9, a5, a0, fa4, ft2, a2, a3, ft8, a7, t3, fa7, t0, fa5, v18, fa3, ft3, fa0, t4, t2], uses: [v18, a0, a4, v8, v4, a2, a1, a3, v9, v3], upward_exposed: [v8, v4, v9, v3], params_defs: []
// [Asm] # live_in: [v5, zero, v8, v7, v4, v6, s11, v9, v3], live_out: [v5, zero, v7, v8, v19, v4, v6, s11, v9, v3]
// [Asm] # block parameters: []
// [Asm] .aux.12705_30:
// [Asm]   # save_ctx2  # live: [v5, a0, v7, s11, v9, zero, v8, v4, v6, v3]
// [Asm]   mv a1, v3  # live: [v5, a0, v7, a1, s11, v9, zero, v8, v4, v6, v3]
// [Asm]   mv a2, v4  # live: [v5, a0, v7, a2, a1, s11, v9, zero, v8, v4, v6, v3]
// [Asm]   mv a3, v8  # live: [v5, a0, v7, a2, a1, s11, a3, v9, zero, v8, v4, v6, v3]
// [Asm]   mv a4, v9  # live: [v5, a0, v7, a2, a1, s11, a3, v9, zero, a4, v8, v4, v6, v3]
// [Asm]   call aux.12699  # live: [v5, zero, a0, v8, v7, v4, v6, s11, v9, v3]
// [Asm]   mv v18, a0  # live: [v5, v18, zero, v8, v7, v4, v6, s11, v9, v3]
// [Asm]   # restore_ctx2  # live: [v5, v18, zero, v8, v7, v4, v6, s11, v9, v3]
// [Asm] # control
// [Asm]   mv v19, v18  # live: [v5, zero, v8, v7, v19, v4, v6, s11, v9, v3]
// [Asm] 
// [Asm] # block info: defs: [v21, v20], uses: [v19, zero, v20], upward_exposed: [v19, zero], params_defs: [v19]
// [Asm] # live_in: [v5, zero, v7, v8, v19, v4, v6, s11, v9, v3], live_out: [v5, v21, zero, v7, v8, v4, v6, s11, v9, v3]
// [Asm] # block parameters: [v19]
// [Asm] .aux.12705_34:
// [Asm]   lw v20, 0(v19)  # live: [v5, zero, v20, v8, v7, v19, v4, v6, s11, v9, v3]
// [Asm]   lw v21, 4(v19)  # live: [v5, v21, zero, v20, v8, v7, v4, v6, s11, v9, v3]
// [Asm] # control
// [Asm]   bne v20, zero, .aux.12705_32  # live: [v5, v21, zero, v8, v7, v4, v6, s11, v9, v3]
// [Asm] 
// [Asm] # block info: defs: [v14, s11, v27], uses: [v14, s11, zero], upward_exposed: [s11, zero], params_defs: []
// [Asm] # live_in: [v5, zero, v8, v7, v4, v6, s11, v9, v3], live_out: [v5, zero, v27, v8, v7, v4, v6, s11, v9, v3]
// [Asm] # block parameters: []
// [Asm] .aux.12705_31:
// [Asm]   addi v14, s11, -8  # live: [v5, v14, zero, v7, v8, v4, v6, v9, v3]
// [Asm]   andi s11, v14, -8  # live: [v5, v14, zero, v7, v8, v4, v6, s11, v9, v3]
// [Asm]   sw zero, 0(v14)  # live: [v5, v14, zero, v7, v8, v4, v6, s11, v9, v3]
// [Asm]   sw zero, 4(v14)  # live: [v5, v14, zero, v7, v8, v4, v6, s11, v9, v3]
// [Asm] # control
// [Asm]   mv v27, v14  # live: [v5, zero, v27, v7, v8, v4, v6, s11, v9, v3]
// [Asm] 
// [Asm] # block info: defs: [v28], uses: [v27], upward_exposed: [v27], params_defs: [v27]
// [Asm] # live_in: [v5, zero, v27, v8, v7, v4, v6, s11, v9, v3], live_out: [v5, zero, v8, v7, v4, v6, s11, v28, v9, v3]
// [Asm] # block parameters: [v27]
// [Asm] .aux.12705_33:
// [Asm] # control
// [Asm]   mv v28, v27  # live: [v5, zero, v7, v8, v4, v6, s11, v28, v9, v3]
// [Asm] 
// [Asm] # block info: defs: [v29, v30], uses: [v28, v29, zero], upward_exposed: [v28, zero], params_defs: [v28]
// [Asm] # live_in: [v5, zero, v8, v7, v4, v6, s11, v28, v9, v3], live_out: [v5, zero, v30, v8, v7, v4, v6, s11, v9, v3]
// [Asm] # block parameters: [v28]
// [Asm] .aux.12705_25:
// [Asm]   lw v29, 0(v28)  # live: [v5, zero, v29, v8, v7, v4, v6, s11, v28, v9, v3]
// [Asm]   lw v30, 4(v28)  # live: [v5, zero, v29, v30, v8, v7, v4, v6, s11, v9, v3]
// [Asm] # control
// [Asm]   bne v29, zero, .aux.12705_19  # live: [v5, zero, v30, v7, v8, v4, v6, s11, v9, v3]
// [Asm] 
// [Asm] # block info: defs: [v15, s11, v39], uses: [s11, v15, zero], upward_exposed: [s11, zero], params_defs: []
// [Asm] # live_in: [v5, zero, v8, v7, v4, v6, s11, v9, v3], live_out: [v5, zero, v8, v7, v4, v6, s11, v9, v39, v3]
// [Asm] # block parameters: []
// [Asm] .aux.12705_18:
// [Asm]   addi v15, s11, -8  # live: [v5, zero, v7, v8, v4, v6, v15, v9, v3]
// [Asm]   andi s11, v15, -8  # live: [v5, zero, v7, v8, v4, v6, s11, v15, v9, v3]
// [Asm]   sw zero, 0(v15)  # live: [v5, zero, v7, v8, v4, v6, s11, v15, v9, v3]
// [Asm]   sw zero, 4(v15)  # live: [v5, zero, v7, v8, v4, v6, s11, v15, v9, v3]
// [Asm] # control
// [Asm]   mv v39, v15  # live: [v5, zero, v7, v8, v4, v6, s11, v9, v39, v3]
// [Asm] 
// [Asm] # block info: defs: [v40], uses: [v39], upward_exposed: [v39], params_defs: [v39]
// [Asm] # live_in: [v5, zero, v8, v7, v4, v6, s11, v9, v39, v3], live_out: [v40, v5, zero, v7, v8, v4, v6, s11, v9, v3]
// [Asm] # block parameters: [v39]
// [Asm] .aux.12705_23:
// [Asm] # control
// [Asm]   mv v40, v39  # live: [v3, v5, zero, v7, v8, v4, v6, s11, v9, v40]
// [Asm] 
// [Asm] # block info: defs: [v41, v42], uses: [v41, zero, v40], upward_exposed: [zero, v40], params_defs: [v40]
// [Asm] # live_in: [v3, v5, zero, v7, v8, v4, v6, s11, v9, v40], live_out: [v5, zero, v42, v8, v7, v4, v6, s11, v9, v3]
// [Asm] # block parameters: [v40]
// [Asm] .aux.12705_10:
// [Asm]   lw v41, 0(v40)  # live: [v40, v5, zero, v7, v8, v4, v41, v6, s11, v9, v3]
// [Asm]   lw v42, 4(v40)  # live: [v5, zero, v42, v7, v8, v4, v41, v6, s11, v9, v3]
// [Asm] # control
// [Asm]   bne v41, zero, .aux.12705_4  # live: [v5, zero, v42, v7, v8, v4, v6, s11, v9, v3]
// [Asm] 
// [Asm] # block info: defs: [v12, s11, v51], uses: [s11, v12, zero], upward_exposed: [s11, zero], params_defs: []
// [Asm] # live_in: [s11, zero], live_out: [v51]
// [Asm] # block parameters: []
// [Asm] .aux.12705_3:
// [Asm]   addi v12, s11, -8  # live: [v12, zero]
// [Asm]   andi s11, v12, -8  # live: [v12, zero]
// [Asm]   sw zero, 0(v12)  # live: [v12, zero]
// [Asm]   sw zero, 4(v12)  # live: [v12]
// [Asm] # control
// [Asm]   mv v51, v12  # live: [v51]
// [Asm] 
// [Asm] # block info: defs: [a0], uses: [a0, v51], upward_exposed: [v51], params_defs: [v51]
// [Asm] # live_in: [v51], live_out: []
// [Asm] # block parameters: [v51]
// [Asm] .aux.12705_8:
// [Asm] # control
// [Asm]   mv a0, v51  # live: [a0]
// [Asm]   # restore_ctx1  # live: [a0]
// [Asm]   ret  # live: []
// [Asm] 
// [Asm] # block info: defs: [t1, ft0, ft1, a1, fa1, fa2, ft6, a4, fa6, a6, ft5, ft10, ft7, ft4, ft9, a5, a0, fa4, ft2, a2, a3, v24, ft8, a7, t3, fa7, t0, fa5, fa3, ft3, v23, fa0, t4, t2], uses: [v5, a1, v21, a0, v23], upward_exposed: [v5, v21], params_defs: []
// [Asm] # live_in: [v5, v21, zero, v7, v8, v4, v6, s11, v9, v3], live_out: [v5, zero, v8, v7, v4, v6, v24, s11, v9, v3]
// [Asm] # block parameters: []
// [Asm] .aux.12705_32:
// [Asm]   # save_ctx2  # live: [v5, v21, zero, v7, v8, v4, v6, s11, v9, v3]
// [Asm]   mv a0, v21  # live: [v5, zero, a0, v7, v8, v4, v6, s11, v9, v3]
// [Asm]   mv a1, v5  # live: [v5, zero, a0, v7, v8, v4, v6, a1, s11, v9, v3]
// [Asm]   call aux.12700  # live: [v5, zero, a0, v7, v8, v4, v6, s11, v9, v3]
// [Asm]   mv v23, a0  # live: [v5, zero, v23, v7, v8, v4, v6, s11, v9, v3]
// [Asm]   # restore_ctx2  # live: [v5, zero, v23, v7, v8, v4, v6, s11, v9, v3]
// [Asm] # control
// [Asm]   mv v24, v23  # live: [v5, zero, v7, v8, v4, v6, v24, s11, v9, v3]
// [Asm] 
// [Asm] # block info: defs: [v66, s11, v13, v27], uses: [v66, s11, v24, v13], upward_exposed: [s11, v24], params_defs: [v24]
// [Asm] # live_in: [v5, zero, v8, v7, v4, v6, v24, s11, v9, v3], live_out: [v5, zero, v27, v8, v7, v4, v6, s11, v9, v3]
// [Asm] # block parameters: [v24]
// [Asm] .aux.12705_35:
// [Asm]   addi v13, s11, -8  # live: [v5, zero, v13, v7, v8, v4, v6, v24, v9, v3]
// [Asm]   andi s11, v13, -8  # live: [v5, zero, v13, v7, v8, v4, v6, s11, v24, v9, v3]
// [Asm]   li v66, 1  # live: [v66, v5, zero, v13, v7, v8, v4, v6, s11, v24, v9, v3]
// [Asm]   sw v66, 0(v13)  # live: [v5, zero, v13, v7, v8, v4, v6, s11, v24, v9, v3]
// [Asm]   sw v24, 4(v13)  # live: [v5, zero, v13, v7, v8, v4, v6, s11, v9, v3]
// [Asm] # control
// [Asm]   mv v27, v13  # live: [v5, zero, v27, v7, v8, v4, v6, s11, v9, v3]
// [Asm]   j .aux.12705_33  # live: [v5, zero, v27, v7, v8, v4, v6, s11, v9, v3]
// [Asm] 
// [Asm] # block info: defs: [], uses: [], upward_exposed: [], params_defs: []
// [Asm] # live_in: [v5, zero, v30, v8, v7, v4, v6, s11, v9, v3], live_out: [v5, zero, v30, v8, v7, v4, v6, s11, v9, v3]
// [Asm] # block parameters: []
// [Asm] .aux.12705_19:
// [Asm] # control
// [Asm] 
// [Asm] # block info: defs: [], uses: [v6, v30], upward_exposed: [v6, v30], params_defs: []
// [Asm] # live_in: [v5, zero, v30, v8, v7, v4, v6, s11, v9, v3], live_out: [v5, zero, v30, v8, v7, v4, v6, s11, v9, v3]
// [Asm] # block parameters: []
// [Asm] .aux.12705_26:
// [Asm] # control
// [Asm]   blt v30, v6, .aux.12705_28  # live: [v5, zero, v30, v7, v8, v4, v6, s11, v9, v3]
// [Asm] 
// [Asm] # block info: defs: [v33], uses: [zero], upward_exposed: [zero], params_defs: []
// [Asm] # live_in: [v5, zero, v30, v8, v7, v4, v6, s11, v9, v3], live_out: [v5, zero, v30, v8, v7, v4, v6, s11, v33, v9, v3]
// [Asm] # block parameters: []
// [Asm] .aux.12705_27:
// [Asm] # control
// [Asm]   mv v33, zero  # live: [v5, zero, v30, v7, v8, v4, v6, s11, v33, v9, v3]
// [Asm] 
// [Asm] # block info: defs: [v34], uses: [v33], upward_exposed: [v33], params_defs: [v33]
// [Asm] # live_in: [v5, zero, v30, v8, v7, v4, v6, s11, v33, v9, v3], live_out: [v5, zero, v30, v8, v7, v4, v6, s11, v34, v9, v3]
// [Asm] # block parameters: [v33]
// [Asm] .aux.12705_29:
// [Asm] # control
// [Asm]   mv v34, v33  # live: [v5, zero, v30, v7, v8, v4, v6, s11, v34, v9, v3]
// [Asm] 
// [Asm] # block info: defs: [], uses: [v34, zero], upward_exposed: [v34, zero], params_defs: [v34]
// [Asm] # live_in: [v5, zero, v30, v8, v7, v4, v6, s11, v34, v9, v3], live_out: [v5, zero, v30, v8, v7, v4, v6, s11, v9, v3]
// [Asm] # block parameters: [v34]
// [Asm] .aux.12705_24:
// [Asm] # control
// [Asm]   bne v34, zero, .aux.12705_21  # live: [v5, zero, v30, v7, v8, v4, v6, s11, v9, v3]
// [Asm] 
// [Asm] # block info: defs: [v11, v37, s11, v60], uses: [v11, s11, v60, v30], upward_exposed: [s11, v30], params_defs: []
// [Asm] # live_in: [v5, zero, v30, v8, v7, v4, v6, s11, v9, v3], live_out: [v5, zero, v8, v7, v37, v4, v6, s11, v9, v3]
// [Asm] # block parameters: []
// [Asm] .aux.12705_20:
// [Asm]   addi v11, s11, -8  # live: [v11, v5, zero, v30, v7, v8, v4, v6, v9, v3]
// [Asm]   andi s11, v11, -8  # live: [v11, v5, zero, v30, v7, v8, v4, v6, s11, v9, v3]
// [Asm]   li v60, 1  # live: [v11, v5, zero, v30, v7, v8, v4, v6, s11, v9, v60, v3]
// [Asm]   sw v60, 0(v11)  # live: [v11, v5, zero, v30, v7, v8, v4, v6, s11, v9, v3]
// [Asm]   sw v30, 4(v11)  # live: [v11, v5, zero, v7, v8, v4, v6, s11, v9, v3]
// [Asm] # control
// [Asm]   mv v37, v11  # live: [v5, zero, v7, v8, v37, v4, v6, s11, v9, v3]
// [Asm] 
// [Asm] # block info: defs: [v39], uses: [v37], upward_exposed: [v37], params_defs: [v37]
// [Asm] # live_in: [v5, zero, v8, v7, v37, v4, v6, s11, v9, v3], live_out: [v5, zero, v8, v7, v4, v6, s11, v9, v39, v3]
// [Asm] # block parameters: [v37]
// [Asm] .aux.12705_22:
// [Asm] # control
// [Asm]   mv v39, v37  # live: [v5, zero, v7, v8, v4, v6, s11, v9, v39, v3]
// [Asm]   j .aux.12705_23  # live: [v5, zero, v7, v8, v4, v6, s11, v9, v39, v3]
// [Asm] 
// [Asm] # block info: defs: [v61, v33], uses: [v61], upward_exposed: [], params_defs: []
// [Asm] # live_in: [v5, zero, v30, v8, v7, v4, v6, s11, v9, v3], live_out: [v5, zero, v30, v8, v7, v4, v6, s11, v33, v9, v3]
// [Asm] # block parameters: []
// [Asm] .aux.12705_28:
// [Asm] # control
// [Asm]   li v61, 1  # live: [v5, zero, v30, v7, v8, v4, v6, s11, v61, v9, v3]
// [Asm]   mv v33, v61  # live: [v5, zero, v30, v7, v8, v4, v6, s11, v33, v9, v3]
// [Asm]   j .aux.12705_29  # live: [v5, zero, v30, v7, v8, v4, v6, s11, v33, v9, v3]
// [Asm] 
// [Asm] # block info: defs: [v17], uses: [zero], upward_exposed: [zero], params_defs: []
// [Asm] # live_in: [v5, zero, v8, v7, v4, v6, s11, v9, v3], live_out: [v5, zero, v8, v7, v4, v17, v6, s11, v9, v3]
// [Asm] # block parameters: []
// [Asm] .aux.12705_21:
// [Asm] # control
// [Asm]   mv v17, zero  # live: [v5, zero, v7, v8, v4, v17, v6, s11, v9, v3]
// [Asm]   j .aux.12705_17  # live: [v5, zero, v7, v8, v4, v17, v6, s11, v9, v3]
// [Asm] 
// [Asm] # block info: defs: [], uses: [], upward_exposed: [], params_defs: []
// [Asm] # live_in: [v5, v42, zero, v8, v7, v4, v6, s11, v9, v3], live_out: [v5, v42, zero, v8, v7, v4, v6, s11, v9, v3]
// [Asm] # block parameters: []
// [Asm] .aux.12705_4:
// [Asm] # control
// [Asm] 
// [Asm] # block info: defs: [], uses: [v42, v7], upward_exposed: [v42, v7], params_defs: []
// [Asm] # live_in: [v5, v42, zero, v8, v7, v4, v6, s11, v9, v3], live_out: [v5, zero, v42, v8, v7, v4, v6, s11, v9, v3]
// [Asm] # block parameters: []
// [Asm] .aux.12705_11:
// [Asm] # control
// [Asm]   blt v7, v42, .aux.12705_13  # live: [v5, zero, v42, v7, v8, v4, v6, s11, v9, v3]
// [Asm] 
// [Asm] # block info: defs: [v45], uses: [zero], upward_exposed: [zero], params_defs: []
// [Asm] # live_in: [v5, zero, v42, v8, v7, v4, v6, s11, v9, v3], live_out: [v5, zero, v42, v8, v45, v7, v4, v6, s11, v9, v3]
// [Asm] # block parameters: []
// [Asm] .aux.12705_12:
// [Asm] # control
// [Asm]   mv v45, zero  # live: [v5, zero, v42, v45, v7, v8, v4, v6, s11, v9, v3]
// [Asm] 
// [Asm] # block info: defs: [v46], uses: [v45], upward_exposed: [v45], params_defs: [v45]
// [Asm] # live_in: [v5, zero, v42, v8, v45, v7, v4, v6, s11, v9, v3], live_out: [v46, v5, zero, v42, v8, v7, v4, v6, s11, v9, v3]
// [Asm] # block parameters: [v45]
// [Asm] .aux.12705_14:
// [Asm] # control
// [Asm]   mv v46, v45  # live: [v46, v5, zero, v42, v7, v8, v4, v6, s11, v9, v3]
// [Asm] 
// [Asm] # block info: defs: [], uses: [v46, zero], upward_exposed: [v46, zero], params_defs: [v46]
// [Asm] # live_in: [v46, v5, zero, v42, v8, v7, v4, v6, s11, v9, v3], live_out: [v5, v42, zero, v8, v7, v4, v6, s11, v9, v3]
// [Asm] # block parameters: [v46]
// [Asm] .aux.12705_9:
// [Asm] # control
// [Asm]   bne v46, zero, .aux.12705_6  # live: [v5, v42, zero, v7, v8, v4, v6, s11, v9, v3]
// [Asm] 
// [Asm] # block info: defs: [v10, s11, v49, v54], uses: [s11, v10, v54, v42], upward_exposed: [s11, v42], params_defs: []
// [Asm] # live_in: [s11, v42], live_out: [v49]
// [Asm] # block parameters: []
// [Asm] .aux.12705_5:
// [Asm]   addi v10, s11, -8  # live: [v10, v42]
// [Asm]   andi s11, v10, -8  # live: [v10, v42]
// [Asm]   li v54, 1  # live: [v10, v42, v54]
// [Asm]   sw v54, 0(v10)  # live: [v10, v42]
// [Asm]   sw v42, 4(v10)  # live: [v10]
// [Asm] # control
// [Asm]   mv v49, v10  # live: [v49]
// [Asm] 
// [Asm] # block info: defs: [v51], uses: [v49], upward_exposed: [v49], params_defs: [v49]
// [Asm] # live_in: [v49], live_out: [v51]
// [Asm] # block parameters: [v49]
// [Asm] .aux.12705_7:
// [Asm] # control
// [Asm]   mv v51, v49  # live: [v51]
// [Asm]   j .aux.12705_8  # live: [v51]
// [Asm] 
// [Asm] # block info: defs: [v55, v45], uses: [v55], upward_exposed: [], params_defs: []
// [Asm] # live_in: [v5, zero, v42, v8, v7, v4, v6, s11, v9, v3], live_out: [v5, zero, v42, v8, v45, v7, v4, v6, s11, v9, v3]
// [Asm] # block parameters: []
// [Asm] .aux.12705_13:
// [Asm] # control
// [Asm]   li v55, 1  # live: [v5, zero, v42, v7, v8, v4, v6, s11, v9, v55, v3]
// [Asm]   mv v45, v55  # live: [v5, zero, v42, v45, v7, v8, v4, v6, s11, v9, v3]
// [Asm]   j .aux.12705_14  # live: [v5, zero, v42, v45, v7, v8, v4, v6, s11, v9, v3]
// [Asm] 
// [Asm] # block info: defs: [v16], uses: [zero], upward_exposed: [zero], params_defs: []
// [Asm] # live_in: [v5, zero, v8, v7, v4, v6, s11, v9, v3], live_out: [v16, v5, zero, v8, v7, v4, v6, s11, v9, v3]
// [Asm] # block parameters: []
// [Asm] .aux.12705_6:
// [Asm] # control
// [Asm]   mv v16, zero  # live: [v16, v5, zero, v7, v8, v4, v6, s11, v9, v3]
// [Asm]   j .aux.12705_2  # live: [v16, v5, zero, v7, v8, v4, v6, s11, v9, v3]
// [Asm] 
// [Asm] # leaf true
// [Asm] aux.12698:
// [Asm] # block info: defs: [v3, v7, v4, v2], uses: [v3, a2, v4, a1, a0, v7], upward_exposed: [a2, a1, a0], params_defs: []
// [Asm] # live_in: [a2, a1, s11, a0, zero], live_out: [v4, s11, zero, v7]
// [Asm] # block parameters: []
// [Asm] .aux.12698_0:
// [Asm]   # save_ctx1  # live: [a2, a1, s11, zero, a0]
// [Asm]   mv v2, a0  # live: [a2, a1, s11, zero]
// [Asm]   mv v3, a1  # live: [a2, s11, zero, v3]
// [Asm]   mv v4, a2  # live: [v4, s11, zero, v3]
// [Asm]   lw v7, 0(v4)  # live: [v3, v4, s11, zero, v7]
// [Asm] # control
// [Asm]   beq v7, v3, .aux.12698_1  # live: [v4, s11, zero, v7]
// [Asm] 
// [Asm] # block info: defs: [v6, v16, s11, v9, v13], uses: [v16, v7, v4, v6, s11, v9], upward_exposed: [v4, s11, v7], params_defs: []
// [Asm] # live_in: [v4, s11, v7], live_out: [v13]
// [Asm] # block parameters: []
// [Asm] .aux.12698_2:
// [Asm]   addi v9, v7, 1  # live: [v4, s11, v9, v7]
// [Asm]   sw v9, 0(v4)  # live: [s11, v7]
// [Asm]   addi v6, s11, -8  # live: [v6, v7]
// [Asm]   andi s11, v6, -8  # live: [v6, v7]
// [Asm]   li v16, 1  # live: [v6, v16, v7]
// [Asm]   sw v16, 0(v6)  # live: [v6, v7]
// [Asm]   sw v7, 4(v6)  # live: [v6]
// [Asm] # control
// [Asm]   mv v13, v6  # live: [v13]
// [Asm] 
// [Asm] # block info: defs: [a0], uses: [v13, a0], upward_exposed: [v13], params_defs: [v13]
// [Asm] # live_in: [v13], live_out: []
// [Asm] # block parameters: [v13]
// [Asm] .aux.12698_3:
// [Asm] # control
// [Asm]   mv a0, v13  # live: [a0]
// [Asm]   # restore_ctx1  # live: [a0]
// [Asm]   ret  # live: []
// [Asm] 
// [Asm] # block info: defs: [v5, s11, v13], uses: [v5, s11, zero], upward_exposed: [s11, zero], params_defs: []
// [Asm] # live_in: [s11, zero], live_out: [v13]
// [Asm] # block parameters: []
// [Asm] .aux.12698_1:
// [Asm]   addi v5, s11, -8  # live: [v5, zero]
// [Asm]   andi s11, v5, -8  # live: [v5, zero]
// [Asm]   sw zero, 0(v5)  # live: [v5, zero]
// [Asm]   sw zero, 4(v5)  # live: [v5]
// [Asm] # control
// [Asm]   mv v13, v5  # live: [v13]
// [Asm]   j .aux.12698_3  # live: [v13]
// [Asm] 
// [Asm] # leaf false
// [Asm] aux.12699:
// [Asm] # block info: defs: [v3, v4, v5, v6, v2], uses: [a2, a1, a3, a0, a4], upward_exposed: [a2, a1, a3, a0, a4], params_defs: []
// [Asm] # live_in: [a0, zero, a4, a2, a1, a3, s11], live_out: [v5, zero, v4, v6, s11, v3]
// [Asm] # block parameters: []
// [Asm] .aux.12699_0:
// [Asm]   # save_ctx1  # live: [zero, a0, a4, a2, a1, s11, a3]
// [Asm]   mv v2, a0  # live: [a2, a1, s11, a3, zero, a4]
// [Asm]   mv v3, a1  # live: [a2, s11, a3, zero, a4, v3]
// [Asm]   mv v4, a2  # live: [v4, s11, a3, zero, a4, v3]
// [Asm]   mv v5, a3  # live: [v4, v5, s11, zero, a4, v3]
// [Asm]   mv v6, a4  # live: [v4, v5, v6, s11, zero, v3]
// [Asm] # control
// [Asm] 
// [Asm] # block info: defs: [v10], uses: [v5, v10, v3], upward_exposed: [v5, v3], params_defs: []
// [Asm] # live_in: [v5, zero, v4, v6, s11, v3], live_out: [v5, v10, zero, v4, v6, s11]
// [Asm] # block parameters: []
// [Asm] .aux.12699_6:
// [Asm]   lw v10, 0(v5)  # live: [v5, v10, zero, v4, v6, s11, v3]
// [Asm] # control
// [Asm]   beq v10, v3, .aux.12699_7  # live: [v4, v5, v6, v10, s11, zero]
// [Asm] 
// [Asm] # block info: defs: [v16, v12, s11, v31, v8], uses: [v5, v10, v8, v12, s11, v31], upward_exposed: [v5, v10, s11], params_defs: []
// [Asm] # live_in: [v5, v10, zero, v4, v6, s11], live_out: [v4, v16, v6, s11, zero]
// [Asm] # block parameters: []
// [Asm] .aux.12699_8:
// [Asm]   addi v12, v10, 1  # live: [v5, v10, zero, v4, v6, s11, v12]
// [Asm]   sw v12, 0(v5)  # live: [v10, zero, v4, v6, s11]
// [Asm]   addi v8, s11, -8  # live: [v10, zero, v8, v4, v6]
// [Asm]   andi s11, v8, -8  # live: [v10, zero, v8, v4, v6, s11]
// [Asm]   li v31, 1  # live: [v10, zero, v8, v4, v6, s11, v31]
// [Asm]   sw v31, 0(v8)  # live: [v10, zero, v8, v4, v6, s11]
// [Asm]   sw v10, 4(v8)  # live: [v4, v6, s11, zero, v8]
// [Asm] # control
// [Asm]   mv v16, v8  # live: [v4, v16, v6, s11, zero]
// [Asm] 
// [Asm] # block info: defs: [v17], uses: [v16], upward_exposed: [v16], params_defs: [v16]
// [Asm] # live_in: [v4, v16, v6, s11, zero], live_out: [v4, v17, v6, s11, zero]
// [Asm] # block parameters: [v16]
// [Asm] .aux.12699_9:
// [Asm] # control
// [Asm]   mv v17, v16  # live: [v4, v17, v6, s11, zero]
// [Asm] 
// [Asm] # block info: defs: [v19, v18], uses: [v17, v18, zero], upward_exposed: [v17, zero], params_defs: [v17]
// [Asm] # live_in: [v4, v17, v6, s11, zero], live_out: [v19, v4, v6, s11]
// [Asm] # block parameters: [v17]
// [Asm] .aux.12699_4:
// [Asm]   lw v18, 0(v17)  # live: [v4, v6, v17, v18, s11, zero]
// [Asm]   lw v19, 4(v17)  # live: [v19, v4, v6, s11, v18, zero]
// [Asm] # control
// [Asm]   bne v18, zero, .aux.12699_2  # live: [v19, v4, v6, s11]
// [Asm] 
// [Asm] # block info: defs: [t1, v22, ft0, ft1, a1, fa1, fa2, ft6, a4, fa6, a6, ft5, ft10, ft7, ft4, ft9, a5, a0, fa4, ft2, a2, a3, ft8, a7, t3, fa7, t0, fa5, fa3, ft3, v23, fa0, t4, t2], uses: [v4, a2, a1, v6, a0, v22], upward_exposed: [v4, v6], params_defs: []
// [Asm] # live_in: [v4, v6], live_out: [v23]
// [Asm] # block parameters: []
// [Asm] .aux.12699_1:
// [Asm]   # save_ctx2  # live: [v4, v6, a0]
// [Asm]   mv a1, v4  # live: [a1, v6, a0]
// [Asm]   mv a2, v6  # live: [a2, a1, a0]
// [Asm]   call aux.12698  # live: [a0]
// [Asm]   mv v22, a0  # live: [v22]
// [Asm]   # restore_ctx2  # live: [v22]
// [Asm] # control
// [Asm]   mv v23, v22  # live: [v23]
// [Asm] 
// [Asm] # block info: defs: [a0], uses: [a0, v23], upward_exposed: [v23], params_defs: [v23]
// [Asm] # live_in: [v23], live_out: []
// [Asm] # block parameters: [v23]
// [Asm] .aux.12699_3:
// [Asm] # control
// [Asm]   mv a0, v23  # live: [a0]
// [Asm]   # restore_ctx1  # live: [a0]
// [Asm]   ret  # live: []
// [Asm] 
// [Asm] # block info: defs: [v16, s11, v7], uses: [s11, zero, v7], upward_exposed: [s11, zero], params_defs: []
// [Asm] # live_in: [v4, v6, s11, zero], live_out: [v4, v16, v6, s11, zero]
// [Asm] # block parameters: []
// [Asm] .aux.12699_7:
// [Asm]   addi v7, s11, -8  # live: [v4, v6, zero, v7]
// [Asm]   andi s11, v7, -8  # live: [v4, v6, s11, zero, v7]
// [Asm]   sw zero, 0(v7)  # live: [v4, v6, s11, zero, v7]
// [Asm]   sw zero, 4(v7)  # live: [v4, v6, s11, zero, v7]
// [Asm] # control
// [Asm]   mv v16, v7  # live: [v4, v16, v6, s11, zero]
// [Asm]   j .aux.12699_9  # live: [v4, v16, v6, s11, zero]
// [Asm] 
// [Asm] # block info: defs: [s11, v9, v26, v23], uses: [v19, s11, v9, v26], upward_exposed: [v19, s11], params_defs: []
// [Asm] # live_in: [v19, s11], live_out: [v23]
// [Asm] # block parameters: []
// [Asm] .aux.12699_2:
// [Asm]   addi v9, s11, -8  # live: [v19, v9]
// [Asm]   andi s11, v9, -8  # live: [v19, v9]
// [Asm]   li v26, 1  # live: [v19, v9, v26]
// [Asm]   sw v26, 0(v9)  # live: [v19, v9]
// [Asm]   sw v19, 4(v9)  # live: [v9]
// [Asm] # control
// [Asm]   mv v23, v9  # live: [v23]
// [Asm]   j .aux.12699_3  # live: [v23]
// [Asm] 
// [Asm] # leaf false
// [Asm] main.12696:
// [Asm] # block info: defs: [v3, v11, v5, v10, v36, v37, s11, v12, v31, v33, v35, v4, v38, v34, v2], uses: [v3, v5, v36, v37, s11, v31, v33, zero, v35, v4, v38, v34, v2], upward_exposed: [s11, zero], params_defs: []
// [Asm] # live_in: [s11, zero], live_out: [v11, v10, v12, zero]
// [Asm] # block parameters: []
// [Asm] .main.12696_0:
// [Asm]   # save_ctx1  # live: [zero, s11]
// [Asm]   addi v2, s11, -4  # live: [zero, v2]
// [Asm]   andi s11, v2, -8  # live: [zero, s11, v2]
// [Asm]   sw zero, 0(v2)  # live: [zero, s11, v2]
// [Asm]   addi v3, s11, -4  # live: [v3, zero, v2]
// [Asm]   andi s11, v3, -8  # live: [v3, zero, s11, v2]
// [Asm]   sw zero, 0(v3)  # live: [v3, zero, s11, v2]
// [Asm]   addi v4, s11, -64  # live: [v3, zero, v4, v2]
// [Asm]   andi s11, v4, -8  # live: [v3, zero, v4, s11, v2]
// [Asm]   la v33, aux.12707  # live: [v3, zero, v4, s11, v33, v2]
// [Asm]   sd v33, 0(v4)  # live: [v3, zero, v4, s11, v2]
// [Asm]   li v34, 100  # live: [v3, zero, v4, s11, v34, v2]
// [Asm]   sd v34, 8(v4)  # live: [v3, zero, v4, s11, v2]
// [Asm]   li v35, 1000  # live: [v3, zero, v35, v4, s11, v2]
// [Asm]   sd v35, 16(v4)  # live: [v3, zero, v4, s11, v2]
// [Asm]   li v36, 1  # live: [v3, zero, v36, v4, s11, v2]
// [Asm]   sd v36, 24(v4)  # live: [v3, zero, v4, s11, v2]
// [Asm]   li v37, 50  # live: [v3, zero, v4, v37, s11, v2]
// [Asm]   sd v37, 32(v4)  # live: [v3, zero, v4, s11, v2]
// [Asm]   li v38, 1200  # live: [v3, zero, v4, v38, s11, v2]
// [Asm]   sd v38, 40(v4)  # live: [v2, v4, s11, zero, v3]
// [Asm]   sd v2, 48(v4)  # live: [v4, s11, zero, v3]
// [Asm]   sd v3, 56(v4)  # live: [v4, s11, zero]
// [Asm]   addi v5, s11, -8  # live: [v4, v5, zero]
// [Asm]   andi s11, v5, -8  # live: [v4, v5, zero]
// [Asm]   la v31, add.12708  # live: [v4, v5, v31, zero]
// [Asm]   sd v31, 0(v5)  # live: [v4, v5, zero]
// [Asm] # control
// [Asm]   mv v10, v4  # live: [v5, v10, zero]
// [Asm]   mv v11, v5  # live: [v11, v10, zero]
// [Asm]   mv v12, zero  # live: [v11, v10, v12, zero]
// [Asm] 
// [Asm] # block info: defs: [t1, v14, v13, ft0, ft1, a1, v28, fa1, fa2, ft6, a4, fa6, a6, ft5, ft10, ft7, ft4, ft9, a5, a0, fa4, ft2, a2, a3, s10, ft8, t3, a7, fa7, t0, fa5, fa3, ft3, fa0, t4, t2, v15], uses: [v14, v10, v28, a0, v13, zero], upward_exposed: [v10, zero], params_defs: [v11, v10, v12]
// [Asm] # live_in: [v11, v10, v12, zero], live_out: [v11, v12, v15, v10, zero]
// [Asm] # block parameters: [v10, v11, v12]
// [Asm] .main.12696_2:
// [Asm]   mv s10, v10  # live: [v11, v10, zero, a0, v12]
// [Asm]   ld v28, 0(v10)  # live: [v11, v10, zero, a0, v12, v28]
// [Asm]   # save_ctx2  # live: [v11, v10, zero, a0, v12, v28]
// [Asm]   jalr v28  # live: [v11, v10, zero, a0, v12]
// [Asm]   mv v13, a0  # live: [v11, v10, zero, v13, v12]
// [Asm]   # restore_ctx2  # live: [v11, v10, zero, v13, v12]
// [Asm]   lw v14, 0(v13)  # live: [v11, v14, v10, zero, v13, v12]
// [Asm]   lw v15, 4(v13)  # live: [v11, v14, v10, zero, v12, v15]
// [Asm] # control
// [Asm]   bne v14, zero, .main.12696_4  # live: [v11, v12, v15, v10, zero]
// [Asm] 
// [Asm] # block info: defs: [t1, ft0, ft1, a1, fa1, fa2, ft6, a4, fa6, v20, v19, a6, ft5, ft10, ft7, ft4, ft9, v21, a5, fa4, a0, ft2, a2, a3, ft8, a7, t3, fa7, t0, fa5, v18, fa3, ft3, fa0, t4, t2], uses: [v12, v21, a0, zero], upward_exposed: [v12, zero], params_defs: []
// [Asm] # live_in: [v12, zero], live_out: [v20]
// [Asm] # block parameters: []
// [Asm] .main.12696_3:
// [Asm]   # save_ctx2  # live: [v12, zero]
// [Asm]   mv a0, v12  # live: [zero, a0]
// [Asm]   call minimbt_print_int  # live: [zero, a0]
// [Asm]   mv v18, a0  # live: [zero]
// [Asm]   # restore_ctx2  # live: [zero]
// [Asm]   # save_ctx2  # live: [zero]
// [Asm]   li v21, 10  # live: [v21, zero]
// [Asm]   mv a0, v21  # live: [zero, a0]
// [Asm]   call minimbt_print_char  # live: [zero, a0]
// [Asm]   mv v19, a0  # live: [zero]
// [Asm]   # restore_ctx2  # live: [zero]
// [Asm] # control
// [Asm]   mv v20, zero  # live: [v20]
// [Asm] 
// [Asm] # block info: defs: [a0], uses: [a0, v20], upward_exposed: [v20], params_defs: [v20]
// [Asm] # live_in: [v20], live_out: []
// [Asm] # block parameters: [v20]
// [Asm] .main.12696_5:
// [Asm] # control
// [Asm]   mv a0, v20  # live: [a0]
// [Asm]   # restore_ctx1  # live: [a0]
// [Asm]   ret  # live: []
// [Asm] 
// [Asm] # block info: defs: [t1, ft0, ft1, a1, v12, fa1, fa2, ft6, a4, fa6, a6, ft5, ft10, ft7, ft4, ft9, a5, a0, fa4, ft2, a2, v17, a3, v24, s10, ft8, t3, a7, fa7, t0, fa5, fa3, ft3, fa0, t4, t2], uses: [v11, v10, a0, a1, v17, v15, v24, v12], upward_exposed: [v11, v12, v15, v10], params_defs: []
// [Asm] # live_in: [v11, v12, v15, v10, zero], live_out: [v11, v10, v12, zero]
// [Asm] # block parameters: []
// [Asm] .main.12696_4:
// [Asm]   mv s10, v11  # live: [v11, v10, v15, v12, zero]
// [Asm]   ld v24, 0(v11)  # live: [v11, v10, v24, v15, v12, zero]
// [Asm]   # save_ctx2  # live: [v11, v10, v24, v15, v12, zero]
// [Asm]   mv a0, v12  # live: [v11, v10, v24, v15, a0, zero]
// [Asm]   mv a1, v15  # live: [v11, a1, v10, v24, zero, a0]
// [Asm]   jalr v24  # live: [v11, v10, zero, a0]
// [Asm]   mv v17, a0  # live: [v11, v17, v10, zero]
// [Asm]   # restore_ctx2  # live: [v11, v17, v10, zero]
// [Asm] # control
// [Asm]   mv v10, v10  # live: [v11, v17, v10, zero]
// [Asm]   mv v11, v11  # live: [v11, v17, v10, zero]
// [Asm]   mv v12, v17  # live: [v11, v10, v12, zero]
// [Asm]   j .main.12696_2  # live: [v11, v10, v12, zero]
// [Asm] 
// [Asm] # leaf false
// [Asm] aux.12707:
// [Asm] # block info: defs: [v2, t1, v7, v0, ft0, ft1, a1, fa1, fa2, ft6, a4, fa6, v8, a6, ft5, ft10, v4, v6, ft7, ft4, v5, ft9, v10, a5, fa4, a0, ft2, a2, a3, v9, ft8, a7, t3, fa7, t0, fa5, fa3, ft3, fa0, t4, t2, v3], uses: [v5, v10, a5, a0, v7, v0, a2, a1, a3, v9, s10, a7, a4, v8, a6, v4, v6, v3], upward_exposed: [s10, a0], params_defs: []
// [Asm] # live_in: [s10, a0], live_out: []
// [Asm] # block parameters: []
// [Asm] .aux.12707_0:
// [Asm]   # save_ctx1  # live: [a0, s10]
// [Asm]   mv v0, s10  # live: [a0, v0]
// [Asm]   mv v2, a0  # live: [a0, v0]
// [Asm]   lw v3, 8(v0)  # live: [a0, v0, v3]
// [Asm]   lw v4, 16(v0)  # live: [a0, v0, v4, v3]
// [Asm]   lw v5, 24(v0)  # live: [v5, a0, v0, v4, v3]
// [Asm]   lw v6, 32(v0)  # live: [v5, a0, v0, v4, v6, v3]
// [Asm]   lw v7, 40(v0)  # live: [v5, a0, v7, v0, v4, v6, v3]
// [Asm]   ld v8, 48(v0)  # live: [v5, a0, v8, v7, v0, v4, v6, v3]
// [Asm]   ld v9, 56(v0)  # live: [v5, a0, v8, v7, v4, v6, v9, v3]
// [Asm]   # save_ctx2  # live: [v5, a0, v8, v7, v4, v6, v9, v3]
// [Asm]   mv a1, v3  # live: [v5, a0, v8, v7, v4, a1, v6, v9]
// [Asm]   mv a2, v4  # live: [v5, a0, v8, v7, a2, a1, v6, v9]
// [Asm]   mv a3, v5  # live: [a0, v8, v7, a2, a1, v6, a3, v9]
// [Asm]   mv a4, v6  # live: [a0, a4, v8, v7, a2, a1, a3, v9]
// [Asm]   mv a5, v7  # live: [a5, a0, a4, v8, a2, a1, a3, v9]
// [Asm]   mv a6, v8  # live: [a5, a0, a4, a6, a2, a1, a3, v9]
// [Asm]   mv a7, v9  # live: [a7, a5, a0, a4, a6, a2, a1, a3]
// [Asm]   call aux.12705  # live: [a0]
// [Asm]   mv v10, a0  # live: [v10]
// [Asm]   # restore_ctx2  # live: [v10]
// [Asm] # control
// [Asm]   mv a0, v10  # live: [a0]
// [Asm]   # restore_ctx1  # live: [a0]
// [Asm]   ret  # live: []
// [Asm] 
// [Asm] # leaf false
// [Asm] T$start:
// [Asm] # block info: defs: [t1, ft0, ft1, a1, fa1, fa2, ft6, a4, fa6, a6, ft5, ft10, ft7, ft4, ft9, a5, a0, fa4, ft2, a2, a3, ft8, a7, t3, fa7, t0, fa5, fa3, ft3, fa0, t4, t2, v2], uses: [a0, v2], upward_exposed: [], params_defs: []
// [Asm] # live_in: [], live_out: []
// [Asm] # block parameters: []
// [Asm] .T$start_0:
// [Asm]   # save_ctx1  # live: []
// [Asm]   # save_ctx2  # live: []
// [Asm]   call main.12696  # live: [a0]
// [Asm]   mv v2, a0  # live: [v2]
// [Asm]   # restore_ctx2  # live: [v2]
// [Asm] # control
// [Asm]   mv a0, v2  # live: [a0]
// [Asm]   # restore_ctx1  # live: [a0]
// [Asm]   ret  # live: []
// [Asm] 
// [Asm] # leaf false
// [Asm] add.12708:
// [Asm] # block info: defs: [v2, t1, v0, ft0, ft1, a1, fa1, fa2, ft6, a4, fa6, a6, ft5, ft10, v4, ft7, ft4, ft9, a5, a0, fa4, ft2, a2, a3, ft8, a7, t3, fa7, t0, fa5, fa3, ft3, fa0, t4, t2, v3], uses: [v2, a0, v4, a1, s10, v3], upward_exposed: [a1, s10, a0], params_defs: []
// [Asm] # live_in: [a1, s10, a0], live_out: []
// [Asm] # block parameters: []
// [Asm] .add.12708_0:
// [Asm]   # save_ctx1  # live: [a1, a0, s10]
// [Asm]   mv v0, s10  # live: [a1, a0]
// [Asm]   mv v2, a0  # live: [a1, v2]
// [Asm]   mv v3, a1  # live: [v2, v3]
// [Asm]   # save_ctx2  # live: [v2, v3]
// [Asm]   mv a0, v2  # live: [a0, v3]
// [Asm]   mv a1, v3  # live: [a1, a0]
// [Asm]   call add.12706  # live: [a0]
// [Asm]   mv v4, a0  # live: [v4]
// [Asm]   # restore_ctx2  # live: [v4]
// [Asm] # control
// [Asm]   mv a0, v4  # live: [a0]
// [Asm]   # restore_ctx1  # live: [a0]
// [Asm]   ret  # live: []
// [Asm] 
// [Asm] # leaf true
// [Asm] add.12706:
// [Asm] # block info: defs: [v3, v4, a0, v2], uses: [v3, v4, a1, a0, v2], upward_exposed: [a1, a0], params_defs: []
// [Asm] # live_in: [a1, a0], live_out: []
// [Asm] # block parameters: []
// [Asm] .add.12706_0:
// [Asm]   # save_ctx1  # live: [a1, a0]
// [Asm]   mv v2, a0  # live: [a1, v2]
// [Asm]   mv v3, a1  # live: [v3, v2]
// [Asm]   add v4, v2, v3  # live: [v4]
// [Asm] # control
// [Asm]   mv a0, v4  # live: [a0]
// [Asm]   # restore_ctx1  # live: [a0]
// [Asm]   ret  # live: []
// [Asm] 
// [Asm] # leaf false
// [Asm] minimbt_main:
// [Asm] # block info: defs: [t1, ft0, ft1, a1, s11, ra, fa1, fa2, ft6, a4, fa6, a6, ft5, ft10, s0, ft7, ft4, ft9, a5, a0, fa4, ft2, a2, sp, a3, ft8, t3, a7, fa7, t0, fa5, fa3, ft3, fa0, t4, t2], uses: [sp, s0, ra, s11, a0], upward_exposed: [s0, ra, s11], params_defs: []
// [Asm] # live_in: [s0, ra, s11], live_out: []
// [Asm] # block parameters: []
// [Asm] .minimbt_main_b0:
// [Asm]   addi sp, sp, -32  # live: [s0, ra, s11]
// [Asm]   sd ra, 0(sp)  # live: [s0, s11]
// [Asm]   sd s0, 8(sp)  # live: [s11]
// [Asm]   sd s11, 16(sp)  # live: []
// [Asm]   la s11, large_heap_end  # live: []
// [Asm]   mv s0, sp  # live: [s0]
// [Asm]   la sp, large_stack_end  # live: [s0]
// [Asm]   call T$start  # live: [s0, a0]
// [Asm]   mv sp, s0  # live: [a0]
// [Asm]   ld ra, 0(sp)  # live: [a0]
// [Asm]   ld s0, 8(sp)  # live: [a0]
// [Asm]   ld s11, 16(sp)  # live: [a0]
// [Asm]   addi sp, sp, 32  # live: [a0]
// [Asm] # control
// [Asm]   ret  # live: []
// [Asm] 
// [Asm] # leaf true
// [Asm] aux.12700:
// [Asm] # block info: defs: [v3, v4, a0, v2], uses: [v2, v4, a1, a0, v3], upward_exposed: [a1, a0], params_defs: []
// [Asm] # live_in: [a1, a0], live_out: []
// [Asm] # block parameters: []
// [Asm] .aux.12700_0:
// [Asm]   # save_ctx1  # live: [a1, a0]
// [Asm]   mv v2, a0  # live: [a1, v2]
// [Asm]   mv v3, a1  # live: [v2, v3]
// [Asm]   add v4, v3, v2  # live: [v4]
// [Asm] # control
// [Asm]   mv a0, v4  # live: [a0]
// [Asm]   # restore_ctx1  # live: [a0]
// [Asm]   ret  # live: []
// [Asm] 
// [Asm] # leaf true
// [Asm] aux.12697:
// [Asm] # block info: defs: [v3, v7, v4, v2], uses: [v3, a2, v4, a1, a0, v7], upward_exposed: [a2, a1, a0], params_defs: []
// [Asm] # live_in: [a2, a1, s11, a0, zero], live_out: [v4, s11, zero, v7]
// [Asm] # block parameters: []
// [Asm] .aux.12697_0:
// [Asm]   # save_ctx1  # live: [a2, a1, s11, zero, a0]
// [Asm]   mv v2, a0  # live: [a2, a1, s11, zero]
// [Asm]   mv v3, a1  # live: [a2, s11, zero, v3]
// [Asm]   mv v4, a2  # live: [v4, s11, zero, v3]
// [Asm]   lw v7, 0(v4)  # live: [v3, v4, s11, zero, v7]
// [Asm] # control
// [Asm]   beq v7, v3, .aux.12697_1  # live: [v4, s11, zero, v7]
// [Asm] 
// [Asm] # block info: defs: [v6, v16, s11, v9, v13], uses: [v16, v7, v4, v6, s11, v9], upward_exposed: [v4, s11, v7], params_defs: []
// [Asm] # live_in: [v4, s11, v7], live_out: [v13]
// [Asm] # block parameters: []
// [Asm] .aux.12697_2:
// [Asm]   addi v9, v7, 1  # live: [v4, s11, v9, v7]
// [Asm]   sw v9, 0(v4)  # live: [s11, v7]
// [Asm]   addi v6, s11, -8  # live: [v6, v7]
// [Asm]   andi s11, v6, -8  # live: [v6, v7]
// [Asm]   li v16, 1  # live: [v6, v16, v7]
// [Asm]   sw v16, 0(v6)  # live: [v6, v7]
// [Asm]   sw v7, 4(v6)  # live: [v6]
// [Asm] # control
// [Asm]   mv v13, v6  # live: [v13]
// [Asm] 
// [Asm] # block info: defs: [a0], uses: [v13, a0], upward_exposed: [v13], params_defs: [v13]
// [Asm] # live_in: [v13], live_out: []
// [Asm] # block parameters: [v13]
// [Asm] .aux.12697_3:
// [Asm] # control
// [Asm]   mv a0, v13  # live: [a0]
// [Asm]   # restore_ctx1  # live: [a0]
// [Asm]   ret  # live: []
// [Asm] 
// [Asm] # block info: defs: [v5, s11, v13], uses: [v5, s11, zero], upward_exposed: [s11, zero], params_defs: []
// [Asm] # live_in: [s11, zero], live_out: [v13]
// [Asm] # block parameters: []
// [Asm] .aux.12697_1:
// [Asm]   addi v5, s11, -8  # live: [v5, zero]
// [Asm]   andi s11, v5, -8  # live: [v5, zero]
// [Asm]   sw zero, 0(v5)  # live: [v5, zero]
// [Asm]   sw zero, 4(v5)  # live: [v5]
// [Asm] # control
// [Asm]   mv v13, v5  # live: [v13]
// [Asm]   j .aux.12697_3  # live: [v13]
// [Asm] 
// [Asm] start:
// [Asm]   .zero 4
// [Asm] 
// [Knf] build_knf: LetRec({name: ("map", Fun([Unit], Tuple([Int, Int]))), args: [("stream", Fun([Unit], Tuple([Int, Int]))), ("f", Fun([Int], Int))], body: LetRec({name: ("aux", Tuple([Int, Int])), args: [("u", Var({val: Some(Unit)}))], body: LetTuple([("ok", Var({val: Some(Int)})), ("val", Var({val: Some(Int)}))], App(Var("stream"), [Unit]), If(Eq(Var("ok"), Int(0)), Tuple([Int(0), Int(0)]), Tuple([Int(1), App(Var("f"), [Var("val")])])))}, Var("aux"))}, LetRec({name: ("filter", Fun([Unit], Tuple([Int, Int]))), args: [("stream", Fun([Unit], Tuple([Int, Int]))), ("f", Fun([Int], Int))], body: LetRec({name: ("aux", Tuple([Int, Int])), args: [("u", Var({val: Some(Unit)}))], body: LetTuple([("ok", Var({val: Some(Int)})), ("val", Var({val: Some(Int)}))], App(Var("stream"), [Unit]), If(Eq(Var("ok"), Int(0)), Tuple([Int(0), Int(0)]), Let(("r", Var({val: Some(Int)})), App(Var("f"), [Var("val")]), If(Eq(Var("r"), Int(0)), Tuple([Int(1), Var("val")]), App(Var("aux"), [Unit])))))}, Var("aux"))}, LetRec({name: ("concat", Fun([Unit], Tuple([Int, Int]))), args: [("stream1", Fun([Unit], Tuple([Int, Int]))), ("stream2", Fun([Unit], Tuple([Int, Int])))], body: LetRec({name: ("aux", Tuple([Int, Int])), args: [("u", Var({val: Some(Unit)}))], body: LetTuple([("ok", Var({val: Some(Int)})), ("val", Var({val: Some(Int)}))], App(Var("stream1"), [Unit]), If(Eq(Var("ok"), Int(0)), App(Var("stream2"), [Unit]), Tuple([Int(1), Var("val")])))}, Var("aux"))}, LetRec({name: ("range", Fun([Unit], Tuple([Int, Int]))), args: [("from", Int), ("to", Int)], body: Let(("state", Var({val: Some(Array(Int))})), Array(Int(1), Var("from")), LetRec({name: ("aux", Tuple([Int, Int])), args: [("u", Var({val: Some(Unit)}))], body: Let(("val", Var({val: Some(Int)})), Get(Var("state"), Int(0)), If(Eq(Var("val"), Var("to")), Tuple([Int(0), Int(0)]), Let(("_", Var({val: Some(Unit)})), Put(Var("state"), Int(0), Prim(Var("val"), Int(1), Add, kind=Some(Int))), Tuple([Int(1), Var("val")]))))}, Var("aux")))}, LetRec({name: ("addx", Fun([Int], Int)), args: [("x", Int)], body: LetRec({name: ("aux", Int), args: [("y", Int)], body: Prim(Var("x"), Var("y"), Add, kind=Some(Int))}, Var("aux"))}, LetRec({name: ("fold", Int), args: [("stream", Fun([Unit], Tuple([Int, Int]))), ("f", Fun([Int, Int], Int)), ("acc", Int)], body: LetTuple([("ok", Var({val: Some(Int)})), ("val", Var({val: Some(Int)}))], App(Var("stream"), [Unit]), If(Eq(Var("ok"), Int(0)), Var("acc"), App(Var("fold"), [Var("stream"), Var("f"), App(Var("f"), [Var("acc"), Var("val")])])))}, LetRec({name: ("sum", Int), args: [("stream", Fun([Unit], Tuple([Int, Int])))], body: LetRec({name: ("add", Int), args: [("x", Int), ("y", Int)], body: Prim(Var("x"), Var("y"), Add, kind=Some(Int))}, App(Var("fold"), [Var("stream"), Var("add"), Int(0)]))}, LetRec({name: ("gt", Fun([Int], Int)), args: [("x", Int)], body: LetRec({name: ("aux", Int), args: [("y", Int)], body: If(LE(Var("x"), Var("y")), Int(0), Int(1))}, Var("aux"))}, LetRec({name: ("le", Fun([Int], Int)), args: [("x", Int)], body: LetRec({name: ("aux", Int), args: [("y", Int)], body: If(LE(Var("y"), Var("x")), Int(0), Int(1))}, Var("aux"))}, LetRec({name: ("main", Var({val: Some(Unit)})), args: [], body: Let(("range100", Var({val: Some(Fun([Unit], Tuple([Int, Int])))})), App(Var("range"), [Int(0), Int(100)]), Let(("range1000", Var({val: Some(Fun([Unit], Tuple([Int, Int])))})), App(Var("range"), [Int(0), Int(1000)]), Let(("catt", Var({val: Some(Fun([Unit], Tuple([Int, Int])))})), App(Var("concat"), [Var("range100"), Var("range1000")]), Let(("addone", Var({val: Some(Fun([Unit], Tuple([Int, Int])))})), App(Var("map"), [Var("catt"), App(Var("addx"), [Int(1)])]), Let(("over50", Var({val: Some(Fun([Unit], Tuple([Int, Int])))})), App(Var("filter"), [Var("addone"), App(Var("gt"), [Int(50)])]), Let(("under1200", Var({val: Some(Fun([Unit], Tuple([Int, Int])))})), App(Var("filter"), [Var("over50"), App(Var("le"), [Int(1200)])]), Let(("sum", Var({val: Some(Int)})), App(Var("sum"), [Var("under1200")]), Let(("_", Var({val: Some(Unit)})), App(Var("print_int"), [Var("sum")]), Let(("_", Var({val: Some(Unit)})), App(Var("print_char"), [Int(10)]), Unit)))))))))}, App(Var("main"), [])))))))))))
// [Knf] build_knf: LetRec({name: ("aux", Tuple([Int, Int])), args: [("u", Var({val: Some(Unit)}))], body: LetTuple([("ok", Var({val: Some(Int)})), ("val", Var({val: Some(Int)}))], App(Var("stream"), [Unit]), If(Eq(Var("ok"), Int(0)), Tuple([Int(0), Int(0)]), Tuple([Int(1), App(Var("f"), [Var("val")])])))}, Var("aux"))
// [Knf] build_knf: LetTuple([("ok", Var({val: Some(Int)})), ("val", Var({val: Some(Int)}))], App(Var("stream"), [Unit]), If(Eq(Var("ok"), Int(0)), Tuple([Int(0), Int(0)]), Tuple([Int(1), App(Var("f"), [Var("val")])])))
// [Knf] build_knf: App(Var("stream"), [Unit])
// [Knf] build_knf: Var("stream")
// [Knf] build_knf: Unit
// [Knf] build_knf: If(Eq(Var("ok"), Int(0)), Tuple([Int(0), Int(0)]), Tuple([Int(1), App(Var("f"), [Var("val")])]))
// [Knf] build_knf: Var("ok")
// [Knf] build_knf: Int(0)
// [Knf] build_knf: Tuple([Int(0), Int(0)])
// [Knf] build_knf: Int(0)
// [Knf] build_knf: Int(0)
// [Knf] build_knf: Tuple([Int(1), App(Var("f"), [Var("val")])])
// [Knf] build_knf: Int(1)
// [Knf] build_knf: App(Var("f"), [Var("val")])
// [Knf] build_knf: Var("f")
// [Knf] build_knf: Var("val")
// [Knf] build_knf: Var("aux")
// [Knf] build_knf: LetRec({name: ("filter", Fun([Unit], Tuple([Int, Int]))), args: [("stream", Fun([Unit], Tuple([Int, Int]))), ("f", Fun([Int], Int))], body: LetRec({name: ("aux", Tuple([Int, Int])), args: [("u", Var({val: Some(Unit)}))], body: LetTuple([("ok", Var({val: Some(Int)})), ("val", Var({val: Some(Int)}))], App(Var("stream"), [Unit]), If(Eq(Var("ok"), Int(0)), Tuple([Int(0), Int(0)]), Let(("r", Var({val: Some(Int)})), App(Var("f"), [Var("val")]), If(Eq(Var("r"), Int(0)), Tuple([Int(1), Var("val")]), App(Var("aux"), [Unit])))))}, Var("aux"))}, LetRec({name: ("concat", Fun([Unit], Tuple([Int, Int]))), args: [("stream1", Fun([Unit], Tuple([Int, Int]))), ("stream2", Fun([Unit], Tuple([Int, Int])))], body: LetRec({name: ("aux", Tuple([Int, Int])), args: [("u", Var({val: Some(Unit)}))], body: LetTuple([("ok", Var({val: Some(Int)})), ("val", Var({val: Some(Int)}))], App(Var("stream1"), [Unit]), If(Eq(Var("ok"), Int(0)), App(Var("stream2"), [Unit]), Tuple([Int(1), Var("val")])))}, Var("aux"))}, LetRec({name: ("range", Fun([Unit], Tuple([Int, Int]))), args: [("from", Int), ("to", Int)], body: Let(("state", Var({val: Some(Array(Int))})), Array(Int(1), Var("from")), LetRec({name: ("aux", Tuple([Int, Int])), args: [("u", Var({val: Some(Unit)}))], body: Let(("val", Var({val: Some(Int)})), Get(Var("state"), Int(0)), If(Eq(Var("val"), Var("to")), Tuple([Int(0), Int(0)]), Let(("_", Var({val: Some(Unit)})), Put(Var("state"), Int(0), Prim(Var("val"), Int(1), Add, kind=Some(Int))), Tuple([Int(1), Var("val")]))))}, Var("aux")))}, LetRec({name: ("addx", Fun([Int], Int)), args: [("x", Int)], body: LetRec({name: ("aux", Int), args: [("y", Int)], body: Prim(Var("x"), Var("y"), Add, kind=Some(Int))}, Var("aux"))}, LetRec({name: ("fold", Int), args: [("stream", Fun([Unit], Tuple([Int, Int]))), ("f", Fun([Int, Int], Int)), ("acc", Int)], body: LetTuple([("ok", Var({val: Some(Int)})), ("val", Var({val: Some(Int)}))], App(Var("stream"), [Unit]), If(Eq(Var("ok"), Int(0)), Var("acc"), App(Var("fold"), [Var("stream"), Var("f"), App(Var("f"), [Var("acc"), Var("val")])])))}, LetRec({name: ("sum", Int), args: [("stream", Fun([Unit], Tuple([Int, Int])))], body: LetRec({name: ("add", Int), args: [("x", Int), ("y", Int)], body: Prim(Var("x"), Var("y"), Add, kind=Some(Int))}, App(Var("fold"), [Var("stream"), Var("add"), Int(0)]))}, LetRec({name: ("gt", Fun([Int], Int)), args: [("x", Int)], body: LetRec({name: ("aux", Int), args: [("y", Int)], body: If(LE(Var("x"), Var("y")), Int(0), Int(1))}, Var("aux"))}, LetRec({name: ("le", Fun([Int], Int)), args: [("x", Int)], body: LetRec({name: ("aux", Int), args: [("y", Int)], body: If(LE(Var("y"), Var("x")), Int(0), Int(1))}, Var("aux"))}, LetRec({name: ("main", Var({val: Some(Unit)})), args: [], body: Let(("range100", Var({val: Some(Fun([Unit], Tuple([Int, Int])))})), App(Var("range"), [Int(0), Int(100)]), Let(("range1000", Var({val: Some(Fun([Unit], Tuple([Int, Int])))})), App(Var("range"), [Int(0), Int(1000)]), Let(("catt", Var({val: Some(Fun([Unit], Tuple([Int, Int])))})), App(Var("concat"), [Var("range100"), Var("range1000")]), Let(("addone", Var({val: Some(Fun([Unit], Tuple([Int, Int])))})), App(Var("map"), [Var("catt"), App(Var("addx"), [Int(1)])]), Let(("over50", Var({val: Some(Fun([Unit], Tuple([Int, Int])))})), App(Var("filter"), [Var("addone"), App(Var("gt"), [Int(50)])]), Let(("under1200", Var({val: Some(Fun([Unit], Tuple([Int, Int])))})), App(Var("filter"), [Var("over50"), App(Var("le"), [Int(1200)])]), Let(("sum", Var({val: Some(Int)})), App(Var("sum"), [Var("under1200")]), Let(("_", Var({val: Some(Unit)})), App(Var("print_int"), [Var("sum")]), Let(("_", Var({val: Some(Unit)})), App(Var("print_char"), [Int(10)]), Unit)))))))))}, App(Var("main"), []))))))))))
// [Knf] build_knf: LetRec({name: ("aux", Tuple([Int, Int])), args: [("u", Var({val: Some(Unit)}))], body: LetTuple([("ok", Var({val: Some(Int)})), ("val", Var({val: Some(Int)}))], App(Var("stream"), [Unit]), If(Eq(Var("ok"), Int(0)), Tuple([Int(0), Int(0)]), Let(("r", Var({val: Some(Int)})), App(Var("f"), [Var("val")]), If(Eq(Var("r"), Int(0)), Tuple([Int(1), Var("val")]), App(Var("aux"), [Unit])))))}, Var("aux"))
// [Knf] build_knf: LetTuple([("ok", Var({val: Some(Int)})), ("val", Var({val: Some(Int)}))], App(Var("stream"), [Unit]), If(Eq(Var("ok"), Int(0)), Tuple([Int(0), Int(0)]), Let(("r", Var({val: Some(Int)})), App(Var("f"), [Var("val")]), If(Eq(Var("r"), Int(0)), Tuple([Int(1), Var("val")]), App(Var("aux"), [Unit])))))
// [Knf] build_knf: App(Var("stream"), [Unit])
// [Knf] build_knf: Var("stream")
// [Knf] build_knf: Unit
// [Knf] build_knf: If(Eq(Var("ok"), Int(0)), Tuple([Int(0), Int(0)]), Let(("r", Var({val: Some(Int)})), App(Var("f"), [Var("val")]), If(Eq(Var("r"), Int(0)), Tuple([Int(1), Var("val")]), App(Var("aux"), [Unit]))))
// [Knf] build_knf: Var("ok")
// [Knf] build_knf: Int(0)
// [Knf] build_knf: Tuple([Int(0), Int(0)])
// [Knf] build_knf: Int(0)
// [Knf] build_knf: Int(0)
// [Knf] build_knf: Let(("r", Var({val: Some(Int)})), App(Var("f"), [Var("val")]), If(Eq(Var("r"), Int(0)), Tuple([Int(1), Var("val")]), App(Var("aux"), [Unit])))
// [Knf] build_knf: App(Var("f"), [Var("val")])
// [Knf] build_knf: Var("f")
// [Knf] build_knf: Var("val")
// [Knf] build_knf: If(Eq(Var("r"), Int(0)), Tuple([Int(1), Var("val")]), App(Var("aux"), [Unit]))
// [Knf] build_knf: Var("r")
// [Knf] build_knf: Int(0)
// [Knf] build_knf: Tuple([Int(1), Var("val")])
// [Knf] build_knf: Int(1)
// [Knf] build_knf: Var("val")
// [Knf] build_knf: App(Var("aux"), [Unit])
// [Knf] build_knf: Var("aux")
// [Knf] build_knf: Unit
// [Knf] build_knf: Var("aux")
// [Knf] build_knf: LetRec({name: ("concat", Fun([Unit], Tuple([Int, Int]))), args: [("stream1", Fun([Unit], Tuple([Int, Int]))), ("stream2", Fun([Unit], Tuple([Int, Int])))], body: LetRec({name: ("aux", Tuple([Int, Int])), args: [("u", Var({val: Some(Unit)}))], body: LetTuple([("ok", Var({val: Some(Int)})), ("val", Var({val: Some(Int)}))], App(Var("stream1"), [Unit]), If(Eq(Var("ok"), Int(0)), App(Var("stream2"), [Unit]), Tuple([Int(1), Var("val")])))}, Var("aux"))}, LetRec({name: ("range", Fun([Unit], Tuple([Int, Int]))), args: [("from", Int), ("to", Int)], body: Let(("state", Var({val: Some(Array(Int))})), Array(Int(1), Var("from")), LetRec({name: ("aux", Tuple([Int, Int])), args: [("u", Var({val: Some(Unit)}))], body: Let(("val", Var({val: Some(Int)})), Get(Var("state"), Int(0)), If(Eq(Var("val"), Var("to")), Tuple([Int(0), Int(0)]), Let(("_", Var({val: Some(Unit)})), Put(Var("state"), Int(0), Prim(Var("val"), Int(1), Add, kind=Some(Int))), Tuple([Int(1), Var("val")]))))}, Var("aux")))}, LetRec({name: ("addx", Fun([Int], Int)), args: [("x", Int)], body: LetRec({name: ("aux", Int), args: [("y", Int)], body: Prim(Var("x"), Var("y"), Add, kind=Some(Int))}, Var("aux"))}, LetRec({name: ("fold", Int), args: [("stream", Fun([Unit], Tuple([Int, Int]))), ("f", Fun([Int, Int], Int)), ("acc", Int)], body: LetTuple([("ok", Var({val: Some(Int)})), ("val", Var({val: Some(Int)}))], App(Var("stream"), [Unit]), If(Eq(Var("ok"), Int(0)), Var("acc"), App(Var("fold"), [Var("stream"), Var("f"), App(Var("f"), [Var("acc"), Var("val")])])))}, LetRec({name: ("sum", Int), args: [("stream", Fun([Unit], Tuple([Int, Int])))], body: LetRec({name: ("add", Int), args: [("x", Int), ("y", Int)], body: Prim(Var("x"), Var("y"), Add, kind=Some(Int))}, App(Var("fold"), [Var("stream"), Var("add"), Int(0)]))}, LetRec({name: ("gt", Fun([Int], Int)), args: [("x", Int)], body: LetRec({name: ("aux", Int), args: [("y", Int)], body: If(LE(Var("x"), Var("y")), Int(0), Int(1))}, Var("aux"))}, LetRec({name: ("le", Fun([Int], Int)), args: [("x", Int)], body: LetRec({name: ("aux", Int), args: [("y", Int)], body: If(LE(Var("y"), Var("x")), Int(0), Int(1))}, Var("aux"))}, LetRec({name: ("main", Var({val: Some(Unit)})), args: [], body: Let(("range100", Var({val: Some(Fun([Unit], Tuple([Int, Int])))})), App(Var("range"), [Int(0), Int(100)]), Let(("range1000", Var({val: Some(Fun([Unit], Tuple([Int, Int])))})), App(Var("range"), [Int(0), Int(1000)]), Let(("catt", Var({val: Some(Fun([Unit], Tuple([Int, Int])))})), App(Var("concat"), [Var("range100"), Var("range1000")]), Let(("addone", Var({val: Some(Fun([Unit], Tuple([Int, Int])))})), App(Var("map"), [Var("catt"), App(Var("addx"), [Int(1)])]), Let(("over50", Var({val: Some(Fun([Unit], Tuple([Int, Int])))})), App(Var("filter"), [Var("addone"), App(Var("gt"), [Int(50)])]), Let(("under1200", Var({val: Some(Fun([Unit], Tuple([Int, Int])))})), App(Var("filter"), [Var("over50"), App(Var("le"), [Int(1200)])]), Let(("sum", Var({val: Some(Int)})), App(Var("sum"), [Var("under1200")]), Let(("_", Var({val: Some(Unit)})), App(Var("print_int"), [Var("sum")]), Let(("_", Var({val: Some(Unit)})), App(Var("print_char"), [Int(10)]), Unit)))))))))}, App(Var("main"), [])))))))))
// [Knf] build_knf: LetRec({name: ("aux", Tuple([Int, Int])), args: [("u", Var({val: Some(Unit)}))], body: LetTuple([("ok", Var({val: Some(Int)})), ("val", Var({val: Some(Int)}))], App(Var("stream1"), [Unit]), If(Eq(Var("ok"), Int(0)), App(Var("stream2"), [Unit]), Tuple([Int(1), Var("val")])))}, Var("aux"))
// [Knf] build_knf: LetTuple([("ok", Var({val: Some(Int)})), ("val", Var({val: Some(Int)}))], App(Var("stream1"), [Unit]), If(Eq(Var("ok"), Int(0)), App(Var("stream2"), [Unit]), Tuple([Int(1), Var("val")])))
// [Knf] build_knf: App(Var("stream1"), [Unit])
// [Knf] build_knf: Var("stream1")
// [Knf] build_knf: Unit
// [Knf] build_knf: If(Eq(Var("ok"), Int(0)), App(Var("stream2"), [Unit]), Tuple([Int(1), Var("val")]))
// [Knf] build_knf: Var("ok")
// [Knf] build_knf: Int(0)
// [Knf] build_knf: App(Var("stream2"), [Unit])
// [Knf] build_knf: Var("stream2")
// [Knf] build_knf: Unit
// [Knf] build_knf: Tuple([Int(1), Var("val")])
// [Knf] build_knf: Int(1)
// [Knf] build_knf: Var("val")
// [Knf] build_knf: Var("aux")
// [Knf] build_knf: LetRec({name: ("range", Fun([Unit], Tuple([Int, Int]))), args: [("from", Int), ("to", Int)], body: Let(("state", Var({val: Some(Array(Int))})), Array(Int(1), Var("from")), LetRec({name: ("aux", Tuple([Int, Int])), args: [("u", Var({val: Some(Unit)}))], body: Let(("val", Var({val: Some(Int)})), Get(Var("state"), Int(0)), If(Eq(Var("val"), Var("to")), Tuple([Int(0), Int(0)]), Let(("_", Var({val: Some(Unit)})), Put(Var("state"), Int(0), Prim(Var("val"), Int(1), Add, kind=Some(Int))), Tuple([Int(1), Var("val")]))))}, Var("aux")))}, LetRec({name: ("addx", Fun([Int], Int)), args: [("x", Int)], body: LetRec({name: ("aux", Int), args: [("y", Int)], body: Prim(Var("x"), Var("y"), Add, kind=Some(Int))}, Var("aux"))}, LetRec({name: ("fold", Int), args: [("stream", Fun([Unit], Tuple([Int, Int]))), ("f", Fun([Int, Int], Int)), ("acc", Int)], body: LetTuple([("ok", Var({val: Some(Int)})), ("val", Var({val: Some(Int)}))], App(Var("stream"), [Unit]), If(Eq(Var("ok"), Int(0)), Var("acc"), App(Var("fold"), [Var("stream"), Var("f"), App(Var("f"), [Var("acc"), Var("val")])])))}, LetRec({name: ("sum", Int), args: [("stream", Fun([Unit], Tuple([Int, Int])))], body: LetRec({name: ("add", Int), args: [("x", Int), ("y", Int)], body: Prim(Var("x"), Var("y"), Add, kind=Some(Int))}, App(Var("fold"), [Var("stream"), Var("add"), Int(0)]))}, LetRec({name: ("gt", Fun([Int], Int)), args: [("x", Int)], body: LetRec({name: ("aux", Int), args: [("y", Int)], body: If(LE(Var("x"), Var("y")), Int(0), Int(1))}, Var("aux"))}, LetRec({name: ("le", Fun([Int], Int)), args: [("x", Int)], body: LetRec({name: ("aux", Int), args: [("y", Int)], body: If(LE(Var("y"), Var("x")), Int(0), Int(1))}, Var("aux"))}, LetRec({name: ("main", Var({val: Some(Unit)})), args: [], body: Let(("range100", Var({val: Some(Fun([Unit], Tuple([Int, Int])))})), App(Var("range"), [Int(0), Int(100)]), Let(("range1000", Var({val: Some(Fun([Unit], Tuple([Int, Int])))})), App(Var("range"), [Int(0), Int(1000)]), Let(("catt", Var({val: Some(Fun([Unit], Tuple([Int, Int])))})), App(Var("concat"), [Var("range100"), Var("range1000")]), Let(("addone", Var({val: Some(Fun([Unit], Tuple([Int, Int])))})), App(Var("map"), [Var("catt"), App(Var("addx"), [Int(1)])]), Let(("over50", Var({val: Some(Fun([Unit], Tuple([Int, Int])))})), App(Var("filter"), [Var("addone"), App(Var("gt"), [Int(50)])]), Let(("under1200", Var({val: Some(Fun([Unit], Tuple([Int, Int])))})), App(Var("filter"), [Var("over50"), App(Var("le"), [Int(1200)])]), Let(("sum", Var({val: Some(Int)})), App(Var("sum"), [Var("under1200")]), Let(("_", Var({val: Some(Unit)})), App(Var("print_int"), [Var("sum")]), Let(("_", Var({val: Some(Unit)})), App(Var("print_char"), [Int(10)]), Unit)))))))))}, App(Var("main"), []))))))))
// [Knf] build_knf: Let(("state", Var({val: Some(Array(Int))})), Array(Int(1), Var("from")), LetRec({name: ("aux", Tuple([Int, Int])), args: [("u", Var({val: Some(Unit)}))], body: Let(("val", Var({val: Some(Int)})), Get(Var("state"), Int(0)), If(Eq(Var("val"), Var("to")), Tuple([Int(0), Int(0)]), Let(("_", Var({val: Some(Unit)})), Put(Var("state"), Int(0), Prim(Var("val"), Int(1), Add, kind=Some(Int))), Tuple([Int(1), Var("val")]))))}, Var("aux")))
// [Knf] build_knf: Array(Int(1), Var("from"))
// [Knf] build_knf: Int(1)
// [Knf] build_knf: Var("from")
// [Knf] build_knf: LetRec({name: ("aux", Tuple([Int, Int])), args: [("u", Var({val: Some(Unit)}))], body: Let(("val", Var({val: Some(Int)})), Get(Var("state"), Int(0)), If(Eq(Var("val"), Var("to")), Tuple([Int(0), Int(0)]), Let(("_", Var({val: Some(Unit)})), Put(Var("state"), Int(0), Prim(Var("val"), Int(1), Add, kind=Some(Int))), Tuple([Int(1), Var("val")]))))}, Var("aux"))
// [Knf] build_knf: Let(("val", Var({val: Some(Int)})), Get(Var("state"), Int(0)), If(Eq(Var("val"), Var("to")), Tuple([Int(0), Int(0)]), Let(("_", Var({val: Some(Unit)})), Put(Var("state"), Int(0), Prim(Var("val"), Int(1), Add, kind=Some(Int))), Tuple([Int(1), Var("val")]))))
// [Knf] build_knf: Get(Var("state"), Int(0))
// [Knf] build_knf: Var("state")
// [Knf] build_knf: Int(0)
// [Knf] build_knf: If(Eq(Var("val"), Var("to")), Tuple([Int(0), Int(0)]), Let(("_", Var({val: Some(Unit)})), Put(Var("state"), Int(0), Prim(Var("val"), Int(1), Add, kind=Some(Int))), Tuple([Int(1), Var("val")])))
// [Knf] build_knf: Var("val")
// [Knf] build_knf: Var("to")
// [Knf] build_knf: Tuple([Int(0), Int(0)])
// [Knf] build_knf: Int(0)
// [Knf] build_knf: Int(0)
// [Knf] build_knf: Let(("_", Var({val: Some(Unit)})), Put(Var("state"), Int(0), Prim(Var("val"), Int(1), Add, kind=Some(Int))), Tuple([Int(1), Var("val")]))
// [Knf] build_knf: Put(Var("state"), Int(0), Prim(Var("val"), Int(1), Add, kind=Some(Int)))
// [Knf] build_knf: Var("state")
// [Knf] build_knf: Int(0)
// [Knf] build_knf: Prim(Var("val"), Int(1), Add, kind=Some(Int))
// [Knf] build_knf: Var("val")
// [Knf] build_knf: Int(1)
// [Knf] build_knf: Tuple([Int(1), Var("val")])
// [Knf] build_knf: Int(1)
// [Knf] build_knf: Var("val")
// [Knf] build_knf: Var("aux")
// [Knf] build_knf: LetRec({name: ("addx", Fun([Int], Int)), args: [("x", Int)], body: LetRec({name: ("aux", Int), args: [("y", Int)], body: Prim(Var("x"), Var("y"), Add, kind=Some(Int))}, Var("aux"))}, LetRec({name: ("fold", Int), args: [("stream", Fun([Unit], Tuple([Int, Int]))), ("f", Fun([Int, Int], Int)), ("acc", Int)], body: LetTuple([("ok", Var({val: Some(Int)})), ("val", Var({val: Some(Int)}))], App(Var("stream"), [Unit]), If(Eq(Var("ok"), Int(0)), Var("acc"), App(Var("fold"), [Var("stream"), Var("f"), App(Var("f"), [Var("acc"), Var("val")])])))}, LetRec({name: ("sum", Int), args: [("stream", Fun([Unit], Tuple([Int, Int])))], body: LetRec({name: ("add", Int), args: [("x", Int), ("y", Int)], body: Prim(Var("x"), Var("y"), Add, kind=Some(Int))}, App(Var("fold"), [Var("stream"), Var("add"), Int(0)]))}, LetRec({name: ("gt", Fun([Int], Int)), args: [("x", Int)], body: LetRec({name: ("aux", Int), args: [("y", Int)], body: If(LE(Var("x"), Var("y")), Int(0), Int(1))}, Var("aux"))}, LetRec({name: ("le", Fun([Int], Int)), args: [("x", Int)], body: LetRec({name: ("aux", Int), args: [("y", Int)], body: If(LE(Var("y"), Var("x")), Int(0), Int(1))}, Var("aux"))}, LetRec({name: ("main", Var({val: Some(Unit)})), args: [], body: Let(("range100", Var({val: Some(Fun([Unit], Tuple([Int, Int])))})), App(Var("range"), [Int(0), Int(100)]), Let(("range1000", Var({val: Some(Fun([Unit], Tuple([Int, Int])))})), App(Var("range"), [Int(0), Int(1000)]), Let(("catt", Var({val: Some(Fun([Unit], Tuple([Int, Int])))})), App(Var("concat"), [Var("range100"), Var("range1000")]), Let(("addone", Var({val: Some(Fun([Unit], Tuple([Int, Int])))})), App(Var("map"), [Var("catt"), App(Var("addx"), [Int(1)])]), Let(("over50", Var({val: Some(Fun([Unit], Tuple([Int, Int])))})), App(Var("filter"), [Var("addone"), App(Var("gt"), [Int(50)])]), Let(("under1200", Var({val: Some(Fun([Unit], Tuple([Int, Int])))})), App(Var("filter"), [Var("over50"), App(Var("le"), [Int(1200)])]), Let(("sum", Var({val: Some(Int)})), App(Var("sum"), [Var("under1200")]), Let(("_", Var({val: Some(Unit)})), App(Var("print_int"), [Var("sum")]), Let(("_", Var({val: Some(Unit)})), App(Var("print_char"), [Int(10)]), Unit)))))))))}, App(Var("main"), [])))))))
// [Knf] build_knf: LetRec({name: ("aux", Int), args: [("y", Int)], body: Prim(Var("x"), Var("y"), Add, kind=Some(Int))}, Var("aux"))
// [Knf] build_knf: Prim(Var("x"), Var("y"), Add, kind=Some(Int))
// [Knf] build_knf: Var("x")
// [Knf] build_knf: Var("y")
// [Knf] build_knf: Var("aux")
// [Knf] build_knf: LetRec({name: ("fold", Int), args: [("stream", Fun([Unit], Tuple([Int, Int]))), ("f", Fun([Int, Int], Int)), ("acc", Int)], body: LetTuple([("ok", Var({val: Some(Int)})), ("val", Var({val: Some(Int)}))], App(Var("stream"), [Unit]), If(Eq(Var("ok"), Int(0)), Var("acc"), App(Var("fold"), [Var("stream"), Var("f"), App(Var("f"), [Var("acc"), Var("val")])])))}, LetRec({name: ("sum", Int), args: [("stream", Fun([Unit], Tuple([Int, Int])))], body: LetRec({name: ("add", Int), args: [("x", Int), ("y", Int)], body: Prim(Var("x"), Var("y"), Add, kind=Some(Int))}, App(Var("fold"), [Var("stream"), Var("add"), Int(0)]))}, LetRec({name: ("gt", Fun([Int], Int)), args: [("x", Int)], body: LetRec({name: ("aux", Int), args: [("y", Int)], body: If(LE(Var("x"), Var("y")), Int(0), Int(1))}, Var("aux"))}, LetRec({name: ("le", Fun([Int], Int)), args: [("x", Int)], body: LetRec({name: ("aux", Int), args: [("y", Int)], body: If(LE(Var("y"), Var("x")), Int(0), Int(1))}, Var("aux"))}, LetRec({name: ("main", Var({val: Some(Unit)})), args: [], body: Let(("range100", Var({val: Some(Fun([Unit], Tuple([Int, Int])))})), App(Var("range"), [Int(0), Int(100)]), Let(("range1000", Var({val: Some(Fun([Unit], Tuple([Int, Int])))})), App(Var("range"), [Int(0), Int(1000)]), Let(("catt", Var({val: Some(Fun([Unit], Tuple([Int, Int])))})), App(Var("concat"), [Var("range100"), Var("range1000")]), Let(("addone", Var({val: Some(Fun([Unit], Tuple([Int, Int])))})), App(Var("map"), [Var("catt"), App(Var("addx"), [Int(1)])]), Let(("over50", Var({val: Some(Fun([Unit], Tuple([Int, Int])))})), App(Var("filter"), [Var("addone"), App(Var("gt"), [Int(50)])]), Let(("under1200", Var({val: Some(Fun([Unit], Tuple([Int, Int])))})), App(Var("filter"), [Var("over50"), App(Var("le"), [Int(1200)])]), Let(("sum", Var({val: Some(Int)})), App(Var("sum"), [Var("under1200")]), Let(("_", Var({val: Some(Unit)})), App(Var("print_int"), [Var("sum")]), Let(("_", Var({val: Some(Unit)})), App(Var("print_char"), [Int(10)]), Unit)))))))))}, App(Var("main"), []))))))
// [Knf] build_knf: LetTuple([("ok", Var({val: Some(Int)})), ("val", Var({val: Some(Int)}))], App(Var("stream"), [Unit]), If(Eq(Var("ok"), Int(0)), Var("acc"), App(Var("fold"), [Var("stream"), Var("f"), App(Var("f"), [Var("acc"), Var("val")])])))
// [Knf] build_knf: App(Var("stream"), [Unit])
// [Knf] build_knf: Var("stream")
// [Knf] build_knf: Unit
// [Knf] build_knf: If(Eq(Var("ok"), Int(0)), Var("acc"), App(Var("fold"), [Var("stream"), Var("f"), App(Var("f"), [Var("acc"), Var("val")])]))
// [Knf] build_knf: Var("ok")
// [Knf] build_knf: Int(0)
// [Knf] build_knf: Var("acc")
// [Knf] build_knf: App(Var("fold"), [Var("stream"), Var("f"), App(Var("f"), [Var("acc"), Var("val")])])
// [Knf] build_knf: Var("fold")
// [Knf] build_knf: Var("stream")
// [Knf] build_knf: Var("f")
// [Knf] build_knf: App(Var("f"), [Var("acc"), Var("val")])
// [Knf] build_knf: Var("f")
// [Knf] build_knf: Var("acc")
// [Knf] build_knf: Var("val")
// [Knf] build_knf: LetRec({name: ("sum", Int), args: [("stream", Fun([Unit], Tuple([Int, Int])))], body: LetRec({name: ("add", Int), args: [("x", Int), ("y", Int)], body: Prim(Var("x"), Var("y"), Add, kind=Some(Int))}, App(Var("fold"), [Var("stream"), Var("add"), Int(0)]))}, LetRec({name: ("gt", Fun([Int], Int)), args: [("x", Int)], body: LetRec({name: ("aux", Int), args: [("y", Int)], body: If(LE(Var("x"), Var("y")), Int(0), Int(1))}, Var("aux"))}, LetRec({name: ("le", Fun([Int], Int)), args: [("x", Int)], body: LetRec({name: ("aux", Int), args: [("y", Int)], body: If(LE(Var("y"), Var("x")), Int(0), Int(1))}, Var("aux"))}, LetRec({name: ("main", Var({val: Some(Unit)})), args: [], body: Let(("range100", Var({val: Some(Fun([Unit], Tuple([Int, Int])))})), App(Var("range"), [Int(0), Int(100)]), Let(("range1000", Var({val: Some(Fun([Unit], Tuple([Int, Int])))})), App(Var("range"), [Int(0), Int(1000)]), Let(("catt", Var({val: Some(Fun([Unit], Tuple([Int, Int])))})), App(Var("concat"), [Var("range100"), Var("range1000")]), Let(("addone", Var({val: Some(Fun([Unit], Tuple([Int, Int])))})), App(Var("map"), [Var("catt"), App(Var("addx"), [Int(1)])]), Let(("over50", Var({val: Some(Fun([Unit], Tuple([Int, Int])))})), App(Var("filter"), [Var("addone"), App(Var("gt"), [Int(50)])]), Let(("under1200", Var({val: Some(Fun([Unit], Tuple([Int, Int])))})), App(Var("filter"), [Var("over50"), App(Var("le"), [Int(1200)])]), Let(("sum", Var({val: Some(Int)})), App(Var("sum"), [Var("under1200")]), Let(("_", Var({val: Some(Unit)})), App(Var("print_int"), [Var("sum")]), Let(("_", Var({val: Some(Unit)})), App(Var("print_char"), [Int(10)]), Unit)))))))))}, App(Var("main"), [])))))
// [Knf] build_knf: LetRec({name: ("add", Int), args: [("x", Int), ("y", Int)], body: Prim(Var("x"), Var("y"), Add, kind=Some(Int))}, App(Var("fold"), [Var("stream"), Var("add"), Int(0)]))
// [Knf] build_knf: Prim(Var("x"), Var("y"), Add, kind=Some(Int))
// [Knf] build_knf: Var("x")
// [Knf] build_knf: Var("y")
// [Knf] build_knf: App(Var("fold"), [Var("stream"), Var("add"), Int(0)])
// [Knf] build_knf: Var("fold")
// [Knf] build_knf: Var("stream")
// [Knf] build_knf: Var("add")
// [Knf] build_knf: Int(0)
// [Knf] build_knf: LetRec({name: ("gt", Fun([Int], Int)), args: [("x", Int)], body: LetRec({name: ("aux", Int), args: [("y", Int)], body: If(LE(Var("x"), Var("y")), Int(0), Int(1))}, Var("aux"))}, LetRec({name: ("le", Fun([Int], Int)), args: [("x", Int)], body: LetRec({name: ("aux", Int), args: [("y", Int)], body: If(LE(Var("y"), Var("x")), Int(0), Int(1))}, Var("aux"))}, LetRec({name: ("main", Var({val: Some(Unit)})), args: [], body: Let(("range100", Var({val: Some(Fun([Unit], Tuple([Int, Int])))})), App(Var("range"), [Int(0), Int(100)]), Let(("range1000", Var({val: Some(Fun([Unit], Tuple([Int, Int])))})), App(Var("range"), [Int(0), Int(1000)]), Let(("catt", Var({val: Some(Fun([Unit], Tuple([Int, Int])))})), App(Var("concat"), [Var("range100"), Var("range1000")]), Let(("addone", Var({val: Some(Fun([Unit], Tuple([Int, Int])))})), App(Var("map"), [Var("catt"), App(Var("addx"), [Int(1)])]), Let(("over50", Var({val: Some(Fun([Unit], Tuple([Int, Int])))})), App(Var("filter"), [Var("addone"), App(Var("gt"), [Int(50)])]), Let(("under1200", Var({val: Some(Fun([Unit], Tuple([Int, Int])))})), App(Var("filter"), [Var("over50"), App(Var("le"), [Int(1200)])]), Let(("sum", Var({val: Some(Int)})), App(Var("sum"), [Var("under1200")]), Let(("_", Var({val: Some(Unit)})), App(Var("print_int"), [Var("sum")]), Let(("_", Var({val: Some(Unit)})), App(Var("print_char"), [Int(10)]), Unit)))))))))}, App(Var("main"), []))))
// [Knf] build_knf: LetRec({name: ("aux", Int), args: [("y", Int)], body: If(LE(Var("x"), Var("y")), Int(0), Int(1))}, Var("aux"))
// [Knf] build_knf: If(LE(Var("x"), Var("y")), Int(0), Int(1))
// [Knf] build_knf: Var("x")
// [Knf] build_knf: Var("y")
// [Knf] build_knf: Int(0)
// [Knf] build_knf: Int(1)
// [Knf] build_knf: Var("aux")
// [Knf] build_knf: LetRec({name: ("le", Fun([Int], Int)), args: [("x", Int)], body: LetRec({name: ("aux", Int), args: [("y", Int)], body: If(LE(Var("y"), Var("x")), Int(0), Int(1))}, Var("aux"))}, LetRec({name: ("main", Var({val: Some(Unit)})), args: [], body: Let(("range100", Var({val: Some(Fun([Unit], Tuple([Int, Int])))})), App(Var("range"), [Int(0), Int(100)]), Let(("range1000", Var({val: Some(Fun([Unit], Tuple([Int, Int])))})), App(Var("range"), [Int(0), Int(1000)]), Let(("catt", Var({val: Some(Fun([Unit], Tuple([Int, Int])))})), App(Var("concat"), [Var("range100"), Var("range1000")]), Let(("addone", Var({val: Some(Fun([Unit], Tuple([Int, Int])))})), App(Var("map"), [Var("catt"), App(Var("addx"), [Int(1)])]), Let(("over50", Var({val: Some(Fun([Unit], Tuple([Int, Int])))})), App(Var("filter"), [Var("addone"), App(Var("gt"), [Int(50)])]), Let(("under1200", Var({val: Some(Fun([Unit], Tuple([Int, Int])))})), App(Var("filter"), [Var("over50"), App(Var("le"), [Int(1200)])]), Let(("sum", Var({val: Some(Int)})), App(Var("sum"), [Var("under1200")]), Let(("_", Var({val: Some(Unit)})), App(Var("print_int"), [Var("sum")]), Let(("_", Var({val: Some(Unit)})), App(Var("print_char"), [Int(10)]), Unit)))))))))}, App(Var("main"), [])))
// [Knf] build_knf: LetRec({name: ("aux", Int), args: [("y", Int)], body: If(LE(Var("y"), Var("x")), Int(0), Int(1))}, Var("aux"))
// [Knf] build_knf: If(LE(Var("y"), Var("x")), Int(0), Int(1))
// [Knf] build_knf: Var("y")
// [Knf] build_knf: Var("x")
// [Knf] build_knf: Int(0)
// [Knf] build_knf: Int(1)
// [Knf] build_knf: Var("aux")
// [Knf] build_knf: LetRec({name: ("main", Var({val: Some(Unit)})), args: [], body: Let(("range100", Var({val: Some(Fun([Unit], Tuple([Int, Int])))})), App(Var("range"), [Int(0), Int(100)]), Let(("range1000", Var({val: Some(Fun([Unit], Tuple([Int, Int])))})), App(Var("range"), [Int(0), Int(1000)]), Let(("catt", Var({val: Some(Fun([Unit], Tuple([Int, Int])))})), App(Var("concat"), [Var("range100"), Var("range1000")]), Let(("addone", Var({val: Some(Fun([Unit], Tuple([Int, Int])))})), App(Var("map"), [Var("catt"), App(Var("addx"), [Int(1)])]), Let(("over50", Var({val: Some(Fun([Unit], Tuple([Int, Int])))})), App(Var("filter"), [Var("addone"), App(Var("gt"), [Int(50)])]), Let(("under1200", Var({val: Some(Fun([Unit], Tuple([Int, Int])))})), App(Var("filter"), [Var("over50"), App(Var("le"), [Int(1200)])]), Let(("sum", Var({val: Some(Int)})), App(Var("sum"), [Var("under1200")]), Let(("_", Var({val: Some(Unit)})), App(Var("print_int"), [Var("sum")]), Let(("_", Var({val: Some(Unit)})), App(Var("print_char"), [Int(10)]), Unit)))))))))}, App(Var("main"), []))
// [Knf] build_knf: Let(("range100", Var({val: Some(Fun([Unit], Tuple([Int, Int])))})), App(Var("range"), [Int(0), Int(100)]), Let(("range1000", Var({val: Some(Fun([Unit], Tuple([Int, Int])))})), App(Var("range"), [Int(0), Int(1000)]), Let(("catt", Var({val: Some(Fun([Unit], Tuple([Int, Int])))})), App(Var("concat"), [Var("range100"), Var("range1000")]), Let(("addone", Var({val: Some(Fun([Unit], Tuple([Int, Int])))})), App(Var("map"), [Var("catt"), App(Var("addx"), [Int(1)])]), Let(("over50", Var({val: Some(Fun([Unit], Tuple([Int, Int])))})), App(Var("filter"), [Var("addone"), App(Var("gt"), [Int(50)])]), Let(("under1200", Var({val: Some(Fun([Unit], Tuple([Int, Int])))})), App(Var("filter"), [Var("over50"), App(Var("le"), [Int(1200)])]), Let(("sum", Var({val: Some(Int)})), App(Var("sum"), [Var("under1200")]), Let(("_", Var({val: Some(Unit)})), App(Var("print_int"), [Var("sum")]), Let(("_", Var({val: Some(Unit)})), App(Var("print_char"), [Int(10)]), Unit)))))))))
// [Knf] build_knf: App(Var("range"), [Int(0), Int(100)])
// [Knf] build_knf: Var("range")
// [Knf] build_knf: Int(0)
// [Knf] build_knf: Int(100)
// [Knf] build_knf: Let(("range1000", Var({val: Some(Fun([Unit], Tuple([Int, Int])))})), App(Var("range"), [Int(0), Int(1000)]), Let(("catt", Var({val: Some(Fun([Unit], Tuple([Int, Int])))})), App(Var("concat"), [Var("range100"), Var("range1000")]), Let(("addone", Var({val: Some(Fun([Unit], Tuple([Int, Int])))})), App(Var("map"), [Var("catt"), App(Var("addx"), [Int(1)])]), Let(("over50", Var({val: Some(Fun([Unit], Tuple([Int, Int])))})), App(Var("filter"), [Var("addone"), App(Var("gt"), [Int(50)])]), Let(("under1200", Var({val: Some(Fun([Unit], Tuple([Int, Int])))})), App(Var("filter"), [Var("over50"), App(Var("le"), [Int(1200)])]), Let(("sum", Var({val: Some(Int)})), App(Var("sum"), [Var("under1200")]), Let(("_", Var({val: Some(Unit)})), App(Var("print_int"), [Var("sum")]), Let(("_", Var({val: Some(Unit)})), App(Var("print_char"), [Int(10)]), Unit))))))))
// [Knf] build_knf: App(Var("range"), [Int(0), Int(1000)])
// [Knf] build_knf: Var("range")
// [Knf] build_knf: Int(0)
// [Knf] build_knf: Int(1000)
// [Knf] build_knf: Let(("catt", Var({val: Some(Fun([Unit], Tuple([Int, Int])))})), App(Var("concat"), [Var("range100"), Var("range1000")]), Let(("addone", Var({val: Some(Fun([Unit], Tuple([Int, Int])))})), App(Var("map"), [Var("catt"), App(Var("addx"), [Int(1)])]), Let(("over50", Var({val: Some(Fun([Unit], Tuple([Int, Int])))})), App(Var("filter"), [Var("addone"), App(Var("gt"), [Int(50)])]), Let(("under1200", Var({val: Some(Fun([Unit], Tuple([Int, Int])))})), App(Var("filter"), [Var("over50"), App(Var("le"), [Int(1200)])]), Let(("sum", Var({val: Some(Int)})), App(Var("sum"), [Var("under1200")]), Let(("_", Var({val: Some(Unit)})), App(Var("print_int"), [Var("sum")]), Let(("_", Var({val: Some(Unit)})), App(Var("print_char"), [Int(10)]), Unit)))))))
// [Knf] build_knf: App(Var("concat"), [Var("range100"), Var("range1000")])
// [Knf] build_knf: Var("concat")
// [Knf] build_knf: Var("range100")
// [Knf] build_knf: Var("range1000")
// [Knf] build_knf: Let(("addone", Var({val: Some(Fun([Unit], Tuple([Int, Int])))})), App(Var("map"), [Var("catt"), App(Var("addx"), [Int(1)])]), Let(("over50", Var({val: Some(Fun([Unit], Tuple([Int, Int])))})), App(Var("filter"), [Var("addone"), App(Var("gt"), [Int(50)])]), Let(("under1200", Var({val: Some(Fun([Unit], Tuple([Int, Int])))})), App(Var("filter"), [Var("over50"), App(Var("le"), [Int(1200)])]), Let(("sum", Var({val: Some(Int)})), App(Var("sum"), [Var("under1200")]), Let(("_", Var({val: Some(Unit)})), App(Var("print_int"), [Var("sum")]), Let(("_", Var({val: Some(Unit)})), App(Var("print_char"), [Int(10)]), Unit))))))
// [Knf] build_knf: App(Var("map"), [Var("catt"), App(Var("addx"), [Int(1)])])
// [Knf] build_knf: Var("map")
// [Knf] build_knf: Var("catt")
// [Knf] build_knf: App(Var("addx"), [Int(1)])
// [Knf] build_knf: Var("addx")
// [Knf] build_knf: Int(1)
// [Knf] build_knf: Let(("over50", Var({val: Some(Fun([Unit], Tuple([Int, Int])))})), App(Var("filter"), [Var("addone"), App(Var("gt"), [Int(50)])]), Let(("under1200", Var({val: Some(Fun([Unit], Tuple([Int, Int])))})), App(Var("filter"), [Var("over50"), App(Var("le"), [Int(1200)])]), Let(("sum", Var({val: Some(Int)})), App(Var("sum"), [Var("under1200")]), Let(("_", Var({val: Some(Unit)})), App(Var("print_int"), [Var("sum")]), Let(("_", Var({val: Some(Unit)})), App(Var("print_char"), [Int(10)]), Unit)))))
// [Knf] build_knf: App(Var("filter"), [Var("addone"), App(Var("gt"), [Int(50)])])
// [Knf] build_knf: Var("filter")
// [Knf] build_knf: Var("addone")
// [Knf] build_knf: App(Var("gt"), [Int(50)])
// [Knf] build_knf: Var("gt")
// [Knf] build_knf: Int(50)
// [Knf] build_knf: Let(("under1200", Var({val: Some(Fun([Unit], Tuple([Int, Int])))})), App(Var("filter"), [Var("over50"), App(Var("le"), [Int(1200)])]), Let(("sum", Var({val: Some(Int)})), App(Var("sum"), [Var("under1200")]), Let(("_", Var({val: Some(Unit)})), App(Var("print_int"), [Var("sum")]), Let(("_", Var({val: Some(Unit)})), App(Var("print_char"), [Int(10)]), Unit))))
// [Knf] build_knf: App(Var("filter"), [Var("over50"), App(Var("le"), [Int(1200)])])
// [Knf] build_knf: Var("filter")
// [Knf] build_knf: Var("over50")
// [Knf] build_knf: App(Var("le"), [Int(1200)])
// [Knf] build_knf: Var("le")
// [Knf] build_knf: Int(1200)
// [Knf] build_knf: Let(("sum", Var({val: Some(Int)})), App(Var("sum"), [Var("under1200")]), Let(("_", Var({val: Some(Unit)})), App(Var("print_int"), [Var("sum")]), Let(("_", Var({val: Some(Unit)})), App(Var("print_char"), [Int(10)]), Unit)))
// [Knf] build_knf: App(Var("sum"), [Var("under1200")])
// [Knf] build_knf: Var("sum")
// [Knf] build_knf: Var("under1200")
// [Knf] build_knf: Let(("_", Var({val: Some(Unit)})), App(Var("print_int"), [Var("sum")]), Let(("_", Var({val: Some(Unit)})), App(Var("print_char"), [Int(10)]), Unit))
// [Knf] build_knf: App(Var("print_int"), [Var("sum")])
// [Knf] build_knf: Var("sum")
// [Knf] build_knf: Let(("_", Var({val: Some(Unit)})), App(Var("print_char"), [Int(10)]), Unit)
// [Knf] build_knf: App(Var("print_char"), [Int(10)])
// [Knf] build_knf: Int(10)
// [Knf] build_knf: Unit
// [Knf] build_knf: App(Var("main"), [])
// [Knf] build_knf: Var("main")
// [Core] b1 control: Panic -> Jump(target=b3, args=[Mem(fref=f0, mref=m0)])
// [Core] b2 control: Panic -> Jump(target=b3, args=[Mem(fref=f0, mref=m1)])
// [Core] b0 control: Panic -> Branch(cond=Insn(iref=%1), t=b1, t_args=[], f=b2, f_args=[])
// [Core] b3 control: Panic -> Return(args=[BlockParam(bref=b3, bpref=$b.0)])
// [Core] b1 control: Panic -> Jump(target=b3, args=[Mem(fref=f1, mref=m0)])
// [Core] b2 control: Panic -> Jump(target=b3, args=[Mem(fref=f1, mref=m1)])
// [Core] b0 control: Panic -> Branch(cond=Insn(iref=%1), t=b1, t_args=[], f=b2, f_args=[])
// [Core] b3 control: Panic -> Return(args=[BlockParam(bref=b3, bpref=$b.0)])
// [Core] b1 control: Panic -> Jump(target=b3, args=[Insn(iref=%4)])
// [Core] b2 control: Panic -> Jump(target=b3, args=[Mem(fref=f2, mref=m0)])
// [Core] b0 control: Panic -> Branch(cond=Insn(iref=%3), t=b1, t_args=[], f=b2, f_args=[])
// [Core] b3 control: Panic -> Return(args=[BlockParam(bref=b3, bpref=$b.0)])
// [Core] b0 control: Panic -> Return(args=[Insn(iref=%0)])
// [Core] b1 control: Panic -> Jump(target=b3, args=[Mem(fref=f4, mref=m0)])
// [Core] b2 control: Panic -> Jump(target=b3, args=[Mem(fref=f4, mref=m1)])
// [Core] b0 control: Panic -> Branch(cond=Insn(iref=%3), t=b1, t_args=[], f=b2, f_args=[])
// [Core] b3 control: Panic -> Return(args=[BlockParam(bref=b3, bpref=$b.0)])
// [Core] b1 control: Panic -> Jump(target=b3, args=[Int32(val=0)])
// [Core] b2 control: Panic -> Jump(target=b3, args=[Int32(val=1)])
// [Core] b0 control: Panic -> Branch(cond=Insn(iref=%0), t=b1, t_args=[], f=b2, f_args=[])
// [Core] b3 control: Panic -> Return(args=[BlockParam(bref=b3, bpref=$b.0)])
// [Core] b5 control: Panic -> Jump(target=b7, args=[Mem(fref=f6, mref=m1)])
// [Core] b6 control: Jump(target=b2, args=[Unit]) already set
// [Core] b4 control: Panic -> Branch(cond=Insn(iref=%6), t=b5, t_args=[], f=b6, f_args=[])
// [Core] b3 control: Panic -> Jump(target=b8, args=[Mem(fref=f6, mref=m0)])
// [Core] b7 control: Panic -> Jump(target=b8, args=[BlockParam(bref=b7, bpref=$b.0)])
// [Core] b2 control: Panic -> Branch(cond=Insn(iref=%3), t=b3, t_args=[], f=b4, f_args=[])
// [Core] b8 control: Panic -> Return(args=[BlockParam(bref=b8, bpref=$b.0)])
// [Core] b0 control: Jump(target=b1, args=[FnParam(fref=f6, fpref=$f.0)]) already set
// [Core] b1 control: Panic -> Jump(target=b3, args=[Int32(val=0)])
// [Core] b2 control: Panic -> Jump(target=b3, args=[Int32(val=1)])
// [Core] b0 control: Panic -> Branch(cond=Insn(iref=%0), t=b1, t_args=[], f=b2, f_args=[])
// [Core] b3 control: Panic -> Return(args=[BlockParam(bref=b3, bpref=$b.0)])
// [Core] b5 control: Panic -> Jump(target=b7, args=[Mem(fref=f8, mref=m1)])
// [Core] b6 control: Jump(target=b2, args=[Unit]) already set
// [Core] b4 control: Panic -> Branch(cond=Insn(iref=%6), t=b5, t_args=[], f=b6, f_args=[])
// [Core] b3 control: Panic -> Jump(target=b8, args=[Mem(fref=f8, mref=m0)])
// [Core] b7 control: Panic -> Jump(target=b8, args=[BlockParam(bref=b7, bpref=$b.0)])
// [Core] b2 control: Panic -> Branch(cond=Insn(iref=%3), t=b3, t_args=[], f=b4, f_args=[])
// [Core] b8 control: Panic -> Return(args=[BlockParam(bref=b8, bpref=$b.0)])
// [Core] b0 control: Jump(target=b1, args=[FnParam(fref=f8, fpref=$f.0)]) already set
// [Core] b0 control: Panic -> Return(args=[Insn(iref=%0)])
// [Core] b3 control: Panic -> Jump(target=b5, args=[Unit])
// [Core] b4 control: Jump(target=b2, args=[BlockParam(bref=b2, bpref=$b.0), BlockParam(bref=b2, bpref=$b.1), Insn(iref=%8)]) already set
// [Core] b2 control: Panic -> Branch(cond=Insn(iref=%5), t=b3, t_args=[], f=b4, f_args=[])
// [Core] b5 control: Panic -> Return(args=[BlockParam(bref=b5, bpref=$b.0)])
// [Core] b0 control: Panic -> Return(args=[Insn(iref=%0)])
// [Core] b0 control: Panic -> Return(args=[Insn(iref=%0)])
// [Core] b0 control: Jump(target=b1, args=[Mem(fref=f10, mref=m2), Mem(fref=f10, mref=m3), Int32(val=0)]) already set
// [Core] b0 control: Panic -> Return(args=[Insn(iref=%0)])
// [Main] beta reduce range100.90 = aux.6414
// [Main] beta reduce range1000.93 = aux.9556
// [Main] beta reduce catt.94 = aux.11127
// [Main] beta reduce _96 = aux.11915
// [Main] beta reduce addone.97 = aux.12301
// [Main] beta reduce _99 = aux.12503
// [Main] beta reduce over50.100 = aux.12593
// [Main] beta reduce _102 = aux.12651
// [Main] beta reduce under1200.103 = aux.12667
// [Main] beta reduce sum.104 = acc.12689
// [Main]   .p2align 4
// [Main]   .bss
// [Main]   .type large_heap, @object
// [Main] large_heap:
// [Main]   .zero 1610612736
// [Main] large_heap_end:
// [Main] 
// [Main]   .p2align 4
// [Main]   .bss
// [Main]   .type large_stack, @object
// [Main] large_stack:
// [Main]   .zero 268435456
// [Main] large_stack_end:
// [Main] 
// [Main] __begin_text:
// [Main]   .p2align 2
// [Main]   .text
// [Main]   .globl aux.12705
// [Main]   .type aux.12705, @function
// [Main] # leaf false
// [Main] aux.12705:
// [Main] .aux.12705_0:
// [Main]   addi sp, sp, -64
// [Main]   sd ra, 0(sp)
// [Main]   sd s0, 8(sp)
// [Main]   sd s1, 16(sp)
// [Main]   sd s2, 24(sp)
// [Main]   sd s3, 32(sp)
// [Main]   sd s4, 40(sp)
// [Main]   sd s5, 48(sp)
// [Main]   sd s6, 56(sp)
// [Main]   mv s6, a1
// [Main]   mv s3, a2
// [Main]   mv s0, a3
// [Main]   mv s4, a4
// [Main]   mv s2, a5
// [Main]   mv s1, a6
// [Main]   mv s5, a7
// [Main] 
// [Main] .aux.12705_2:
// [Main] 
// [Main] .aux.12705_15:
// [Main]   mv a0, zero
// [Main] 
// [Main] .aux.12705_17:
// [Main] 
// [Main] .aux.12705_30:
// [Main]   mv a1, s6
// [Main]   mv a2, s3
// [Main]   mv a3, s1
// [Main]   mv a4, s5
// [Main]   call aux.12699
// [Main]   mv a1, a0
// [Main] 
// [Main] .aux.12705_34:
// [Main]   lw a0, 0(a1)
// [Main]   lw a1, 4(a1)
// [Main]   bne a0, zero, .aux.12705_32
// [Main] 
// [Main] .aux.12705_31:
// [Main]   addi a0, s11, -8
// [Main]   andi s11, a0, -8
// [Main]   sw zero, 0(a0)
// [Main]   sw zero, 4(a0)
// [Main] 
// [Main] .aux.12705_33:
// [Main]   mv a1, a0
// [Main] 
// [Main] .aux.12705_25:
// [Main]   lw a0, 0(a1)
// [Main]   lw a1, 4(a1)
// [Main]   bne a0, zero, .aux.12705_19
// [Main] 
// [Main] .aux.12705_18:
// [Main]   addi a0, s11, -8
// [Main]   andi s11, a0, -8
// [Main]   sw zero, 0(a0)
// [Main]   sw zero, 4(a0)
// [Main] 
// [Main] .aux.12705_23:
// [Main]   mv a1, a0
// [Main] 
// [Main] .aux.12705_10:
// [Main]   lw a0, 0(a1)
// [Main]   lw a1, 4(a1)
// [Main]   bne a0, zero, .aux.12705_4
// [Main] 
// [Main] .aux.12705_3:
// [Main]   addi a0, s11, -8
// [Main]   andi s11, a0, -8
// [Main]   sw zero, 0(a0)
// [Main]   sw zero, 4(a0)
// [Main] 
// [Main] .aux.12705_8:
// [Main]   ld ra, 0(sp)
// [Main]   ld s0, 8(sp)
// [Main]   ld s1, 16(sp)
// [Main]   ld s2, 24(sp)
// [Main]   ld s3, 32(sp)
// [Main]   ld s4, 40(sp)
// [Main]   ld s5, 48(sp)
// [Main]   ld s6, 56(sp)
// [Main]   addi sp, sp, 64
// [Main]   ret
// [Main] 
// [Main] .aux.12705_32:
// [Main]   mv a0, a1
// [Main]   mv a1, s0
// [Main]   call aux.12700
// [Main]   mv a1, a0
// [Main] 
// [Main] .aux.12705_35:
// [Main]   addi a0, s11, -8
// [Main]   andi s11, a0, -8
// [Main]   li a2, 1
// [Main]   sw a2, 0(a0)
// [Main]   sw a1, 4(a0)
// [Main]   j .aux.12705_33
// [Main] 
// [Main] .aux.12705_19:
// [Main] 
// [Main] .aux.12705_26:
// [Main]   blt a1, s4, .aux.12705_28
// [Main] 
// [Main] .aux.12705_27:
// [Main]   mv a0, zero
// [Main] 
// [Main] .aux.12705_29:
// [Main] 
// [Main] .aux.12705_24:
// [Main]   bne a0, zero, .aux.12705_21
// [Main] 
// [Main] .aux.12705_20:
// [Main]   addi a0, s11, -8
// [Main]   andi s11, a0, -8
// [Main]   li a2, 1
// [Main]   sw a2, 0(a0)
// [Main]   sw a1, 4(a0)
// [Main] 
// [Main] .aux.12705_22:
// [Main]   j .aux.12705_23
// [Main] 
// [Main] .aux.12705_28:
// [Main]   li a0, 1
// [Main]   j .aux.12705_29
// [Main] 
// [Main] .aux.12705_21:
// [Main]   mv a0, zero
// [Main]   j .aux.12705_17
// [Main] 
// [Main] .aux.12705_4:
// [Main] 
// [Main] .aux.12705_11:
// [Main]   blt s2, a1, .aux.12705_13
// [Main] 
// [Main] .aux.12705_12:
// [Main]   mv a0, zero
// [Main] 
// [Main] .aux.12705_14:
// [Main] 
// [Main] .aux.12705_9:
// [Main]   bne a0, zero, .aux.12705_6
// [Main] 
// [Main] .aux.12705_5:
// [Main]   addi a0, s11, -8
// [Main]   andi s11, a0, -8
// [Main]   li a2, 1
// [Main]   sw a2, 0(a0)
// [Main]   sw a1, 4(a0)
// [Main] 
// [Main] .aux.12705_7:
// [Main]   j .aux.12705_8
// [Main] 
// [Main] .aux.12705_13:
// [Main]   li a0, 1
// [Main]   j .aux.12705_14
// [Main] 
// [Main] .aux.12705_6:
// [Main]   mv a0, zero
// [Main]   j .aux.12705_2
// [Main] 
// [Main]   .p2align 2
// [Main]   .text
// [Main]   .globl aux.12698
// [Main]   .type aux.12698, @function
// [Main] # leaf true
// [Main] aux.12698:
// [Main] .aux.12698_0:
// [Main]   mv a0, a1
// [Main]   mv a1, a2
// [Main]   lw a2, 0(a1)
// [Main]   beq a2, a0, .aux.12698_1
// [Main] 
// [Main] .aux.12698_2:
// [Main]   addi a0, a2, 1
// [Main]   sw a0, 0(a1)
// [Main]   addi a0, s11, -8
// [Main]   andi s11, a0, -8
// [Main]   li a1, 1
// [Main]   sw a1, 0(a0)
// [Main]   sw a2, 4(a0)
// [Main] 
// [Main] .aux.12698_3:
// [Main]   ret
// [Main] 
// [Main] .aux.12698_1:
// [Main]   addi a0, s11, -8
// [Main]   andi s11, a0, -8
// [Main]   sw zero, 0(a0)
// [Main]   sw zero, 4(a0)
// [Main]   j .aux.12698_3
// [Main] 
// [Main]   .p2align 2
// [Main]   .text
// [Main]   .globl aux.12699
// [Main]   .type aux.12699, @function
// [Main] # leaf false
// [Main] aux.12699:
// [Main] .aux.12699_0:
// [Main]   addi sp, sp, -16
// [Main]   sd ra, 0(sp)
// [Main]   mv a5, a1
// [Main]   mv a1, a2
// [Main]   mv a2, a4
// [Main] 
// [Main] .aux.12699_6:
// [Main]   lw a0, 0(a3)
// [Main]   beq a0, a5, .aux.12699_7
// [Main] 
// [Main] .aux.12699_8:
// [Main]   addi a4, a0, 1
// [Main]   sw a4, 0(a3)
// [Main]   addi a3, s11, -8
// [Main]   andi s11, a3, -8
// [Main]   li a4, 1
// [Main]   sw a4, 0(a3)
// [Main]   sw a0, 4(a3)
// [Main]   mv a0, a3
// [Main] 
// [Main] .aux.12699_9:
// [Main]   mv a3, a0
// [Main] 
// [Main] .aux.12699_4:
// [Main]   lw a0, 0(a3)
// [Main]   lw a3, 4(a3)
// [Main]   bne a0, zero, .aux.12699_2
// [Main] 
// [Main] .aux.12699_1:
// [Main]   call aux.12698
// [Main] 
// [Main] .aux.12699_3:
// [Main]   ld ra, 0(sp)
// [Main]   addi sp, sp, 16
// [Main]   ret
// [Main] 
// [Main] .aux.12699_7:
// [Main]   addi a0, s11, -8
// [Main]   andi s11, a0, -8
// [Main]   sw zero, 0(a0)
// [Main]   sw zero, 4(a0)
// [Main]   j .aux.12699_9
// [Main] 
// [Main] .aux.12699_2:
// [Main]   addi a0, s11, -8
// [Main]   andi s11, a0, -8
// [Main]   li a1, 1
// [Main]   sw a1, 0(a0)
// [Main]   sw a3, 4(a0)
// [Main]   j .aux.12699_3
// [Main] 
// [Main]   .p2align 2
// [Main]   .text
// [Main]   .globl main.12696
// [Main]   .type main.12696, @function
// [Main] # leaf false
// [Main] main.12696:
// [Main] .main.12696_0:
// [Main]   addi sp, sp, -32
// [Main]   sd ra, 0(sp)
// [Main]   sd s0, 8(sp)
// [Main]   sd s1, 16(sp)
// [Main]   sd s2, 24(sp)
// [Main]   addi a0, s11, -4
// [Main]   andi s11, a0, -8
// [Main]   sw zero, 0(a0)
// [Main]   addi a2, s11, -4
// [Main]   andi s11, a2, -8
// [Main]   sw zero, 0(a2)
// [Main]   addi a1, s11, -64
// [Main]   andi s11, a1, -8
// [Main]   la a3, aux.12707
// [Main]   sd a3, 0(a1)
// [Main]   li a3, 100
// [Main]   sd a3, 8(a1)
// [Main]   li a3, 1000
// [Main]   sd a3, 16(a1)
// [Main]   li a3, 1
// [Main]   sd a3, 24(a1)
// [Main]   li a3, 50
// [Main]   sd a3, 32(a1)
// [Main]   li a3, 1200
// [Main]   sd a3, 40(a1)
// [Main]   sd a0, 48(a1)
// [Main]   sd a2, 56(a1)
// [Main]   addi a0, s11, -8
// [Main]   andi s11, a0, -8
// [Main]   la a2, add.12708
// [Main]   sd a2, 0(a0)
// [Main]   mv s1, a1
// [Main]   mv s0, a0
// [Main]   mv s2, zero
// [Main] 
// [Main] .main.12696_2:
// [Main]   mv s10, s1
// [Main]   ld a1, 0(s1)
// [Main]   jalr a1
// [Main]   mv a1, a0
// [Main]   lw a0, 0(a1)
// [Main]   lw a1, 4(a1)
// [Main]   bne a0, zero, .main.12696_4
// [Main] 
// [Main] .main.12696_3:
// [Main]   mv a0, s2
// [Main]   call minimbt_print_int
// [Main]   li a0, 10
// [Main]   call minimbt_print_char
// [Main]   mv a0, zero
// [Main] 
// [Main] .main.12696_5:
// [Main]   ld ra, 0(sp)
// [Main]   ld s0, 8(sp)
// [Main]   ld s1, 16(sp)
// [Main]   ld s2, 24(sp)
// [Main]   addi sp, sp, 32
// [Main]   ret
// [Main] 
// [Main] .main.12696_4:
// [Main]   mv s10, s0
// [Main]   ld a2, 0(s0)
// [Main]   mv a0, s2
// [Main]   jalr a2
// [Main]   mv s2, a0
// [Main]   j .main.12696_2
// [Main] 
// [Main]   .p2align 2
// [Main]   .text
// [Main]   .globl aux.12707
// [Main]   .type aux.12707, @function
// [Main] # leaf false
// [Main] aux.12707:
// [Main] .aux.12707_0:
// [Main]   addi sp, sp, -16
// [Main]   sd ra, 0(sp)
// [Main]   mv a1, s10
// [Main]   lw a2, 8(a1)
// [Main]   lw a3, 16(a1)
// [Main]   lw a4, 24(a1)
// [Main]   lw a5, 32(a1)
// [Main]   lw a6, 40(a1)
// [Main]   ld a7, 48(a1)
// [Main]   ld t0, 56(a1)
// [Main]   mv a1, a2
// [Main]   mv a2, a3
// [Main]   mv a3, a4
// [Main]   mv a4, a5
// [Main]   mv a5, a6
// [Main]   mv a6, a7
// [Main]   mv a7, t0
// [Main]   call aux.12705
// [Main]   ld ra, 0(sp)
// [Main]   addi sp, sp, 16
// [Main]   ret
// [Main] 
// [Main]   .p2align 2
// [Main]   .text
// [Main]   .globl T$start
// [Main]   .type T$start, @function
// [Main] # leaf false
// [Main] T$start:
// [Main] .T$start_0:
// [Main]   addi sp, sp, -16
// [Main]   sd ra, 0(sp)
// [Main]   call main.12696
// [Main]   ld ra, 0(sp)
// [Main]   addi sp, sp, 16
// [Main]   ret
// [Main] 
// [Main]   .p2align 2
// [Main]   .text
// [Main]   .globl add.12708
// [Main]   .type add.12708, @function
// [Main] # leaf false
// [Main] add.12708:
// [Main] .add.12708_0:
// [Main]   addi sp, sp, -16
// [Main]   sd ra, 0(sp)
// [Main]   mv a2, s10
// [Main]   call add.12706
// [Main]   ld ra, 0(sp)
// [Main]   addi sp, sp, 16
// [Main]   ret
// [Main] 
// [Main]   .p2align 2
// [Main]   .text
// [Main]   .globl add.12706
// [Main]   .type add.12706, @function
// [Main] # leaf true
// [Main] add.12706:
// [Main] .add.12706_0:
// [Main]   add a0, a0, a1
// [Main]   ret
// [Main] 
// [Main]   .p2align 2
// [Main]   .text
// [Main]   .globl minimbt_main
// [Main]   .type minimbt_main, @function
// [Main] # leaf false
// [Main] minimbt_main:
// [Main] .minimbt_main_b0:
// [Main]   addi sp, sp, -32
// [Main]   sd ra, 0(sp)
// [Main]   sd s0, 8(sp)
// [Main]   sd s11, 16(sp)
// [Main]   la s11, large_heap_end
// [Main]   mv s0, sp
// [Main]   la sp, large_stack_end
// [Main]   call T$start
// [Main]   mv sp, s0
// [Main]   ld ra, 0(sp)
// [Main]   ld s0, 8(sp)
// [Main]   ld s11, 16(sp)
// [Main]   addi sp, sp, 32
// [Main]   ret
// [Main] 
// [Main]   .p2align 2
// [Main]   .text
// [Main]   .globl aux.12700
// [Main]   .type aux.12700, @function
// [Main] # leaf true
// [Main] aux.12700:
// [Main] .aux.12700_0:
// [Main]   add a0, a1, a0
// [Main]   ret
// [Main] 
// [Main]   .p2align 2
// [Main]   .text
// [Main]   .globl aux.12697
// [Main]   .type aux.12697, @function
// [Main] # leaf true
// [Main] aux.12697:
// [Main] .aux.12697_0:
// [Main]   mv a0, a1
// [Main]   mv a1, a2
// [Main]   lw a2, 0(a1)
// [Main]   beq a2, a0, .aux.12697_1
// [Main] 
// [Main] .aux.12697_2:
// [Main]   addi a0, a2, 1
// [Main]   sw a0, 0(a1)
// [Main]   addi a0, s11, -8
// [Main]   andi s11, a0, -8
// [Main]   li a1, 1
// [Main]   sw a1, 0(a0)
// [Main]   sw a2, 4(a0)
// [Main] 
// [Main] .aux.12697_3:
// [Main]   ret
// [Main] 
// [Main] .aux.12697_1:
// [Main]   addi a0, s11, -8
// [Main]   andi s11, a0, -8
// [Main]   sw zero, 0(a0)
// [Main]   sw zero, 4(a0)
// [Main]   j .aux.12697_3
// [Main] 
// [Main] __end_text:
// [Main]   .p2align 2
// [Main]   .bss
// [Main]   .globl start
// [Main]   .type start, @object
// [Main] start:
// [Main]   .zero 4
// [Main] 
// [Wasm] Lowering function aux.12705
// [Wasm] Lowering control Return(args=[BlockParam(bref=b8, bpref=$b.0)])
// [Wasm] Get Local name BlockParam(bref=b8, bpref=$b.0) -> $b8.$b.0
// [Wasm] Lowering insn Alloc(ty=Tuple(fields=[Int32, Int32]), mref=m0, fills=[Field(index=0, val=Int32(val=0)), Field(index=1, val=Int32(val=0))])
// [Wasm] Get Local name Mem(fref=f8, mref=m0) -> $f8.m0
// [Wasm] Get Local name Mem(fref=f8, mref=m0) -> $f8.m0
// [Wasm] Get Local name Mem(fref=f8, mref=m0) -> $f8.m0
// [Wasm] Lowering control Jump(target=b8, args=[Mem(fref=f8, mref=m0)])
// [Wasm] Get Local name Mem(fref=f8, mref=m0) -> $f8.m0
// [Wasm] Get Local name BlockParam(bref=b8, bpref=$b.0) -> $b8.$b.0
// [Wasm] Lowering control Jump(target=b8, args=[BlockParam(bref=b7, bpref=$b.0)])
// [Wasm] Get Local name BlockParam(bref=b7, bpref=$b.0) -> $b7.$b.0
// [Wasm] Get Local name BlockParam(bref=b8, bpref=$b.0) -> $b8.$b.0
// [Wasm] Lowering insn Alloc(ty=Tuple(fields=[Int32, Int32]), mref=m1, fills=[Field(index=0, val=Int32(val=1)), Field(index=1, val=Insn(iref=%2))])
// [Wasm] Get Local name Mem(fref=f8, mref=m1) -> $f8.m1
// [Wasm] Get Local name Mem(fref=f8, mref=m1) -> $f8.m1
// [Wasm] Get Local name Mem(fref=f8, mref=m1) -> $f8.m1
// [Wasm] Get Local name Insn(iref=%2) -> $%2
// [Wasm] Lowering control Jump(target=b7, args=[Mem(fref=f8, mref=m1)])
// [Wasm] Get Local name Mem(fref=f8, mref=m1) -> $f8.m1
// [Wasm] Get Local name BlockParam(bref=b7, bpref=$b.0) -> $b7.$b.0
// [Wasm] Lowering control Jump(target=b2, args=[Unit])
// [Wasm] Lowering insn Op(ty=Bool, op=Eq, args=[BlockParam(bref=b9, bpref=$b.0), Int32(val=0)])
// [Wasm] Get Local name BlockParam(bref=b9, bpref=$b.0) -> $b9.$b.0
// [Wasm] Get Local name Insn(iref=%6) -> $%6
// [Wasm] Lowering control Branch(cond=Insn(iref=%6), t=b5, t_args=[], f=b6, f_args=[])
// [Wasm] Get Local name Insn(iref=%6) -> $%6
// [Wasm] Lowering control Jump(target=b9, args=[BlockParam(bref=b14, bpref=$b.0)])
// [Wasm] Get Local name BlockParam(bref=b14, bpref=$b.0) -> $b14.$b.0
// [Wasm] Get Local name BlockParam(bref=b9, bpref=$b.0) -> $b9.$b.0
// [Wasm] Lowering control Jump(target=b14, args=[Int32(val=0)])
// [Wasm] Get Local name BlockParam(bref=b14, bpref=$b.0) -> $b14.$b.0
// [Wasm] Lowering control Jump(target=b14, args=[Int32(val=1)])
// [Wasm] Get Local name BlockParam(bref=b14, bpref=$b.0) -> $b14.$b.0
// [Wasm] Lowering insn Op(ty=Bool, op=Le, args=[Insn(iref=%2), FnParam(fref=f8, fpref=$f.5)])
// [Wasm] Get Local name Insn(iref=%2) -> $%2
// [Wasm] Get Local name FnParam(fref=f8, fpref=$f.5) -> $$f.5
// [Wasm] Get Local name Insn(iref=%8) -> $%8
// [Wasm] Lowering control Branch(cond=Insn(iref=%8), t=b12, t_args=[], f=b13, f_args=[])
// [Wasm] Get Local name Insn(iref=%8) -> $%8
// [Wasm] Lowering control Jump(target=b11, args=[])
// [Wasm] Lowering insn Load(ty=Int32, ma=Field(ty=Int32, val=BlockParam(bref=b10, bpref=$b.0), index=0, width=@(@32, @(@32, @32))))
// [Wasm] Get Local name BlockParam(bref=b10, bpref=$b.0) -> $b10.$b.0
// [Wasm] Get Local name Insn(iref=%1) -> $%1
// [Wasm] Lowering insn Load(ty=Int32, ma=Field(ty=Int32, val=BlockParam(bref=b10, bpref=$b.0), index=1, width=@(@32, @(@32, @32))))
// [Wasm] Get Local name BlockParam(bref=b10, bpref=$b.0) -> $b10.$b.0
// [Wasm] Get Local name Insn(iref=%2) -> $%2
// [Wasm] Lowering insn Op(ty=Bool, op=Eq, args=[Insn(iref=%1), Int32(val=0)])
// [Wasm] Get Local name Insn(iref=%1) -> $%1
// [Wasm] Get Local name Insn(iref=%3) -> $%3
// [Wasm] Lowering control Branch(cond=Insn(iref=%3), t=b3, t_args=[], f=b4, f_args=[])
// [Wasm] Get Local name Insn(iref=%3) -> $%3
// [Wasm] Lowering control Jump(target=b10, args=[BlockParam(bref=b23, bpref=$b.0)])
// [Wasm] Get Local name BlockParam(bref=b23, bpref=$b.0) -> $b23.$b.0
// [Wasm] Get Local name BlockParam(bref=b10, bpref=$b.0) -> $b10.$b.0
// [Wasm] Lowering insn Alloc(ty=Tuple(fields=[Int32, Int32]), mref=m15, fills=[Field(index=0, val=Int32(val=0)), Field(index=1, val=Int32(val=0))])
// [Wasm] Get Local name Mem(fref=f8, mref=m15) -> $f8.m15
// [Wasm] Get Local name Mem(fref=f8, mref=m15) -> $f8.m15
// [Wasm] Get Local name Mem(fref=f8, mref=m15) -> $f8.m15
// [Wasm] Lowering control Jump(target=b23, args=[Mem(fref=f8, mref=m15)])
// [Wasm] Get Local name Mem(fref=f8, mref=m15) -> $f8.m15
// [Wasm] Get Local name BlockParam(bref=b23, bpref=$b.0) -> $b23.$b.0
// [Wasm] Lowering control Jump(target=b23, args=[BlockParam(bref=b22, bpref=$b.0)])
// [Wasm] Get Local name BlockParam(bref=b22, bpref=$b.0) -> $b22.$b.0
// [Wasm] Get Local name BlockParam(bref=b23, bpref=$b.0) -> $b23.$b.0
// [Wasm] Lowering insn Alloc(ty=Tuple(fields=[Int32, Int32]), mref=m16, fills=[Field(index=0, val=Int32(val=1)), Field(index=1, val=Insn(iref=%11))])
// [Wasm] Get Local name Mem(fref=f8, mref=m16) -> $f8.m16
// [Wasm] Get Local name Mem(fref=f8, mref=m16) -> $f8.m16
// [Wasm] Get Local name Mem(fref=f8, mref=m16) -> $f8.m16
// [Wasm] Get Local name Insn(iref=%11) -> $%11
// [Wasm] Lowering control Jump(target=b22, args=[Mem(fref=f8, mref=m16)])
// [Wasm] Get Local name Mem(fref=f8, mref=m16) -> $f8.m16
// [Wasm] Get Local name BlockParam(bref=b22, bpref=$b.0) -> $b22.$b.0
// [Wasm] Lowering control Jump(target=b17, args=[Unit])
// [Wasm] Lowering insn Op(ty=Bool, op=Eq, args=[BlockParam(bref=b24, bpref=$b.0), Int32(val=0)])
// [Wasm] Get Local name BlockParam(bref=b24, bpref=$b.0) -> $b24.$b.0
// [Wasm] Get Local name Insn(iref=%15) -> $%15
// [Wasm] Lowering control Branch(cond=Insn(iref=%15), t=b20, t_args=[], f=b21, f_args=[])
// [Wasm] Get Local name Insn(iref=%15) -> $%15
// [Wasm] Lowering control Jump(target=b24, args=[BlockParam(bref=b29, bpref=$b.0)])
// [Wasm] Get Local name BlockParam(bref=b29, bpref=$b.0) -> $b29.$b.0
// [Wasm] Get Local name BlockParam(bref=b24, bpref=$b.0) -> $b24.$b.0
// [Wasm] Lowering control Jump(target=b29, args=[Int32(val=0)])
// [Wasm] Get Local name BlockParam(bref=b29, bpref=$b.0) -> $b29.$b.0
// [Wasm] Lowering control Jump(target=b29, args=[Int32(val=1)])
// [Wasm] Get Local name BlockParam(bref=b29, bpref=$b.0) -> $b29.$b.0
// [Wasm] Lowering insn Op(ty=Bool, op=Le, args=[FnParam(fref=f8, fpref=$f.4), Insn(iref=%11)])
// [Wasm] Get Local name FnParam(fref=f8, fpref=$f.4) -> $$f.4
// [Wasm] Get Local name Insn(iref=%11) -> $%11
// [Wasm] Get Local name Insn(iref=%17) -> $%17
// [Wasm] Lowering control Branch(cond=Insn(iref=%17), t=b27, t_args=[], f=b28, f_args=[])
// [Wasm] Get Local name Insn(iref=%17) -> $%17
// [Wasm] Lowering control Jump(target=b26, args=[])
// [Wasm] Lowering insn Load(ty=Int32, ma=Field(ty=Int32, val=BlockParam(bref=b25, bpref=$b.0), index=0, width=@(@32, @(@32, @32))))
// [Wasm] Get Local name BlockParam(bref=b25, bpref=$b.0) -> $b25.$b.0
// [Wasm] Get Local name Insn(iref=%10) -> $%10
// [Wasm] Lowering insn Load(ty=Int32, ma=Field(ty=Int32, val=BlockParam(bref=b25, bpref=$b.0), index=1, width=@(@32, @(@32, @32))))
// [Wasm] Get Local name BlockParam(bref=b25, bpref=$b.0) -> $b25.$b.0
// [Wasm] Get Local name Insn(iref=%11) -> $%11
// [Wasm] Lowering insn Op(ty=Bool, op=Eq, args=[Insn(iref=%10), Int32(val=0)])
// [Wasm] Get Local name Insn(iref=%10) -> $%10
// [Wasm] Get Local name Insn(iref=%12) -> $%12
// [Wasm] Lowering control Branch(cond=Insn(iref=%12), t=b18, t_args=[], f=b19, f_args=[])
// [Wasm] Get Local name Insn(iref=%12) -> $%12
// [Wasm] Lowering control Jump(target=b25, args=[BlockParam(bref=b33, bpref=$b.0)])
// [Wasm] Get Local name BlockParam(bref=b33, bpref=$b.0) -> $b33.$b.0
// [Wasm] Get Local name BlockParam(bref=b25, bpref=$b.0) -> $b25.$b.0
// [Wasm] Lowering insn Alloc(ty=Tuple(fields=[Int32, Int32]), mref=m30, fills=[Field(index=0, val=Int32(val=0)), Field(index=1, val=Int32(val=0))])
// [Wasm] Get Local name Mem(fref=f8, mref=m30) -> $f8.m30
// [Wasm] Get Local name Mem(fref=f8, mref=m30) -> $f8.m30
// [Wasm] Get Local name Mem(fref=f8, mref=m30) -> $f8.m30
// [Wasm] Lowering control Jump(target=b33, args=[Mem(fref=f8, mref=m30)])
// [Wasm] Get Local name Mem(fref=f8, mref=m30) -> $f8.m30
// [Wasm] Get Local name BlockParam(bref=b33, bpref=$b.0) -> $b33.$b.0
// [Wasm] Lowering insn Alloc(ty=Tuple(fields=[Int32, Int32]), mref=m31, fills=[Field(index=0, val=Int32(val=1)), Field(index=1, val=BlockParam(bref=b35, bpref=$b.0))])
// [Wasm] Get Local name Mem(fref=f8, mref=m31) -> $f8.m31
// [Wasm] Get Local name Mem(fref=f8, mref=m31) -> $f8.m31
// [Wasm] Get Local name Mem(fref=f8, mref=m31) -> $f8.m31
// [Wasm] Get Local name BlockParam(bref=b35, bpref=$b.0) -> $b35.$b.0
// [Wasm] Lowering control Jump(target=b33, args=[Mem(fref=f8, mref=m31)])
// [Wasm] Get Local name Mem(fref=f8, mref=m31) -> $f8.m31
// [Wasm] Get Local name BlockParam(bref=b33, bpref=$b.0) -> $b33.$b.0
// [Wasm] Lowering insn Call(ty=Int32, f=f3, args=[Insn(iref=%20), FnParam(fref=f8, fpref=$f.3)])
// [Wasm] Get Local name Insn(iref=%20) -> $%20
// [Wasm] Get Local name FnParam(fref=f8, fpref=$f.3) -> $$f.3
// [Wasm] Get Local name Insn(iref=%23) -> $%23
// [Wasm] Lowering control Jump(target=b35, args=[Insn(iref=%23)])
// [Wasm] Get Local name Insn(iref=%23) -> $%23
// [Wasm] Get Local name BlockParam(bref=b35, bpref=$b.0) -> $b35.$b.0
// [Wasm] Lowering insn Load(ty=Int32, ma=Field(ty=Int32, val=BlockParam(bref=b34, bpref=$b.0), index=0, width=@(@32, @(@32, @32))))
// [Wasm] Get Local name BlockParam(bref=b34, bpref=$b.0) -> $b34.$b.0
// [Wasm] Get Local name Insn(iref=%19) -> $%19
// [Wasm] Lowering insn Load(ty=Int32, ma=Field(ty=Int32, val=BlockParam(bref=b34, bpref=$b.0), index=1, width=@(@32, @(@32, @32))))
// [Wasm] Get Local name BlockParam(bref=b34, bpref=$b.0) -> $b34.$b.0
// [Wasm] Get Local name Insn(iref=%20) -> $%20
// [Wasm] Lowering insn Op(ty=Bool, op=Eq, args=[Insn(iref=%19), Int32(val=0)])
// [Wasm] Get Local name Insn(iref=%19) -> $%19
// [Wasm] Get Local name Insn(iref=%21) -> $%21
// [Wasm] Lowering control Branch(cond=Insn(iref=%21), t=b31, t_args=[], f=b32, f_args=[])
// [Wasm] Get Local name Insn(iref=%21) -> $%21
// [Wasm] Lowering insn Call(ty=Tuple(fields=[Int32, Int32]), f=f2, args=[Unit, FnParam(fref=f8, fpref=$f.1), FnParam(fref=f8, fpref=$f.2), FnParam(fref=f8, fpref=$f.6), FnParam(fref=f8, fpref=$f.7)])
// [Wasm] Get Local name FnParam(fref=f8, fpref=$f.1) -> $$f.1
// [Wasm] Get Local name FnParam(fref=f8, fpref=$f.2) -> $$f.2
// [Wasm] Get Local name FnParam(fref=f8, fpref=$f.6) -> $$f.6
// [Wasm] Get Local name FnParam(fref=f8, fpref=$f.7) -> $$f.7
// [Wasm] Get Local name Insn(iref=%18) -> $%18
// [Wasm] Lowering control Jump(target=b34, args=[Insn(iref=%18)])
// [Wasm] Get Local name Insn(iref=%18) -> $%18
// [Wasm] Get Local name BlockParam(bref=b34, bpref=$b.0) -> $b34.$b.0
// [Wasm] Lowering control Jump(target=b30, args=[])
// [Wasm] Lowering control Jump(target=b16, args=[Unit])
// [Wasm] Lowering control Jump(target=b15, args=[])
// [Wasm] Lowering control Jump(target=b1, args=[FnParam(fref=f8, fpref=$f.0)])
// [Wasm] Get Local name FnParam(fref=f8, fpref=$f.1) -> $$f.1
// [Wasm] Get Local name FnParam(fref=f8, fpref=$f.2) -> $$f.2
// [Wasm] Get Local name FnParam(fref=f8, fpref=$f.3) -> $$f.3
// [Wasm] Get Local name FnParam(fref=f8, fpref=$f.4) -> $$f.4
// [Wasm] Get Local name FnParam(fref=f8, fpref=$f.5) -> $$f.5
// [Wasm] Get Local name FnParam(fref=f8, fpref=$f.6) -> $$f.6
// [Wasm] Get Local name FnParam(fref=f8, fpref=$f.7) -> $$f.7
// [Wasm] Local Insn(iref=%15) -> $%15
// [Wasm] Local BlockParam(bref=b7, bpref=$b.0) -> $b7.$b.0
// [Wasm] Local Mem(fref=f8, mref=m15) -> $f8.m15
// [Wasm] Local BlockParam(bref=b10, bpref=$b.0) -> $b10.$b.0
// [Wasm] Local Insn(iref=%8) -> $%8
// [Wasm] Local Insn(iref=%10) -> $%10
// [Wasm] Local BlockParam(bref=b34, bpref=$b.0) -> $b34.$b.0
// [Wasm] Local BlockParam(bref=b14, bpref=$b.0) -> $b14.$b.0
// [Wasm] Local BlockParam(bref=b35, bpref=$b.0) -> $b35.$b.0
// [Wasm] Local Mem(fref=f8, mref=m16) -> $f8.m16
// [Wasm] Local BlockParam(bref=b25, bpref=$b.0) -> $b25.$b.0
// [Wasm] Local Mem(fref=f8, mref=m0) -> $f8.m0
// [Wasm] Local Insn(iref=%1) -> $%1
// [Wasm] Local Insn(iref=%11) -> $%11
// [Wasm] Local BlockParam(bref=b23, bpref=$b.0) -> $b23.$b.0
// [Wasm] Local BlockParam(bref=b24, bpref=$b.0) -> $b24.$b.0
// [Wasm] Local Insn(iref=%6) -> $%6
// [Wasm] Local BlockParam(bref=b9, bpref=$b.0) -> $b9.$b.0
// [Wasm] Local BlockParam(bref=b29, bpref=$b.0) -> $b29.$b.0
// [Wasm] Local Mem(fref=f8, mref=m31) -> $f8.m31
// [Wasm] Local BlockParam(bref=b22, bpref=$b.0) -> $b22.$b.0
// [Wasm] Local BlockParam(bref=b8, bpref=$b.0) -> $b8.$b.0
// [Wasm] Local Mem(fref=f8, mref=m1) -> $f8.m1
// [Wasm] Local Insn(iref=%19) -> $%19
// [Wasm] Local Insn(iref=%3) -> $%3
// [Wasm] Local Insn(iref=%18) -> $%18
// [Wasm] Local BlockParam(bref=b33, bpref=$b.0) -> $b33.$b.0
// [Wasm] Local Mem(fref=f8, mref=m30) -> $f8.m30
// [Wasm] Local Insn(iref=%17) -> $%17
// [Wasm] Local Insn(iref=%23) -> $%23
// [Wasm] Local Insn(iref=%2) -> $%2
// [Wasm] Local Insn(iref=%20) -> $%20
// [Wasm] Local Insn(iref=%21) -> $%21
// [Wasm] Local Insn(iref=%12) -> $%12
// [Wasm] Lowered function aux.12705 to wasm
// [Wasm] Lowering function add.12706
// [Wasm] Lowering insn Op(ty=Int32, op=Add, args=[FnParam(fref=f9, fpref=$f.0), FnParam(fref=f9, fpref=$f.1)])
// [Wasm] Get Local name FnParam(fref=f9, fpref=$f.0) -> $$f.0
// [Wasm] Get Local name FnParam(fref=f9, fpref=$f.1) -> $$f.1
// [Wasm] Get Local name Insn(iref=%0) -> $%0
// [Wasm] Lowering control Return(args=[Insn(iref=%0)])
// [Wasm] Get Local name Insn(iref=%0) -> $%0
// [Wasm] Get Local name FnParam(fref=f9, fpref=$f.0) -> $$f.0
// [Wasm] Get Local name FnParam(fref=f9, fpref=$f.1) -> $$f.1
// [Wasm] Local Insn(iref=%0) -> $%0
// [Wasm] Lowered function add.12706 to wasm
// [Wasm] Lowering function aux.12697
// [Wasm] Lowering control Return(args=[BlockParam(bref=b3, bpref=$b.0)])
// [Wasm] Get Local name BlockParam(bref=b3, bpref=$b.0) -> $b3.$b.0
// [Wasm] Lowering insn Alloc(ty=Tuple(fields=[Int32, Int32]), mref=m0, fills=[Field(index=0, val=Int32(val=0)), Field(index=1, val=Int32(val=0))])
// [Wasm] Get Local name Mem(fref=f0, mref=m0) -> $f0.m0
// [Wasm] Get Local name Mem(fref=f0, mref=m0) -> $f0.m0
// [Wasm] Get Local name Mem(fref=f0, mref=m0) -> $f0.m0
// [Wasm] Lowering control Jump(target=b3, args=[Mem(fref=f0, mref=m0)])
// [Wasm] Get Local name Mem(fref=f0, mref=m0) -> $f0.m0
// [Wasm] Get Local name BlockParam(bref=b3, bpref=$b.0) -> $b3.$b.0
// [Wasm] Lowering insn Op(ty=Int32, op=Add, args=[Insn(iref=%0), Int32(val=1)])
// [Wasm] Get Local name Insn(iref=%0) -> $%0
// [Wasm] Get Local name Insn(iref=%3) -> $%3
// [Wasm] Lowering insn Store(ty=Int32, ma=Field(ty=Int32, val=FnParam(fref=f0, fpref=$f.2), index=0, width=@32), val=Insn(iref=%3))
// [Wasm] Get Local name FnParam(fref=f0, fpref=$f.2) -> $$f.2
// [Wasm] Get Local name Insn(iref=%3) -> $%3
// [Wasm] Lowering insn Alloc(ty=Tuple(fields=[Int32, Int32]), mref=m1, fills=[Field(index=0, val=Int32(val=1)), Field(index=1, val=Insn(iref=%0))])
// [Wasm] Get Local name Mem(fref=f0, mref=m1) -> $f0.m1
// [Wasm] Get Local name Mem(fref=f0, mref=m1) -> $f0.m1
// [Wasm] Get Local name Mem(fref=f0, mref=m1) -> $f0.m1
// [Wasm] Get Local name Insn(iref=%0) -> $%0
// [Wasm] Lowering control Jump(target=b3, args=[Mem(fref=f0, mref=m1)])
// [Wasm] Get Local name Mem(fref=f0, mref=m1) -> $f0.m1
// [Wasm] Get Local name BlockParam(bref=b3, bpref=$b.0) -> $b3.$b.0
// [Wasm] Lowering insn Load(ty=Int32, ma=Field(ty=Int32, val=FnParam(fref=f0, fpref=$f.2), index=0, width=@32))
// [Wasm] Get Local name FnParam(fref=f0, fpref=$f.2) -> $$f.2
// [Wasm] Get Local name Insn(iref=%0) -> $%0
// [Wasm] Lowering insn Op(ty=Bool, op=Eq, args=[Insn(iref=%0), FnParam(fref=f0, fpref=$f.1)])
// [Wasm] Get Local name Insn(iref=%0) -> $%0
// [Wasm] Get Local name FnParam(fref=f0, fpref=$f.1) -> $$f.1
// [Wasm] Get Local name Insn(iref=%1) -> $%1
// [Wasm] Lowering control Branch(cond=Insn(iref=%1), t=b1, t_args=[], f=b2, f_args=[])
// [Wasm] Get Local name Insn(iref=%1) -> $%1
// [Wasm] Get Local name FnParam(fref=f0, fpref=$f.1) -> $$f.1
// [Wasm] Get Local name FnParam(fref=f0, fpref=$f.2) -> $$f.2
// [Wasm] Local Mem(fref=f0, mref=m0) -> $f0.m0
// [Wasm] Local Insn(iref=%1) -> $%1
// [Wasm] Local Insn(iref=%3) -> $%3
// [Wasm] Local Mem(fref=f0, mref=m1) -> $f0.m1
// [Wasm] Local BlockParam(bref=b3, bpref=$b.0) -> $b3.$b.0
// [Wasm] Local Insn(iref=%0) -> $%0
// [Wasm] Lowered function aux.12697 to wasm
// [Wasm] Lowering function T$start
// [Wasm] Lowering insn Call(ty=Unit, f=f10, args=[])
// [Wasm] Lowering control Return(args=[Insn(iref=%0)])
// [Wasm] Lowered function T$start to wasm
// [Wasm] Lowering function aux.12698
// [Wasm] Lowering control Return(args=[BlockParam(bref=b3, bpref=$b.0)])
// [Wasm] Get Local name BlockParam(bref=b3, bpref=$b.0) -> $b3.$b.0
// [Wasm] Lowering insn Alloc(ty=Tuple(fields=[Int32, Int32]), mref=m0, fills=[Field(index=0, val=Int32(val=0)), Field(index=1, val=Int32(val=0))])
// [Wasm] Get Local name Mem(fref=f1, mref=m0) -> $f1.m0
// [Wasm] Get Local name Mem(fref=f1, mref=m0) -> $f1.m0
// [Wasm] Get Local name Mem(fref=f1, mref=m0) -> $f1.m0
// [Wasm] Lowering control Jump(target=b3, args=[Mem(fref=f1, mref=m0)])
// [Wasm] Get Local name Mem(fref=f1, mref=m0) -> $f1.m0
// [Wasm] Get Local name BlockParam(bref=b3, bpref=$b.0) -> $b3.$b.0
// [Wasm] Lowering insn Op(ty=Int32, op=Add, args=[Insn(iref=%0), Int32(val=1)])
// [Wasm] Get Local name Insn(iref=%0) -> $%0
// [Wasm] Get Local name Insn(iref=%3) -> $%3
// [Wasm] Lowering insn Store(ty=Int32, ma=Field(ty=Int32, val=FnParam(fref=f1, fpref=$f.2), index=0, width=@32), val=Insn(iref=%3))
// [Wasm] Get Local name FnParam(fref=f1, fpref=$f.2) -> $$f.2
// [Wasm] Get Local name Insn(iref=%3) -> $%3
// [Wasm] Lowering insn Alloc(ty=Tuple(fields=[Int32, Int32]), mref=m1, fills=[Field(index=0, val=Int32(val=1)), Field(index=1, val=Insn(iref=%0))])
// [Wasm] Get Local name Mem(fref=f1, mref=m1) -> $f1.m1
// [Wasm] Get Local name Mem(fref=f1, mref=m1) -> $f1.m1
// [Wasm] Get Local name Mem(fref=f1, mref=m1) -> $f1.m1
// [Wasm] Get Local name Insn(iref=%0) -> $%0
// [Wasm] Lowering control Jump(target=b3, args=[Mem(fref=f1, mref=m1)])
// [Wasm] Get Local name Mem(fref=f1, mref=m1) -> $f1.m1
// [Wasm] Get Local name BlockParam(bref=b3, bpref=$b.0) -> $b3.$b.0
// [Wasm] Lowering insn Load(ty=Int32, ma=Field(ty=Int32, val=FnParam(fref=f1, fpref=$f.2), index=0, width=@32))
// [Wasm] Get Local name FnParam(fref=f1, fpref=$f.2) -> $$f.2
// [Wasm] Get Local name Insn(iref=%0) -> $%0
// [Wasm] Lowering insn Op(ty=Bool, op=Eq, args=[Insn(iref=%0), FnParam(fref=f1, fpref=$f.1)])
// [Wasm] Get Local name Insn(iref=%0) -> $%0
// [Wasm] Get Local name FnParam(fref=f1, fpref=$f.1) -> $$f.1
// [Wasm] Get Local name Insn(iref=%1) -> $%1
// [Wasm] Lowering control Branch(cond=Insn(iref=%1), t=b1, t_args=[], f=b2, f_args=[])
// [Wasm] Get Local name Insn(iref=%1) -> $%1
// [Wasm] Get Local name FnParam(fref=f1, fpref=$f.1) -> $$f.1
// [Wasm] Get Local name FnParam(fref=f1, fpref=$f.2) -> $$f.2
// [Wasm] Local Insn(iref=%1) -> $%1
// [Wasm] Local Mem(fref=f1, mref=m0) -> $f1.m0
// [Wasm] Local Insn(iref=%3) -> $%3
// [Wasm] Local Mem(fref=f1, mref=m1) -> $f1.m1
// [Wasm] Local BlockParam(bref=b3, bpref=$b.0) -> $b3.$b.0
// [Wasm] Local Insn(iref=%0) -> $%0
// [Wasm] Lowered function aux.12698 to wasm
// [Wasm] Lowering function main.12696
// [Wasm] Lowering control Return(args=[BlockParam(bref=b5, bpref=$b.0)])
// [Wasm] Lowering insn ExtCall(ty=Unit, ext_f="minimbt_print_int", args=[BlockParam(bref=b2, bpref=$b.2)])
// [Wasm] Get Local name BlockParam(bref=b2, bpref=$b.2) -> $b2.$b.2
// [Wasm] Lowering insn ExtCall(ty=Unit, ext_f="minimbt_print_char", args=[Int32(val=10)])
// [Wasm] Lowering control Jump(target=b5, args=[Unit])
// [Wasm] Lowering insn Apply(ty=Int32, f=BlockParam(bref=b2, bpref=$b.1), args=[BlockParam(bref=b2, bpref=$b.2), Insn(iref=%4)])
// [Wasm] Get Local name BlockParam(bref=b2, bpref=$b.1) -> $b2.$b.1
// [Wasm] Get Local name BlockParam(bref=b2, bpref=$b.2) -> $b2.$b.2
// [Wasm] Get Local name Insn(iref=%4) -> $%4
// [Wasm] Get Local name BlockParam(bref=b2, bpref=$b.1) -> $b2.$b.1
// [Wasm] Get Local name Insn(iref=%8) -> $%8
// [Wasm] Lowering control Jump(target=b2, args=[BlockParam(bref=b2, bpref=$b.0), BlockParam(bref=b2, bpref=$b.1), Insn(iref=%8)])
// [Wasm] Get Local name BlockParam(bref=b2, bpref=$b.0) -> $b2.$b.0
// [Wasm] Get Local name BlockParam(bref=b2, bpref=$b.0) -> $b2.$b.0
// [Wasm] Get Local name BlockParam(bref=b2, bpref=$b.1) -> $b2.$b.1
// [Wasm] Get Local name BlockParam(bref=b2, bpref=$b.1) -> $b2.$b.1
// [Wasm] Get Local name Insn(iref=%8) -> $%8
// [Wasm] Get Local name BlockParam(bref=b2, bpref=$b.2) -> $b2.$b.2
// [Wasm] Lowering insn Apply(ty=Tuple(fields=[Int32, Int32]), f=BlockParam(bref=b2, bpref=$b.0), args=[Unit])
// [Wasm] Get Local name BlockParam(bref=b2, bpref=$b.0) -> $b2.$b.0
// [Wasm] Get Local name BlockParam(bref=b2, bpref=$b.0) -> $b2.$b.0
// [Wasm] Get Local name Insn(iref=%2) -> $%2
// [Wasm] Lowering insn Load(ty=Int32, ma=Field(ty=Int32, val=Insn(iref=%2), index=0, width=@(@32, @(@32, @32))))
// [Wasm] Get Local name Insn(iref=%2) -> $%2
// [Wasm] Get Local name Insn(iref=%3) -> $%3
// [Wasm] Lowering insn Load(ty=Int32, ma=Field(ty=Int32, val=Insn(iref=%2), index=1, width=@(@32, @(@32, @32))))
// [Wasm] Get Local name Insn(iref=%2) -> $%2
// [Wasm] Get Local name Insn(iref=%4) -> $%4
// [Wasm] Lowering insn Op(ty=Bool, op=Eq, args=[Insn(iref=%3), Int32(val=0)])
// [Wasm] Get Local name Insn(iref=%3) -> $%3
// [Wasm] Get Local name Insn(iref=%5) -> $%5
// [Wasm] Lowering control Branch(cond=Insn(iref=%5), t=b3, t_args=[], f=b4, f_args=[])
// [Wasm] Get Local name Insn(iref=%5) -> $%5
// [Wasm] Lowering insn Alloc(ty=Array(elem=Int32), mref=m0, fills=[Zero])
// [Wasm] Get Local name Mem(fref=f10, mref=m0) -> $f10.m0
// [Wasm] Lowering insn Alloc(ty=Array(elem=Int32), mref=m1, fills=[Zero])
// [Wasm] Get Local name Mem(fref=f10, mref=m1) -> $f10.m1
// [Wasm] Lowering insn Alloc(ty=ClosureFn(params=[Unit], ty=Tuple(fields=[Int32, Int32])), mref=m2, fills=[Field(index=0, val=Fn(fref=f22)), Field(index=1, val=Int32(val=100)), Field(index=2, val=Int32(val=1000)), Field(index=3, val=Int32(val=1)), Field(index=4, val=Int32(val=50)), Field(index=5, val=Int32(val=1200)), Field(index=6, val=Mem(fref=f10, mref=m0)), Field(index=7, val=Mem(fref=f10, mref=m1))])
// [Wasm] Get Local name Mem(fref=f10, mref=m2) -> $f10.m2
// [Wasm] Get Local name Mem(fref=f10, mref=m2) -> $f10.m2
// [Wasm] Get Local name Mem(fref=f10, mref=m2) -> $f10.m2
// [Wasm] Get Local name Mem(fref=f10, mref=m2) -> $f10.m2
// [Wasm] Get Local name Mem(fref=f10, mref=m2) -> $f10.m2
// [Wasm] Get Local name Mem(fref=f10, mref=m2) -> $f10.m2
// [Wasm] Get Local name Mem(fref=f10, mref=m2) -> $f10.m2
// [Wasm] Get Local name Mem(fref=f10, mref=m2) -> $f10.m2
// [Wasm] Get Local name Mem(fref=f10, mref=m0) -> $f10.m0
// [Wasm] Get Local name Mem(fref=f10, mref=m2) -> $f10.m2
// [Wasm] Get Local name Mem(fref=f10, mref=m1) -> $f10.m1
// [Wasm] Lowering insn Alloc(ty=ClosureFn(params=[Int32, Int32], ty=Int32), mref=m3, fills=[Field(index=0, val=Fn(fref=f24))])
// [Wasm] Get Local name Mem(fref=f10, mref=m3) -> $f10.m3
// [Wasm] Get Local name Mem(fref=f10, mref=m3) -> $f10.m3
// [Wasm] Lowering control Jump(target=b1, args=[Mem(fref=f10, mref=m2), Mem(fref=f10, mref=m3), Int32(val=0)])
// [Wasm] Get Local name Mem(fref=f10, mref=m2) -> $f10.m2
// [Wasm] Get Local name BlockParam(bref=b2, bpref=$b.0) -> $b2.$b.0
// [Wasm] Get Local name Mem(fref=f10, mref=m3) -> $f10.m3
// [Wasm] Get Local name BlockParam(bref=b2, bpref=$b.1) -> $b2.$b.1
// [Wasm] Get Local name BlockParam(bref=b2, bpref=$b.2) -> $b2.$b.2
// [Wasm] Local Insn(iref=%3) -> $%3
// [Wasm] Local BlockParam(bref=b2, bpref=$b.0) -> $b2.$b.0
// [Wasm] Local Mem(fref=f10, mref=m0) -> $f10.m0
// [Wasm] Local Mem(fref=f10, mref=m2) -> $f10.m2
// [Wasm] Local Insn(iref=%2) -> $%2
// [Wasm] Local Insn(iref=%8) -> $%8
// [Wasm] Local BlockParam(bref=b2, bpref=$b.1) -> $b2.$b.1
// [Wasm] Local Mem(fref=f10, mref=m3) -> $f10.m3
// [Wasm] Local Mem(fref=f10, mref=m1) -> $f10.m1
// [Wasm] Local BlockParam(bref=b2, bpref=$b.2) -> $b2.$b.2
// [Wasm] Local Insn(iref=%5) -> $%5
// [Wasm] Local Insn(iref=%4) -> $%4
// [Wasm] Lowered function main.12696 to wasm
// [Wasm] Lowering function aux.12699
// [Wasm] Lowering control Return(args=[BlockParam(bref=b3, bpref=$b.0)])
// [Wasm] Get Local name BlockParam(bref=b3, bpref=$b.0) -> $b3.$b.0
// [Wasm] Lowering insn Call(ty=Tuple(fields=[Int32, Int32]), f=f1, args=[Unit, FnParam(fref=f2, fpref=$f.2), FnParam(fref=f2, fpref=$f.4)])
// [Wasm] Get Local name FnParam(fref=f2, fpref=$f.2) -> $$f.2
// [Wasm] Get Local name FnParam(fref=f2, fpref=$f.4) -> $$f.4
// [Wasm] Get Local name Insn(iref=%4) -> $%4
// [Wasm] Lowering control Jump(target=b3, args=[Insn(iref=%4)])
// [Wasm] Get Local name Insn(iref=%4) -> $%4
// [Wasm] Get Local name BlockParam(bref=b3, bpref=$b.0) -> $b3.$b.0
// [Wasm] Lowering insn Alloc(ty=Tuple(fields=[Int32, Int32]), mref=m0, fills=[Field(index=0, val=Int32(val=1)), Field(index=1, val=Insn(iref=%2))])
// [Wasm] Get Local name Mem(fref=f2, mref=m0) -> $f2.m0
// [Wasm] Get Local name Mem(fref=f2, mref=m0) -> $f2.m0
// [Wasm] Get Local name Mem(fref=f2, mref=m0) -> $f2.m0
// [Wasm] Get Local name Insn(iref=%2) -> $%2
// [Wasm] Lowering control Jump(target=b3, args=[Mem(fref=f2, mref=m0)])
// [Wasm] Get Local name Mem(fref=f2, mref=m0) -> $f2.m0
// [Wasm] Get Local name BlockParam(bref=b3, bpref=$b.0) -> $b3.$b.0
// [Wasm] Lowering insn Load(ty=Int32, ma=Field(ty=Int32, val=BlockParam(bref=b4, bpref=$b.0), index=0, width=@(@32, @(@32, @32))))
// [Wasm] Get Local name BlockParam(bref=b4, bpref=$b.0) -> $b4.$b.0
// [Wasm] Get Local name Insn(iref=%1) -> $%1
// [Wasm] Lowering insn Load(ty=Int32, ma=Field(ty=Int32, val=BlockParam(bref=b4, bpref=$b.0), index=1, width=@(@32, @(@32, @32))))
// [Wasm] Get Local name BlockParam(bref=b4, bpref=$b.0) -> $b4.$b.0
// [Wasm] Get Local name Insn(iref=%2) -> $%2
// [Wasm] Lowering insn Op(ty=Bool, op=Eq, args=[Insn(iref=%1), Int32(val=0)])
// [Wasm] Get Local name Insn(iref=%1) -> $%1
// [Wasm] Get Local name Insn(iref=%3) -> $%3
// [Wasm] Lowering control Branch(cond=Insn(iref=%3), t=b1, t_args=[], f=b2, f_args=[])
// [Wasm] Get Local name Insn(iref=%3) -> $%3
// [Wasm] Lowering control Jump(target=b4, args=[BlockParam(bref=b9, bpref=$b.0)])
// [Wasm] Get Local name BlockParam(bref=b9, bpref=$b.0) -> $b9.$b.0
// [Wasm] Get Local name BlockParam(bref=b4, bpref=$b.0) -> $b4.$b.0
// [Wasm] Lowering insn Alloc(ty=Tuple(fields=[Int32, Int32]), mref=m6, fills=[Field(index=0, val=Int32(val=0)), Field(index=1, val=Int32(val=0))])
// [Wasm] Get Local name Mem(fref=f2, mref=m6) -> $f2.m6
// [Wasm] Get Local name Mem(fref=f2, mref=m6) -> $f2.m6
// [Wasm] Get Local name Mem(fref=f2, mref=m6) -> $f2.m6
// [Wasm] Lowering control Jump(target=b9, args=[Mem(fref=f2, mref=m6)])
// [Wasm] Get Local name Mem(fref=f2, mref=m6) -> $f2.m6
// [Wasm] Get Local name BlockParam(bref=b9, bpref=$b.0) -> $b9.$b.0
// [Wasm] Lowering insn Op(ty=Int32, op=Add, args=[Insn(iref=%6), Int32(val=1)])
// [Wasm] Get Local name Insn(iref=%6) -> $%6
// [Wasm] Get Local name Insn(iref=%9) -> $%9
// [Wasm] Lowering insn Store(ty=Int32, ma=Field(ty=Int32, val=FnParam(fref=f2, fpref=$f.3), index=0, width=@32), val=Insn(iref=%9))
// [Wasm] Get Local name FnParam(fref=f2, fpref=$f.3) -> $$f.3
// [Wasm] Get Local name Insn(iref=%9) -> $%9
// [Wasm] Lowering insn Alloc(ty=Tuple(fields=[Int32, Int32]), mref=m7, fills=[Field(index=0, val=Int32(val=1)), Field(index=1, val=Insn(iref=%6))])
// [Wasm] Get Local name Mem(fref=f2, mref=m7) -> $f2.m7
// [Wasm] Get Local name Mem(fref=f2, mref=m7) -> $f2.m7
// [Wasm] Get Local name Mem(fref=f2, mref=m7) -> $f2.m7
// [Wasm] Get Local name Insn(iref=%6) -> $%6
// [Wasm] Lowering control Jump(target=b9, args=[Mem(fref=f2, mref=m7)])
// [Wasm] Get Local name Mem(fref=f2, mref=m7) -> $f2.m7
// [Wasm] Get Local name BlockParam(bref=b9, bpref=$b.0) -> $b9.$b.0
// [Wasm] Lowering insn Load(ty=Int32, ma=Field(ty=Int32, val=FnParam(fref=f2, fpref=$f.3), index=0, width=@32))
// [Wasm] Get Local name FnParam(fref=f2, fpref=$f.3) -> $$f.3
// [Wasm] Get Local name Insn(iref=%6) -> $%6
// [Wasm] Lowering insn Op(ty=Bool, op=Eq, args=[Insn(iref=%6), FnParam(fref=f2, fpref=$f.1)])
// [Wasm] Get Local name Insn(iref=%6) -> $%6
// [Wasm] Get Local name FnParam(fref=f2, fpref=$f.1) -> $$f.1
// [Wasm] Get Local name Insn(iref=%7) -> $%7
// [Wasm] Lowering control Branch(cond=Insn(iref=%7), t=b7, t_args=[], f=b8, f_args=[])
// [Wasm] Get Local name Insn(iref=%7) -> $%7
// [Wasm] Lowering control Jump(target=b6, args=[])
// [Wasm] Get Local name FnParam(fref=f2, fpref=$f.1) -> $$f.1
// [Wasm] Get Local name FnParam(fref=f2, fpref=$f.2) -> $$f.2
// [Wasm] Get Local name FnParam(fref=f2, fpref=$f.3) -> $$f.3
// [Wasm] Get Local name FnParam(fref=f2, fpref=$f.4) -> $$f.4
// [Wasm] Local Insn(iref=%3) -> $%3
// [Wasm] Local Mem(fref=f2, mref=m7) -> $f2.m7
// [Wasm] Local Mem(fref=f2, mref=m0) -> $f2.m0
// [Wasm] Local Insn(iref=%7) -> $%7
// [Wasm] Local Mem(fref=f2, mref=m6) -> $f2.m6
// [Wasm] Local BlockParam(bref=b3, bpref=$b.0) -> $b3.$b.0
// [Wasm] Local Insn(iref=%2) -> $%2
// [Wasm] Local Insn(iref=%9) -> $%9
// [Wasm] Local Insn(iref=%1) -> $%1
// [Wasm] Local BlockParam(bref=b4, bpref=$b.0) -> $b4.$b.0
// [Wasm] Local Insn(iref=%6) -> $%6
// [Wasm] Local BlockParam(bref=b9, bpref=$b.0) -> $b9.$b.0
// [Wasm] Local Insn(iref=%4) -> $%4
// [Wasm] Lowered function aux.12699 to wasm
// [Wasm] Lowering function aux.12700
// [Wasm] Lowering insn Op(ty=Int32, op=Add, args=[FnParam(fref=f3, fpref=$f.1), FnParam(fref=f3, fpref=$f.0)])
// [Wasm] Get Local name FnParam(fref=f3, fpref=$f.1) -> $$f.1
// [Wasm] Get Local name FnParam(fref=f3, fpref=$f.0) -> $$f.0
// [Wasm] Get Local name Insn(iref=%0) -> $%0
// [Wasm] Lowering control Return(args=[Insn(iref=%0)])
// [Wasm] Get Local name Insn(iref=%0) -> $%0
// [Wasm] Get Local name FnParam(fref=f3, fpref=$f.0) -> $$f.0
// [Wasm] Get Local name FnParam(fref=f3, fpref=$f.1) -> $$f.1
// [Wasm] Local Insn(iref=%0) -> $%0
// [Wasm] Lowered function aux.12700 to wasm
// [Wasm] Lowering function add.12708
// [Wasm] Lowering insn Call(ty=Int32, f=f9, args=[FnParam(fref=f24, fpref=$f.0), FnParam(fref=f24, fpref=$f.1)])
// [Wasm] Get Local name FnParam(fref=f24, fpref=$f.0) -> $$f.0
// [Wasm] Get Local name FnParam(fref=f24, fpref=$f.1) -> $$f.1
// [Wasm] Get Local name Insn(iref=%0) -> $%0
// [Wasm] Lowering control Return(args=[Insn(iref=%0)])
// [Wasm] Get Local name Insn(iref=%0) -> $%0
// [Wasm] Get Local name FnParam(fref=f24, fpref=$f.0) -> $$f.0
// [Wasm] Get Local name FnParam(fref=f24, fpref=$f.1) -> $$f.1
// [Wasm] Local Insn(iref=%0) -> $%0
// [Wasm] Lowered function add.12708 to wasm
// [Wasm] Lowering function aux.12707
// [Wasm] Get Local name FreeVar(fvref=^1) -> $^1
// [Wasm] Get Local name FreeVar(fvref=^2) -> $^2
// [Wasm] Get Local name FreeVar(fvref=^3) -> $^3
// [Wasm] Get Local name FreeVar(fvref=^4) -> $^4
// [Wasm] Get Local name FreeVar(fvref=^5) -> $^5
// [Wasm] Get Local name FreeVar(fvref=^6) -> $^6
// [Wasm] Get Local name FreeVar(fvref=^7) -> $^7
// [Wasm] Lowering insn Call(ty=Tuple(fields=[Int32, Int32]), f=f8, args=[FnParam(fref=f22, fpref=$f.0), FreeVar(fvref=^1), FreeVar(fvref=^2), FreeVar(fvref=^3), FreeVar(fvref=^4), FreeVar(fvref=^5), FreeVar(fvref=^6), FreeVar(fvref=^7)])
// [Wasm] Get Local name FreeVar(fvref=^1) -> $^1
// [Wasm] Get Local name FreeVar(fvref=^2) -> $^2
// [Wasm] Get Local name FreeVar(fvref=^3) -> $^3
// [Wasm] Get Local name FreeVar(fvref=^4) -> $^4
// [Wasm] Get Local name FreeVar(fvref=^5) -> $^5
// [Wasm] Get Local name FreeVar(fvref=^6) -> $^6
// [Wasm] Get Local name FreeVar(fvref=^7) -> $^7
// [Wasm] Get Local name Insn(iref=%0) -> $%0
// [Wasm] Lowering control Return(args=[Insn(iref=%0)])
// [Wasm] Get Local name Insn(iref=%0) -> $%0
// [Wasm] Local FreeVar(fvref=^1) -> $^1
// [Wasm] Local FreeVar(fvref=^2) -> $^2
// [Wasm] Local FreeVar(fvref=^6) -> $^6
// [Wasm] Local FreeVar(fvref=^5) -> $^5
// [Wasm] Local FreeVar(fvref=^4) -> $^4
// [Wasm] Local FreeVar(fvref=^3) -> $^3
// [Wasm] Local FreeVar(fvref=^7) -> $^7
// [Wasm] Local Insn(iref=%0) -> $%0
// [Wasm] Lowered function aux.12707 to wasm
// [KnfOpt] func_tre: map.1 false
// [KnfOpt] func_tre: aux.4 false
// [KnfOpt] func_tre: filter.15 false
// [KnfOpt] func_tre: aux.18 true
// [KnfOpt] func_tre: concat.31 false
// [KnfOpt] func_tre: aux.34 false
// [KnfOpt] func_tre: range.43 false
// [KnfOpt] func_tre: aux.48 false
// [KnfOpt] func_tre: addx.59 false
// [KnfOpt] func_tre: aux.61 false
// [KnfOpt] func_tre: fold.63 true
// [KnfOpt] func_tre: sum.73 false
// [KnfOpt] func_tre: add.75 false
// [KnfOpt] func_tre: gt.79 false
// [KnfOpt] func_tre: aux.81 false
// [KnfOpt] func_tre: le.83 false
// [KnfOpt] func_tre: aux.85 false
// [KnfOpt] func_tre: main.87 false
// [KnfOpt] freq: {map.1: Once, aux.4: AsClosure, filter.15: Many(2), aux.18: AsClosure, aux.108: Many(2), concat.31: Once, aux.34: AsClosure, range.43: Many(2), aux.48: AsClosure, addx.59: Once, aux.61: AsClosure, fold.63: Once, fold.121: Many(2), sum.73: Once, add.75: AsClosure, gt.79: Once, aux.81: AsClosure, le.83: Once, aux.85: AsClosure, main.87: Once}
// [KnfOpt] Inline threshold 14
// [KnfOpt] Fn like 2
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision fold.63 accepted
// [KnfOpt] Knf inline Some(fold) Unit
// [KnfOpt] Inline threshold 27
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 0
// [KnfOpt] Inline decision range.43 accepted
// [KnfOpt] Inline threshold 27
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 0
// [KnfOpt] Inline decision range.43 accepted
// [KnfOpt] Inline threshold 16
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 0
// [KnfOpt] Inline decision concat.31 accepted
// [KnfOpt] Inline threshold 3
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 0
// [KnfOpt] Inline decision addx.59 accepted
// [KnfOpt] Inline threshold 20
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 0
// [KnfOpt] Inline decision map.1 accepted
// [KnfOpt] Inline threshold 5
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 0
// [KnfOpt] Inline decision gt.79 accepted
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 5
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 0
// [KnfOpt] Inline decision le.83 accepted
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.141: Int = (x.142: Int, y.143: Int) {
// [KnfOpt]   Add(x.142, y.143)
// [KnfOpt] }
// [KnfOpt] let _144: Int = Int(0)
// [KnfOpt] let join fold.145: Int = (stream.146: Fun([Unit], Tuple([Int, Int])), f.147: Fun([Int, Int], Int), acc.148: Int) {
// [KnfOpt]   let _149: Unit = Unit
// [KnfOpt]   let _150: Tuple([Int, Int]) = Apply(stream.146, [_149, ])
// [KnfOpt]   let (ok.151: Var({val: Some(Int)}), val.152: Var({val: Some(Int)})) = _150
// [KnfOpt]   let _153: Int = Int(0)
// [KnfOpt]   if (ok.151 == _153) then {
// [KnfOpt]     let sum.104: Int = Var(acc.148)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _154: Int = Apply(f.147, [acc.148, val.152, ])
// [KnfOpt]     Jump(fold.145, [stream.146, f.147, _154, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.145, [under1200.103, add.141, _144, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(le) let _102: Fun([Int], Int) = Unit
// [KnfOpt] let rec aux.155: Tuple([Int, Int]) = (u.156: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.157: Tuple([Int, Int]) = (u.158: Var({val: Some(Unit)})) {
// [KnfOpt]     let _159: Unit = Unit
// [KnfOpt]     let _160: Tuple([Int, Int]) = Apply(over50.100, [_159, ])
// [KnfOpt]     let (ok.161: Var({val: Some(Int)}), val.162: Var({val: Some(Int)})) = _160
// [KnfOpt]     let _163: Int = Int(0)
// [KnfOpt]     if (ok.161 == _163) then {
// [KnfOpt]       let _164: Int = Int(0)
// [KnfOpt]       let _165: Int = Int(0)
// [KnfOpt]       Tuple([_164, _165, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.166: Int = Apply(_102, [val.162, ])
// [KnfOpt]       let _167: Int = Int(0)
// [KnfOpt]       if (r.166 == _167) then {
// [KnfOpt]         let _168: Int = Int(1)
// [KnfOpt]         Tuple([_168, val.162, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _169: Unit = Unit
// [KnfOpt]         Jump(aux.157, [_169, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.157, [u.156, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.155)
// [KnfOpt] let rec add.170: Int = (x.171: Int, y.172: Int) {
// [KnfOpt]   Add(x.171, y.172)
// [KnfOpt] }
// [KnfOpt] let _173: Int = Int(0)
// [KnfOpt] let join fold.174: Int = (stream.175: Fun([Unit], Tuple([Int, Int])), f.176: Fun([Int, Int], Int), acc.177: Int) {
// [KnfOpt]   let _178: Unit = Unit
// [KnfOpt]   let _179: Tuple([Int, Int]) = Apply(stream.175, [_178, ])
// [KnfOpt]   let (ok.180: Var({val: Some(Int)}), val.181: Var({val: Some(Int)})) = _179
// [KnfOpt]   let _182: Int = Int(0)
// [KnfOpt]   if (ok.180 == _182) then {
// [KnfOpt]     let sum.104: Int = Var(acc.177)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _183: Int = Apply(f.176, [acc.177, val.181, ])
// [KnfOpt]     Jump(fold.174, [stream.175, f.176, _183, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.174, [under1200.103, add.170, _173, ])
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.186: Int = (x.187: Int, y.188: Int) {
// [KnfOpt]   Add(x.187, y.188)
// [KnfOpt] }
// [KnfOpt] let _189: Int = Int(0)
// [KnfOpt] let join fold.190: Int = (stream.191: Fun([Unit], Tuple([Int, Int])), f.192: Fun([Int, Int], Int), acc.193: Int) {
// [KnfOpt]   let _194: Unit = Unit
// [KnfOpt]   let _195: Tuple([Int, Int]) = Apply(stream.191, [_194, ])
// [KnfOpt]   let (ok.196: Var({val: Some(Int)}), val.197: Var({val: Some(Int)})) = _195
// [KnfOpt]   let _198: Int = Int(0)
// [KnfOpt]   if (ok.196 == _198) then {
// [KnfOpt]     let sum.104: Int = Var(acc.193)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _199: Int = Apply(f.192, [acc.193, val.197, ])
// [KnfOpt]     Jump(fold.190, [stream.191, f.192, _199, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.190, [under1200.103, add.186, _189, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let over50.100: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let _101: Int = Int(1200)
// [KnfOpt] let rec aux.184: Int = (y.185: Int) {
// [KnfOpt]   if (y.185 <= _101) then {
// [KnfOpt]     Int(0)
// [KnfOpt]   } else {
// [KnfOpt]     Int(1)
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] let _102: Fun([Int], Int) = Var(aux.184)
// [KnfOpt] let rec aux.200: Tuple([Int, Int]) = (u.201: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.202: Tuple([Int, Int]) = (u.203: Var({val: Some(Unit)})) {
// [KnfOpt]     let _204: Unit = Unit
// [KnfOpt]     let _205: Tuple([Int, Int]) = Apply(over50.100, [_204, ])
// [KnfOpt]     let (ok.206: Var({val: Some(Int)}), val.207: Var({val: Some(Int)})) = _205
// [KnfOpt]     let _208: Int = Int(0)
// [KnfOpt]     if (ok.206 == _208) then {
// [KnfOpt]       let _209: Int = Int(0)
// [KnfOpt]       let _210: Int = Int(0)
// [KnfOpt]       Tuple([_209, _210, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.211: Int = Apply(_102, [val.207, ])
// [KnfOpt]       let _212: Int = Int(0)
// [KnfOpt]       if (r.211 == _212) then {
// [KnfOpt]         let _213: Int = Int(1)
// [KnfOpt]         Tuple([_213, val.207, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _214: Unit = Unit
// [KnfOpt]         Jump(aux.202, [_214, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.202, [u.201, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.200)
// [KnfOpt] let rec add.215: Int = (x.216: Int, y.217: Int) {
// [KnfOpt]   Add(x.216, y.217)
// [KnfOpt] }
// [KnfOpt] let _218: Int = Int(0)
// [KnfOpt] let join fold.219: Int = (stream.220: Fun([Unit], Tuple([Int, Int])), f.221: Fun([Int, Int], Int), acc.222: Int) {
// [KnfOpt]   let _223: Unit = Unit
// [KnfOpt]   let _224: Tuple([Int, Int]) = Apply(stream.220, [_223, ])
// [KnfOpt]   let (ok.225: Var({val: Some(Int)}), val.226: Var({val: Some(Int)})) = _224
// [KnfOpt]   let _227: Int = Int(0)
// [KnfOpt]   if (ok.225 == _227) then {
// [KnfOpt]     let sum.104: Int = Var(acc.222)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _228: Int = Apply(f.221, [acc.222, val.226, ])
// [KnfOpt]     Jump(fold.219, [stream.220, f.221, _228, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.219, [under1200.103, add.215, _218, ])
// [KnfOpt] Inline threshold 5
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 0
// [KnfOpt] Inline decision le.83 accepted
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.244: Int = (x.245: Int, y.246: Int) {
// [KnfOpt]   Add(x.245, y.246)
// [KnfOpt] }
// [KnfOpt] let _247: Int = Int(0)
// [KnfOpt] let join fold.248: Int = (stream.249: Fun([Unit], Tuple([Int, Int])), f.250: Fun([Int, Int], Int), acc.251: Int) {
// [KnfOpt]   let _252: Unit = Unit
// [KnfOpt]   let _253: Tuple([Int, Int]) = Apply(stream.249, [_252, ])
// [KnfOpt]   let (ok.254: Var({val: Some(Int)}), val.255: Var({val: Some(Int)})) = _253
// [KnfOpt]   let _256: Int = Int(0)
// [KnfOpt]   if (ok.254 == _256) then {
// [KnfOpt]     let sum.104: Int = Var(acc.251)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _257: Int = Apply(f.250, [acc.251, val.255, ])
// [KnfOpt]     Jump(fold.248, [stream.249, f.250, _257, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.248, [under1200.103, add.244, _247, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(le) let _102: Fun([Int], Int) = Unit
// [KnfOpt] let rec aux.258: Tuple([Int, Int]) = (u.259: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.260: Tuple([Int, Int]) = (u.261: Var({val: Some(Unit)})) {
// [KnfOpt]     let _262: Unit = Unit
// [KnfOpt]     let _263: Tuple([Int, Int]) = Apply(over50.100, [_262, ])
// [KnfOpt]     let (ok.264: Var({val: Some(Int)}), val.265: Var({val: Some(Int)})) = _263
// [KnfOpt]     let _266: Int = Int(0)
// [KnfOpt]     if (ok.264 == _266) then {
// [KnfOpt]       let _267: Int = Int(0)
// [KnfOpt]       let _268: Int = Int(0)
// [KnfOpt]       Tuple([_267, _268, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.269: Int = Apply(_102, [val.265, ])
// [KnfOpt]       let _270: Int = Int(0)
// [KnfOpt]       if (r.269 == _270) then {
// [KnfOpt]         let _271: Int = Int(1)
// [KnfOpt]         Tuple([_271, val.265, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _272: Unit = Unit
// [KnfOpt]         Jump(aux.260, [_272, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.260, [u.259, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.258)
// [KnfOpt] let rec add.273: Int = (x.274: Int, y.275: Int) {
// [KnfOpt]   Add(x.274, y.275)
// [KnfOpt] }
// [KnfOpt] let _276: Int = Int(0)
// [KnfOpt] let join fold.277: Int = (stream.278: Fun([Unit], Tuple([Int, Int])), f.279: Fun([Int, Int], Int), acc.280: Int) {
// [KnfOpt]   let _281: Unit = Unit
// [KnfOpt]   let _282: Tuple([Int, Int]) = Apply(stream.278, [_281, ])
// [KnfOpt]   let (ok.283: Var({val: Some(Int)}), val.284: Var({val: Some(Int)})) = _282
// [KnfOpt]   let _285: Int = Int(0)
// [KnfOpt]   if (ok.283 == _285) then {
// [KnfOpt]     let sum.104: Int = Var(acc.280)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _286: Int = Apply(f.279, [acc.280, val.284, ])
// [KnfOpt]     Jump(fold.277, [stream.278, f.279, _286, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.277, [under1200.103, add.273, _276, ])
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.289: Int = (x.290: Int, y.291: Int) {
// [KnfOpt]   Add(x.290, y.291)
// [KnfOpt] }
// [KnfOpt] let _292: Int = Int(0)
// [KnfOpt] let join fold.293: Int = (stream.294: Fun([Unit], Tuple([Int, Int])), f.295: Fun([Int, Int], Int), acc.296: Int) {
// [KnfOpt]   let _297: Unit = Unit
// [KnfOpt]   let _298: Tuple([Int, Int]) = Apply(stream.294, [_297, ])
// [KnfOpt]   let (ok.299: Var({val: Some(Int)}), val.300: Var({val: Some(Int)})) = _298
// [KnfOpt]   let _301: Int = Int(0)
// [KnfOpt]   if (ok.299 == _301) then {
// [KnfOpt]     let sum.104: Int = Var(acc.296)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _302: Int = Apply(f.295, [acc.296, val.300, ])
// [KnfOpt]     Jump(fold.293, [stream.294, f.295, _302, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.293, [under1200.103, add.289, _292, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(gt) let _99: Fun([Int], Int) = Unit
// [KnfOpt] let rec aux.229: Tuple([Int, Int]) = (u.230: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.231: Tuple([Int, Int]) = (u.232: Var({val: Some(Unit)})) {
// [KnfOpt]     let _233: Unit = Unit
// [KnfOpt]     let _234: Tuple([Int, Int]) = Apply(addone.97, [_233, ])
// [KnfOpt]     let (ok.235: Var({val: Some(Int)}), val.236: Var({val: Some(Int)})) = _234
// [KnfOpt]     let _237: Int = Int(0)
// [KnfOpt]     if (ok.235 == _237) then {
// [KnfOpt]       let _238: Int = Int(0)
// [KnfOpt]       let _239: Int = Int(0)
// [KnfOpt]       Tuple([_238, _239, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.240: Int = Apply(_99, [val.236, ])
// [KnfOpt]       let _241: Int = Int(0)
// [KnfOpt]       if (r.240 == _241) then {
// [KnfOpt]         let _242: Int = Int(1)
// [KnfOpt]         Tuple([_242, val.236, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _243: Unit = Unit
// [KnfOpt]         Jump(aux.231, [_243, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.231, [u.230, ])
// [KnfOpt] }
// [KnfOpt] let over50.100: Fun([Unit], Tuple([Int, Int])) = Var(aux.229)
// [KnfOpt] let _101: Int = Int(1200)
// [KnfOpt] let rec aux.287: Int = (y.288: Int) {
// [KnfOpt]   if (y.288 <= _101) then {
// [KnfOpt]     Int(0)
// [KnfOpt]   } else {
// [KnfOpt]     Int(1)
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] let _102: Fun([Int], Int) = Var(aux.287)
// [KnfOpt] let rec aux.303: Tuple([Int, Int]) = (u.304: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.305: Tuple([Int, Int]) = (u.306: Var({val: Some(Unit)})) {
// [KnfOpt]     let _307: Unit = Unit
// [KnfOpt]     let _308: Tuple([Int, Int]) = Apply(over50.100, [_307, ])
// [KnfOpt]     let (ok.309: Var({val: Some(Int)}), val.310: Var({val: Some(Int)})) = _308
// [KnfOpt]     let _311: Int = Int(0)
// [KnfOpt]     if (ok.309 == _311) then {
// [KnfOpt]       let _312: Int = Int(0)
// [KnfOpt]       let _313: Int = Int(0)
// [KnfOpt]       Tuple([_312, _313, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.314: Int = Apply(_102, [val.310, ])
// [KnfOpt]       let _315: Int = Int(0)
// [KnfOpt]       if (r.314 == _315) then {
// [KnfOpt]         let _316: Int = Int(1)
// [KnfOpt]         Tuple([_316, val.310, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _317: Unit = Unit
// [KnfOpt]         Jump(aux.305, [_317, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.305, [u.304, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.303)
// [KnfOpt] let rec add.318: Int = (x.319: Int, y.320: Int) {
// [KnfOpt]   Add(x.319, y.320)
// [KnfOpt] }
// [KnfOpt] let _321: Int = Int(0)
// [KnfOpt] let join fold.322: Int = (stream.323: Fun([Unit], Tuple([Int, Int])), f.324: Fun([Int, Int], Int), acc.325: Int) {
// [KnfOpt]   let _326: Unit = Unit
// [KnfOpt]   let _327: Tuple([Int, Int]) = Apply(stream.323, [_326, ])
// [KnfOpt]   let (ok.328: Var({val: Some(Int)}), val.329: Var({val: Some(Int)})) = _327
// [KnfOpt]   let _330: Int = Int(0)
// [KnfOpt]   if (ok.328 == _330) then {
// [KnfOpt]     let sum.104: Int = Var(acc.325)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _331: Int = Apply(f.324, [acc.325, val.329, ])
// [KnfOpt]     Jump(fold.322, [stream.323, f.324, _331, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.322, [under1200.103, add.318, _321, ])
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 5
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 0
// [KnfOpt] Inline decision le.83 accepted
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.334: Int = (x.335: Int, y.336: Int) {
// [KnfOpt]   Add(x.335, y.336)
// [KnfOpt] }
// [KnfOpt] let _337: Int = Int(0)
// [KnfOpt] let join fold.338: Int = (stream.339: Fun([Unit], Tuple([Int, Int])), f.340: Fun([Int, Int], Int), acc.341: Int) {
// [KnfOpt]   let _342: Unit = Unit
// [KnfOpt]   let _343: Tuple([Int, Int]) = Apply(stream.339, [_342, ])
// [KnfOpt]   let (ok.344: Var({val: Some(Int)}), val.345: Var({val: Some(Int)})) = _343
// [KnfOpt]   let _346: Int = Int(0)
// [KnfOpt]   if (ok.344 == _346) then {
// [KnfOpt]     let sum.104: Int = Var(acc.341)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _347: Int = Apply(f.340, [acc.341, val.345, ])
// [KnfOpt]     Jump(fold.338, [stream.339, f.340, _347, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.338, [under1200.103, add.334, _337, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(le) let _102: Fun([Int], Int) = Unit
// [KnfOpt] let rec aux.348: Tuple([Int, Int]) = (u.349: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.350: Tuple([Int, Int]) = (u.351: Var({val: Some(Unit)})) {
// [KnfOpt]     let _352: Unit = Unit
// [KnfOpt]     let _353: Tuple([Int, Int]) = Apply(over50.100, [_352, ])
// [KnfOpt]     let (ok.354: Var({val: Some(Int)}), val.355: Var({val: Some(Int)})) = _353
// [KnfOpt]     let _356: Int = Int(0)
// [KnfOpt]     if (ok.354 == _356) then {
// [KnfOpt]       let _357: Int = Int(0)
// [KnfOpt]       let _358: Int = Int(0)
// [KnfOpt]       Tuple([_357, _358, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.359: Int = Apply(_102, [val.355, ])
// [KnfOpt]       let _360: Int = Int(0)
// [KnfOpt]       if (r.359 == _360) then {
// [KnfOpt]         let _361: Int = Int(1)
// [KnfOpt]         Tuple([_361, val.355, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _362: Unit = Unit
// [KnfOpt]         Jump(aux.350, [_362, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.350, [u.349, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.348)
// [KnfOpt] let rec add.363: Int = (x.364: Int, y.365: Int) {
// [KnfOpt]   Add(x.364, y.365)
// [KnfOpt] }
// [KnfOpt] let _366: Int = Int(0)
// [KnfOpt] let join fold.367: Int = (stream.368: Fun([Unit], Tuple([Int, Int])), f.369: Fun([Int, Int], Int), acc.370: Int) {
// [KnfOpt]   let _371: Unit = Unit
// [KnfOpt]   let _372: Tuple([Int, Int]) = Apply(stream.368, [_371, ])
// [KnfOpt]   let (ok.373: Var({val: Some(Int)}), val.374: Var({val: Some(Int)})) = _372
// [KnfOpt]   let _375: Int = Int(0)
// [KnfOpt]   if (ok.373 == _375) then {
// [KnfOpt]     let sum.104: Int = Var(acc.370)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _376: Int = Apply(f.369, [acc.370, val.374, ])
// [KnfOpt]     Jump(fold.367, [stream.368, f.369, _376, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.367, [under1200.103, add.363, _366, ])
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.379: Int = (x.380: Int, y.381: Int) {
// [KnfOpt]   Add(x.380, y.381)
// [KnfOpt] }
// [KnfOpt] let _382: Int = Int(0)
// [KnfOpt] let join fold.383: Int = (stream.384: Fun([Unit], Tuple([Int, Int])), f.385: Fun([Int, Int], Int), acc.386: Int) {
// [KnfOpt]   let _387: Unit = Unit
// [KnfOpt]   let _388: Tuple([Int, Int]) = Apply(stream.384, [_387, ])
// [KnfOpt]   let (ok.389: Var({val: Some(Int)}), val.390: Var({val: Some(Int)})) = _388
// [KnfOpt]   let _391: Int = Int(0)
// [KnfOpt]   if (ok.389 == _391) then {
// [KnfOpt]     let sum.104: Int = Var(acc.386)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _392: Int = Apply(f.385, [acc.386, val.390, ])
// [KnfOpt]     Jump(fold.383, [stream.384, f.385, _392, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.383, [under1200.103, add.379, _382, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let over50.100: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let _101: Int = Int(1200)
// [KnfOpt] let rec aux.377: Int = (y.378: Int) {
// [KnfOpt]   if (y.378 <= _101) then {
// [KnfOpt]     Int(0)
// [KnfOpt]   } else {
// [KnfOpt]     Int(1)
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] let _102: Fun([Int], Int) = Var(aux.377)
// [KnfOpt] let rec aux.393: Tuple([Int, Int]) = (u.394: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.395: Tuple([Int, Int]) = (u.396: Var({val: Some(Unit)})) {
// [KnfOpt]     let _397: Unit = Unit
// [KnfOpt]     let _398: Tuple([Int, Int]) = Apply(over50.100, [_397, ])
// [KnfOpt]     let (ok.399: Var({val: Some(Int)}), val.400: Var({val: Some(Int)})) = _398
// [KnfOpt]     let _401: Int = Int(0)
// [KnfOpt]     if (ok.399 == _401) then {
// [KnfOpt]       let _402: Int = Int(0)
// [KnfOpt]       let _403: Int = Int(0)
// [KnfOpt]       Tuple([_402, _403, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.404: Int = Apply(_102, [val.400, ])
// [KnfOpt]       let _405: Int = Int(0)
// [KnfOpt]       if (r.404 == _405) then {
// [KnfOpt]         let _406: Int = Int(1)
// [KnfOpt]         Tuple([_406, val.400, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _407: Unit = Unit
// [KnfOpt]         Jump(aux.395, [_407, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.395, [u.394, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.393)
// [KnfOpt] let rec add.408: Int = (x.409: Int, y.410: Int) {
// [KnfOpt]   Add(x.409, y.410)
// [KnfOpt] }
// [KnfOpt] let _411: Int = Int(0)
// [KnfOpt] let join fold.412: Int = (stream.413: Fun([Unit], Tuple([Int, Int])), f.414: Fun([Int, Int], Int), acc.415: Int) {
// [KnfOpt]   let _416: Unit = Unit
// [KnfOpt]   let _417: Tuple([Int, Int]) = Apply(stream.413, [_416, ])
// [KnfOpt]   let (ok.418: Var({val: Some(Int)}), val.419: Var({val: Some(Int)})) = _417
// [KnfOpt]   let _420: Int = Int(0)
// [KnfOpt]   if (ok.418 == _420) then {
// [KnfOpt]     let sum.104: Int = Var(acc.415)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _421: Int = Apply(f.414, [acc.415, val.419, ])
// [KnfOpt]     Jump(fold.412, [stream.413, f.414, _421, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.412, [under1200.103, add.408, _411, ])
// [KnfOpt] Inline threshold 5
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 0
// [KnfOpt] Inline decision le.83 accepted
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.437: Int = (x.438: Int, y.439: Int) {
// [KnfOpt]   Add(x.438, y.439)
// [KnfOpt] }
// [KnfOpt] let _440: Int = Int(0)
// [KnfOpt] let join fold.441: Int = (stream.442: Fun([Unit], Tuple([Int, Int])), f.443: Fun([Int, Int], Int), acc.444: Int) {
// [KnfOpt]   let _445: Unit = Unit
// [KnfOpt]   let _446: Tuple([Int, Int]) = Apply(stream.442, [_445, ])
// [KnfOpt]   let (ok.447: Var({val: Some(Int)}), val.448: Var({val: Some(Int)})) = _446
// [KnfOpt]   let _449: Int = Int(0)
// [KnfOpt]   if (ok.447 == _449) then {
// [KnfOpt]     let sum.104: Int = Var(acc.444)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _450: Int = Apply(f.443, [acc.444, val.448, ])
// [KnfOpt]     Jump(fold.441, [stream.442, f.443, _450, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.441, [under1200.103, add.437, _440, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(le) let _102: Fun([Int], Int) = Unit
// [KnfOpt] let rec aux.451: Tuple([Int, Int]) = (u.452: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.453: Tuple([Int, Int]) = (u.454: Var({val: Some(Unit)})) {
// [KnfOpt]     let _455: Unit = Unit
// [KnfOpt]     let _456: Tuple([Int, Int]) = Apply(over50.100, [_455, ])
// [KnfOpt]     let (ok.457: Var({val: Some(Int)}), val.458: Var({val: Some(Int)})) = _456
// [KnfOpt]     let _459: Int = Int(0)
// [KnfOpt]     if (ok.457 == _459) then {
// [KnfOpt]       let _460: Int = Int(0)
// [KnfOpt]       let _461: Int = Int(0)
// [KnfOpt]       Tuple([_460, _461, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.462: Int = Apply(_102, [val.458, ])
// [KnfOpt]       let _463: Int = Int(0)
// [KnfOpt]       if (r.462 == _463) then {
// [KnfOpt]         let _464: Int = Int(1)
// [KnfOpt]         Tuple([_464, val.458, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _465: Unit = Unit
// [KnfOpt]         Jump(aux.453, [_465, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.453, [u.452, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.451)
// [KnfOpt] let rec add.466: Int = (x.467: Int, y.468: Int) {
// [KnfOpt]   Add(x.467, y.468)
// [KnfOpt] }
// [KnfOpt] let _469: Int = Int(0)
// [KnfOpt] let join fold.470: Int = (stream.471: Fun([Unit], Tuple([Int, Int])), f.472: Fun([Int, Int], Int), acc.473: Int) {
// [KnfOpt]   let _474: Unit = Unit
// [KnfOpt]   let _475: Tuple([Int, Int]) = Apply(stream.471, [_474, ])
// [KnfOpt]   let (ok.476: Var({val: Some(Int)}), val.477: Var({val: Some(Int)})) = _475
// [KnfOpt]   let _478: Int = Int(0)
// [KnfOpt]   if (ok.476 == _478) then {
// [KnfOpt]     let sum.104: Int = Var(acc.473)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _479: Int = Apply(f.472, [acc.473, val.477, ])
// [KnfOpt]     Jump(fold.470, [stream.471, f.472, _479, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.470, [under1200.103, add.466, _469, ])
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.482: Int = (x.483: Int, y.484: Int) {
// [KnfOpt]   Add(x.483, y.484)
// [KnfOpt] }
// [KnfOpt] let _485: Int = Int(0)
// [KnfOpt] let join fold.486: Int = (stream.487: Fun([Unit], Tuple([Int, Int])), f.488: Fun([Int, Int], Int), acc.489: Int) {
// [KnfOpt]   let _490: Unit = Unit
// [KnfOpt]   let _491: Tuple([Int, Int]) = Apply(stream.487, [_490, ])
// [KnfOpt]   let (ok.492: Var({val: Some(Int)}), val.493: Var({val: Some(Int)})) = _491
// [KnfOpt]   let _494: Int = Int(0)
// [KnfOpt]   if (ok.492 == _494) then {
// [KnfOpt]     let sum.104: Int = Var(acc.489)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _495: Int = Apply(f.488, [acc.489, val.493, ])
// [KnfOpt]     Jump(fold.486, [stream.487, f.488, _495, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.486, [under1200.103, add.482, _485, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(map) let addone.97: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let _98: Int = Int(50)
// [KnfOpt] let rec aux.332: Int = (y.333: Int) {
// [KnfOpt]   if (_98 <= y.333) then {
// [KnfOpt]     Int(0)
// [KnfOpt]   } else {
// [KnfOpt]     Int(1)
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] let _99: Fun([Int], Int) = Var(aux.332)
// [KnfOpt] let rec aux.422: Tuple([Int, Int]) = (u.423: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.424: Tuple([Int, Int]) = (u.425: Var({val: Some(Unit)})) {
// [KnfOpt]     let _426: Unit = Unit
// [KnfOpt]     let _427: Tuple([Int, Int]) = Apply(addone.97, [_426, ])
// [KnfOpt]     let (ok.428: Var({val: Some(Int)}), val.429: Var({val: Some(Int)})) = _427
// [KnfOpt]     let _430: Int = Int(0)
// [KnfOpt]     if (ok.428 == _430) then {
// [KnfOpt]       let _431: Int = Int(0)
// [KnfOpt]       let _432: Int = Int(0)
// [KnfOpt]       Tuple([_431, _432, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.433: Int = Apply(_99, [val.429, ])
// [KnfOpt]       let _434: Int = Int(0)
// [KnfOpt]       if (r.433 == _434) then {
// [KnfOpt]         let _435: Int = Int(1)
// [KnfOpt]         Tuple([_435, val.429, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _436: Unit = Unit
// [KnfOpt]         Jump(aux.424, [_436, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.424, [u.423, ])
// [KnfOpt] }
// [KnfOpt] let over50.100: Fun([Unit], Tuple([Int, Int])) = Var(aux.422)
// [KnfOpt] let _101: Int = Int(1200)
// [KnfOpt] let rec aux.480: Int = (y.481: Int) {
// [KnfOpt]   if (y.481 <= _101) then {
// [KnfOpt]     Int(0)
// [KnfOpt]   } else {
// [KnfOpt]     Int(1)
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] let _102: Fun([Int], Int) = Var(aux.480)
// [KnfOpt] let rec aux.496: Tuple([Int, Int]) = (u.497: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.498: Tuple([Int, Int]) = (u.499: Var({val: Some(Unit)})) {
// [KnfOpt]     let _500: Unit = Unit
// [KnfOpt]     let _501: Tuple([Int, Int]) = Apply(over50.100, [_500, ])
// [KnfOpt]     let (ok.502: Var({val: Some(Int)}), val.503: Var({val: Some(Int)})) = _501
// [KnfOpt]     let _504: Int = Int(0)
// [KnfOpt]     if (ok.502 == _504) then {
// [KnfOpt]       let _505: Int = Int(0)
// [KnfOpt]       let _506: Int = Int(0)
// [KnfOpt]       Tuple([_505, _506, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.507: Int = Apply(_102, [val.503, ])
// [KnfOpt]       let _508: Int = Int(0)
// [KnfOpt]       if (r.507 == _508) then {
// [KnfOpt]         let _509: Int = Int(1)
// [KnfOpt]         Tuple([_509, val.503, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _510: Unit = Unit
// [KnfOpt]         Jump(aux.498, [_510, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.498, [u.497, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.496)
// [KnfOpt] let rec add.511: Int = (x.512: Int, y.513: Int) {
// [KnfOpt]   Add(x.512, y.513)
// [KnfOpt] }
// [KnfOpt] let _514: Int = Int(0)
// [KnfOpt] let join fold.515: Int = (stream.516: Fun([Unit], Tuple([Int, Int])), f.517: Fun([Int, Int], Int), acc.518: Int) {
// [KnfOpt]   let _519: Unit = Unit
// [KnfOpt]   let _520: Tuple([Int, Int]) = Apply(stream.516, [_519, ])
// [KnfOpt]   let (ok.521: Var({val: Some(Int)}), val.522: Var({val: Some(Int)})) = _520
// [KnfOpt]   let _523: Int = Int(0)
// [KnfOpt]   if (ok.521 == _523) then {
// [KnfOpt]     let sum.104: Int = Var(acc.518)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _524: Int = Apply(f.517, [acc.518, val.522, ])
// [KnfOpt]     Jump(fold.515, [stream.516, f.517, _524, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.515, [under1200.103, add.511, _514, ])
// [KnfOpt] Inline threshold 5
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 0
// [KnfOpt] Inline decision gt.79 accepted
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 5
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 0
// [KnfOpt] Inline decision le.83 accepted
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.536: Int = (x.537: Int, y.538: Int) {
// [KnfOpt]   Add(x.537, y.538)
// [KnfOpt] }
// [KnfOpt] let _539: Int = Int(0)
// [KnfOpt] let join fold.540: Int = (stream.541: Fun([Unit], Tuple([Int, Int])), f.542: Fun([Int, Int], Int), acc.543: Int) {
// [KnfOpt]   let _544: Unit = Unit
// [KnfOpt]   let _545: Tuple([Int, Int]) = Apply(stream.541, [_544, ])
// [KnfOpt]   let (ok.546: Var({val: Some(Int)}), val.547: Var({val: Some(Int)})) = _545
// [KnfOpt]   let _548: Int = Int(0)
// [KnfOpt]   if (ok.546 == _548) then {
// [KnfOpt]     let sum.104: Int = Var(acc.543)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _549: Int = Apply(f.542, [acc.543, val.547, ])
// [KnfOpt]     Jump(fold.540, [stream.541, f.542, _549, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.540, [under1200.103, add.536, _539, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(le) let _102: Fun([Int], Int) = Unit
// [KnfOpt] let rec aux.550: Tuple([Int, Int]) = (u.551: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.552: Tuple([Int, Int]) = (u.553: Var({val: Some(Unit)})) {
// [KnfOpt]     let _554: Unit = Unit
// [KnfOpt]     let _555: Tuple([Int, Int]) = Apply(over50.100, [_554, ])
// [KnfOpt]     let (ok.556: Var({val: Some(Int)}), val.557: Var({val: Some(Int)})) = _555
// [KnfOpt]     let _558: Int = Int(0)
// [KnfOpt]     if (ok.556 == _558) then {
// [KnfOpt]       let _559: Int = Int(0)
// [KnfOpt]       let _560: Int = Int(0)
// [KnfOpt]       Tuple([_559, _560, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.561: Int = Apply(_102, [val.557, ])
// [KnfOpt]       let _562: Int = Int(0)
// [KnfOpt]       if (r.561 == _562) then {
// [KnfOpt]         let _563: Int = Int(1)
// [KnfOpt]         Tuple([_563, val.557, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _564: Unit = Unit
// [KnfOpt]         Jump(aux.552, [_564, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.552, [u.551, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.550)
// [KnfOpt] let rec add.565: Int = (x.566: Int, y.567: Int) {
// [KnfOpt]   Add(x.566, y.567)
// [KnfOpt] }
// [KnfOpt] let _568: Int = Int(0)
// [KnfOpt] let join fold.569: Int = (stream.570: Fun([Unit], Tuple([Int, Int])), f.571: Fun([Int, Int], Int), acc.572: Int) {
// [KnfOpt]   let _573: Unit = Unit
// [KnfOpt]   let _574: Tuple([Int, Int]) = Apply(stream.570, [_573, ])
// [KnfOpt]   let (ok.575: Var({val: Some(Int)}), val.576: Var({val: Some(Int)})) = _574
// [KnfOpt]   let _577: Int = Int(0)
// [KnfOpt]   if (ok.575 == _577) then {
// [KnfOpt]     let sum.104: Int = Var(acc.572)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _578: Int = Apply(f.571, [acc.572, val.576, ])
// [KnfOpt]     Jump(fold.569, [stream.570, f.571, _578, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.569, [under1200.103, add.565, _568, ])
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.581: Int = (x.582: Int, y.583: Int) {
// [KnfOpt]   Add(x.582, y.583)
// [KnfOpt] }
// [KnfOpt] let _584: Int = Int(0)
// [KnfOpt] let join fold.585: Int = (stream.586: Fun([Unit], Tuple([Int, Int])), f.587: Fun([Int, Int], Int), acc.588: Int) {
// [KnfOpt]   let _589: Unit = Unit
// [KnfOpt]   let _590: Tuple([Int, Int]) = Apply(stream.586, [_589, ])
// [KnfOpt]   let (ok.591: Var({val: Some(Int)}), val.592: Var({val: Some(Int)})) = _590
// [KnfOpt]   let _593: Int = Int(0)
// [KnfOpt]   if (ok.591 == _593) then {
// [KnfOpt]     let sum.104: Int = Var(acc.588)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _594: Int = Apply(f.587, [acc.588, val.592, ])
// [KnfOpt]     Jump(fold.585, [stream.586, f.587, _594, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.585, [under1200.103, add.581, _584, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let over50.100: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let _101: Int = Int(1200)
// [KnfOpt] let rec aux.579: Int = (y.580: Int) {
// [KnfOpt]   if (y.580 <= _101) then {
// [KnfOpt]     Int(0)
// [KnfOpt]   } else {
// [KnfOpt]     Int(1)
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] let _102: Fun([Int], Int) = Var(aux.579)
// [KnfOpt] let rec aux.595: Tuple([Int, Int]) = (u.596: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.597: Tuple([Int, Int]) = (u.598: Var({val: Some(Unit)})) {
// [KnfOpt]     let _599: Unit = Unit
// [KnfOpt]     let _600: Tuple([Int, Int]) = Apply(over50.100, [_599, ])
// [KnfOpt]     let (ok.601: Var({val: Some(Int)}), val.602: Var({val: Some(Int)})) = _600
// [KnfOpt]     let _603: Int = Int(0)
// [KnfOpt]     if (ok.601 == _603) then {
// [KnfOpt]       let _604: Int = Int(0)
// [KnfOpt]       let _605: Int = Int(0)
// [KnfOpt]       Tuple([_604, _605, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.606: Int = Apply(_102, [val.602, ])
// [KnfOpt]       let _607: Int = Int(0)
// [KnfOpt]       if (r.606 == _607) then {
// [KnfOpt]         let _608: Int = Int(1)
// [KnfOpt]         Tuple([_608, val.602, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _609: Unit = Unit
// [KnfOpt]         Jump(aux.597, [_609, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.597, [u.596, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.595)
// [KnfOpt] let rec add.610: Int = (x.611: Int, y.612: Int) {
// [KnfOpt]   Add(x.611, y.612)
// [KnfOpt] }
// [KnfOpt] let _613: Int = Int(0)
// [KnfOpt] let join fold.614: Int = (stream.615: Fun([Unit], Tuple([Int, Int])), f.616: Fun([Int, Int], Int), acc.617: Int) {
// [KnfOpt]   let _618: Unit = Unit
// [KnfOpt]   let _619: Tuple([Int, Int]) = Apply(stream.615, [_618, ])
// [KnfOpt]   let (ok.620: Var({val: Some(Int)}), val.621: Var({val: Some(Int)})) = _619
// [KnfOpt]   let _622: Int = Int(0)
// [KnfOpt]   if (ok.620 == _622) then {
// [KnfOpt]     let sum.104: Int = Var(acc.617)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _623: Int = Apply(f.616, [acc.617, val.621, ])
// [KnfOpt]     Jump(fold.614, [stream.615, f.616, _623, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.614, [under1200.103, add.610, _613, ])
// [KnfOpt] Inline threshold 5
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 0
// [KnfOpt] Inline decision le.83 accepted
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.639: Int = (x.640: Int, y.641: Int) {
// [KnfOpt]   Add(x.640, y.641)
// [KnfOpt] }
// [KnfOpt] let _642: Int = Int(0)
// [KnfOpt] let join fold.643: Int = (stream.644: Fun([Unit], Tuple([Int, Int])), f.645: Fun([Int, Int], Int), acc.646: Int) {
// [KnfOpt]   let _647: Unit = Unit
// [KnfOpt]   let _648: Tuple([Int, Int]) = Apply(stream.644, [_647, ])
// [KnfOpt]   let (ok.649: Var({val: Some(Int)}), val.650: Var({val: Some(Int)})) = _648
// [KnfOpt]   let _651: Int = Int(0)
// [KnfOpt]   if (ok.649 == _651) then {
// [KnfOpt]     let sum.104: Int = Var(acc.646)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _652: Int = Apply(f.645, [acc.646, val.650, ])
// [KnfOpt]     Jump(fold.643, [stream.644, f.645, _652, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.643, [under1200.103, add.639, _642, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(le) let _102: Fun([Int], Int) = Unit
// [KnfOpt] let rec aux.653: Tuple([Int, Int]) = (u.654: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.655: Tuple([Int, Int]) = (u.656: Var({val: Some(Unit)})) {
// [KnfOpt]     let _657: Unit = Unit
// [KnfOpt]     let _658: Tuple([Int, Int]) = Apply(over50.100, [_657, ])
// [KnfOpt]     let (ok.659: Var({val: Some(Int)}), val.660: Var({val: Some(Int)})) = _658
// [KnfOpt]     let _661: Int = Int(0)
// [KnfOpt]     if (ok.659 == _661) then {
// [KnfOpt]       let _662: Int = Int(0)
// [KnfOpt]       let _663: Int = Int(0)
// [KnfOpt]       Tuple([_662, _663, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.664: Int = Apply(_102, [val.660, ])
// [KnfOpt]       let _665: Int = Int(0)
// [KnfOpt]       if (r.664 == _665) then {
// [KnfOpt]         let _666: Int = Int(1)
// [KnfOpt]         Tuple([_666, val.660, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _667: Unit = Unit
// [KnfOpt]         Jump(aux.655, [_667, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.655, [u.654, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.653)
// [KnfOpt] let rec add.668: Int = (x.669: Int, y.670: Int) {
// [KnfOpt]   Add(x.669, y.670)
// [KnfOpt] }
// [KnfOpt] let _671: Int = Int(0)
// [KnfOpt] let join fold.672: Int = (stream.673: Fun([Unit], Tuple([Int, Int])), f.674: Fun([Int, Int], Int), acc.675: Int) {
// [KnfOpt]   let _676: Unit = Unit
// [KnfOpt]   let _677: Tuple([Int, Int]) = Apply(stream.673, [_676, ])
// [KnfOpt]   let (ok.678: Var({val: Some(Int)}), val.679: Var({val: Some(Int)})) = _677
// [KnfOpt]   let _680: Int = Int(0)
// [KnfOpt]   if (ok.678 == _680) then {
// [KnfOpt]     let sum.104: Int = Var(acc.675)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _681: Int = Apply(f.674, [acc.675, val.679, ])
// [KnfOpt]     Jump(fold.672, [stream.673, f.674, _681, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.672, [under1200.103, add.668, _671, ])
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.684: Int = (x.685: Int, y.686: Int) {
// [KnfOpt]   Add(x.685, y.686)
// [KnfOpt] }
// [KnfOpt] let _687: Int = Int(0)
// [KnfOpt] let join fold.688: Int = (stream.689: Fun([Unit], Tuple([Int, Int])), f.690: Fun([Int, Int], Int), acc.691: Int) {
// [KnfOpt]   let _692: Unit = Unit
// [KnfOpt]   let _693: Tuple([Int, Int]) = Apply(stream.689, [_692, ])
// [KnfOpt]   let (ok.694: Var({val: Some(Int)}), val.695: Var({val: Some(Int)})) = _693
// [KnfOpt]   let _696: Int = Int(0)
// [KnfOpt]   if (ok.694 == _696) then {
// [KnfOpt]     let sum.104: Int = Var(acc.691)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _697: Int = Apply(f.690, [acc.691, val.695, ])
// [KnfOpt]     Jump(fold.688, [stream.689, f.690, _697, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.688, [under1200.103, add.684, _687, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(gt) let _99: Fun([Int], Int) = Unit
// [KnfOpt] let rec aux.624: Tuple([Int, Int]) = (u.625: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.626: Tuple([Int, Int]) = (u.627: Var({val: Some(Unit)})) {
// [KnfOpt]     let _628: Unit = Unit
// [KnfOpt]     let _629: Tuple([Int, Int]) = Apply(addone.97, [_628, ])
// [KnfOpt]     let (ok.630: Var({val: Some(Int)}), val.631: Var({val: Some(Int)})) = _629
// [KnfOpt]     let _632: Int = Int(0)
// [KnfOpt]     if (ok.630 == _632) then {
// [KnfOpt]       let _633: Int = Int(0)
// [KnfOpt]       let _634: Int = Int(0)
// [KnfOpt]       Tuple([_633, _634, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.635: Int = Apply(_99, [val.631, ])
// [KnfOpt]       let _636: Int = Int(0)
// [KnfOpt]       if (r.635 == _636) then {
// [KnfOpt]         let _637: Int = Int(1)
// [KnfOpt]         Tuple([_637, val.631, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _638: Unit = Unit
// [KnfOpt]         Jump(aux.626, [_638, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.626, [u.625, ])
// [KnfOpt] }
// [KnfOpt] let over50.100: Fun([Unit], Tuple([Int, Int])) = Var(aux.624)
// [KnfOpt] let _101: Int = Int(1200)
// [KnfOpt] let rec aux.682: Int = (y.683: Int) {
// [KnfOpt]   if (y.683 <= _101) then {
// [KnfOpt]     Int(0)
// [KnfOpt]   } else {
// [KnfOpt]     Int(1)
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] let _102: Fun([Int], Int) = Var(aux.682)
// [KnfOpt] let rec aux.698: Tuple([Int, Int]) = (u.699: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.700: Tuple([Int, Int]) = (u.701: Var({val: Some(Unit)})) {
// [KnfOpt]     let _702: Unit = Unit
// [KnfOpt]     let _703: Tuple([Int, Int]) = Apply(over50.100, [_702, ])
// [KnfOpt]     let (ok.704: Var({val: Some(Int)}), val.705: Var({val: Some(Int)})) = _703
// [KnfOpt]     let _706: Int = Int(0)
// [KnfOpt]     if (ok.704 == _706) then {
// [KnfOpt]       let _707: Int = Int(0)
// [KnfOpt]       let _708: Int = Int(0)
// [KnfOpt]       Tuple([_707, _708, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.709: Int = Apply(_102, [val.705, ])
// [KnfOpt]       let _710: Int = Int(0)
// [KnfOpt]       if (r.709 == _710) then {
// [KnfOpt]         let _711: Int = Int(1)
// [KnfOpt]         Tuple([_711, val.705, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _712: Unit = Unit
// [KnfOpt]         Jump(aux.700, [_712, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.700, [u.699, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.698)
// [KnfOpt] let rec add.713: Int = (x.714: Int, y.715: Int) {
// [KnfOpt]   Add(x.714, y.715)
// [KnfOpt] }
// [KnfOpt] let _716: Int = Int(0)
// [KnfOpt] let join fold.717: Int = (stream.718: Fun([Unit], Tuple([Int, Int])), f.719: Fun([Int, Int], Int), acc.720: Int) {
// [KnfOpt]   let _721: Unit = Unit
// [KnfOpt]   let _722: Tuple([Int, Int]) = Apply(stream.718, [_721, ])
// [KnfOpt]   let (ok.723: Var({val: Some(Int)}), val.724: Var({val: Some(Int)})) = _722
// [KnfOpt]   let _725: Int = Int(0)
// [KnfOpt]   if (ok.723 == _725) then {
// [KnfOpt]     let sum.104: Int = Var(acc.720)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _726: Int = Apply(f.719, [acc.720, val.724, ])
// [KnfOpt]     Jump(fold.717, [stream.718, f.719, _726, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.717, [under1200.103, add.713, _716, ])
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 5
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 0
// [KnfOpt] Inline decision le.83 accepted
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.729: Int = (x.730: Int, y.731: Int) {
// [KnfOpt]   Add(x.730, y.731)
// [KnfOpt] }
// [KnfOpt] let _732: Int = Int(0)
// [KnfOpt] let join fold.733: Int = (stream.734: Fun([Unit], Tuple([Int, Int])), f.735: Fun([Int, Int], Int), acc.736: Int) {
// [KnfOpt]   let _737: Unit = Unit
// [KnfOpt]   let _738: Tuple([Int, Int]) = Apply(stream.734, [_737, ])
// [KnfOpt]   let (ok.739: Var({val: Some(Int)}), val.740: Var({val: Some(Int)})) = _738
// [KnfOpt]   let _741: Int = Int(0)
// [KnfOpt]   if (ok.739 == _741) then {
// [KnfOpt]     let sum.104: Int = Var(acc.736)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _742: Int = Apply(f.735, [acc.736, val.740, ])
// [KnfOpt]     Jump(fold.733, [stream.734, f.735, _742, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.733, [under1200.103, add.729, _732, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(le) let _102: Fun([Int], Int) = Unit
// [KnfOpt] let rec aux.743: Tuple([Int, Int]) = (u.744: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.745: Tuple([Int, Int]) = (u.746: Var({val: Some(Unit)})) {
// [KnfOpt]     let _747: Unit = Unit
// [KnfOpt]     let _748: Tuple([Int, Int]) = Apply(over50.100, [_747, ])
// [KnfOpt]     let (ok.749: Var({val: Some(Int)}), val.750: Var({val: Some(Int)})) = _748
// [KnfOpt]     let _751: Int = Int(0)
// [KnfOpt]     if (ok.749 == _751) then {
// [KnfOpt]       let _752: Int = Int(0)
// [KnfOpt]       let _753: Int = Int(0)
// [KnfOpt]       Tuple([_752, _753, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.754: Int = Apply(_102, [val.750, ])
// [KnfOpt]       let _755: Int = Int(0)
// [KnfOpt]       if (r.754 == _755) then {
// [KnfOpt]         let _756: Int = Int(1)
// [KnfOpt]         Tuple([_756, val.750, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _757: Unit = Unit
// [KnfOpt]         Jump(aux.745, [_757, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.745, [u.744, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.743)
// [KnfOpt] let rec add.758: Int = (x.759: Int, y.760: Int) {
// [KnfOpt]   Add(x.759, y.760)
// [KnfOpt] }
// [KnfOpt] let _761: Int = Int(0)
// [KnfOpt] let join fold.762: Int = (stream.763: Fun([Unit], Tuple([Int, Int])), f.764: Fun([Int, Int], Int), acc.765: Int) {
// [KnfOpt]   let _766: Unit = Unit
// [KnfOpt]   let _767: Tuple([Int, Int]) = Apply(stream.763, [_766, ])
// [KnfOpt]   let (ok.768: Var({val: Some(Int)}), val.769: Var({val: Some(Int)})) = _767
// [KnfOpt]   let _770: Int = Int(0)
// [KnfOpt]   if (ok.768 == _770) then {
// [KnfOpt]     let sum.104: Int = Var(acc.765)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _771: Int = Apply(f.764, [acc.765, val.769, ])
// [KnfOpt]     Jump(fold.762, [stream.763, f.764, _771, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.762, [under1200.103, add.758, _761, ])
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.774: Int = (x.775: Int, y.776: Int) {
// [KnfOpt]   Add(x.775, y.776)
// [KnfOpt] }
// [KnfOpt] let _777: Int = Int(0)
// [KnfOpt] let join fold.778: Int = (stream.779: Fun([Unit], Tuple([Int, Int])), f.780: Fun([Int, Int], Int), acc.781: Int) {
// [KnfOpt]   let _782: Unit = Unit
// [KnfOpt]   let _783: Tuple([Int, Int]) = Apply(stream.779, [_782, ])
// [KnfOpt]   let (ok.784: Var({val: Some(Int)}), val.785: Var({val: Some(Int)})) = _783
// [KnfOpt]   let _786: Int = Int(0)
// [KnfOpt]   if (ok.784 == _786) then {
// [KnfOpt]     let sum.104: Int = Var(acc.781)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _787: Int = Apply(f.780, [acc.781, val.785, ])
// [KnfOpt]     Jump(fold.778, [stream.779, f.780, _787, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.778, [under1200.103, add.774, _777, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let over50.100: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let _101: Int = Int(1200)
// [KnfOpt] let rec aux.772: Int = (y.773: Int) {
// [KnfOpt]   if (y.773 <= _101) then {
// [KnfOpt]     Int(0)
// [KnfOpt]   } else {
// [KnfOpt]     Int(1)
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] let _102: Fun([Int], Int) = Var(aux.772)
// [KnfOpt] let rec aux.788: Tuple([Int, Int]) = (u.789: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.790: Tuple([Int, Int]) = (u.791: Var({val: Some(Unit)})) {
// [KnfOpt]     let _792: Unit = Unit
// [KnfOpt]     let _793: Tuple([Int, Int]) = Apply(over50.100, [_792, ])
// [KnfOpt]     let (ok.794: Var({val: Some(Int)}), val.795: Var({val: Some(Int)})) = _793
// [KnfOpt]     let _796: Int = Int(0)
// [KnfOpt]     if (ok.794 == _796) then {
// [KnfOpt]       let _797: Int = Int(0)
// [KnfOpt]       let _798: Int = Int(0)
// [KnfOpt]       Tuple([_797, _798, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.799: Int = Apply(_102, [val.795, ])
// [KnfOpt]       let _800: Int = Int(0)
// [KnfOpt]       if (r.799 == _800) then {
// [KnfOpt]         let _801: Int = Int(1)
// [KnfOpt]         Tuple([_801, val.795, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _802: Unit = Unit
// [KnfOpt]         Jump(aux.790, [_802, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.790, [u.789, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.788)
// [KnfOpt] let rec add.803: Int = (x.804: Int, y.805: Int) {
// [KnfOpt]   Add(x.804, y.805)
// [KnfOpt] }
// [KnfOpt] let _806: Int = Int(0)
// [KnfOpt] let join fold.807: Int = (stream.808: Fun([Unit], Tuple([Int, Int])), f.809: Fun([Int, Int], Int), acc.810: Int) {
// [KnfOpt]   let _811: Unit = Unit
// [KnfOpt]   let _812: Tuple([Int, Int]) = Apply(stream.808, [_811, ])
// [KnfOpt]   let (ok.813: Var({val: Some(Int)}), val.814: Var({val: Some(Int)})) = _812
// [KnfOpt]   let _815: Int = Int(0)
// [KnfOpt]   if (ok.813 == _815) then {
// [KnfOpt]     let sum.104: Int = Var(acc.810)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _816: Int = Apply(f.809, [acc.810, val.814, ])
// [KnfOpt]     Jump(fold.807, [stream.808, f.809, _816, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.807, [under1200.103, add.803, _806, ])
// [KnfOpt] Inline threshold 5
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 0
// [KnfOpt] Inline decision le.83 accepted
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.832: Int = (x.833: Int, y.834: Int) {
// [KnfOpt]   Add(x.833, y.834)
// [KnfOpt] }
// [KnfOpt] let _835: Int = Int(0)
// [KnfOpt] let join fold.836: Int = (stream.837: Fun([Unit], Tuple([Int, Int])), f.838: Fun([Int, Int], Int), acc.839: Int) {
// [KnfOpt]   let _840: Unit = Unit
// [KnfOpt]   let _841: Tuple([Int, Int]) = Apply(stream.837, [_840, ])
// [KnfOpt]   let (ok.842: Var({val: Some(Int)}), val.843: Var({val: Some(Int)})) = _841
// [KnfOpt]   let _844: Int = Int(0)
// [KnfOpt]   if (ok.842 == _844) then {
// [KnfOpt]     let sum.104: Int = Var(acc.839)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _845: Int = Apply(f.838, [acc.839, val.843, ])
// [KnfOpt]     Jump(fold.836, [stream.837, f.838, _845, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.836, [under1200.103, add.832, _835, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(le) let _102: Fun([Int], Int) = Unit
// [KnfOpt] let rec aux.846: Tuple([Int, Int]) = (u.847: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.848: Tuple([Int, Int]) = (u.849: Var({val: Some(Unit)})) {
// [KnfOpt]     let _850: Unit = Unit
// [KnfOpt]     let _851: Tuple([Int, Int]) = Apply(over50.100, [_850, ])
// [KnfOpt]     let (ok.852: Var({val: Some(Int)}), val.853: Var({val: Some(Int)})) = _851
// [KnfOpt]     let _854: Int = Int(0)
// [KnfOpt]     if (ok.852 == _854) then {
// [KnfOpt]       let _855: Int = Int(0)
// [KnfOpt]       let _856: Int = Int(0)
// [KnfOpt]       Tuple([_855, _856, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.857: Int = Apply(_102, [val.853, ])
// [KnfOpt]       let _858: Int = Int(0)
// [KnfOpt]       if (r.857 == _858) then {
// [KnfOpt]         let _859: Int = Int(1)
// [KnfOpt]         Tuple([_859, val.853, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _860: Unit = Unit
// [KnfOpt]         Jump(aux.848, [_860, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.848, [u.847, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.846)
// [KnfOpt] let rec add.861: Int = (x.862: Int, y.863: Int) {
// [KnfOpt]   Add(x.862, y.863)
// [KnfOpt] }
// [KnfOpt] let _864: Int = Int(0)
// [KnfOpt] let join fold.865: Int = (stream.866: Fun([Unit], Tuple([Int, Int])), f.867: Fun([Int, Int], Int), acc.868: Int) {
// [KnfOpt]   let _869: Unit = Unit
// [KnfOpt]   let _870: Tuple([Int, Int]) = Apply(stream.866, [_869, ])
// [KnfOpt]   let (ok.871: Var({val: Some(Int)}), val.872: Var({val: Some(Int)})) = _870
// [KnfOpt]   let _873: Int = Int(0)
// [KnfOpt]   if (ok.871 == _873) then {
// [KnfOpt]     let sum.104: Int = Var(acc.868)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _874: Int = Apply(f.867, [acc.868, val.872, ])
// [KnfOpt]     Jump(fold.865, [stream.866, f.867, _874, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.865, [under1200.103, add.861, _864, ])
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.877: Int = (x.878: Int, y.879: Int) {
// [KnfOpt]   Add(x.878, y.879)
// [KnfOpt] }
// [KnfOpt] let _880: Int = Int(0)
// [KnfOpt] let join fold.881: Int = (stream.882: Fun([Unit], Tuple([Int, Int])), f.883: Fun([Int, Int], Int), acc.884: Int) {
// [KnfOpt]   let _885: Unit = Unit
// [KnfOpt]   let _886: Tuple([Int, Int]) = Apply(stream.882, [_885, ])
// [KnfOpt]   let (ok.887: Var({val: Some(Int)}), val.888: Var({val: Some(Int)})) = _886
// [KnfOpt]   let _889: Int = Int(0)
// [KnfOpt]   if (ok.887 == _889) then {
// [KnfOpt]     let sum.104: Int = Var(acc.884)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _890: Int = Apply(f.883, [acc.884, val.888, ])
// [KnfOpt]     Jump(fold.881, [stream.882, f.883, _890, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.881, [under1200.103, add.877, _880, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(addx) let _96: Fun([Int], Int) = Unit
// [KnfOpt] let rec aux.525: Tuple([Int, Int]) = (u.526: Var({val: Some(Unit)})) {
// [KnfOpt]   let _527: Unit = Unit
// [KnfOpt]   let _528: Tuple([Int, Int]) = Apply(catt.94, [_527, ])
// [KnfOpt]   let (ok.529: Var({val: Some(Int)}), val.530: Var({val: Some(Int)})) = _528
// [KnfOpt]   let _531: Int = Int(0)
// [KnfOpt]   if (ok.529 == _531) then {
// [KnfOpt]     let _532: Int = Int(0)
// [KnfOpt]     let _533: Int = Int(0)
// [KnfOpt]     Tuple([_532, _533, ])
// [KnfOpt]   } else {
// [KnfOpt]     let _534: Int = Int(1)
// [KnfOpt]     let _535: Int = Apply(_96, [val.530, ])
// [KnfOpt]     Tuple([_534, _535, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] let addone.97: Fun([Unit], Tuple([Int, Int])) = Var(aux.525)
// [KnfOpt] let _98: Int = Int(50)
// [KnfOpt] let rec aux.727: Int = (y.728: Int) {
// [KnfOpt]   if (_98 <= y.728) then {
// [KnfOpt]     Int(0)
// [KnfOpt]   } else {
// [KnfOpt]     Int(1)
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] let _99: Fun([Int], Int) = Var(aux.727)
// [KnfOpt] let rec aux.817: Tuple([Int, Int]) = (u.818: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.819: Tuple([Int, Int]) = (u.820: Var({val: Some(Unit)})) {
// [KnfOpt]     let _821: Unit = Unit
// [KnfOpt]     let _822: Tuple([Int, Int]) = Apply(addone.97, [_821, ])
// [KnfOpt]     let (ok.823: Var({val: Some(Int)}), val.824: Var({val: Some(Int)})) = _822
// [KnfOpt]     let _825: Int = Int(0)
// [KnfOpt]     if (ok.823 == _825) then {
// [KnfOpt]       let _826: Int = Int(0)
// [KnfOpt]       let _827: Int = Int(0)
// [KnfOpt]       Tuple([_826, _827, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.828: Int = Apply(_99, [val.824, ])
// [KnfOpt]       let _829: Int = Int(0)
// [KnfOpt]       if (r.828 == _829) then {
// [KnfOpt]         let _830: Int = Int(1)
// [KnfOpt]         Tuple([_830, val.824, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _831: Unit = Unit
// [KnfOpt]         Jump(aux.819, [_831, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.819, [u.818, ])
// [KnfOpt] }
// [KnfOpt] let over50.100: Fun([Unit], Tuple([Int, Int])) = Var(aux.817)
// [KnfOpt] let _101: Int = Int(1200)
// [KnfOpt] let rec aux.875: Int = (y.876: Int) {
// [KnfOpt]   if (y.876 <= _101) then {
// [KnfOpt]     Int(0)
// [KnfOpt]   } else {
// [KnfOpt]     Int(1)
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] let _102: Fun([Int], Int) = Var(aux.875)
// [KnfOpt] let rec aux.891: Tuple([Int, Int]) = (u.892: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.893: Tuple([Int, Int]) = (u.894: Var({val: Some(Unit)})) {
// [KnfOpt]     let _895: Unit = Unit
// [KnfOpt]     let _896: Tuple([Int, Int]) = Apply(over50.100, [_895, ])
// [KnfOpt]     let (ok.897: Var({val: Some(Int)}), val.898: Var({val: Some(Int)})) = _896
// [KnfOpt]     let _899: Int = Int(0)
// [KnfOpt]     if (ok.897 == _899) then {
// [KnfOpt]       let _900: Int = Int(0)
// [KnfOpt]       let _901: Int = Int(0)
// [KnfOpt]       Tuple([_900, _901, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.902: Int = Apply(_102, [val.898, ])
// [KnfOpt]       let _903: Int = Int(0)
// [KnfOpt]       if (r.902 == _903) then {
// [KnfOpt]         let _904: Int = Int(1)
// [KnfOpt]         Tuple([_904, val.898, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _905: Unit = Unit
// [KnfOpt]         Jump(aux.893, [_905, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.893, [u.892, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.891)
// [KnfOpt] let rec add.906: Int = (x.907: Int, y.908: Int) {
// [KnfOpt]   Add(x.907, y.908)
// [KnfOpt] }
// [KnfOpt] let _909: Int = Int(0)
// [KnfOpt] let join fold.910: Int = (stream.911: Fun([Unit], Tuple([Int, Int])), f.912: Fun([Int, Int], Int), acc.913: Int) {
// [KnfOpt]   let _914: Unit = Unit
// [KnfOpt]   let _915: Tuple([Int, Int]) = Apply(stream.911, [_914, ])
// [KnfOpt]   let (ok.916: Var({val: Some(Int)}), val.917: Var({val: Some(Int)})) = _915
// [KnfOpt]   let _918: Int = Int(0)
// [KnfOpt]   if (ok.916 == _918) then {
// [KnfOpt]     let sum.104: Int = Var(acc.913)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _919: Int = Apply(f.912, [acc.913, val.917, ])
// [KnfOpt]     Jump(fold.910, [stream.911, f.912, _919, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.910, [under1200.103, add.906, _909, ])
// [KnfOpt] Inline threshold 20
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 0
// [KnfOpt] Inline decision map.1 accepted
// [KnfOpt] Inline threshold 5
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 0
// [KnfOpt] Inline decision gt.79 accepted
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 5
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 0
// [KnfOpt] Inline decision le.83 accepted
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.922: Int = (x.923: Int, y.924: Int) {
// [KnfOpt]   Add(x.923, y.924)
// [KnfOpt] }
// [KnfOpt] let _925: Int = Int(0)
// [KnfOpt] let join fold.926: Int = (stream.927: Fun([Unit], Tuple([Int, Int])), f.928: Fun([Int, Int], Int), acc.929: Int) {
// [KnfOpt]   let _930: Unit = Unit
// [KnfOpt]   let _931: Tuple([Int, Int]) = Apply(stream.927, [_930, ])
// [KnfOpt]   let (ok.932: Var({val: Some(Int)}), val.933: Var({val: Some(Int)})) = _931
// [KnfOpt]   let _934: Int = Int(0)
// [KnfOpt]   if (ok.932 == _934) then {
// [KnfOpt]     let sum.104: Int = Var(acc.929)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _935: Int = Apply(f.928, [acc.929, val.933, ])
// [KnfOpt]     Jump(fold.926, [stream.927, f.928, _935, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.926, [under1200.103, add.922, _925, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(le) let _102: Fun([Int], Int) = Unit
// [KnfOpt] let rec aux.936: Tuple([Int, Int]) = (u.937: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.938: Tuple([Int, Int]) = (u.939: Var({val: Some(Unit)})) {
// [KnfOpt]     let _940: Unit = Unit
// [KnfOpt]     let _941: Tuple([Int, Int]) = Apply(over50.100, [_940, ])
// [KnfOpt]     let (ok.942: Var({val: Some(Int)}), val.943: Var({val: Some(Int)})) = _941
// [KnfOpt]     let _944: Int = Int(0)
// [KnfOpt]     if (ok.942 == _944) then {
// [KnfOpt]       let _945: Int = Int(0)
// [KnfOpt]       let _946: Int = Int(0)
// [KnfOpt]       Tuple([_945, _946, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.947: Int = Apply(_102, [val.943, ])
// [KnfOpt]       let _948: Int = Int(0)
// [KnfOpt]       if (r.947 == _948) then {
// [KnfOpt]         let _949: Int = Int(1)
// [KnfOpt]         Tuple([_949, val.943, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _950: Unit = Unit
// [KnfOpt]         Jump(aux.938, [_950, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.938, [u.937, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.936)
// [KnfOpt] let rec add.951: Int = (x.952: Int, y.953: Int) {
// [KnfOpt]   Add(x.952, y.953)
// [KnfOpt] }
// [KnfOpt] let _954: Int = Int(0)
// [KnfOpt] let join fold.955: Int = (stream.956: Fun([Unit], Tuple([Int, Int])), f.957: Fun([Int, Int], Int), acc.958: Int) {
// [KnfOpt]   let _959: Unit = Unit
// [KnfOpt]   let _960: Tuple([Int, Int]) = Apply(stream.956, [_959, ])
// [KnfOpt]   let (ok.961: Var({val: Some(Int)}), val.962: Var({val: Some(Int)})) = _960
// [KnfOpt]   let _963: Int = Int(0)
// [KnfOpt]   if (ok.961 == _963) then {
// [KnfOpt]     let sum.104: Int = Var(acc.958)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _964: Int = Apply(f.957, [acc.958, val.962, ])
// [KnfOpt]     Jump(fold.955, [stream.956, f.957, _964, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.955, [under1200.103, add.951, _954, ])
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.967: Int = (x.968: Int, y.969: Int) {
// [KnfOpt]   Add(x.968, y.969)
// [KnfOpt] }
// [KnfOpt] let _970: Int = Int(0)
// [KnfOpt] let join fold.971: Int = (stream.972: Fun([Unit], Tuple([Int, Int])), f.973: Fun([Int, Int], Int), acc.974: Int) {
// [KnfOpt]   let _975: Unit = Unit
// [KnfOpt]   let _976: Tuple([Int, Int]) = Apply(stream.972, [_975, ])
// [KnfOpt]   let (ok.977: Var({val: Some(Int)}), val.978: Var({val: Some(Int)})) = _976
// [KnfOpt]   let _979: Int = Int(0)
// [KnfOpt]   if (ok.977 == _979) then {
// [KnfOpt]     let sum.104: Int = Var(acc.974)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _980: Int = Apply(f.973, [acc.974, val.978, ])
// [KnfOpt]     Jump(fold.971, [stream.972, f.973, _980, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.971, [under1200.103, add.967, _970, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let over50.100: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let _101: Int = Int(1200)
// [KnfOpt] let rec aux.965: Int = (y.966: Int) {
// [KnfOpt]   if (y.966 <= _101) then {
// [KnfOpt]     Int(0)
// [KnfOpt]   } else {
// [KnfOpt]     Int(1)
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] let _102: Fun([Int], Int) = Var(aux.965)
// [KnfOpt] let rec aux.981: Tuple([Int, Int]) = (u.982: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.983: Tuple([Int, Int]) = (u.984: Var({val: Some(Unit)})) {
// [KnfOpt]     let _985: Unit = Unit
// [KnfOpt]     let _986: Tuple([Int, Int]) = Apply(over50.100, [_985, ])
// [KnfOpt]     let (ok.987: Var({val: Some(Int)}), val.988: Var({val: Some(Int)})) = _986
// [KnfOpt]     let _989: Int = Int(0)
// [KnfOpt]     if (ok.987 == _989) then {
// [KnfOpt]       let _990: Int = Int(0)
// [KnfOpt]       let _991: Int = Int(0)
// [KnfOpt]       Tuple([_990, _991, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.992: Int = Apply(_102, [val.988, ])
// [KnfOpt]       let _993: Int = Int(0)
// [KnfOpt]       if (r.992 == _993) then {
// [KnfOpt]         let _994: Int = Int(1)
// [KnfOpt]         Tuple([_994, val.988, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _995: Unit = Unit
// [KnfOpt]         Jump(aux.983, [_995, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.983, [u.982, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.981)
// [KnfOpt] let rec add.996: Int = (x.997: Int, y.998: Int) {
// [KnfOpt]   Add(x.997, y.998)
// [KnfOpt] }
// [KnfOpt] let _999: Int = Int(0)
// [KnfOpt] let join fold.1000: Int = (stream.1001: Fun([Unit], Tuple([Int, Int])), f.1002: Fun([Int, Int], Int), acc.1003: Int) {
// [KnfOpt]   let _1004: Unit = Unit
// [KnfOpt]   let _1005: Tuple([Int, Int]) = Apply(stream.1001, [_1004, ])
// [KnfOpt]   let (ok.1006: Var({val: Some(Int)}), val.1007: Var({val: Some(Int)})) = _1005
// [KnfOpt]   let _1008: Int = Int(0)
// [KnfOpt]   if (ok.1006 == _1008) then {
// [KnfOpt]     let sum.104: Int = Var(acc.1003)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _1009: Int = Apply(f.1002, [acc.1003, val.1007, ])
// [KnfOpt]     Jump(fold.1000, [stream.1001, f.1002, _1009, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.1000, [under1200.103, add.996, _999, ])
// [KnfOpt] Inline threshold 5
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 0
// [KnfOpt] Inline decision le.83 accepted
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.1025: Int = (x.1026: Int, y.1027: Int) {
// [KnfOpt]   Add(x.1026, y.1027)
// [KnfOpt] }
// [KnfOpt] let _1028: Int = Int(0)
// [KnfOpt] let join fold.1029: Int = (stream.1030: Fun([Unit], Tuple([Int, Int])), f.1031: Fun([Int, Int], Int), acc.1032: Int) {
// [KnfOpt]   let _1033: Unit = Unit
// [KnfOpt]   let _1034: Tuple([Int, Int]) = Apply(stream.1030, [_1033, ])
// [KnfOpt]   let (ok.1035: Var({val: Some(Int)}), val.1036: Var({val: Some(Int)})) = _1034
// [KnfOpt]   let _1037: Int = Int(0)
// [KnfOpt]   if (ok.1035 == _1037) then {
// [KnfOpt]     let sum.104: Int = Var(acc.1032)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _1038: Int = Apply(f.1031, [acc.1032, val.1036, ])
// [KnfOpt]     Jump(fold.1029, [stream.1030, f.1031, _1038, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.1029, [under1200.103, add.1025, _1028, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(le) let _102: Fun([Int], Int) = Unit
// [KnfOpt] let rec aux.1039: Tuple([Int, Int]) = (u.1040: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.1041: Tuple([Int, Int]) = (u.1042: Var({val: Some(Unit)})) {
// [KnfOpt]     let _1043: Unit = Unit
// [KnfOpt]     let _1044: Tuple([Int, Int]) = Apply(over50.100, [_1043, ])
// [KnfOpt]     let (ok.1045: Var({val: Some(Int)}), val.1046: Var({val: Some(Int)})) = _1044
// [KnfOpt]     let _1047: Int = Int(0)
// [KnfOpt]     if (ok.1045 == _1047) then {
// [KnfOpt]       let _1048: Int = Int(0)
// [KnfOpt]       let _1049: Int = Int(0)
// [KnfOpt]       Tuple([_1048, _1049, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.1050: Int = Apply(_102, [val.1046, ])
// [KnfOpt]       let _1051: Int = Int(0)
// [KnfOpt]       if (r.1050 == _1051) then {
// [KnfOpt]         let _1052: Int = Int(1)
// [KnfOpt]         Tuple([_1052, val.1046, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _1053: Unit = Unit
// [KnfOpt]         Jump(aux.1041, [_1053, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.1041, [u.1040, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.1039)
// [KnfOpt] let rec add.1054: Int = (x.1055: Int, y.1056: Int) {
// [KnfOpt]   Add(x.1055, y.1056)
// [KnfOpt] }
// [KnfOpt] let _1057: Int = Int(0)
// [KnfOpt] let join fold.1058: Int = (stream.1059: Fun([Unit], Tuple([Int, Int])), f.1060: Fun([Int, Int], Int), acc.1061: Int) {
// [KnfOpt]   let _1062: Unit = Unit
// [KnfOpt]   let _1063: Tuple([Int, Int]) = Apply(stream.1059, [_1062, ])
// [KnfOpt]   let (ok.1064: Var({val: Some(Int)}), val.1065: Var({val: Some(Int)})) = _1063
// [KnfOpt]   let _1066: Int = Int(0)
// [KnfOpt]   if (ok.1064 == _1066) then {
// [KnfOpt]     let sum.104: Int = Var(acc.1061)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _1067: Int = Apply(f.1060, [acc.1061, val.1065, ])
// [KnfOpt]     Jump(fold.1058, [stream.1059, f.1060, _1067, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.1058, [under1200.103, add.1054, _1057, ])
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.1070: Int = (x.1071: Int, y.1072: Int) {
// [KnfOpt]   Add(x.1071, y.1072)
// [KnfOpt] }
// [KnfOpt] let _1073: Int = Int(0)
// [KnfOpt] let join fold.1074: Int = (stream.1075: Fun([Unit], Tuple([Int, Int])), f.1076: Fun([Int, Int], Int), acc.1077: Int) {
// [KnfOpt]   let _1078: Unit = Unit
// [KnfOpt]   let _1079: Tuple([Int, Int]) = Apply(stream.1075, [_1078, ])
// [KnfOpt]   let (ok.1080: Var({val: Some(Int)}), val.1081: Var({val: Some(Int)})) = _1079
// [KnfOpt]   let _1082: Int = Int(0)
// [KnfOpt]   if (ok.1080 == _1082) then {
// [KnfOpt]     let sum.104: Int = Var(acc.1077)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _1083: Int = Apply(f.1076, [acc.1077, val.1081, ])
// [KnfOpt]     Jump(fold.1074, [stream.1075, f.1076, _1083, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.1074, [under1200.103, add.1070, _1073, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(gt) let _99: Fun([Int], Int) = Unit
// [KnfOpt] let rec aux.1010: Tuple([Int, Int]) = (u.1011: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.1012: Tuple([Int, Int]) = (u.1013: Var({val: Some(Unit)})) {
// [KnfOpt]     let _1014: Unit = Unit
// [KnfOpt]     let _1015: Tuple([Int, Int]) = Apply(addone.97, [_1014, ])
// [KnfOpt]     let (ok.1016: Var({val: Some(Int)}), val.1017: Var({val: Some(Int)})) = _1015
// [KnfOpt]     let _1018: Int = Int(0)
// [KnfOpt]     if (ok.1016 == _1018) then {
// [KnfOpt]       let _1019: Int = Int(0)
// [KnfOpt]       let _1020: Int = Int(0)
// [KnfOpt]       Tuple([_1019, _1020, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.1021: Int = Apply(_99, [val.1017, ])
// [KnfOpt]       let _1022: Int = Int(0)
// [KnfOpt]       if (r.1021 == _1022) then {
// [KnfOpt]         let _1023: Int = Int(1)
// [KnfOpt]         Tuple([_1023, val.1017, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _1024: Unit = Unit
// [KnfOpt]         Jump(aux.1012, [_1024, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.1012, [u.1011, ])
// [KnfOpt] }
// [KnfOpt] let over50.100: Fun([Unit], Tuple([Int, Int])) = Var(aux.1010)
// [KnfOpt] let _101: Int = Int(1200)
// [KnfOpt] let rec aux.1068: Int = (y.1069: Int) {
// [KnfOpt]   if (y.1069 <= _101) then {
// [KnfOpt]     Int(0)
// [KnfOpt]   } else {
// [KnfOpt]     Int(1)
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] let _102: Fun([Int], Int) = Var(aux.1068)
// [KnfOpt] let rec aux.1084: Tuple([Int, Int]) = (u.1085: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.1086: Tuple([Int, Int]) = (u.1087: Var({val: Some(Unit)})) {
// [KnfOpt]     let _1088: Unit = Unit
// [KnfOpt]     let _1089: Tuple([Int, Int]) = Apply(over50.100, [_1088, ])
// [KnfOpt]     let (ok.1090: Var({val: Some(Int)}), val.1091: Var({val: Some(Int)})) = _1089
// [KnfOpt]     let _1092: Int = Int(0)
// [KnfOpt]     if (ok.1090 == _1092) then {
// [KnfOpt]       let _1093: Int = Int(0)
// [KnfOpt]       let _1094: Int = Int(0)
// [KnfOpt]       Tuple([_1093, _1094, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.1095: Int = Apply(_102, [val.1091, ])
// [KnfOpt]       let _1096: Int = Int(0)
// [KnfOpt]       if (r.1095 == _1096) then {
// [KnfOpt]         let _1097: Int = Int(1)
// [KnfOpt]         Tuple([_1097, val.1091, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _1098: Unit = Unit
// [KnfOpt]         Jump(aux.1086, [_1098, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.1086, [u.1085, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.1084)
// [KnfOpt] let rec add.1099: Int = (x.1100: Int, y.1101: Int) {
// [KnfOpt]   Add(x.1100, y.1101)
// [KnfOpt] }
// [KnfOpt] let _1102: Int = Int(0)
// [KnfOpt] let join fold.1103: Int = (stream.1104: Fun([Unit], Tuple([Int, Int])), f.1105: Fun([Int, Int], Int), acc.1106: Int) {
// [KnfOpt]   let _1107: Unit = Unit
// [KnfOpt]   let _1108: Tuple([Int, Int]) = Apply(stream.1104, [_1107, ])
// [KnfOpt]   let (ok.1109: Var({val: Some(Int)}), val.1110: Var({val: Some(Int)})) = _1108
// [KnfOpt]   let _1111: Int = Int(0)
// [KnfOpt]   if (ok.1109 == _1111) then {
// [KnfOpt]     let sum.104: Int = Var(acc.1106)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _1112: Int = Apply(f.1105, [acc.1106, val.1110, ])
// [KnfOpt]     Jump(fold.1103, [stream.1104, f.1105, _1112, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.1103, [under1200.103, add.1099, _1102, ])
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 5
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 0
// [KnfOpt] Inline decision le.83 accepted
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.1115: Int = (x.1116: Int, y.1117: Int) {
// [KnfOpt]   Add(x.1116, y.1117)
// [KnfOpt] }
// [KnfOpt] let _1118: Int = Int(0)
// [KnfOpt] let join fold.1119: Int = (stream.1120: Fun([Unit], Tuple([Int, Int])), f.1121: Fun([Int, Int], Int), acc.1122: Int) {
// [KnfOpt]   let _1123: Unit = Unit
// [KnfOpt]   let _1124: Tuple([Int, Int]) = Apply(stream.1120, [_1123, ])
// [KnfOpt]   let (ok.1125: Var({val: Some(Int)}), val.1126: Var({val: Some(Int)})) = _1124
// [KnfOpt]   let _1127: Int = Int(0)
// [KnfOpt]   if (ok.1125 == _1127) then {
// [KnfOpt]     let sum.104: Int = Var(acc.1122)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _1128: Int = Apply(f.1121, [acc.1122, val.1126, ])
// [KnfOpt]     Jump(fold.1119, [stream.1120, f.1121, _1128, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.1119, [under1200.103, add.1115, _1118, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(le) let _102: Fun([Int], Int) = Unit
// [KnfOpt] let rec aux.1129: Tuple([Int, Int]) = (u.1130: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.1131: Tuple([Int, Int]) = (u.1132: Var({val: Some(Unit)})) {
// [KnfOpt]     let _1133: Unit = Unit
// [KnfOpt]     let _1134: Tuple([Int, Int]) = Apply(over50.100, [_1133, ])
// [KnfOpt]     let (ok.1135: Var({val: Some(Int)}), val.1136: Var({val: Some(Int)})) = _1134
// [KnfOpt]     let _1137: Int = Int(0)
// [KnfOpt]     if (ok.1135 == _1137) then {
// [KnfOpt]       let _1138: Int = Int(0)
// [KnfOpt]       let _1139: Int = Int(0)
// [KnfOpt]       Tuple([_1138, _1139, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.1140: Int = Apply(_102, [val.1136, ])
// [KnfOpt]       let _1141: Int = Int(0)
// [KnfOpt]       if (r.1140 == _1141) then {
// [KnfOpt]         let _1142: Int = Int(1)
// [KnfOpt]         Tuple([_1142, val.1136, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _1143: Unit = Unit
// [KnfOpt]         Jump(aux.1131, [_1143, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.1131, [u.1130, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.1129)
// [KnfOpt] let rec add.1144: Int = (x.1145: Int, y.1146: Int) {
// [KnfOpt]   Add(x.1145, y.1146)
// [KnfOpt] }
// [KnfOpt] let _1147: Int = Int(0)
// [KnfOpt] let join fold.1148: Int = (stream.1149: Fun([Unit], Tuple([Int, Int])), f.1150: Fun([Int, Int], Int), acc.1151: Int) {
// [KnfOpt]   let _1152: Unit = Unit
// [KnfOpt]   let _1153: Tuple([Int, Int]) = Apply(stream.1149, [_1152, ])
// [KnfOpt]   let (ok.1154: Var({val: Some(Int)}), val.1155: Var({val: Some(Int)})) = _1153
// [KnfOpt]   let _1156: Int = Int(0)
// [KnfOpt]   if (ok.1154 == _1156) then {
// [KnfOpt]     let sum.104: Int = Var(acc.1151)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _1157: Int = Apply(f.1150, [acc.1151, val.1155, ])
// [KnfOpt]     Jump(fold.1148, [stream.1149, f.1150, _1157, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.1148, [under1200.103, add.1144, _1147, ])
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.1160: Int = (x.1161: Int, y.1162: Int) {
// [KnfOpt]   Add(x.1161, y.1162)
// [KnfOpt] }
// [KnfOpt] let _1163: Int = Int(0)
// [KnfOpt] let join fold.1164: Int = (stream.1165: Fun([Unit], Tuple([Int, Int])), f.1166: Fun([Int, Int], Int), acc.1167: Int) {
// [KnfOpt]   let _1168: Unit = Unit
// [KnfOpt]   let _1169: Tuple([Int, Int]) = Apply(stream.1165, [_1168, ])
// [KnfOpt]   let (ok.1170: Var({val: Some(Int)}), val.1171: Var({val: Some(Int)})) = _1169
// [KnfOpt]   let _1172: Int = Int(0)
// [KnfOpt]   if (ok.1170 == _1172) then {
// [KnfOpt]     let sum.104: Int = Var(acc.1167)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _1173: Int = Apply(f.1166, [acc.1167, val.1171, ])
// [KnfOpt]     Jump(fold.1164, [stream.1165, f.1166, _1173, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.1164, [under1200.103, add.1160, _1163, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let over50.100: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let _101: Int = Int(1200)
// [KnfOpt] let rec aux.1158: Int = (y.1159: Int) {
// [KnfOpt]   if (y.1159 <= _101) then {
// [KnfOpt]     Int(0)
// [KnfOpt]   } else {
// [KnfOpt]     Int(1)
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] let _102: Fun([Int], Int) = Var(aux.1158)
// [KnfOpt] let rec aux.1174: Tuple([Int, Int]) = (u.1175: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.1176: Tuple([Int, Int]) = (u.1177: Var({val: Some(Unit)})) {
// [KnfOpt]     let _1178: Unit = Unit
// [KnfOpt]     let _1179: Tuple([Int, Int]) = Apply(over50.100, [_1178, ])
// [KnfOpt]     let (ok.1180: Var({val: Some(Int)}), val.1181: Var({val: Some(Int)})) = _1179
// [KnfOpt]     let _1182: Int = Int(0)
// [KnfOpt]     if (ok.1180 == _1182) then {
// [KnfOpt]       let _1183: Int = Int(0)
// [KnfOpt]       let _1184: Int = Int(0)
// [KnfOpt]       Tuple([_1183, _1184, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.1185: Int = Apply(_102, [val.1181, ])
// [KnfOpt]       let _1186: Int = Int(0)
// [KnfOpt]       if (r.1185 == _1186) then {
// [KnfOpt]         let _1187: Int = Int(1)
// [KnfOpt]         Tuple([_1187, val.1181, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _1188: Unit = Unit
// [KnfOpt]         Jump(aux.1176, [_1188, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.1176, [u.1175, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.1174)
// [KnfOpt] let rec add.1189: Int = (x.1190: Int, y.1191: Int) {
// [KnfOpt]   Add(x.1190, y.1191)
// [KnfOpt] }
// [KnfOpt] let _1192: Int = Int(0)
// [KnfOpt] let join fold.1193: Int = (stream.1194: Fun([Unit], Tuple([Int, Int])), f.1195: Fun([Int, Int], Int), acc.1196: Int) {
// [KnfOpt]   let _1197: Unit = Unit
// [KnfOpt]   let _1198: Tuple([Int, Int]) = Apply(stream.1194, [_1197, ])
// [KnfOpt]   let (ok.1199: Var({val: Some(Int)}), val.1200: Var({val: Some(Int)})) = _1198
// [KnfOpt]   let _1201: Int = Int(0)
// [KnfOpt]   if (ok.1199 == _1201) then {
// [KnfOpt]     let sum.104: Int = Var(acc.1196)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _1202: Int = Apply(f.1195, [acc.1196, val.1200, ])
// [KnfOpt]     Jump(fold.1193, [stream.1194, f.1195, _1202, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.1193, [under1200.103, add.1189, _1192, ])
// [KnfOpt] Inline threshold 5
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 0
// [KnfOpt] Inline decision le.83 accepted
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.1218: Int = (x.1219: Int, y.1220: Int) {
// [KnfOpt]   Add(x.1219, y.1220)
// [KnfOpt] }
// [KnfOpt] let _1221: Int = Int(0)
// [KnfOpt] let join fold.1222: Int = (stream.1223: Fun([Unit], Tuple([Int, Int])), f.1224: Fun([Int, Int], Int), acc.1225: Int) {
// [KnfOpt]   let _1226: Unit = Unit
// [KnfOpt]   let _1227: Tuple([Int, Int]) = Apply(stream.1223, [_1226, ])
// [KnfOpt]   let (ok.1228: Var({val: Some(Int)}), val.1229: Var({val: Some(Int)})) = _1227
// [KnfOpt]   let _1230: Int = Int(0)
// [KnfOpt]   if (ok.1228 == _1230) then {
// [KnfOpt]     let sum.104: Int = Var(acc.1225)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _1231: Int = Apply(f.1224, [acc.1225, val.1229, ])
// [KnfOpt]     Jump(fold.1222, [stream.1223, f.1224, _1231, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.1222, [under1200.103, add.1218, _1221, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(le) let _102: Fun([Int], Int) = Unit
// [KnfOpt] let rec aux.1232: Tuple([Int, Int]) = (u.1233: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.1234: Tuple([Int, Int]) = (u.1235: Var({val: Some(Unit)})) {
// [KnfOpt]     let _1236: Unit = Unit
// [KnfOpt]     let _1237: Tuple([Int, Int]) = Apply(over50.100, [_1236, ])
// [KnfOpt]     let (ok.1238: Var({val: Some(Int)}), val.1239: Var({val: Some(Int)})) = _1237
// [KnfOpt]     let _1240: Int = Int(0)
// [KnfOpt]     if (ok.1238 == _1240) then {
// [KnfOpt]       let _1241: Int = Int(0)
// [KnfOpt]       let _1242: Int = Int(0)
// [KnfOpt]       Tuple([_1241, _1242, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.1243: Int = Apply(_102, [val.1239, ])
// [KnfOpt]       let _1244: Int = Int(0)
// [KnfOpt]       if (r.1243 == _1244) then {
// [KnfOpt]         let _1245: Int = Int(1)
// [KnfOpt]         Tuple([_1245, val.1239, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _1246: Unit = Unit
// [KnfOpt]         Jump(aux.1234, [_1246, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.1234, [u.1233, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.1232)
// [KnfOpt] let rec add.1247: Int = (x.1248: Int, y.1249: Int) {
// [KnfOpt]   Add(x.1248, y.1249)
// [KnfOpt] }
// [KnfOpt] let _1250: Int = Int(0)
// [KnfOpt] let join fold.1251: Int = (stream.1252: Fun([Unit], Tuple([Int, Int])), f.1253: Fun([Int, Int], Int), acc.1254: Int) {
// [KnfOpt]   let _1255: Unit = Unit
// [KnfOpt]   let _1256: Tuple([Int, Int]) = Apply(stream.1252, [_1255, ])
// [KnfOpt]   let (ok.1257: Var({val: Some(Int)}), val.1258: Var({val: Some(Int)})) = _1256
// [KnfOpt]   let _1259: Int = Int(0)
// [KnfOpt]   if (ok.1257 == _1259) then {
// [KnfOpt]     let sum.104: Int = Var(acc.1254)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _1260: Int = Apply(f.1253, [acc.1254, val.1258, ])
// [KnfOpt]     Jump(fold.1251, [stream.1252, f.1253, _1260, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.1251, [under1200.103, add.1247, _1250, ])
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.1263: Int = (x.1264: Int, y.1265: Int) {
// [KnfOpt]   Add(x.1264, y.1265)
// [KnfOpt] }
// [KnfOpt] let _1266: Int = Int(0)
// [KnfOpt] let join fold.1267: Int = (stream.1268: Fun([Unit], Tuple([Int, Int])), f.1269: Fun([Int, Int], Int), acc.1270: Int) {
// [KnfOpt]   let _1271: Unit = Unit
// [KnfOpt]   let _1272: Tuple([Int, Int]) = Apply(stream.1268, [_1271, ])
// [KnfOpt]   let (ok.1273: Var({val: Some(Int)}), val.1274: Var({val: Some(Int)})) = _1272
// [KnfOpt]   let _1275: Int = Int(0)
// [KnfOpt]   if (ok.1273 == _1275) then {
// [KnfOpt]     let sum.104: Int = Var(acc.1270)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _1276: Int = Apply(f.1269, [acc.1270, val.1274, ])
// [KnfOpt]     Jump(fold.1267, [stream.1268, f.1269, _1276, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.1267, [under1200.103, add.1263, _1266, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(map) let addone.97: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let _98: Int = Int(50)
// [KnfOpt] let rec aux.1113: Int = (y.1114: Int) {
// [KnfOpt]   if (_98 <= y.1114) then {
// [KnfOpt]     Int(0)
// [KnfOpt]   } else {
// [KnfOpt]     Int(1)
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] let _99: Fun([Int], Int) = Var(aux.1113)
// [KnfOpt] let rec aux.1203: Tuple([Int, Int]) = (u.1204: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.1205: Tuple([Int, Int]) = (u.1206: Var({val: Some(Unit)})) {
// [KnfOpt]     let _1207: Unit = Unit
// [KnfOpt]     let _1208: Tuple([Int, Int]) = Apply(addone.97, [_1207, ])
// [KnfOpt]     let (ok.1209: Var({val: Some(Int)}), val.1210: Var({val: Some(Int)})) = _1208
// [KnfOpt]     let _1211: Int = Int(0)
// [KnfOpt]     if (ok.1209 == _1211) then {
// [KnfOpt]       let _1212: Int = Int(0)
// [KnfOpt]       let _1213: Int = Int(0)
// [KnfOpt]       Tuple([_1212, _1213, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.1214: Int = Apply(_99, [val.1210, ])
// [KnfOpt]       let _1215: Int = Int(0)
// [KnfOpt]       if (r.1214 == _1215) then {
// [KnfOpt]         let _1216: Int = Int(1)
// [KnfOpt]         Tuple([_1216, val.1210, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _1217: Unit = Unit
// [KnfOpt]         Jump(aux.1205, [_1217, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.1205, [u.1204, ])
// [KnfOpt] }
// [KnfOpt] let over50.100: Fun([Unit], Tuple([Int, Int])) = Var(aux.1203)
// [KnfOpt] let _101: Int = Int(1200)
// [KnfOpt] let rec aux.1261: Int = (y.1262: Int) {
// [KnfOpt]   if (y.1262 <= _101) then {
// [KnfOpt]     Int(0)
// [KnfOpt]   } else {
// [KnfOpt]     Int(1)
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] let _102: Fun([Int], Int) = Var(aux.1261)
// [KnfOpt] let rec aux.1277: Tuple([Int, Int]) = (u.1278: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.1279: Tuple([Int, Int]) = (u.1280: Var({val: Some(Unit)})) {
// [KnfOpt]     let _1281: Unit = Unit
// [KnfOpt]     let _1282: Tuple([Int, Int]) = Apply(over50.100, [_1281, ])
// [KnfOpt]     let (ok.1283: Var({val: Some(Int)}), val.1284: Var({val: Some(Int)})) = _1282
// [KnfOpt]     let _1285: Int = Int(0)
// [KnfOpt]     if (ok.1283 == _1285) then {
// [KnfOpt]       let _1286: Int = Int(0)
// [KnfOpt]       let _1287: Int = Int(0)
// [KnfOpt]       Tuple([_1286, _1287, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.1288: Int = Apply(_102, [val.1284, ])
// [KnfOpt]       let _1289: Int = Int(0)
// [KnfOpt]       if (r.1288 == _1289) then {
// [KnfOpt]         let _1290: Int = Int(1)
// [KnfOpt]         Tuple([_1290, val.1284, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _1291: Unit = Unit
// [KnfOpt]         Jump(aux.1279, [_1291, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.1279, [u.1278, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.1277)
// [KnfOpt] let rec add.1292: Int = (x.1293: Int, y.1294: Int) {
// [KnfOpt]   Add(x.1293, y.1294)
// [KnfOpt] }
// [KnfOpt] let _1295: Int = Int(0)
// [KnfOpt] let join fold.1296: Int = (stream.1297: Fun([Unit], Tuple([Int, Int])), f.1298: Fun([Int, Int], Int), acc.1299: Int) {
// [KnfOpt]   let _1300: Unit = Unit
// [KnfOpt]   let _1301: Tuple([Int, Int]) = Apply(stream.1297, [_1300, ])
// [KnfOpt]   let (ok.1302: Var({val: Some(Int)}), val.1303: Var({val: Some(Int)})) = _1301
// [KnfOpt]   let _1304: Int = Int(0)
// [KnfOpt]   if (ok.1302 == _1304) then {
// [KnfOpt]     let sum.104: Int = Var(acc.1299)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _1305: Int = Apply(f.1298, [acc.1299, val.1303, ])
// [KnfOpt]     Jump(fold.1296, [stream.1297, f.1298, _1305, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.1296, [under1200.103, add.1292, _1295, ])
// [KnfOpt] Inline threshold 5
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 0
// [KnfOpt] Inline decision gt.79 accepted
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 5
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 0
// [KnfOpt] Inline decision le.83 accepted
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.1317: Int = (x.1318: Int, y.1319: Int) {
// [KnfOpt]   Add(x.1318, y.1319)
// [KnfOpt] }
// [KnfOpt] let _1320: Int = Int(0)
// [KnfOpt] let join fold.1321: Int = (stream.1322: Fun([Unit], Tuple([Int, Int])), f.1323: Fun([Int, Int], Int), acc.1324: Int) {
// [KnfOpt]   let _1325: Unit = Unit
// [KnfOpt]   let _1326: Tuple([Int, Int]) = Apply(stream.1322, [_1325, ])
// [KnfOpt]   let (ok.1327: Var({val: Some(Int)}), val.1328: Var({val: Some(Int)})) = _1326
// [KnfOpt]   let _1329: Int = Int(0)
// [KnfOpt]   if (ok.1327 == _1329) then {
// [KnfOpt]     let sum.104: Int = Var(acc.1324)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _1330: Int = Apply(f.1323, [acc.1324, val.1328, ])
// [KnfOpt]     Jump(fold.1321, [stream.1322, f.1323, _1330, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.1321, [under1200.103, add.1317, _1320, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(le) let _102: Fun([Int], Int) = Unit
// [KnfOpt] let rec aux.1331: Tuple([Int, Int]) = (u.1332: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.1333: Tuple([Int, Int]) = (u.1334: Var({val: Some(Unit)})) {
// [KnfOpt]     let _1335: Unit = Unit
// [KnfOpt]     let _1336: Tuple([Int, Int]) = Apply(over50.100, [_1335, ])
// [KnfOpt]     let (ok.1337: Var({val: Some(Int)}), val.1338: Var({val: Some(Int)})) = _1336
// [KnfOpt]     let _1339: Int = Int(0)
// [KnfOpt]     if (ok.1337 == _1339) then {
// [KnfOpt]       let _1340: Int = Int(0)
// [KnfOpt]       let _1341: Int = Int(0)
// [KnfOpt]       Tuple([_1340, _1341, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.1342: Int = Apply(_102, [val.1338, ])
// [KnfOpt]       let _1343: Int = Int(0)
// [KnfOpt]       if (r.1342 == _1343) then {
// [KnfOpt]         let _1344: Int = Int(1)
// [KnfOpt]         Tuple([_1344, val.1338, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _1345: Unit = Unit
// [KnfOpt]         Jump(aux.1333, [_1345, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.1333, [u.1332, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.1331)
// [KnfOpt] let rec add.1346: Int = (x.1347: Int, y.1348: Int) {
// [KnfOpt]   Add(x.1347, y.1348)
// [KnfOpt] }
// [KnfOpt] let _1349: Int = Int(0)
// [KnfOpt] let join fold.1350: Int = (stream.1351: Fun([Unit], Tuple([Int, Int])), f.1352: Fun([Int, Int], Int), acc.1353: Int) {
// [KnfOpt]   let _1354: Unit = Unit
// [KnfOpt]   let _1355: Tuple([Int, Int]) = Apply(stream.1351, [_1354, ])
// [KnfOpt]   let (ok.1356: Var({val: Some(Int)}), val.1357: Var({val: Some(Int)})) = _1355
// [KnfOpt]   let _1358: Int = Int(0)
// [KnfOpt]   if (ok.1356 == _1358) then {
// [KnfOpt]     let sum.104: Int = Var(acc.1353)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _1359: Int = Apply(f.1352, [acc.1353, val.1357, ])
// [KnfOpt]     Jump(fold.1350, [stream.1351, f.1352, _1359, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.1350, [under1200.103, add.1346, _1349, ])
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.1362: Int = (x.1363: Int, y.1364: Int) {
// [KnfOpt]   Add(x.1363, y.1364)
// [KnfOpt] }
// [KnfOpt] let _1365: Int = Int(0)
// [KnfOpt] let join fold.1366: Int = (stream.1367: Fun([Unit], Tuple([Int, Int])), f.1368: Fun([Int, Int], Int), acc.1369: Int) {
// [KnfOpt]   let _1370: Unit = Unit
// [KnfOpt]   let _1371: Tuple([Int, Int]) = Apply(stream.1367, [_1370, ])
// [KnfOpt]   let (ok.1372: Var({val: Some(Int)}), val.1373: Var({val: Some(Int)})) = _1371
// [KnfOpt]   let _1374: Int = Int(0)
// [KnfOpt]   if (ok.1372 == _1374) then {
// [KnfOpt]     let sum.104: Int = Var(acc.1369)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _1375: Int = Apply(f.1368, [acc.1369, val.1373, ])
// [KnfOpt]     Jump(fold.1366, [stream.1367, f.1368, _1375, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.1366, [under1200.103, add.1362, _1365, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let over50.100: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let _101: Int = Int(1200)
// [KnfOpt] let rec aux.1360: Int = (y.1361: Int) {
// [KnfOpt]   if (y.1361 <= _101) then {
// [KnfOpt]     Int(0)
// [KnfOpt]   } else {
// [KnfOpt]     Int(1)
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] let _102: Fun([Int], Int) = Var(aux.1360)
// [KnfOpt] let rec aux.1376: Tuple([Int, Int]) = (u.1377: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.1378: Tuple([Int, Int]) = (u.1379: Var({val: Some(Unit)})) {
// [KnfOpt]     let _1380: Unit = Unit
// [KnfOpt]     let _1381: Tuple([Int, Int]) = Apply(over50.100, [_1380, ])
// [KnfOpt]     let (ok.1382: Var({val: Some(Int)}), val.1383: Var({val: Some(Int)})) = _1381
// [KnfOpt]     let _1384: Int = Int(0)
// [KnfOpt]     if (ok.1382 == _1384) then {
// [KnfOpt]       let _1385: Int = Int(0)
// [KnfOpt]       let _1386: Int = Int(0)
// [KnfOpt]       Tuple([_1385, _1386, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.1387: Int = Apply(_102, [val.1383, ])
// [KnfOpt]       let _1388: Int = Int(0)
// [KnfOpt]       if (r.1387 == _1388) then {
// [KnfOpt]         let _1389: Int = Int(1)
// [KnfOpt]         Tuple([_1389, val.1383, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _1390: Unit = Unit
// [KnfOpt]         Jump(aux.1378, [_1390, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.1378, [u.1377, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.1376)
// [KnfOpt] let rec add.1391: Int = (x.1392: Int, y.1393: Int) {
// [KnfOpt]   Add(x.1392, y.1393)
// [KnfOpt] }
// [KnfOpt] let _1394: Int = Int(0)
// [KnfOpt] let join fold.1395: Int = (stream.1396: Fun([Unit], Tuple([Int, Int])), f.1397: Fun([Int, Int], Int), acc.1398: Int) {
// [KnfOpt]   let _1399: Unit = Unit
// [KnfOpt]   let _1400: Tuple([Int, Int]) = Apply(stream.1396, [_1399, ])
// [KnfOpt]   let (ok.1401: Var({val: Some(Int)}), val.1402: Var({val: Some(Int)})) = _1400
// [KnfOpt]   let _1403: Int = Int(0)
// [KnfOpt]   if (ok.1401 == _1403) then {
// [KnfOpt]     let sum.104: Int = Var(acc.1398)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _1404: Int = Apply(f.1397, [acc.1398, val.1402, ])
// [KnfOpt]     Jump(fold.1395, [stream.1396, f.1397, _1404, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.1395, [under1200.103, add.1391, _1394, ])
// [KnfOpt] Inline threshold 5
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 0
// [KnfOpt] Inline decision le.83 accepted
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.1420: Int = (x.1421: Int, y.1422: Int) {
// [KnfOpt]   Add(x.1421, y.1422)
// [KnfOpt] }
// [KnfOpt] let _1423: Int = Int(0)
// [KnfOpt] let join fold.1424: Int = (stream.1425: Fun([Unit], Tuple([Int, Int])), f.1426: Fun([Int, Int], Int), acc.1427: Int) {
// [KnfOpt]   let _1428: Unit = Unit
// [KnfOpt]   let _1429: Tuple([Int, Int]) = Apply(stream.1425, [_1428, ])
// [KnfOpt]   let (ok.1430: Var({val: Some(Int)}), val.1431: Var({val: Some(Int)})) = _1429
// [KnfOpt]   let _1432: Int = Int(0)
// [KnfOpt]   if (ok.1430 == _1432) then {
// [KnfOpt]     let sum.104: Int = Var(acc.1427)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _1433: Int = Apply(f.1426, [acc.1427, val.1431, ])
// [KnfOpt]     Jump(fold.1424, [stream.1425, f.1426, _1433, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.1424, [under1200.103, add.1420, _1423, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(le) let _102: Fun([Int], Int) = Unit
// [KnfOpt] let rec aux.1434: Tuple([Int, Int]) = (u.1435: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.1436: Tuple([Int, Int]) = (u.1437: Var({val: Some(Unit)})) {
// [KnfOpt]     let _1438: Unit = Unit
// [KnfOpt]     let _1439: Tuple([Int, Int]) = Apply(over50.100, [_1438, ])
// [KnfOpt]     let (ok.1440: Var({val: Some(Int)}), val.1441: Var({val: Some(Int)})) = _1439
// [KnfOpt]     let _1442: Int = Int(0)
// [KnfOpt]     if (ok.1440 == _1442) then {
// [KnfOpt]       let _1443: Int = Int(0)
// [KnfOpt]       let _1444: Int = Int(0)
// [KnfOpt]       Tuple([_1443, _1444, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.1445: Int = Apply(_102, [val.1441, ])
// [KnfOpt]       let _1446: Int = Int(0)
// [KnfOpt]       if (r.1445 == _1446) then {
// [KnfOpt]         let _1447: Int = Int(1)
// [KnfOpt]         Tuple([_1447, val.1441, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _1448: Unit = Unit
// [KnfOpt]         Jump(aux.1436, [_1448, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.1436, [u.1435, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.1434)
// [KnfOpt] let rec add.1449: Int = (x.1450: Int, y.1451: Int) {
// [KnfOpt]   Add(x.1450, y.1451)
// [KnfOpt] }
// [KnfOpt] let _1452: Int = Int(0)
// [KnfOpt] let join fold.1453: Int = (stream.1454: Fun([Unit], Tuple([Int, Int])), f.1455: Fun([Int, Int], Int), acc.1456: Int) {
// [KnfOpt]   let _1457: Unit = Unit
// [KnfOpt]   let _1458: Tuple([Int, Int]) = Apply(stream.1454, [_1457, ])
// [KnfOpt]   let (ok.1459: Var({val: Some(Int)}), val.1460: Var({val: Some(Int)})) = _1458
// [KnfOpt]   let _1461: Int = Int(0)
// [KnfOpt]   if (ok.1459 == _1461) then {
// [KnfOpt]     let sum.104: Int = Var(acc.1456)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _1462: Int = Apply(f.1455, [acc.1456, val.1460, ])
// [KnfOpt]     Jump(fold.1453, [stream.1454, f.1455, _1462, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.1453, [under1200.103, add.1449, _1452, ])
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.1465: Int = (x.1466: Int, y.1467: Int) {
// [KnfOpt]   Add(x.1466, y.1467)
// [KnfOpt] }
// [KnfOpt] let _1468: Int = Int(0)
// [KnfOpt] let join fold.1469: Int = (stream.1470: Fun([Unit], Tuple([Int, Int])), f.1471: Fun([Int, Int], Int), acc.1472: Int) {
// [KnfOpt]   let _1473: Unit = Unit
// [KnfOpt]   let _1474: Tuple([Int, Int]) = Apply(stream.1470, [_1473, ])
// [KnfOpt]   let (ok.1475: Var({val: Some(Int)}), val.1476: Var({val: Some(Int)})) = _1474
// [KnfOpt]   let _1477: Int = Int(0)
// [KnfOpt]   if (ok.1475 == _1477) then {
// [KnfOpt]     let sum.104: Int = Var(acc.1472)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _1478: Int = Apply(f.1471, [acc.1472, val.1476, ])
// [KnfOpt]     Jump(fold.1469, [stream.1470, f.1471, _1478, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.1469, [under1200.103, add.1465, _1468, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(gt) let _99: Fun([Int], Int) = Unit
// [KnfOpt] let rec aux.1405: Tuple([Int, Int]) = (u.1406: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.1407: Tuple([Int, Int]) = (u.1408: Var({val: Some(Unit)})) {
// [KnfOpt]     let _1409: Unit = Unit
// [KnfOpt]     let _1410: Tuple([Int, Int]) = Apply(addone.97, [_1409, ])
// [KnfOpt]     let (ok.1411: Var({val: Some(Int)}), val.1412: Var({val: Some(Int)})) = _1410
// [KnfOpt]     let _1413: Int = Int(0)
// [KnfOpt]     if (ok.1411 == _1413) then {
// [KnfOpt]       let _1414: Int = Int(0)
// [KnfOpt]       let _1415: Int = Int(0)
// [KnfOpt]       Tuple([_1414, _1415, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.1416: Int = Apply(_99, [val.1412, ])
// [KnfOpt]       let _1417: Int = Int(0)
// [KnfOpt]       if (r.1416 == _1417) then {
// [KnfOpt]         let _1418: Int = Int(1)
// [KnfOpt]         Tuple([_1418, val.1412, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _1419: Unit = Unit
// [KnfOpt]         Jump(aux.1407, [_1419, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.1407, [u.1406, ])
// [KnfOpt] }
// [KnfOpt] let over50.100: Fun([Unit], Tuple([Int, Int])) = Var(aux.1405)
// [KnfOpt] let _101: Int = Int(1200)
// [KnfOpt] let rec aux.1463: Int = (y.1464: Int) {
// [KnfOpt]   if (y.1464 <= _101) then {
// [KnfOpt]     Int(0)
// [KnfOpt]   } else {
// [KnfOpt]     Int(1)
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] let _102: Fun([Int], Int) = Var(aux.1463)
// [KnfOpt] let rec aux.1479: Tuple([Int, Int]) = (u.1480: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.1481: Tuple([Int, Int]) = (u.1482: Var({val: Some(Unit)})) {
// [KnfOpt]     let _1483: Unit = Unit
// [KnfOpt]     let _1484: Tuple([Int, Int]) = Apply(over50.100, [_1483, ])
// [KnfOpt]     let (ok.1485: Var({val: Some(Int)}), val.1486: Var({val: Some(Int)})) = _1484
// [KnfOpt]     let _1487: Int = Int(0)
// [KnfOpt]     if (ok.1485 == _1487) then {
// [KnfOpt]       let _1488: Int = Int(0)
// [KnfOpt]       let _1489: Int = Int(0)
// [KnfOpt]       Tuple([_1488, _1489, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.1490: Int = Apply(_102, [val.1486, ])
// [KnfOpt]       let _1491: Int = Int(0)
// [KnfOpt]       if (r.1490 == _1491) then {
// [KnfOpt]         let _1492: Int = Int(1)
// [KnfOpt]         Tuple([_1492, val.1486, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _1493: Unit = Unit
// [KnfOpt]         Jump(aux.1481, [_1493, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.1481, [u.1480, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.1479)
// [KnfOpt] let rec add.1494: Int = (x.1495: Int, y.1496: Int) {
// [KnfOpt]   Add(x.1495, y.1496)
// [KnfOpt] }
// [KnfOpt] let _1497: Int = Int(0)
// [KnfOpt] let join fold.1498: Int = (stream.1499: Fun([Unit], Tuple([Int, Int])), f.1500: Fun([Int, Int], Int), acc.1501: Int) {
// [KnfOpt]   let _1502: Unit = Unit
// [KnfOpt]   let _1503: Tuple([Int, Int]) = Apply(stream.1499, [_1502, ])
// [KnfOpt]   let (ok.1504: Var({val: Some(Int)}), val.1505: Var({val: Some(Int)})) = _1503
// [KnfOpt]   let _1506: Int = Int(0)
// [KnfOpt]   if (ok.1504 == _1506) then {
// [KnfOpt]     let sum.104: Int = Var(acc.1501)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _1507: Int = Apply(f.1500, [acc.1501, val.1505, ])
// [KnfOpt]     Jump(fold.1498, [stream.1499, f.1500, _1507, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.1498, [under1200.103, add.1494, _1497, ])
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 5
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 0
// [KnfOpt] Inline decision le.83 accepted
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.1510: Int = (x.1511: Int, y.1512: Int) {
// [KnfOpt]   Add(x.1511, y.1512)
// [KnfOpt] }
// [KnfOpt] let _1513: Int = Int(0)
// [KnfOpt] let join fold.1514: Int = (stream.1515: Fun([Unit], Tuple([Int, Int])), f.1516: Fun([Int, Int], Int), acc.1517: Int) {
// [KnfOpt]   let _1518: Unit = Unit
// [KnfOpt]   let _1519: Tuple([Int, Int]) = Apply(stream.1515, [_1518, ])
// [KnfOpt]   let (ok.1520: Var({val: Some(Int)}), val.1521: Var({val: Some(Int)})) = _1519
// [KnfOpt]   let _1522: Int = Int(0)
// [KnfOpt]   if (ok.1520 == _1522) then {
// [KnfOpt]     let sum.104: Int = Var(acc.1517)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _1523: Int = Apply(f.1516, [acc.1517, val.1521, ])
// [KnfOpt]     Jump(fold.1514, [stream.1515, f.1516, _1523, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.1514, [under1200.103, add.1510, _1513, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(le) let _102: Fun([Int], Int) = Unit
// [KnfOpt] let rec aux.1524: Tuple([Int, Int]) = (u.1525: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.1526: Tuple([Int, Int]) = (u.1527: Var({val: Some(Unit)})) {
// [KnfOpt]     let _1528: Unit = Unit
// [KnfOpt]     let _1529: Tuple([Int, Int]) = Apply(over50.100, [_1528, ])
// [KnfOpt]     let (ok.1530: Var({val: Some(Int)}), val.1531: Var({val: Some(Int)})) = _1529
// [KnfOpt]     let _1532: Int = Int(0)
// [KnfOpt]     if (ok.1530 == _1532) then {
// [KnfOpt]       let _1533: Int = Int(0)
// [KnfOpt]       let _1534: Int = Int(0)
// [KnfOpt]       Tuple([_1533, _1534, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.1535: Int = Apply(_102, [val.1531, ])
// [KnfOpt]       let _1536: Int = Int(0)
// [KnfOpt]       if (r.1535 == _1536) then {
// [KnfOpt]         let _1537: Int = Int(1)
// [KnfOpt]         Tuple([_1537, val.1531, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _1538: Unit = Unit
// [KnfOpt]         Jump(aux.1526, [_1538, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.1526, [u.1525, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.1524)
// [KnfOpt] let rec add.1539: Int = (x.1540: Int, y.1541: Int) {
// [KnfOpt]   Add(x.1540, y.1541)
// [KnfOpt] }
// [KnfOpt] let _1542: Int = Int(0)
// [KnfOpt] let join fold.1543: Int = (stream.1544: Fun([Unit], Tuple([Int, Int])), f.1545: Fun([Int, Int], Int), acc.1546: Int) {
// [KnfOpt]   let _1547: Unit = Unit
// [KnfOpt]   let _1548: Tuple([Int, Int]) = Apply(stream.1544, [_1547, ])
// [KnfOpt]   let (ok.1549: Var({val: Some(Int)}), val.1550: Var({val: Some(Int)})) = _1548
// [KnfOpt]   let _1551: Int = Int(0)
// [KnfOpt]   if (ok.1549 == _1551) then {
// [KnfOpt]     let sum.104: Int = Var(acc.1546)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _1552: Int = Apply(f.1545, [acc.1546, val.1550, ])
// [KnfOpt]     Jump(fold.1543, [stream.1544, f.1545, _1552, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.1543, [under1200.103, add.1539, _1542, ])
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.1555: Int = (x.1556: Int, y.1557: Int) {
// [KnfOpt]   Add(x.1556, y.1557)
// [KnfOpt] }
// [KnfOpt] let _1558: Int = Int(0)
// [KnfOpt] let join fold.1559: Int = (stream.1560: Fun([Unit], Tuple([Int, Int])), f.1561: Fun([Int, Int], Int), acc.1562: Int) {
// [KnfOpt]   let _1563: Unit = Unit
// [KnfOpt]   let _1564: Tuple([Int, Int]) = Apply(stream.1560, [_1563, ])
// [KnfOpt]   let (ok.1565: Var({val: Some(Int)}), val.1566: Var({val: Some(Int)})) = _1564
// [KnfOpt]   let _1567: Int = Int(0)
// [KnfOpt]   if (ok.1565 == _1567) then {
// [KnfOpt]     let sum.104: Int = Var(acc.1562)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _1568: Int = Apply(f.1561, [acc.1562, val.1566, ])
// [KnfOpt]     Jump(fold.1559, [stream.1560, f.1561, _1568, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.1559, [under1200.103, add.1555, _1558, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let over50.100: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let _101: Int = Int(1200)
// [KnfOpt] let rec aux.1553: Int = (y.1554: Int) {
// [KnfOpt]   if (y.1554 <= _101) then {
// [KnfOpt]     Int(0)
// [KnfOpt]   } else {
// [KnfOpt]     Int(1)
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] let _102: Fun([Int], Int) = Var(aux.1553)
// [KnfOpt] let rec aux.1569: Tuple([Int, Int]) = (u.1570: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.1571: Tuple([Int, Int]) = (u.1572: Var({val: Some(Unit)})) {
// [KnfOpt]     let _1573: Unit = Unit
// [KnfOpt]     let _1574: Tuple([Int, Int]) = Apply(over50.100, [_1573, ])
// [KnfOpt]     let (ok.1575: Var({val: Some(Int)}), val.1576: Var({val: Some(Int)})) = _1574
// [KnfOpt]     let _1577: Int = Int(0)
// [KnfOpt]     if (ok.1575 == _1577) then {
// [KnfOpt]       let _1578: Int = Int(0)
// [KnfOpt]       let _1579: Int = Int(0)
// [KnfOpt]       Tuple([_1578, _1579, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.1580: Int = Apply(_102, [val.1576, ])
// [KnfOpt]       let _1581: Int = Int(0)
// [KnfOpt]       if (r.1580 == _1581) then {
// [KnfOpt]         let _1582: Int = Int(1)
// [KnfOpt]         Tuple([_1582, val.1576, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _1583: Unit = Unit
// [KnfOpt]         Jump(aux.1571, [_1583, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.1571, [u.1570, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.1569)
// [KnfOpt] let rec add.1584: Int = (x.1585: Int, y.1586: Int) {
// [KnfOpt]   Add(x.1585, y.1586)
// [KnfOpt] }
// [KnfOpt] let _1587: Int = Int(0)
// [KnfOpt] let join fold.1588: Int = (stream.1589: Fun([Unit], Tuple([Int, Int])), f.1590: Fun([Int, Int], Int), acc.1591: Int) {
// [KnfOpt]   let _1592: Unit = Unit
// [KnfOpt]   let _1593: Tuple([Int, Int]) = Apply(stream.1589, [_1592, ])
// [KnfOpt]   let (ok.1594: Var({val: Some(Int)}), val.1595: Var({val: Some(Int)})) = _1593
// [KnfOpt]   let _1596: Int = Int(0)
// [KnfOpt]   if (ok.1594 == _1596) then {
// [KnfOpt]     let sum.104: Int = Var(acc.1591)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _1597: Int = Apply(f.1590, [acc.1591, val.1595, ])
// [KnfOpt]     Jump(fold.1588, [stream.1589, f.1590, _1597, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.1588, [under1200.103, add.1584, _1587, ])
// [KnfOpt] Inline threshold 5
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 0
// [KnfOpt] Inline decision le.83 accepted
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.1613: Int = (x.1614: Int, y.1615: Int) {
// [KnfOpt]   Add(x.1614, y.1615)
// [KnfOpt] }
// [KnfOpt] let _1616: Int = Int(0)
// [KnfOpt] let join fold.1617: Int = (stream.1618: Fun([Unit], Tuple([Int, Int])), f.1619: Fun([Int, Int], Int), acc.1620: Int) {
// [KnfOpt]   let _1621: Unit = Unit
// [KnfOpt]   let _1622: Tuple([Int, Int]) = Apply(stream.1618, [_1621, ])
// [KnfOpt]   let (ok.1623: Var({val: Some(Int)}), val.1624: Var({val: Some(Int)})) = _1622
// [KnfOpt]   let _1625: Int = Int(0)
// [KnfOpt]   if (ok.1623 == _1625) then {
// [KnfOpt]     let sum.104: Int = Var(acc.1620)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _1626: Int = Apply(f.1619, [acc.1620, val.1624, ])
// [KnfOpt]     Jump(fold.1617, [stream.1618, f.1619, _1626, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.1617, [under1200.103, add.1613, _1616, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(le) let _102: Fun([Int], Int) = Unit
// [KnfOpt] let rec aux.1627: Tuple([Int, Int]) = (u.1628: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.1629: Tuple([Int, Int]) = (u.1630: Var({val: Some(Unit)})) {
// [KnfOpt]     let _1631: Unit = Unit
// [KnfOpt]     let _1632: Tuple([Int, Int]) = Apply(over50.100, [_1631, ])
// [KnfOpt]     let (ok.1633: Var({val: Some(Int)}), val.1634: Var({val: Some(Int)})) = _1632
// [KnfOpt]     let _1635: Int = Int(0)
// [KnfOpt]     if (ok.1633 == _1635) then {
// [KnfOpt]       let _1636: Int = Int(0)
// [KnfOpt]       let _1637: Int = Int(0)
// [KnfOpt]       Tuple([_1636, _1637, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.1638: Int = Apply(_102, [val.1634, ])
// [KnfOpt]       let _1639: Int = Int(0)
// [KnfOpt]       if (r.1638 == _1639) then {
// [KnfOpt]         let _1640: Int = Int(1)
// [KnfOpt]         Tuple([_1640, val.1634, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _1641: Unit = Unit
// [KnfOpt]         Jump(aux.1629, [_1641, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.1629, [u.1628, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.1627)
// [KnfOpt] let rec add.1642: Int = (x.1643: Int, y.1644: Int) {
// [KnfOpt]   Add(x.1643, y.1644)
// [KnfOpt] }
// [KnfOpt] let _1645: Int = Int(0)
// [KnfOpt] let join fold.1646: Int = (stream.1647: Fun([Unit], Tuple([Int, Int])), f.1648: Fun([Int, Int], Int), acc.1649: Int) {
// [KnfOpt]   let _1650: Unit = Unit
// [KnfOpt]   let _1651: Tuple([Int, Int]) = Apply(stream.1647, [_1650, ])
// [KnfOpt]   let (ok.1652: Var({val: Some(Int)}), val.1653: Var({val: Some(Int)})) = _1651
// [KnfOpt]   let _1654: Int = Int(0)
// [KnfOpt]   if (ok.1652 == _1654) then {
// [KnfOpt]     let sum.104: Int = Var(acc.1649)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _1655: Int = Apply(f.1648, [acc.1649, val.1653, ])
// [KnfOpt]     Jump(fold.1646, [stream.1647, f.1648, _1655, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.1646, [under1200.103, add.1642, _1645, ])
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.1658: Int = (x.1659: Int, y.1660: Int) {
// [KnfOpt]   Add(x.1659, y.1660)
// [KnfOpt] }
// [KnfOpt] let _1661: Int = Int(0)
// [KnfOpt] let join fold.1662: Int = (stream.1663: Fun([Unit], Tuple([Int, Int])), f.1664: Fun([Int, Int], Int), acc.1665: Int) {
// [KnfOpt]   let _1666: Unit = Unit
// [KnfOpt]   let _1667: Tuple([Int, Int]) = Apply(stream.1663, [_1666, ])
// [KnfOpt]   let (ok.1668: Var({val: Some(Int)}), val.1669: Var({val: Some(Int)})) = _1667
// [KnfOpt]   let _1670: Int = Int(0)
// [KnfOpt]   if (ok.1668 == _1670) then {
// [KnfOpt]     let sum.104: Int = Var(acc.1665)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _1671: Int = Apply(f.1664, [acc.1665, val.1669, ])
// [KnfOpt]     Jump(fold.1662, [stream.1663, f.1664, _1671, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.1662, [under1200.103, add.1658, _1661, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(concat) let catt.94: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let _95: Int = Int(1)
// [KnfOpt] let rec aux.920: Int = (y.921: Int) {
// [KnfOpt]   Add(_95, y.921)
// [KnfOpt] }
// [KnfOpt] let _96: Fun([Int], Int) = Var(aux.920)
// [KnfOpt] let rec aux.1306: Tuple([Int, Int]) = (u.1307: Var({val: Some(Unit)})) {
// [KnfOpt]   let _1308: Unit = Unit
// [KnfOpt]   let _1309: Tuple([Int, Int]) = Apply(catt.94, [_1308, ])
// [KnfOpt]   let (ok.1310: Var({val: Some(Int)}), val.1311: Var({val: Some(Int)})) = _1309
// [KnfOpt]   let _1312: Int = Int(0)
// [KnfOpt]   if (ok.1310 == _1312) then {
// [KnfOpt]     let _1313: Int = Int(0)
// [KnfOpt]     let _1314: Int = Int(0)
// [KnfOpt]     Tuple([_1313, _1314, ])
// [KnfOpt]   } else {
// [KnfOpt]     let _1315: Int = Int(1)
// [KnfOpt]     let _1316: Int = Apply(_96, [val.1311, ])
// [KnfOpt]     Tuple([_1315, _1316, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] let addone.97: Fun([Unit], Tuple([Int, Int])) = Var(aux.1306)
// [KnfOpt] let _98: Int = Int(50)
// [KnfOpt] let rec aux.1508: Int = (y.1509: Int) {
// [KnfOpt]   if (_98 <= y.1509) then {
// [KnfOpt]     Int(0)
// [KnfOpt]   } else {
// [KnfOpt]     Int(1)
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] let _99: Fun([Int], Int) = Var(aux.1508)
// [KnfOpt] let rec aux.1598: Tuple([Int, Int]) = (u.1599: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.1600: Tuple([Int, Int]) = (u.1601: Var({val: Some(Unit)})) {
// [KnfOpt]     let _1602: Unit = Unit
// [KnfOpt]     let _1603: Tuple([Int, Int]) = Apply(addone.97, [_1602, ])
// [KnfOpt]     let (ok.1604: Var({val: Some(Int)}), val.1605: Var({val: Some(Int)})) = _1603
// [KnfOpt]     let _1606: Int = Int(0)
// [KnfOpt]     if (ok.1604 == _1606) then {
// [KnfOpt]       let _1607: Int = Int(0)
// [KnfOpt]       let _1608: Int = Int(0)
// [KnfOpt]       Tuple([_1607, _1608, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.1609: Int = Apply(_99, [val.1605, ])
// [KnfOpt]       let _1610: Int = Int(0)
// [KnfOpt]       if (r.1609 == _1610) then {
// [KnfOpt]         let _1611: Int = Int(1)
// [KnfOpt]         Tuple([_1611, val.1605, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _1612: Unit = Unit
// [KnfOpt]         Jump(aux.1600, [_1612, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.1600, [u.1599, ])
// [KnfOpt] }
// [KnfOpt] let over50.100: Fun([Unit], Tuple([Int, Int])) = Var(aux.1598)
// [KnfOpt] let _101: Int = Int(1200)
// [KnfOpt] let rec aux.1656: Int = (y.1657: Int) {
// [KnfOpt]   if (y.1657 <= _101) then {
// [KnfOpt]     Int(0)
// [KnfOpt]   } else {
// [KnfOpt]     Int(1)
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] let _102: Fun([Int], Int) = Var(aux.1656)
// [KnfOpt] let rec aux.1672: Tuple([Int, Int]) = (u.1673: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.1674: Tuple([Int, Int]) = (u.1675: Var({val: Some(Unit)})) {
// [KnfOpt]     let _1676: Unit = Unit
// [KnfOpt]     let _1677: Tuple([Int, Int]) = Apply(over50.100, [_1676, ])
// [KnfOpt]     let (ok.1678: Var({val: Some(Int)}), val.1679: Var({val: Some(Int)})) = _1677
// [KnfOpt]     let _1680: Int = Int(0)
// [KnfOpt]     if (ok.1678 == _1680) then {
// [KnfOpt]       let _1681: Int = Int(0)
// [KnfOpt]       let _1682: Int = Int(0)
// [KnfOpt]       Tuple([_1681, _1682, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.1683: Int = Apply(_102, [val.1679, ])
// [KnfOpt]       let _1684: Int = Int(0)
// [KnfOpt]       if (r.1683 == _1684) then {
// [KnfOpt]         let _1685: Int = Int(1)
// [KnfOpt]         Tuple([_1685, val.1679, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _1686: Unit = Unit
// [KnfOpt]         Jump(aux.1674, [_1686, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.1674, [u.1673, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.1672)
// [KnfOpt] let rec add.1687: Int = (x.1688: Int, y.1689: Int) {
// [KnfOpt]   Add(x.1688, y.1689)
// [KnfOpt] }
// [KnfOpt] let _1690: Int = Int(0)
// [KnfOpt] let join fold.1691: Int = (stream.1692: Fun([Unit], Tuple([Int, Int])), f.1693: Fun([Int, Int], Int), acc.1694: Int) {
// [KnfOpt]   let _1695: Unit = Unit
// [KnfOpt]   let _1696: Tuple([Int, Int]) = Apply(stream.1692, [_1695, ])
// [KnfOpt]   let (ok.1697: Var({val: Some(Int)}), val.1698: Var({val: Some(Int)})) = _1696
// [KnfOpt]   let _1699: Int = Int(0)
// [KnfOpt]   if (ok.1697 == _1699) then {
// [KnfOpt]     let sum.104: Int = Var(acc.1694)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _1700: Int = Apply(f.1693, [acc.1694, val.1698, ])
// [KnfOpt]     Jump(fold.1691, [stream.1692, f.1693, _1700, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.1691, [under1200.103, add.1687, _1690, ])
// [KnfOpt] Inline threshold 3
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 0
// [KnfOpt] Inline decision addx.59 accepted
// [KnfOpt] Inline threshold 20
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 0
// [KnfOpt] Inline decision map.1 accepted
// [KnfOpt] Inline threshold 5
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 0
// [KnfOpt] Inline decision gt.79 accepted
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 5
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 0
// [KnfOpt] Inline decision le.83 accepted
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.1710: Int = (x.1711: Int, y.1712: Int) {
// [KnfOpt]   Add(x.1711, y.1712)
// [KnfOpt] }
// [KnfOpt] let _1713: Int = Int(0)
// [KnfOpt] let join fold.1714: Int = (stream.1715: Fun([Unit], Tuple([Int, Int])), f.1716: Fun([Int, Int], Int), acc.1717: Int) {
// [KnfOpt]   let _1718: Unit = Unit
// [KnfOpt]   let _1719: Tuple([Int, Int]) = Apply(stream.1715, [_1718, ])
// [KnfOpt]   let (ok.1720: Var({val: Some(Int)}), val.1721: Var({val: Some(Int)})) = _1719
// [KnfOpt]   let _1722: Int = Int(0)
// [KnfOpt]   if (ok.1720 == _1722) then {
// [KnfOpt]     let sum.104: Int = Var(acc.1717)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _1723: Int = Apply(f.1716, [acc.1717, val.1721, ])
// [KnfOpt]     Jump(fold.1714, [stream.1715, f.1716, _1723, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.1714, [under1200.103, add.1710, _1713, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(le) let _102: Fun([Int], Int) = Unit
// [KnfOpt] let rec aux.1724: Tuple([Int, Int]) = (u.1725: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.1726: Tuple([Int, Int]) = (u.1727: Var({val: Some(Unit)})) {
// [KnfOpt]     let _1728: Unit = Unit
// [KnfOpt]     let _1729: Tuple([Int, Int]) = Apply(over50.100, [_1728, ])
// [KnfOpt]     let (ok.1730: Var({val: Some(Int)}), val.1731: Var({val: Some(Int)})) = _1729
// [KnfOpt]     let _1732: Int = Int(0)
// [KnfOpt]     if (ok.1730 == _1732) then {
// [KnfOpt]       let _1733: Int = Int(0)
// [KnfOpt]       let _1734: Int = Int(0)
// [KnfOpt]       Tuple([_1733, _1734, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.1735: Int = Apply(_102, [val.1731, ])
// [KnfOpt]       let _1736: Int = Int(0)
// [KnfOpt]       if (r.1735 == _1736) then {
// [KnfOpt]         let _1737: Int = Int(1)
// [KnfOpt]         Tuple([_1737, val.1731, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _1738: Unit = Unit
// [KnfOpt]         Jump(aux.1726, [_1738, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.1726, [u.1725, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.1724)
// [KnfOpt] let rec add.1739: Int = (x.1740: Int, y.1741: Int) {
// [KnfOpt]   Add(x.1740, y.1741)
// [KnfOpt] }
// [KnfOpt] let _1742: Int = Int(0)
// [KnfOpt] let join fold.1743: Int = (stream.1744: Fun([Unit], Tuple([Int, Int])), f.1745: Fun([Int, Int], Int), acc.1746: Int) {
// [KnfOpt]   let _1747: Unit = Unit
// [KnfOpt]   let _1748: Tuple([Int, Int]) = Apply(stream.1744, [_1747, ])
// [KnfOpt]   let (ok.1749: Var({val: Some(Int)}), val.1750: Var({val: Some(Int)})) = _1748
// [KnfOpt]   let _1751: Int = Int(0)
// [KnfOpt]   if (ok.1749 == _1751) then {
// [KnfOpt]     let sum.104: Int = Var(acc.1746)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _1752: Int = Apply(f.1745, [acc.1746, val.1750, ])
// [KnfOpt]     Jump(fold.1743, [stream.1744, f.1745, _1752, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.1743, [under1200.103, add.1739, _1742, ])
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.1755: Int = (x.1756: Int, y.1757: Int) {
// [KnfOpt]   Add(x.1756, y.1757)
// [KnfOpt] }
// [KnfOpt] let _1758: Int = Int(0)
// [KnfOpt] let join fold.1759: Int = (stream.1760: Fun([Unit], Tuple([Int, Int])), f.1761: Fun([Int, Int], Int), acc.1762: Int) {
// [KnfOpt]   let _1763: Unit = Unit
// [KnfOpt]   let _1764: Tuple([Int, Int]) = Apply(stream.1760, [_1763, ])
// [KnfOpt]   let (ok.1765: Var({val: Some(Int)}), val.1766: Var({val: Some(Int)})) = _1764
// [KnfOpt]   let _1767: Int = Int(0)
// [KnfOpt]   if (ok.1765 == _1767) then {
// [KnfOpt]     let sum.104: Int = Var(acc.1762)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _1768: Int = Apply(f.1761, [acc.1762, val.1766, ])
// [KnfOpt]     Jump(fold.1759, [stream.1760, f.1761, _1768, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.1759, [under1200.103, add.1755, _1758, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let over50.100: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let _101: Int = Int(1200)
// [KnfOpt] let rec aux.1753: Int = (y.1754: Int) {
// [KnfOpt]   if (y.1754 <= _101) then {
// [KnfOpt]     Int(0)
// [KnfOpt]   } else {
// [KnfOpt]     Int(1)
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] let _102: Fun([Int], Int) = Var(aux.1753)
// [KnfOpt] let rec aux.1769: Tuple([Int, Int]) = (u.1770: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.1771: Tuple([Int, Int]) = (u.1772: Var({val: Some(Unit)})) {
// [KnfOpt]     let _1773: Unit = Unit
// [KnfOpt]     let _1774: Tuple([Int, Int]) = Apply(over50.100, [_1773, ])
// [KnfOpt]     let (ok.1775: Var({val: Some(Int)}), val.1776: Var({val: Some(Int)})) = _1774
// [KnfOpt]     let _1777: Int = Int(0)
// [KnfOpt]     if (ok.1775 == _1777) then {
// [KnfOpt]       let _1778: Int = Int(0)
// [KnfOpt]       let _1779: Int = Int(0)
// [KnfOpt]       Tuple([_1778, _1779, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.1780: Int = Apply(_102, [val.1776, ])
// [KnfOpt]       let _1781: Int = Int(0)
// [KnfOpt]       if (r.1780 == _1781) then {
// [KnfOpt]         let _1782: Int = Int(1)
// [KnfOpt]         Tuple([_1782, val.1776, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _1783: Unit = Unit
// [KnfOpt]         Jump(aux.1771, [_1783, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.1771, [u.1770, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.1769)
// [KnfOpt] let rec add.1784: Int = (x.1785: Int, y.1786: Int) {
// [KnfOpt]   Add(x.1785, y.1786)
// [KnfOpt] }
// [KnfOpt] let _1787: Int = Int(0)
// [KnfOpt] let join fold.1788: Int = (stream.1789: Fun([Unit], Tuple([Int, Int])), f.1790: Fun([Int, Int], Int), acc.1791: Int) {
// [KnfOpt]   let _1792: Unit = Unit
// [KnfOpt]   let _1793: Tuple([Int, Int]) = Apply(stream.1789, [_1792, ])
// [KnfOpt]   let (ok.1794: Var({val: Some(Int)}), val.1795: Var({val: Some(Int)})) = _1793
// [KnfOpt]   let _1796: Int = Int(0)
// [KnfOpt]   if (ok.1794 == _1796) then {
// [KnfOpt]     let sum.104: Int = Var(acc.1791)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _1797: Int = Apply(f.1790, [acc.1791, val.1795, ])
// [KnfOpt]     Jump(fold.1788, [stream.1789, f.1790, _1797, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.1788, [under1200.103, add.1784, _1787, ])
// [KnfOpt] Inline threshold 5
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 0
// [KnfOpt] Inline decision le.83 accepted
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.1813: Int = (x.1814: Int, y.1815: Int) {
// [KnfOpt]   Add(x.1814, y.1815)
// [KnfOpt] }
// [KnfOpt] let _1816: Int = Int(0)
// [KnfOpt] let join fold.1817: Int = (stream.1818: Fun([Unit], Tuple([Int, Int])), f.1819: Fun([Int, Int], Int), acc.1820: Int) {
// [KnfOpt]   let _1821: Unit = Unit
// [KnfOpt]   let _1822: Tuple([Int, Int]) = Apply(stream.1818, [_1821, ])
// [KnfOpt]   let (ok.1823: Var({val: Some(Int)}), val.1824: Var({val: Some(Int)})) = _1822
// [KnfOpt]   let _1825: Int = Int(0)
// [KnfOpt]   if (ok.1823 == _1825) then {
// [KnfOpt]     let sum.104: Int = Var(acc.1820)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _1826: Int = Apply(f.1819, [acc.1820, val.1824, ])
// [KnfOpt]     Jump(fold.1817, [stream.1818, f.1819, _1826, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.1817, [under1200.103, add.1813, _1816, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(le) let _102: Fun([Int], Int) = Unit
// [KnfOpt] let rec aux.1827: Tuple([Int, Int]) = (u.1828: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.1829: Tuple([Int, Int]) = (u.1830: Var({val: Some(Unit)})) {
// [KnfOpt]     let _1831: Unit = Unit
// [KnfOpt]     let _1832: Tuple([Int, Int]) = Apply(over50.100, [_1831, ])
// [KnfOpt]     let (ok.1833: Var({val: Some(Int)}), val.1834: Var({val: Some(Int)})) = _1832
// [KnfOpt]     let _1835: Int = Int(0)
// [KnfOpt]     if (ok.1833 == _1835) then {
// [KnfOpt]       let _1836: Int = Int(0)
// [KnfOpt]       let _1837: Int = Int(0)
// [KnfOpt]       Tuple([_1836, _1837, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.1838: Int = Apply(_102, [val.1834, ])
// [KnfOpt]       let _1839: Int = Int(0)
// [KnfOpt]       if (r.1838 == _1839) then {
// [KnfOpt]         let _1840: Int = Int(1)
// [KnfOpt]         Tuple([_1840, val.1834, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _1841: Unit = Unit
// [KnfOpt]         Jump(aux.1829, [_1841, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.1829, [u.1828, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.1827)
// [KnfOpt] let rec add.1842: Int = (x.1843: Int, y.1844: Int) {
// [KnfOpt]   Add(x.1843, y.1844)
// [KnfOpt] }
// [KnfOpt] let _1845: Int = Int(0)
// [KnfOpt] let join fold.1846: Int = (stream.1847: Fun([Unit], Tuple([Int, Int])), f.1848: Fun([Int, Int], Int), acc.1849: Int) {
// [KnfOpt]   let _1850: Unit = Unit
// [KnfOpt]   let _1851: Tuple([Int, Int]) = Apply(stream.1847, [_1850, ])
// [KnfOpt]   let (ok.1852: Var({val: Some(Int)}), val.1853: Var({val: Some(Int)})) = _1851
// [KnfOpt]   let _1854: Int = Int(0)
// [KnfOpt]   if (ok.1852 == _1854) then {
// [KnfOpt]     let sum.104: Int = Var(acc.1849)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _1855: Int = Apply(f.1848, [acc.1849, val.1853, ])
// [KnfOpt]     Jump(fold.1846, [stream.1847, f.1848, _1855, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.1846, [under1200.103, add.1842, _1845, ])
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.1858: Int = (x.1859: Int, y.1860: Int) {
// [KnfOpt]   Add(x.1859, y.1860)
// [KnfOpt] }
// [KnfOpt] let _1861: Int = Int(0)
// [KnfOpt] let join fold.1862: Int = (stream.1863: Fun([Unit], Tuple([Int, Int])), f.1864: Fun([Int, Int], Int), acc.1865: Int) {
// [KnfOpt]   let _1866: Unit = Unit
// [KnfOpt]   let _1867: Tuple([Int, Int]) = Apply(stream.1863, [_1866, ])
// [KnfOpt]   let (ok.1868: Var({val: Some(Int)}), val.1869: Var({val: Some(Int)})) = _1867
// [KnfOpt]   let _1870: Int = Int(0)
// [KnfOpt]   if (ok.1868 == _1870) then {
// [KnfOpt]     let sum.104: Int = Var(acc.1865)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _1871: Int = Apply(f.1864, [acc.1865, val.1869, ])
// [KnfOpt]     Jump(fold.1862, [stream.1863, f.1864, _1871, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.1862, [under1200.103, add.1858, _1861, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(gt) let _99: Fun([Int], Int) = Unit
// [KnfOpt] let rec aux.1798: Tuple([Int, Int]) = (u.1799: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.1800: Tuple([Int, Int]) = (u.1801: Var({val: Some(Unit)})) {
// [KnfOpt]     let _1802: Unit = Unit
// [KnfOpt]     let _1803: Tuple([Int, Int]) = Apply(addone.97, [_1802, ])
// [KnfOpt]     let (ok.1804: Var({val: Some(Int)}), val.1805: Var({val: Some(Int)})) = _1803
// [KnfOpt]     let _1806: Int = Int(0)
// [KnfOpt]     if (ok.1804 == _1806) then {
// [KnfOpt]       let _1807: Int = Int(0)
// [KnfOpt]       let _1808: Int = Int(0)
// [KnfOpt]       Tuple([_1807, _1808, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.1809: Int = Apply(_99, [val.1805, ])
// [KnfOpt]       let _1810: Int = Int(0)
// [KnfOpt]       if (r.1809 == _1810) then {
// [KnfOpt]         let _1811: Int = Int(1)
// [KnfOpt]         Tuple([_1811, val.1805, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _1812: Unit = Unit
// [KnfOpt]         Jump(aux.1800, [_1812, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.1800, [u.1799, ])
// [KnfOpt] }
// [KnfOpt] let over50.100: Fun([Unit], Tuple([Int, Int])) = Var(aux.1798)
// [KnfOpt] let _101: Int = Int(1200)
// [KnfOpt] let rec aux.1856: Int = (y.1857: Int) {
// [KnfOpt]   if (y.1857 <= _101) then {
// [KnfOpt]     Int(0)
// [KnfOpt]   } else {
// [KnfOpt]     Int(1)
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] let _102: Fun([Int], Int) = Var(aux.1856)
// [KnfOpt] let rec aux.1872: Tuple([Int, Int]) = (u.1873: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.1874: Tuple([Int, Int]) = (u.1875: Var({val: Some(Unit)})) {
// [KnfOpt]     let _1876: Unit = Unit
// [KnfOpt]     let _1877: Tuple([Int, Int]) = Apply(over50.100, [_1876, ])
// [KnfOpt]     let (ok.1878: Var({val: Some(Int)}), val.1879: Var({val: Some(Int)})) = _1877
// [KnfOpt]     let _1880: Int = Int(0)
// [KnfOpt]     if (ok.1878 == _1880) then {
// [KnfOpt]       let _1881: Int = Int(0)
// [KnfOpt]       let _1882: Int = Int(0)
// [KnfOpt]       Tuple([_1881, _1882, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.1883: Int = Apply(_102, [val.1879, ])
// [KnfOpt]       let _1884: Int = Int(0)
// [KnfOpt]       if (r.1883 == _1884) then {
// [KnfOpt]         let _1885: Int = Int(1)
// [KnfOpt]         Tuple([_1885, val.1879, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _1886: Unit = Unit
// [KnfOpt]         Jump(aux.1874, [_1886, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.1874, [u.1873, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.1872)
// [KnfOpt] let rec add.1887: Int = (x.1888: Int, y.1889: Int) {
// [KnfOpt]   Add(x.1888, y.1889)
// [KnfOpt] }
// [KnfOpt] let _1890: Int = Int(0)
// [KnfOpt] let join fold.1891: Int = (stream.1892: Fun([Unit], Tuple([Int, Int])), f.1893: Fun([Int, Int], Int), acc.1894: Int) {
// [KnfOpt]   let _1895: Unit = Unit
// [KnfOpt]   let _1896: Tuple([Int, Int]) = Apply(stream.1892, [_1895, ])
// [KnfOpt]   let (ok.1897: Var({val: Some(Int)}), val.1898: Var({val: Some(Int)})) = _1896
// [KnfOpt]   let _1899: Int = Int(0)
// [KnfOpt]   if (ok.1897 == _1899) then {
// [KnfOpt]     let sum.104: Int = Var(acc.1894)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _1900: Int = Apply(f.1893, [acc.1894, val.1898, ])
// [KnfOpt]     Jump(fold.1891, [stream.1892, f.1893, _1900, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.1891, [under1200.103, add.1887, _1890, ])
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 5
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 0
// [KnfOpt] Inline decision le.83 accepted
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.1903: Int = (x.1904: Int, y.1905: Int) {
// [KnfOpt]   Add(x.1904, y.1905)
// [KnfOpt] }
// [KnfOpt] let _1906: Int = Int(0)
// [KnfOpt] let join fold.1907: Int = (stream.1908: Fun([Unit], Tuple([Int, Int])), f.1909: Fun([Int, Int], Int), acc.1910: Int) {
// [KnfOpt]   let _1911: Unit = Unit
// [KnfOpt]   let _1912: Tuple([Int, Int]) = Apply(stream.1908, [_1911, ])
// [KnfOpt]   let (ok.1913: Var({val: Some(Int)}), val.1914: Var({val: Some(Int)})) = _1912
// [KnfOpt]   let _1915: Int = Int(0)
// [KnfOpt]   if (ok.1913 == _1915) then {
// [KnfOpt]     let sum.104: Int = Var(acc.1910)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _1916: Int = Apply(f.1909, [acc.1910, val.1914, ])
// [KnfOpt]     Jump(fold.1907, [stream.1908, f.1909, _1916, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.1907, [under1200.103, add.1903, _1906, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(le) let _102: Fun([Int], Int) = Unit
// [KnfOpt] let rec aux.1917: Tuple([Int, Int]) = (u.1918: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.1919: Tuple([Int, Int]) = (u.1920: Var({val: Some(Unit)})) {
// [KnfOpt]     let _1921: Unit = Unit
// [KnfOpt]     let _1922: Tuple([Int, Int]) = Apply(over50.100, [_1921, ])
// [KnfOpt]     let (ok.1923: Var({val: Some(Int)}), val.1924: Var({val: Some(Int)})) = _1922
// [KnfOpt]     let _1925: Int = Int(0)
// [KnfOpt]     if (ok.1923 == _1925) then {
// [KnfOpt]       let _1926: Int = Int(0)
// [KnfOpt]       let _1927: Int = Int(0)
// [KnfOpt]       Tuple([_1926, _1927, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.1928: Int = Apply(_102, [val.1924, ])
// [KnfOpt]       let _1929: Int = Int(0)
// [KnfOpt]       if (r.1928 == _1929) then {
// [KnfOpt]         let _1930: Int = Int(1)
// [KnfOpt]         Tuple([_1930, val.1924, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _1931: Unit = Unit
// [KnfOpt]         Jump(aux.1919, [_1931, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.1919, [u.1918, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.1917)
// [KnfOpt] let rec add.1932: Int = (x.1933: Int, y.1934: Int) {
// [KnfOpt]   Add(x.1933, y.1934)
// [KnfOpt] }
// [KnfOpt] let _1935: Int = Int(0)
// [KnfOpt] let join fold.1936: Int = (stream.1937: Fun([Unit], Tuple([Int, Int])), f.1938: Fun([Int, Int], Int), acc.1939: Int) {
// [KnfOpt]   let _1940: Unit = Unit
// [KnfOpt]   let _1941: Tuple([Int, Int]) = Apply(stream.1937, [_1940, ])
// [KnfOpt]   let (ok.1942: Var({val: Some(Int)}), val.1943: Var({val: Some(Int)})) = _1941
// [KnfOpt]   let _1944: Int = Int(0)
// [KnfOpt]   if (ok.1942 == _1944) then {
// [KnfOpt]     let sum.104: Int = Var(acc.1939)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _1945: Int = Apply(f.1938, [acc.1939, val.1943, ])
// [KnfOpt]     Jump(fold.1936, [stream.1937, f.1938, _1945, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.1936, [under1200.103, add.1932, _1935, ])
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.1948: Int = (x.1949: Int, y.1950: Int) {
// [KnfOpt]   Add(x.1949, y.1950)
// [KnfOpt] }
// [KnfOpt] let _1951: Int = Int(0)
// [KnfOpt] let join fold.1952: Int = (stream.1953: Fun([Unit], Tuple([Int, Int])), f.1954: Fun([Int, Int], Int), acc.1955: Int) {
// [KnfOpt]   let _1956: Unit = Unit
// [KnfOpt]   let _1957: Tuple([Int, Int]) = Apply(stream.1953, [_1956, ])
// [KnfOpt]   let (ok.1958: Var({val: Some(Int)}), val.1959: Var({val: Some(Int)})) = _1957
// [KnfOpt]   let _1960: Int = Int(0)
// [KnfOpt]   if (ok.1958 == _1960) then {
// [KnfOpt]     let sum.104: Int = Var(acc.1955)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _1961: Int = Apply(f.1954, [acc.1955, val.1959, ])
// [KnfOpt]     Jump(fold.1952, [stream.1953, f.1954, _1961, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.1952, [under1200.103, add.1948, _1951, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let over50.100: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let _101: Int = Int(1200)
// [KnfOpt] let rec aux.1946: Int = (y.1947: Int) {
// [KnfOpt]   if (y.1947 <= _101) then {
// [KnfOpt]     Int(0)
// [KnfOpt]   } else {
// [KnfOpt]     Int(1)
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] let _102: Fun([Int], Int) = Var(aux.1946)
// [KnfOpt] let rec aux.1962: Tuple([Int, Int]) = (u.1963: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.1964: Tuple([Int, Int]) = (u.1965: Var({val: Some(Unit)})) {
// [KnfOpt]     let _1966: Unit = Unit
// [KnfOpt]     let _1967: Tuple([Int, Int]) = Apply(over50.100, [_1966, ])
// [KnfOpt]     let (ok.1968: Var({val: Some(Int)}), val.1969: Var({val: Some(Int)})) = _1967
// [KnfOpt]     let _1970: Int = Int(0)
// [KnfOpt]     if (ok.1968 == _1970) then {
// [KnfOpt]       let _1971: Int = Int(0)
// [KnfOpt]       let _1972: Int = Int(0)
// [KnfOpt]       Tuple([_1971, _1972, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.1973: Int = Apply(_102, [val.1969, ])
// [KnfOpt]       let _1974: Int = Int(0)
// [KnfOpt]       if (r.1973 == _1974) then {
// [KnfOpt]         let _1975: Int = Int(1)
// [KnfOpt]         Tuple([_1975, val.1969, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _1976: Unit = Unit
// [KnfOpt]         Jump(aux.1964, [_1976, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.1964, [u.1963, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.1962)
// [KnfOpt] let rec add.1977: Int = (x.1978: Int, y.1979: Int) {
// [KnfOpt]   Add(x.1978, y.1979)
// [KnfOpt] }
// [KnfOpt] let _1980: Int = Int(0)
// [KnfOpt] let join fold.1981: Int = (stream.1982: Fun([Unit], Tuple([Int, Int])), f.1983: Fun([Int, Int], Int), acc.1984: Int) {
// [KnfOpt]   let _1985: Unit = Unit
// [KnfOpt]   let _1986: Tuple([Int, Int]) = Apply(stream.1982, [_1985, ])
// [KnfOpt]   let (ok.1987: Var({val: Some(Int)}), val.1988: Var({val: Some(Int)})) = _1986
// [KnfOpt]   let _1989: Int = Int(0)
// [KnfOpt]   if (ok.1987 == _1989) then {
// [KnfOpt]     let sum.104: Int = Var(acc.1984)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _1990: Int = Apply(f.1983, [acc.1984, val.1988, ])
// [KnfOpt]     Jump(fold.1981, [stream.1982, f.1983, _1990, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.1981, [under1200.103, add.1977, _1980, ])
// [KnfOpt] Inline threshold 5
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 0
// [KnfOpt] Inline decision le.83 accepted
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.2006: Int = (x.2007: Int, y.2008: Int) {
// [KnfOpt]   Add(x.2007, y.2008)
// [KnfOpt] }
// [KnfOpt] let _2009: Int = Int(0)
// [KnfOpt] let join fold.2010: Int = (stream.2011: Fun([Unit], Tuple([Int, Int])), f.2012: Fun([Int, Int], Int), acc.2013: Int) {
// [KnfOpt]   let _2014: Unit = Unit
// [KnfOpt]   let _2015: Tuple([Int, Int]) = Apply(stream.2011, [_2014, ])
// [KnfOpt]   let (ok.2016: Var({val: Some(Int)}), val.2017: Var({val: Some(Int)})) = _2015
// [KnfOpt]   let _2018: Int = Int(0)
// [KnfOpt]   if (ok.2016 == _2018) then {
// [KnfOpt]     let sum.104: Int = Var(acc.2013)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _2019: Int = Apply(f.2012, [acc.2013, val.2017, ])
// [KnfOpt]     Jump(fold.2010, [stream.2011, f.2012, _2019, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.2010, [under1200.103, add.2006, _2009, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(le) let _102: Fun([Int], Int) = Unit
// [KnfOpt] let rec aux.2020: Tuple([Int, Int]) = (u.2021: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.2022: Tuple([Int, Int]) = (u.2023: Var({val: Some(Unit)})) {
// [KnfOpt]     let _2024: Unit = Unit
// [KnfOpt]     let _2025: Tuple([Int, Int]) = Apply(over50.100, [_2024, ])
// [KnfOpt]     let (ok.2026: Var({val: Some(Int)}), val.2027: Var({val: Some(Int)})) = _2025
// [KnfOpt]     let _2028: Int = Int(0)
// [KnfOpt]     if (ok.2026 == _2028) then {
// [KnfOpt]       let _2029: Int = Int(0)
// [KnfOpt]       let _2030: Int = Int(0)
// [KnfOpt]       Tuple([_2029, _2030, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.2031: Int = Apply(_102, [val.2027, ])
// [KnfOpt]       let _2032: Int = Int(0)
// [KnfOpt]       if (r.2031 == _2032) then {
// [KnfOpt]         let _2033: Int = Int(1)
// [KnfOpt]         Tuple([_2033, val.2027, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _2034: Unit = Unit
// [KnfOpt]         Jump(aux.2022, [_2034, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.2022, [u.2021, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.2020)
// [KnfOpt] let rec add.2035: Int = (x.2036: Int, y.2037: Int) {
// [KnfOpt]   Add(x.2036, y.2037)
// [KnfOpt] }
// [KnfOpt] let _2038: Int = Int(0)
// [KnfOpt] let join fold.2039: Int = (stream.2040: Fun([Unit], Tuple([Int, Int])), f.2041: Fun([Int, Int], Int), acc.2042: Int) {
// [KnfOpt]   let _2043: Unit = Unit
// [KnfOpt]   let _2044: Tuple([Int, Int]) = Apply(stream.2040, [_2043, ])
// [KnfOpt]   let (ok.2045: Var({val: Some(Int)}), val.2046: Var({val: Some(Int)})) = _2044
// [KnfOpt]   let _2047: Int = Int(0)
// [KnfOpt]   if (ok.2045 == _2047) then {
// [KnfOpt]     let sum.104: Int = Var(acc.2042)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _2048: Int = Apply(f.2041, [acc.2042, val.2046, ])
// [KnfOpt]     Jump(fold.2039, [stream.2040, f.2041, _2048, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.2039, [under1200.103, add.2035, _2038, ])
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.2051: Int = (x.2052: Int, y.2053: Int) {
// [KnfOpt]   Add(x.2052, y.2053)
// [KnfOpt] }
// [KnfOpt] let _2054: Int = Int(0)
// [KnfOpt] let join fold.2055: Int = (stream.2056: Fun([Unit], Tuple([Int, Int])), f.2057: Fun([Int, Int], Int), acc.2058: Int) {
// [KnfOpt]   let _2059: Unit = Unit
// [KnfOpt]   let _2060: Tuple([Int, Int]) = Apply(stream.2056, [_2059, ])
// [KnfOpt]   let (ok.2061: Var({val: Some(Int)}), val.2062: Var({val: Some(Int)})) = _2060
// [KnfOpt]   let _2063: Int = Int(0)
// [KnfOpt]   if (ok.2061 == _2063) then {
// [KnfOpt]     let sum.104: Int = Var(acc.2058)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _2064: Int = Apply(f.2057, [acc.2058, val.2062, ])
// [KnfOpt]     Jump(fold.2055, [stream.2056, f.2057, _2064, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.2055, [under1200.103, add.2051, _2054, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(map) let addone.97: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let _98: Int = Int(50)
// [KnfOpt] let rec aux.1901: Int = (y.1902: Int) {
// [KnfOpt]   if (_98 <= y.1902) then {
// [KnfOpt]     Int(0)
// [KnfOpt]   } else {
// [KnfOpt]     Int(1)
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] let _99: Fun([Int], Int) = Var(aux.1901)
// [KnfOpt] let rec aux.1991: Tuple([Int, Int]) = (u.1992: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.1993: Tuple([Int, Int]) = (u.1994: Var({val: Some(Unit)})) {
// [KnfOpt]     let _1995: Unit = Unit
// [KnfOpt]     let _1996: Tuple([Int, Int]) = Apply(addone.97, [_1995, ])
// [KnfOpt]     let (ok.1997: Var({val: Some(Int)}), val.1998: Var({val: Some(Int)})) = _1996
// [KnfOpt]     let _1999: Int = Int(0)
// [KnfOpt]     if (ok.1997 == _1999) then {
// [KnfOpt]       let _2000: Int = Int(0)
// [KnfOpt]       let _2001: Int = Int(0)
// [KnfOpt]       Tuple([_2000, _2001, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.2002: Int = Apply(_99, [val.1998, ])
// [KnfOpt]       let _2003: Int = Int(0)
// [KnfOpt]       if (r.2002 == _2003) then {
// [KnfOpt]         let _2004: Int = Int(1)
// [KnfOpt]         Tuple([_2004, val.1998, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _2005: Unit = Unit
// [KnfOpt]         Jump(aux.1993, [_2005, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.1993, [u.1992, ])
// [KnfOpt] }
// [KnfOpt] let over50.100: Fun([Unit], Tuple([Int, Int])) = Var(aux.1991)
// [KnfOpt] let _101: Int = Int(1200)
// [KnfOpt] let rec aux.2049: Int = (y.2050: Int) {
// [KnfOpt]   if (y.2050 <= _101) then {
// [KnfOpt]     Int(0)
// [KnfOpt]   } else {
// [KnfOpt]     Int(1)
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] let _102: Fun([Int], Int) = Var(aux.2049)
// [KnfOpt] let rec aux.2065: Tuple([Int, Int]) = (u.2066: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.2067: Tuple([Int, Int]) = (u.2068: Var({val: Some(Unit)})) {
// [KnfOpt]     let _2069: Unit = Unit
// [KnfOpt]     let _2070: Tuple([Int, Int]) = Apply(over50.100, [_2069, ])
// [KnfOpt]     let (ok.2071: Var({val: Some(Int)}), val.2072: Var({val: Some(Int)})) = _2070
// [KnfOpt]     let _2073: Int = Int(0)
// [KnfOpt]     if (ok.2071 == _2073) then {
// [KnfOpt]       let _2074: Int = Int(0)
// [KnfOpt]       let _2075: Int = Int(0)
// [KnfOpt]       Tuple([_2074, _2075, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.2076: Int = Apply(_102, [val.2072, ])
// [KnfOpt]       let _2077: Int = Int(0)
// [KnfOpt]       if (r.2076 == _2077) then {
// [KnfOpt]         let _2078: Int = Int(1)
// [KnfOpt]         Tuple([_2078, val.2072, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _2079: Unit = Unit
// [KnfOpt]         Jump(aux.2067, [_2079, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.2067, [u.2066, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.2065)
// [KnfOpt] let rec add.2080: Int = (x.2081: Int, y.2082: Int) {
// [KnfOpt]   Add(x.2081, y.2082)
// [KnfOpt] }
// [KnfOpt] let _2083: Int = Int(0)
// [KnfOpt] let join fold.2084: Int = (stream.2085: Fun([Unit], Tuple([Int, Int])), f.2086: Fun([Int, Int], Int), acc.2087: Int) {
// [KnfOpt]   let _2088: Unit = Unit
// [KnfOpt]   let _2089: Tuple([Int, Int]) = Apply(stream.2085, [_2088, ])
// [KnfOpt]   let (ok.2090: Var({val: Some(Int)}), val.2091: Var({val: Some(Int)})) = _2089
// [KnfOpt]   let _2092: Int = Int(0)
// [KnfOpt]   if (ok.2090 == _2092) then {
// [KnfOpt]     let sum.104: Int = Var(acc.2087)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _2093: Int = Apply(f.2086, [acc.2087, val.2091, ])
// [KnfOpt]     Jump(fold.2084, [stream.2085, f.2086, _2093, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.2084, [under1200.103, add.2080, _2083, ])
// [KnfOpt] Inline threshold 5
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 0
// [KnfOpt] Inline decision gt.79 accepted
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 5
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 0
// [KnfOpt] Inline decision le.83 accepted
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.2105: Int = (x.2106: Int, y.2107: Int) {
// [KnfOpt]   Add(x.2106, y.2107)
// [KnfOpt] }
// [KnfOpt] let _2108: Int = Int(0)
// [KnfOpt] let join fold.2109: Int = (stream.2110: Fun([Unit], Tuple([Int, Int])), f.2111: Fun([Int, Int], Int), acc.2112: Int) {
// [KnfOpt]   let _2113: Unit = Unit
// [KnfOpt]   let _2114: Tuple([Int, Int]) = Apply(stream.2110, [_2113, ])
// [KnfOpt]   let (ok.2115: Var({val: Some(Int)}), val.2116: Var({val: Some(Int)})) = _2114
// [KnfOpt]   let _2117: Int = Int(0)
// [KnfOpt]   if (ok.2115 == _2117) then {
// [KnfOpt]     let sum.104: Int = Var(acc.2112)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _2118: Int = Apply(f.2111, [acc.2112, val.2116, ])
// [KnfOpt]     Jump(fold.2109, [stream.2110, f.2111, _2118, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.2109, [under1200.103, add.2105, _2108, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(le) let _102: Fun([Int], Int) = Unit
// [KnfOpt] let rec aux.2119: Tuple([Int, Int]) = (u.2120: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.2121: Tuple([Int, Int]) = (u.2122: Var({val: Some(Unit)})) {
// [KnfOpt]     let _2123: Unit = Unit
// [KnfOpt]     let _2124: Tuple([Int, Int]) = Apply(over50.100, [_2123, ])
// [KnfOpt]     let (ok.2125: Var({val: Some(Int)}), val.2126: Var({val: Some(Int)})) = _2124
// [KnfOpt]     let _2127: Int = Int(0)
// [KnfOpt]     if (ok.2125 == _2127) then {
// [KnfOpt]       let _2128: Int = Int(0)
// [KnfOpt]       let _2129: Int = Int(0)
// [KnfOpt]       Tuple([_2128, _2129, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.2130: Int = Apply(_102, [val.2126, ])
// [KnfOpt]       let _2131: Int = Int(0)
// [KnfOpt]       if (r.2130 == _2131) then {
// [KnfOpt]         let _2132: Int = Int(1)
// [KnfOpt]         Tuple([_2132, val.2126, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _2133: Unit = Unit
// [KnfOpt]         Jump(aux.2121, [_2133, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.2121, [u.2120, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.2119)
// [KnfOpt] let rec add.2134: Int = (x.2135: Int, y.2136: Int) {
// [KnfOpt]   Add(x.2135, y.2136)
// [KnfOpt] }
// [KnfOpt] let _2137: Int = Int(0)
// [KnfOpt] let join fold.2138: Int = (stream.2139: Fun([Unit], Tuple([Int, Int])), f.2140: Fun([Int, Int], Int), acc.2141: Int) {
// [KnfOpt]   let _2142: Unit = Unit
// [KnfOpt]   let _2143: Tuple([Int, Int]) = Apply(stream.2139, [_2142, ])
// [KnfOpt]   let (ok.2144: Var({val: Some(Int)}), val.2145: Var({val: Some(Int)})) = _2143
// [KnfOpt]   let _2146: Int = Int(0)
// [KnfOpt]   if (ok.2144 == _2146) then {
// [KnfOpt]     let sum.104: Int = Var(acc.2141)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _2147: Int = Apply(f.2140, [acc.2141, val.2145, ])
// [KnfOpt]     Jump(fold.2138, [stream.2139, f.2140, _2147, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.2138, [under1200.103, add.2134, _2137, ])
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.2150: Int = (x.2151: Int, y.2152: Int) {
// [KnfOpt]   Add(x.2151, y.2152)
// [KnfOpt] }
// [KnfOpt] let _2153: Int = Int(0)
// [KnfOpt] let join fold.2154: Int = (stream.2155: Fun([Unit], Tuple([Int, Int])), f.2156: Fun([Int, Int], Int), acc.2157: Int) {
// [KnfOpt]   let _2158: Unit = Unit
// [KnfOpt]   let _2159: Tuple([Int, Int]) = Apply(stream.2155, [_2158, ])
// [KnfOpt]   let (ok.2160: Var({val: Some(Int)}), val.2161: Var({val: Some(Int)})) = _2159
// [KnfOpt]   let _2162: Int = Int(0)
// [KnfOpt]   if (ok.2160 == _2162) then {
// [KnfOpt]     let sum.104: Int = Var(acc.2157)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _2163: Int = Apply(f.2156, [acc.2157, val.2161, ])
// [KnfOpt]     Jump(fold.2154, [stream.2155, f.2156, _2163, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.2154, [under1200.103, add.2150, _2153, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let over50.100: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let _101: Int = Int(1200)
// [KnfOpt] let rec aux.2148: Int = (y.2149: Int) {
// [KnfOpt]   if (y.2149 <= _101) then {
// [KnfOpt]     Int(0)
// [KnfOpt]   } else {
// [KnfOpt]     Int(1)
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] let _102: Fun([Int], Int) = Var(aux.2148)
// [KnfOpt] let rec aux.2164: Tuple([Int, Int]) = (u.2165: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.2166: Tuple([Int, Int]) = (u.2167: Var({val: Some(Unit)})) {
// [KnfOpt]     let _2168: Unit = Unit
// [KnfOpt]     let _2169: Tuple([Int, Int]) = Apply(over50.100, [_2168, ])
// [KnfOpt]     let (ok.2170: Var({val: Some(Int)}), val.2171: Var({val: Some(Int)})) = _2169
// [KnfOpt]     let _2172: Int = Int(0)
// [KnfOpt]     if (ok.2170 == _2172) then {
// [KnfOpt]       let _2173: Int = Int(0)
// [KnfOpt]       let _2174: Int = Int(0)
// [KnfOpt]       Tuple([_2173, _2174, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.2175: Int = Apply(_102, [val.2171, ])
// [KnfOpt]       let _2176: Int = Int(0)
// [KnfOpt]       if (r.2175 == _2176) then {
// [KnfOpt]         let _2177: Int = Int(1)
// [KnfOpt]         Tuple([_2177, val.2171, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _2178: Unit = Unit
// [KnfOpt]         Jump(aux.2166, [_2178, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.2166, [u.2165, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.2164)
// [KnfOpt] let rec add.2179: Int = (x.2180: Int, y.2181: Int) {
// [KnfOpt]   Add(x.2180, y.2181)
// [KnfOpt] }
// [KnfOpt] let _2182: Int = Int(0)
// [KnfOpt] let join fold.2183: Int = (stream.2184: Fun([Unit], Tuple([Int, Int])), f.2185: Fun([Int, Int], Int), acc.2186: Int) {
// [KnfOpt]   let _2187: Unit = Unit
// [KnfOpt]   let _2188: Tuple([Int, Int]) = Apply(stream.2184, [_2187, ])
// [KnfOpt]   let (ok.2189: Var({val: Some(Int)}), val.2190: Var({val: Some(Int)})) = _2188
// [KnfOpt]   let _2191: Int = Int(0)
// [KnfOpt]   if (ok.2189 == _2191) then {
// [KnfOpt]     let sum.104: Int = Var(acc.2186)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _2192: Int = Apply(f.2185, [acc.2186, val.2190, ])
// [KnfOpt]     Jump(fold.2183, [stream.2184, f.2185, _2192, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.2183, [under1200.103, add.2179, _2182, ])
// [KnfOpt] Inline threshold 5
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 0
// [KnfOpt] Inline decision le.83 accepted
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.2208: Int = (x.2209: Int, y.2210: Int) {
// [KnfOpt]   Add(x.2209, y.2210)
// [KnfOpt] }
// [KnfOpt] let _2211: Int = Int(0)
// [KnfOpt] let join fold.2212: Int = (stream.2213: Fun([Unit], Tuple([Int, Int])), f.2214: Fun([Int, Int], Int), acc.2215: Int) {
// [KnfOpt]   let _2216: Unit = Unit
// [KnfOpt]   let _2217: Tuple([Int, Int]) = Apply(stream.2213, [_2216, ])
// [KnfOpt]   let (ok.2218: Var({val: Some(Int)}), val.2219: Var({val: Some(Int)})) = _2217
// [KnfOpt]   let _2220: Int = Int(0)
// [KnfOpt]   if (ok.2218 == _2220) then {
// [KnfOpt]     let sum.104: Int = Var(acc.2215)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _2221: Int = Apply(f.2214, [acc.2215, val.2219, ])
// [KnfOpt]     Jump(fold.2212, [stream.2213, f.2214, _2221, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.2212, [under1200.103, add.2208, _2211, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(le) let _102: Fun([Int], Int) = Unit
// [KnfOpt] let rec aux.2222: Tuple([Int, Int]) = (u.2223: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.2224: Tuple([Int, Int]) = (u.2225: Var({val: Some(Unit)})) {
// [KnfOpt]     let _2226: Unit = Unit
// [KnfOpt]     let _2227: Tuple([Int, Int]) = Apply(over50.100, [_2226, ])
// [KnfOpt]     let (ok.2228: Var({val: Some(Int)}), val.2229: Var({val: Some(Int)})) = _2227
// [KnfOpt]     let _2230: Int = Int(0)
// [KnfOpt]     if (ok.2228 == _2230) then {
// [KnfOpt]       let _2231: Int = Int(0)
// [KnfOpt]       let _2232: Int = Int(0)
// [KnfOpt]       Tuple([_2231, _2232, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.2233: Int = Apply(_102, [val.2229, ])
// [KnfOpt]       let _2234: Int = Int(0)
// [KnfOpt]       if (r.2233 == _2234) then {
// [KnfOpt]         let _2235: Int = Int(1)
// [KnfOpt]         Tuple([_2235, val.2229, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _2236: Unit = Unit
// [KnfOpt]         Jump(aux.2224, [_2236, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.2224, [u.2223, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.2222)
// [KnfOpt] let rec add.2237: Int = (x.2238: Int, y.2239: Int) {
// [KnfOpt]   Add(x.2238, y.2239)
// [KnfOpt] }
// [KnfOpt] let _2240: Int = Int(0)
// [KnfOpt] let join fold.2241: Int = (stream.2242: Fun([Unit], Tuple([Int, Int])), f.2243: Fun([Int, Int], Int), acc.2244: Int) {
// [KnfOpt]   let _2245: Unit = Unit
// [KnfOpt]   let _2246: Tuple([Int, Int]) = Apply(stream.2242, [_2245, ])
// [KnfOpt]   let (ok.2247: Var({val: Some(Int)}), val.2248: Var({val: Some(Int)})) = _2246
// [KnfOpt]   let _2249: Int = Int(0)
// [KnfOpt]   if (ok.2247 == _2249) then {
// [KnfOpt]     let sum.104: Int = Var(acc.2244)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _2250: Int = Apply(f.2243, [acc.2244, val.2248, ])
// [KnfOpt]     Jump(fold.2241, [stream.2242, f.2243, _2250, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.2241, [under1200.103, add.2237, _2240, ])
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.2253: Int = (x.2254: Int, y.2255: Int) {
// [KnfOpt]   Add(x.2254, y.2255)
// [KnfOpt] }
// [KnfOpt] let _2256: Int = Int(0)
// [KnfOpt] let join fold.2257: Int = (stream.2258: Fun([Unit], Tuple([Int, Int])), f.2259: Fun([Int, Int], Int), acc.2260: Int) {
// [KnfOpt]   let _2261: Unit = Unit
// [KnfOpt]   let _2262: Tuple([Int, Int]) = Apply(stream.2258, [_2261, ])
// [KnfOpt]   let (ok.2263: Var({val: Some(Int)}), val.2264: Var({val: Some(Int)})) = _2262
// [KnfOpt]   let _2265: Int = Int(0)
// [KnfOpt]   if (ok.2263 == _2265) then {
// [KnfOpt]     let sum.104: Int = Var(acc.2260)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _2266: Int = Apply(f.2259, [acc.2260, val.2264, ])
// [KnfOpt]     Jump(fold.2257, [stream.2258, f.2259, _2266, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.2257, [under1200.103, add.2253, _2256, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(gt) let _99: Fun([Int], Int) = Unit
// [KnfOpt] let rec aux.2193: Tuple([Int, Int]) = (u.2194: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.2195: Tuple([Int, Int]) = (u.2196: Var({val: Some(Unit)})) {
// [KnfOpt]     let _2197: Unit = Unit
// [KnfOpt]     let _2198: Tuple([Int, Int]) = Apply(addone.97, [_2197, ])
// [KnfOpt]     let (ok.2199: Var({val: Some(Int)}), val.2200: Var({val: Some(Int)})) = _2198
// [KnfOpt]     let _2201: Int = Int(0)
// [KnfOpt]     if (ok.2199 == _2201) then {
// [KnfOpt]       let _2202: Int = Int(0)
// [KnfOpt]       let _2203: Int = Int(0)
// [KnfOpt]       Tuple([_2202, _2203, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.2204: Int = Apply(_99, [val.2200, ])
// [KnfOpt]       let _2205: Int = Int(0)
// [KnfOpt]       if (r.2204 == _2205) then {
// [KnfOpt]         let _2206: Int = Int(1)
// [KnfOpt]         Tuple([_2206, val.2200, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _2207: Unit = Unit
// [KnfOpt]         Jump(aux.2195, [_2207, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.2195, [u.2194, ])
// [KnfOpt] }
// [KnfOpt] let over50.100: Fun([Unit], Tuple([Int, Int])) = Var(aux.2193)
// [KnfOpt] let _101: Int = Int(1200)
// [KnfOpt] let rec aux.2251: Int = (y.2252: Int) {
// [KnfOpt]   if (y.2252 <= _101) then {
// [KnfOpt]     Int(0)
// [KnfOpt]   } else {
// [KnfOpt]     Int(1)
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] let _102: Fun([Int], Int) = Var(aux.2251)
// [KnfOpt] let rec aux.2267: Tuple([Int, Int]) = (u.2268: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.2269: Tuple([Int, Int]) = (u.2270: Var({val: Some(Unit)})) {
// [KnfOpt]     let _2271: Unit = Unit
// [KnfOpt]     let _2272: Tuple([Int, Int]) = Apply(over50.100, [_2271, ])
// [KnfOpt]     let (ok.2273: Var({val: Some(Int)}), val.2274: Var({val: Some(Int)})) = _2272
// [KnfOpt]     let _2275: Int = Int(0)
// [KnfOpt]     if (ok.2273 == _2275) then {
// [KnfOpt]       let _2276: Int = Int(0)
// [KnfOpt]       let _2277: Int = Int(0)
// [KnfOpt]       Tuple([_2276, _2277, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.2278: Int = Apply(_102, [val.2274, ])
// [KnfOpt]       let _2279: Int = Int(0)
// [KnfOpt]       if (r.2278 == _2279) then {
// [KnfOpt]         let _2280: Int = Int(1)
// [KnfOpt]         Tuple([_2280, val.2274, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _2281: Unit = Unit
// [KnfOpt]         Jump(aux.2269, [_2281, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.2269, [u.2268, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.2267)
// [KnfOpt] let rec add.2282: Int = (x.2283: Int, y.2284: Int) {
// [KnfOpt]   Add(x.2283, y.2284)
// [KnfOpt] }
// [KnfOpt] let _2285: Int = Int(0)
// [KnfOpt] let join fold.2286: Int = (stream.2287: Fun([Unit], Tuple([Int, Int])), f.2288: Fun([Int, Int], Int), acc.2289: Int) {
// [KnfOpt]   let _2290: Unit = Unit
// [KnfOpt]   let _2291: Tuple([Int, Int]) = Apply(stream.2287, [_2290, ])
// [KnfOpt]   let (ok.2292: Var({val: Some(Int)}), val.2293: Var({val: Some(Int)})) = _2291
// [KnfOpt]   let _2294: Int = Int(0)
// [KnfOpt]   if (ok.2292 == _2294) then {
// [KnfOpt]     let sum.104: Int = Var(acc.2289)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _2295: Int = Apply(f.2288, [acc.2289, val.2293, ])
// [KnfOpt]     Jump(fold.2286, [stream.2287, f.2288, _2295, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.2286, [under1200.103, add.2282, _2285, ])
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 5
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 0
// [KnfOpt] Inline decision le.83 accepted
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.2298: Int = (x.2299: Int, y.2300: Int) {
// [KnfOpt]   Add(x.2299, y.2300)
// [KnfOpt] }
// [KnfOpt] let _2301: Int = Int(0)
// [KnfOpt] let join fold.2302: Int = (stream.2303: Fun([Unit], Tuple([Int, Int])), f.2304: Fun([Int, Int], Int), acc.2305: Int) {
// [KnfOpt]   let _2306: Unit = Unit
// [KnfOpt]   let _2307: Tuple([Int, Int]) = Apply(stream.2303, [_2306, ])
// [KnfOpt]   let (ok.2308: Var({val: Some(Int)}), val.2309: Var({val: Some(Int)})) = _2307
// [KnfOpt]   let _2310: Int = Int(0)
// [KnfOpt]   if (ok.2308 == _2310) then {
// [KnfOpt]     let sum.104: Int = Var(acc.2305)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _2311: Int = Apply(f.2304, [acc.2305, val.2309, ])
// [KnfOpt]     Jump(fold.2302, [stream.2303, f.2304, _2311, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.2302, [under1200.103, add.2298, _2301, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(le) let _102: Fun([Int], Int) = Unit
// [KnfOpt] let rec aux.2312: Tuple([Int, Int]) = (u.2313: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.2314: Tuple([Int, Int]) = (u.2315: Var({val: Some(Unit)})) {
// [KnfOpt]     let _2316: Unit = Unit
// [KnfOpt]     let _2317: Tuple([Int, Int]) = Apply(over50.100, [_2316, ])
// [KnfOpt]     let (ok.2318: Var({val: Some(Int)}), val.2319: Var({val: Some(Int)})) = _2317
// [KnfOpt]     let _2320: Int = Int(0)
// [KnfOpt]     if (ok.2318 == _2320) then {
// [KnfOpt]       let _2321: Int = Int(0)
// [KnfOpt]       let _2322: Int = Int(0)
// [KnfOpt]       Tuple([_2321, _2322, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.2323: Int = Apply(_102, [val.2319, ])
// [KnfOpt]       let _2324: Int = Int(0)
// [KnfOpt]       if (r.2323 == _2324) then {
// [KnfOpt]         let _2325: Int = Int(1)
// [KnfOpt]         Tuple([_2325, val.2319, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _2326: Unit = Unit
// [KnfOpt]         Jump(aux.2314, [_2326, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.2314, [u.2313, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.2312)
// [KnfOpt] let rec add.2327: Int = (x.2328: Int, y.2329: Int) {
// [KnfOpt]   Add(x.2328, y.2329)
// [KnfOpt] }
// [KnfOpt] let _2330: Int = Int(0)
// [KnfOpt] let join fold.2331: Int = (stream.2332: Fun([Unit], Tuple([Int, Int])), f.2333: Fun([Int, Int], Int), acc.2334: Int) {
// [KnfOpt]   let _2335: Unit = Unit
// [KnfOpt]   let _2336: Tuple([Int, Int]) = Apply(stream.2332, [_2335, ])
// [KnfOpt]   let (ok.2337: Var({val: Some(Int)}), val.2338: Var({val: Some(Int)})) = _2336
// [KnfOpt]   let _2339: Int = Int(0)
// [KnfOpt]   if (ok.2337 == _2339) then {
// [KnfOpt]     let sum.104: Int = Var(acc.2334)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _2340: Int = Apply(f.2333, [acc.2334, val.2338, ])
// [KnfOpt]     Jump(fold.2331, [stream.2332, f.2333, _2340, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.2331, [under1200.103, add.2327, _2330, ])
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.2343: Int = (x.2344: Int, y.2345: Int) {
// [KnfOpt]   Add(x.2344, y.2345)
// [KnfOpt] }
// [KnfOpt] let _2346: Int = Int(0)
// [KnfOpt] let join fold.2347: Int = (stream.2348: Fun([Unit], Tuple([Int, Int])), f.2349: Fun([Int, Int], Int), acc.2350: Int) {
// [KnfOpt]   let _2351: Unit = Unit
// [KnfOpt]   let _2352: Tuple([Int, Int]) = Apply(stream.2348, [_2351, ])
// [KnfOpt]   let (ok.2353: Var({val: Some(Int)}), val.2354: Var({val: Some(Int)})) = _2352
// [KnfOpt]   let _2355: Int = Int(0)
// [KnfOpt]   if (ok.2353 == _2355) then {
// [KnfOpt]     let sum.104: Int = Var(acc.2350)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _2356: Int = Apply(f.2349, [acc.2350, val.2354, ])
// [KnfOpt]     Jump(fold.2347, [stream.2348, f.2349, _2356, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.2347, [under1200.103, add.2343, _2346, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let over50.100: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let _101: Int = Int(1200)
// [KnfOpt] let rec aux.2341: Int = (y.2342: Int) {
// [KnfOpt]   if (y.2342 <= _101) then {
// [KnfOpt]     Int(0)
// [KnfOpt]   } else {
// [KnfOpt]     Int(1)
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] let _102: Fun([Int], Int) = Var(aux.2341)
// [KnfOpt] let rec aux.2357: Tuple([Int, Int]) = (u.2358: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.2359: Tuple([Int, Int]) = (u.2360: Var({val: Some(Unit)})) {
// [KnfOpt]     let _2361: Unit = Unit
// [KnfOpt]     let _2362: Tuple([Int, Int]) = Apply(over50.100, [_2361, ])
// [KnfOpt]     let (ok.2363: Var({val: Some(Int)}), val.2364: Var({val: Some(Int)})) = _2362
// [KnfOpt]     let _2365: Int = Int(0)
// [KnfOpt]     if (ok.2363 == _2365) then {
// [KnfOpt]       let _2366: Int = Int(0)
// [KnfOpt]       let _2367: Int = Int(0)
// [KnfOpt]       Tuple([_2366, _2367, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.2368: Int = Apply(_102, [val.2364, ])
// [KnfOpt]       let _2369: Int = Int(0)
// [KnfOpt]       if (r.2368 == _2369) then {
// [KnfOpt]         let _2370: Int = Int(1)
// [KnfOpt]         Tuple([_2370, val.2364, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _2371: Unit = Unit
// [KnfOpt]         Jump(aux.2359, [_2371, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.2359, [u.2358, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.2357)
// [KnfOpt] let rec add.2372: Int = (x.2373: Int, y.2374: Int) {
// [KnfOpt]   Add(x.2373, y.2374)
// [KnfOpt] }
// [KnfOpt] let _2375: Int = Int(0)
// [KnfOpt] let join fold.2376: Int = (stream.2377: Fun([Unit], Tuple([Int, Int])), f.2378: Fun([Int, Int], Int), acc.2379: Int) {
// [KnfOpt]   let _2380: Unit = Unit
// [KnfOpt]   let _2381: Tuple([Int, Int]) = Apply(stream.2377, [_2380, ])
// [KnfOpt]   let (ok.2382: Var({val: Some(Int)}), val.2383: Var({val: Some(Int)})) = _2381
// [KnfOpt]   let _2384: Int = Int(0)
// [KnfOpt]   if (ok.2382 == _2384) then {
// [KnfOpt]     let sum.104: Int = Var(acc.2379)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _2385: Int = Apply(f.2378, [acc.2379, val.2383, ])
// [KnfOpt]     Jump(fold.2376, [stream.2377, f.2378, _2385, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.2376, [under1200.103, add.2372, _2375, ])
// [KnfOpt] Inline threshold 5
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 0
// [KnfOpt] Inline decision le.83 accepted
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.2401: Int = (x.2402: Int, y.2403: Int) {
// [KnfOpt]   Add(x.2402, y.2403)
// [KnfOpt] }
// [KnfOpt] let _2404: Int = Int(0)
// [KnfOpt] let join fold.2405: Int = (stream.2406: Fun([Unit], Tuple([Int, Int])), f.2407: Fun([Int, Int], Int), acc.2408: Int) {
// [KnfOpt]   let _2409: Unit = Unit
// [KnfOpt]   let _2410: Tuple([Int, Int]) = Apply(stream.2406, [_2409, ])
// [KnfOpt]   let (ok.2411: Var({val: Some(Int)}), val.2412: Var({val: Some(Int)})) = _2410
// [KnfOpt]   let _2413: Int = Int(0)
// [KnfOpt]   if (ok.2411 == _2413) then {
// [KnfOpt]     let sum.104: Int = Var(acc.2408)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _2414: Int = Apply(f.2407, [acc.2408, val.2412, ])
// [KnfOpt]     Jump(fold.2405, [stream.2406, f.2407, _2414, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.2405, [under1200.103, add.2401, _2404, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(le) let _102: Fun([Int], Int) = Unit
// [KnfOpt] let rec aux.2415: Tuple([Int, Int]) = (u.2416: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.2417: Tuple([Int, Int]) = (u.2418: Var({val: Some(Unit)})) {
// [KnfOpt]     let _2419: Unit = Unit
// [KnfOpt]     let _2420: Tuple([Int, Int]) = Apply(over50.100, [_2419, ])
// [KnfOpt]     let (ok.2421: Var({val: Some(Int)}), val.2422: Var({val: Some(Int)})) = _2420
// [KnfOpt]     let _2423: Int = Int(0)
// [KnfOpt]     if (ok.2421 == _2423) then {
// [KnfOpt]       let _2424: Int = Int(0)
// [KnfOpt]       let _2425: Int = Int(0)
// [KnfOpt]       Tuple([_2424, _2425, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.2426: Int = Apply(_102, [val.2422, ])
// [KnfOpt]       let _2427: Int = Int(0)
// [KnfOpt]       if (r.2426 == _2427) then {
// [KnfOpt]         let _2428: Int = Int(1)
// [KnfOpt]         Tuple([_2428, val.2422, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _2429: Unit = Unit
// [KnfOpt]         Jump(aux.2417, [_2429, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.2417, [u.2416, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.2415)
// [KnfOpt] let rec add.2430: Int = (x.2431: Int, y.2432: Int) {
// [KnfOpt]   Add(x.2431, y.2432)
// [KnfOpt] }
// [KnfOpt] let _2433: Int = Int(0)
// [KnfOpt] let join fold.2434: Int = (stream.2435: Fun([Unit], Tuple([Int, Int])), f.2436: Fun([Int, Int], Int), acc.2437: Int) {
// [KnfOpt]   let _2438: Unit = Unit
// [KnfOpt]   let _2439: Tuple([Int, Int]) = Apply(stream.2435, [_2438, ])
// [KnfOpt]   let (ok.2440: Var({val: Some(Int)}), val.2441: Var({val: Some(Int)})) = _2439
// [KnfOpt]   let _2442: Int = Int(0)
// [KnfOpt]   if (ok.2440 == _2442) then {
// [KnfOpt]     let sum.104: Int = Var(acc.2437)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _2443: Int = Apply(f.2436, [acc.2437, val.2441, ])
// [KnfOpt]     Jump(fold.2434, [stream.2435, f.2436, _2443, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.2434, [under1200.103, add.2430, _2433, ])
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.2446: Int = (x.2447: Int, y.2448: Int) {
// [KnfOpt]   Add(x.2447, y.2448)
// [KnfOpt] }
// [KnfOpt] let _2449: Int = Int(0)
// [KnfOpt] let join fold.2450: Int = (stream.2451: Fun([Unit], Tuple([Int, Int])), f.2452: Fun([Int, Int], Int), acc.2453: Int) {
// [KnfOpt]   let _2454: Unit = Unit
// [KnfOpt]   let _2455: Tuple([Int, Int]) = Apply(stream.2451, [_2454, ])
// [KnfOpt]   let (ok.2456: Var({val: Some(Int)}), val.2457: Var({val: Some(Int)})) = _2455
// [KnfOpt]   let _2458: Int = Int(0)
// [KnfOpt]   if (ok.2456 == _2458) then {
// [KnfOpt]     let sum.104: Int = Var(acc.2453)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _2459: Int = Apply(f.2452, [acc.2453, val.2457, ])
// [KnfOpt]     Jump(fold.2450, [stream.2451, f.2452, _2459, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.2450, [under1200.103, add.2446, _2449, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(addx) let _96: Fun([Int], Int) = Unit
// [KnfOpt] let rec aux.2094: Tuple([Int, Int]) = (u.2095: Var({val: Some(Unit)})) {
// [KnfOpt]   let _2096: Unit = Unit
// [KnfOpt]   let _2097: Tuple([Int, Int]) = Apply(catt.94, [_2096, ])
// [KnfOpt]   let (ok.2098: Var({val: Some(Int)}), val.2099: Var({val: Some(Int)})) = _2097
// [KnfOpt]   let _2100: Int = Int(0)
// [KnfOpt]   if (ok.2098 == _2100) then {
// [KnfOpt]     let _2101: Int = Int(0)
// [KnfOpt]     let _2102: Int = Int(0)
// [KnfOpt]     Tuple([_2101, _2102, ])
// [KnfOpt]   } else {
// [KnfOpt]     let _2103: Int = Int(1)
// [KnfOpt]     let _2104: Int = Apply(_96, [val.2099, ])
// [KnfOpt]     Tuple([_2103, _2104, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] let addone.97: Fun([Unit], Tuple([Int, Int])) = Var(aux.2094)
// [KnfOpt] let _98: Int = Int(50)
// [KnfOpt] let rec aux.2296: Int = (y.2297: Int) {
// [KnfOpt]   if (_98 <= y.2297) then {
// [KnfOpt]     Int(0)
// [KnfOpt]   } else {
// [KnfOpt]     Int(1)
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] let _99: Fun([Int], Int) = Var(aux.2296)
// [KnfOpt] let rec aux.2386: Tuple([Int, Int]) = (u.2387: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.2388: Tuple([Int, Int]) = (u.2389: Var({val: Some(Unit)})) {
// [KnfOpt]     let _2390: Unit = Unit
// [KnfOpt]     let _2391: Tuple([Int, Int]) = Apply(addone.97, [_2390, ])
// [KnfOpt]     let (ok.2392: Var({val: Some(Int)}), val.2393: Var({val: Some(Int)})) = _2391
// [KnfOpt]     let _2394: Int = Int(0)
// [KnfOpt]     if (ok.2392 == _2394) then {
// [KnfOpt]       let _2395: Int = Int(0)
// [KnfOpt]       let _2396: Int = Int(0)
// [KnfOpt]       Tuple([_2395, _2396, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.2397: Int = Apply(_99, [val.2393, ])
// [KnfOpt]       let _2398: Int = Int(0)
// [KnfOpt]       if (r.2397 == _2398) then {
// [KnfOpt]         let _2399: Int = Int(1)
// [KnfOpt]         Tuple([_2399, val.2393, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _2400: Unit = Unit
// [KnfOpt]         Jump(aux.2388, [_2400, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.2388, [u.2387, ])
// [KnfOpt] }
// [KnfOpt] let over50.100: Fun([Unit], Tuple([Int, Int])) = Var(aux.2386)
// [KnfOpt] let _101: Int = Int(1200)
// [KnfOpt] let rec aux.2444: Int = (y.2445: Int) {
// [KnfOpt]   if (y.2445 <= _101) then {
// [KnfOpt]     Int(0)
// [KnfOpt]   } else {
// [KnfOpt]     Int(1)
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] let _102: Fun([Int], Int) = Var(aux.2444)
// [KnfOpt] let rec aux.2460: Tuple([Int, Int]) = (u.2461: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.2462: Tuple([Int, Int]) = (u.2463: Var({val: Some(Unit)})) {
// [KnfOpt]     let _2464: Unit = Unit
// [KnfOpt]     let _2465: Tuple([Int, Int]) = Apply(over50.100, [_2464, ])
// [KnfOpt]     let (ok.2466: Var({val: Some(Int)}), val.2467: Var({val: Some(Int)})) = _2465
// [KnfOpt]     let _2468: Int = Int(0)
// [KnfOpt]     if (ok.2466 == _2468) then {
// [KnfOpt]       let _2469: Int = Int(0)
// [KnfOpt]       let _2470: Int = Int(0)
// [KnfOpt]       Tuple([_2469, _2470, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.2471: Int = Apply(_102, [val.2467, ])
// [KnfOpt]       let _2472: Int = Int(0)
// [KnfOpt]       if (r.2471 == _2472) then {
// [KnfOpt]         let _2473: Int = Int(1)
// [KnfOpt]         Tuple([_2473, val.2467, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _2474: Unit = Unit
// [KnfOpt]         Jump(aux.2462, [_2474, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.2462, [u.2461, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.2460)
// [KnfOpt] let rec add.2475: Int = (x.2476: Int, y.2477: Int) {
// [KnfOpt]   Add(x.2476, y.2477)
// [KnfOpt] }
// [KnfOpt] let _2478: Int = Int(0)
// [KnfOpt] let join fold.2479: Int = (stream.2480: Fun([Unit], Tuple([Int, Int])), f.2481: Fun([Int, Int], Int), acc.2482: Int) {
// [KnfOpt]   let _2483: Unit = Unit
// [KnfOpt]   let _2484: Tuple([Int, Int]) = Apply(stream.2480, [_2483, ])
// [KnfOpt]   let (ok.2485: Var({val: Some(Int)}), val.2486: Var({val: Some(Int)})) = _2484
// [KnfOpt]   let _2487: Int = Int(0)
// [KnfOpt]   if (ok.2485 == _2487) then {
// [KnfOpt]     let sum.104: Int = Var(acc.2482)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _2488: Int = Apply(f.2481, [acc.2482, val.2486, ])
// [KnfOpt]     Jump(fold.2479, [stream.2480, f.2481, _2488, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.2479, [under1200.103, add.2475, _2478, ])
// [KnfOpt] Inline threshold 20
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 0
// [KnfOpt] Inline decision map.1 accepted
// [KnfOpt] Inline threshold 5
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 0
// [KnfOpt] Inline decision gt.79 accepted
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 5
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 0
// [KnfOpt] Inline decision le.83 accepted
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.2491: Int = (x.2492: Int, y.2493: Int) {
// [KnfOpt]   Add(x.2492, y.2493)
// [KnfOpt] }
// [KnfOpt] let _2494: Int = Int(0)
// [KnfOpt] let join fold.2495: Int = (stream.2496: Fun([Unit], Tuple([Int, Int])), f.2497: Fun([Int, Int], Int), acc.2498: Int) {
// [KnfOpt]   let _2499: Unit = Unit
// [KnfOpt]   let _2500: Tuple([Int, Int]) = Apply(stream.2496, [_2499, ])
// [KnfOpt]   let (ok.2501: Var({val: Some(Int)}), val.2502: Var({val: Some(Int)})) = _2500
// [KnfOpt]   let _2503: Int = Int(0)
// [KnfOpt]   if (ok.2501 == _2503) then {
// [KnfOpt]     let sum.104: Int = Var(acc.2498)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _2504: Int = Apply(f.2497, [acc.2498, val.2502, ])
// [KnfOpt]     Jump(fold.2495, [stream.2496, f.2497, _2504, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.2495, [under1200.103, add.2491, _2494, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(le) let _102: Fun([Int], Int) = Unit
// [KnfOpt] let rec aux.2505: Tuple([Int, Int]) = (u.2506: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.2507: Tuple([Int, Int]) = (u.2508: Var({val: Some(Unit)})) {
// [KnfOpt]     let _2509: Unit = Unit
// [KnfOpt]     let _2510: Tuple([Int, Int]) = Apply(over50.100, [_2509, ])
// [KnfOpt]     let (ok.2511: Var({val: Some(Int)}), val.2512: Var({val: Some(Int)})) = _2510
// [KnfOpt]     let _2513: Int = Int(0)
// [KnfOpt]     if (ok.2511 == _2513) then {
// [KnfOpt]       let _2514: Int = Int(0)
// [KnfOpt]       let _2515: Int = Int(0)
// [KnfOpt]       Tuple([_2514, _2515, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.2516: Int = Apply(_102, [val.2512, ])
// [KnfOpt]       let _2517: Int = Int(0)
// [KnfOpt]       if (r.2516 == _2517) then {
// [KnfOpt]         let _2518: Int = Int(1)
// [KnfOpt]         Tuple([_2518, val.2512, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _2519: Unit = Unit
// [KnfOpt]         Jump(aux.2507, [_2519, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.2507, [u.2506, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.2505)
// [KnfOpt] let rec add.2520: Int = (x.2521: Int, y.2522: Int) {
// [KnfOpt]   Add(x.2521, y.2522)
// [KnfOpt] }
// [KnfOpt] let _2523: Int = Int(0)
// [KnfOpt] let join fold.2524: Int = (stream.2525: Fun([Unit], Tuple([Int, Int])), f.2526: Fun([Int, Int], Int), acc.2527: Int) {
// [KnfOpt]   let _2528: Unit = Unit
// [KnfOpt]   let _2529: Tuple([Int, Int]) = Apply(stream.2525, [_2528, ])
// [KnfOpt]   let (ok.2530: Var({val: Some(Int)}), val.2531: Var({val: Some(Int)})) = _2529
// [KnfOpt]   let _2532: Int = Int(0)
// [KnfOpt]   if (ok.2530 == _2532) then {
// [KnfOpt]     let sum.104: Int = Var(acc.2527)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _2533: Int = Apply(f.2526, [acc.2527, val.2531, ])
// [KnfOpt]     Jump(fold.2524, [stream.2525, f.2526, _2533, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.2524, [under1200.103, add.2520, _2523, ])
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.2536: Int = (x.2537: Int, y.2538: Int) {
// [KnfOpt]   Add(x.2537, y.2538)
// [KnfOpt] }
// [KnfOpt] let _2539: Int = Int(0)
// [KnfOpt] let join fold.2540: Int = (stream.2541: Fun([Unit], Tuple([Int, Int])), f.2542: Fun([Int, Int], Int), acc.2543: Int) {
// [KnfOpt]   let _2544: Unit = Unit
// [KnfOpt]   let _2545: Tuple([Int, Int]) = Apply(stream.2541, [_2544, ])
// [KnfOpt]   let (ok.2546: Var({val: Some(Int)}), val.2547: Var({val: Some(Int)})) = _2545
// [KnfOpt]   let _2548: Int = Int(0)
// [KnfOpt]   if (ok.2546 == _2548) then {
// [KnfOpt]     let sum.104: Int = Var(acc.2543)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _2549: Int = Apply(f.2542, [acc.2543, val.2547, ])
// [KnfOpt]     Jump(fold.2540, [stream.2541, f.2542, _2549, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.2540, [under1200.103, add.2536, _2539, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let over50.100: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let _101: Int = Int(1200)
// [KnfOpt] let rec aux.2534: Int = (y.2535: Int) {
// [KnfOpt]   if (y.2535 <= _101) then {
// [KnfOpt]     Int(0)
// [KnfOpt]   } else {
// [KnfOpt]     Int(1)
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] let _102: Fun([Int], Int) = Var(aux.2534)
// [KnfOpt] let rec aux.2550: Tuple([Int, Int]) = (u.2551: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.2552: Tuple([Int, Int]) = (u.2553: Var({val: Some(Unit)})) {
// [KnfOpt]     let _2554: Unit = Unit
// [KnfOpt]     let _2555: Tuple([Int, Int]) = Apply(over50.100, [_2554, ])
// [KnfOpt]     let (ok.2556: Var({val: Some(Int)}), val.2557: Var({val: Some(Int)})) = _2555
// [KnfOpt]     let _2558: Int = Int(0)
// [KnfOpt]     if (ok.2556 == _2558) then {
// [KnfOpt]       let _2559: Int = Int(0)
// [KnfOpt]       let _2560: Int = Int(0)
// [KnfOpt]       Tuple([_2559, _2560, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.2561: Int = Apply(_102, [val.2557, ])
// [KnfOpt]       let _2562: Int = Int(0)
// [KnfOpt]       if (r.2561 == _2562) then {
// [KnfOpt]         let _2563: Int = Int(1)
// [KnfOpt]         Tuple([_2563, val.2557, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _2564: Unit = Unit
// [KnfOpt]         Jump(aux.2552, [_2564, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.2552, [u.2551, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.2550)
// [KnfOpt] let rec add.2565: Int = (x.2566: Int, y.2567: Int) {
// [KnfOpt]   Add(x.2566, y.2567)
// [KnfOpt] }
// [KnfOpt] let _2568: Int = Int(0)
// [KnfOpt] let join fold.2569: Int = (stream.2570: Fun([Unit], Tuple([Int, Int])), f.2571: Fun([Int, Int], Int), acc.2572: Int) {
// [KnfOpt]   let _2573: Unit = Unit
// [KnfOpt]   let _2574: Tuple([Int, Int]) = Apply(stream.2570, [_2573, ])
// [KnfOpt]   let (ok.2575: Var({val: Some(Int)}), val.2576: Var({val: Some(Int)})) = _2574
// [KnfOpt]   let _2577: Int = Int(0)
// [KnfOpt]   if (ok.2575 == _2577) then {
// [KnfOpt]     let sum.104: Int = Var(acc.2572)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _2578: Int = Apply(f.2571, [acc.2572, val.2576, ])
// [KnfOpt]     Jump(fold.2569, [stream.2570, f.2571, _2578, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.2569, [under1200.103, add.2565, _2568, ])
// [KnfOpt] Inline threshold 5
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 0
// [KnfOpt] Inline decision le.83 accepted
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.2594: Int = (x.2595: Int, y.2596: Int) {
// [KnfOpt]   Add(x.2595, y.2596)
// [KnfOpt] }
// [KnfOpt] let _2597: Int = Int(0)
// [KnfOpt] let join fold.2598: Int = (stream.2599: Fun([Unit], Tuple([Int, Int])), f.2600: Fun([Int, Int], Int), acc.2601: Int) {
// [KnfOpt]   let _2602: Unit = Unit
// [KnfOpt]   let _2603: Tuple([Int, Int]) = Apply(stream.2599, [_2602, ])
// [KnfOpt]   let (ok.2604: Var({val: Some(Int)}), val.2605: Var({val: Some(Int)})) = _2603
// [KnfOpt]   let _2606: Int = Int(0)
// [KnfOpt]   if (ok.2604 == _2606) then {
// [KnfOpt]     let sum.104: Int = Var(acc.2601)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _2607: Int = Apply(f.2600, [acc.2601, val.2605, ])
// [KnfOpt]     Jump(fold.2598, [stream.2599, f.2600, _2607, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.2598, [under1200.103, add.2594, _2597, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(le) let _102: Fun([Int], Int) = Unit
// [KnfOpt] let rec aux.2608: Tuple([Int, Int]) = (u.2609: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.2610: Tuple([Int, Int]) = (u.2611: Var({val: Some(Unit)})) {
// [KnfOpt]     let _2612: Unit = Unit
// [KnfOpt]     let _2613: Tuple([Int, Int]) = Apply(over50.100, [_2612, ])
// [KnfOpt]     let (ok.2614: Var({val: Some(Int)}), val.2615: Var({val: Some(Int)})) = _2613
// [KnfOpt]     let _2616: Int = Int(0)
// [KnfOpt]     if (ok.2614 == _2616) then {
// [KnfOpt]       let _2617: Int = Int(0)
// [KnfOpt]       let _2618: Int = Int(0)
// [KnfOpt]       Tuple([_2617, _2618, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.2619: Int = Apply(_102, [val.2615, ])
// [KnfOpt]       let _2620: Int = Int(0)
// [KnfOpt]       if (r.2619 == _2620) then {
// [KnfOpt]         let _2621: Int = Int(1)
// [KnfOpt]         Tuple([_2621, val.2615, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _2622: Unit = Unit
// [KnfOpt]         Jump(aux.2610, [_2622, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.2610, [u.2609, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.2608)
// [KnfOpt] let rec add.2623: Int = (x.2624: Int, y.2625: Int) {
// [KnfOpt]   Add(x.2624, y.2625)
// [KnfOpt] }
// [KnfOpt] let _2626: Int = Int(0)
// [KnfOpt] let join fold.2627: Int = (stream.2628: Fun([Unit], Tuple([Int, Int])), f.2629: Fun([Int, Int], Int), acc.2630: Int) {
// [KnfOpt]   let _2631: Unit = Unit
// [KnfOpt]   let _2632: Tuple([Int, Int]) = Apply(stream.2628, [_2631, ])
// [KnfOpt]   let (ok.2633: Var({val: Some(Int)}), val.2634: Var({val: Some(Int)})) = _2632
// [KnfOpt]   let _2635: Int = Int(0)
// [KnfOpt]   if (ok.2633 == _2635) then {
// [KnfOpt]     let sum.104: Int = Var(acc.2630)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _2636: Int = Apply(f.2629, [acc.2630, val.2634, ])
// [KnfOpt]     Jump(fold.2627, [stream.2628, f.2629, _2636, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.2627, [under1200.103, add.2623, _2626, ])
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.2639: Int = (x.2640: Int, y.2641: Int) {
// [KnfOpt]   Add(x.2640, y.2641)
// [KnfOpt] }
// [KnfOpt] let _2642: Int = Int(0)
// [KnfOpt] let join fold.2643: Int = (stream.2644: Fun([Unit], Tuple([Int, Int])), f.2645: Fun([Int, Int], Int), acc.2646: Int) {
// [KnfOpt]   let _2647: Unit = Unit
// [KnfOpt]   let _2648: Tuple([Int, Int]) = Apply(stream.2644, [_2647, ])
// [KnfOpt]   let (ok.2649: Var({val: Some(Int)}), val.2650: Var({val: Some(Int)})) = _2648
// [KnfOpt]   let _2651: Int = Int(0)
// [KnfOpt]   if (ok.2649 == _2651) then {
// [KnfOpt]     let sum.104: Int = Var(acc.2646)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _2652: Int = Apply(f.2645, [acc.2646, val.2650, ])
// [KnfOpt]     Jump(fold.2643, [stream.2644, f.2645, _2652, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.2643, [under1200.103, add.2639, _2642, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(gt) let _99: Fun([Int], Int) = Unit
// [KnfOpt] let rec aux.2579: Tuple([Int, Int]) = (u.2580: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.2581: Tuple([Int, Int]) = (u.2582: Var({val: Some(Unit)})) {
// [KnfOpt]     let _2583: Unit = Unit
// [KnfOpt]     let _2584: Tuple([Int, Int]) = Apply(addone.97, [_2583, ])
// [KnfOpt]     let (ok.2585: Var({val: Some(Int)}), val.2586: Var({val: Some(Int)})) = _2584
// [KnfOpt]     let _2587: Int = Int(0)
// [KnfOpt]     if (ok.2585 == _2587) then {
// [KnfOpt]       let _2588: Int = Int(0)
// [KnfOpt]       let _2589: Int = Int(0)
// [KnfOpt]       Tuple([_2588, _2589, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.2590: Int = Apply(_99, [val.2586, ])
// [KnfOpt]       let _2591: Int = Int(0)
// [KnfOpt]       if (r.2590 == _2591) then {
// [KnfOpt]         let _2592: Int = Int(1)
// [KnfOpt]         Tuple([_2592, val.2586, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _2593: Unit = Unit
// [KnfOpt]         Jump(aux.2581, [_2593, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.2581, [u.2580, ])
// [KnfOpt] }
// [KnfOpt] let over50.100: Fun([Unit], Tuple([Int, Int])) = Var(aux.2579)
// [KnfOpt] let _101: Int = Int(1200)
// [KnfOpt] let rec aux.2637: Int = (y.2638: Int) {
// [KnfOpt]   if (y.2638 <= _101) then {
// [KnfOpt]     Int(0)
// [KnfOpt]   } else {
// [KnfOpt]     Int(1)
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] let _102: Fun([Int], Int) = Var(aux.2637)
// [KnfOpt] let rec aux.2653: Tuple([Int, Int]) = (u.2654: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.2655: Tuple([Int, Int]) = (u.2656: Var({val: Some(Unit)})) {
// [KnfOpt]     let _2657: Unit = Unit
// [KnfOpt]     let _2658: Tuple([Int, Int]) = Apply(over50.100, [_2657, ])
// [KnfOpt]     let (ok.2659: Var({val: Some(Int)}), val.2660: Var({val: Some(Int)})) = _2658
// [KnfOpt]     let _2661: Int = Int(0)
// [KnfOpt]     if (ok.2659 == _2661) then {
// [KnfOpt]       let _2662: Int = Int(0)
// [KnfOpt]       let _2663: Int = Int(0)
// [KnfOpt]       Tuple([_2662, _2663, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.2664: Int = Apply(_102, [val.2660, ])
// [KnfOpt]       let _2665: Int = Int(0)
// [KnfOpt]       if (r.2664 == _2665) then {
// [KnfOpt]         let _2666: Int = Int(1)
// [KnfOpt]         Tuple([_2666, val.2660, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _2667: Unit = Unit
// [KnfOpt]         Jump(aux.2655, [_2667, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.2655, [u.2654, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.2653)
// [KnfOpt] let rec add.2668: Int = (x.2669: Int, y.2670: Int) {
// [KnfOpt]   Add(x.2669, y.2670)
// [KnfOpt] }
// [KnfOpt] let _2671: Int = Int(0)
// [KnfOpt] let join fold.2672: Int = (stream.2673: Fun([Unit], Tuple([Int, Int])), f.2674: Fun([Int, Int], Int), acc.2675: Int) {
// [KnfOpt]   let _2676: Unit = Unit
// [KnfOpt]   let _2677: Tuple([Int, Int]) = Apply(stream.2673, [_2676, ])
// [KnfOpt]   let (ok.2678: Var({val: Some(Int)}), val.2679: Var({val: Some(Int)})) = _2677
// [KnfOpt]   let _2680: Int = Int(0)
// [KnfOpt]   if (ok.2678 == _2680) then {
// [KnfOpt]     let sum.104: Int = Var(acc.2675)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _2681: Int = Apply(f.2674, [acc.2675, val.2679, ])
// [KnfOpt]     Jump(fold.2672, [stream.2673, f.2674, _2681, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.2672, [under1200.103, add.2668, _2671, ])
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 5
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 0
// [KnfOpt] Inline decision le.83 accepted
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.2684: Int = (x.2685: Int, y.2686: Int) {
// [KnfOpt]   Add(x.2685, y.2686)
// [KnfOpt] }
// [KnfOpt] let _2687: Int = Int(0)
// [KnfOpt] let join fold.2688: Int = (stream.2689: Fun([Unit], Tuple([Int, Int])), f.2690: Fun([Int, Int], Int), acc.2691: Int) {
// [KnfOpt]   let _2692: Unit = Unit
// [KnfOpt]   let _2693: Tuple([Int, Int]) = Apply(stream.2689, [_2692, ])
// [KnfOpt]   let (ok.2694: Var({val: Some(Int)}), val.2695: Var({val: Some(Int)})) = _2693
// [KnfOpt]   let _2696: Int = Int(0)
// [KnfOpt]   if (ok.2694 == _2696) then {
// [KnfOpt]     let sum.104: Int = Var(acc.2691)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _2697: Int = Apply(f.2690, [acc.2691, val.2695, ])
// [KnfOpt]     Jump(fold.2688, [stream.2689, f.2690, _2697, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.2688, [under1200.103, add.2684, _2687, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(le) let _102: Fun([Int], Int) = Unit
// [KnfOpt] let rec aux.2698: Tuple([Int, Int]) = (u.2699: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.2700: Tuple([Int, Int]) = (u.2701: Var({val: Some(Unit)})) {
// [KnfOpt]     let _2702: Unit = Unit
// [KnfOpt]     let _2703: Tuple([Int, Int]) = Apply(over50.100, [_2702, ])
// [KnfOpt]     let (ok.2704: Var({val: Some(Int)}), val.2705: Var({val: Some(Int)})) = _2703
// [KnfOpt]     let _2706: Int = Int(0)
// [KnfOpt]     if (ok.2704 == _2706) then {
// [KnfOpt]       let _2707: Int = Int(0)
// [KnfOpt]       let _2708: Int = Int(0)
// [KnfOpt]       Tuple([_2707, _2708, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.2709: Int = Apply(_102, [val.2705, ])
// [KnfOpt]       let _2710: Int = Int(0)
// [KnfOpt]       if (r.2709 == _2710) then {
// [KnfOpt]         let _2711: Int = Int(1)
// [KnfOpt]         Tuple([_2711, val.2705, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _2712: Unit = Unit
// [KnfOpt]         Jump(aux.2700, [_2712, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.2700, [u.2699, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.2698)
// [KnfOpt] let rec add.2713: Int = (x.2714: Int, y.2715: Int) {
// [KnfOpt]   Add(x.2714, y.2715)
// [KnfOpt] }
// [KnfOpt] let _2716: Int = Int(0)
// [KnfOpt] let join fold.2717: Int = (stream.2718: Fun([Unit], Tuple([Int, Int])), f.2719: Fun([Int, Int], Int), acc.2720: Int) {
// [KnfOpt]   let _2721: Unit = Unit
// [KnfOpt]   let _2722: Tuple([Int, Int]) = Apply(stream.2718, [_2721, ])
// [KnfOpt]   let (ok.2723: Var({val: Some(Int)}), val.2724: Var({val: Some(Int)})) = _2722
// [KnfOpt]   let _2725: Int = Int(0)
// [KnfOpt]   if (ok.2723 == _2725) then {
// [KnfOpt]     let sum.104: Int = Var(acc.2720)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _2726: Int = Apply(f.2719, [acc.2720, val.2724, ])
// [KnfOpt]     Jump(fold.2717, [stream.2718, f.2719, _2726, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.2717, [under1200.103, add.2713, _2716, ])
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.2729: Int = (x.2730: Int, y.2731: Int) {
// [KnfOpt]   Add(x.2730, y.2731)
// [KnfOpt] }
// [KnfOpt] let _2732: Int = Int(0)
// [KnfOpt] let join fold.2733: Int = (stream.2734: Fun([Unit], Tuple([Int, Int])), f.2735: Fun([Int, Int], Int), acc.2736: Int) {
// [KnfOpt]   let _2737: Unit = Unit
// [KnfOpt]   let _2738: Tuple([Int, Int]) = Apply(stream.2734, [_2737, ])
// [KnfOpt]   let (ok.2739: Var({val: Some(Int)}), val.2740: Var({val: Some(Int)})) = _2738
// [KnfOpt]   let _2741: Int = Int(0)
// [KnfOpt]   if (ok.2739 == _2741) then {
// [KnfOpt]     let sum.104: Int = Var(acc.2736)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _2742: Int = Apply(f.2735, [acc.2736, val.2740, ])
// [KnfOpt]     Jump(fold.2733, [stream.2734, f.2735, _2742, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.2733, [under1200.103, add.2729, _2732, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let over50.100: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let _101: Int = Int(1200)
// [KnfOpt] let rec aux.2727: Int = (y.2728: Int) {
// [KnfOpt]   if (y.2728 <= _101) then {
// [KnfOpt]     Int(0)
// [KnfOpt]   } else {
// [KnfOpt]     Int(1)
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] let _102: Fun([Int], Int) = Var(aux.2727)
// [KnfOpt] let rec aux.2743: Tuple([Int, Int]) = (u.2744: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.2745: Tuple([Int, Int]) = (u.2746: Var({val: Some(Unit)})) {
// [KnfOpt]     let _2747: Unit = Unit
// [KnfOpt]     let _2748: Tuple([Int, Int]) = Apply(over50.100, [_2747, ])
// [KnfOpt]     let (ok.2749: Var({val: Some(Int)}), val.2750: Var({val: Some(Int)})) = _2748
// [KnfOpt]     let _2751: Int = Int(0)
// [KnfOpt]     if (ok.2749 == _2751) then {
// [KnfOpt]       let _2752: Int = Int(0)
// [KnfOpt]       let _2753: Int = Int(0)
// [KnfOpt]       Tuple([_2752, _2753, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.2754: Int = Apply(_102, [val.2750, ])
// [KnfOpt]       let _2755: Int = Int(0)
// [KnfOpt]       if (r.2754 == _2755) then {
// [KnfOpt]         let _2756: Int = Int(1)
// [KnfOpt]         Tuple([_2756, val.2750, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _2757: Unit = Unit
// [KnfOpt]         Jump(aux.2745, [_2757, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.2745, [u.2744, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.2743)
// [KnfOpt] let rec add.2758: Int = (x.2759: Int, y.2760: Int) {
// [KnfOpt]   Add(x.2759, y.2760)
// [KnfOpt] }
// [KnfOpt] let _2761: Int = Int(0)
// [KnfOpt] let join fold.2762: Int = (stream.2763: Fun([Unit], Tuple([Int, Int])), f.2764: Fun([Int, Int], Int), acc.2765: Int) {
// [KnfOpt]   let _2766: Unit = Unit
// [KnfOpt]   let _2767: Tuple([Int, Int]) = Apply(stream.2763, [_2766, ])
// [KnfOpt]   let (ok.2768: Var({val: Some(Int)}), val.2769: Var({val: Some(Int)})) = _2767
// [KnfOpt]   let _2770: Int = Int(0)
// [KnfOpt]   if (ok.2768 == _2770) then {
// [KnfOpt]     let sum.104: Int = Var(acc.2765)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _2771: Int = Apply(f.2764, [acc.2765, val.2769, ])
// [KnfOpt]     Jump(fold.2762, [stream.2763, f.2764, _2771, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.2762, [under1200.103, add.2758, _2761, ])
// [KnfOpt] Inline threshold 5
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 0
// [KnfOpt] Inline decision le.83 accepted
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.2787: Int = (x.2788: Int, y.2789: Int) {
// [KnfOpt]   Add(x.2788, y.2789)
// [KnfOpt] }
// [KnfOpt] let _2790: Int = Int(0)
// [KnfOpt] let join fold.2791: Int = (stream.2792: Fun([Unit], Tuple([Int, Int])), f.2793: Fun([Int, Int], Int), acc.2794: Int) {
// [KnfOpt]   let _2795: Unit = Unit
// [KnfOpt]   let _2796: Tuple([Int, Int]) = Apply(stream.2792, [_2795, ])
// [KnfOpt]   let (ok.2797: Var({val: Some(Int)}), val.2798: Var({val: Some(Int)})) = _2796
// [KnfOpt]   let _2799: Int = Int(0)
// [KnfOpt]   if (ok.2797 == _2799) then {
// [KnfOpt]     let sum.104: Int = Var(acc.2794)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _2800: Int = Apply(f.2793, [acc.2794, val.2798, ])
// [KnfOpt]     Jump(fold.2791, [stream.2792, f.2793, _2800, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.2791, [under1200.103, add.2787, _2790, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(le) let _102: Fun([Int], Int) = Unit
// [KnfOpt] let rec aux.2801: Tuple([Int, Int]) = (u.2802: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.2803: Tuple([Int, Int]) = (u.2804: Var({val: Some(Unit)})) {
// [KnfOpt]     let _2805: Unit = Unit
// [KnfOpt]     let _2806: Tuple([Int, Int]) = Apply(over50.100, [_2805, ])
// [KnfOpt]     let (ok.2807: Var({val: Some(Int)}), val.2808: Var({val: Some(Int)})) = _2806
// [KnfOpt]     let _2809: Int = Int(0)
// [KnfOpt]     if (ok.2807 == _2809) then {
// [KnfOpt]       let _2810: Int = Int(0)
// [KnfOpt]       let _2811: Int = Int(0)
// [KnfOpt]       Tuple([_2810, _2811, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.2812: Int = Apply(_102, [val.2808, ])
// [KnfOpt]       let _2813: Int = Int(0)
// [KnfOpt]       if (r.2812 == _2813) then {
// [KnfOpt]         let _2814: Int = Int(1)
// [KnfOpt]         Tuple([_2814, val.2808, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _2815: Unit = Unit
// [KnfOpt]         Jump(aux.2803, [_2815, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.2803, [u.2802, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.2801)
// [KnfOpt] let rec add.2816: Int = (x.2817: Int, y.2818: Int) {
// [KnfOpt]   Add(x.2817, y.2818)
// [KnfOpt] }
// [KnfOpt] let _2819: Int = Int(0)
// [KnfOpt] let join fold.2820: Int = (stream.2821: Fun([Unit], Tuple([Int, Int])), f.2822: Fun([Int, Int], Int), acc.2823: Int) {
// [KnfOpt]   let _2824: Unit = Unit
// [KnfOpt]   let _2825: Tuple([Int, Int]) = Apply(stream.2821, [_2824, ])
// [KnfOpt]   let (ok.2826: Var({val: Some(Int)}), val.2827: Var({val: Some(Int)})) = _2825
// [KnfOpt]   let _2828: Int = Int(0)
// [KnfOpt]   if (ok.2826 == _2828) then {
// [KnfOpt]     let sum.104: Int = Var(acc.2823)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _2829: Int = Apply(f.2822, [acc.2823, val.2827, ])
// [KnfOpt]     Jump(fold.2820, [stream.2821, f.2822, _2829, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.2820, [under1200.103, add.2816, _2819, ])
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.2832: Int = (x.2833: Int, y.2834: Int) {
// [KnfOpt]   Add(x.2833, y.2834)
// [KnfOpt] }
// [KnfOpt] let _2835: Int = Int(0)
// [KnfOpt] let join fold.2836: Int = (stream.2837: Fun([Unit], Tuple([Int, Int])), f.2838: Fun([Int, Int], Int), acc.2839: Int) {
// [KnfOpt]   let _2840: Unit = Unit
// [KnfOpt]   let _2841: Tuple([Int, Int]) = Apply(stream.2837, [_2840, ])
// [KnfOpt]   let (ok.2842: Var({val: Some(Int)}), val.2843: Var({val: Some(Int)})) = _2841
// [KnfOpt]   let _2844: Int = Int(0)
// [KnfOpt]   if (ok.2842 == _2844) then {
// [KnfOpt]     let sum.104: Int = Var(acc.2839)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _2845: Int = Apply(f.2838, [acc.2839, val.2843, ])
// [KnfOpt]     Jump(fold.2836, [stream.2837, f.2838, _2845, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.2836, [under1200.103, add.2832, _2835, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(map) let addone.97: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let _98: Int = Int(50)
// [KnfOpt] let rec aux.2682: Int = (y.2683: Int) {
// [KnfOpt]   if (_98 <= y.2683) then {
// [KnfOpt]     Int(0)
// [KnfOpt]   } else {
// [KnfOpt]     Int(1)
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] let _99: Fun([Int], Int) = Var(aux.2682)
// [KnfOpt] let rec aux.2772: Tuple([Int, Int]) = (u.2773: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.2774: Tuple([Int, Int]) = (u.2775: Var({val: Some(Unit)})) {
// [KnfOpt]     let _2776: Unit = Unit
// [KnfOpt]     let _2777: Tuple([Int, Int]) = Apply(addone.97, [_2776, ])
// [KnfOpt]     let (ok.2778: Var({val: Some(Int)}), val.2779: Var({val: Some(Int)})) = _2777
// [KnfOpt]     let _2780: Int = Int(0)
// [KnfOpt]     if (ok.2778 == _2780) then {
// [KnfOpt]       let _2781: Int = Int(0)
// [KnfOpt]       let _2782: Int = Int(0)
// [KnfOpt]       Tuple([_2781, _2782, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.2783: Int = Apply(_99, [val.2779, ])
// [KnfOpt]       let _2784: Int = Int(0)
// [KnfOpt]       if (r.2783 == _2784) then {
// [KnfOpt]         let _2785: Int = Int(1)
// [KnfOpt]         Tuple([_2785, val.2779, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _2786: Unit = Unit
// [KnfOpt]         Jump(aux.2774, [_2786, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.2774, [u.2773, ])
// [KnfOpt] }
// [KnfOpt] let over50.100: Fun([Unit], Tuple([Int, Int])) = Var(aux.2772)
// [KnfOpt] let _101: Int = Int(1200)
// [KnfOpt] let rec aux.2830: Int = (y.2831: Int) {
// [KnfOpt]   if (y.2831 <= _101) then {
// [KnfOpt]     Int(0)
// [KnfOpt]   } else {
// [KnfOpt]     Int(1)
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] let _102: Fun([Int], Int) = Var(aux.2830)
// [KnfOpt] let rec aux.2846: Tuple([Int, Int]) = (u.2847: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.2848: Tuple([Int, Int]) = (u.2849: Var({val: Some(Unit)})) {
// [KnfOpt]     let _2850: Unit = Unit
// [KnfOpt]     let _2851: Tuple([Int, Int]) = Apply(over50.100, [_2850, ])
// [KnfOpt]     let (ok.2852: Var({val: Some(Int)}), val.2853: Var({val: Some(Int)})) = _2851
// [KnfOpt]     let _2854: Int = Int(0)
// [KnfOpt]     if (ok.2852 == _2854) then {
// [KnfOpt]       let _2855: Int = Int(0)
// [KnfOpt]       let _2856: Int = Int(0)
// [KnfOpt]       Tuple([_2855, _2856, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.2857: Int = Apply(_102, [val.2853, ])
// [KnfOpt]       let _2858: Int = Int(0)
// [KnfOpt]       if (r.2857 == _2858) then {
// [KnfOpt]         let _2859: Int = Int(1)
// [KnfOpt]         Tuple([_2859, val.2853, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _2860: Unit = Unit
// [KnfOpt]         Jump(aux.2848, [_2860, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.2848, [u.2847, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.2846)
// [KnfOpt] let rec add.2861: Int = (x.2862: Int, y.2863: Int) {
// [KnfOpt]   Add(x.2862, y.2863)
// [KnfOpt] }
// [KnfOpt] let _2864: Int = Int(0)
// [KnfOpt] let join fold.2865: Int = (stream.2866: Fun([Unit], Tuple([Int, Int])), f.2867: Fun([Int, Int], Int), acc.2868: Int) {
// [KnfOpt]   let _2869: Unit = Unit
// [KnfOpt]   let _2870: Tuple([Int, Int]) = Apply(stream.2866, [_2869, ])
// [KnfOpt]   let (ok.2871: Var({val: Some(Int)}), val.2872: Var({val: Some(Int)})) = _2870
// [KnfOpt]   let _2873: Int = Int(0)
// [KnfOpt]   if (ok.2871 == _2873) then {
// [KnfOpt]     let sum.104: Int = Var(acc.2868)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _2874: Int = Apply(f.2867, [acc.2868, val.2872, ])
// [KnfOpt]     Jump(fold.2865, [stream.2866, f.2867, _2874, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.2865, [under1200.103, add.2861, _2864, ])
// [KnfOpt] Inline threshold 5
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 0
// [KnfOpt] Inline decision gt.79 accepted
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 5
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 0
// [KnfOpt] Inline decision le.83 accepted
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.2886: Int = (x.2887: Int, y.2888: Int) {
// [KnfOpt]   Add(x.2887, y.2888)
// [KnfOpt] }
// [KnfOpt] let _2889: Int = Int(0)
// [KnfOpt] let join fold.2890: Int = (stream.2891: Fun([Unit], Tuple([Int, Int])), f.2892: Fun([Int, Int], Int), acc.2893: Int) {
// [KnfOpt]   let _2894: Unit = Unit
// [KnfOpt]   let _2895: Tuple([Int, Int]) = Apply(stream.2891, [_2894, ])
// [KnfOpt]   let (ok.2896: Var({val: Some(Int)}), val.2897: Var({val: Some(Int)})) = _2895
// [KnfOpt]   let _2898: Int = Int(0)
// [KnfOpt]   if (ok.2896 == _2898) then {
// [KnfOpt]     let sum.104: Int = Var(acc.2893)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _2899: Int = Apply(f.2892, [acc.2893, val.2897, ])
// [KnfOpt]     Jump(fold.2890, [stream.2891, f.2892, _2899, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.2890, [under1200.103, add.2886, _2889, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(le) let _102: Fun([Int], Int) = Unit
// [KnfOpt] let rec aux.2900: Tuple([Int, Int]) = (u.2901: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.2902: Tuple([Int, Int]) = (u.2903: Var({val: Some(Unit)})) {
// [KnfOpt]     let _2904: Unit = Unit
// [KnfOpt]     let _2905: Tuple([Int, Int]) = Apply(over50.100, [_2904, ])
// [KnfOpt]     let (ok.2906: Var({val: Some(Int)}), val.2907: Var({val: Some(Int)})) = _2905
// [KnfOpt]     let _2908: Int = Int(0)
// [KnfOpt]     if (ok.2906 == _2908) then {
// [KnfOpt]       let _2909: Int = Int(0)
// [KnfOpt]       let _2910: Int = Int(0)
// [KnfOpt]       Tuple([_2909, _2910, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.2911: Int = Apply(_102, [val.2907, ])
// [KnfOpt]       let _2912: Int = Int(0)
// [KnfOpt]       if (r.2911 == _2912) then {
// [KnfOpt]         let _2913: Int = Int(1)
// [KnfOpt]         Tuple([_2913, val.2907, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _2914: Unit = Unit
// [KnfOpt]         Jump(aux.2902, [_2914, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.2902, [u.2901, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.2900)
// [KnfOpt] let rec add.2915: Int = (x.2916: Int, y.2917: Int) {
// [KnfOpt]   Add(x.2916, y.2917)
// [KnfOpt] }
// [KnfOpt] let _2918: Int = Int(0)
// [KnfOpt] let join fold.2919: Int = (stream.2920: Fun([Unit], Tuple([Int, Int])), f.2921: Fun([Int, Int], Int), acc.2922: Int) {
// [KnfOpt]   let _2923: Unit = Unit
// [KnfOpt]   let _2924: Tuple([Int, Int]) = Apply(stream.2920, [_2923, ])
// [KnfOpt]   let (ok.2925: Var({val: Some(Int)}), val.2926: Var({val: Some(Int)})) = _2924
// [KnfOpt]   let _2927: Int = Int(0)
// [KnfOpt]   if (ok.2925 == _2927) then {
// [KnfOpt]     let sum.104: Int = Var(acc.2922)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _2928: Int = Apply(f.2921, [acc.2922, val.2926, ])
// [KnfOpt]     Jump(fold.2919, [stream.2920, f.2921, _2928, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.2919, [under1200.103, add.2915, _2918, ])
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.2931: Int = (x.2932: Int, y.2933: Int) {
// [KnfOpt]   Add(x.2932, y.2933)
// [KnfOpt] }
// [KnfOpt] let _2934: Int = Int(0)
// [KnfOpt] let join fold.2935: Int = (stream.2936: Fun([Unit], Tuple([Int, Int])), f.2937: Fun([Int, Int], Int), acc.2938: Int) {
// [KnfOpt]   let _2939: Unit = Unit
// [KnfOpt]   let _2940: Tuple([Int, Int]) = Apply(stream.2936, [_2939, ])
// [KnfOpt]   let (ok.2941: Var({val: Some(Int)}), val.2942: Var({val: Some(Int)})) = _2940
// [KnfOpt]   let _2943: Int = Int(0)
// [KnfOpt]   if (ok.2941 == _2943) then {
// [KnfOpt]     let sum.104: Int = Var(acc.2938)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _2944: Int = Apply(f.2937, [acc.2938, val.2942, ])
// [KnfOpt]     Jump(fold.2935, [stream.2936, f.2937, _2944, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.2935, [under1200.103, add.2931, _2934, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let over50.100: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let _101: Int = Int(1200)
// [KnfOpt] let rec aux.2929: Int = (y.2930: Int) {
// [KnfOpt]   if (y.2930 <= _101) then {
// [KnfOpt]     Int(0)
// [KnfOpt]   } else {
// [KnfOpt]     Int(1)
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] let _102: Fun([Int], Int) = Var(aux.2929)
// [KnfOpt] let rec aux.2945: Tuple([Int, Int]) = (u.2946: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.2947: Tuple([Int, Int]) = (u.2948: Var({val: Some(Unit)})) {
// [KnfOpt]     let _2949: Unit = Unit
// [KnfOpt]     let _2950: Tuple([Int, Int]) = Apply(over50.100, [_2949, ])
// [KnfOpt]     let (ok.2951: Var({val: Some(Int)}), val.2952: Var({val: Some(Int)})) = _2950
// [KnfOpt]     let _2953: Int = Int(0)
// [KnfOpt]     if (ok.2951 == _2953) then {
// [KnfOpt]       let _2954: Int = Int(0)
// [KnfOpt]       let _2955: Int = Int(0)
// [KnfOpt]       Tuple([_2954, _2955, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.2956: Int = Apply(_102, [val.2952, ])
// [KnfOpt]       let _2957: Int = Int(0)
// [KnfOpt]       if (r.2956 == _2957) then {
// [KnfOpt]         let _2958: Int = Int(1)
// [KnfOpt]         Tuple([_2958, val.2952, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _2959: Unit = Unit
// [KnfOpt]         Jump(aux.2947, [_2959, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.2947, [u.2946, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.2945)
// [KnfOpt] let rec add.2960: Int = (x.2961: Int, y.2962: Int) {
// [KnfOpt]   Add(x.2961, y.2962)
// [KnfOpt] }
// [KnfOpt] let _2963: Int = Int(0)
// [KnfOpt] let join fold.2964: Int = (stream.2965: Fun([Unit], Tuple([Int, Int])), f.2966: Fun([Int, Int], Int), acc.2967: Int) {
// [KnfOpt]   let _2968: Unit = Unit
// [KnfOpt]   let _2969: Tuple([Int, Int]) = Apply(stream.2965, [_2968, ])
// [KnfOpt]   let (ok.2970: Var({val: Some(Int)}), val.2971: Var({val: Some(Int)})) = _2969
// [KnfOpt]   let _2972: Int = Int(0)
// [KnfOpt]   if (ok.2970 == _2972) then {
// [KnfOpt]     let sum.104: Int = Var(acc.2967)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _2973: Int = Apply(f.2966, [acc.2967, val.2971, ])
// [KnfOpt]     Jump(fold.2964, [stream.2965, f.2966, _2973, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.2964, [under1200.103, add.2960, _2963, ])
// [KnfOpt] Inline threshold 5
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 0
// [KnfOpt] Inline decision le.83 accepted
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.2989: Int = (x.2990: Int, y.2991: Int) {
// [KnfOpt]   Add(x.2990, y.2991)
// [KnfOpt] }
// [KnfOpt] let _2992: Int = Int(0)
// [KnfOpt] let join fold.2993: Int = (stream.2994: Fun([Unit], Tuple([Int, Int])), f.2995: Fun([Int, Int], Int), acc.2996: Int) {
// [KnfOpt]   let _2997: Unit = Unit
// [KnfOpt]   let _2998: Tuple([Int, Int]) = Apply(stream.2994, [_2997, ])
// [KnfOpt]   let (ok.2999: Var({val: Some(Int)}), val.3000: Var({val: Some(Int)})) = _2998
// [KnfOpt]   let _3001: Int = Int(0)
// [KnfOpt]   if (ok.2999 == _3001) then {
// [KnfOpt]     let sum.104: Int = Var(acc.2996)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _3002: Int = Apply(f.2995, [acc.2996, val.3000, ])
// [KnfOpt]     Jump(fold.2993, [stream.2994, f.2995, _3002, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.2993, [under1200.103, add.2989, _2992, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(le) let _102: Fun([Int], Int) = Unit
// [KnfOpt] let rec aux.3003: Tuple([Int, Int]) = (u.3004: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.3005: Tuple([Int, Int]) = (u.3006: Var({val: Some(Unit)})) {
// [KnfOpt]     let _3007: Unit = Unit
// [KnfOpt]     let _3008: Tuple([Int, Int]) = Apply(over50.100, [_3007, ])
// [KnfOpt]     let (ok.3009: Var({val: Some(Int)}), val.3010: Var({val: Some(Int)})) = _3008
// [KnfOpt]     let _3011: Int = Int(0)
// [KnfOpt]     if (ok.3009 == _3011) then {
// [KnfOpt]       let _3012: Int = Int(0)
// [KnfOpt]       let _3013: Int = Int(0)
// [KnfOpt]       Tuple([_3012, _3013, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.3014: Int = Apply(_102, [val.3010, ])
// [KnfOpt]       let _3015: Int = Int(0)
// [KnfOpt]       if (r.3014 == _3015) then {
// [KnfOpt]         let _3016: Int = Int(1)
// [KnfOpt]         Tuple([_3016, val.3010, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _3017: Unit = Unit
// [KnfOpt]         Jump(aux.3005, [_3017, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.3005, [u.3004, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.3003)
// [KnfOpt] let rec add.3018: Int = (x.3019: Int, y.3020: Int) {
// [KnfOpt]   Add(x.3019, y.3020)
// [KnfOpt] }
// [KnfOpt] let _3021: Int = Int(0)
// [KnfOpt] let join fold.3022: Int = (stream.3023: Fun([Unit], Tuple([Int, Int])), f.3024: Fun([Int, Int], Int), acc.3025: Int) {
// [KnfOpt]   let _3026: Unit = Unit
// [KnfOpt]   let _3027: Tuple([Int, Int]) = Apply(stream.3023, [_3026, ])
// [KnfOpt]   let (ok.3028: Var({val: Some(Int)}), val.3029: Var({val: Some(Int)})) = _3027
// [KnfOpt]   let _3030: Int = Int(0)
// [KnfOpt]   if (ok.3028 == _3030) then {
// [KnfOpt]     let sum.104: Int = Var(acc.3025)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _3031: Int = Apply(f.3024, [acc.3025, val.3029, ])
// [KnfOpt]     Jump(fold.3022, [stream.3023, f.3024, _3031, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.3022, [under1200.103, add.3018, _3021, ])
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.3034: Int = (x.3035: Int, y.3036: Int) {
// [KnfOpt]   Add(x.3035, y.3036)
// [KnfOpt] }
// [KnfOpt] let _3037: Int = Int(0)
// [KnfOpt] let join fold.3038: Int = (stream.3039: Fun([Unit], Tuple([Int, Int])), f.3040: Fun([Int, Int], Int), acc.3041: Int) {
// [KnfOpt]   let _3042: Unit = Unit
// [KnfOpt]   let _3043: Tuple([Int, Int]) = Apply(stream.3039, [_3042, ])
// [KnfOpt]   let (ok.3044: Var({val: Some(Int)}), val.3045: Var({val: Some(Int)})) = _3043
// [KnfOpt]   let _3046: Int = Int(0)
// [KnfOpt]   if (ok.3044 == _3046) then {
// [KnfOpt]     let sum.104: Int = Var(acc.3041)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _3047: Int = Apply(f.3040, [acc.3041, val.3045, ])
// [KnfOpt]     Jump(fold.3038, [stream.3039, f.3040, _3047, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.3038, [under1200.103, add.3034, _3037, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(gt) let _99: Fun([Int], Int) = Unit
// [KnfOpt] let rec aux.2974: Tuple([Int, Int]) = (u.2975: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.2976: Tuple([Int, Int]) = (u.2977: Var({val: Some(Unit)})) {
// [KnfOpt]     let _2978: Unit = Unit
// [KnfOpt]     let _2979: Tuple([Int, Int]) = Apply(addone.97, [_2978, ])
// [KnfOpt]     let (ok.2980: Var({val: Some(Int)}), val.2981: Var({val: Some(Int)})) = _2979
// [KnfOpt]     let _2982: Int = Int(0)
// [KnfOpt]     if (ok.2980 == _2982) then {
// [KnfOpt]       let _2983: Int = Int(0)
// [KnfOpt]       let _2984: Int = Int(0)
// [KnfOpt]       Tuple([_2983, _2984, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.2985: Int = Apply(_99, [val.2981, ])
// [KnfOpt]       let _2986: Int = Int(0)
// [KnfOpt]       if (r.2985 == _2986) then {
// [KnfOpt]         let _2987: Int = Int(1)
// [KnfOpt]         Tuple([_2987, val.2981, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _2988: Unit = Unit
// [KnfOpt]         Jump(aux.2976, [_2988, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.2976, [u.2975, ])
// [KnfOpt] }
// [KnfOpt] let over50.100: Fun([Unit], Tuple([Int, Int])) = Var(aux.2974)
// [KnfOpt] let _101: Int = Int(1200)
// [KnfOpt] let rec aux.3032: Int = (y.3033: Int) {
// [KnfOpt]   if (y.3033 <= _101) then {
// [KnfOpt]     Int(0)
// [KnfOpt]   } else {
// [KnfOpt]     Int(1)
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] let _102: Fun([Int], Int) = Var(aux.3032)
// [KnfOpt] let rec aux.3048: Tuple([Int, Int]) = (u.3049: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.3050: Tuple([Int, Int]) = (u.3051: Var({val: Some(Unit)})) {
// [KnfOpt]     let _3052: Unit = Unit
// [KnfOpt]     let _3053: Tuple([Int, Int]) = Apply(over50.100, [_3052, ])
// [KnfOpt]     let (ok.3054: Var({val: Some(Int)}), val.3055: Var({val: Some(Int)})) = _3053
// [KnfOpt]     let _3056: Int = Int(0)
// [KnfOpt]     if (ok.3054 == _3056) then {
// [KnfOpt]       let _3057: Int = Int(0)
// [KnfOpt]       let _3058: Int = Int(0)
// [KnfOpt]       Tuple([_3057, _3058, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.3059: Int = Apply(_102, [val.3055, ])
// [KnfOpt]       let _3060: Int = Int(0)
// [KnfOpt]       if (r.3059 == _3060) then {
// [KnfOpt]         let _3061: Int = Int(1)
// [KnfOpt]         Tuple([_3061, val.3055, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _3062: Unit = Unit
// [KnfOpt]         Jump(aux.3050, [_3062, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.3050, [u.3049, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.3048)
// [KnfOpt] let rec add.3063: Int = (x.3064: Int, y.3065: Int) {
// [KnfOpt]   Add(x.3064, y.3065)
// [KnfOpt] }
// [KnfOpt] let _3066: Int = Int(0)
// [KnfOpt] let join fold.3067: Int = (stream.3068: Fun([Unit], Tuple([Int, Int])), f.3069: Fun([Int, Int], Int), acc.3070: Int) {
// [KnfOpt]   let _3071: Unit = Unit
// [KnfOpt]   let _3072: Tuple([Int, Int]) = Apply(stream.3068, [_3071, ])
// [KnfOpt]   let (ok.3073: Var({val: Some(Int)}), val.3074: Var({val: Some(Int)})) = _3072
// [KnfOpt]   let _3075: Int = Int(0)
// [KnfOpt]   if (ok.3073 == _3075) then {
// [KnfOpt]     let sum.104: Int = Var(acc.3070)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _3076: Int = Apply(f.3069, [acc.3070, val.3074, ])
// [KnfOpt]     Jump(fold.3067, [stream.3068, f.3069, _3076, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.3067, [under1200.103, add.3063, _3066, ])
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 5
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 0
// [KnfOpt] Inline decision le.83 accepted
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.3079: Int = (x.3080: Int, y.3081: Int) {
// [KnfOpt]   Add(x.3080, y.3081)
// [KnfOpt] }
// [KnfOpt] let _3082: Int = Int(0)
// [KnfOpt] let join fold.3083: Int = (stream.3084: Fun([Unit], Tuple([Int, Int])), f.3085: Fun([Int, Int], Int), acc.3086: Int) {
// [KnfOpt]   let _3087: Unit = Unit
// [KnfOpt]   let _3088: Tuple([Int, Int]) = Apply(stream.3084, [_3087, ])
// [KnfOpt]   let (ok.3089: Var({val: Some(Int)}), val.3090: Var({val: Some(Int)})) = _3088
// [KnfOpt]   let _3091: Int = Int(0)
// [KnfOpt]   if (ok.3089 == _3091) then {
// [KnfOpt]     let sum.104: Int = Var(acc.3086)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _3092: Int = Apply(f.3085, [acc.3086, val.3090, ])
// [KnfOpt]     Jump(fold.3083, [stream.3084, f.3085, _3092, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.3083, [under1200.103, add.3079, _3082, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(le) let _102: Fun([Int], Int) = Unit
// [KnfOpt] let rec aux.3093: Tuple([Int, Int]) = (u.3094: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.3095: Tuple([Int, Int]) = (u.3096: Var({val: Some(Unit)})) {
// [KnfOpt]     let _3097: Unit = Unit
// [KnfOpt]     let _3098: Tuple([Int, Int]) = Apply(over50.100, [_3097, ])
// [KnfOpt]     let (ok.3099: Var({val: Some(Int)}), val.3100: Var({val: Some(Int)})) = _3098
// [KnfOpt]     let _3101: Int = Int(0)
// [KnfOpt]     if (ok.3099 == _3101) then {
// [KnfOpt]       let _3102: Int = Int(0)
// [KnfOpt]       let _3103: Int = Int(0)
// [KnfOpt]       Tuple([_3102, _3103, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.3104: Int = Apply(_102, [val.3100, ])
// [KnfOpt]       let _3105: Int = Int(0)
// [KnfOpt]       if (r.3104 == _3105) then {
// [KnfOpt]         let _3106: Int = Int(1)
// [KnfOpt]         Tuple([_3106, val.3100, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _3107: Unit = Unit
// [KnfOpt]         Jump(aux.3095, [_3107, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.3095, [u.3094, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.3093)
// [KnfOpt] let rec add.3108: Int = (x.3109: Int, y.3110: Int) {
// [KnfOpt]   Add(x.3109, y.3110)
// [KnfOpt] }
// [KnfOpt] let _3111: Int = Int(0)
// [KnfOpt] let join fold.3112: Int = (stream.3113: Fun([Unit], Tuple([Int, Int])), f.3114: Fun([Int, Int], Int), acc.3115: Int) {
// [KnfOpt]   let _3116: Unit = Unit
// [KnfOpt]   let _3117: Tuple([Int, Int]) = Apply(stream.3113, [_3116, ])
// [KnfOpt]   let (ok.3118: Var({val: Some(Int)}), val.3119: Var({val: Some(Int)})) = _3117
// [KnfOpt]   let _3120: Int = Int(0)
// [KnfOpt]   if (ok.3118 == _3120) then {
// [KnfOpt]     let sum.104: Int = Var(acc.3115)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _3121: Int = Apply(f.3114, [acc.3115, val.3119, ])
// [KnfOpt]     Jump(fold.3112, [stream.3113, f.3114, _3121, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.3112, [under1200.103, add.3108, _3111, ])
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.3124: Int = (x.3125: Int, y.3126: Int) {
// [KnfOpt]   Add(x.3125, y.3126)
// [KnfOpt] }
// [KnfOpt] let _3127: Int = Int(0)
// [KnfOpt] let join fold.3128: Int = (stream.3129: Fun([Unit], Tuple([Int, Int])), f.3130: Fun([Int, Int], Int), acc.3131: Int) {
// [KnfOpt]   let _3132: Unit = Unit
// [KnfOpt]   let _3133: Tuple([Int, Int]) = Apply(stream.3129, [_3132, ])
// [KnfOpt]   let (ok.3134: Var({val: Some(Int)}), val.3135: Var({val: Some(Int)})) = _3133
// [KnfOpt]   let _3136: Int = Int(0)
// [KnfOpt]   if (ok.3134 == _3136) then {
// [KnfOpt]     let sum.104: Int = Var(acc.3131)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _3137: Int = Apply(f.3130, [acc.3131, val.3135, ])
// [KnfOpt]     Jump(fold.3128, [stream.3129, f.3130, _3137, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.3128, [under1200.103, add.3124, _3127, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let over50.100: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let _101: Int = Int(1200)
// [KnfOpt] let rec aux.3122: Int = (y.3123: Int) {
// [KnfOpt]   if (y.3123 <= _101) then {
// [KnfOpt]     Int(0)
// [KnfOpt]   } else {
// [KnfOpt]     Int(1)
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] let _102: Fun([Int], Int) = Var(aux.3122)
// [KnfOpt] let rec aux.3138: Tuple([Int, Int]) = (u.3139: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.3140: Tuple([Int, Int]) = (u.3141: Var({val: Some(Unit)})) {
// [KnfOpt]     let _3142: Unit = Unit
// [KnfOpt]     let _3143: Tuple([Int, Int]) = Apply(over50.100, [_3142, ])
// [KnfOpt]     let (ok.3144: Var({val: Some(Int)}), val.3145: Var({val: Some(Int)})) = _3143
// [KnfOpt]     let _3146: Int = Int(0)
// [KnfOpt]     if (ok.3144 == _3146) then {
// [KnfOpt]       let _3147: Int = Int(0)
// [KnfOpt]       let _3148: Int = Int(0)
// [KnfOpt]       Tuple([_3147, _3148, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.3149: Int = Apply(_102, [val.3145, ])
// [KnfOpt]       let _3150: Int = Int(0)
// [KnfOpt]       if (r.3149 == _3150) then {
// [KnfOpt]         let _3151: Int = Int(1)
// [KnfOpt]         Tuple([_3151, val.3145, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _3152: Unit = Unit
// [KnfOpt]         Jump(aux.3140, [_3152, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.3140, [u.3139, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.3138)
// [KnfOpt] let rec add.3153: Int = (x.3154: Int, y.3155: Int) {
// [KnfOpt]   Add(x.3154, y.3155)
// [KnfOpt] }
// [KnfOpt] let _3156: Int = Int(0)
// [KnfOpt] let join fold.3157: Int = (stream.3158: Fun([Unit], Tuple([Int, Int])), f.3159: Fun([Int, Int], Int), acc.3160: Int) {
// [KnfOpt]   let _3161: Unit = Unit
// [KnfOpt]   let _3162: Tuple([Int, Int]) = Apply(stream.3158, [_3161, ])
// [KnfOpt]   let (ok.3163: Var({val: Some(Int)}), val.3164: Var({val: Some(Int)})) = _3162
// [KnfOpt]   let _3165: Int = Int(0)
// [KnfOpt]   if (ok.3163 == _3165) then {
// [KnfOpt]     let sum.104: Int = Var(acc.3160)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _3166: Int = Apply(f.3159, [acc.3160, val.3164, ])
// [KnfOpt]     Jump(fold.3157, [stream.3158, f.3159, _3166, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.3157, [under1200.103, add.3153, _3156, ])
// [KnfOpt] Inline threshold 5
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 0
// [KnfOpt] Inline decision le.83 accepted
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.3182: Int = (x.3183: Int, y.3184: Int) {
// [KnfOpt]   Add(x.3183, y.3184)
// [KnfOpt] }
// [KnfOpt] let _3185: Int = Int(0)
// [KnfOpt] let join fold.3186: Int = (stream.3187: Fun([Unit], Tuple([Int, Int])), f.3188: Fun([Int, Int], Int), acc.3189: Int) {
// [KnfOpt]   let _3190: Unit = Unit
// [KnfOpt]   let _3191: Tuple([Int, Int]) = Apply(stream.3187, [_3190, ])
// [KnfOpt]   let (ok.3192: Var({val: Some(Int)}), val.3193: Var({val: Some(Int)})) = _3191
// [KnfOpt]   let _3194: Int = Int(0)
// [KnfOpt]   if (ok.3192 == _3194) then {
// [KnfOpt]     let sum.104: Int = Var(acc.3189)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _3195: Int = Apply(f.3188, [acc.3189, val.3193, ])
// [KnfOpt]     Jump(fold.3186, [stream.3187, f.3188, _3195, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.3186, [under1200.103, add.3182, _3185, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(le) let _102: Fun([Int], Int) = Unit
// [KnfOpt] let rec aux.3196: Tuple([Int, Int]) = (u.3197: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.3198: Tuple([Int, Int]) = (u.3199: Var({val: Some(Unit)})) {
// [KnfOpt]     let _3200: Unit = Unit
// [KnfOpt]     let _3201: Tuple([Int, Int]) = Apply(over50.100, [_3200, ])
// [KnfOpt]     let (ok.3202: Var({val: Some(Int)}), val.3203: Var({val: Some(Int)})) = _3201
// [KnfOpt]     let _3204: Int = Int(0)
// [KnfOpt]     if (ok.3202 == _3204) then {
// [KnfOpt]       let _3205: Int = Int(0)
// [KnfOpt]       let _3206: Int = Int(0)
// [KnfOpt]       Tuple([_3205, _3206, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.3207: Int = Apply(_102, [val.3203, ])
// [KnfOpt]       let _3208: Int = Int(0)
// [KnfOpt]       if (r.3207 == _3208) then {
// [KnfOpt]         let _3209: Int = Int(1)
// [KnfOpt]         Tuple([_3209, val.3203, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _3210: Unit = Unit
// [KnfOpt]         Jump(aux.3198, [_3210, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.3198, [u.3197, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.3196)
// [KnfOpt] let rec add.3211: Int = (x.3212: Int, y.3213: Int) {
// [KnfOpt]   Add(x.3212, y.3213)
// [KnfOpt] }
// [KnfOpt] let _3214: Int = Int(0)
// [KnfOpt] let join fold.3215: Int = (stream.3216: Fun([Unit], Tuple([Int, Int])), f.3217: Fun([Int, Int], Int), acc.3218: Int) {
// [KnfOpt]   let _3219: Unit = Unit
// [KnfOpt]   let _3220: Tuple([Int, Int]) = Apply(stream.3216, [_3219, ])
// [KnfOpt]   let (ok.3221: Var({val: Some(Int)}), val.3222: Var({val: Some(Int)})) = _3220
// [KnfOpt]   let _3223: Int = Int(0)
// [KnfOpt]   if (ok.3221 == _3223) then {
// [KnfOpt]     let sum.104: Int = Var(acc.3218)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _3224: Int = Apply(f.3217, [acc.3218, val.3222, ])
// [KnfOpt]     Jump(fold.3215, [stream.3216, f.3217, _3224, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.3215, [under1200.103, add.3211, _3214, ])
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.3227: Int = (x.3228: Int, y.3229: Int) {
// [KnfOpt]   Add(x.3228, y.3229)
// [KnfOpt] }
// [KnfOpt] let _3230: Int = Int(0)
// [KnfOpt] let join fold.3231: Int = (stream.3232: Fun([Unit], Tuple([Int, Int])), f.3233: Fun([Int, Int], Int), acc.3234: Int) {
// [KnfOpt]   let _3235: Unit = Unit
// [KnfOpt]   let _3236: Tuple([Int, Int]) = Apply(stream.3232, [_3235, ])
// [KnfOpt]   let (ok.3237: Var({val: Some(Int)}), val.3238: Var({val: Some(Int)})) = _3236
// [KnfOpt]   let _3239: Int = Int(0)
// [KnfOpt]   if (ok.3237 == _3239) then {
// [KnfOpt]     let sum.104: Int = Var(acc.3234)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _3240: Int = Apply(f.3233, [acc.3234, val.3238, ])
// [KnfOpt]     Jump(fold.3231, [stream.3232, f.3233, _3240, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.3231, [under1200.103, add.3227, _3230, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(range) let range1000.93: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec aux.1701: Tuple([Int, Int]) = (u.1702: Var({val: Some(Unit)})) {
// [KnfOpt]   let _1703: Unit = Unit
// [KnfOpt]   let _1704: Tuple([Int, Int]) = Apply(range100.90, [_1703, ])
// [KnfOpt]   let (ok.1705: Var({val: Some(Int)}), val.1706: Var({val: Some(Int)})) = _1704
// [KnfOpt]   let _1707: Int = Int(0)
// [KnfOpt]   if (ok.1705 == _1707) then {
// [KnfOpt]     let _1708: Unit = Unit
// [KnfOpt]     Apply(range1000.93, [_1708, ])
// [KnfOpt]   } else {
// [KnfOpt]     let _1709: Int = Int(1)
// [KnfOpt]     Tuple([_1709, val.1706, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] let catt.94: Fun([Unit], Tuple([Int, Int])) = Var(aux.1701)
// [KnfOpt] let _95: Int = Int(1)
// [KnfOpt] let rec aux.2489: Int = (y.2490: Int) {
// [KnfOpt]   Add(_95, y.2490)
// [KnfOpt] }
// [KnfOpt] let _96: Fun([Int], Int) = Var(aux.2489)
// [KnfOpt] let rec aux.2875: Tuple([Int, Int]) = (u.2876: Var({val: Some(Unit)})) {
// [KnfOpt]   let _2877: Unit = Unit
// [KnfOpt]   let _2878: Tuple([Int, Int]) = Apply(catt.94, [_2877, ])
// [KnfOpt]   let (ok.2879: Var({val: Some(Int)}), val.2880: Var({val: Some(Int)})) = _2878
// [KnfOpt]   let _2881: Int = Int(0)
// [KnfOpt]   if (ok.2879 == _2881) then {
// [KnfOpt]     let _2882: Int = Int(0)
// [KnfOpt]     let _2883: Int = Int(0)
// [KnfOpt]     Tuple([_2882, _2883, ])
// [KnfOpt]   } else {
// [KnfOpt]     let _2884: Int = Int(1)
// [KnfOpt]     let _2885: Int = Apply(_96, [val.2880, ])
// [KnfOpt]     Tuple([_2884, _2885, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] let addone.97: Fun([Unit], Tuple([Int, Int])) = Var(aux.2875)
// [KnfOpt] let _98: Int = Int(50)
// [KnfOpt] let rec aux.3077: Int = (y.3078: Int) {
// [KnfOpt]   if (_98 <= y.3078) then {
// [KnfOpt]     Int(0)
// [KnfOpt]   } else {
// [KnfOpt]     Int(1)
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] let _99: Fun([Int], Int) = Var(aux.3077)
// [KnfOpt] let rec aux.3167: Tuple([Int, Int]) = (u.3168: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.3169: Tuple([Int, Int]) = (u.3170: Var({val: Some(Unit)})) {
// [KnfOpt]     let _3171: Unit = Unit
// [KnfOpt]     let _3172: Tuple([Int, Int]) = Apply(addone.97, [_3171, ])
// [KnfOpt]     let (ok.3173: Var({val: Some(Int)}), val.3174: Var({val: Some(Int)})) = _3172
// [KnfOpt]     let _3175: Int = Int(0)
// [KnfOpt]     if (ok.3173 == _3175) then {
// [KnfOpt]       let _3176: Int = Int(0)
// [KnfOpt]       let _3177: Int = Int(0)
// [KnfOpt]       Tuple([_3176, _3177, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.3178: Int = Apply(_99, [val.3174, ])
// [KnfOpt]       let _3179: Int = Int(0)
// [KnfOpt]       if (r.3178 == _3179) then {
// [KnfOpt]         let _3180: Int = Int(1)
// [KnfOpt]         Tuple([_3180, val.3174, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _3181: Unit = Unit
// [KnfOpt]         Jump(aux.3169, [_3181, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.3169, [u.3168, ])
// [KnfOpt] }
// [KnfOpt] let over50.100: Fun([Unit], Tuple([Int, Int])) = Var(aux.3167)
// [KnfOpt] let _101: Int = Int(1200)
// [KnfOpt] let rec aux.3225: Int = (y.3226: Int) {
// [KnfOpt]   if (y.3226 <= _101) then {
// [KnfOpt]     Int(0)
// [KnfOpt]   } else {
// [KnfOpt]     Int(1)
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] let _102: Fun([Int], Int) = Var(aux.3225)
// [KnfOpt] let rec aux.3241: Tuple([Int, Int]) = (u.3242: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.3243: Tuple([Int, Int]) = (u.3244: Var({val: Some(Unit)})) {
// [KnfOpt]     let _3245: Unit = Unit
// [KnfOpt]     let _3246: Tuple([Int, Int]) = Apply(over50.100, [_3245, ])
// [KnfOpt]     let (ok.3247: Var({val: Some(Int)}), val.3248: Var({val: Some(Int)})) = _3246
// [KnfOpt]     let _3249: Int = Int(0)
// [KnfOpt]     if (ok.3247 == _3249) then {
// [KnfOpt]       let _3250: Int = Int(0)
// [KnfOpt]       let _3251: Int = Int(0)
// [KnfOpt]       Tuple([_3250, _3251, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.3252: Int = Apply(_102, [val.3248, ])
// [KnfOpt]       let _3253: Int = Int(0)
// [KnfOpt]       if (r.3252 == _3253) then {
// [KnfOpt]         let _3254: Int = Int(1)
// [KnfOpt]         Tuple([_3254, val.3248, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _3255: Unit = Unit
// [KnfOpt]         Jump(aux.3243, [_3255, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.3243, [u.3242, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.3241)
// [KnfOpt] let rec add.3256: Int = (x.3257: Int, y.3258: Int) {
// [KnfOpt]   Add(x.3257, y.3258)
// [KnfOpt] }
// [KnfOpt] let _3259: Int = Int(0)
// [KnfOpt] let join fold.3260: Int = (stream.3261: Fun([Unit], Tuple([Int, Int])), f.3262: Fun([Int, Int], Int), acc.3263: Int) {
// [KnfOpt]   let _3264: Unit = Unit
// [KnfOpt]   let _3265: Tuple([Int, Int]) = Apply(stream.3261, [_3264, ])
// [KnfOpt]   let (ok.3266: Var({val: Some(Int)}), val.3267: Var({val: Some(Int)})) = _3265
// [KnfOpt]   let _3268: Int = Int(0)
// [KnfOpt]   if (ok.3266 == _3268) then {
// [KnfOpt]     let sum.104: Int = Var(acc.3263)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _3269: Int = Apply(f.3262, [acc.3263, val.3267, ])
// [KnfOpt]     Jump(fold.3260, [stream.3261, f.3262, _3269, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.3260, [under1200.103, add.3256, _3259, ])
// [KnfOpt] Inline threshold 16
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 0
// [KnfOpt] Inline decision concat.31 accepted
// [KnfOpt] Inline threshold 3
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 0
// [KnfOpt] Inline decision addx.59 accepted
// [KnfOpt] Inline threshold 20
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 0
// [KnfOpt] Inline decision map.1 accepted
// [KnfOpt] Inline threshold 5
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 0
// [KnfOpt] Inline decision gt.79 accepted
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 5
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 0
// [KnfOpt] Inline decision le.83 accepted
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.3283: Int = (x.3284: Int, y.3285: Int) {
// [KnfOpt]   Add(x.3284, y.3285)
// [KnfOpt] }
// [KnfOpt] let _3286: Int = Int(0)
// [KnfOpt] let join fold.3287: Int = (stream.3288: Fun([Unit], Tuple([Int, Int])), f.3289: Fun([Int, Int], Int), acc.3290: Int) {
// [KnfOpt]   let _3291: Unit = Unit
// [KnfOpt]   let _3292: Tuple([Int, Int]) = Apply(stream.3288, [_3291, ])
// [KnfOpt]   let (ok.3293: Var({val: Some(Int)}), val.3294: Var({val: Some(Int)})) = _3292
// [KnfOpt]   let _3295: Int = Int(0)
// [KnfOpt]   if (ok.3293 == _3295) then {
// [KnfOpt]     let sum.104: Int = Var(acc.3290)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _3296: Int = Apply(f.3289, [acc.3290, val.3294, ])
// [KnfOpt]     Jump(fold.3287, [stream.3288, f.3289, _3296, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.3287, [under1200.103, add.3283, _3286, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(le) let _102: Fun([Int], Int) = Unit
// [KnfOpt] let rec aux.3297: Tuple([Int, Int]) = (u.3298: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.3299: Tuple([Int, Int]) = (u.3300: Var({val: Some(Unit)})) {
// [KnfOpt]     let _3301: Unit = Unit
// [KnfOpt]     let _3302: Tuple([Int, Int]) = Apply(over50.100, [_3301, ])
// [KnfOpt]     let (ok.3303: Var({val: Some(Int)}), val.3304: Var({val: Some(Int)})) = _3302
// [KnfOpt]     let _3305: Int = Int(0)
// [KnfOpt]     if (ok.3303 == _3305) then {
// [KnfOpt]       let _3306: Int = Int(0)
// [KnfOpt]       let _3307: Int = Int(0)
// [KnfOpt]       Tuple([_3306, _3307, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.3308: Int = Apply(_102, [val.3304, ])
// [KnfOpt]       let _3309: Int = Int(0)
// [KnfOpt]       if (r.3308 == _3309) then {
// [KnfOpt]         let _3310: Int = Int(1)
// [KnfOpt]         Tuple([_3310, val.3304, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _3311: Unit = Unit
// [KnfOpt]         Jump(aux.3299, [_3311, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.3299, [u.3298, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.3297)
// [KnfOpt] let rec add.3312: Int = (x.3313: Int, y.3314: Int) {
// [KnfOpt]   Add(x.3313, y.3314)
// [KnfOpt] }
// [KnfOpt] let _3315: Int = Int(0)
// [KnfOpt] let join fold.3316: Int = (stream.3317: Fun([Unit], Tuple([Int, Int])), f.3318: Fun([Int, Int], Int), acc.3319: Int) {
// [KnfOpt]   let _3320: Unit = Unit
// [KnfOpt]   let _3321: Tuple([Int, Int]) = Apply(stream.3317, [_3320, ])
// [KnfOpt]   let (ok.3322: Var({val: Some(Int)}), val.3323: Var({val: Some(Int)})) = _3321
// [KnfOpt]   let _3324: Int = Int(0)
// [KnfOpt]   if (ok.3322 == _3324) then {
// [KnfOpt]     let sum.104: Int = Var(acc.3319)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _3325: Int = Apply(f.3318, [acc.3319, val.3323, ])
// [KnfOpt]     Jump(fold.3316, [stream.3317, f.3318, _3325, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.3316, [under1200.103, add.3312, _3315, ])
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.3328: Int = (x.3329: Int, y.3330: Int) {
// [KnfOpt]   Add(x.3329, y.3330)
// [KnfOpt] }
// [KnfOpt] let _3331: Int = Int(0)
// [KnfOpt] let join fold.3332: Int = (stream.3333: Fun([Unit], Tuple([Int, Int])), f.3334: Fun([Int, Int], Int), acc.3335: Int) {
// [KnfOpt]   let _3336: Unit = Unit
// [KnfOpt]   let _3337: Tuple([Int, Int]) = Apply(stream.3333, [_3336, ])
// [KnfOpt]   let (ok.3338: Var({val: Some(Int)}), val.3339: Var({val: Some(Int)})) = _3337
// [KnfOpt]   let _3340: Int = Int(0)
// [KnfOpt]   if (ok.3338 == _3340) then {
// [KnfOpt]     let sum.104: Int = Var(acc.3335)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _3341: Int = Apply(f.3334, [acc.3335, val.3339, ])
// [KnfOpt]     Jump(fold.3332, [stream.3333, f.3334, _3341, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.3332, [under1200.103, add.3328, _3331, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let over50.100: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let _101: Int = Int(1200)
// [KnfOpt] let rec aux.3326: Int = (y.3327: Int) {
// [KnfOpt]   if (y.3327 <= _101) then {
// [KnfOpt]     Int(0)
// [KnfOpt]   } else {
// [KnfOpt]     Int(1)
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] let _102: Fun([Int], Int) = Var(aux.3326)
// [KnfOpt] let rec aux.3342: Tuple([Int, Int]) = (u.3343: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.3344: Tuple([Int, Int]) = (u.3345: Var({val: Some(Unit)})) {
// [KnfOpt]     let _3346: Unit = Unit
// [KnfOpt]     let _3347: Tuple([Int, Int]) = Apply(over50.100, [_3346, ])
// [KnfOpt]     let (ok.3348: Var({val: Some(Int)}), val.3349: Var({val: Some(Int)})) = _3347
// [KnfOpt]     let _3350: Int = Int(0)
// [KnfOpt]     if (ok.3348 == _3350) then {
// [KnfOpt]       let _3351: Int = Int(0)
// [KnfOpt]       let _3352: Int = Int(0)
// [KnfOpt]       Tuple([_3351, _3352, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.3353: Int = Apply(_102, [val.3349, ])
// [KnfOpt]       let _3354: Int = Int(0)
// [KnfOpt]       if (r.3353 == _3354) then {
// [KnfOpt]         let _3355: Int = Int(1)
// [KnfOpt]         Tuple([_3355, val.3349, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _3356: Unit = Unit
// [KnfOpt]         Jump(aux.3344, [_3356, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.3344, [u.3343, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.3342)
// [KnfOpt] let rec add.3357: Int = (x.3358: Int, y.3359: Int) {
// [KnfOpt]   Add(x.3358, y.3359)
// [KnfOpt] }
// [KnfOpt] let _3360: Int = Int(0)
// [KnfOpt] let join fold.3361: Int = (stream.3362: Fun([Unit], Tuple([Int, Int])), f.3363: Fun([Int, Int], Int), acc.3364: Int) {
// [KnfOpt]   let _3365: Unit = Unit
// [KnfOpt]   let _3366: Tuple([Int, Int]) = Apply(stream.3362, [_3365, ])
// [KnfOpt]   let (ok.3367: Var({val: Some(Int)}), val.3368: Var({val: Some(Int)})) = _3366
// [KnfOpt]   let _3369: Int = Int(0)
// [KnfOpt]   if (ok.3367 == _3369) then {
// [KnfOpt]     let sum.104: Int = Var(acc.3364)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _3370: Int = Apply(f.3363, [acc.3364, val.3368, ])
// [KnfOpt]     Jump(fold.3361, [stream.3362, f.3363, _3370, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.3361, [under1200.103, add.3357, _3360, ])
// [KnfOpt] Inline threshold 5
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 0
// [KnfOpt] Inline decision le.83 accepted
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.3386: Int = (x.3387: Int, y.3388: Int) {
// [KnfOpt]   Add(x.3387, y.3388)
// [KnfOpt] }
// [KnfOpt] let _3389: Int = Int(0)
// [KnfOpt] let join fold.3390: Int = (stream.3391: Fun([Unit], Tuple([Int, Int])), f.3392: Fun([Int, Int], Int), acc.3393: Int) {
// [KnfOpt]   let _3394: Unit = Unit
// [KnfOpt]   let _3395: Tuple([Int, Int]) = Apply(stream.3391, [_3394, ])
// [KnfOpt]   let (ok.3396: Var({val: Some(Int)}), val.3397: Var({val: Some(Int)})) = _3395
// [KnfOpt]   let _3398: Int = Int(0)
// [KnfOpt]   if (ok.3396 == _3398) then {
// [KnfOpt]     let sum.104: Int = Var(acc.3393)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _3399: Int = Apply(f.3392, [acc.3393, val.3397, ])
// [KnfOpt]     Jump(fold.3390, [stream.3391, f.3392, _3399, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.3390, [under1200.103, add.3386, _3389, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(le) let _102: Fun([Int], Int) = Unit
// [KnfOpt] let rec aux.3400: Tuple([Int, Int]) = (u.3401: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.3402: Tuple([Int, Int]) = (u.3403: Var({val: Some(Unit)})) {
// [KnfOpt]     let _3404: Unit = Unit
// [KnfOpt]     let _3405: Tuple([Int, Int]) = Apply(over50.100, [_3404, ])
// [KnfOpt]     let (ok.3406: Var({val: Some(Int)}), val.3407: Var({val: Some(Int)})) = _3405
// [KnfOpt]     let _3408: Int = Int(0)
// [KnfOpt]     if (ok.3406 == _3408) then {
// [KnfOpt]       let _3409: Int = Int(0)
// [KnfOpt]       let _3410: Int = Int(0)
// [KnfOpt]       Tuple([_3409, _3410, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.3411: Int = Apply(_102, [val.3407, ])
// [KnfOpt]       let _3412: Int = Int(0)
// [KnfOpt]       if (r.3411 == _3412) then {
// [KnfOpt]         let _3413: Int = Int(1)
// [KnfOpt]         Tuple([_3413, val.3407, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _3414: Unit = Unit
// [KnfOpt]         Jump(aux.3402, [_3414, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.3402, [u.3401, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.3400)
// [KnfOpt] let rec add.3415: Int = (x.3416: Int, y.3417: Int) {
// [KnfOpt]   Add(x.3416, y.3417)
// [KnfOpt] }
// [KnfOpt] let _3418: Int = Int(0)
// [KnfOpt] let join fold.3419: Int = (stream.3420: Fun([Unit], Tuple([Int, Int])), f.3421: Fun([Int, Int], Int), acc.3422: Int) {
// [KnfOpt]   let _3423: Unit = Unit
// [KnfOpt]   let _3424: Tuple([Int, Int]) = Apply(stream.3420, [_3423, ])
// [KnfOpt]   let (ok.3425: Var({val: Some(Int)}), val.3426: Var({val: Some(Int)})) = _3424
// [KnfOpt]   let _3427: Int = Int(0)
// [KnfOpt]   if (ok.3425 == _3427) then {
// [KnfOpt]     let sum.104: Int = Var(acc.3422)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _3428: Int = Apply(f.3421, [acc.3422, val.3426, ])
// [KnfOpt]     Jump(fold.3419, [stream.3420, f.3421, _3428, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.3419, [under1200.103, add.3415, _3418, ])
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.3431: Int = (x.3432: Int, y.3433: Int) {
// [KnfOpt]   Add(x.3432, y.3433)
// [KnfOpt] }
// [KnfOpt] let _3434: Int = Int(0)
// [KnfOpt] let join fold.3435: Int = (stream.3436: Fun([Unit], Tuple([Int, Int])), f.3437: Fun([Int, Int], Int), acc.3438: Int) {
// [KnfOpt]   let _3439: Unit = Unit
// [KnfOpt]   let _3440: Tuple([Int, Int]) = Apply(stream.3436, [_3439, ])
// [KnfOpt]   let (ok.3441: Var({val: Some(Int)}), val.3442: Var({val: Some(Int)})) = _3440
// [KnfOpt]   let _3443: Int = Int(0)
// [KnfOpt]   if (ok.3441 == _3443) then {
// [KnfOpt]     let sum.104: Int = Var(acc.3438)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _3444: Int = Apply(f.3437, [acc.3438, val.3442, ])
// [KnfOpt]     Jump(fold.3435, [stream.3436, f.3437, _3444, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.3435, [under1200.103, add.3431, _3434, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(gt) let _99: Fun([Int], Int) = Unit
// [KnfOpt] let rec aux.3371: Tuple([Int, Int]) = (u.3372: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.3373: Tuple([Int, Int]) = (u.3374: Var({val: Some(Unit)})) {
// [KnfOpt]     let _3375: Unit = Unit
// [KnfOpt]     let _3376: Tuple([Int, Int]) = Apply(addone.97, [_3375, ])
// [KnfOpt]     let (ok.3377: Var({val: Some(Int)}), val.3378: Var({val: Some(Int)})) = _3376
// [KnfOpt]     let _3379: Int = Int(0)
// [KnfOpt]     if (ok.3377 == _3379) then {
// [KnfOpt]       let _3380: Int = Int(0)
// [KnfOpt]       let _3381: Int = Int(0)
// [KnfOpt]       Tuple([_3380, _3381, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.3382: Int = Apply(_99, [val.3378, ])
// [KnfOpt]       let _3383: Int = Int(0)
// [KnfOpt]       if (r.3382 == _3383) then {
// [KnfOpt]         let _3384: Int = Int(1)
// [KnfOpt]         Tuple([_3384, val.3378, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _3385: Unit = Unit
// [KnfOpt]         Jump(aux.3373, [_3385, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.3373, [u.3372, ])
// [KnfOpt] }
// [KnfOpt] let over50.100: Fun([Unit], Tuple([Int, Int])) = Var(aux.3371)
// [KnfOpt] let _101: Int = Int(1200)
// [KnfOpt] let rec aux.3429: Int = (y.3430: Int) {
// [KnfOpt]   if (y.3430 <= _101) then {
// [KnfOpt]     Int(0)
// [KnfOpt]   } else {
// [KnfOpt]     Int(1)
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] let _102: Fun([Int], Int) = Var(aux.3429)
// [KnfOpt] let rec aux.3445: Tuple([Int, Int]) = (u.3446: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.3447: Tuple([Int, Int]) = (u.3448: Var({val: Some(Unit)})) {
// [KnfOpt]     let _3449: Unit = Unit
// [KnfOpt]     let _3450: Tuple([Int, Int]) = Apply(over50.100, [_3449, ])
// [KnfOpt]     let (ok.3451: Var({val: Some(Int)}), val.3452: Var({val: Some(Int)})) = _3450
// [KnfOpt]     let _3453: Int = Int(0)
// [KnfOpt]     if (ok.3451 == _3453) then {
// [KnfOpt]       let _3454: Int = Int(0)
// [KnfOpt]       let _3455: Int = Int(0)
// [KnfOpt]       Tuple([_3454, _3455, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.3456: Int = Apply(_102, [val.3452, ])
// [KnfOpt]       let _3457: Int = Int(0)
// [KnfOpt]       if (r.3456 == _3457) then {
// [KnfOpt]         let _3458: Int = Int(1)
// [KnfOpt]         Tuple([_3458, val.3452, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _3459: Unit = Unit
// [KnfOpt]         Jump(aux.3447, [_3459, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.3447, [u.3446, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.3445)
// [KnfOpt] let rec add.3460: Int = (x.3461: Int, y.3462: Int) {
// [KnfOpt]   Add(x.3461, y.3462)
// [KnfOpt] }
// [KnfOpt] let _3463: Int = Int(0)
// [KnfOpt] let join fold.3464: Int = (stream.3465: Fun([Unit], Tuple([Int, Int])), f.3466: Fun([Int, Int], Int), acc.3467: Int) {
// [KnfOpt]   let _3468: Unit = Unit
// [KnfOpt]   let _3469: Tuple([Int, Int]) = Apply(stream.3465, [_3468, ])
// [KnfOpt]   let (ok.3470: Var({val: Some(Int)}), val.3471: Var({val: Some(Int)})) = _3469
// [KnfOpt]   let _3472: Int = Int(0)
// [KnfOpt]   if (ok.3470 == _3472) then {
// [KnfOpt]     let sum.104: Int = Var(acc.3467)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _3473: Int = Apply(f.3466, [acc.3467, val.3471, ])
// [KnfOpt]     Jump(fold.3464, [stream.3465, f.3466, _3473, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.3464, [under1200.103, add.3460, _3463, ])
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 5
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 0
// [KnfOpt] Inline decision le.83 accepted
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.3476: Int = (x.3477: Int, y.3478: Int) {
// [KnfOpt]   Add(x.3477, y.3478)
// [KnfOpt] }
// [KnfOpt] let _3479: Int = Int(0)
// [KnfOpt] let join fold.3480: Int = (stream.3481: Fun([Unit], Tuple([Int, Int])), f.3482: Fun([Int, Int], Int), acc.3483: Int) {
// [KnfOpt]   let _3484: Unit = Unit
// [KnfOpt]   let _3485: Tuple([Int, Int]) = Apply(stream.3481, [_3484, ])
// [KnfOpt]   let (ok.3486: Var({val: Some(Int)}), val.3487: Var({val: Some(Int)})) = _3485
// [KnfOpt]   let _3488: Int = Int(0)
// [KnfOpt]   if (ok.3486 == _3488) then {
// [KnfOpt]     let sum.104: Int = Var(acc.3483)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _3489: Int = Apply(f.3482, [acc.3483, val.3487, ])
// [KnfOpt]     Jump(fold.3480, [stream.3481, f.3482, _3489, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.3480, [under1200.103, add.3476, _3479, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(le) let _102: Fun([Int], Int) = Unit
// [KnfOpt] let rec aux.3490: Tuple([Int, Int]) = (u.3491: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.3492: Tuple([Int, Int]) = (u.3493: Var({val: Some(Unit)})) {
// [KnfOpt]     let _3494: Unit = Unit
// [KnfOpt]     let _3495: Tuple([Int, Int]) = Apply(over50.100, [_3494, ])
// [KnfOpt]     let (ok.3496: Var({val: Some(Int)}), val.3497: Var({val: Some(Int)})) = _3495
// [KnfOpt]     let _3498: Int = Int(0)
// [KnfOpt]     if (ok.3496 == _3498) then {
// [KnfOpt]       let _3499: Int = Int(0)
// [KnfOpt]       let _3500: Int = Int(0)
// [KnfOpt]       Tuple([_3499, _3500, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.3501: Int = Apply(_102, [val.3497, ])
// [KnfOpt]       let _3502: Int = Int(0)
// [KnfOpt]       if (r.3501 == _3502) then {
// [KnfOpt]         let _3503: Int = Int(1)
// [KnfOpt]         Tuple([_3503, val.3497, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _3504: Unit = Unit
// [KnfOpt]         Jump(aux.3492, [_3504, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.3492, [u.3491, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.3490)
// [KnfOpt] let rec add.3505: Int = (x.3506: Int, y.3507: Int) {
// [KnfOpt]   Add(x.3506, y.3507)
// [KnfOpt] }
// [KnfOpt] let _3508: Int = Int(0)
// [KnfOpt] let join fold.3509: Int = (stream.3510: Fun([Unit], Tuple([Int, Int])), f.3511: Fun([Int, Int], Int), acc.3512: Int) {
// [KnfOpt]   let _3513: Unit = Unit
// [KnfOpt]   let _3514: Tuple([Int, Int]) = Apply(stream.3510, [_3513, ])
// [KnfOpt]   let (ok.3515: Var({val: Some(Int)}), val.3516: Var({val: Some(Int)})) = _3514
// [KnfOpt]   let _3517: Int = Int(0)
// [KnfOpt]   if (ok.3515 == _3517) then {
// [KnfOpt]     let sum.104: Int = Var(acc.3512)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _3518: Int = Apply(f.3511, [acc.3512, val.3516, ])
// [KnfOpt]     Jump(fold.3509, [stream.3510, f.3511, _3518, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.3509, [under1200.103, add.3505, _3508, ])
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.3521: Int = (x.3522: Int, y.3523: Int) {
// [KnfOpt]   Add(x.3522, y.3523)
// [KnfOpt] }
// [KnfOpt] let _3524: Int = Int(0)
// [KnfOpt] let join fold.3525: Int = (stream.3526: Fun([Unit], Tuple([Int, Int])), f.3527: Fun([Int, Int], Int), acc.3528: Int) {
// [KnfOpt]   let _3529: Unit = Unit
// [KnfOpt]   let _3530: Tuple([Int, Int]) = Apply(stream.3526, [_3529, ])
// [KnfOpt]   let (ok.3531: Var({val: Some(Int)}), val.3532: Var({val: Some(Int)})) = _3530
// [KnfOpt]   let _3533: Int = Int(0)
// [KnfOpt]   if (ok.3531 == _3533) then {
// [KnfOpt]     let sum.104: Int = Var(acc.3528)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _3534: Int = Apply(f.3527, [acc.3528, val.3532, ])
// [KnfOpt]     Jump(fold.3525, [stream.3526, f.3527, _3534, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.3525, [under1200.103, add.3521, _3524, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let over50.100: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let _101: Int = Int(1200)
// [KnfOpt] let rec aux.3519: Int = (y.3520: Int) {
// [KnfOpt]   if (y.3520 <= _101) then {
// [KnfOpt]     Int(0)
// [KnfOpt]   } else {
// [KnfOpt]     Int(1)
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] let _102: Fun([Int], Int) = Var(aux.3519)
// [KnfOpt] let rec aux.3535: Tuple([Int, Int]) = (u.3536: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.3537: Tuple([Int, Int]) = (u.3538: Var({val: Some(Unit)})) {
// [KnfOpt]     let _3539: Unit = Unit
// [KnfOpt]     let _3540: Tuple([Int, Int]) = Apply(over50.100, [_3539, ])
// [KnfOpt]     let (ok.3541: Var({val: Some(Int)}), val.3542: Var({val: Some(Int)})) = _3540
// [KnfOpt]     let _3543: Int = Int(0)
// [KnfOpt]     if (ok.3541 == _3543) then {
// [KnfOpt]       let _3544: Int = Int(0)
// [KnfOpt]       let _3545: Int = Int(0)
// [KnfOpt]       Tuple([_3544, _3545, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.3546: Int = Apply(_102, [val.3542, ])
// [KnfOpt]       let _3547: Int = Int(0)
// [KnfOpt]       if (r.3546 == _3547) then {
// [KnfOpt]         let _3548: Int = Int(1)
// [KnfOpt]         Tuple([_3548, val.3542, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _3549: Unit = Unit
// [KnfOpt]         Jump(aux.3537, [_3549, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.3537, [u.3536, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.3535)
// [KnfOpt] let rec add.3550: Int = (x.3551: Int, y.3552: Int) {
// [KnfOpt]   Add(x.3551, y.3552)
// [KnfOpt] }
// [KnfOpt] let _3553: Int = Int(0)
// [KnfOpt] let join fold.3554: Int = (stream.3555: Fun([Unit], Tuple([Int, Int])), f.3556: Fun([Int, Int], Int), acc.3557: Int) {
// [KnfOpt]   let _3558: Unit = Unit
// [KnfOpt]   let _3559: Tuple([Int, Int]) = Apply(stream.3555, [_3558, ])
// [KnfOpt]   let (ok.3560: Var({val: Some(Int)}), val.3561: Var({val: Some(Int)})) = _3559
// [KnfOpt]   let _3562: Int = Int(0)
// [KnfOpt]   if (ok.3560 == _3562) then {
// [KnfOpt]     let sum.104: Int = Var(acc.3557)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _3563: Int = Apply(f.3556, [acc.3557, val.3561, ])
// [KnfOpt]     Jump(fold.3554, [stream.3555, f.3556, _3563, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.3554, [under1200.103, add.3550, _3553, ])
// [KnfOpt] Inline threshold 5
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 0
// [KnfOpt] Inline decision le.83 accepted
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.3579: Int = (x.3580: Int, y.3581: Int) {
// [KnfOpt]   Add(x.3580, y.3581)
// [KnfOpt] }
// [KnfOpt] let _3582: Int = Int(0)
// [KnfOpt] let join fold.3583: Int = (stream.3584: Fun([Unit], Tuple([Int, Int])), f.3585: Fun([Int, Int], Int), acc.3586: Int) {
// [KnfOpt]   let _3587: Unit = Unit
// [KnfOpt]   let _3588: Tuple([Int, Int]) = Apply(stream.3584, [_3587, ])
// [KnfOpt]   let (ok.3589: Var({val: Some(Int)}), val.3590: Var({val: Some(Int)})) = _3588
// [KnfOpt]   let _3591: Int = Int(0)
// [KnfOpt]   if (ok.3589 == _3591) then {
// [KnfOpt]     let sum.104: Int = Var(acc.3586)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _3592: Int = Apply(f.3585, [acc.3586, val.3590, ])
// [KnfOpt]     Jump(fold.3583, [stream.3584, f.3585, _3592, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.3583, [under1200.103, add.3579, _3582, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(le) let _102: Fun([Int], Int) = Unit
// [KnfOpt] let rec aux.3593: Tuple([Int, Int]) = (u.3594: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.3595: Tuple([Int, Int]) = (u.3596: Var({val: Some(Unit)})) {
// [KnfOpt]     let _3597: Unit = Unit
// [KnfOpt]     let _3598: Tuple([Int, Int]) = Apply(over50.100, [_3597, ])
// [KnfOpt]     let (ok.3599: Var({val: Some(Int)}), val.3600: Var({val: Some(Int)})) = _3598
// [KnfOpt]     let _3601: Int = Int(0)
// [KnfOpt]     if (ok.3599 == _3601) then {
// [KnfOpt]       let _3602: Int = Int(0)
// [KnfOpt]       let _3603: Int = Int(0)
// [KnfOpt]       Tuple([_3602, _3603, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.3604: Int = Apply(_102, [val.3600, ])
// [KnfOpt]       let _3605: Int = Int(0)
// [KnfOpt]       if (r.3604 == _3605) then {
// [KnfOpt]         let _3606: Int = Int(1)
// [KnfOpt]         Tuple([_3606, val.3600, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _3607: Unit = Unit
// [KnfOpt]         Jump(aux.3595, [_3607, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.3595, [u.3594, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.3593)
// [KnfOpt] let rec add.3608: Int = (x.3609: Int, y.3610: Int) {
// [KnfOpt]   Add(x.3609, y.3610)
// [KnfOpt] }
// [KnfOpt] let _3611: Int = Int(0)
// [KnfOpt] let join fold.3612: Int = (stream.3613: Fun([Unit], Tuple([Int, Int])), f.3614: Fun([Int, Int], Int), acc.3615: Int) {
// [KnfOpt]   let _3616: Unit = Unit
// [KnfOpt]   let _3617: Tuple([Int, Int]) = Apply(stream.3613, [_3616, ])
// [KnfOpt]   let (ok.3618: Var({val: Some(Int)}), val.3619: Var({val: Some(Int)})) = _3617
// [KnfOpt]   let _3620: Int = Int(0)
// [KnfOpt]   if (ok.3618 == _3620) then {
// [KnfOpt]     let sum.104: Int = Var(acc.3615)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _3621: Int = Apply(f.3614, [acc.3615, val.3619, ])
// [KnfOpt]     Jump(fold.3612, [stream.3613, f.3614, _3621, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.3612, [under1200.103, add.3608, _3611, ])
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.3624: Int = (x.3625: Int, y.3626: Int) {
// [KnfOpt]   Add(x.3625, y.3626)
// [KnfOpt] }
// [KnfOpt] let _3627: Int = Int(0)
// [KnfOpt] let join fold.3628: Int = (stream.3629: Fun([Unit], Tuple([Int, Int])), f.3630: Fun([Int, Int], Int), acc.3631: Int) {
// [KnfOpt]   let _3632: Unit = Unit
// [KnfOpt]   let _3633: Tuple([Int, Int]) = Apply(stream.3629, [_3632, ])
// [KnfOpt]   let (ok.3634: Var({val: Some(Int)}), val.3635: Var({val: Some(Int)})) = _3633
// [KnfOpt]   let _3636: Int = Int(0)
// [KnfOpt]   if (ok.3634 == _3636) then {
// [KnfOpt]     let sum.104: Int = Var(acc.3631)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _3637: Int = Apply(f.3630, [acc.3631, val.3635, ])
// [KnfOpt]     Jump(fold.3628, [stream.3629, f.3630, _3637, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.3628, [under1200.103, add.3624, _3627, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(map) let addone.97: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let _98: Int = Int(50)
// [KnfOpt] let rec aux.3474: Int = (y.3475: Int) {
// [KnfOpt]   if (_98 <= y.3475) then {
// [KnfOpt]     Int(0)
// [KnfOpt]   } else {
// [KnfOpt]     Int(1)
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] let _99: Fun([Int], Int) = Var(aux.3474)
// [KnfOpt] let rec aux.3564: Tuple([Int, Int]) = (u.3565: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.3566: Tuple([Int, Int]) = (u.3567: Var({val: Some(Unit)})) {
// [KnfOpt]     let _3568: Unit = Unit
// [KnfOpt]     let _3569: Tuple([Int, Int]) = Apply(addone.97, [_3568, ])
// [KnfOpt]     let (ok.3570: Var({val: Some(Int)}), val.3571: Var({val: Some(Int)})) = _3569
// [KnfOpt]     let _3572: Int = Int(0)
// [KnfOpt]     if (ok.3570 == _3572) then {
// [KnfOpt]       let _3573: Int = Int(0)
// [KnfOpt]       let _3574: Int = Int(0)
// [KnfOpt]       Tuple([_3573, _3574, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.3575: Int = Apply(_99, [val.3571, ])
// [KnfOpt]       let _3576: Int = Int(0)
// [KnfOpt]       if (r.3575 == _3576) then {
// [KnfOpt]         let _3577: Int = Int(1)
// [KnfOpt]         Tuple([_3577, val.3571, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _3578: Unit = Unit
// [KnfOpt]         Jump(aux.3566, [_3578, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.3566, [u.3565, ])
// [KnfOpt] }
// [KnfOpt] let over50.100: Fun([Unit], Tuple([Int, Int])) = Var(aux.3564)
// [KnfOpt] let _101: Int = Int(1200)
// [KnfOpt] let rec aux.3622: Int = (y.3623: Int) {
// [KnfOpt]   if (y.3623 <= _101) then {
// [KnfOpt]     Int(0)
// [KnfOpt]   } else {
// [KnfOpt]     Int(1)
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] let _102: Fun([Int], Int) = Var(aux.3622)
// [KnfOpt] let rec aux.3638: Tuple([Int, Int]) = (u.3639: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.3640: Tuple([Int, Int]) = (u.3641: Var({val: Some(Unit)})) {
// [KnfOpt]     let _3642: Unit = Unit
// [KnfOpt]     let _3643: Tuple([Int, Int]) = Apply(over50.100, [_3642, ])
// [KnfOpt]     let (ok.3644: Var({val: Some(Int)}), val.3645: Var({val: Some(Int)})) = _3643
// [KnfOpt]     let _3646: Int = Int(0)
// [KnfOpt]     if (ok.3644 == _3646) then {
// [KnfOpt]       let _3647: Int = Int(0)
// [KnfOpt]       let _3648: Int = Int(0)
// [KnfOpt]       Tuple([_3647, _3648, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.3649: Int = Apply(_102, [val.3645, ])
// [KnfOpt]       let _3650: Int = Int(0)
// [KnfOpt]       if (r.3649 == _3650) then {
// [KnfOpt]         let _3651: Int = Int(1)
// [KnfOpt]         Tuple([_3651, val.3645, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _3652: Unit = Unit
// [KnfOpt]         Jump(aux.3640, [_3652, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.3640, [u.3639, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.3638)
// [KnfOpt] let rec add.3653: Int = (x.3654: Int, y.3655: Int) {
// [KnfOpt]   Add(x.3654, y.3655)
// [KnfOpt] }
// [KnfOpt] let _3656: Int = Int(0)
// [KnfOpt] let join fold.3657: Int = (stream.3658: Fun([Unit], Tuple([Int, Int])), f.3659: Fun([Int, Int], Int), acc.3660: Int) {
// [KnfOpt]   let _3661: Unit = Unit
// [KnfOpt]   let _3662: Tuple([Int, Int]) = Apply(stream.3658, [_3661, ])
// [KnfOpt]   let (ok.3663: Var({val: Some(Int)}), val.3664: Var({val: Some(Int)})) = _3662
// [KnfOpt]   let _3665: Int = Int(0)
// [KnfOpt]   if (ok.3663 == _3665) then {
// [KnfOpt]     let sum.104: Int = Var(acc.3660)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _3666: Int = Apply(f.3659, [acc.3660, val.3664, ])
// [KnfOpt]     Jump(fold.3657, [stream.3658, f.3659, _3666, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.3657, [under1200.103, add.3653, _3656, ])
// [KnfOpt] Inline threshold 5
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 0
// [KnfOpt] Inline decision gt.79 accepted
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 5
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 0
// [KnfOpt] Inline decision le.83 accepted
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.3678: Int = (x.3679: Int, y.3680: Int) {
// [KnfOpt]   Add(x.3679, y.3680)
// [KnfOpt] }
// [KnfOpt] let _3681: Int = Int(0)
// [KnfOpt] let join fold.3682: Int = (stream.3683: Fun([Unit], Tuple([Int, Int])), f.3684: Fun([Int, Int], Int), acc.3685: Int) {
// [KnfOpt]   let _3686: Unit = Unit
// [KnfOpt]   let _3687: Tuple([Int, Int]) = Apply(stream.3683, [_3686, ])
// [KnfOpt]   let (ok.3688: Var({val: Some(Int)}), val.3689: Var({val: Some(Int)})) = _3687
// [KnfOpt]   let _3690: Int = Int(0)
// [KnfOpt]   if (ok.3688 == _3690) then {
// [KnfOpt]     let sum.104: Int = Var(acc.3685)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _3691: Int = Apply(f.3684, [acc.3685, val.3689, ])
// [KnfOpt]     Jump(fold.3682, [stream.3683, f.3684, _3691, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.3682, [under1200.103, add.3678, _3681, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(le) let _102: Fun([Int], Int) = Unit
// [KnfOpt] let rec aux.3692: Tuple([Int, Int]) = (u.3693: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.3694: Tuple([Int, Int]) = (u.3695: Var({val: Some(Unit)})) {
// [KnfOpt]     let _3696: Unit = Unit
// [KnfOpt]     let _3697: Tuple([Int, Int]) = Apply(over50.100, [_3696, ])
// [KnfOpt]     let (ok.3698: Var({val: Some(Int)}), val.3699: Var({val: Some(Int)})) = _3697
// [KnfOpt]     let _3700: Int = Int(0)
// [KnfOpt]     if (ok.3698 == _3700) then {
// [KnfOpt]       let _3701: Int = Int(0)
// [KnfOpt]       let _3702: Int = Int(0)
// [KnfOpt]       Tuple([_3701, _3702, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.3703: Int = Apply(_102, [val.3699, ])
// [KnfOpt]       let _3704: Int = Int(0)
// [KnfOpt]       if (r.3703 == _3704) then {
// [KnfOpt]         let _3705: Int = Int(1)
// [KnfOpt]         Tuple([_3705, val.3699, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _3706: Unit = Unit
// [KnfOpt]         Jump(aux.3694, [_3706, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.3694, [u.3693, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.3692)
// [KnfOpt] let rec add.3707: Int = (x.3708: Int, y.3709: Int) {
// [KnfOpt]   Add(x.3708, y.3709)
// [KnfOpt] }
// [KnfOpt] let _3710: Int = Int(0)
// [KnfOpt] let join fold.3711: Int = (stream.3712: Fun([Unit], Tuple([Int, Int])), f.3713: Fun([Int, Int], Int), acc.3714: Int) {
// [KnfOpt]   let _3715: Unit = Unit
// [KnfOpt]   let _3716: Tuple([Int, Int]) = Apply(stream.3712, [_3715, ])
// [KnfOpt]   let (ok.3717: Var({val: Some(Int)}), val.3718: Var({val: Some(Int)})) = _3716
// [KnfOpt]   let _3719: Int = Int(0)
// [KnfOpt]   if (ok.3717 == _3719) then {
// [KnfOpt]     let sum.104: Int = Var(acc.3714)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _3720: Int = Apply(f.3713, [acc.3714, val.3718, ])
// [KnfOpt]     Jump(fold.3711, [stream.3712, f.3713, _3720, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.3711, [under1200.103, add.3707, _3710, ])
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.3723: Int = (x.3724: Int, y.3725: Int) {
// [KnfOpt]   Add(x.3724, y.3725)
// [KnfOpt] }
// [KnfOpt] let _3726: Int = Int(0)
// [KnfOpt] let join fold.3727: Int = (stream.3728: Fun([Unit], Tuple([Int, Int])), f.3729: Fun([Int, Int], Int), acc.3730: Int) {
// [KnfOpt]   let _3731: Unit = Unit
// [KnfOpt]   let _3732: Tuple([Int, Int]) = Apply(stream.3728, [_3731, ])
// [KnfOpt]   let (ok.3733: Var({val: Some(Int)}), val.3734: Var({val: Some(Int)})) = _3732
// [KnfOpt]   let _3735: Int = Int(0)
// [KnfOpt]   if (ok.3733 == _3735) then {
// [KnfOpt]     let sum.104: Int = Var(acc.3730)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _3736: Int = Apply(f.3729, [acc.3730, val.3734, ])
// [KnfOpt]     Jump(fold.3727, [stream.3728, f.3729, _3736, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.3727, [under1200.103, add.3723, _3726, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let over50.100: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let _101: Int = Int(1200)
// [KnfOpt] let rec aux.3721: Int = (y.3722: Int) {
// [KnfOpt]   if (y.3722 <= _101) then {
// [KnfOpt]     Int(0)
// [KnfOpt]   } else {
// [KnfOpt]     Int(1)
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] let _102: Fun([Int], Int) = Var(aux.3721)
// [KnfOpt] let rec aux.3737: Tuple([Int, Int]) = (u.3738: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.3739: Tuple([Int, Int]) = (u.3740: Var({val: Some(Unit)})) {
// [KnfOpt]     let _3741: Unit = Unit
// [KnfOpt]     let _3742: Tuple([Int, Int]) = Apply(over50.100, [_3741, ])
// [KnfOpt]     let (ok.3743: Var({val: Some(Int)}), val.3744: Var({val: Some(Int)})) = _3742
// [KnfOpt]     let _3745: Int = Int(0)
// [KnfOpt]     if (ok.3743 == _3745) then {
// [KnfOpt]       let _3746: Int = Int(0)
// [KnfOpt]       let _3747: Int = Int(0)
// [KnfOpt]       Tuple([_3746, _3747, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.3748: Int = Apply(_102, [val.3744, ])
// [KnfOpt]       let _3749: Int = Int(0)
// [KnfOpt]       if (r.3748 == _3749) then {
// [KnfOpt]         let _3750: Int = Int(1)
// [KnfOpt]         Tuple([_3750, val.3744, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _3751: Unit = Unit
// [KnfOpt]         Jump(aux.3739, [_3751, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.3739, [u.3738, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.3737)
// [KnfOpt] let rec add.3752: Int = (x.3753: Int, y.3754: Int) {
// [KnfOpt]   Add(x.3753, y.3754)
// [KnfOpt] }
// [KnfOpt] let _3755: Int = Int(0)
// [KnfOpt] let join fold.3756: Int = (stream.3757: Fun([Unit], Tuple([Int, Int])), f.3758: Fun([Int, Int], Int), acc.3759: Int) {
// [KnfOpt]   let _3760: Unit = Unit
// [KnfOpt]   let _3761: Tuple([Int, Int]) = Apply(stream.3757, [_3760, ])
// [KnfOpt]   let (ok.3762: Var({val: Some(Int)}), val.3763: Var({val: Some(Int)})) = _3761
// [KnfOpt]   let _3764: Int = Int(0)
// [KnfOpt]   if (ok.3762 == _3764) then {
// [KnfOpt]     let sum.104: Int = Var(acc.3759)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _3765: Int = Apply(f.3758, [acc.3759, val.3763, ])
// [KnfOpt]     Jump(fold.3756, [stream.3757, f.3758, _3765, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.3756, [under1200.103, add.3752, _3755, ])
// [KnfOpt] Inline threshold 5
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 0
// [KnfOpt] Inline decision le.83 accepted
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.3781: Int = (x.3782: Int, y.3783: Int) {
// [KnfOpt]   Add(x.3782, y.3783)
// [KnfOpt] }
// [KnfOpt] let _3784: Int = Int(0)
// [KnfOpt] let join fold.3785: Int = (stream.3786: Fun([Unit], Tuple([Int, Int])), f.3787: Fun([Int, Int], Int), acc.3788: Int) {
// [KnfOpt]   let _3789: Unit = Unit
// [KnfOpt]   let _3790: Tuple([Int, Int]) = Apply(stream.3786, [_3789, ])
// [KnfOpt]   let (ok.3791: Var({val: Some(Int)}), val.3792: Var({val: Some(Int)})) = _3790
// [KnfOpt]   let _3793: Int = Int(0)
// [KnfOpt]   if (ok.3791 == _3793) then {
// [KnfOpt]     let sum.104: Int = Var(acc.3788)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _3794: Int = Apply(f.3787, [acc.3788, val.3792, ])
// [KnfOpt]     Jump(fold.3785, [stream.3786, f.3787, _3794, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.3785, [under1200.103, add.3781, _3784, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(le) let _102: Fun([Int], Int) = Unit
// [KnfOpt] let rec aux.3795: Tuple([Int, Int]) = (u.3796: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.3797: Tuple([Int, Int]) = (u.3798: Var({val: Some(Unit)})) {
// [KnfOpt]     let _3799: Unit = Unit
// [KnfOpt]     let _3800: Tuple([Int, Int]) = Apply(over50.100, [_3799, ])
// [KnfOpt]     let (ok.3801: Var({val: Some(Int)}), val.3802: Var({val: Some(Int)})) = _3800
// [KnfOpt]     let _3803: Int = Int(0)
// [KnfOpt]     if (ok.3801 == _3803) then {
// [KnfOpt]       let _3804: Int = Int(0)
// [KnfOpt]       let _3805: Int = Int(0)
// [KnfOpt]       Tuple([_3804, _3805, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.3806: Int = Apply(_102, [val.3802, ])
// [KnfOpt]       let _3807: Int = Int(0)
// [KnfOpt]       if (r.3806 == _3807) then {
// [KnfOpt]         let _3808: Int = Int(1)
// [KnfOpt]         Tuple([_3808, val.3802, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _3809: Unit = Unit
// [KnfOpt]         Jump(aux.3797, [_3809, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.3797, [u.3796, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.3795)
// [KnfOpt] let rec add.3810: Int = (x.3811: Int, y.3812: Int) {
// [KnfOpt]   Add(x.3811, y.3812)
// [KnfOpt] }
// [KnfOpt] let _3813: Int = Int(0)
// [KnfOpt] let join fold.3814: Int = (stream.3815: Fun([Unit], Tuple([Int, Int])), f.3816: Fun([Int, Int], Int), acc.3817: Int) {
// [KnfOpt]   let _3818: Unit = Unit
// [KnfOpt]   let _3819: Tuple([Int, Int]) = Apply(stream.3815, [_3818, ])
// [KnfOpt]   let (ok.3820: Var({val: Some(Int)}), val.3821: Var({val: Some(Int)})) = _3819
// [KnfOpt]   let _3822: Int = Int(0)
// [KnfOpt]   if (ok.3820 == _3822) then {
// [KnfOpt]     let sum.104: Int = Var(acc.3817)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _3823: Int = Apply(f.3816, [acc.3817, val.3821, ])
// [KnfOpt]     Jump(fold.3814, [stream.3815, f.3816, _3823, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.3814, [under1200.103, add.3810, _3813, ])
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.3826: Int = (x.3827: Int, y.3828: Int) {
// [KnfOpt]   Add(x.3827, y.3828)
// [KnfOpt] }
// [KnfOpt] let _3829: Int = Int(0)
// [KnfOpt] let join fold.3830: Int = (stream.3831: Fun([Unit], Tuple([Int, Int])), f.3832: Fun([Int, Int], Int), acc.3833: Int) {
// [KnfOpt]   let _3834: Unit = Unit
// [KnfOpt]   let _3835: Tuple([Int, Int]) = Apply(stream.3831, [_3834, ])
// [KnfOpt]   let (ok.3836: Var({val: Some(Int)}), val.3837: Var({val: Some(Int)})) = _3835
// [KnfOpt]   let _3838: Int = Int(0)
// [KnfOpt]   if (ok.3836 == _3838) then {
// [KnfOpt]     let sum.104: Int = Var(acc.3833)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _3839: Int = Apply(f.3832, [acc.3833, val.3837, ])
// [KnfOpt]     Jump(fold.3830, [stream.3831, f.3832, _3839, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.3830, [under1200.103, add.3826, _3829, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(gt) let _99: Fun([Int], Int) = Unit
// [KnfOpt] let rec aux.3766: Tuple([Int, Int]) = (u.3767: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.3768: Tuple([Int, Int]) = (u.3769: Var({val: Some(Unit)})) {
// [KnfOpt]     let _3770: Unit = Unit
// [KnfOpt]     let _3771: Tuple([Int, Int]) = Apply(addone.97, [_3770, ])
// [KnfOpt]     let (ok.3772: Var({val: Some(Int)}), val.3773: Var({val: Some(Int)})) = _3771
// [KnfOpt]     let _3774: Int = Int(0)
// [KnfOpt]     if (ok.3772 == _3774) then {
// [KnfOpt]       let _3775: Int = Int(0)
// [KnfOpt]       let _3776: Int = Int(0)
// [KnfOpt]       Tuple([_3775, _3776, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.3777: Int = Apply(_99, [val.3773, ])
// [KnfOpt]       let _3778: Int = Int(0)
// [KnfOpt]       if (r.3777 == _3778) then {
// [KnfOpt]         let _3779: Int = Int(1)
// [KnfOpt]         Tuple([_3779, val.3773, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _3780: Unit = Unit
// [KnfOpt]         Jump(aux.3768, [_3780, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.3768, [u.3767, ])
// [KnfOpt] }
// [KnfOpt] let over50.100: Fun([Unit], Tuple([Int, Int])) = Var(aux.3766)
// [KnfOpt] let _101: Int = Int(1200)
// [KnfOpt] let rec aux.3824: Int = (y.3825: Int) {
// [KnfOpt]   if (y.3825 <= _101) then {
// [KnfOpt]     Int(0)
// [KnfOpt]   } else {
// [KnfOpt]     Int(1)
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] let _102: Fun([Int], Int) = Var(aux.3824)
// [KnfOpt] let rec aux.3840: Tuple([Int, Int]) = (u.3841: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.3842: Tuple([Int, Int]) = (u.3843: Var({val: Some(Unit)})) {
// [KnfOpt]     let _3844: Unit = Unit
// [KnfOpt]     let _3845: Tuple([Int, Int]) = Apply(over50.100, [_3844, ])
// [KnfOpt]     let (ok.3846: Var({val: Some(Int)}), val.3847: Var({val: Some(Int)})) = _3845
// [KnfOpt]     let _3848: Int = Int(0)
// [KnfOpt]     if (ok.3846 == _3848) then {
// [KnfOpt]       let _3849: Int = Int(0)
// [KnfOpt]       let _3850: Int = Int(0)
// [KnfOpt]       Tuple([_3849, _3850, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.3851: Int = Apply(_102, [val.3847, ])
// [KnfOpt]       let _3852: Int = Int(0)
// [KnfOpt]       if (r.3851 == _3852) then {
// [KnfOpt]         let _3853: Int = Int(1)
// [KnfOpt]         Tuple([_3853, val.3847, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _3854: Unit = Unit
// [KnfOpt]         Jump(aux.3842, [_3854, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.3842, [u.3841, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.3840)
// [KnfOpt] let rec add.3855: Int = (x.3856: Int, y.3857: Int) {
// [KnfOpt]   Add(x.3856, y.3857)
// [KnfOpt] }
// [KnfOpt] let _3858: Int = Int(0)
// [KnfOpt] let join fold.3859: Int = (stream.3860: Fun([Unit], Tuple([Int, Int])), f.3861: Fun([Int, Int], Int), acc.3862: Int) {
// [KnfOpt]   let _3863: Unit = Unit
// [KnfOpt]   let _3864: Tuple([Int, Int]) = Apply(stream.3860, [_3863, ])
// [KnfOpt]   let (ok.3865: Var({val: Some(Int)}), val.3866: Var({val: Some(Int)})) = _3864
// [KnfOpt]   let _3867: Int = Int(0)
// [KnfOpt]   if (ok.3865 == _3867) then {
// [KnfOpt]     let sum.104: Int = Var(acc.3862)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _3868: Int = Apply(f.3861, [acc.3862, val.3866, ])
// [KnfOpt]     Jump(fold.3859, [stream.3860, f.3861, _3868, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.3859, [under1200.103, add.3855, _3858, ])
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 5
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 0
// [KnfOpt] Inline decision le.83 accepted
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.3871: Int = (x.3872: Int, y.3873: Int) {
// [KnfOpt]   Add(x.3872, y.3873)
// [KnfOpt] }
// [KnfOpt] let _3874: Int = Int(0)
// [KnfOpt] let join fold.3875: Int = (stream.3876: Fun([Unit], Tuple([Int, Int])), f.3877: Fun([Int, Int], Int), acc.3878: Int) {
// [KnfOpt]   let _3879: Unit = Unit
// [KnfOpt]   let _3880: Tuple([Int, Int]) = Apply(stream.3876, [_3879, ])
// [KnfOpt]   let (ok.3881: Var({val: Some(Int)}), val.3882: Var({val: Some(Int)})) = _3880
// [KnfOpt]   let _3883: Int = Int(0)
// [KnfOpt]   if (ok.3881 == _3883) then {
// [KnfOpt]     let sum.104: Int = Var(acc.3878)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _3884: Int = Apply(f.3877, [acc.3878, val.3882, ])
// [KnfOpt]     Jump(fold.3875, [stream.3876, f.3877, _3884, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.3875, [under1200.103, add.3871, _3874, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(le) let _102: Fun([Int], Int) = Unit
// [KnfOpt] let rec aux.3885: Tuple([Int, Int]) = (u.3886: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.3887: Tuple([Int, Int]) = (u.3888: Var({val: Some(Unit)})) {
// [KnfOpt]     let _3889: Unit = Unit
// [KnfOpt]     let _3890: Tuple([Int, Int]) = Apply(over50.100, [_3889, ])
// [KnfOpt]     let (ok.3891: Var({val: Some(Int)}), val.3892: Var({val: Some(Int)})) = _3890
// [KnfOpt]     let _3893: Int = Int(0)
// [KnfOpt]     if (ok.3891 == _3893) then {
// [KnfOpt]       let _3894: Int = Int(0)
// [KnfOpt]       let _3895: Int = Int(0)
// [KnfOpt]       Tuple([_3894, _3895, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.3896: Int = Apply(_102, [val.3892, ])
// [KnfOpt]       let _3897: Int = Int(0)
// [KnfOpt]       if (r.3896 == _3897) then {
// [KnfOpt]         let _3898: Int = Int(1)
// [KnfOpt]         Tuple([_3898, val.3892, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _3899: Unit = Unit
// [KnfOpt]         Jump(aux.3887, [_3899, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.3887, [u.3886, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.3885)
// [KnfOpt] let rec add.3900: Int = (x.3901: Int, y.3902: Int) {
// [KnfOpt]   Add(x.3901, y.3902)
// [KnfOpt] }
// [KnfOpt] let _3903: Int = Int(0)
// [KnfOpt] let join fold.3904: Int = (stream.3905: Fun([Unit], Tuple([Int, Int])), f.3906: Fun([Int, Int], Int), acc.3907: Int) {
// [KnfOpt]   let _3908: Unit = Unit
// [KnfOpt]   let _3909: Tuple([Int, Int]) = Apply(stream.3905, [_3908, ])
// [KnfOpt]   let (ok.3910: Var({val: Some(Int)}), val.3911: Var({val: Some(Int)})) = _3909
// [KnfOpt]   let _3912: Int = Int(0)
// [KnfOpt]   if (ok.3910 == _3912) then {
// [KnfOpt]     let sum.104: Int = Var(acc.3907)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _3913: Int = Apply(f.3906, [acc.3907, val.3911, ])
// [KnfOpt]     Jump(fold.3904, [stream.3905, f.3906, _3913, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.3904, [under1200.103, add.3900, _3903, ])
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.3916: Int = (x.3917: Int, y.3918: Int) {
// [KnfOpt]   Add(x.3917, y.3918)
// [KnfOpt] }
// [KnfOpt] let _3919: Int = Int(0)
// [KnfOpt] let join fold.3920: Int = (stream.3921: Fun([Unit], Tuple([Int, Int])), f.3922: Fun([Int, Int], Int), acc.3923: Int) {
// [KnfOpt]   let _3924: Unit = Unit
// [KnfOpt]   let _3925: Tuple([Int, Int]) = Apply(stream.3921, [_3924, ])
// [KnfOpt]   let (ok.3926: Var({val: Some(Int)}), val.3927: Var({val: Some(Int)})) = _3925
// [KnfOpt]   let _3928: Int = Int(0)
// [KnfOpt]   if (ok.3926 == _3928) then {
// [KnfOpt]     let sum.104: Int = Var(acc.3923)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _3929: Int = Apply(f.3922, [acc.3923, val.3927, ])
// [KnfOpt]     Jump(fold.3920, [stream.3921, f.3922, _3929, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.3920, [under1200.103, add.3916, _3919, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let over50.100: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let _101: Int = Int(1200)
// [KnfOpt] let rec aux.3914: Int = (y.3915: Int) {
// [KnfOpt]   if (y.3915 <= _101) then {
// [KnfOpt]     Int(0)
// [KnfOpt]   } else {
// [KnfOpt]     Int(1)
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] let _102: Fun([Int], Int) = Var(aux.3914)
// [KnfOpt] let rec aux.3930: Tuple([Int, Int]) = (u.3931: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.3932: Tuple([Int, Int]) = (u.3933: Var({val: Some(Unit)})) {
// [KnfOpt]     let _3934: Unit = Unit
// [KnfOpt]     let _3935: Tuple([Int, Int]) = Apply(over50.100, [_3934, ])
// [KnfOpt]     let (ok.3936: Var({val: Some(Int)}), val.3937: Var({val: Some(Int)})) = _3935
// [KnfOpt]     let _3938: Int = Int(0)
// [KnfOpt]     if (ok.3936 == _3938) then {
// [KnfOpt]       let _3939: Int = Int(0)
// [KnfOpt]       let _3940: Int = Int(0)
// [KnfOpt]       Tuple([_3939, _3940, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.3941: Int = Apply(_102, [val.3937, ])
// [KnfOpt]       let _3942: Int = Int(0)
// [KnfOpt]       if (r.3941 == _3942) then {
// [KnfOpt]         let _3943: Int = Int(1)
// [KnfOpt]         Tuple([_3943, val.3937, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _3944: Unit = Unit
// [KnfOpt]         Jump(aux.3932, [_3944, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.3932, [u.3931, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.3930)
// [KnfOpt] let rec add.3945: Int = (x.3946: Int, y.3947: Int) {
// [KnfOpt]   Add(x.3946, y.3947)
// [KnfOpt] }
// [KnfOpt] let _3948: Int = Int(0)
// [KnfOpt] let join fold.3949: Int = (stream.3950: Fun([Unit], Tuple([Int, Int])), f.3951: Fun([Int, Int], Int), acc.3952: Int) {
// [KnfOpt]   let _3953: Unit = Unit
// [KnfOpt]   let _3954: Tuple([Int, Int]) = Apply(stream.3950, [_3953, ])
// [KnfOpt]   let (ok.3955: Var({val: Some(Int)}), val.3956: Var({val: Some(Int)})) = _3954
// [KnfOpt]   let _3957: Int = Int(0)
// [KnfOpt]   if (ok.3955 == _3957) then {
// [KnfOpt]     let sum.104: Int = Var(acc.3952)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _3958: Int = Apply(f.3951, [acc.3952, val.3956, ])
// [KnfOpt]     Jump(fold.3949, [stream.3950, f.3951, _3958, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.3949, [under1200.103, add.3945, _3948, ])
// [KnfOpt] Inline threshold 5
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 0
// [KnfOpt] Inline decision le.83 accepted
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.3974: Int = (x.3975: Int, y.3976: Int) {
// [KnfOpt]   Add(x.3975, y.3976)
// [KnfOpt] }
// [KnfOpt] let _3977: Int = Int(0)
// [KnfOpt] let join fold.3978: Int = (stream.3979: Fun([Unit], Tuple([Int, Int])), f.3980: Fun([Int, Int], Int), acc.3981: Int) {
// [KnfOpt]   let _3982: Unit = Unit
// [KnfOpt]   let _3983: Tuple([Int, Int]) = Apply(stream.3979, [_3982, ])
// [KnfOpt]   let (ok.3984: Var({val: Some(Int)}), val.3985: Var({val: Some(Int)})) = _3983
// [KnfOpt]   let _3986: Int = Int(0)
// [KnfOpt]   if (ok.3984 == _3986) then {
// [KnfOpt]     let sum.104: Int = Var(acc.3981)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _3987: Int = Apply(f.3980, [acc.3981, val.3985, ])
// [KnfOpt]     Jump(fold.3978, [stream.3979, f.3980, _3987, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.3978, [under1200.103, add.3974, _3977, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(le) let _102: Fun([Int], Int) = Unit
// [KnfOpt] let rec aux.3988: Tuple([Int, Int]) = (u.3989: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.3990: Tuple([Int, Int]) = (u.3991: Var({val: Some(Unit)})) {
// [KnfOpt]     let _3992: Unit = Unit
// [KnfOpt]     let _3993: Tuple([Int, Int]) = Apply(over50.100, [_3992, ])
// [KnfOpt]     let (ok.3994: Var({val: Some(Int)}), val.3995: Var({val: Some(Int)})) = _3993
// [KnfOpt]     let _3996: Int = Int(0)
// [KnfOpt]     if (ok.3994 == _3996) then {
// [KnfOpt]       let _3997: Int = Int(0)
// [KnfOpt]       let _3998: Int = Int(0)
// [KnfOpt]       Tuple([_3997, _3998, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.3999: Int = Apply(_102, [val.3995, ])
// [KnfOpt]       let _4000: Int = Int(0)
// [KnfOpt]       if (r.3999 == _4000) then {
// [KnfOpt]         let _4001: Int = Int(1)
// [KnfOpt]         Tuple([_4001, val.3995, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _4002: Unit = Unit
// [KnfOpt]         Jump(aux.3990, [_4002, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.3990, [u.3989, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.3988)
// [KnfOpt] let rec add.4003: Int = (x.4004: Int, y.4005: Int) {
// [KnfOpt]   Add(x.4004, y.4005)
// [KnfOpt] }
// [KnfOpt] let _4006: Int = Int(0)
// [KnfOpt] let join fold.4007: Int = (stream.4008: Fun([Unit], Tuple([Int, Int])), f.4009: Fun([Int, Int], Int), acc.4010: Int) {
// [KnfOpt]   let _4011: Unit = Unit
// [KnfOpt]   let _4012: Tuple([Int, Int]) = Apply(stream.4008, [_4011, ])
// [KnfOpt]   let (ok.4013: Var({val: Some(Int)}), val.4014: Var({val: Some(Int)})) = _4012
// [KnfOpt]   let _4015: Int = Int(0)
// [KnfOpt]   if (ok.4013 == _4015) then {
// [KnfOpt]     let sum.104: Int = Var(acc.4010)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _4016: Int = Apply(f.4009, [acc.4010, val.4014, ])
// [KnfOpt]     Jump(fold.4007, [stream.4008, f.4009, _4016, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.4007, [under1200.103, add.4003, _4006, ])
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.4019: Int = (x.4020: Int, y.4021: Int) {
// [KnfOpt]   Add(x.4020, y.4021)
// [KnfOpt] }
// [KnfOpt] let _4022: Int = Int(0)
// [KnfOpt] let join fold.4023: Int = (stream.4024: Fun([Unit], Tuple([Int, Int])), f.4025: Fun([Int, Int], Int), acc.4026: Int) {
// [KnfOpt]   let _4027: Unit = Unit
// [KnfOpt]   let _4028: Tuple([Int, Int]) = Apply(stream.4024, [_4027, ])
// [KnfOpt]   let (ok.4029: Var({val: Some(Int)}), val.4030: Var({val: Some(Int)})) = _4028
// [KnfOpt]   let _4031: Int = Int(0)
// [KnfOpt]   if (ok.4029 == _4031) then {
// [KnfOpt]     let sum.104: Int = Var(acc.4026)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _4032: Int = Apply(f.4025, [acc.4026, val.4030, ])
// [KnfOpt]     Jump(fold.4023, [stream.4024, f.4025, _4032, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.4023, [under1200.103, add.4019, _4022, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(addx) let _96: Fun([Int], Int) = Unit
// [KnfOpt] let rec aux.3667: Tuple([Int, Int]) = (u.3668: Var({val: Some(Unit)})) {
// [KnfOpt]   let _3669: Unit = Unit
// [KnfOpt]   let _3670: Tuple([Int, Int]) = Apply(catt.94, [_3669, ])
// [KnfOpt]   let (ok.3671: Var({val: Some(Int)}), val.3672: Var({val: Some(Int)})) = _3670
// [KnfOpt]   let _3673: Int = Int(0)
// [KnfOpt]   if (ok.3671 == _3673) then {
// [KnfOpt]     let _3674: Int = Int(0)
// [KnfOpt]     let _3675: Int = Int(0)
// [KnfOpt]     Tuple([_3674, _3675, ])
// [KnfOpt]   } else {
// [KnfOpt]     let _3676: Int = Int(1)
// [KnfOpt]     let _3677: Int = Apply(_96, [val.3672, ])
// [KnfOpt]     Tuple([_3676, _3677, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] let addone.97: Fun([Unit], Tuple([Int, Int])) = Var(aux.3667)
// [KnfOpt] let _98: Int = Int(50)
// [KnfOpt] let rec aux.3869: Int = (y.3870: Int) {
// [KnfOpt]   if (_98 <= y.3870) then {
// [KnfOpt]     Int(0)
// [KnfOpt]   } else {
// [KnfOpt]     Int(1)
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] let _99: Fun([Int], Int) = Var(aux.3869)
// [KnfOpt] let rec aux.3959: Tuple([Int, Int]) = (u.3960: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.3961: Tuple([Int, Int]) = (u.3962: Var({val: Some(Unit)})) {
// [KnfOpt]     let _3963: Unit = Unit
// [KnfOpt]     let _3964: Tuple([Int, Int]) = Apply(addone.97, [_3963, ])
// [KnfOpt]     let (ok.3965: Var({val: Some(Int)}), val.3966: Var({val: Some(Int)})) = _3964
// [KnfOpt]     let _3967: Int = Int(0)
// [KnfOpt]     if (ok.3965 == _3967) then {
// [KnfOpt]       let _3968: Int = Int(0)
// [KnfOpt]       let _3969: Int = Int(0)
// [KnfOpt]       Tuple([_3968, _3969, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.3970: Int = Apply(_99, [val.3966, ])
// [KnfOpt]       let _3971: Int = Int(0)
// [KnfOpt]       if (r.3970 == _3971) then {
// [KnfOpt]         let _3972: Int = Int(1)
// [KnfOpt]         Tuple([_3972, val.3966, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _3973: Unit = Unit
// [KnfOpt]         Jump(aux.3961, [_3973, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.3961, [u.3960, ])
// [KnfOpt] }
// [KnfOpt] let over50.100: Fun([Unit], Tuple([Int, Int])) = Var(aux.3959)
// [KnfOpt] let _101: Int = Int(1200)
// [KnfOpt] let rec aux.4017: Int = (y.4018: Int) {
// [KnfOpt]   if (y.4018 <= _101) then {
// [KnfOpt]     Int(0)
// [KnfOpt]   } else {
// [KnfOpt]     Int(1)
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] let _102: Fun([Int], Int) = Var(aux.4017)
// [KnfOpt] let rec aux.4033: Tuple([Int, Int]) = (u.4034: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.4035: Tuple([Int, Int]) = (u.4036: Var({val: Some(Unit)})) {
// [KnfOpt]     let _4037: Unit = Unit
// [KnfOpt]     let _4038: Tuple([Int, Int]) = Apply(over50.100, [_4037, ])
// [KnfOpt]     let (ok.4039: Var({val: Some(Int)}), val.4040: Var({val: Some(Int)})) = _4038
// [KnfOpt]     let _4041: Int = Int(0)
// [KnfOpt]     if (ok.4039 == _4041) then {
// [KnfOpt]       let _4042: Int = Int(0)
// [KnfOpt]       let _4043: Int = Int(0)
// [KnfOpt]       Tuple([_4042, _4043, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.4044: Int = Apply(_102, [val.4040, ])
// [KnfOpt]       let _4045: Int = Int(0)
// [KnfOpt]       if (r.4044 == _4045) then {
// [KnfOpt]         let _4046: Int = Int(1)
// [KnfOpt]         Tuple([_4046, val.4040, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _4047: Unit = Unit
// [KnfOpt]         Jump(aux.4035, [_4047, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.4035, [u.4034, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.4033)
// [KnfOpt] let rec add.4048: Int = (x.4049: Int, y.4050: Int) {
// [KnfOpt]   Add(x.4049, y.4050)
// [KnfOpt] }
// [KnfOpt] let _4051: Int = Int(0)
// [KnfOpt] let join fold.4052: Int = (stream.4053: Fun([Unit], Tuple([Int, Int])), f.4054: Fun([Int, Int], Int), acc.4055: Int) {
// [KnfOpt]   let _4056: Unit = Unit
// [KnfOpt]   let _4057: Tuple([Int, Int]) = Apply(stream.4053, [_4056, ])
// [KnfOpt]   let (ok.4058: Var({val: Some(Int)}), val.4059: Var({val: Some(Int)})) = _4057
// [KnfOpt]   let _4060: Int = Int(0)
// [KnfOpt]   if (ok.4058 == _4060) then {
// [KnfOpt]     let sum.104: Int = Var(acc.4055)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _4061: Int = Apply(f.4054, [acc.4055, val.4059, ])
// [KnfOpt]     Jump(fold.4052, [stream.4053, f.4054, _4061, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.4052, [under1200.103, add.4048, _4051, ])
// [KnfOpt] Inline threshold 20
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 0
// [KnfOpt] Inline decision map.1 accepted
// [KnfOpt] Inline threshold 5
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 0
// [KnfOpt] Inline decision gt.79 accepted
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 5
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 0
// [KnfOpt] Inline decision le.83 accepted
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.4064: Int = (x.4065: Int, y.4066: Int) {
// [KnfOpt]   Add(x.4065, y.4066)
// [KnfOpt] }
// [KnfOpt] let _4067: Int = Int(0)
// [KnfOpt] let join fold.4068: Int = (stream.4069: Fun([Unit], Tuple([Int, Int])), f.4070: Fun([Int, Int], Int), acc.4071: Int) {
// [KnfOpt]   let _4072: Unit = Unit
// [KnfOpt]   let _4073: Tuple([Int, Int]) = Apply(stream.4069, [_4072, ])
// [KnfOpt]   let (ok.4074: Var({val: Some(Int)}), val.4075: Var({val: Some(Int)})) = _4073
// [KnfOpt]   let _4076: Int = Int(0)
// [KnfOpt]   if (ok.4074 == _4076) then {
// [KnfOpt]     let sum.104: Int = Var(acc.4071)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _4077: Int = Apply(f.4070, [acc.4071, val.4075, ])
// [KnfOpt]     Jump(fold.4068, [stream.4069, f.4070, _4077, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.4068, [under1200.103, add.4064, _4067, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(le) let _102: Fun([Int], Int) = Unit
// [KnfOpt] let rec aux.4078: Tuple([Int, Int]) = (u.4079: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.4080: Tuple([Int, Int]) = (u.4081: Var({val: Some(Unit)})) {
// [KnfOpt]     let _4082: Unit = Unit
// [KnfOpt]     let _4083: Tuple([Int, Int]) = Apply(over50.100, [_4082, ])
// [KnfOpt]     let (ok.4084: Var({val: Some(Int)}), val.4085: Var({val: Some(Int)})) = _4083
// [KnfOpt]     let _4086: Int = Int(0)
// [KnfOpt]     if (ok.4084 == _4086) then {
// [KnfOpt]       let _4087: Int = Int(0)
// [KnfOpt]       let _4088: Int = Int(0)
// [KnfOpt]       Tuple([_4087, _4088, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.4089: Int = Apply(_102, [val.4085, ])
// [KnfOpt]       let _4090: Int = Int(0)
// [KnfOpt]       if (r.4089 == _4090) then {
// [KnfOpt]         let _4091: Int = Int(1)
// [KnfOpt]         Tuple([_4091, val.4085, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _4092: Unit = Unit
// [KnfOpt]         Jump(aux.4080, [_4092, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.4080, [u.4079, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.4078)
// [KnfOpt] let rec add.4093: Int = (x.4094: Int, y.4095: Int) {
// [KnfOpt]   Add(x.4094, y.4095)
// [KnfOpt] }
// [KnfOpt] let _4096: Int = Int(0)
// [KnfOpt] let join fold.4097: Int = (stream.4098: Fun([Unit], Tuple([Int, Int])), f.4099: Fun([Int, Int], Int), acc.4100: Int) {
// [KnfOpt]   let _4101: Unit = Unit
// [KnfOpt]   let _4102: Tuple([Int, Int]) = Apply(stream.4098, [_4101, ])
// [KnfOpt]   let (ok.4103: Var({val: Some(Int)}), val.4104: Var({val: Some(Int)})) = _4102
// [KnfOpt]   let _4105: Int = Int(0)
// [KnfOpt]   if (ok.4103 == _4105) then {
// [KnfOpt]     let sum.104: Int = Var(acc.4100)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _4106: Int = Apply(f.4099, [acc.4100, val.4104, ])
// [KnfOpt]     Jump(fold.4097, [stream.4098, f.4099, _4106, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.4097, [under1200.103, add.4093, _4096, ])
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.4109: Int = (x.4110: Int, y.4111: Int) {
// [KnfOpt]   Add(x.4110, y.4111)
// [KnfOpt] }
// [KnfOpt] let _4112: Int = Int(0)
// [KnfOpt] let join fold.4113: Int = (stream.4114: Fun([Unit], Tuple([Int, Int])), f.4115: Fun([Int, Int], Int), acc.4116: Int) {
// [KnfOpt]   let _4117: Unit = Unit
// [KnfOpt]   let _4118: Tuple([Int, Int]) = Apply(stream.4114, [_4117, ])
// [KnfOpt]   let (ok.4119: Var({val: Some(Int)}), val.4120: Var({val: Some(Int)})) = _4118
// [KnfOpt]   let _4121: Int = Int(0)
// [KnfOpt]   if (ok.4119 == _4121) then {
// [KnfOpt]     let sum.104: Int = Var(acc.4116)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _4122: Int = Apply(f.4115, [acc.4116, val.4120, ])
// [KnfOpt]     Jump(fold.4113, [stream.4114, f.4115, _4122, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.4113, [under1200.103, add.4109, _4112, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let over50.100: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let _101: Int = Int(1200)
// [KnfOpt] let rec aux.4107: Int = (y.4108: Int) {
// [KnfOpt]   if (y.4108 <= _101) then {
// [KnfOpt]     Int(0)
// [KnfOpt]   } else {
// [KnfOpt]     Int(1)
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] let _102: Fun([Int], Int) = Var(aux.4107)
// [KnfOpt] let rec aux.4123: Tuple([Int, Int]) = (u.4124: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.4125: Tuple([Int, Int]) = (u.4126: Var({val: Some(Unit)})) {
// [KnfOpt]     let _4127: Unit = Unit
// [KnfOpt]     let _4128: Tuple([Int, Int]) = Apply(over50.100, [_4127, ])
// [KnfOpt]     let (ok.4129: Var({val: Some(Int)}), val.4130: Var({val: Some(Int)})) = _4128
// [KnfOpt]     let _4131: Int = Int(0)
// [KnfOpt]     if (ok.4129 == _4131) then {
// [KnfOpt]       let _4132: Int = Int(0)
// [KnfOpt]       let _4133: Int = Int(0)
// [KnfOpt]       Tuple([_4132, _4133, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.4134: Int = Apply(_102, [val.4130, ])
// [KnfOpt]       let _4135: Int = Int(0)
// [KnfOpt]       if (r.4134 == _4135) then {
// [KnfOpt]         let _4136: Int = Int(1)
// [KnfOpt]         Tuple([_4136, val.4130, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _4137: Unit = Unit
// [KnfOpt]         Jump(aux.4125, [_4137, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.4125, [u.4124, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.4123)
// [KnfOpt] let rec add.4138: Int = (x.4139: Int, y.4140: Int) {
// [KnfOpt]   Add(x.4139, y.4140)
// [KnfOpt] }
// [KnfOpt] let _4141: Int = Int(0)
// [KnfOpt] let join fold.4142: Int = (stream.4143: Fun([Unit], Tuple([Int, Int])), f.4144: Fun([Int, Int], Int), acc.4145: Int) {
// [KnfOpt]   let _4146: Unit = Unit
// [KnfOpt]   let _4147: Tuple([Int, Int]) = Apply(stream.4143, [_4146, ])
// [KnfOpt]   let (ok.4148: Var({val: Some(Int)}), val.4149: Var({val: Some(Int)})) = _4147
// [KnfOpt]   let _4150: Int = Int(0)
// [KnfOpt]   if (ok.4148 == _4150) then {
// [KnfOpt]     let sum.104: Int = Var(acc.4145)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _4151: Int = Apply(f.4144, [acc.4145, val.4149, ])
// [KnfOpt]     Jump(fold.4142, [stream.4143, f.4144, _4151, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.4142, [under1200.103, add.4138, _4141, ])
// [KnfOpt] Inline threshold 5
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 0
// [KnfOpt] Inline decision le.83 accepted
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.4167: Int = (x.4168: Int, y.4169: Int) {
// [KnfOpt]   Add(x.4168, y.4169)
// [KnfOpt] }
// [KnfOpt] let _4170: Int = Int(0)
// [KnfOpt] let join fold.4171: Int = (stream.4172: Fun([Unit], Tuple([Int, Int])), f.4173: Fun([Int, Int], Int), acc.4174: Int) {
// [KnfOpt]   let _4175: Unit = Unit
// [KnfOpt]   let _4176: Tuple([Int, Int]) = Apply(stream.4172, [_4175, ])
// [KnfOpt]   let (ok.4177: Var({val: Some(Int)}), val.4178: Var({val: Some(Int)})) = _4176
// [KnfOpt]   let _4179: Int = Int(0)
// [KnfOpt]   if (ok.4177 == _4179) then {
// [KnfOpt]     let sum.104: Int = Var(acc.4174)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _4180: Int = Apply(f.4173, [acc.4174, val.4178, ])
// [KnfOpt]     Jump(fold.4171, [stream.4172, f.4173, _4180, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.4171, [under1200.103, add.4167, _4170, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(le) let _102: Fun([Int], Int) = Unit
// [KnfOpt] let rec aux.4181: Tuple([Int, Int]) = (u.4182: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.4183: Tuple([Int, Int]) = (u.4184: Var({val: Some(Unit)})) {
// [KnfOpt]     let _4185: Unit = Unit
// [KnfOpt]     let _4186: Tuple([Int, Int]) = Apply(over50.100, [_4185, ])
// [KnfOpt]     let (ok.4187: Var({val: Some(Int)}), val.4188: Var({val: Some(Int)})) = _4186
// [KnfOpt]     let _4189: Int = Int(0)
// [KnfOpt]     if (ok.4187 == _4189) then {
// [KnfOpt]       let _4190: Int = Int(0)
// [KnfOpt]       let _4191: Int = Int(0)
// [KnfOpt]       Tuple([_4190, _4191, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.4192: Int = Apply(_102, [val.4188, ])
// [KnfOpt]       let _4193: Int = Int(0)
// [KnfOpt]       if (r.4192 == _4193) then {
// [KnfOpt]         let _4194: Int = Int(1)
// [KnfOpt]         Tuple([_4194, val.4188, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _4195: Unit = Unit
// [KnfOpt]         Jump(aux.4183, [_4195, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.4183, [u.4182, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.4181)
// [KnfOpt] let rec add.4196: Int = (x.4197: Int, y.4198: Int) {
// [KnfOpt]   Add(x.4197, y.4198)
// [KnfOpt] }
// [KnfOpt] let _4199: Int = Int(0)
// [KnfOpt] let join fold.4200: Int = (stream.4201: Fun([Unit], Tuple([Int, Int])), f.4202: Fun([Int, Int], Int), acc.4203: Int) {
// [KnfOpt]   let _4204: Unit = Unit
// [KnfOpt]   let _4205: Tuple([Int, Int]) = Apply(stream.4201, [_4204, ])
// [KnfOpt]   let (ok.4206: Var({val: Some(Int)}), val.4207: Var({val: Some(Int)})) = _4205
// [KnfOpt]   let _4208: Int = Int(0)
// [KnfOpt]   if (ok.4206 == _4208) then {
// [KnfOpt]     let sum.104: Int = Var(acc.4203)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _4209: Int = Apply(f.4202, [acc.4203, val.4207, ])
// [KnfOpt]     Jump(fold.4200, [stream.4201, f.4202, _4209, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.4200, [under1200.103, add.4196, _4199, ])
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.4212: Int = (x.4213: Int, y.4214: Int) {
// [KnfOpt]   Add(x.4213, y.4214)
// [KnfOpt] }
// [KnfOpt] let _4215: Int = Int(0)
// [KnfOpt] let join fold.4216: Int = (stream.4217: Fun([Unit], Tuple([Int, Int])), f.4218: Fun([Int, Int], Int), acc.4219: Int) {
// [KnfOpt]   let _4220: Unit = Unit
// [KnfOpt]   let _4221: Tuple([Int, Int]) = Apply(stream.4217, [_4220, ])
// [KnfOpt]   let (ok.4222: Var({val: Some(Int)}), val.4223: Var({val: Some(Int)})) = _4221
// [KnfOpt]   let _4224: Int = Int(0)
// [KnfOpt]   if (ok.4222 == _4224) then {
// [KnfOpt]     let sum.104: Int = Var(acc.4219)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _4225: Int = Apply(f.4218, [acc.4219, val.4223, ])
// [KnfOpt]     Jump(fold.4216, [stream.4217, f.4218, _4225, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.4216, [under1200.103, add.4212, _4215, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(gt) let _99: Fun([Int], Int) = Unit
// [KnfOpt] let rec aux.4152: Tuple([Int, Int]) = (u.4153: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.4154: Tuple([Int, Int]) = (u.4155: Var({val: Some(Unit)})) {
// [KnfOpt]     let _4156: Unit = Unit
// [KnfOpt]     let _4157: Tuple([Int, Int]) = Apply(addone.97, [_4156, ])
// [KnfOpt]     let (ok.4158: Var({val: Some(Int)}), val.4159: Var({val: Some(Int)})) = _4157
// [KnfOpt]     let _4160: Int = Int(0)
// [KnfOpt]     if (ok.4158 == _4160) then {
// [KnfOpt]       let _4161: Int = Int(0)
// [KnfOpt]       let _4162: Int = Int(0)
// [KnfOpt]       Tuple([_4161, _4162, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.4163: Int = Apply(_99, [val.4159, ])
// [KnfOpt]       let _4164: Int = Int(0)
// [KnfOpt]       if (r.4163 == _4164) then {
// [KnfOpt]         let _4165: Int = Int(1)
// [KnfOpt]         Tuple([_4165, val.4159, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _4166: Unit = Unit
// [KnfOpt]         Jump(aux.4154, [_4166, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.4154, [u.4153, ])
// [KnfOpt] }
// [KnfOpt] let over50.100: Fun([Unit], Tuple([Int, Int])) = Var(aux.4152)
// [KnfOpt] let _101: Int = Int(1200)
// [KnfOpt] let rec aux.4210: Int = (y.4211: Int) {
// [KnfOpt]   if (y.4211 <= _101) then {
// [KnfOpt]     Int(0)
// [KnfOpt]   } else {
// [KnfOpt]     Int(1)
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] let _102: Fun([Int], Int) = Var(aux.4210)
// [KnfOpt] let rec aux.4226: Tuple([Int, Int]) = (u.4227: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.4228: Tuple([Int, Int]) = (u.4229: Var({val: Some(Unit)})) {
// [KnfOpt]     let _4230: Unit = Unit
// [KnfOpt]     let _4231: Tuple([Int, Int]) = Apply(over50.100, [_4230, ])
// [KnfOpt]     let (ok.4232: Var({val: Some(Int)}), val.4233: Var({val: Some(Int)})) = _4231
// [KnfOpt]     let _4234: Int = Int(0)
// [KnfOpt]     if (ok.4232 == _4234) then {
// [KnfOpt]       let _4235: Int = Int(0)
// [KnfOpt]       let _4236: Int = Int(0)
// [KnfOpt]       Tuple([_4235, _4236, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.4237: Int = Apply(_102, [val.4233, ])
// [KnfOpt]       let _4238: Int = Int(0)
// [KnfOpt]       if (r.4237 == _4238) then {
// [KnfOpt]         let _4239: Int = Int(1)
// [KnfOpt]         Tuple([_4239, val.4233, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _4240: Unit = Unit
// [KnfOpt]         Jump(aux.4228, [_4240, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.4228, [u.4227, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.4226)
// [KnfOpt] let rec add.4241: Int = (x.4242: Int, y.4243: Int) {
// [KnfOpt]   Add(x.4242, y.4243)
// [KnfOpt] }
// [KnfOpt] let _4244: Int = Int(0)
// [KnfOpt] let join fold.4245: Int = (stream.4246: Fun([Unit], Tuple([Int, Int])), f.4247: Fun([Int, Int], Int), acc.4248: Int) {
// [KnfOpt]   let _4249: Unit = Unit
// [KnfOpt]   let _4250: Tuple([Int, Int]) = Apply(stream.4246, [_4249, ])
// [KnfOpt]   let (ok.4251: Var({val: Some(Int)}), val.4252: Var({val: Some(Int)})) = _4250
// [KnfOpt]   let _4253: Int = Int(0)
// [KnfOpt]   if (ok.4251 == _4253) then {
// [KnfOpt]     let sum.104: Int = Var(acc.4248)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _4254: Int = Apply(f.4247, [acc.4248, val.4252, ])
// [KnfOpt]     Jump(fold.4245, [stream.4246, f.4247, _4254, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.4245, [under1200.103, add.4241, _4244, ])
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 5
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 0
// [KnfOpt] Inline decision le.83 accepted
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.4257: Int = (x.4258: Int, y.4259: Int) {
// [KnfOpt]   Add(x.4258, y.4259)
// [KnfOpt] }
// [KnfOpt] let _4260: Int = Int(0)
// [KnfOpt] let join fold.4261: Int = (stream.4262: Fun([Unit], Tuple([Int, Int])), f.4263: Fun([Int, Int], Int), acc.4264: Int) {
// [KnfOpt]   let _4265: Unit = Unit
// [KnfOpt]   let _4266: Tuple([Int, Int]) = Apply(stream.4262, [_4265, ])
// [KnfOpt]   let (ok.4267: Var({val: Some(Int)}), val.4268: Var({val: Some(Int)})) = _4266
// [KnfOpt]   let _4269: Int = Int(0)
// [KnfOpt]   if (ok.4267 == _4269) then {
// [KnfOpt]     let sum.104: Int = Var(acc.4264)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _4270: Int = Apply(f.4263, [acc.4264, val.4268, ])
// [KnfOpt]     Jump(fold.4261, [stream.4262, f.4263, _4270, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.4261, [under1200.103, add.4257, _4260, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(le) let _102: Fun([Int], Int) = Unit
// [KnfOpt] let rec aux.4271: Tuple([Int, Int]) = (u.4272: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.4273: Tuple([Int, Int]) = (u.4274: Var({val: Some(Unit)})) {
// [KnfOpt]     let _4275: Unit = Unit
// [KnfOpt]     let _4276: Tuple([Int, Int]) = Apply(over50.100, [_4275, ])
// [KnfOpt]     let (ok.4277: Var({val: Some(Int)}), val.4278: Var({val: Some(Int)})) = _4276
// [KnfOpt]     let _4279: Int = Int(0)
// [KnfOpt]     if (ok.4277 == _4279) then {
// [KnfOpt]       let _4280: Int = Int(0)
// [KnfOpt]       let _4281: Int = Int(0)
// [KnfOpt]       Tuple([_4280, _4281, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.4282: Int = Apply(_102, [val.4278, ])
// [KnfOpt]       let _4283: Int = Int(0)
// [KnfOpt]       if (r.4282 == _4283) then {
// [KnfOpt]         let _4284: Int = Int(1)
// [KnfOpt]         Tuple([_4284, val.4278, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _4285: Unit = Unit
// [KnfOpt]         Jump(aux.4273, [_4285, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.4273, [u.4272, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.4271)
// [KnfOpt] let rec add.4286: Int = (x.4287: Int, y.4288: Int) {
// [KnfOpt]   Add(x.4287, y.4288)
// [KnfOpt] }
// [KnfOpt] let _4289: Int = Int(0)
// [KnfOpt] let join fold.4290: Int = (stream.4291: Fun([Unit], Tuple([Int, Int])), f.4292: Fun([Int, Int], Int), acc.4293: Int) {
// [KnfOpt]   let _4294: Unit = Unit
// [KnfOpt]   let _4295: Tuple([Int, Int]) = Apply(stream.4291, [_4294, ])
// [KnfOpt]   let (ok.4296: Var({val: Some(Int)}), val.4297: Var({val: Some(Int)})) = _4295
// [KnfOpt]   let _4298: Int = Int(0)
// [KnfOpt]   if (ok.4296 == _4298) then {
// [KnfOpt]     let sum.104: Int = Var(acc.4293)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _4299: Int = Apply(f.4292, [acc.4293, val.4297, ])
// [KnfOpt]     Jump(fold.4290, [stream.4291, f.4292, _4299, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.4290, [under1200.103, add.4286, _4289, ])
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.4302: Int = (x.4303: Int, y.4304: Int) {
// [KnfOpt]   Add(x.4303, y.4304)
// [KnfOpt] }
// [KnfOpt] let _4305: Int = Int(0)
// [KnfOpt] let join fold.4306: Int = (stream.4307: Fun([Unit], Tuple([Int, Int])), f.4308: Fun([Int, Int], Int), acc.4309: Int) {
// [KnfOpt]   let _4310: Unit = Unit
// [KnfOpt]   let _4311: Tuple([Int, Int]) = Apply(stream.4307, [_4310, ])
// [KnfOpt]   let (ok.4312: Var({val: Some(Int)}), val.4313: Var({val: Some(Int)})) = _4311
// [KnfOpt]   let _4314: Int = Int(0)
// [KnfOpt]   if (ok.4312 == _4314) then {
// [KnfOpt]     let sum.104: Int = Var(acc.4309)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _4315: Int = Apply(f.4308, [acc.4309, val.4313, ])
// [KnfOpt]     Jump(fold.4306, [stream.4307, f.4308, _4315, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.4306, [under1200.103, add.4302, _4305, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let over50.100: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let _101: Int = Int(1200)
// [KnfOpt] let rec aux.4300: Int = (y.4301: Int) {
// [KnfOpt]   if (y.4301 <= _101) then {
// [KnfOpt]     Int(0)
// [KnfOpt]   } else {
// [KnfOpt]     Int(1)
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] let _102: Fun([Int], Int) = Var(aux.4300)
// [KnfOpt] let rec aux.4316: Tuple([Int, Int]) = (u.4317: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.4318: Tuple([Int, Int]) = (u.4319: Var({val: Some(Unit)})) {
// [KnfOpt]     let _4320: Unit = Unit
// [KnfOpt]     let _4321: Tuple([Int, Int]) = Apply(over50.100, [_4320, ])
// [KnfOpt]     let (ok.4322: Var({val: Some(Int)}), val.4323: Var({val: Some(Int)})) = _4321
// [KnfOpt]     let _4324: Int = Int(0)
// [KnfOpt]     if (ok.4322 == _4324) then {
// [KnfOpt]       let _4325: Int = Int(0)
// [KnfOpt]       let _4326: Int = Int(0)
// [KnfOpt]       Tuple([_4325, _4326, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.4327: Int = Apply(_102, [val.4323, ])
// [KnfOpt]       let _4328: Int = Int(0)
// [KnfOpt]       if (r.4327 == _4328) then {
// [KnfOpt]         let _4329: Int = Int(1)
// [KnfOpt]         Tuple([_4329, val.4323, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _4330: Unit = Unit
// [KnfOpt]         Jump(aux.4318, [_4330, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.4318, [u.4317, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.4316)
// [KnfOpt] let rec add.4331: Int = (x.4332: Int, y.4333: Int) {
// [KnfOpt]   Add(x.4332, y.4333)
// [KnfOpt] }
// [KnfOpt] let _4334: Int = Int(0)
// [KnfOpt] let join fold.4335: Int = (stream.4336: Fun([Unit], Tuple([Int, Int])), f.4337: Fun([Int, Int], Int), acc.4338: Int) {
// [KnfOpt]   let _4339: Unit = Unit
// [KnfOpt]   let _4340: Tuple([Int, Int]) = Apply(stream.4336, [_4339, ])
// [KnfOpt]   let (ok.4341: Var({val: Some(Int)}), val.4342: Var({val: Some(Int)})) = _4340
// [KnfOpt]   let _4343: Int = Int(0)
// [KnfOpt]   if (ok.4341 == _4343) then {
// [KnfOpt]     let sum.104: Int = Var(acc.4338)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _4344: Int = Apply(f.4337, [acc.4338, val.4342, ])
// [KnfOpt]     Jump(fold.4335, [stream.4336, f.4337, _4344, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.4335, [under1200.103, add.4331, _4334, ])
// [KnfOpt] Inline threshold 5
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 0
// [KnfOpt] Inline decision le.83 accepted
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.4360: Int = (x.4361: Int, y.4362: Int) {
// [KnfOpt]   Add(x.4361, y.4362)
// [KnfOpt] }
// [KnfOpt] let _4363: Int = Int(0)
// [KnfOpt] let join fold.4364: Int = (stream.4365: Fun([Unit], Tuple([Int, Int])), f.4366: Fun([Int, Int], Int), acc.4367: Int) {
// [KnfOpt]   let _4368: Unit = Unit
// [KnfOpt]   let _4369: Tuple([Int, Int]) = Apply(stream.4365, [_4368, ])
// [KnfOpt]   let (ok.4370: Var({val: Some(Int)}), val.4371: Var({val: Some(Int)})) = _4369
// [KnfOpt]   let _4372: Int = Int(0)
// [KnfOpt]   if (ok.4370 == _4372) then {
// [KnfOpt]     let sum.104: Int = Var(acc.4367)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _4373: Int = Apply(f.4366, [acc.4367, val.4371, ])
// [KnfOpt]     Jump(fold.4364, [stream.4365, f.4366, _4373, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.4364, [under1200.103, add.4360, _4363, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(le) let _102: Fun([Int], Int) = Unit
// [KnfOpt] let rec aux.4374: Tuple([Int, Int]) = (u.4375: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.4376: Tuple([Int, Int]) = (u.4377: Var({val: Some(Unit)})) {
// [KnfOpt]     let _4378: Unit = Unit
// [KnfOpt]     let _4379: Tuple([Int, Int]) = Apply(over50.100, [_4378, ])
// [KnfOpt]     let (ok.4380: Var({val: Some(Int)}), val.4381: Var({val: Some(Int)})) = _4379
// [KnfOpt]     let _4382: Int = Int(0)
// [KnfOpt]     if (ok.4380 == _4382) then {
// [KnfOpt]       let _4383: Int = Int(0)
// [KnfOpt]       let _4384: Int = Int(0)
// [KnfOpt]       Tuple([_4383, _4384, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.4385: Int = Apply(_102, [val.4381, ])
// [KnfOpt]       let _4386: Int = Int(0)
// [KnfOpt]       if (r.4385 == _4386) then {
// [KnfOpt]         let _4387: Int = Int(1)
// [KnfOpt]         Tuple([_4387, val.4381, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _4388: Unit = Unit
// [KnfOpt]         Jump(aux.4376, [_4388, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.4376, [u.4375, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.4374)
// [KnfOpt] let rec add.4389: Int = (x.4390: Int, y.4391: Int) {
// [KnfOpt]   Add(x.4390, y.4391)
// [KnfOpt] }
// [KnfOpt] let _4392: Int = Int(0)
// [KnfOpt] let join fold.4393: Int = (stream.4394: Fun([Unit], Tuple([Int, Int])), f.4395: Fun([Int, Int], Int), acc.4396: Int) {
// [KnfOpt]   let _4397: Unit = Unit
// [KnfOpt]   let _4398: Tuple([Int, Int]) = Apply(stream.4394, [_4397, ])
// [KnfOpt]   let (ok.4399: Var({val: Some(Int)}), val.4400: Var({val: Some(Int)})) = _4398
// [KnfOpt]   let _4401: Int = Int(0)
// [KnfOpt]   if (ok.4399 == _4401) then {
// [KnfOpt]     let sum.104: Int = Var(acc.4396)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _4402: Int = Apply(f.4395, [acc.4396, val.4400, ])
// [KnfOpt]     Jump(fold.4393, [stream.4394, f.4395, _4402, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.4393, [under1200.103, add.4389, _4392, ])
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.4405: Int = (x.4406: Int, y.4407: Int) {
// [KnfOpt]   Add(x.4406, y.4407)
// [KnfOpt] }
// [KnfOpt] let _4408: Int = Int(0)
// [KnfOpt] let join fold.4409: Int = (stream.4410: Fun([Unit], Tuple([Int, Int])), f.4411: Fun([Int, Int], Int), acc.4412: Int) {
// [KnfOpt]   let _4413: Unit = Unit
// [KnfOpt]   let _4414: Tuple([Int, Int]) = Apply(stream.4410, [_4413, ])
// [KnfOpt]   let (ok.4415: Var({val: Some(Int)}), val.4416: Var({val: Some(Int)})) = _4414
// [KnfOpt]   let _4417: Int = Int(0)
// [KnfOpt]   if (ok.4415 == _4417) then {
// [KnfOpt]     let sum.104: Int = Var(acc.4412)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _4418: Int = Apply(f.4411, [acc.4412, val.4416, ])
// [KnfOpt]     Jump(fold.4409, [stream.4410, f.4411, _4418, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.4409, [under1200.103, add.4405, _4408, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(map) let addone.97: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let _98: Int = Int(50)
// [KnfOpt] let rec aux.4255: Int = (y.4256: Int) {
// [KnfOpt]   if (_98 <= y.4256) then {
// [KnfOpt]     Int(0)
// [KnfOpt]   } else {
// [KnfOpt]     Int(1)
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] let _99: Fun([Int], Int) = Var(aux.4255)
// [KnfOpt] let rec aux.4345: Tuple([Int, Int]) = (u.4346: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.4347: Tuple([Int, Int]) = (u.4348: Var({val: Some(Unit)})) {
// [KnfOpt]     let _4349: Unit = Unit
// [KnfOpt]     let _4350: Tuple([Int, Int]) = Apply(addone.97, [_4349, ])
// [KnfOpt]     let (ok.4351: Var({val: Some(Int)}), val.4352: Var({val: Some(Int)})) = _4350
// [KnfOpt]     let _4353: Int = Int(0)
// [KnfOpt]     if (ok.4351 == _4353) then {
// [KnfOpt]       let _4354: Int = Int(0)
// [KnfOpt]       let _4355: Int = Int(0)
// [KnfOpt]       Tuple([_4354, _4355, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.4356: Int = Apply(_99, [val.4352, ])
// [KnfOpt]       let _4357: Int = Int(0)
// [KnfOpt]       if (r.4356 == _4357) then {
// [KnfOpt]         let _4358: Int = Int(1)
// [KnfOpt]         Tuple([_4358, val.4352, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _4359: Unit = Unit
// [KnfOpt]         Jump(aux.4347, [_4359, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.4347, [u.4346, ])
// [KnfOpt] }
// [KnfOpt] let over50.100: Fun([Unit], Tuple([Int, Int])) = Var(aux.4345)
// [KnfOpt] let _101: Int = Int(1200)
// [KnfOpt] let rec aux.4403: Int = (y.4404: Int) {
// [KnfOpt]   if (y.4404 <= _101) then {
// [KnfOpt]     Int(0)
// [KnfOpt]   } else {
// [KnfOpt]     Int(1)
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] let _102: Fun([Int], Int) = Var(aux.4403)
// [KnfOpt] let rec aux.4419: Tuple([Int, Int]) = (u.4420: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.4421: Tuple([Int, Int]) = (u.4422: Var({val: Some(Unit)})) {
// [KnfOpt]     let _4423: Unit = Unit
// [KnfOpt]     let _4424: Tuple([Int, Int]) = Apply(over50.100, [_4423, ])
// [KnfOpt]     let (ok.4425: Var({val: Some(Int)}), val.4426: Var({val: Some(Int)})) = _4424
// [KnfOpt]     let _4427: Int = Int(0)
// [KnfOpt]     if (ok.4425 == _4427) then {
// [KnfOpt]       let _4428: Int = Int(0)
// [KnfOpt]       let _4429: Int = Int(0)
// [KnfOpt]       Tuple([_4428, _4429, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.4430: Int = Apply(_102, [val.4426, ])
// [KnfOpt]       let _4431: Int = Int(0)
// [KnfOpt]       if (r.4430 == _4431) then {
// [KnfOpt]         let _4432: Int = Int(1)
// [KnfOpt]         Tuple([_4432, val.4426, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _4433: Unit = Unit
// [KnfOpt]         Jump(aux.4421, [_4433, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.4421, [u.4420, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.4419)
// [KnfOpt] let rec add.4434: Int = (x.4435: Int, y.4436: Int) {
// [KnfOpt]   Add(x.4435, y.4436)
// [KnfOpt] }
// [KnfOpt] let _4437: Int = Int(0)
// [KnfOpt] let join fold.4438: Int = (stream.4439: Fun([Unit], Tuple([Int, Int])), f.4440: Fun([Int, Int], Int), acc.4441: Int) {
// [KnfOpt]   let _4442: Unit = Unit
// [KnfOpt]   let _4443: Tuple([Int, Int]) = Apply(stream.4439, [_4442, ])
// [KnfOpt]   let (ok.4444: Var({val: Some(Int)}), val.4445: Var({val: Some(Int)})) = _4443
// [KnfOpt]   let _4446: Int = Int(0)
// [KnfOpt]   if (ok.4444 == _4446) then {
// [KnfOpt]     let sum.104: Int = Var(acc.4441)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _4447: Int = Apply(f.4440, [acc.4441, val.4445, ])
// [KnfOpt]     Jump(fold.4438, [stream.4439, f.4440, _4447, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.4438, [under1200.103, add.4434, _4437, ])
// [KnfOpt] Inline threshold 5
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 0
// [KnfOpt] Inline decision gt.79 accepted
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 5
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 0
// [KnfOpt] Inline decision le.83 accepted
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.4459: Int = (x.4460: Int, y.4461: Int) {
// [KnfOpt]   Add(x.4460, y.4461)
// [KnfOpt] }
// [KnfOpt] let _4462: Int = Int(0)
// [KnfOpt] let join fold.4463: Int = (stream.4464: Fun([Unit], Tuple([Int, Int])), f.4465: Fun([Int, Int], Int), acc.4466: Int) {
// [KnfOpt]   let _4467: Unit = Unit
// [KnfOpt]   let _4468: Tuple([Int, Int]) = Apply(stream.4464, [_4467, ])
// [KnfOpt]   let (ok.4469: Var({val: Some(Int)}), val.4470: Var({val: Some(Int)})) = _4468
// [KnfOpt]   let _4471: Int = Int(0)
// [KnfOpt]   if (ok.4469 == _4471) then {
// [KnfOpt]     let sum.104: Int = Var(acc.4466)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _4472: Int = Apply(f.4465, [acc.4466, val.4470, ])
// [KnfOpt]     Jump(fold.4463, [stream.4464, f.4465, _4472, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.4463, [under1200.103, add.4459, _4462, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(le) let _102: Fun([Int], Int) = Unit
// [KnfOpt] let rec aux.4473: Tuple([Int, Int]) = (u.4474: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.4475: Tuple([Int, Int]) = (u.4476: Var({val: Some(Unit)})) {
// [KnfOpt]     let _4477: Unit = Unit
// [KnfOpt]     let _4478: Tuple([Int, Int]) = Apply(over50.100, [_4477, ])
// [KnfOpt]     let (ok.4479: Var({val: Some(Int)}), val.4480: Var({val: Some(Int)})) = _4478
// [KnfOpt]     let _4481: Int = Int(0)
// [KnfOpt]     if (ok.4479 == _4481) then {
// [KnfOpt]       let _4482: Int = Int(0)
// [KnfOpt]       let _4483: Int = Int(0)
// [KnfOpt]       Tuple([_4482, _4483, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.4484: Int = Apply(_102, [val.4480, ])
// [KnfOpt]       let _4485: Int = Int(0)
// [KnfOpt]       if (r.4484 == _4485) then {
// [KnfOpt]         let _4486: Int = Int(1)
// [KnfOpt]         Tuple([_4486, val.4480, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _4487: Unit = Unit
// [KnfOpt]         Jump(aux.4475, [_4487, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.4475, [u.4474, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.4473)
// [KnfOpt] let rec add.4488: Int = (x.4489: Int, y.4490: Int) {
// [KnfOpt]   Add(x.4489, y.4490)
// [KnfOpt] }
// [KnfOpt] let _4491: Int = Int(0)
// [KnfOpt] let join fold.4492: Int = (stream.4493: Fun([Unit], Tuple([Int, Int])), f.4494: Fun([Int, Int], Int), acc.4495: Int) {
// [KnfOpt]   let _4496: Unit = Unit
// [KnfOpt]   let _4497: Tuple([Int, Int]) = Apply(stream.4493, [_4496, ])
// [KnfOpt]   let (ok.4498: Var({val: Some(Int)}), val.4499: Var({val: Some(Int)})) = _4497
// [KnfOpt]   let _4500: Int = Int(0)
// [KnfOpt]   if (ok.4498 == _4500) then {
// [KnfOpt]     let sum.104: Int = Var(acc.4495)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _4501: Int = Apply(f.4494, [acc.4495, val.4499, ])
// [KnfOpt]     Jump(fold.4492, [stream.4493, f.4494, _4501, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.4492, [under1200.103, add.4488, _4491, ])
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.4504: Int = (x.4505: Int, y.4506: Int) {
// [KnfOpt]   Add(x.4505, y.4506)
// [KnfOpt] }
// [KnfOpt] let _4507: Int = Int(0)
// [KnfOpt] let join fold.4508: Int = (stream.4509: Fun([Unit], Tuple([Int, Int])), f.4510: Fun([Int, Int], Int), acc.4511: Int) {
// [KnfOpt]   let _4512: Unit = Unit
// [KnfOpt]   let _4513: Tuple([Int, Int]) = Apply(stream.4509, [_4512, ])
// [KnfOpt]   let (ok.4514: Var({val: Some(Int)}), val.4515: Var({val: Some(Int)})) = _4513
// [KnfOpt]   let _4516: Int = Int(0)
// [KnfOpt]   if (ok.4514 == _4516) then {
// [KnfOpt]     let sum.104: Int = Var(acc.4511)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _4517: Int = Apply(f.4510, [acc.4511, val.4515, ])
// [KnfOpt]     Jump(fold.4508, [stream.4509, f.4510, _4517, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.4508, [under1200.103, add.4504, _4507, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let over50.100: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let _101: Int = Int(1200)
// [KnfOpt] let rec aux.4502: Int = (y.4503: Int) {
// [KnfOpt]   if (y.4503 <= _101) then {
// [KnfOpt]     Int(0)
// [KnfOpt]   } else {
// [KnfOpt]     Int(1)
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] let _102: Fun([Int], Int) = Var(aux.4502)
// [KnfOpt] let rec aux.4518: Tuple([Int, Int]) = (u.4519: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.4520: Tuple([Int, Int]) = (u.4521: Var({val: Some(Unit)})) {
// [KnfOpt]     let _4522: Unit = Unit
// [KnfOpt]     let _4523: Tuple([Int, Int]) = Apply(over50.100, [_4522, ])
// [KnfOpt]     let (ok.4524: Var({val: Some(Int)}), val.4525: Var({val: Some(Int)})) = _4523
// [KnfOpt]     let _4526: Int = Int(0)
// [KnfOpt]     if (ok.4524 == _4526) then {
// [KnfOpt]       let _4527: Int = Int(0)
// [KnfOpt]       let _4528: Int = Int(0)
// [KnfOpt]       Tuple([_4527, _4528, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.4529: Int = Apply(_102, [val.4525, ])
// [KnfOpt]       let _4530: Int = Int(0)
// [KnfOpt]       if (r.4529 == _4530) then {
// [KnfOpt]         let _4531: Int = Int(1)
// [KnfOpt]         Tuple([_4531, val.4525, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _4532: Unit = Unit
// [KnfOpt]         Jump(aux.4520, [_4532, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.4520, [u.4519, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.4518)
// [KnfOpt] let rec add.4533: Int = (x.4534: Int, y.4535: Int) {
// [KnfOpt]   Add(x.4534, y.4535)
// [KnfOpt] }
// [KnfOpt] let _4536: Int = Int(0)
// [KnfOpt] let join fold.4537: Int = (stream.4538: Fun([Unit], Tuple([Int, Int])), f.4539: Fun([Int, Int], Int), acc.4540: Int) {
// [KnfOpt]   let _4541: Unit = Unit
// [KnfOpt]   let _4542: Tuple([Int, Int]) = Apply(stream.4538, [_4541, ])
// [KnfOpt]   let (ok.4543: Var({val: Some(Int)}), val.4544: Var({val: Some(Int)})) = _4542
// [KnfOpt]   let _4545: Int = Int(0)
// [KnfOpt]   if (ok.4543 == _4545) then {
// [KnfOpt]     let sum.104: Int = Var(acc.4540)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _4546: Int = Apply(f.4539, [acc.4540, val.4544, ])
// [KnfOpt]     Jump(fold.4537, [stream.4538, f.4539, _4546, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.4537, [under1200.103, add.4533, _4536, ])
// [KnfOpt] Inline threshold 5
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 0
// [KnfOpt] Inline decision le.83 accepted
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.4562: Int = (x.4563: Int, y.4564: Int) {
// [KnfOpt]   Add(x.4563, y.4564)
// [KnfOpt] }
// [KnfOpt] let _4565: Int = Int(0)
// [KnfOpt] let join fold.4566: Int = (stream.4567: Fun([Unit], Tuple([Int, Int])), f.4568: Fun([Int, Int], Int), acc.4569: Int) {
// [KnfOpt]   let _4570: Unit = Unit
// [KnfOpt]   let _4571: Tuple([Int, Int]) = Apply(stream.4567, [_4570, ])
// [KnfOpt]   let (ok.4572: Var({val: Some(Int)}), val.4573: Var({val: Some(Int)})) = _4571
// [KnfOpt]   let _4574: Int = Int(0)
// [KnfOpt]   if (ok.4572 == _4574) then {
// [KnfOpt]     let sum.104: Int = Var(acc.4569)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _4575: Int = Apply(f.4568, [acc.4569, val.4573, ])
// [KnfOpt]     Jump(fold.4566, [stream.4567, f.4568, _4575, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.4566, [under1200.103, add.4562, _4565, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(le) let _102: Fun([Int], Int) = Unit
// [KnfOpt] let rec aux.4576: Tuple([Int, Int]) = (u.4577: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.4578: Tuple([Int, Int]) = (u.4579: Var({val: Some(Unit)})) {
// [KnfOpt]     let _4580: Unit = Unit
// [KnfOpt]     let _4581: Tuple([Int, Int]) = Apply(over50.100, [_4580, ])
// [KnfOpt]     let (ok.4582: Var({val: Some(Int)}), val.4583: Var({val: Some(Int)})) = _4581
// [KnfOpt]     let _4584: Int = Int(0)
// [KnfOpt]     if (ok.4582 == _4584) then {
// [KnfOpt]       let _4585: Int = Int(0)
// [KnfOpt]       let _4586: Int = Int(0)
// [KnfOpt]       Tuple([_4585, _4586, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.4587: Int = Apply(_102, [val.4583, ])
// [KnfOpt]       let _4588: Int = Int(0)
// [KnfOpt]       if (r.4587 == _4588) then {
// [KnfOpt]         let _4589: Int = Int(1)
// [KnfOpt]         Tuple([_4589, val.4583, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _4590: Unit = Unit
// [KnfOpt]         Jump(aux.4578, [_4590, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.4578, [u.4577, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.4576)
// [KnfOpt] let rec add.4591: Int = (x.4592: Int, y.4593: Int) {
// [KnfOpt]   Add(x.4592, y.4593)
// [KnfOpt] }
// [KnfOpt] let _4594: Int = Int(0)
// [KnfOpt] let join fold.4595: Int = (stream.4596: Fun([Unit], Tuple([Int, Int])), f.4597: Fun([Int, Int], Int), acc.4598: Int) {
// [KnfOpt]   let _4599: Unit = Unit
// [KnfOpt]   let _4600: Tuple([Int, Int]) = Apply(stream.4596, [_4599, ])
// [KnfOpt]   let (ok.4601: Var({val: Some(Int)}), val.4602: Var({val: Some(Int)})) = _4600
// [KnfOpt]   let _4603: Int = Int(0)
// [KnfOpt]   if (ok.4601 == _4603) then {
// [KnfOpt]     let sum.104: Int = Var(acc.4598)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _4604: Int = Apply(f.4597, [acc.4598, val.4602, ])
// [KnfOpt]     Jump(fold.4595, [stream.4596, f.4597, _4604, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.4595, [under1200.103, add.4591, _4594, ])
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.4607: Int = (x.4608: Int, y.4609: Int) {
// [KnfOpt]   Add(x.4608, y.4609)
// [KnfOpt] }
// [KnfOpt] let _4610: Int = Int(0)
// [KnfOpt] let join fold.4611: Int = (stream.4612: Fun([Unit], Tuple([Int, Int])), f.4613: Fun([Int, Int], Int), acc.4614: Int) {
// [KnfOpt]   let _4615: Unit = Unit
// [KnfOpt]   let _4616: Tuple([Int, Int]) = Apply(stream.4612, [_4615, ])
// [KnfOpt]   let (ok.4617: Var({val: Some(Int)}), val.4618: Var({val: Some(Int)})) = _4616
// [KnfOpt]   let _4619: Int = Int(0)
// [KnfOpt]   if (ok.4617 == _4619) then {
// [KnfOpt]     let sum.104: Int = Var(acc.4614)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _4620: Int = Apply(f.4613, [acc.4614, val.4618, ])
// [KnfOpt]     Jump(fold.4611, [stream.4612, f.4613, _4620, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.4611, [under1200.103, add.4607, _4610, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(gt) let _99: Fun([Int], Int) = Unit
// [KnfOpt] let rec aux.4547: Tuple([Int, Int]) = (u.4548: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.4549: Tuple([Int, Int]) = (u.4550: Var({val: Some(Unit)})) {
// [KnfOpt]     let _4551: Unit = Unit
// [KnfOpt]     let _4552: Tuple([Int, Int]) = Apply(addone.97, [_4551, ])
// [KnfOpt]     let (ok.4553: Var({val: Some(Int)}), val.4554: Var({val: Some(Int)})) = _4552
// [KnfOpt]     let _4555: Int = Int(0)
// [KnfOpt]     if (ok.4553 == _4555) then {
// [KnfOpt]       let _4556: Int = Int(0)
// [KnfOpt]       let _4557: Int = Int(0)
// [KnfOpt]       Tuple([_4556, _4557, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.4558: Int = Apply(_99, [val.4554, ])
// [KnfOpt]       let _4559: Int = Int(0)
// [KnfOpt]       if (r.4558 == _4559) then {
// [KnfOpt]         let _4560: Int = Int(1)
// [KnfOpt]         Tuple([_4560, val.4554, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _4561: Unit = Unit
// [KnfOpt]         Jump(aux.4549, [_4561, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.4549, [u.4548, ])
// [KnfOpt] }
// [KnfOpt] let over50.100: Fun([Unit], Tuple([Int, Int])) = Var(aux.4547)
// [KnfOpt] let _101: Int = Int(1200)
// [KnfOpt] let rec aux.4605: Int = (y.4606: Int) {
// [KnfOpt]   if (y.4606 <= _101) then {
// [KnfOpt]     Int(0)
// [KnfOpt]   } else {
// [KnfOpt]     Int(1)
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] let _102: Fun([Int], Int) = Var(aux.4605)
// [KnfOpt] let rec aux.4621: Tuple([Int, Int]) = (u.4622: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.4623: Tuple([Int, Int]) = (u.4624: Var({val: Some(Unit)})) {
// [KnfOpt]     let _4625: Unit = Unit
// [KnfOpt]     let _4626: Tuple([Int, Int]) = Apply(over50.100, [_4625, ])
// [KnfOpt]     let (ok.4627: Var({val: Some(Int)}), val.4628: Var({val: Some(Int)})) = _4626
// [KnfOpt]     let _4629: Int = Int(0)
// [KnfOpt]     if (ok.4627 == _4629) then {
// [KnfOpt]       let _4630: Int = Int(0)
// [KnfOpt]       let _4631: Int = Int(0)
// [KnfOpt]       Tuple([_4630, _4631, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.4632: Int = Apply(_102, [val.4628, ])
// [KnfOpt]       let _4633: Int = Int(0)
// [KnfOpt]       if (r.4632 == _4633) then {
// [KnfOpt]         let _4634: Int = Int(1)
// [KnfOpt]         Tuple([_4634, val.4628, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _4635: Unit = Unit
// [KnfOpt]         Jump(aux.4623, [_4635, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.4623, [u.4622, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.4621)
// [KnfOpt] let rec add.4636: Int = (x.4637: Int, y.4638: Int) {
// [KnfOpt]   Add(x.4637, y.4638)
// [KnfOpt] }
// [KnfOpt] let _4639: Int = Int(0)
// [KnfOpt] let join fold.4640: Int = (stream.4641: Fun([Unit], Tuple([Int, Int])), f.4642: Fun([Int, Int], Int), acc.4643: Int) {
// [KnfOpt]   let _4644: Unit = Unit
// [KnfOpt]   let _4645: Tuple([Int, Int]) = Apply(stream.4641, [_4644, ])
// [KnfOpt]   let (ok.4646: Var({val: Some(Int)}), val.4647: Var({val: Some(Int)})) = _4645
// [KnfOpt]   let _4648: Int = Int(0)
// [KnfOpt]   if (ok.4646 == _4648) then {
// [KnfOpt]     let sum.104: Int = Var(acc.4643)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _4649: Int = Apply(f.4642, [acc.4643, val.4647, ])
// [KnfOpt]     Jump(fold.4640, [stream.4641, f.4642, _4649, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.4640, [under1200.103, add.4636, _4639, ])
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 5
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 0
// [KnfOpt] Inline decision le.83 accepted
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.4652: Int = (x.4653: Int, y.4654: Int) {
// [KnfOpt]   Add(x.4653, y.4654)
// [KnfOpt] }
// [KnfOpt] let _4655: Int = Int(0)
// [KnfOpt] let join fold.4656: Int = (stream.4657: Fun([Unit], Tuple([Int, Int])), f.4658: Fun([Int, Int], Int), acc.4659: Int) {
// [KnfOpt]   let _4660: Unit = Unit
// [KnfOpt]   let _4661: Tuple([Int, Int]) = Apply(stream.4657, [_4660, ])
// [KnfOpt]   let (ok.4662: Var({val: Some(Int)}), val.4663: Var({val: Some(Int)})) = _4661
// [KnfOpt]   let _4664: Int = Int(0)
// [KnfOpt]   if (ok.4662 == _4664) then {
// [KnfOpt]     let sum.104: Int = Var(acc.4659)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _4665: Int = Apply(f.4658, [acc.4659, val.4663, ])
// [KnfOpt]     Jump(fold.4656, [stream.4657, f.4658, _4665, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.4656, [under1200.103, add.4652, _4655, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(le) let _102: Fun([Int], Int) = Unit
// [KnfOpt] let rec aux.4666: Tuple([Int, Int]) = (u.4667: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.4668: Tuple([Int, Int]) = (u.4669: Var({val: Some(Unit)})) {
// [KnfOpt]     let _4670: Unit = Unit
// [KnfOpt]     let _4671: Tuple([Int, Int]) = Apply(over50.100, [_4670, ])
// [KnfOpt]     let (ok.4672: Var({val: Some(Int)}), val.4673: Var({val: Some(Int)})) = _4671
// [KnfOpt]     let _4674: Int = Int(0)
// [KnfOpt]     if (ok.4672 == _4674) then {
// [KnfOpt]       let _4675: Int = Int(0)
// [KnfOpt]       let _4676: Int = Int(0)
// [KnfOpt]       Tuple([_4675, _4676, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.4677: Int = Apply(_102, [val.4673, ])
// [KnfOpt]       let _4678: Int = Int(0)
// [KnfOpt]       if (r.4677 == _4678) then {
// [KnfOpt]         let _4679: Int = Int(1)
// [KnfOpt]         Tuple([_4679, val.4673, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _4680: Unit = Unit
// [KnfOpt]         Jump(aux.4668, [_4680, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.4668, [u.4667, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.4666)
// [KnfOpt] let rec add.4681: Int = (x.4682: Int, y.4683: Int) {
// [KnfOpt]   Add(x.4682, y.4683)
// [KnfOpt] }
// [KnfOpt] let _4684: Int = Int(0)
// [KnfOpt] let join fold.4685: Int = (stream.4686: Fun([Unit], Tuple([Int, Int])), f.4687: Fun([Int, Int], Int), acc.4688: Int) {
// [KnfOpt]   let _4689: Unit = Unit
// [KnfOpt]   let _4690: Tuple([Int, Int]) = Apply(stream.4686, [_4689, ])
// [KnfOpt]   let (ok.4691: Var({val: Some(Int)}), val.4692: Var({val: Some(Int)})) = _4690
// [KnfOpt]   let _4693: Int = Int(0)
// [KnfOpt]   if (ok.4691 == _4693) then {
// [KnfOpt]     let sum.104: Int = Var(acc.4688)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _4694: Int = Apply(f.4687, [acc.4688, val.4692, ])
// [KnfOpt]     Jump(fold.4685, [stream.4686, f.4687, _4694, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.4685, [under1200.103, add.4681, _4684, ])
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.4697: Int = (x.4698: Int, y.4699: Int) {
// [KnfOpt]   Add(x.4698, y.4699)
// [KnfOpt] }
// [KnfOpt] let _4700: Int = Int(0)
// [KnfOpt] let join fold.4701: Int = (stream.4702: Fun([Unit], Tuple([Int, Int])), f.4703: Fun([Int, Int], Int), acc.4704: Int) {
// [KnfOpt]   let _4705: Unit = Unit
// [KnfOpt]   let _4706: Tuple([Int, Int]) = Apply(stream.4702, [_4705, ])
// [KnfOpt]   let (ok.4707: Var({val: Some(Int)}), val.4708: Var({val: Some(Int)})) = _4706
// [KnfOpt]   let _4709: Int = Int(0)
// [KnfOpt]   if (ok.4707 == _4709) then {
// [KnfOpt]     let sum.104: Int = Var(acc.4704)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _4710: Int = Apply(f.4703, [acc.4704, val.4708, ])
// [KnfOpt]     Jump(fold.4701, [stream.4702, f.4703, _4710, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.4701, [under1200.103, add.4697, _4700, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let over50.100: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let _101: Int = Int(1200)
// [KnfOpt] let rec aux.4695: Int = (y.4696: Int) {
// [KnfOpt]   if (y.4696 <= _101) then {
// [KnfOpt]     Int(0)
// [KnfOpt]   } else {
// [KnfOpt]     Int(1)
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] let _102: Fun([Int], Int) = Var(aux.4695)
// [KnfOpt] let rec aux.4711: Tuple([Int, Int]) = (u.4712: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.4713: Tuple([Int, Int]) = (u.4714: Var({val: Some(Unit)})) {
// [KnfOpt]     let _4715: Unit = Unit
// [KnfOpt]     let _4716: Tuple([Int, Int]) = Apply(over50.100, [_4715, ])
// [KnfOpt]     let (ok.4717: Var({val: Some(Int)}), val.4718: Var({val: Some(Int)})) = _4716
// [KnfOpt]     let _4719: Int = Int(0)
// [KnfOpt]     if (ok.4717 == _4719) then {
// [KnfOpt]       let _4720: Int = Int(0)
// [KnfOpt]       let _4721: Int = Int(0)
// [KnfOpt]       Tuple([_4720, _4721, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.4722: Int = Apply(_102, [val.4718, ])
// [KnfOpt]       let _4723: Int = Int(0)
// [KnfOpt]       if (r.4722 == _4723) then {
// [KnfOpt]         let _4724: Int = Int(1)
// [KnfOpt]         Tuple([_4724, val.4718, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _4725: Unit = Unit
// [KnfOpt]         Jump(aux.4713, [_4725, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.4713, [u.4712, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.4711)
// [KnfOpt] let rec add.4726: Int = (x.4727: Int, y.4728: Int) {
// [KnfOpt]   Add(x.4727, y.4728)
// [KnfOpt] }
// [KnfOpt] let _4729: Int = Int(0)
// [KnfOpt] let join fold.4730: Int = (stream.4731: Fun([Unit], Tuple([Int, Int])), f.4732: Fun([Int, Int], Int), acc.4733: Int) {
// [KnfOpt]   let _4734: Unit = Unit
// [KnfOpt]   let _4735: Tuple([Int, Int]) = Apply(stream.4731, [_4734, ])
// [KnfOpt]   let (ok.4736: Var({val: Some(Int)}), val.4737: Var({val: Some(Int)})) = _4735
// [KnfOpt]   let _4738: Int = Int(0)
// [KnfOpt]   if (ok.4736 == _4738) then {
// [KnfOpt]     let sum.104: Int = Var(acc.4733)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _4739: Int = Apply(f.4732, [acc.4733, val.4737, ])
// [KnfOpt]     Jump(fold.4730, [stream.4731, f.4732, _4739, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.4730, [under1200.103, add.4726, _4729, ])
// [KnfOpt] Inline threshold 5
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 0
// [KnfOpt] Inline decision le.83 accepted
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.4755: Int = (x.4756: Int, y.4757: Int) {
// [KnfOpt]   Add(x.4756, y.4757)
// [KnfOpt] }
// [KnfOpt] let _4758: Int = Int(0)
// [KnfOpt] let join fold.4759: Int = (stream.4760: Fun([Unit], Tuple([Int, Int])), f.4761: Fun([Int, Int], Int), acc.4762: Int) {
// [KnfOpt]   let _4763: Unit = Unit
// [KnfOpt]   let _4764: Tuple([Int, Int]) = Apply(stream.4760, [_4763, ])
// [KnfOpt]   let (ok.4765: Var({val: Some(Int)}), val.4766: Var({val: Some(Int)})) = _4764
// [KnfOpt]   let _4767: Int = Int(0)
// [KnfOpt]   if (ok.4765 == _4767) then {
// [KnfOpt]     let sum.104: Int = Var(acc.4762)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _4768: Int = Apply(f.4761, [acc.4762, val.4766, ])
// [KnfOpt]     Jump(fold.4759, [stream.4760, f.4761, _4768, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.4759, [under1200.103, add.4755, _4758, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(le) let _102: Fun([Int], Int) = Unit
// [KnfOpt] let rec aux.4769: Tuple([Int, Int]) = (u.4770: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.4771: Tuple([Int, Int]) = (u.4772: Var({val: Some(Unit)})) {
// [KnfOpt]     let _4773: Unit = Unit
// [KnfOpt]     let _4774: Tuple([Int, Int]) = Apply(over50.100, [_4773, ])
// [KnfOpt]     let (ok.4775: Var({val: Some(Int)}), val.4776: Var({val: Some(Int)})) = _4774
// [KnfOpt]     let _4777: Int = Int(0)
// [KnfOpt]     if (ok.4775 == _4777) then {
// [KnfOpt]       let _4778: Int = Int(0)
// [KnfOpt]       let _4779: Int = Int(0)
// [KnfOpt]       Tuple([_4778, _4779, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.4780: Int = Apply(_102, [val.4776, ])
// [KnfOpt]       let _4781: Int = Int(0)
// [KnfOpt]       if (r.4780 == _4781) then {
// [KnfOpt]         let _4782: Int = Int(1)
// [KnfOpt]         Tuple([_4782, val.4776, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _4783: Unit = Unit
// [KnfOpt]         Jump(aux.4771, [_4783, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.4771, [u.4770, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.4769)
// [KnfOpt] let rec add.4784: Int = (x.4785: Int, y.4786: Int) {
// [KnfOpt]   Add(x.4785, y.4786)
// [KnfOpt] }
// [KnfOpt] let _4787: Int = Int(0)
// [KnfOpt] let join fold.4788: Int = (stream.4789: Fun([Unit], Tuple([Int, Int])), f.4790: Fun([Int, Int], Int), acc.4791: Int) {
// [KnfOpt]   let _4792: Unit = Unit
// [KnfOpt]   let _4793: Tuple([Int, Int]) = Apply(stream.4789, [_4792, ])
// [KnfOpt]   let (ok.4794: Var({val: Some(Int)}), val.4795: Var({val: Some(Int)})) = _4793
// [KnfOpt]   let _4796: Int = Int(0)
// [KnfOpt]   if (ok.4794 == _4796) then {
// [KnfOpt]     let sum.104: Int = Var(acc.4791)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _4797: Int = Apply(f.4790, [acc.4791, val.4795, ])
// [KnfOpt]     Jump(fold.4788, [stream.4789, f.4790, _4797, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.4788, [under1200.103, add.4784, _4787, ])
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.4800: Int = (x.4801: Int, y.4802: Int) {
// [KnfOpt]   Add(x.4801, y.4802)
// [KnfOpt] }
// [KnfOpt] let _4803: Int = Int(0)
// [KnfOpt] let join fold.4804: Int = (stream.4805: Fun([Unit], Tuple([Int, Int])), f.4806: Fun([Int, Int], Int), acc.4807: Int) {
// [KnfOpt]   let _4808: Unit = Unit
// [KnfOpt]   let _4809: Tuple([Int, Int]) = Apply(stream.4805, [_4808, ])
// [KnfOpt]   let (ok.4810: Var({val: Some(Int)}), val.4811: Var({val: Some(Int)})) = _4809
// [KnfOpt]   let _4812: Int = Int(0)
// [KnfOpt]   if (ok.4810 == _4812) then {
// [KnfOpt]     let sum.104: Int = Var(acc.4807)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _4813: Int = Apply(f.4806, [acc.4807, val.4811, ])
// [KnfOpt]     Jump(fold.4804, [stream.4805, f.4806, _4813, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.4804, [under1200.103, add.4800, _4803, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(concat) let catt.94: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let _95: Int = Int(1)
// [KnfOpt] let rec aux.4062: Int = (y.4063: Int) {
// [KnfOpt]   Add(_95, y.4063)
// [KnfOpt] }
// [KnfOpt] let _96: Fun([Int], Int) = Var(aux.4062)
// [KnfOpt] let rec aux.4448: Tuple([Int, Int]) = (u.4449: Var({val: Some(Unit)})) {
// [KnfOpt]   let _4450: Unit = Unit
// [KnfOpt]   let _4451: Tuple([Int, Int]) = Apply(catt.94, [_4450, ])
// [KnfOpt]   let (ok.4452: Var({val: Some(Int)}), val.4453: Var({val: Some(Int)})) = _4451
// [KnfOpt]   let _4454: Int = Int(0)
// [KnfOpt]   if (ok.4452 == _4454) then {
// [KnfOpt]     let _4455: Int = Int(0)
// [KnfOpt]     let _4456: Int = Int(0)
// [KnfOpt]     Tuple([_4455, _4456, ])
// [KnfOpt]   } else {
// [KnfOpt]     let _4457: Int = Int(1)
// [KnfOpt]     let _4458: Int = Apply(_96, [val.4453, ])
// [KnfOpt]     Tuple([_4457, _4458, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] let addone.97: Fun([Unit], Tuple([Int, Int])) = Var(aux.4448)
// [KnfOpt] let _98: Int = Int(50)
// [KnfOpt] let rec aux.4650: Int = (y.4651: Int) {
// [KnfOpt]   if (_98 <= y.4651) then {
// [KnfOpt]     Int(0)
// [KnfOpt]   } else {
// [KnfOpt]     Int(1)
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] let _99: Fun([Int], Int) = Var(aux.4650)
// [KnfOpt] let rec aux.4740: Tuple([Int, Int]) = (u.4741: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.4742: Tuple([Int, Int]) = (u.4743: Var({val: Some(Unit)})) {
// [KnfOpt]     let _4744: Unit = Unit
// [KnfOpt]     let _4745: Tuple([Int, Int]) = Apply(addone.97, [_4744, ])
// [KnfOpt]     let (ok.4746: Var({val: Some(Int)}), val.4747: Var({val: Some(Int)})) = _4745
// [KnfOpt]     let _4748: Int = Int(0)
// [KnfOpt]     if (ok.4746 == _4748) then {
// [KnfOpt]       let _4749: Int = Int(0)
// [KnfOpt]       let _4750: Int = Int(0)
// [KnfOpt]       Tuple([_4749, _4750, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.4751: Int = Apply(_99, [val.4747, ])
// [KnfOpt]       let _4752: Int = Int(0)
// [KnfOpt]       if (r.4751 == _4752) then {
// [KnfOpt]         let _4753: Int = Int(1)
// [KnfOpt]         Tuple([_4753, val.4747, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _4754: Unit = Unit
// [KnfOpt]         Jump(aux.4742, [_4754, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.4742, [u.4741, ])
// [KnfOpt] }
// [KnfOpt] let over50.100: Fun([Unit], Tuple([Int, Int])) = Var(aux.4740)
// [KnfOpt] let _101: Int = Int(1200)
// [KnfOpt] let rec aux.4798: Int = (y.4799: Int) {
// [KnfOpt]   if (y.4799 <= _101) then {
// [KnfOpt]     Int(0)
// [KnfOpt]   } else {
// [KnfOpt]     Int(1)
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] let _102: Fun([Int], Int) = Var(aux.4798)
// [KnfOpt] let rec aux.4814: Tuple([Int, Int]) = (u.4815: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.4816: Tuple([Int, Int]) = (u.4817: Var({val: Some(Unit)})) {
// [KnfOpt]     let _4818: Unit = Unit
// [KnfOpt]     let _4819: Tuple([Int, Int]) = Apply(over50.100, [_4818, ])
// [KnfOpt]     let (ok.4820: Var({val: Some(Int)}), val.4821: Var({val: Some(Int)})) = _4819
// [KnfOpt]     let _4822: Int = Int(0)
// [KnfOpt]     if (ok.4820 == _4822) then {
// [KnfOpt]       let _4823: Int = Int(0)
// [KnfOpt]       let _4824: Int = Int(0)
// [KnfOpt]       Tuple([_4823, _4824, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.4825: Int = Apply(_102, [val.4821, ])
// [KnfOpt]       let _4826: Int = Int(0)
// [KnfOpt]       if (r.4825 == _4826) then {
// [KnfOpt]         let _4827: Int = Int(1)
// [KnfOpt]         Tuple([_4827, val.4821, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _4828: Unit = Unit
// [KnfOpt]         Jump(aux.4816, [_4828, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.4816, [u.4815, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.4814)
// [KnfOpt] let rec add.4829: Int = (x.4830: Int, y.4831: Int) {
// [KnfOpt]   Add(x.4830, y.4831)
// [KnfOpt] }
// [KnfOpt] let _4832: Int = Int(0)
// [KnfOpt] let join fold.4833: Int = (stream.4834: Fun([Unit], Tuple([Int, Int])), f.4835: Fun([Int, Int], Int), acc.4836: Int) {
// [KnfOpt]   let _4837: Unit = Unit
// [KnfOpt]   let _4838: Tuple([Int, Int]) = Apply(stream.4834, [_4837, ])
// [KnfOpt]   let (ok.4839: Var({val: Some(Int)}), val.4840: Var({val: Some(Int)})) = _4838
// [KnfOpt]   let _4841: Int = Int(0)
// [KnfOpt]   if (ok.4839 == _4841) then {
// [KnfOpt]     let sum.104: Int = Var(acc.4836)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _4842: Int = Apply(f.4835, [acc.4836, val.4840, ])
// [KnfOpt]     Jump(fold.4833, [stream.4834, f.4835, _4842, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.4833, [under1200.103, add.4829, _4832, ])
// [KnfOpt] Inline threshold 3
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 0
// [KnfOpt] Inline decision addx.59 accepted
// [KnfOpt] Inline threshold 20
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 0
// [KnfOpt] Inline decision map.1 accepted
// [KnfOpt] Inline threshold 5
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 0
// [KnfOpt] Inline decision gt.79 accepted
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 5
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 0
// [KnfOpt] Inline decision le.83 accepted
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.4852: Int = (x.4853: Int, y.4854: Int) {
// [KnfOpt]   Add(x.4853, y.4854)
// [KnfOpt] }
// [KnfOpt] let _4855: Int = Int(0)
// [KnfOpt] let join fold.4856: Int = (stream.4857: Fun([Unit], Tuple([Int, Int])), f.4858: Fun([Int, Int], Int), acc.4859: Int) {
// [KnfOpt]   let _4860: Unit = Unit
// [KnfOpt]   let _4861: Tuple([Int, Int]) = Apply(stream.4857, [_4860, ])
// [KnfOpt]   let (ok.4862: Var({val: Some(Int)}), val.4863: Var({val: Some(Int)})) = _4861
// [KnfOpt]   let _4864: Int = Int(0)
// [KnfOpt]   if (ok.4862 == _4864) then {
// [KnfOpt]     let sum.104: Int = Var(acc.4859)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _4865: Int = Apply(f.4858, [acc.4859, val.4863, ])
// [KnfOpt]     Jump(fold.4856, [stream.4857, f.4858, _4865, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.4856, [under1200.103, add.4852, _4855, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(le) let _102: Fun([Int], Int) = Unit
// [KnfOpt] let rec aux.4866: Tuple([Int, Int]) = (u.4867: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.4868: Tuple([Int, Int]) = (u.4869: Var({val: Some(Unit)})) {
// [KnfOpt]     let _4870: Unit = Unit
// [KnfOpt]     let _4871: Tuple([Int, Int]) = Apply(over50.100, [_4870, ])
// [KnfOpt]     let (ok.4872: Var({val: Some(Int)}), val.4873: Var({val: Some(Int)})) = _4871
// [KnfOpt]     let _4874: Int = Int(0)
// [KnfOpt]     if (ok.4872 == _4874) then {
// [KnfOpt]       let _4875: Int = Int(0)
// [KnfOpt]       let _4876: Int = Int(0)
// [KnfOpt]       Tuple([_4875, _4876, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.4877: Int = Apply(_102, [val.4873, ])
// [KnfOpt]       let _4878: Int = Int(0)
// [KnfOpt]       if (r.4877 == _4878) then {
// [KnfOpt]         let _4879: Int = Int(1)
// [KnfOpt]         Tuple([_4879, val.4873, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _4880: Unit = Unit
// [KnfOpt]         Jump(aux.4868, [_4880, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.4868, [u.4867, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.4866)
// [KnfOpt] let rec add.4881: Int = (x.4882: Int, y.4883: Int) {
// [KnfOpt]   Add(x.4882, y.4883)
// [KnfOpt] }
// [KnfOpt] let _4884: Int = Int(0)
// [KnfOpt] let join fold.4885: Int = (stream.4886: Fun([Unit], Tuple([Int, Int])), f.4887: Fun([Int, Int], Int), acc.4888: Int) {
// [KnfOpt]   let _4889: Unit = Unit
// [KnfOpt]   let _4890: Tuple([Int, Int]) = Apply(stream.4886, [_4889, ])
// [KnfOpt]   let (ok.4891: Var({val: Some(Int)}), val.4892: Var({val: Some(Int)})) = _4890
// [KnfOpt]   let _4893: Int = Int(0)
// [KnfOpt]   if (ok.4891 == _4893) then {
// [KnfOpt]     let sum.104: Int = Var(acc.4888)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _4894: Int = Apply(f.4887, [acc.4888, val.4892, ])
// [KnfOpt]     Jump(fold.4885, [stream.4886, f.4887, _4894, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.4885, [under1200.103, add.4881, _4884, ])
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.4897: Int = (x.4898: Int, y.4899: Int) {
// [KnfOpt]   Add(x.4898, y.4899)
// [KnfOpt] }
// [KnfOpt] let _4900: Int = Int(0)
// [KnfOpt] let join fold.4901: Int = (stream.4902: Fun([Unit], Tuple([Int, Int])), f.4903: Fun([Int, Int], Int), acc.4904: Int) {
// [KnfOpt]   let _4905: Unit = Unit
// [KnfOpt]   let _4906: Tuple([Int, Int]) = Apply(stream.4902, [_4905, ])
// [KnfOpt]   let (ok.4907: Var({val: Some(Int)}), val.4908: Var({val: Some(Int)})) = _4906
// [KnfOpt]   let _4909: Int = Int(0)
// [KnfOpt]   if (ok.4907 == _4909) then {
// [KnfOpt]     let sum.104: Int = Var(acc.4904)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _4910: Int = Apply(f.4903, [acc.4904, val.4908, ])
// [KnfOpt]     Jump(fold.4901, [stream.4902, f.4903, _4910, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.4901, [under1200.103, add.4897, _4900, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let over50.100: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let _101: Int = Int(1200)
// [KnfOpt] let rec aux.4895: Int = (y.4896: Int) {
// [KnfOpt]   if (y.4896 <= _101) then {
// [KnfOpt]     Int(0)
// [KnfOpt]   } else {
// [KnfOpt]     Int(1)
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] let _102: Fun([Int], Int) = Var(aux.4895)
// [KnfOpt] let rec aux.4911: Tuple([Int, Int]) = (u.4912: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.4913: Tuple([Int, Int]) = (u.4914: Var({val: Some(Unit)})) {
// [KnfOpt]     let _4915: Unit = Unit
// [KnfOpt]     let _4916: Tuple([Int, Int]) = Apply(over50.100, [_4915, ])
// [KnfOpt]     let (ok.4917: Var({val: Some(Int)}), val.4918: Var({val: Some(Int)})) = _4916
// [KnfOpt]     let _4919: Int = Int(0)
// [KnfOpt]     if (ok.4917 == _4919) then {
// [KnfOpt]       let _4920: Int = Int(0)
// [KnfOpt]       let _4921: Int = Int(0)
// [KnfOpt]       Tuple([_4920, _4921, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.4922: Int = Apply(_102, [val.4918, ])
// [KnfOpt]       let _4923: Int = Int(0)
// [KnfOpt]       if (r.4922 == _4923) then {
// [KnfOpt]         let _4924: Int = Int(1)
// [KnfOpt]         Tuple([_4924, val.4918, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _4925: Unit = Unit
// [KnfOpt]         Jump(aux.4913, [_4925, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.4913, [u.4912, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.4911)
// [KnfOpt] let rec add.4926: Int = (x.4927: Int, y.4928: Int) {
// [KnfOpt]   Add(x.4927, y.4928)
// [KnfOpt] }
// [KnfOpt] let _4929: Int = Int(0)
// [KnfOpt] let join fold.4930: Int = (stream.4931: Fun([Unit], Tuple([Int, Int])), f.4932: Fun([Int, Int], Int), acc.4933: Int) {
// [KnfOpt]   let _4934: Unit = Unit
// [KnfOpt]   let _4935: Tuple([Int, Int]) = Apply(stream.4931, [_4934, ])
// [KnfOpt]   let (ok.4936: Var({val: Some(Int)}), val.4937: Var({val: Some(Int)})) = _4935
// [KnfOpt]   let _4938: Int = Int(0)
// [KnfOpt]   if (ok.4936 == _4938) then {
// [KnfOpt]     let sum.104: Int = Var(acc.4933)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _4939: Int = Apply(f.4932, [acc.4933, val.4937, ])
// [KnfOpt]     Jump(fold.4930, [stream.4931, f.4932, _4939, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.4930, [under1200.103, add.4926, _4929, ])
// [KnfOpt] Inline threshold 5
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 0
// [KnfOpt] Inline decision le.83 accepted
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.4955: Int = (x.4956: Int, y.4957: Int) {
// [KnfOpt]   Add(x.4956, y.4957)
// [KnfOpt] }
// [KnfOpt] let _4958: Int = Int(0)
// [KnfOpt] let join fold.4959: Int = (stream.4960: Fun([Unit], Tuple([Int, Int])), f.4961: Fun([Int, Int], Int), acc.4962: Int) {
// [KnfOpt]   let _4963: Unit = Unit
// [KnfOpt]   let _4964: Tuple([Int, Int]) = Apply(stream.4960, [_4963, ])
// [KnfOpt]   let (ok.4965: Var({val: Some(Int)}), val.4966: Var({val: Some(Int)})) = _4964
// [KnfOpt]   let _4967: Int = Int(0)
// [KnfOpt]   if (ok.4965 == _4967) then {
// [KnfOpt]     let sum.104: Int = Var(acc.4962)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _4968: Int = Apply(f.4961, [acc.4962, val.4966, ])
// [KnfOpt]     Jump(fold.4959, [stream.4960, f.4961, _4968, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.4959, [under1200.103, add.4955, _4958, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(le) let _102: Fun([Int], Int) = Unit
// [KnfOpt] let rec aux.4969: Tuple([Int, Int]) = (u.4970: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.4971: Tuple([Int, Int]) = (u.4972: Var({val: Some(Unit)})) {
// [KnfOpt]     let _4973: Unit = Unit
// [KnfOpt]     let _4974: Tuple([Int, Int]) = Apply(over50.100, [_4973, ])
// [KnfOpt]     let (ok.4975: Var({val: Some(Int)}), val.4976: Var({val: Some(Int)})) = _4974
// [KnfOpt]     let _4977: Int = Int(0)
// [KnfOpt]     if (ok.4975 == _4977) then {
// [KnfOpt]       let _4978: Int = Int(0)
// [KnfOpt]       let _4979: Int = Int(0)
// [KnfOpt]       Tuple([_4978, _4979, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.4980: Int = Apply(_102, [val.4976, ])
// [KnfOpt]       let _4981: Int = Int(0)
// [KnfOpt]       if (r.4980 == _4981) then {
// [KnfOpt]         let _4982: Int = Int(1)
// [KnfOpt]         Tuple([_4982, val.4976, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _4983: Unit = Unit
// [KnfOpt]         Jump(aux.4971, [_4983, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.4971, [u.4970, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.4969)
// [KnfOpt] let rec add.4984: Int = (x.4985: Int, y.4986: Int) {
// [KnfOpt]   Add(x.4985, y.4986)
// [KnfOpt] }
// [KnfOpt] let _4987: Int = Int(0)
// [KnfOpt] let join fold.4988: Int = (stream.4989: Fun([Unit], Tuple([Int, Int])), f.4990: Fun([Int, Int], Int), acc.4991: Int) {
// [KnfOpt]   let _4992: Unit = Unit
// [KnfOpt]   let _4993: Tuple([Int, Int]) = Apply(stream.4989, [_4992, ])
// [KnfOpt]   let (ok.4994: Var({val: Some(Int)}), val.4995: Var({val: Some(Int)})) = _4993
// [KnfOpt]   let _4996: Int = Int(0)
// [KnfOpt]   if (ok.4994 == _4996) then {
// [KnfOpt]     let sum.104: Int = Var(acc.4991)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _4997: Int = Apply(f.4990, [acc.4991, val.4995, ])
// [KnfOpt]     Jump(fold.4988, [stream.4989, f.4990, _4997, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.4988, [under1200.103, add.4984, _4987, ])
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.5000: Int = (x.5001: Int, y.5002: Int) {
// [KnfOpt]   Add(x.5001, y.5002)
// [KnfOpt] }
// [KnfOpt] let _5003: Int = Int(0)
// [KnfOpt] let join fold.5004: Int = (stream.5005: Fun([Unit], Tuple([Int, Int])), f.5006: Fun([Int, Int], Int), acc.5007: Int) {
// [KnfOpt]   let _5008: Unit = Unit
// [KnfOpt]   let _5009: Tuple([Int, Int]) = Apply(stream.5005, [_5008, ])
// [KnfOpt]   let (ok.5010: Var({val: Some(Int)}), val.5011: Var({val: Some(Int)})) = _5009
// [KnfOpt]   let _5012: Int = Int(0)
// [KnfOpt]   if (ok.5010 == _5012) then {
// [KnfOpt]     let sum.104: Int = Var(acc.5007)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _5013: Int = Apply(f.5006, [acc.5007, val.5011, ])
// [KnfOpt]     Jump(fold.5004, [stream.5005, f.5006, _5013, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.5004, [under1200.103, add.5000, _5003, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(gt) let _99: Fun([Int], Int) = Unit
// [KnfOpt] let rec aux.4940: Tuple([Int, Int]) = (u.4941: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.4942: Tuple([Int, Int]) = (u.4943: Var({val: Some(Unit)})) {
// [KnfOpt]     let _4944: Unit = Unit
// [KnfOpt]     let _4945: Tuple([Int, Int]) = Apply(addone.97, [_4944, ])
// [KnfOpt]     let (ok.4946: Var({val: Some(Int)}), val.4947: Var({val: Some(Int)})) = _4945
// [KnfOpt]     let _4948: Int = Int(0)
// [KnfOpt]     if (ok.4946 == _4948) then {
// [KnfOpt]       let _4949: Int = Int(0)
// [KnfOpt]       let _4950: Int = Int(0)
// [KnfOpt]       Tuple([_4949, _4950, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.4951: Int = Apply(_99, [val.4947, ])
// [KnfOpt]       let _4952: Int = Int(0)
// [KnfOpt]       if (r.4951 == _4952) then {
// [KnfOpt]         let _4953: Int = Int(1)
// [KnfOpt]         Tuple([_4953, val.4947, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _4954: Unit = Unit
// [KnfOpt]         Jump(aux.4942, [_4954, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.4942, [u.4941, ])
// [KnfOpt] }
// [KnfOpt] let over50.100: Fun([Unit], Tuple([Int, Int])) = Var(aux.4940)
// [KnfOpt] let _101: Int = Int(1200)
// [KnfOpt] let rec aux.4998: Int = (y.4999: Int) {
// [KnfOpt]   if (y.4999 <= _101) then {
// [KnfOpt]     Int(0)
// [KnfOpt]   } else {
// [KnfOpt]     Int(1)
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] let _102: Fun([Int], Int) = Var(aux.4998)
// [KnfOpt] let rec aux.5014: Tuple([Int, Int]) = (u.5015: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.5016: Tuple([Int, Int]) = (u.5017: Var({val: Some(Unit)})) {
// [KnfOpt]     let _5018: Unit = Unit
// [KnfOpt]     let _5019: Tuple([Int, Int]) = Apply(over50.100, [_5018, ])
// [KnfOpt]     let (ok.5020: Var({val: Some(Int)}), val.5021: Var({val: Some(Int)})) = _5019
// [KnfOpt]     let _5022: Int = Int(0)
// [KnfOpt]     if (ok.5020 == _5022) then {
// [KnfOpt]       let _5023: Int = Int(0)
// [KnfOpt]       let _5024: Int = Int(0)
// [KnfOpt]       Tuple([_5023, _5024, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.5025: Int = Apply(_102, [val.5021, ])
// [KnfOpt]       let _5026: Int = Int(0)
// [KnfOpt]       if (r.5025 == _5026) then {
// [KnfOpt]         let _5027: Int = Int(1)
// [KnfOpt]         Tuple([_5027, val.5021, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _5028: Unit = Unit
// [KnfOpt]         Jump(aux.5016, [_5028, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.5016, [u.5015, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.5014)
// [KnfOpt] let rec add.5029: Int = (x.5030: Int, y.5031: Int) {
// [KnfOpt]   Add(x.5030, y.5031)
// [KnfOpt] }
// [KnfOpt] let _5032: Int = Int(0)
// [KnfOpt] let join fold.5033: Int = (stream.5034: Fun([Unit], Tuple([Int, Int])), f.5035: Fun([Int, Int], Int), acc.5036: Int) {
// [KnfOpt]   let _5037: Unit = Unit
// [KnfOpt]   let _5038: Tuple([Int, Int]) = Apply(stream.5034, [_5037, ])
// [KnfOpt]   let (ok.5039: Var({val: Some(Int)}), val.5040: Var({val: Some(Int)})) = _5038
// [KnfOpt]   let _5041: Int = Int(0)
// [KnfOpt]   if (ok.5039 == _5041) then {
// [KnfOpt]     let sum.104: Int = Var(acc.5036)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _5042: Int = Apply(f.5035, [acc.5036, val.5040, ])
// [KnfOpt]     Jump(fold.5033, [stream.5034, f.5035, _5042, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.5033, [under1200.103, add.5029, _5032, ])
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 5
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 0
// [KnfOpt] Inline decision le.83 accepted
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.5045: Int = (x.5046: Int, y.5047: Int) {
// [KnfOpt]   Add(x.5046, y.5047)
// [KnfOpt] }
// [KnfOpt] let _5048: Int = Int(0)
// [KnfOpt] let join fold.5049: Int = (stream.5050: Fun([Unit], Tuple([Int, Int])), f.5051: Fun([Int, Int], Int), acc.5052: Int) {
// [KnfOpt]   let _5053: Unit = Unit
// [KnfOpt]   let _5054: Tuple([Int, Int]) = Apply(stream.5050, [_5053, ])
// [KnfOpt]   let (ok.5055: Var({val: Some(Int)}), val.5056: Var({val: Some(Int)})) = _5054
// [KnfOpt]   let _5057: Int = Int(0)
// [KnfOpt]   if (ok.5055 == _5057) then {
// [KnfOpt]     let sum.104: Int = Var(acc.5052)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _5058: Int = Apply(f.5051, [acc.5052, val.5056, ])
// [KnfOpt]     Jump(fold.5049, [stream.5050, f.5051, _5058, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.5049, [under1200.103, add.5045, _5048, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(le) let _102: Fun([Int], Int) = Unit
// [KnfOpt] let rec aux.5059: Tuple([Int, Int]) = (u.5060: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.5061: Tuple([Int, Int]) = (u.5062: Var({val: Some(Unit)})) {
// [KnfOpt]     let _5063: Unit = Unit
// [KnfOpt]     let _5064: Tuple([Int, Int]) = Apply(over50.100, [_5063, ])
// [KnfOpt]     let (ok.5065: Var({val: Some(Int)}), val.5066: Var({val: Some(Int)})) = _5064
// [KnfOpt]     let _5067: Int = Int(0)
// [KnfOpt]     if (ok.5065 == _5067) then {
// [KnfOpt]       let _5068: Int = Int(0)
// [KnfOpt]       let _5069: Int = Int(0)
// [KnfOpt]       Tuple([_5068, _5069, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.5070: Int = Apply(_102, [val.5066, ])
// [KnfOpt]       let _5071: Int = Int(0)
// [KnfOpt]       if (r.5070 == _5071) then {
// [KnfOpt]         let _5072: Int = Int(1)
// [KnfOpt]         Tuple([_5072, val.5066, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _5073: Unit = Unit
// [KnfOpt]         Jump(aux.5061, [_5073, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.5061, [u.5060, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.5059)
// [KnfOpt] let rec add.5074: Int = (x.5075: Int, y.5076: Int) {
// [KnfOpt]   Add(x.5075, y.5076)
// [KnfOpt] }
// [KnfOpt] let _5077: Int = Int(0)
// [KnfOpt] let join fold.5078: Int = (stream.5079: Fun([Unit], Tuple([Int, Int])), f.5080: Fun([Int, Int], Int), acc.5081: Int) {
// [KnfOpt]   let _5082: Unit = Unit
// [KnfOpt]   let _5083: Tuple([Int, Int]) = Apply(stream.5079, [_5082, ])
// [KnfOpt]   let (ok.5084: Var({val: Some(Int)}), val.5085: Var({val: Some(Int)})) = _5083
// [KnfOpt]   let _5086: Int = Int(0)
// [KnfOpt]   if (ok.5084 == _5086) then {
// [KnfOpt]     let sum.104: Int = Var(acc.5081)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _5087: Int = Apply(f.5080, [acc.5081, val.5085, ])
// [KnfOpt]     Jump(fold.5078, [stream.5079, f.5080, _5087, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.5078, [under1200.103, add.5074, _5077, ])
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.5090: Int = (x.5091: Int, y.5092: Int) {
// [KnfOpt]   Add(x.5091, y.5092)
// [KnfOpt] }
// [KnfOpt] let _5093: Int = Int(0)
// [KnfOpt] let join fold.5094: Int = (stream.5095: Fun([Unit], Tuple([Int, Int])), f.5096: Fun([Int, Int], Int), acc.5097: Int) {
// [KnfOpt]   let _5098: Unit = Unit
// [KnfOpt]   let _5099: Tuple([Int, Int]) = Apply(stream.5095, [_5098, ])
// [KnfOpt]   let (ok.5100: Var({val: Some(Int)}), val.5101: Var({val: Some(Int)})) = _5099
// [KnfOpt]   let _5102: Int = Int(0)
// [KnfOpt]   if (ok.5100 == _5102) then {
// [KnfOpt]     let sum.104: Int = Var(acc.5097)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _5103: Int = Apply(f.5096, [acc.5097, val.5101, ])
// [KnfOpt]     Jump(fold.5094, [stream.5095, f.5096, _5103, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.5094, [under1200.103, add.5090, _5093, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let over50.100: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let _101: Int = Int(1200)
// [KnfOpt] let rec aux.5088: Int = (y.5089: Int) {
// [KnfOpt]   if (y.5089 <= _101) then {
// [KnfOpt]     Int(0)
// [KnfOpt]   } else {
// [KnfOpt]     Int(1)
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] let _102: Fun([Int], Int) = Var(aux.5088)
// [KnfOpt] let rec aux.5104: Tuple([Int, Int]) = (u.5105: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.5106: Tuple([Int, Int]) = (u.5107: Var({val: Some(Unit)})) {
// [KnfOpt]     let _5108: Unit = Unit
// [KnfOpt]     let _5109: Tuple([Int, Int]) = Apply(over50.100, [_5108, ])
// [KnfOpt]     let (ok.5110: Var({val: Some(Int)}), val.5111: Var({val: Some(Int)})) = _5109
// [KnfOpt]     let _5112: Int = Int(0)
// [KnfOpt]     if (ok.5110 == _5112) then {
// [KnfOpt]       let _5113: Int = Int(0)
// [KnfOpt]       let _5114: Int = Int(0)
// [KnfOpt]       Tuple([_5113, _5114, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.5115: Int = Apply(_102, [val.5111, ])
// [KnfOpt]       let _5116: Int = Int(0)
// [KnfOpt]       if (r.5115 == _5116) then {
// [KnfOpt]         let _5117: Int = Int(1)
// [KnfOpt]         Tuple([_5117, val.5111, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _5118: Unit = Unit
// [KnfOpt]         Jump(aux.5106, [_5118, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.5106, [u.5105, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.5104)
// [KnfOpt] let rec add.5119: Int = (x.5120: Int, y.5121: Int) {
// [KnfOpt]   Add(x.5120, y.5121)
// [KnfOpt] }
// [KnfOpt] let _5122: Int = Int(0)
// [KnfOpt] let join fold.5123: Int = (stream.5124: Fun([Unit], Tuple([Int, Int])), f.5125: Fun([Int, Int], Int), acc.5126: Int) {
// [KnfOpt]   let _5127: Unit = Unit
// [KnfOpt]   let _5128: Tuple([Int, Int]) = Apply(stream.5124, [_5127, ])
// [KnfOpt]   let (ok.5129: Var({val: Some(Int)}), val.5130: Var({val: Some(Int)})) = _5128
// [KnfOpt]   let _5131: Int = Int(0)
// [KnfOpt]   if (ok.5129 == _5131) then {
// [KnfOpt]     let sum.104: Int = Var(acc.5126)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _5132: Int = Apply(f.5125, [acc.5126, val.5130, ])
// [KnfOpt]     Jump(fold.5123, [stream.5124, f.5125, _5132, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.5123, [under1200.103, add.5119, _5122, ])
// [KnfOpt] Inline threshold 5
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 0
// [KnfOpt] Inline decision le.83 accepted
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.5148: Int = (x.5149: Int, y.5150: Int) {
// [KnfOpt]   Add(x.5149, y.5150)
// [KnfOpt] }
// [KnfOpt] let _5151: Int = Int(0)
// [KnfOpt] let join fold.5152: Int = (stream.5153: Fun([Unit], Tuple([Int, Int])), f.5154: Fun([Int, Int], Int), acc.5155: Int) {
// [KnfOpt]   let _5156: Unit = Unit
// [KnfOpt]   let _5157: Tuple([Int, Int]) = Apply(stream.5153, [_5156, ])
// [KnfOpt]   let (ok.5158: Var({val: Some(Int)}), val.5159: Var({val: Some(Int)})) = _5157
// [KnfOpt]   let _5160: Int = Int(0)
// [KnfOpt]   if (ok.5158 == _5160) then {
// [KnfOpt]     let sum.104: Int = Var(acc.5155)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _5161: Int = Apply(f.5154, [acc.5155, val.5159, ])
// [KnfOpt]     Jump(fold.5152, [stream.5153, f.5154, _5161, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.5152, [under1200.103, add.5148, _5151, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(le) let _102: Fun([Int], Int) = Unit
// [KnfOpt] let rec aux.5162: Tuple([Int, Int]) = (u.5163: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.5164: Tuple([Int, Int]) = (u.5165: Var({val: Some(Unit)})) {
// [KnfOpt]     let _5166: Unit = Unit
// [KnfOpt]     let _5167: Tuple([Int, Int]) = Apply(over50.100, [_5166, ])
// [KnfOpt]     let (ok.5168: Var({val: Some(Int)}), val.5169: Var({val: Some(Int)})) = _5167
// [KnfOpt]     let _5170: Int = Int(0)
// [KnfOpt]     if (ok.5168 == _5170) then {
// [KnfOpt]       let _5171: Int = Int(0)
// [KnfOpt]       let _5172: Int = Int(0)
// [KnfOpt]       Tuple([_5171, _5172, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.5173: Int = Apply(_102, [val.5169, ])
// [KnfOpt]       let _5174: Int = Int(0)
// [KnfOpt]       if (r.5173 == _5174) then {
// [KnfOpt]         let _5175: Int = Int(1)
// [KnfOpt]         Tuple([_5175, val.5169, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _5176: Unit = Unit
// [KnfOpt]         Jump(aux.5164, [_5176, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.5164, [u.5163, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.5162)
// [KnfOpt] let rec add.5177: Int = (x.5178: Int, y.5179: Int) {
// [KnfOpt]   Add(x.5178, y.5179)
// [KnfOpt] }
// [KnfOpt] let _5180: Int = Int(0)
// [KnfOpt] let join fold.5181: Int = (stream.5182: Fun([Unit], Tuple([Int, Int])), f.5183: Fun([Int, Int], Int), acc.5184: Int) {
// [KnfOpt]   let _5185: Unit = Unit
// [KnfOpt]   let _5186: Tuple([Int, Int]) = Apply(stream.5182, [_5185, ])
// [KnfOpt]   let (ok.5187: Var({val: Some(Int)}), val.5188: Var({val: Some(Int)})) = _5186
// [KnfOpt]   let _5189: Int = Int(0)
// [KnfOpt]   if (ok.5187 == _5189) then {
// [KnfOpt]     let sum.104: Int = Var(acc.5184)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _5190: Int = Apply(f.5183, [acc.5184, val.5188, ])
// [KnfOpt]     Jump(fold.5181, [stream.5182, f.5183, _5190, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.5181, [under1200.103, add.5177, _5180, ])
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.5193: Int = (x.5194: Int, y.5195: Int) {
// [KnfOpt]   Add(x.5194, y.5195)
// [KnfOpt] }
// [KnfOpt] let _5196: Int = Int(0)
// [KnfOpt] let join fold.5197: Int = (stream.5198: Fun([Unit], Tuple([Int, Int])), f.5199: Fun([Int, Int], Int), acc.5200: Int) {
// [KnfOpt]   let _5201: Unit = Unit
// [KnfOpt]   let _5202: Tuple([Int, Int]) = Apply(stream.5198, [_5201, ])
// [KnfOpt]   let (ok.5203: Var({val: Some(Int)}), val.5204: Var({val: Some(Int)})) = _5202
// [KnfOpt]   let _5205: Int = Int(0)
// [KnfOpt]   if (ok.5203 == _5205) then {
// [KnfOpt]     let sum.104: Int = Var(acc.5200)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _5206: Int = Apply(f.5199, [acc.5200, val.5204, ])
// [KnfOpt]     Jump(fold.5197, [stream.5198, f.5199, _5206, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.5197, [under1200.103, add.5193, _5196, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(map) let addone.97: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let _98: Int = Int(50)
// [KnfOpt] let rec aux.5043: Int = (y.5044: Int) {
// [KnfOpt]   if (_98 <= y.5044) then {
// [KnfOpt]     Int(0)
// [KnfOpt]   } else {
// [KnfOpt]     Int(1)
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] let _99: Fun([Int], Int) = Var(aux.5043)
// [KnfOpt] let rec aux.5133: Tuple([Int, Int]) = (u.5134: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.5135: Tuple([Int, Int]) = (u.5136: Var({val: Some(Unit)})) {
// [KnfOpt]     let _5137: Unit = Unit
// [KnfOpt]     let _5138: Tuple([Int, Int]) = Apply(addone.97, [_5137, ])
// [KnfOpt]     let (ok.5139: Var({val: Some(Int)}), val.5140: Var({val: Some(Int)})) = _5138
// [KnfOpt]     let _5141: Int = Int(0)
// [KnfOpt]     if (ok.5139 == _5141) then {
// [KnfOpt]       let _5142: Int = Int(0)
// [KnfOpt]       let _5143: Int = Int(0)
// [KnfOpt]       Tuple([_5142, _5143, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.5144: Int = Apply(_99, [val.5140, ])
// [KnfOpt]       let _5145: Int = Int(0)
// [KnfOpt]       if (r.5144 == _5145) then {
// [KnfOpt]         let _5146: Int = Int(1)
// [KnfOpt]         Tuple([_5146, val.5140, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _5147: Unit = Unit
// [KnfOpt]         Jump(aux.5135, [_5147, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.5135, [u.5134, ])
// [KnfOpt] }
// [KnfOpt] let over50.100: Fun([Unit], Tuple([Int, Int])) = Var(aux.5133)
// [KnfOpt] let _101: Int = Int(1200)
// [KnfOpt] let rec aux.5191: Int = (y.5192: Int) {
// [KnfOpt]   if (y.5192 <= _101) then {
// [KnfOpt]     Int(0)
// [KnfOpt]   } else {
// [KnfOpt]     Int(1)
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] let _102: Fun([Int], Int) = Var(aux.5191)
// [KnfOpt] let rec aux.5207: Tuple([Int, Int]) = (u.5208: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.5209: Tuple([Int, Int]) = (u.5210: Var({val: Some(Unit)})) {
// [KnfOpt]     let _5211: Unit = Unit
// [KnfOpt]     let _5212: Tuple([Int, Int]) = Apply(over50.100, [_5211, ])
// [KnfOpt]     let (ok.5213: Var({val: Some(Int)}), val.5214: Var({val: Some(Int)})) = _5212
// [KnfOpt]     let _5215: Int = Int(0)
// [KnfOpt]     if (ok.5213 == _5215) then {
// [KnfOpt]       let _5216: Int = Int(0)
// [KnfOpt]       let _5217: Int = Int(0)
// [KnfOpt]       Tuple([_5216, _5217, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.5218: Int = Apply(_102, [val.5214, ])
// [KnfOpt]       let _5219: Int = Int(0)
// [KnfOpt]       if (r.5218 == _5219) then {
// [KnfOpt]         let _5220: Int = Int(1)
// [KnfOpt]         Tuple([_5220, val.5214, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _5221: Unit = Unit
// [KnfOpt]         Jump(aux.5209, [_5221, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.5209, [u.5208, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.5207)
// [KnfOpt] let rec add.5222: Int = (x.5223: Int, y.5224: Int) {
// [KnfOpt]   Add(x.5223, y.5224)
// [KnfOpt] }
// [KnfOpt] let _5225: Int = Int(0)
// [KnfOpt] let join fold.5226: Int = (stream.5227: Fun([Unit], Tuple([Int, Int])), f.5228: Fun([Int, Int], Int), acc.5229: Int) {
// [KnfOpt]   let _5230: Unit = Unit
// [KnfOpt]   let _5231: Tuple([Int, Int]) = Apply(stream.5227, [_5230, ])
// [KnfOpt]   let (ok.5232: Var({val: Some(Int)}), val.5233: Var({val: Some(Int)})) = _5231
// [KnfOpt]   let _5234: Int = Int(0)
// [KnfOpt]   if (ok.5232 == _5234) then {
// [KnfOpt]     let sum.104: Int = Var(acc.5229)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _5235: Int = Apply(f.5228, [acc.5229, val.5233, ])
// [KnfOpt]     Jump(fold.5226, [stream.5227, f.5228, _5235, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.5226, [under1200.103, add.5222, _5225, ])
// [KnfOpt] Inline threshold 5
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 0
// [KnfOpt] Inline decision gt.79 accepted
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 5
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 0
// [KnfOpt] Inline decision le.83 accepted
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.5247: Int = (x.5248: Int, y.5249: Int) {
// [KnfOpt]   Add(x.5248, y.5249)
// [KnfOpt] }
// [KnfOpt] let _5250: Int = Int(0)
// [KnfOpt] let join fold.5251: Int = (stream.5252: Fun([Unit], Tuple([Int, Int])), f.5253: Fun([Int, Int], Int), acc.5254: Int) {
// [KnfOpt]   let _5255: Unit = Unit
// [KnfOpt]   let _5256: Tuple([Int, Int]) = Apply(stream.5252, [_5255, ])
// [KnfOpt]   let (ok.5257: Var({val: Some(Int)}), val.5258: Var({val: Some(Int)})) = _5256
// [KnfOpt]   let _5259: Int = Int(0)
// [KnfOpt]   if (ok.5257 == _5259) then {
// [KnfOpt]     let sum.104: Int = Var(acc.5254)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _5260: Int = Apply(f.5253, [acc.5254, val.5258, ])
// [KnfOpt]     Jump(fold.5251, [stream.5252, f.5253, _5260, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.5251, [under1200.103, add.5247, _5250, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(le) let _102: Fun([Int], Int) = Unit
// [KnfOpt] let rec aux.5261: Tuple([Int, Int]) = (u.5262: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.5263: Tuple([Int, Int]) = (u.5264: Var({val: Some(Unit)})) {
// [KnfOpt]     let _5265: Unit = Unit
// [KnfOpt]     let _5266: Tuple([Int, Int]) = Apply(over50.100, [_5265, ])
// [KnfOpt]     let (ok.5267: Var({val: Some(Int)}), val.5268: Var({val: Some(Int)})) = _5266
// [KnfOpt]     let _5269: Int = Int(0)
// [KnfOpt]     if (ok.5267 == _5269) then {
// [KnfOpt]       let _5270: Int = Int(0)
// [KnfOpt]       let _5271: Int = Int(0)
// [KnfOpt]       Tuple([_5270, _5271, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.5272: Int = Apply(_102, [val.5268, ])
// [KnfOpt]       let _5273: Int = Int(0)
// [KnfOpt]       if (r.5272 == _5273) then {
// [KnfOpt]         let _5274: Int = Int(1)
// [KnfOpt]         Tuple([_5274, val.5268, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _5275: Unit = Unit
// [KnfOpt]         Jump(aux.5263, [_5275, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.5263, [u.5262, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.5261)
// [KnfOpt] let rec add.5276: Int = (x.5277: Int, y.5278: Int) {
// [KnfOpt]   Add(x.5277, y.5278)
// [KnfOpt] }
// [KnfOpt] let _5279: Int = Int(0)
// [KnfOpt] let join fold.5280: Int = (stream.5281: Fun([Unit], Tuple([Int, Int])), f.5282: Fun([Int, Int], Int), acc.5283: Int) {
// [KnfOpt]   let _5284: Unit = Unit
// [KnfOpt]   let _5285: Tuple([Int, Int]) = Apply(stream.5281, [_5284, ])
// [KnfOpt]   let (ok.5286: Var({val: Some(Int)}), val.5287: Var({val: Some(Int)})) = _5285
// [KnfOpt]   let _5288: Int = Int(0)
// [KnfOpt]   if (ok.5286 == _5288) then {
// [KnfOpt]     let sum.104: Int = Var(acc.5283)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _5289: Int = Apply(f.5282, [acc.5283, val.5287, ])
// [KnfOpt]     Jump(fold.5280, [stream.5281, f.5282, _5289, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.5280, [under1200.103, add.5276, _5279, ])
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.5292: Int = (x.5293: Int, y.5294: Int) {
// [KnfOpt]   Add(x.5293, y.5294)
// [KnfOpt] }
// [KnfOpt] let _5295: Int = Int(0)
// [KnfOpt] let join fold.5296: Int = (stream.5297: Fun([Unit], Tuple([Int, Int])), f.5298: Fun([Int, Int], Int), acc.5299: Int) {
// [KnfOpt]   let _5300: Unit = Unit
// [KnfOpt]   let _5301: Tuple([Int, Int]) = Apply(stream.5297, [_5300, ])
// [KnfOpt]   let (ok.5302: Var({val: Some(Int)}), val.5303: Var({val: Some(Int)})) = _5301
// [KnfOpt]   let _5304: Int = Int(0)
// [KnfOpt]   if (ok.5302 == _5304) then {
// [KnfOpt]     let sum.104: Int = Var(acc.5299)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _5305: Int = Apply(f.5298, [acc.5299, val.5303, ])
// [KnfOpt]     Jump(fold.5296, [stream.5297, f.5298, _5305, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.5296, [under1200.103, add.5292, _5295, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let over50.100: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let _101: Int = Int(1200)
// [KnfOpt] let rec aux.5290: Int = (y.5291: Int) {
// [KnfOpt]   if (y.5291 <= _101) then {
// [KnfOpt]     Int(0)
// [KnfOpt]   } else {
// [KnfOpt]     Int(1)
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] let _102: Fun([Int], Int) = Var(aux.5290)
// [KnfOpt] let rec aux.5306: Tuple([Int, Int]) = (u.5307: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.5308: Tuple([Int, Int]) = (u.5309: Var({val: Some(Unit)})) {
// [KnfOpt]     let _5310: Unit = Unit
// [KnfOpt]     let _5311: Tuple([Int, Int]) = Apply(over50.100, [_5310, ])
// [KnfOpt]     let (ok.5312: Var({val: Some(Int)}), val.5313: Var({val: Some(Int)})) = _5311
// [KnfOpt]     let _5314: Int = Int(0)
// [KnfOpt]     if (ok.5312 == _5314) then {
// [KnfOpt]       let _5315: Int = Int(0)
// [KnfOpt]       let _5316: Int = Int(0)
// [KnfOpt]       Tuple([_5315, _5316, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.5317: Int = Apply(_102, [val.5313, ])
// [KnfOpt]       let _5318: Int = Int(0)
// [KnfOpt]       if (r.5317 == _5318) then {
// [KnfOpt]         let _5319: Int = Int(1)
// [KnfOpt]         Tuple([_5319, val.5313, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _5320: Unit = Unit
// [KnfOpt]         Jump(aux.5308, [_5320, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.5308, [u.5307, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.5306)
// [KnfOpt] let rec add.5321: Int = (x.5322: Int, y.5323: Int) {
// [KnfOpt]   Add(x.5322, y.5323)
// [KnfOpt] }
// [KnfOpt] let _5324: Int = Int(0)
// [KnfOpt] let join fold.5325: Int = (stream.5326: Fun([Unit], Tuple([Int, Int])), f.5327: Fun([Int, Int], Int), acc.5328: Int) {
// [KnfOpt]   let _5329: Unit = Unit
// [KnfOpt]   let _5330: Tuple([Int, Int]) = Apply(stream.5326, [_5329, ])
// [KnfOpt]   let (ok.5331: Var({val: Some(Int)}), val.5332: Var({val: Some(Int)})) = _5330
// [KnfOpt]   let _5333: Int = Int(0)
// [KnfOpt]   if (ok.5331 == _5333) then {
// [KnfOpt]     let sum.104: Int = Var(acc.5328)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _5334: Int = Apply(f.5327, [acc.5328, val.5332, ])
// [KnfOpt]     Jump(fold.5325, [stream.5326, f.5327, _5334, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.5325, [under1200.103, add.5321, _5324, ])
// [KnfOpt] Inline threshold 5
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 0
// [KnfOpt] Inline decision le.83 accepted
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.5350: Int = (x.5351: Int, y.5352: Int) {
// [KnfOpt]   Add(x.5351, y.5352)
// [KnfOpt] }
// [KnfOpt] let _5353: Int = Int(0)
// [KnfOpt] let join fold.5354: Int = (stream.5355: Fun([Unit], Tuple([Int, Int])), f.5356: Fun([Int, Int], Int), acc.5357: Int) {
// [KnfOpt]   let _5358: Unit = Unit
// [KnfOpt]   let _5359: Tuple([Int, Int]) = Apply(stream.5355, [_5358, ])
// [KnfOpt]   let (ok.5360: Var({val: Some(Int)}), val.5361: Var({val: Some(Int)})) = _5359
// [KnfOpt]   let _5362: Int = Int(0)
// [KnfOpt]   if (ok.5360 == _5362) then {
// [KnfOpt]     let sum.104: Int = Var(acc.5357)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _5363: Int = Apply(f.5356, [acc.5357, val.5361, ])
// [KnfOpt]     Jump(fold.5354, [stream.5355, f.5356, _5363, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.5354, [under1200.103, add.5350, _5353, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(le) let _102: Fun([Int], Int) = Unit
// [KnfOpt] let rec aux.5364: Tuple([Int, Int]) = (u.5365: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.5366: Tuple([Int, Int]) = (u.5367: Var({val: Some(Unit)})) {
// [KnfOpt]     let _5368: Unit = Unit
// [KnfOpt]     let _5369: Tuple([Int, Int]) = Apply(over50.100, [_5368, ])
// [KnfOpt]     let (ok.5370: Var({val: Some(Int)}), val.5371: Var({val: Some(Int)})) = _5369
// [KnfOpt]     let _5372: Int = Int(0)
// [KnfOpt]     if (ok.5370 == _5372) then {
// [KnfOpt]       let _5373: Int = Int(0)
// [KnfOpt]       let _5374: Int = Int(0)
// [KnfOpt]       Tuple([_5373, _5374, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.5375: Int = Apply(_102, [val.5371, ])
// [KnfOpt]       let _5376: Int = Int(0)
// [KnfOpt]       if (r.5375 == _5376) then {
// [KnfOpt]         let _5377: Int = Int(1)
// [KnfOpt]         Tuple([_5377, val.5371, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _5378: Unit = Unit
// [KnfOpt]         Jump(aux.5366, [_5378, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.5366, [u.5365, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.5364)
// [KnfOpt] let rec add.5379: Int = (x.5380: Int, y.5381: Int) {
// [KnfOpt]   Add(x.5380, y.5381)
// [KnfOpt] }
// [KnfOpt] let _5382: Int = Int(0)
// [KnfOpt] let join fold.5383: Int = (stream.5384: Fun([Unit], Tuple([Int, Int])), f.5385: Fun([Int, Int], Int), acc.5386: Int) {
// [KnfOpt]   let _5387: Unit = Unit
// [KnfOpt]   let _5388: Tuple([Int, Int]) = Apply(stream.5384, [_5387, ])
// [KnfOpt]   let (ok.5389: Var({val: Some(Int)}), val.5390: Var({val: Some(Int)})) = _5388
// [KnfOpt]   let _5391: Int = Int(0)
// [KnfOpt]   if (ok.5389 == _5391) then {
// [KnfOpt]     let sum.104: Int = Var(acc.5386)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _5392: Int = Apply(f.5385, [acc.5386, val.5390, ])
// [KnfOpt]     Jump(fold.5383, [stream.5384, f.5385, _5392, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.5383, [under1200.103, add.5379, _5382, ])
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.5395: Int = (x.5396: Int, y.5397: Int) {
// [KnfOpt]   Add(x.5396, y.5397)
// [KnfOpt] }
// [KnfOpt] let _5398: Int = Int(0)
// [KnfOpt] let join fold.5399: Int = (stream.5400: Fun([Unit], Tuple([Int, Int])), f.5401: Fun([Int, Int], Int), acc.5402: Int) {
// [KnfOpt]   let _5403: Unit = Unit
// [KnfOpt]   let _5404: Tuple([Int, Int]) = Apply(stream.5400, [_5403, ])
// [KnfOpt]   let (ok.5405: Var({val: Some(Int)}), val.5406: Var({val: Some(Int)})) = _5404
// [KnfOpt]   let _5407: Int = Int(0)
// [KnfOpt]   if (ok.5405 == _5407) then {
// [KnfOpt]     let sum.104: Int = Var(acc.5402)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _5408: Int = Apply(f.5401, [acc.5402, val.5406, ])
// [KnfOpt]     Jump(fold.5399, [stream.5400, f.5401, _5408, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.5399, [under1200.103, add.5395, _5398, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(gt) let _99: Fun([Int], Int) = Unit
// [KnfOpt] let rec aux.5335: Tuple([Int, Int]) = (u.5336: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.5337: Tuple([Int, Int]) = (u.5338: Var({val: Some(Unit)})) {
// [KnfOpt]     let _5339: Unit = Unit
// [KnfOpt]     let _5340: Tuple([Int, Int]) = Apply(addone.97, [_5339, ])
// [KnfOpt]     let (ok.5341: Var({val: Some(Int)}), val.5342: Var({val: Some(Int)})) = _5340
// [KnfOpt]     let _5343: Int = Int(0)
// [KnfOpt]     if (ok.5341 == _5343) then {
// [KnfOpt]       let _5344: Int = Int(0)
// [KnfOpt]       let _5345: Int = Int(0)
// [KnfOpt]       Tuple([_5344, _5345, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.5346: Int = Apply(_99, [val.5342, ])
// [KnfOpt]       let _5347: Int = Int(0)
// [KnfOpt]       if (r.5346 == _5347) then {
// [KnfOpt]         let _5348: Int = Int(1)
// [KnfOpt]         Tuple([_5348, val.5342, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _5349: Unit = Unit
// [KnfOpt]         Jump(aux.5337, [_5349, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.5337, [u.5336, ])
// [KnfOpt] }
// [KnfOpt] let over50.100: Fun([Unit], Tuple([Int, Int])) = Var(aux.5335)
// [KnfOpt] let _101: Int = Int(1200)
// [KnfOpt] let rec aux.5393: Int = (y.5394: Int) {
// [KnfOpt]   if (y.5394 <= _101) then {
// [KnfOpt]     Int(0)
// [KnfOpt]   } else {
// [KnfOpt]     Int(1)
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] let _102: Fun([Int], Int) = Var(aux.5393)
// [KnfOpt] let rec aux.5409: Tuple([Int, Int]) = (u.5410: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.5411: Tuple([Int, Int]) = (u.5412: Var({val: Some(Unit)})) {
// [KnfOpt]     let _5413: Unit = Unit
// [KnfOpt]     let _5414: Tuple([Int, Int]) = Apply(over50.100, [_5413, ])
// [KnfOpt]     let (ok.5415: Var({val: Some(Int)}), val.5416: Var({val: Some(Int)})) = _5414
// [KnfOpt]     let _5417: Int = Int(0)
// [KnfOpt]     if (ok.5415 == _5417) then {
// [KnfOpt]       let _5418: Int = Int(0)
// [KnfOpt]       let _5419: Int = Int(0)
// [KnfOpt]       Tuple([_5418, _5419, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.5420: Int = Apply(_102, [val.5416, ])
// [KnfOpt]       let _5421: Int = Int(0)
// [KnfOpt]       if (r.5420 == _5421) then {
// [KnfOpt]         let _5422: Int = Int(1)
// [KnfOpt]         Tuple([_5422, val.5416, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _5423: Unit = Unit
// [KnfOpt]         Jump(aux.5411, [_5423, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.5411, [u.5410, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.5409)
// [KnfOpt] let rec add.5424: Int = (x.5425: Int, y.5426: Int) {
// [KnfOpt]   Add(x.5425, y.5426)
// [KnfOpt] }
// [KnfOpt] let _5427: Int = Int(0)
// [KnfOpt] let join fold.5428: Int = (stream.5429: Fun([Unit], Tuple([Int, Int])), f.5430: Fun([Int, Int], Int), acc.5431: Int) {
// [KnfOpt]   let _5432: Unit = Unit
// [KnfOpt]   let _5433: Tuple([Int, Int]) = Apply(stream.5429, [_5432, ])
// [KnfOpt]   let (ok.5434: Var({val: Some(Int)}), val.5435: Var({val: Some(Int)})) = _5433
// [KnfOpt]   let _5436: Int = Int(0)
// [KnfOpt]   if (ok.5434 == _5436) then {
// [KnfOpt]     let sum.104: Int = Var(acc.5431)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _5437: Int = Apply(f.5430, [acc.5431, val.5435, ])
// [KnfOpt]     Jump(fold.5428, [stream.5429, f.5430, _5437, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.5428, [under1200.103, add.5424, _5427, ])
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 5
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 0
// [KnfOpt] Inline decision le.83 accepted
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.5440: Int = (x.5441: Int, y.5442: Int) {
// [KnfOpt]   Add(x.5441, y.5442)
// [KnfOpt] }
// [KnfOpt] let _5443: Int = Int(0)
// [KnfOpt] let join fold.5444: Int = (stream.5445: Fun([Unit], Tuple([Int, Int])), f.5446: Fun([Int, Int], Int), acc.5447: Int) {
// [KnfOpt]   let _5448: Unit = Unit
// [KnfOpt]   let _5449: Tuple([Int, Int]) = Apply(stream.5445, [_5448, ])
// [KnfOpt]   let (ok.5450: Var({val: Some(Int)}), val.5451: Var({val: Some(Int)})) = _5449
// [KnfOpt]   let _5452: Int = Int(0)
// [KnfOpt]   if (ok.5450 == _5452) then {
// [KnfOpt]     let sum.104: Int = Var(acc.5447)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _5453: Int = Apply(f.5446, [acc.5447, val.5451, ])
// [KnfOpt]     Jump(fold.5444, [stream.5445, f.5446, _5453, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.5444, [under1200.103, add.5440, _5443, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(le) let _102: Fun([Int], Int) = Unit
// [KnfOpt] let rec aux.5454: Tuple([Int, Int]) = (u.5455: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.5456: Tuple([Int, Int]) = (u.5457: Var({val: Some(Unit)})) {
// [KnfOpt]     let _5458: Unit = Unit
// [KnfOpt]     let _5459: Tuple([Int, Int]) = Apply(over50.100, [_5458, ])
// [KnfOpt]     let (ok.5460: Var({val: Some(Int)}), val.5461: Var({val: Some(Int)})) = _5459
// [KnfOpt]     let _5462: Int = Int(0)
// [KnfOpt]     if (ok.5460 == _5462) then {
// [KnfOpt]       let _5463: Int = Int(0)
// [KnfOpt]       let _5464: Int = Int(0)
// [KnfOpt]       Tuple([_5463, _5464, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.5465: Int = Apply(_102, [val.5461, ])
// [KnfOpt]       let _5466: Int = Int(0)
// [KnfOpt]       if (r.5465 == _5466) then {
// [KnfOpt]         let _5467: Int = Int(1)
// [KnfOpt]         Tuple([_5467, val.5461, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _5468: Unit = Unit
// [KnfOpt]         Jump(aux.5456, [_5468, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.5456, [u.5455, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.5454)
// [KnfOpt] let rec add.5469: Int = (x.5470: Int, y.5471: Int) {
// [KnfOpt]   Add(x.5470, y.5471)
// [KnfOpt] }
// [KnfOpt] let _5472: Int = Int(0)
// [KnfOpt] let join fold.5473: Int = (stream.5474: Fun([Unit], Tuple([Int, Int])), f.5475: Fun([Int, Int], Int), acc.5476: Int) {
// [KnfOpt]   let _5477: Unit = Unit
// [KnfOpt]   let _5478: Tuple([Int, Int]) = Apply(stream.5474, [_5477, ])
// [KnfOpt]   let (ok.5479: Var({val: Some(Int)}), val.5480: Var({val: Some(Int)})) = _5478
// [KnfOpt]   let _5481: Int = Int(0)
// [KnfOpt]   if (ok.5479 == _5481) then {
// [KnfOpt]     let sum.104: Int = Var(acc.5476)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _5482: Int = Apply(f.5475, [acc.5476, val.5480, ])
// [KnfOpt]     Jump(fold.5473, [stream.5474, f.5475, _5482, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.5473, [under1200.103, add.5469, _5472, ])
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.5485: Int = (x.5486: Int, y.5487: Int) {
// [KnfOpt]   Add(x.5486, y.5487)
// [KnfOpt] }
// [KnfOpt] let _5488: Int = Int(0)
// [KnfOpt] let join fold.5489: Int = (stream.5490: Fun([Unit], Tuple([Int, Int])), f.5491: Fun([Int, Int], Int), acc.5492: Int) {
// [KnfOpt]   let _5493: Unit = Unit
// [KnfOpt]   let _5494: Tuple([Int, Int]) = Apply(stream.5490, [_5493, ])
// [KnfOpt]   let (ok.5495: Var({val: Some(Int)}), val.5496: Var({val: Some(Int)})) = _5494
// [KnfOpt]   let _5497: Int = Int(0)
// [KnfOpt]   if (ok.5495 == _5497) then {
// [KnfOpt]     let sum.104: Int = Var(acc.5492)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _5498: Int = Apply(f.5491, [acc.5492, val.5496, ])
// [KnfOpt]     Jump(fold.5489, [stream.5490, f.5491, _5498, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.5489, [under1200.103, add.5485, _5488, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let over50.100: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let _101: Int = Int(1200)
// [KnfOpt] let rec aux.5483: Int = (y.5484: Int) {
// [KnfOpt]   if (y.5484 <= _101) then {
// [KnfOpt]     Int(0)
// [KnfOpt]   } else {
// [KnfOpt]     Int(1)
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] let _102: Fun([Int], Int) = Var(aux.5483)
// [KnfOpt] let rec aux.5499: Tuple([Int, Int]) = (u.5500: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.5501: Tuple([Int, Int]) = (u.5502: Var({val: Some(Unit)})) {
// [KnfOpt]     let _5503: Unit = Unit
// [KnfOpt]     let _5504: Tuple([Int, Int]) = Apply(over50.100, [_5503, ])
// [KnfOpt]     let (ok.5505: Var({val: Some(Int)}), val.5506: Var({val: Some(Int)})) = _5504
// [KnfOpt]     let _5507: Int = Int(0)
// [KnfOpt]     if (ok.5505 == _5507) then {
// [KnfOpt]       let _5508: Int = Int(0)
// [KnfOpt]       let _5509: Int = Int(0)
// [KnfOpt]       Tuple([_5508, _5509, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.5510: Int = Apply(_102, [val.5506, ])
// [KnfOpt]       let _5511: Int = Int(0)
// [KnfOpt]       if (r.5510 == _5511) then {
// [KnfOpt]         let _5512: Int = Int(1)
// [KnfOpt]         Tuple([_5512, val.5506, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _5513: Unit = Unit
// [KnfOpt]         Jump(aux.5501, [_5513, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.5501, [u.5500, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.5499)
// [KnfOpt] let rec add.5514: Int = (x.5515: Int, y.5516: Int) {
// [KnfOpt]   Add(x.5515, y.5516)
// [KnfOpt] }
// [KnfOpt] let _5517: Int = Int(0)
// [KnfOpt] let join fold.5518: Int = (stream.5519: Fun([Unit], Tuple([Int, Int])), f.5520: Fun([Int, Int], Int), acc.5521: Int) {
// [KnfOpt]   let _5522: Unit = Unit
// [KnfOpt]   let _5523: Tuple([Int, Int]) = Apply(stream.5519, [_5522, ])
// [KnfOpt]   let (ok.5524: Var({val: Some(Int)}), val.5525: Var({val: Some(Int)})) = _5523
// [KnfOpt]   let _5526: Int = Int(0)
// [KnfOpt]   if (ok.5524 == _5526) then {
// [KnfOpt]     let sum.104: Int = Var(acc.5521)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _5527: Int = Apply(f.5520, [acc.5521, val.5525, ])
// [KnfOpt]     Jump(fold.5518, [stream.5519, f.5520, _5527, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.5518, [under1200.103, add.5514, _5517, ])
// [KnfOpt] Inline threshold 5
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 0
// [KnfOpt] Inline decision le.83 accepted
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.5543: Int = (x.5544: Int, y.5545: Int) {
// [KnfOpt]   Add(x.5544, y.5545)
// [KnfOpt] }
// [KnfOpt] let _5546: Int = Int(0)
// [KnfOpt] let join fold.5547: Int = (stream.5548: Fun([Unit], Tuple([Int, Int])), f.5549: Fun([Int, Int], Int), acc.5550: Int) {
// [KnfOpt]   let _5551: Unit = Unit
// [KnfOpt]   let _5552: Tuple([Int, Int]) = Apply(stream.5548, [_5551, ])
// [KnfOpt]   let (ok.5553: Var({val: Some(Int)}), val.5554: Var({val: Some(Int)})) = _5552
// [KnfOpt]   let _5555: Int = Int(0)
// [KnfOpt]   if (ok.5553 == _5555) then {
// [KnfOpt]     let sum.104: Int = Var(acc.5550)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _5556: Int = Apply(f.5549, [acc.5550, val.5554, ])
// [KnfOpt]     Jump(fold.5547, [stream.5548, f.5549, _5556, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.5547, [under1200.103, add.5543, _5546, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(le) let _102: Fun([Int], Int) = Unit
// [KnfOpt] let rec aux.5557: Tuple([Int, Int]) = (u.5558: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.5559: Tuple([Int, Int]) = (u.5560: Var({val: Some(Unit)})) {
// [KnfOpt]     let _5561: Unit = Unit
// [KnfOpt]     let _5562: Tuple([Int, Int]) = Apply(over50.100, [_5561, ])
// [KnfOpt]     let (ok.5563: Var({val: Some(Int)}), val.5564: Var({val: Some(Int)})) = _5562
// [KnfOpt]     let _5565: Int = Int(0)
// [KnfOpt]     if (ok.5563 == _5565) then {
// [KnfOpt]       let _5566: Int = Int(0)
// [KnfOpt]       let _5567: Int = Int(0)
// [KnfOpt]       Tuple([_5566, _5567, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.5568: Int = Apply(_102, [val.5564, ])
// [KnfOpt]       let _5569: Int = Int(0)
// [KnfOpt]       if (r.5568 == _5569) then {
// [KnfOpt]         let _5570: Int = Int(1)
// [KnfOpt]         Tuple([_5570, val.5564, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _5571: Unit = Unit
// [KnfOpt]         Jump(aux.5559, [_5571, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.5559, [u.5558, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.5557)
// [KnfOpt] let rec add.5572: Int = (x.5573: Int, y.5574: Int) {
// [KnfOpt]   Add(x.5573, y.5574)
// [KnfOpt] }
// [KnfOpt] let _5575: Int = Int(0)
// [KnfOpt] let join fold.5576: Int = (stream.5577: Fun([Unit], Tuple([Int, Int])), f.5578: Fun([Int, Int], Int), acc.5579: Int) {
// [KnfOpt]   let _5580: Unit = Unit
// [KnfOpt]   let _5581: Tuple([Int, Int]) = Apply(stream.5577, [_5580, ])
// [KnfOpt]   let (ok.5582: Var({val: Some(Int)}), val.5583: Var({val: Some(Int)})) = _5581
// [KnfOpt]   let _5584: Int = Int(0)
// [KnfOpt]   if (ok.5582 == _5584) then {
// [KnfOpt]     let sum.104: Int = Var(acc.5579)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _5585: Int = Apply(f.5578, [acc.5579, val.5583, ])
// [KnfOpt]     Jump(fold.5576, [stream.5577, f.5578, _5585, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.5576, [under1200.103, add.5572, _5575, ])
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.5588: Int = (x.5589: Int, y.5590: Int) {
// [KnfOpt]   Add(x.5589, y.5590)
// [KnfOpt] }
// [KnfOpt] let _5591: Int = Int(0)
// [KnfOpt] let join fold.5592: Int = (stream.5593: Fun([Unit], Tuple([Int, Int])), f.5594: Fun([Int, Int], Int), acc.5595: Int) {
// [KnfOpt]   let _5596: Unit = Unit
// [KnfOpt]   let _5597: Tuple([Int, Int]) = Apply(stream.5593, [_5596, ])
// [KnfOpt]   let (ok.5598: Var({val: Some(Int)}), val.5599: Var({val: Some(Int)})) = _5597
// [KnfOpt]   let _5600: Int = Int(0)
// [KnfOpt]   if (ok.5598 == _5600) then {
// [KnfOpt]     let sum.104: Int = Var(acc.5595)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _5601: Int = Apply(f.5594, [acc.5595, val.5599, ])
// [KnfOpt]     Jump(fold.5592, [stream.5593, f.5594, _5601, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.5592, [under1200.103, add.5588, _5591, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(addx) let _96: Fun([Int], Int) = Unit
// [KnfOpt] let rec aux.5236: Tuple([Int, Int]) = (u.5237: Var({val: Some(Unit)})) {
// [KnfOpt]   let _5238: Unit = Unit
// [KnfOpt]   let _5239: Tuple([Int, Int]) = Apply(catt.94, [_5238, ])
// [KnfOpt]   let (ok.5240: Var({val: Some(Int)}), val.5241: Var({val: Some(Int)})) = _5239
// [KnfOpt]   let _5242: Int = Int(0)
// [KnfOpt]   if (ok.5240 == _5242) then {
// [KnfOpt]     let _5243: Int = Int(0)
// [KnfOpt]     let _5244: Int = Int(0)
// [KnfOpt]     Tuple([_5243, _5244, ])
// [KnfOpt]   } else {
// [KnfOpt]     let _5245: Int = Int(1)
// [KnfOpt]     let _5246: Int = Apply(_96, [val.5241, ])
// [KnfOpt]     Tuple([_5245, _5246, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] let addone.97: Fun([Unit], Tuple([Int, Int])) = Var(aux.5236)
// [KnfOpt] let _98: Int = Int(50)
// [KnfOpt] let rec aux.5438: Int = (y.5439: Int) {
// [KnfOpt]   if (_98 <= y.5439) then {
// [KnfOpt]     Int(0)
// [KnfOpt]   } else {
// [KnfOpt]     Int(1)
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] let _99: Fun([Int], Int) = Var(aux.5438)
// [KnfOpt] let rec aux.5528: Tuple([Int, Int]) = (u.5529: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.5530: Tuple([Int, Int]) = (u.5531: Var({val: Some(Unit)})) {
// [KnfOpt]     let _5532: Unit = Unit
// [KnfOpt]     let _5533: Tuple([Int, Int]) = Apply(addone.97, [_5532, ])
// [KnfOpt]     let (ok.5534: Var({val: Some(Int)}), val.5535: Var({val: Some(Int)})) = _5533
// [KnfOpt]     let _5536: Int = Int(0)
// [KnfOpt]     if (ok.5534 == _5536) then {
// [KnfOpt]       let _5537: Int = Int(0)
// [KnfOpt]       let _5538: Int = Int(0)
// [KnfOpt]       Tuple([_5537, _5538, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.5539: Int = Apply(_99, [val.5535, ])
// [KnfOpt]       let _5540: Int = Int(0)
// [KnfOpt]       if (r.5539 == _5540) then {
// [KnfOpt]         let _5541: Int = Int(1)
// [KnfOpt]         Tuple([_5541, val.5535, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _5542: Unit = Unit
// [KnfOpt]         Jump(aux.5530, [_5542, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.5530, [u.5529, ])
// [KnfOpt] }
// [KnfOpt] let over50.100: Fun([Unit], Tuple([Int, Int])) = Var(aux.5528)
// [KnfOpt] let _101: Int = Int(1200)
// [KnfOpt] let rec aux.5586: Int = (y.5587: Int) {
// [KnfOpt]   if (y.5587 <= _101) then {
// [KnfOpt]     Int(0)
// [KnfOpt]   } else {
// [KnfOpt]     Int(1)
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] let _102: Fun([Int], Int) = Var(aux.5586)
// [KnfOpt] let rec aux.5602: Tuple([Int, Int]) = (u.5603: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.5604: Tuple([Int, Int]) = (u.5605: Var({val: Some(Unit)})) {
// [KnfOpt]     let _5606: Unit = Unit
// [KnfOpt]     let _5607: Tuple([Int, Int]) = Apply(over50.100, [_5606, ])
// [KnfOpt]     let (ok.5608: Var({val: Some(Int)}), val.5609: Var({val: Some(Int)})) = _5607
// [KnfOpt]     let _5610: Int = Int(0)
// [KnfOpt]     if (ok.5608 == _5610) then {
// [KnfOpt]       let _5611: Int = Int(0)
// [KnfOpt]       let _5612: Int = Int(0)
// [KnfOpt]       Tuple([_5611, _5612, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.5613: Int = Apply(_102, [val.5609, ])
// [KnfOpt]       let _5614: Int = Int(0)
// [KnfOpt]       if (r.5613 == _5614) then {
// [KnfOpt]         let _5615: Int = Int(1)
// [KnfOpt]         Tuple([_5615, val.5609, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _5616: Unit = Unit
// [KnfOpt]         Jump(aux.5604, [_5616, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.5604, [u.5603, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.5602)
// [KnfOpt] let rec add.5617: Int = (x.5618: Int, y.5619: Int) {
// [KnfOpt]   Add(x.5618, y.5619)
// [KnfOpt] }
// [KnfOpt] let _5620: Int = Int(0)
// [KnfOpt] let join fold.5621: Int = (stream.5622: Fun([Unit], Tuple([Int, Int])), f.5623: Fun([Int, Int], Int), acc.5624: Int) {
// [KnfOpt]   let _5625: Unit = Unit
// [KnfOpt]   let _5626: Tuple([Int, Int]) = Apply(stream.5622, [_5625, ])
// [KnfOpt]   let (ok.5627: Var({val: Some(Int)}), val.5628: Var({val: Some(Int)})) = _5626
// [KnfOpt]   let _5629: Int = Int(0)
// [KnfOpt]   if (ok.5627 == _5629) then {
// [KnfOpt]     let sum.104: Int = Var(acc.5624)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _5630: Int = Apply(f.5623, [acc.5624, val.5628, ])
// [KnfOpt]     Jump(fold.5621, [stream.5622, f.5623, _5630, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.5621, [under1200.103, add.5617, _5620, ])
// [KnfOpt] Inline threshold 20
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 0
// [KnfOpt] Inline decision map.1 accepted
// [KnfOpt] Inline threshold 5
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 0
// [KnfOpt] Inline decision gt.79 accepted
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 5
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 0
// [KnfOpt] Inline decision le.83 accepted
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.5633: Int = (x.5634: Int, y.5635: Int) {
// [KnfOpt]   Add(x.5634, y.5635)
// [KnfOpt] }
// [KnfOpt] let _5636: Int = Int(0)
// [KnfOpt] let join fold.5637: Int = (stream.5638: Fun([Unit], Tuple([Int, Int])), f.5639: Fun([Int, Int], Int), acc.5640: Int) {
// [KnfOpt]   let _5641: Unit = Unit
// [KnfOpt]   let _5642: Tuple([Int, Int]) = Apply(stream.5638, [_5641, ])
// [KnfOpt]   let (ok.5643: Var({val: Some(Int)}), val.5644: Var({val: Some(Int)})) = _5642
// [KnfOpt]   let _5645: Int = Int(0)
// [KnfOpt]   if (ok.5643 == _5645) then {
// [KnfOpt]     let sum.104: Int = Var(acc.5640)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _5646: Int = Apply(f.5639, [acc.5640, val.5644, ])
// [KnfOpt]     Jump(fold.5637, [stream.5638, f.5639, _5646, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.5637, [under1200.103, add.5633, _5636, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(le) let _102: Fun([Int], Int) = Unit
// [KnfOpt] let rec aux.5647: Tuple([Int, Int]) = (u.5648: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.5649: Tuple([Int, Int]) = (u.5650: Var({val: Some(Unit)})) {
// [KnfOpt]     let _5651: Unit = Unit
// [KnfOpt]     let _5652: Tuple([Int, Int]) = Apply(over50.100, [_5651, ])
// [KnfOpt]     let (ok.5653: Var({val: Some(Int)}), val.5654: Var({val: Some(Int)})) = _5652
// [KnfOpt]     let _5655: Int = Int(0)
// [KnfOpt]     if (ok.5653 == _5655) then {
// [KnfOpt]       let _5656: Int = Int(0)
// [KnfOpt]       let _5657: Int = Int(0)
// [KnfOpt]       Tuple([_5656, _5657, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.5658: Int = Apply(_102, [val.5654, ])
// [KnfOpt]       let _5659: Int = Int(0)
// [KnfOpt]       if (r.5658 == _5659) then {
// [KnfOpt]         let _5660: Int = Int(1)
// [KnfOpt]         Tuple([_5660, val.5654, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _5661: Unit = Unit
// [KnfOpt]         Jump(aux.5649, [_5661, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.5649, [u.5648, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.5647)
// [KnfOpt] let rec add.5662: Int = (x.5663: Int, y.5664: Int) {
// [KnfOpt]   Add(x.5663, y.5664)
// [KnfOpt] }
// [KnfOpt] let _5665: Int = Int(0)
// [KnfOpt] let join fold.5666: Int = (stream.5667: Fun([Unit], Tuple([Int, Int])), f.5668: Fun([Int, Int], Int), acc.5669: Int) {
// [KnfOpt]   let _5670: Unit = Unit
// [KnfOpt]   let _5671: Tuple([Int, Int]) = Apply(stream.5667, [_5670, ])
// [KnfOpt]   let (ok.5672: Var({val: Some(Int)}), val.5673: Var({val: Some(Int)})) = _5671
// [KnfOpt]   let _5674: Int = Int(0)
// [KnfOpt]   if (ok.5672 == _5674) then {
// [KnfOpt]     let sum.104: Int = Var(acc.5669)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _5675: Int = Apply(f.5668, [acc.5669, val.5673, ])
// [KnfOpt]     Jump(fold.5666, [stream.5667, f.5668, _5675, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.5666, [under1200.103, add.5662, _5665, ])
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.5678: Int = (x.5679: Int, y.5680: Int) {
// [KnfOpt]   Add(x.5679, y.5680)
// [KnfOpt] }
// [KnfOpt] let _5681: Int = Int(0)
// [KnfOpt] let join fold.5682: Int = (stream.5683: Fun([Unit], Tuple([Int, Int])), f.5684: Fun([Int, Int], Int), acc.5685: Int) {
// [KnfOpt]   let _5686: Unit = Unit
// [KnfOpt]   let _5687: Tuple([Int, Int]) = Apply(stream.5683, [_5686, ])
// [KnfOpt]   let (ok.5688: Var({val: Some(Int)}), val.5689: Var({val: Some(Int)})) = _5687
// [KnfOpt]   let _5690: Int = Int(0)
// [KnfOpt]   if (ok.5688 == _5690) then {
// [KnfOpt]     let sum.104: Int = Var(acc.5685)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _5691: Int = Apply(f.5684, [acc.5685, val.5689, ])
// [KnfOpt]     Jump(fold.5682, [stream.5683, f.5684, _5691, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.5682, [under1200.103, add.5678, _5681, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let over50.100: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let _101: Int = Int(1200)
// [KnfOpt] let rec aux.5676: Int = (y.5677: Int) {
// [KnfOpt]   if (y.5677 <= _101) then {
// [KnfOpt]     Int(0)
// [KnfOpt]   } else {
// [KnfOpt]     Int(1)
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] let _102: Fun([Int], Int) = Var(aux.5676)
// [KnfOpt] let rec aux.5692: Tuple([Int, Int]) = (u.5693: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.5694: Tuple([Int, Int]) = (u.5695: Var({val: Some(Unit)})) {
// [KnfOpt]     let _5696: Unit = Unit
// [KnfOpt]     let _5697: Tuple([Int, Int]) = Apply(over50.100, [_5696, ])
// [KnfOpt]     let (ok.5698: Var({val: Some(Int)}), val.5699: Var({val: Some(Int)})) = _5697
// [KnfOpt]     let _5700: Int = Int(0)
// [KnfOpt]     if (ok.5698 == _5700) then {
// [KnfOpt]       let _5701: Int = Int(0)
// [KnfOpt]       let _5702: Int = Int(0)
// [KnfOpt]       Tuple([_5701, _5702, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.5703: Int = Apply(_102, [val.5699, ])
// [KnfOpt]       let _5704: Int = Int(0)
// [KnfOpt]       if (r.5703 == _5704) then {
// [KnfOpt]         let _5705: Int = Int(1)
// [KnfOpt]         Tuple([_5705, val.5699, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _5706: Unit = Unit
// [KnfOpt]         Jump(aux.5694, [_5706, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.5694, [u.5693, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.5692)
// [KnfOpt] let rec add.5707: Int = (x.5708: Int, y.5709: Int) {
// [KnfOpt]   Add(x.5708, y.5709)
// [KnfOpt] }
// [KnfOpt] let _5710: Int = Int(0)
// [KnfOpt] let join fold.5711: Int = (stream.5712: Fun([Unit], Tuple([Int, Int])), f.5713: Fun([Int, Int], Int), acc.5714: Int) {
// [KnfOpt]   let _5715: Unit = Unit
// [KnfOpt]   let _5716: Tuple([Int, Int]) = Apply(stream.5712, [_5715, ])
// [KnfOpt]   let (ok.5717: Var({val: Some(Int)}), val.5718: Var({val: Some(Int)})) = _5716
// [KnfOpt]   let _5719: Int = Int(0)
// [KnfOpt]   if (ok.5717 == _5719) then {
// [KnfOpt]     let sum.104: Int = Var(acc.5714)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _5720: Int = Apply(f.5713, [acc.5714, val.5718, ])
// [KnfOpt]     Jump(fold.5711, [stream.5712, f.5713, _5720, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.5711, [under1200.103, add.5707, _5710, ])
// [KnfOpt] Inline threshold 5
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 0
// [KnfOpt] Inline decision le.83 accepted
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.5736: Int = (x.5737: Int, y.5738: Int) {
// [KnfOpt]   Add(x.5737, y.5738)
// [KnfOpt] }
// [KnfOpt] let _5739: Int = Int(0)
// [KnfOpt] let join fold.5740: Int = (stream.5741: Fun([Unit], Tuple([Int, Int])), f.5742: Fun([Int, Int], Int), acc.5743: Int) {
// [KnfOpt]   let _5744: Unit = Unit
// [KnfOpt]   let _5745: Tuple([Int, Int]) = Apply(stream.5741, [_5744, ])
// [KnfOpt]   let (ok.5746: Var({val: Some(Int)}), val.5747: Var({val: Some(Int)})) = _5745
// [KnfOpt]   let _5748: Int = Int(0)
// [KnfOpt]   if (ok.5746 == _5748) then {
// [KnfOpt]     let sum.104: Int = Var(acc.5743)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _5749: Int = Apply(f.5742, [acc.5743, val.5747, ])
// [KnfOpt]     Jump(fold.5740, [stream.5741, f.5742, _5749, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.5740, [under1200.103, add.5736, _5739, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(le) let _102: Fun([Int], Int) = Unit
// [KnfOpt] let rec aux.5750: Tuple([Int, Int]) = (u.5751: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.5752: Tuple([Int, Int]) = (u.5753: Var({val: Some(Unit)})) {
// [KnfOpt]     let _5754: Unit = Unit
// [KnfOpt]     let _5755: Tuple([Int, Int]) = Apply(over50.100, [_5754, ])
// [KnfOpt]     let (ok.5756: Var({val: Some(Int)}), val.5757: Var({val: Some(Int)})) = _5755
// [KnfOpt]     let _5758: Int = Int(0)
// [KnfOpt]     if (ok.5756 == _5758) then {
// [KnfOpt]       let _5759: Int = Int(0)
// [KnfOpt]       let _5760: Int = Int(0)
// [KnfOpt]       Tuple([_5759, _5760, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.5761: Int = Apply(_102, [val.5757, ])
// [KnfOpt]       let _5762: Int = Int(0)
// [KnfOpt]       if (r.5761 == _5762) then {
// [KnfOpt]         let _5763: Int = Int(1)
// [KnfOpt]         Tuple([_5763, val.5757, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _5764: Unit = Unit
// [KnfOpt]         Jump(aux.5752, [_5764, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.5752, [u.5751, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.5750)
// [KnfOpt] let rec add.5765: Int = (x.5766: Int, y.5767: Int) {
// [KnfOpt]   Add(x.5766, y.5767)
// [KnfOpt] }
// [KnfOpt] let _5768: Int = Int(0)
// [KnfOpt] let join fold.5769: Int = (stream.5770: Fun([Unit], Tuple([Int, Int])), f.5771: Fun([Int, Int], Int), acc.5772: Int) {
// [KnfOpt]   let _5773: Unit = Unit
// [KnfOpt]   let _5774: Tuple([Int, Int]) = Apply(stream.5770, [_5773, ])
// [KnfOpt]   let (ok.5775: Var({val: Some(Int)}), val.5776: Var({val: Some(Int)})) = _5774
// [KnfOpt]   let _5777: Int = Int(0)
// [KnfOpt]   if (ok.5775 == _5777) then {
// [KnfOpt]     let sum.104: Int = Var(acc.5772)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _5778: Int = Apply(f.5771, [acc.5772, val.5776, ])
// [KnfOpt]     Jump(fold.5769, [stream.5770, f.5771, _5778, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.5769, [under1200.103, add.5765, _5768, ])
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.5781: Int = (x.5782: Int, y.5783: Int) {
// [KnfOpt]   Add(x.5782, y.5783)
// [KnfOpt] }
// [KnfOpt] let _5784: Int = Int(0)
// [KnfOpt] let join fold.5785: Int = (stream.5786: Fun([Unit], Tuple([Int, Int])), f.5787: Fun([Int, Int], Int), acc.5788: Int) {
// [KnfOpt]   let _5789: Unit = Unit
// [KnfOpt]   let _5790: Tuple([Int, Int]) = Apply(stream.5786, [_5789, ])
// [KnfOpt]   let (ok.5791: Var({val: Some(Int)}), val.5792: Var({val: Some(Int)})) = _5790
// [KnfOpt]   let _5793: Int = Int(0)
// [KnfOpt]   if (ok.5791 == _5793) then {
// [KnfOpt]     let sum.104: Int = Var(acc.5788)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _5794: Int = Apply(f.5787, [acc.5788, val.5792, ])
// [KnfOpt]     Jump(fold.5785, [stream.5786, f.5787, _5794, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.5785, [under1200.103, add.5781, _5784, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(gt) let _99: Fun([Int], Int) = Unit
// [KnfOpt] let rec aux.5721: Tuple([Int, Int]) = (u.5722: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.5723: Tuple([Int, Int]) = (u.5724: Var({val: Some(Unit)})) {
// [KnfOpt]     let _5725: Unit = Unit
// [KnfOpt]     let _5726: Tuple([Int, Int]) = Apply(addone.97, [_5725, ])
// [KnfOpt]     let (ok.5727: Var({val: Some(Int)}), val.5728: Var({val: Some(Int)})) = _5726
// [KnfOpt]     let _5729: Int = Int(0)
// [KnfOpt]     if (ok.5727 == _5729) then {
// [KnfOpt]       let _5730: Int = Int(0)
// [KnfOpt]       let _5731: Int = Int(0)
// [KnfOpt]       Tuple([_5730, _5731, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.5732: Int = Apply(_99, [val.5728, ])
// [KnfOpt]       let _5733: Int = Int(0)
// [KnfOpt]       if (r.5732 == _5733) then {
// [KnfOpt]         let _5734: Int = Int(1)
// [KnfOpt]         Tuple([_5734, val.5728, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _5735: Unit = Unit
// [KnfOpt]         Jump(aux.5723, [_5735, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.5723, [u.5722, ])
// [KnfOpt] }
// [KnfOpt] let over50.100: Fun([Unit], Tuple([Int, Int])) = Var(aux.5721)
// [KnfOpt] let _101: Int = Int(1200)
// [KnfOpt] let rec aux.5779: Int = (y.5780: Int) {
// [KnfOpt]   if (y.5780 <= _101) then {
// [KnfOpt]     Int(0)
// [KnfOpt]   } else {
// [KnfOpt]     Int(1)
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] let _102: Fun([Int], Int) = Var(aux.5779)
// [KnfOpt] let rec aux.5795: Tuple([Int, Int]) = (u.5796: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.5797: Tuple([Int, Int]) = (u.5798: Var({val: Some(Unit)})) {
// [KnfOpt]     let _5799: Unit = Unit
// [KnfOpt]     let _5800: Tuple([Int, Int]) = Apply(over50.100, [_5799, ])
// [KnfOpt]     let (ok.5801: Var({val: Some(Int)}), val.5802: Var({val: Some(Int)})) = _5800
// [KnfOpt]     let _5803: Int = Int(0)
// [KnfOpt]     if (ok.5801 == _5803) then {
// [KnfOpt]       let _5804: Int = Int(0)
// [KnfOpt]       let _5805: Int = Int(0)
// [KnfOpt]       Tuple([_5804, _5805, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.5806: Int = Apply(_102, [val.5802, ])
// [KnfOpt]       let _5807: Int = Int(0)
// [KnfOpt]       if (r.5806 == _5807) then {
// [KnfOpt]         let _5808: Int = Int(1)
// [KnfOpt]         Tuple([_5808, val.5802, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _5809: Unit = Unit
// [KnfOpt]         Jump(aux.5797, [_5809, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.5797, [u.5796, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.5795)
// [KnfOpt] let rec add.5810: Int = (x.5811: Int, y.5812: Int) {
// [KnfOpt]   Add(x.5811, y.5812)
// [KnfOpt] }
// [KnfOpt] let _5813: Int = Int(0)
// [KnfOpt] let join fold.5814: Int = (stream.5815: Fun([Unit], Tuple([Int, Int])), f.5816: Fun([Int, Int], Int), acc.5817: Int) {
// [KnfOpt]   let _5818: Unit = Unit
// [KnfOpt]   let _5819: Tuple([Int, Int]) = Apply(stream.5815, [_5818, ])
// [KnfOpt]   let (ok.5820: Var({val: Some(Int)}), val.5821: Var({val: Some(Int)})) = _5819
// [KnfOpt]   let _5822: Int = Int(0)
// [KnfOpt]   if (ok.5820 == _5822) then {
// [KnfOpt]     let sum.104: Int = Var(acc.5817)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _5823: Int = Apply(f.5816, [acc.5817, val.5821, ])
// [KnfOpt]     Jump(fold.5814, [stream.5815, f.5816, _5823, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.5814, [under1200.103, add.5810, _5813, ])
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 5
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 0
// [KnfOpt] Inline decision le.83 accepted
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.5826: Int = (x.5827: Int, y.5828: Int) {
// [KnfOpt]   Add(x.5827, y.5828)
// [KnfOpt] }
// [KnfOpt] let _5829: Int = Int(0)
// [KnfOpt] let join fold.5830: Int = (stream.5831: Fun([Unit], Tuple([Int, Int])), f.5832: Fun([Int, Int], Int), acc.5833: Int) {
// [KnfOpt]   let _5834: Unit = Unit
// [KnfOpt]   let _5835: Tuple([Int, Int]) = Apply(stream.5831, [_5834, ])
// [KnfOpt]   let (ok.5836: Var({val: Some(Int)}), val.5837: Var({val: Some(Int)})) = _5835
// [KnfOpt]   let _5838: Int = Int(0)
// [KnfOpt]   if (ok.5836 == _5838) then {
// [KnfOpt]     let sum.104: Int = Var(acc.5833)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _5839: Int = Apply(f.5832, [acc.5833, val.5837, ])
// [KnfOpt]     Jump(fold.5830, [stream.5831, f.5832, _5839, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.5830, [under1200.103, add.5826, _5829, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(le) let _102: Fun([Int], Int) = Unit
// [KnfOpt] let rec aux.5840: Tuple([Int, Int]) = (u.5841: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.5842: Tuple([Int, Int]) = (u.5843: Var({val: Some(Unit)})) {
// [KnfOpt]     let _5844: Unit = Unit
// [KnfOpt]     let _5845: Tuple([Int, Int]) = Apply(over50.100, [_5844, ])
// [KnfOpt]     let (ok.5846: Var({val: Some(Int)}), val.5847: Var({val: Some(Int)})) = _5845
// [KnfOpt]     let _5848: Int = Int(0)
// [KnfOpt]     if (ok.5846 == _5848) then {
// [KnfOpt]       let _5849: Int = Int(0)
// [KnfOpt]       let _5850: Int = Int(0)
// [KnfOpt]       Tuple([_5849, _5850, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.5851: Int = Apply(_102, [val.5847, ])
// [KnfOpt]       let _5852: Int = Int(0)
// [KnfOpt]       if (r.5851 == _5852) then {
// [KnfOpt]         let _5853: Int = Int(1)
// [KnfOpt]         Tuple([_5853, val.5847, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _5854: Unit = Unit
// [KnfOpt]         Jump(aux.5842, [_5854, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.5842, [u.5841, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.5840)
// [KnfOpt] let rec add.5855: Int = (x.5856: Int, y.5857: Int) {
// [KnfOpt]   Add(x.5856, y.5857)
// [KnfOpt] }
// [KnfOpt] let _5858: Int = Int(0)
// [KnfOpt] let join fold.5859: Int = (stream.5860: Fun([Unit], Tuple([Int, Int])), f.5861: Fun([Int, Int], Int), acc.5862: Int) {
// [KnfOpt]   let _5863: Unit = Unit
// [KnfOpt]   let _5864: Tuple([Int, Int]) = Apply(stream.5860, [_5863, ])
// [KnfOpt]   let (ok.5865: Var({val: Some(Int)}), val.5866: Var({val: Some(Int)})) = _5864
// [KnfOpt]   let _5867: Int = Int(0)
// [KnfOpt]   if (ok.5865 == _5867) then {
// [KnfOpt]     let sum.104: Int = Var(acc.5862)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _5868: Int = Apply(f.5861, [acc.5862, val.5866, ])
// [KnfOpt]     Jump(fold.5859, [stream.5860, f.5861, _5868, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.5859, [under1200.103, add.5855, _5858, ])
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.5871: Int = (x.5872: Int, y.5873: Int) {
// [KnfOpt]   Add(x.5872, y.5873)
// [KnfOpt] }
// [KnfOpt] let _5874: Int = Int(0)
// [KnfOpt] let join fold.5875: Int = (stream.5876: Fun([Unit], Tuple([Int, Int])), f.5877: Fun([Int, Int], Int), acc.5878: Int) {
// [KnfOpt]   let _5879: Unit = Unit
// [KnfOpt]   let _5880: Tuple([Int, Int]) = Apply(stream.5876, [_5879, ])
// [KnfOpt]   let (ok.5881: Var({val: Some(Int)}), val.5882: Var({val: Some(Int)})) = _5880
// [KnfOpt]   let _5883: Int = Int(0)
// [KnfOpt]   if (ok.5881 == _5883) then {
// [KnfOpt]     let sum.104: Int = Var(acc.5878)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _5884: Int = Apply(f.5877, [acc.5878, val.5882, ])
// [KnfOpt]     Jump(fold.5875, [stream.5876, f.5877, _5884, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.5875, [under1200.103, add.5871, _5874, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let over50.100: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let _101: Int = Int(1200)
// [KnfOpt] let rec aux.5869: Int = (y.5870: Int) {
// [KnfOpt]   if (y.5870 <= _101) then {
// [KnfOpt]     Int(0)
// [KnfOpt]   } else {
// [KnfOpt]     Int(1)
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] let _102: Fun([Int], Int) = Var(aux.5869)
// [KnfOpt] let rec aux.5885: Tuple([Int, Int]) = (u.5886: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.5887: Tuple([Int, Int]) = (u.5888: Var({val: Some(Unit)})) {
// [KnfOpt]     let _5889: Unit = Unit
// [KnfOpt]     let _5890: Tuple([Int, Int]) = Apply(over50.100, [_5889, ])
// [KnfOpt]     let (ok.5891: Var({val: Some(Int)}), val.5892: Var({val: Some(Int)})) = _5890
// [KnfOpt]     let _5893: Int = Int(0)
// [KnfOpt]     if (ok.5891 == _5893) then {
// [KnfOpt]       let _5894: Int = Int(0)
// [KnfOpt]       let _5895: Int = Int(0)
// [KnfOpt]       Tuple([_5894, _5895, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.5896: Int = Apply(_102, [val.5892, ])
// [KnfOpt]       let _5897: Int = Int(0)
// [KnfOpt]       if (r.5896 == _5897) then {
// [KnfOpt]         let _5898: Int = Int(1)
// [KnfOpt]         Tuple([_5898, val.5892, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _5899: Unit = Unit
// [KnfOpt]         Jump(aux.5887, [_5899, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.5887, [u.5886, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.5885)
// [KnfOpt] let rec add.5900: Int = (x.5901: Int, y.5902: Int) {
// [KnfOpt]   Add(x.5901, y.5902)
// [KnfOpt] }
// [KnfOpt] let _5903: Int = Int(0)
// [KnfOpt] let join fold.5904: Int = (stream.5905: Fun([Unit], Tuple([Int, Int])), f.5906: Fun([Int, Int], Int), acc.5907: Int) {
// [KnfOpt]   let _5908: Unit = Unit
// [KnfOpt]   let _5909: Tuple([Int, Int]) = Apply(stream.5905, [_5908, ])
// [KnfOpt]   let (ok.5910: Var({val: Some(Int)}), val.5911: Var({val: Some(Int)})) = _5909
// [KnfOpt]   let _5912: Int = Int(0)
// [KnfOpt]   if (ok.5910 == _5912) then {
// [KnfOpt]     let sum.104: Int = Var(acc.5907)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _5913: Int = Apply(f.5906, [acc.5907, val.5911, ])
// [KnfOpt]     Jump(fold.5904, [stream.5905, f.5906, _5913, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.5904, [under1200.103, add.5900, _5903, ])
// [KnfOpt] Inline threshold 5
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 0
// [KnfOpt] Inline decision le.83 accepted
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.5929: Int = (x.5930: Int, y.5931: Int) {
// [KnfOpt]   Add(x.5930, y.5931)
// [KnfOpt] }
// [KnfOpt] let _5932: Int = Int(0)
// [KnfOpt] let join fold.5933: Int = (stream.5934: Fun([Unit], Tuple([Int, Int])), f.5935: Fun([Int, Int], Int), acc.5936: Int) {
// [KnfOpt]   let _5937: Unit = Unit
// [KnfOpt]   let _5938: Tuple([Int, Int]) = Apply(stream.5934, [_5937, ])
// [KnfOpt]   let (ok.5939: Var({val: Some(Int)}), val.5940: Var({val: Some(Int)})) = _5938
// [KnfOpt]   let _5941: Int = Int(0)
// [KnfOpt]   if (ok.5939 == _5941) then {
// [KnfOpt]     let sum.104: Int = Var(acc.5936)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _5942: Int = Apply(f.5935, [acc.5936, val.5940, ])
// [KnfOpt]     Jump(fold.5933, [stream.5934, f.5935, _5942, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.5933, [under1200.103, add.5929, _5932, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(le) let _102: Fun([Int], Int) = Unit
// [KnfOpt] let rec aux.5943: Tuple([Int, Int]) = (u.5944: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.5945: Tuple([Int, Int]) = (u.5946: Var({val: Some(Unit)})) {
// [KnfOpt]     let _5947: Unit = Unit
// [KnfOpt]     let _5948: Tuple([Int, Int]) = Apply(over50.100, [_5947, ])
// [KnfOpt]     let (ok.5949: Var({val: Some(Int)}), val.5950: Var({val: Some(Int)})) = _5948
// [KnfOpt]     let _5951: Int = Int(0)
// [KnfOpt]     if (ok.5949 == _5951) then {
// [KnfOpt]       let _5952: Int = Int(0)
// [KnfOpt]       let _5953: Int = Int(0)
// [KnfOpt]       Tuple([_5952, _5953, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.5954: Int = Apply(_102, [val.5950, ])
// [KnfOpt]       let _5955: Int = Int(0)
// [KnfOpt]       if (r.5954 == _5955) then {
// [KnfOpt]         let _5956: Int = Int(1)
// [KnfOpt]         Tuple([_5956, val.5950, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _5957: Unit = Unit
// [KnfOpt]         Jump(aux.5945, [_5957, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.5945, [u.5944, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.5943)
// [KnfOpt] let rec add.5958: Int = (x.5959: Int, y.5960: Int) {
// [KnfOpt]   Add(x.5959, y.5960)
// [KnfOpt] }
// [KnfOpt] let _5961: Int = Int(0)
// [KnfOpt] let join fold.5962: Int = (stream.5963: Fun([Unit], Tuple([Int, Int])), f.5964: Fun([Int, Int], Int), acc.5965: Int) {
// [KnfOpt]   let _5966: Unit = Unit
// [KnfOpt]   let _5967: Tuple([Int, Int]) = Apply(stream.5963, [_5966, ])
// [KnfOpt]   let (ok.5968: Var({val: Some(Int)}), val.5969: Var({val: Some(Int)})) = _5967
// [KnfOpt]   let _5970: Int = Int(0)
// [KnfOpt]   if (ok.5968 == _5970) then {
// [KnfOpt]     let sum.104: Int = Var(acc.5965)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _5971: Int = Apply(f.5964, [acc.5965, val.5969, ])
// [KnfOpt]     Jump(fold.5962, [stream.5963, f.5964, _5971, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.5962, [under1200.103, add.5958, _5961, ])
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.5974: Int = (x.5975: Int, y.5976: Int) {
// [KnfOpt]   Add(x.5975, y.5976)
// [KnfOpt] }
// [KnfOpt] let _5977: Int = Int(0)
// [KnfOpt] let join fold.5978: Int = (stream.5979: Fun([Unit], Tuple([Int, Int])), f.5980: Fun([Int, Int], Int), acc.5981: Int) {
// [KnfOpt]   let _5982: Unit = Unit
// [KnfOpt]   let _5983: Tuple([Int, Int]) = Apply(stream.5979, [_5982, ])
// [KnfOpt]   let (ok.5984: Var({val: Some(Int)}), val.5985: Var({val: Some(Int)})) = _5983
// [KnfOpt]   let _5986: Int = Int(0)
// [KnfOpt]   if (ok.5984 == _5986) then {
// [KnfOpt]     let sum.104: Int = Var(acc.5981)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _5987: Int = Apply(f.5980, [acc.5981, val.5985, ])
// [KnfOpt]     Jump(fold.5978, [stream.5979, f.5980, _5987, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.5978, [under1200.103, add.5974, _5977, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(map) let addone.97: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let _98: Int = Int(50)
// [KnfOpt] let rec aux.5824: Int = (y.5825: Int) {
// [KnfOpt]   if (_98 <= y.5825) then {
// [KnfOpt]     Int(0)
// [KnfOpt]   } else {
// [KnfOpt]     Int(1)
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] let _99: Fun([Int], Int) = Var(aux.5824)
// [KnfOpt] let rec aux.5914: Tuple([Int, Int]) = (u.5915: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.5916: Tuple([Int, Int]) = (u.5917: Var({val: Some(Unit)})) {
// [KnfOpt]     let _5918: Unit = Unit
// [KnfOpt]     let _5919: Tuple([Int, Int]) = Apply(addone.97, [_5918, ])
// [KnfOpt]     let (ok.5920: Var({val: Some(Int)}), val.5921: Var({val: Some(Int)})) = _5919
// [KnfOpt]     let _5922: Int = Int(0)
// [KnfOpt]     if (ok.5920 == _5922) then {
// [KnfOpt]       let _5923: Int = Int(0)
// [KnfOpt]       let _5924: Int = Int(0)
// [KnfOpt]       Tuple([_5923, _5924, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.5925: Int = Apply(_99, [val.5921, ])
// [KnfOpt]       let _5926: Int = Int(0)
// [KnfOpt]       if (r.5925 == _5926) then {
// [KnfOpt]         let _5927: Int = Int(1)
// [KnfOpt]         Tuple([_5927, val.5921, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _5928: Unit = Unit
// [KnfOpt]         Jump(aux.5916, [_5928, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.5916, [u.5915, ])
// [KnfOpt] }
// [KnfOpt] let over50.100: Fun([Unit], Tuple([Int, Int])) = Var(aux.5914)
// [KnfOpt] let _101: Int = Int(1200)
// [KnfOpt] let rec aux.5972: Int = (y.5973: Int) {
// [KnfOpt]   if (y.5973 <= _101) then {
// [KnfOpt]     Int(0)
// [KnfOpt]   } else {
// [KnfOpt]     Int(1)
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] let _102: Fun([Int], Int) = Var(aux.5972)
// [KnfOpt] let rec aux.5988: Tuple([Int, Int]) = (u.5989: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.5990: Tuple([Int, Int]) = (u.5991: Var({val: Some(Unit)})) {
// [KnfOpt]     let _5992: Unit = Unit
// [KnfOpt]     let _5993: Tuple([Int, Int]) = Apply(over50.100, [_5992, ])
// [KnfOpt]     let (ok.5994: Var({val: Some(Int)}), val.5995: Var({val: Some(Int)})) = _5993
// [KnfOpt]     let _5996: Int = Int(0)
// [KnfOpt]     if (ok.5994 == _5996) then {
// [KnfOpt]       let _5997: Int = Int(0)
// [KnfOpt]       let _5998: Int = Int(0)
// [KnfOpt]       Tuple([_5997, _5998, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.5999: Int = Apply(_102, [val.5995, ])
// [KnfOpt]       let _6000: Int = Int(0)
// [KnfOpt]       if (r.5999 == _6000) then {
// [KnfOpt]         let _6001: Int = Int(1)
// [KnfOpt]         Tuple([_6001, val.5995, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _6002: Unit = Unit
// [KnfOpt]         Jump(aux.5990, [_6002, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.5990, [u.5989, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.5988)
// [KnfOpt] let rec add.6003: Int = (x.6004: Int, y.6005: Int) {
// [KnfOpt]   Add(x.6004, y.6005)
// [KnfOpt] }
// [KnfOpt] let _6006: Int = Int(0)
// [KnfOpt] let join fold.6007: Int = (stream.6008: Fun([Unit], Tuple([Int, Int])), f.6009: Fun([Int, Int], Int), acc.6010: Int) {
// [KnfOpt]   let _6011: Unit = Unit
// [KnfOpt]   let _6012: Tuple([Int, Int]) = Apply(stream.6008, [_6011, ])
// [KnfOpt]   let (ok.6013: Var({val: Some(Int)}), val.6014: Var({val: Some(Int)})) = _6012
// [KnfOpt]   let _6015: Int = Int(0)
// [KnfOpt]   if (ok.6013 == _6015) then {
// [KnfOpt]     let sum.104: Int = Var(acc.6010)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _6016: Int = Apply(f.6009, [acc.6010, val.6014, ])
// [KnfOpt]     Jump(fold.6007, [stream.6008, f.6009, _6016, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.6007, [under1200.103, add.6003, _6006, ])
// [KnfOpt] Inline threshold 5
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 0
// [KnfOpt] Inline decision gt.79 accepted
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 5
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 0
// [KnfOpt] Inline decision le.83 accepted
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.6028: Int = (x.6029: Int, y.6030: Int) {
// [KnfOpt]   Add(x.6029, y.6030)
// [KnfOpt] }
// [KnfOpt] let _6031: Int = Int(0)
// [KnfOpt] let join fold.6032: Int = (stream.6033: Fun([Unit], Tuple([Int, Int])), f.6034: Fun([Int, Int], Int), acc.6035: Int) {
// [KnfOpt]   let _6036: Unit = Unit
// [KnfOpt]   let _6037: Tuple([Int, Int]) = Apply(stream.6033, [_6036, ])
// [KnfOpt]   let (ok.6038: Var({val: Some(Int)}), val.6039: Var({val: Some(Int)})) = _6037
// [KnfOpt]   let _6040: Int = Int(0)
// [KnfOpt]   if (ok.6038 == _6040) then {
// [KnfOpt]     let sum.104: Int = Var(acc.6035)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _6041: Int = Apply(f.6034, [acc.6035, val.6039, ])
// [KnfOpt]     Jump(fold.6032, [stream.6033, f.6034, _6041, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.6032, [under1200.103, add.6028, _6031, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(le) let _102: Fun([Int], Int) = Unit
// [KnfOpt] let rec aux.6042: Tuple([Int, Int]) = (u.6043: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.6044: Tuple([Int, Int]) = (u.6045: Var({val: Some(Unit)})) {
// [KnfOpt]     let _6046: Unit = Unit
// [KnfOpt]     let _6047: Tuple([Int, Int]) = Apply(over50.100, [_6046, ])
// [KnfOpt]     let (ok.6048: Var({val: Some(Int)}), val.6049: Var({val: Some(Int)})) = _6047
// [KnfOpt]     let _6050: Int = Int(0)
// [KnfOpt]     if (ok.6048 == _6050) then {
// [KnfOpt]       let _6051: Int = Int(0)
// [KnfOpt]       let _6052: Int = Int(0)
// [KnfOpt]       Tuple([_6051, _6052, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.6053: Int = Apply(_102, [val.6049, ])
// [KnfOpt]       let _6054: Int = Int(0)
// [KnfOpt]       if (r.6053 == _6054) then {
// [KnfOpt]         let _6055: Int = Int(1)
// [KnfOpt]         Tuple([_6055, val.6049, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _6056: Unit = Unit
// [KnfOpt]         Jump(aux.6044, [_6056, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.6044, [u.6043, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.6042)
// [KnfOpt] let rec add.6057: Int = (x.6058: Int, y.6059: Int) {
// [KnfOpt]   Add(x.6058, y.6059)
// [KnfOpt] }
// [KnfOpt] let _6060: Int = Int(0)
// [KnfOpt] let join fold.6061: Int = (stream.6062: Fun([Unit], Tuple([Int, Int])), f.6063: Fun([Int, Int], Int), acc.6064: Int) {
// [KnfOpt]   let _6065: Unit = Unit
// [KnfOpt]   let _6066: Tuple([Int, Int]) = Apply(stream.6062, [_6065, ])
// [KnfOpt]   let (ok.6067: Var({val: Some(Int)}), val.6068: Var({val: Some(Int)})) = _6066
// [KnfOpt]   let _6069: Int = Int(0)
// [KnfOpt]   if (ok.6067 == _6069) then {
// [KnfOpt]     let sum.104: Int = Var(acc.6064)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _6070: Int = Apply(f.6063, [acc.6064, val.6068, ])
// [KnfOpt]     Jump(fold.6061, [stream.6062, f.6063, _6070, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.6061, [under1200.103, add.6057, _6060, ])
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.6073: Int = (x.6074: Int, y.6075: Int) {
// [KnfOpt]   Add(x.6074, y.6075)
// [KnfOpt] }
// [KnfOpt] let _6076: Int = Int(0)
// [KnfOpt] let join fold.6077: Int = (stream.6078: Fun([Unit], Tuple([Int, Int])), f.6079: Fun([Int, Int], Int), acc.6080: Int) {
// [KnfOpt]   let _6081: Unit = Unit
// [KnfOpt]   let _6082: Tuple([Int, Int]) = Apply(stream.6078, [_6081, ])
// [KnfOpt]   let (ok.6083: Var({val: Some(Int)}), val.6084: Var({val: Some(Int)})) = _6082
// [KnfOpt]   let _6085: Int = Int(0)
// [KnfOpt]   if (ok.6083 == _6085) then {
// [KnfOpt]     let sum.104: Int = Var(acc.6080)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _6086: Int = Apply(f.6079, [acc.6080, val.6084, ])
// [KnfOpt]     Jump(fold.6077, [stream.6078, f.6079, _6086, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.6077, [under1200.103, add.6073, _6076, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let over50.100: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let _101: Int = Int(1200)
// [KnfOpt] let rec aux.6071: Int = (y.6072: Int) {
// [KnfOpt]   if (y.6072 <= _101) then {
// [KnfOpt]     Int(0)
// [KnfOpt]   } else {
// [KnfOpt]     Int(1)
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] let _102: Fun([Int], Int) = Var(aux.6071)
// [KnfOpt] let rec aux.6087: Tuple([Int, Int]) = (u.6088: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.6089: Tuple([Int, Int]) = (u.6090: Var({val: Some(Unit)})) {
// [KnfOpt]     let _6091: Unit = Unit
// [KnfOpt]     let _6092: Tuple([Int, Int]) = Apply(over50.100, [_6091, ])
// [KnfOpt]     let (ok.6093: Var({val: Some(Int)}), val.6094: Var({val: Some(Int)})) = _6092
// [KnfOpt]     let _6095: Int = Int(0)
// [KnfOpt]     if (ok.6093 == _6095) then {
// [KnfOpt]       let _6096: Int = Int(0)
// [KnfOpt]       let _6097: Int = Int(0)
// [KnfOpt]       Tuple([_6096, _6097, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.6098: Int = Apply(_102, [val.6094, ])
// [KnfOpt]       let _6099: Int = Int(0)
// [KnfOpt]       if (r.6098 == _6099) then {
// [KnfOpt]         let _6100: Int = Int(1)
// [KnfOpt]         Tuple([_6100, val.6094, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _6101: Unit = Unit
// [KnfOpt]         Jump(aux.6089, [_6101, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.6089, [u.6088, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.6087)
// [KnfOpt] let rec add.6102: Int = (x.6103: Int, y.6104: Int) {
// [KnfOpt]   Add(x.6103, y.6104)
// [KnfOpt] }
// [KnfOpt] let _6105: Int = Int(0)
// [KnfOpt] let join fold.6106: Int = (stream.6107: Fun([Unit], Tuple([Int, Int])), f.6108: Fun([Int, Int], Int), acc.6109: Int) {
// [KnfOpt]   let _6110: Unit = Unit
// [KnfOpt]   let _6111: Tuple([Int, Int]) = Apply(stream.6107, [_6110, ])
// [KnfOpt]   let (ok.6112: Var({val: Some(Int)}), val.6113: Var({val: Some(Int)})) = _6111
// [KnfOpt]   let _6114: Int = Int(0)
// [KnfOpt]   if (ok.6112 == _6114) then {
// [KnfOpt]     let sum.104: Int = Var(acc.6109)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _6115: Int = Apply(f.6108, [acc.6109, val.6113, ])
// [KnfOpt]     Jump(fold.6106, [stream.6107, f.6108, _6115, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.6106, [under1200.103, add.6102, _6105, ])
// [KnfOpt] Inline threshold 5
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 0
// [KnfOpt] Inline decision le.83 accepted
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.6131: Int = (x.6132: Int, y.6133: Int) {
// [KnfOpt]   Add(x.6132, y.6133)
// [KnfOpt] }
// [KnfOpt] let _6134: Int = Int(0)
// [KnfOpt] let join fold.6135: Int = (stream.6136: Fun([Unit], Tuple([Int, Int])), f.6137: Fun([Int, Int], Int), acc.6138: Int) {
// [KnfOpt]   let _6139: Unit = Unit
// [KnfOpt]   let _6140: Tuple([Int, Int]) = Apply(stream.6136, [_6139, ])
// [KnfOpt]   let (ok.6141: Var({val: Some(Int)}), val.6142: Var({val: Some(Int)})) = _6140
// [KnfOpt]   let _6143: Int = Int(0)
// [KnfOpt]   if (ok.6141 == _6143) then {
// [KnfOpt]     let sum.104: Int = Var(acc.6138)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _6144: Int = Apply(f.6137, [acc.6138, val.6142, ])
// [KnfOpt]     Jump(fold.6135, [stream.6136, f.6137, _6144, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.6135, [under1200.103, add.6131, _6134, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(le) let _102: Fun([Int], Int) = Unit
// [KnfOpt] let rec aux.6145: Tuple([Int, Int]) = (u.6146: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.6147: Tuple([Int, Int]) = (u.6148: Var({val: Some(Unit)})) {
// [KnfOpt]     let _6149: Unit = Unit
// [KnfOpt]     let _6150: Tuple([Int, Int]) = Apply(over50.100, [_6149, ])
// [KnfOpt]     let (ok.6151: Var({val: Some(Int)}), val.6152: Var({val: Some(Int)})) = _6150
// [KnfOpt]     let _6153: Int = Int(0)
// [KnfOpt]     if (ok.6151 == _6153) then {
// [KnfOpt]       let _6154: Int = Int(0)
// [KnfOpt]       let _6155: Int = Int(0)
// [KnfOpt]       Tuple([_6154, _6155, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.6156: Int = Apply(_102, [val.6152, ])
// [KnfOpt]       let _6157: Int = Int(0)
// [KnfOpt]       if (r.6156 == _6157) then {
// [KnfOpt]         let _6158: Int = Int(1)
// [KnfOpt]         Tuple([_6158, val.6152, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _6159: Unit = Unit
// [KnfOpt]         Jump(aux.6147, [_6159, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.6147, [u.6146, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.6145)
// [KnfOpt] let rec add.6160: Int = (x.6161: Int, y.6162: Int) {
// [KnfOpt]   Add(x.6161, y.6162)
// [KnfOpt] }
// [KnfOpt] let _6163: Int = Int(0)
// [KnfOpt] let join fold.6164: Int = (stream.6165: Fun([Unit], Tuple([Int, Int])), f.6166: Fun([Int, Int], Int), acc.6167: Int) {
// [KnfOpt]   let _6168: Unit = Unit
// [KnfOpt]   let _6169: Tuple([Int, Int]) = Apply(stream.6165, [_6168, ])
// [KnfOpt]   let (ok.6170: Var({val: Some(Int)}), val.6171: Var({val: Some(Int)})) = _6169
// [KnfOpt]   let _6172: Int = Int(0)
// [KnfOpt]   if (ok.6170 == _6172) then {
// [KnfOpt]     let sum.104: Int = Var(acc.6167)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _6173: Int = Apply(f.6166, [acc.6167, val.6171, ])
// [KnfOpt]     Jump(fold.6164, [stream.6165, f.6166, _6173, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.6164, [under1200.103, add.6160, _6163, ])
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.6176: Int = (x.6177: Int, y.6178: Int) {
// [KnfOpt]   Add(x.6177, y.6178)
// [KnfOpt] }
// [KnfOpt] let _6179: Int = Int(0)
// [KnfOpt] let join fold.6180: Int = (stream.6181: Fun([Unit], Tuple([Int, Int])), f.6182: Fun([Int, Int], Int), acc.6183: Int) {
// [KnfOpt]   let _6184: Unit = Unit
// [KnfOpt]   let _6185: Tuple([Int, Int]) = Apply(stream.6181, [_6184, ])
// [KnfOpt]   let (ok.6186: Var({val: Some(Int)}), val.6187: Var({val: Some(Int)})) = _6185
// [KnfOpt]   let _6188: Int = Int(0)
// [KnfOpt]   if (ok.6186 == _6188) then {
// [KnfOpt]     let sum.104: Int = Var(acc.6183)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _6189: Int = Apply(f.6182, [acc.6183, val.6187, ])
// [KnfOpt]     Jump(fold.6180, [stream.6181, f.6182, _6189, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.6180, [under1200.103, add.6176, _6179, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(gt) let _99: Fun([Int], Int) = Unit
// [KnfOpt] let rec aux.6116: Tuple([Int, Int]) = (u.6117: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.6118: Tuple([Int, Int]) = (u.6119: Var({val: Some(Unit)})) {
// [KnfOpt]     let _6120: Unit = Unit
// [KnfOpt]     let _6121: Tuple([Int, Int]) = Apply(addone.97, [_6120, ])
// [KnfOpt]     let (ok.6122: Var({val: Some(Int)}), val.6123: Var({val: Some(Int)})) = _6121
// [KnfOpt]     let _6124: Int = Int(0)
// [KnfOpt]     if (ok.6122 == _6124) then {
// [KnfOpt]       let _6125: Int = Int(0)
// [KnfOpt]       let _6126: Int = Int(0)
// [KnfOpt]       Tuple([_6125, _6126, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.6127: Int = Apply(_99, [val.6123, ])
// [KnfOpt]       let _6128: Int = Int(0)
// [KnfOpt]       if (r.6127 == _6128) then {
// [KnfOpt]         let _6129: Int = Int(1)
// [KnfOpt]         Tuple([_6129, val.6123, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _6130: Unit = Unit
// [KnfOpt]         Jump(aux.6118, [_6130, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.6118, [u.6117, ])
// [KnfOpt] }
// [KnfOpt] let over50.100: Fun([Unit], Tuple([Int, Int])) = Var(aux.6116)
// [KnfOpt] let _101: Int = Int(1200)
// [KnfOpt] let rec aux.6174: Int = (y.6175: Int) {
// [KnfOpt]   if (y.6175 <= _101) then {
// [KnfOpt]     Int(0)
// [KnfOpt]   } else {
// [KnfOpt]     Int(1)
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] let _102: Fun([Int], Int) = Var(aux.6174)
// [KnfOpt] let rec aux.6190: Tuple([Int, Int]) = (u.6191: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.6192: Tuple([Int, Int]) = (u.6193: Var({val: Some(Unit)})) {
// [KnfOpt]     let _6194: Unit = Unit
// [KnfOpt]     let _6195: Tuple([Int, Int]) = Apply(over50.100, [_6194, ])
// [KnfOpt]     let (ok.6196: Var({val: Some(Int)}), val.6197: Var({val: Some(Int)})) = _6195
// [KnfOpt]     let _6198: Int = Int(0)
// [KnfOpt]     if (ok.6196 == _6198) then {
// [KnfOpt]       let _6199: Int = Int(0)
// [KnfOpt]       let _6200: Int = Int(0)
// [KnfOpt]       Tuple([_6199, _6200, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.6201: Int = Apply(_102, [val.6197, ])
// [KnfOpt]       let _6202: Int = Int(0)
// [KnfOpt]       if (r.6201 == _6202) then {
// [KnfOpt]         let _6203: Int = Int(1)
// [KnfOpt]         Tuple([_6203, val.6197, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _6204: Unit = Unit
// [KnfOpt]         Jump(aux.6192, [_6204, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.6192, [u.6191, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.6190)
// [KnfOpt] let rec add.6205: Int = (x.6206: Int, y.6207: Int) {
// [KnfOpt]   Add(x.6206, y.6207)
// [KnfOpt] }
// [KnfOpt] let _6208: Int = Int(0)
// [KnfOpt] let join fold.6209: Int = (stream.6210: Fun([Unit], Tuple([Int, Int])), f.6211: Fun([Int, Int], Int), acc.6212: Int) {
// [KnfOpt]   let _6213: Unit = Unit
// [KnfOpt]   let _6214: Tuple([Int, Int]) = Apply(stream.6210, [_6213, ])
// [KnfOpt]   let (ok.6215: Var({val: Some(Int)}), val.6216: Var({val: Some(Int)})) = _6214
// [KnfOpt]   let _6217: Int = Int(0)
// [KnfOpt]   if (ok.6215 == _6217) then {
// [KnfOpt]     let sum.104: Int = Var(acc.6212)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _6218: Int = Apply(f.6211, [acc.6212, val.6216, ])
// [KnfOpt]     Jump(fold.6209, [stream.6210, f.6211, _6218, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.6209, [under1200.103, add.6205, _6208, ])
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 5
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 0
// [KnfOpt] Inline decision le.83 accepted
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.6221: Int = (x.6222: Int, y.6223: Int) {
// [KnfOpt]   Add(x.6222, y.6223)
// [KnfOpt] }
// [KnfOpt] let _6224: Int = Int(0)
// [KnfOpt] let join fold.6225: Int = (stream.6226: Fun([Unit], Tuple([Int, Int])), f.6227: Fun([Int, Int], Int), acc.6228: Int) {
// [KnfOpt]   let _6229: Unit = Unit
// [KnfOpt]   let _6230: Tuple([Int, Int]) = Apply(stream.6226, [_6229, ])
// [KnfOpt]   let (ok.6231: Var({val: Some(Int)}), val.6232: Var({val: Some(Int)})) = _6230
// [KnfOpt]   let _6233: Int = Int(0)
// [KnfOpt]   if (ok.6231 == _6233) then {
// [KnfOpt]     let sum.104: Int = Var(acc.6228)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _6234: Int = Apply(f.6227, [acc.6228, val.6232, ])
// [KnfOpt]     Jump(fold.6225, [stream.6226, f.6227, _6234, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.6225, [under1200.103, add.6221, _6224, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(le) let _102: Fun([Int], Int) = Unit
// [KnfOpt] let rec aux.6235: Tuple([Int, Int]) = (u.6236: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.6237: Tuple([Int, Int]) = (u.6238: Var({val: Some(Unit)})) {
// [KnfOpt]     let _6239: Unit = Unit
// [KnfOpt]     let _6240: Tuple([Int, Int]) = Apply(over50.100, [_6239, ])
// [KnfOpt]     let (ok.6241: Var({val: Some(Int)}), val.6242: Var({val: Some(Int)})) = _6240
// [KnfOpt]     let _6243: Int = Int(0)
// [KnfOpt]     if (ok.6241 == _6243) then {
// [KnfOpt]       let _6244: Int = Int(0)
// [KnfOpt]       let _6245: Int = Int(0)
// [KnfOpt]       Tuple([_6244, _6245, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.6246: Int = Apply(_102, [val.6242, ])
// [KnfOpt]       let _6247: Int = Int(0)
// [KnfOpt]       if (r.6246 == _6247) then {
// [KnfOpt]         let _6248: Int = Int(1)
// [KnfOpt]         Tuple([_6248, val.6242, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _6249: Unit = Unit
// [KnfOpt]         Jump(aux.6237, [_6249, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.6237, [u.6236, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.6235)
// [KnfOpt] let rec add.6250: Int = (x.6251: Int, y.6252: Int) {
// [KnfOpt]   Add(x.6251, y.6252)
// [KnfOpt] }
// [KnfOpt] let _6253: Int = Int(0)
// [KnfOpt] let join fold.6254: Int = (stream.6255: Fun([Unit], Tuple([Int, Int])), f.6256: Fun([Int, Int], Int), acc.6257: Int) {
// [KnfOpt]   let _6258: Unit = Unit
// [KnfOpt]   let _6259: Tuple([Int, Int]) = Apply(stream.6255, [_6258, ])
// [KnfOpt]   let (ok.6260: Var({val: Some(Int)}), val.6261: Var({val: Some(Int)})) = _6259
// [KnfOpt]   let _6262: Int = Int(0)
// [KnfOpt]   if (ok.6260 == _6262) then {
// [KnfOpt]     let sum.104: Int = Var(acc.6257)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _6263: Int = Apply(f.6256, [acc.6257, val.6261, ])
// [KnfOpt]     Jump(fold.6254, [stream.6255, f.6256, _6263, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.6254, [under1200.103, add.6250, _6253, ])
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.6266: Int = (x.6267: Int, y.6268: Int) {
// [KnfOpt]   Add(x.6267, y.6268)
// [KnfOpt] }
// [KnfOpt] let _6269: Int = Int(0)
// [KnfOpt] let join fold.6270: Int = (stream.6271: Fun([Unit], Tuple([Int, Int])), f.6272: Fun([Int, Int], Int), acc.6273: Int) {
// [KnfOpt]   let _6274: Unit = Unit
// [KnfOpt]   let _6275: Tuple([Int, Int]) = Apply(stream.6271, [_6274, ])
// [KnfOpt]   let (ok.6276: Var({val: Some(Int)}), val.6277: Var({val: Some(Int)})) = _6275
// [KnfOpt]   let _6278: Int = Int(0)
// [KnfOpt]   if (ok.6276 == _6278) then {
// [KnfOpt]     let sum.104: Int = Var(acc.6273)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _6279: Int = Apply(f.6272, [acc.6273, val.6277, ])
// [KnfOpt]     Jump(fold.6270, [stream.6271, f.6272, _6279, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.6270, [under1200.103, add.6266, _6269, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let over50.100: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let _101: Int = Int(1200)
// [KnfOpt] let rec aux.6264: Int = (y.6265: Int) {
// [KnfOpt]   if (y.6265 <= _101) then {
// [KnfOpt]     Int(0)
// [KnfOpt]   } else {
// [KnfOpt]     Int(1)
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] let _102: Fun([Int], Int) = Var(aux.6264)
// [KnfOpt] let rec aux.6280: Tuple([Int, Int]) = (u.6281: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.6282: Tuple([Int, Int]) = (u.6283: Var({val: Some(Unit)})) {
// [KnfOpt]     let _6284: Unit = Unit
// [KnfOpt]     let _6285: Tuple([Int, Int]) = Apply(over50.100, [_6284, ])
// [KnfOpt]     let (ok.6286: Var({val: Some(Int)}), val.6287: Var({val: Some(Int)})) = _6285
// [KnfOpt]     let _6288: Int = Int(0)
// [KnfOpt]     if (ok.6286 == _6288) then {
// [KnfOpt]       let _6289: Int = Int(0)
// [KnfOpt]       let _6290: Int = Int(0)
// [KnfOpt]       Tuple([_6289, _6290, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.6291: Int = Apply(_102, [val.6287, ])
// [KnfOpt]       let _6292: Int = Int(0)
// [KnfOpt]       if (r.6291 == _6292) then {
// [KnfOpt]         let _6293: Int = Int(1)
// [KnfOpt]         Tuple([_6293, val.6287, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _6294: Unit = Unit
// [KnfOpt]         Jump(aux.6282, [_6294, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.6282, [u.6281, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.6280)
// [KnfOpt] let rec add.6295: Int = (x.6296: Int, y.6297: Int) {
// [KnfOpt]   Add(x.6296, y.6297)
// [KnfOpt] }
// [KnfOpt] let _6298: Int = Int(0)
// [KnfOpt] let join fold.6299: Int = (stream.6300: Fun([Unit], Tuple([Int, Int])), f.6301: Fun([Int, Int], Int), acc.6302: Int) {
// [KnfOpt]   let _6303: Unit = Unit
// [KnfOpt]   let _6304: Tuple([Int, Int]) = Apply(stream.6300, [_6303, ])
// [KnfOpt]   let (ok.6305: Var({val: Some(Int)}), val.6306: Var({val: Some(Int)})) = _6304
// [KnfOpt]   let _6307: Int = Int(0)
// [KnfOpt]   if (ok.6305 == _6307) then {
// [KnfOpt]     let sum.104: Int = Var(acc.6302)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _6308: Int = Apply(f.6301, [acc.6302, val.6306, ])
// [KnfOpt]     Jump(fold.6299, [stream.6300, f.6301, _6308, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.6299, [under1200.103, add.6295, _6298, ])
// [KnfOpt] Inline threshold 5
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 0
// [KnfOpt] Inline decision le.83 accepted
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.6324: Int = (x.6325: Int, y.6326: Int) {
// [KnfOpt]   Add(x.6325, y.6326)
// [KnfOpt] }
// [KnfOpt] let _6327: Int = Int(0)
// [KnfOpt] let join fold.6328: Int = (stream.6329: Fun([Unit], Tuple([Int, Int])), f.6330: Fun([Int, Int], Int), acc.6331: Int) {
// [KnfOpt]   let _6332: Unit = Unit
// [KnfOpt]   let _6333: Tuple([Int, Int]) = Apply(stream.6329, [_6332, ])
// [KnfOpt]   let (ok.6334: Var({val: Some(Int)}), val.6335: Var({val: Some(Int)})) = _6333
// [KnfOpt]   let _6336: Int = Int(0)
// [KnfOpt]   if (ok.6334 == _6336) then {
// [KnfOpt]     let sum.104: Int = Var(acc.6331)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _6337: Int = Apply(f.6330, [acc.6331, val.6335, ])
// [KnfOpt]     Jump(fold.6328, [stream.6329, f.6330, _6337, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.6328, [under1200.103, add.6324, _6327, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(le) let _102: Fun([Int], Int) = Unit
// [KnfOpt] let rec aux.6338: Tuple([Int, Int]) = (u.6339: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.6340: Tuple([Int, Int]) = (u.6341: Var({val: Some(Unit)})) {
// [KnfOpt]     let _6342: Unit = Unit
// [KnfOpt]     let _6343: Tuple([Int, Int]) = Apply(over50.100, [_6342, ])
// [KnfOpt]     let (ok.6344: Var({val: Some(Int)}), val.6345: Var({val: Some(Int)})) = _6343
// [KnfOpt]     let _6346: Int = Int(0)
// [KnfOpt]     if (ok.6344 == _6346) then {
// [KnfOpt]       let _6347: Int = Int(0)
// [KnfOpt]       let _6348: Int = Int(0)
// [KnfOpt]       Tuple([_6347, _6348, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.6349: Int = Apply(_102, [val.6345, ])
// [KnfOpt]       let _6350: Int = Int(0)
// [KnfOpt]       if (r.6349 == _6350) then {
// [KnfOpt]         let _6351: Int = Int(1)
// [KnfOpt]         Tuple([_6351, val.6345, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _6352: Unit = Unit
// [KnfOpt]         Jump(aux.6340, [_6352, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.6340, [u.6339, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.6338)
// [KnfOpt] let rec add.6353: Int = (x.6354: Int, y.6355: Int) {
// [KnfOpt]   Add(x.6354, y.6355)
// [KnfOpt] }
// [KnfOpt] let _6356: Int = Int(0)
// [KnfOpt] let join fold.6357: Int = (stream.6358: Fun([Unit], Tuple([Int, Int])), f.6359: Fun([Int, Int], Int), acc.6360: Int) {
// [KnfOpt]   let _6361: Unit = Unit
// [KnfOpt]   let _6362: Tuple([Int, Int]) = Apply(stream.6358, [_6361, ])
// [KnfOpt]   let (ok.6363: Var({val: Some(Int)}), val.6364: Var({val: Some(Int)})) = _6362
// [KnfOpt]   let _6365: Int = Int(0)
// [KnfOpt]   if (ok.6363 == _6365) then {
// [KnfOpt]     let sum.104: Int = Var(acc.6360)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _6366: Int = Apply(f.6359, [acc.6360, val.6364, ])
// [KnfOpt]     Jump(fold.6357, [stream.6358, f.6359, _6366, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.6357, [under1200.103, add.6353, _6356, ])
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.6369: Int = (x.6370: Int, y.6371: Int) {
// [KnfOpt]   Add(x.6370, y.6371)
// [KnfOpt] }
// [KnfOpt] let _6372: Int = Int(0)
// [KnfOpt] let join fold.6373: Int = (stream.6374: Fun([Unit], Tuple([Int, Int])), f.6375: Fun([Int, Int], Int), acc.6376: Int) {
// [KnfOpt]   let _6377: Unit = Unit
// [KnfOpt]   let _6378: Tuple([Int, Int]) = Apply(stream.6374, [_6377, ])
// [KnfOpt]   let (ok.6379: Var({val: Some(Int)}), val.6380: Var({val: Some(Int)})) = _6378
// [KnfOpt]   let _6381: Int = Int(0)
// [KnfOpt]   if (ok.6379 == _6381) then {
// [KnfOpt]     let sum.104: Int = Var(acc.6376)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _6382: Int = Apply(f.6375, [acc.6376, val.6380, ])
// [KnfOpt]     Jump(fold.6373, [stream.6374, f.6375, _6382, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.6373, [under1200.103, add.6369, _6372, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(range) let range100.90: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let _91: Int = Int(0)
// [KnfOpt] let _92: Int = Int(1000)
// [KnfOpt] let _3270: Int = Int(1)
// [KnfOpt] let state.3271: Array(Int) = ExtApply(minimbt_create_array, [_3270, _91, ])
// [KnfOpt] let rec aux.3272: Tuple([Int, Int]) = (u.3273: Var({val: Some(Unit)})) {
// [KnfOpt]   let _3274: Int = Int(0)
// [KnfOpt]   let val.3275: Int = Get state.3271[_3274]
// [KnfOpt]   if (val.3275 == _92) then {
// [KnfOpt]     let _3276: Int = Int(0)
// [KnfOpt]     let _3277: Int = Int(0)
// [KnfOpt]     Tuple([_3276, _3277, ])
// [KnfOpt]   } else {
// [KnfOpt]     let _3278: Int = Int(0)
// [KnfOpt]     let _3279: Int = Int(1)
// [KnfOpt]     let _3280: Int = Add(val.3275, _3279)
// [KnfOpt]     let _3281: Unit = Put state.3271[_3278] = _3280
// [KnfOpt]     let _3282: Int = Int(1)
// [KnfOpt]     Tuple([_3282, val.3275, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] let range1000.93: Fun([Unit], Tuple([Int, Int])) = Var(aux.3272)
// [KnfOpt] let rec aux.4843: Tuple([Int, Int]) = (u.4844: Var({val: Some(Unit)})) {
// [KnfOpt]   let _4845: Unit = Unit
// [KnfOpt]   let _4846: Tuple([Int, Int]) = Apply(range100.90, [_4845, ])
// [KnfOpt]   let (ok.4847: Var({val: Some(Int)}), val.4848: Var({val: Some(Int)})) = _4846
// [KnfOpt]   let _4849: Int = Int(0)
// [KnfOpt]   if (ok.4847 == _4849) then {
// [KnfOpt]     let _4850: Unit = Unit
// [KnfOpt]     Apply(range1000.93, [_4850, ])
// [KnfOpt]   } else {
// [KnfOpt]     let _4851: Int = Int(1)
// [KnfOpt]     Tuple([_4851, val.4848, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] let catt.94: Fun([Unit], Tuple([Int, Int])) = Var(aux.4843)
// [KnfOpt] let _95: Int = Int(1)
// [KnfOpt] let rec aux.5631: Int = (y.5632: Int) {
// [KnfOpt]   Add(_95, y.5632)
// [KnfOpt] }
// [KnfOpt] let _96: Fun([Int], Int) = Var(aux.5631)
// [KnfOpt] let rec aux.6017: Tuple([Int, Int]) = (u.6018: Var({val: Some(Unit)})) {
// [KnfOpt]   let _6019: Unit = Unit
// [KnfOpt]   let _6020: Tuple([Int, Int]) = Apply(catt.94, [_6019, ])
// [KnfOpt]   let (ok.6021: Var({val: Some(Int)}), val.6022: Var({val: Some(Int)})) = _6020
// [KnfOpt]   let _6023: Int = Int(0)
// [KnfOpt]   if (ok.6021 == _6023) then {
// [KnfOpt]     let _6024: Int = Int(0)
// [KnfOpt]     let _6025: Int = Int(0)
// [KnfOpt]     Tuple([_6024, _6025, ])
// [KnfOpt]   } else {
// [KnfOpt]     let _6026: Int = Int(1)
// [KnfOpt]     let _6027: Int = Apply(_96, [val.6022, ])
// [KnfOpt]     Tuple([_6026, _6027, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] let addone.97: Fun([Unit], Tuple([Int, Int])) = Var(aux.6017)
// [KnfOpt] let _98: Int = Int(50)
// [KnfOpt] let rec aux.6219: Int = (y.6220: Int) {
// [KnfOpt]   if (_98 <= y.6220) then {
// [KnfOpt]     Int(0)
// [KnfOpt]   } else {
// [KnfOpt]     Int(1)
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] let _99: Fun([Int], Int) = Var(aux.6219)
// [KnfOpt] let rec aux.6309: Tuple([Int, Int]) = (u.6310: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.6311: Tuple([Int, Int]) = (u.6312: Var({val: Some(Unit)})) {
// [KnfOpt]     let _6313: Unit = Unit
// [KnfOpt]     let _6314: Tuple([Int, Int]) = Apply(addone.97, [_6313, ])
// [KnfOpt]     let (ok.6315: Var({val: Some(Int)}), val.6316: Var({val: Some(Int)})) = _6314
// [KnfOpt]     let _6317: Int = Int(0)
// [KnfOpt]     if (ok.6315 == _6317) then {
// [KnfOpt]       let _6318: Int = Int(0)
// [KnfOpt]       let _6319: Int = Int(0)
// [KnfOpt]       Tuple([_6318, _6319, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.6320: Int = Apply(_99, [val.6316, ])
// [KnfOpt]       let _6321: Int = Int(0)
// [KnfOpt]       if (r.6320 == _6321) then {
// [KnfOpt]         let _6322: Int = Int(1)
// [KnfOpt]         Tuple([_6322, val.6316, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _6323: Unit = Unit
// [KnfOpt]         Jump(aux.6311, [_6323, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.6311, [u.6310, ])
// [KnfOpt] }
// [KnfOpt] let over50.100: Fun([Unit], Tuple([Int, Int])) = Var(aux.6309)
// [KnfOpt] let _101: Int = Int(1200)
// [KnfOpt] let rec aux.6367: Int = (y.6368: Int) {
// [KnfOpt]   if (y.6368 <= _101) then {
// [KnfOpt]     Int(0)
// [KnfOpt]   } else {
// [KnfOpt]     Int(1)
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] let _102: Fun([Int], Int) = Var(aux.6367)
// [KnfOpt] let rec aux.6383: Tuple([Int, Int]) = (u.6384: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.6385: Tuple([Int, Int]) = (u.6386: Var({val: Some(Unit)})) {
// [KnfOpt]     let _6387: Unit = Unit
// [KnfOpt]     let _6388: Tuple([Int, Int]) = Apply(over50.100, [_6387, ])
// [KnfOpt]     let (ok.6389: Var({val: Some(Int)}), val.6390: Var({val: Some(Int)})) = _6388
// [KnfOpt]     let _6391: Int = Int(0)
// [KnfOpt]     if (ok.6389 == _6391) then {
// [KnfOpt]       let _6392: Int = Int(0)
// [KnfOpt]       let _6393: Int = Int(0)
// [KnfOpt]       Tuple([_6392, _6393, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.6394: Int = Apply(_102, [val.6390, ])
// [KnfOpt]       let _6395: Int = Int(0)
// [KnfOpt]       if (r.6394 == _6395) then {
// [KnfOpt]         let _6396: Int = Int(1)
// [KnfOpt]         Tuple([_6396, val.6390, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _6397: Unit = Unit
// [KnfOpt]         Jump(aux.6385, [_6397, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.6385, [u.6384, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.6383)
// [KnfOpt] let rec add.6398: Int = (x.6399: Int, y.6400: Int) {
// [KnfOpt]   Add(x.6399, y.6400)
// [KnfOpt] }
// [KnfOpt] let _6401: Int = Int(0)
// [KnfOpt] let join fold.6402: Int = (stream.6403: Fun([Unit], Tuple([Int, Int])), f.6404: Fun([Int, Int], Int), acc.6405: Int) {
// [KnfOpt]   let _6406: Unit = Unit
// [KnfOpt]   let _6407: Tuple([Int, Int]) = Apply(stream.6403, [_6406, ])
// [KnfOpt]   let (ok.6408: Var({val: Some(Int)}), val.6409: Var({val: Some(Int)})) = _6407
// [KnfOpt]   let _6410: Int = Int(0)
// [KnfOpt]   if (ok.6408 == _6410) then {
// [KnfOpt]     let sum.104: Int = Var(acc.6405)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _6411: Int = Apply(f.6404, [acc.6405, val.6409, ])
// [KnfOpt]     Jump(fold.6402, [stream.6403, f.6404, _6411, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.6402, [under1200.103, add.6398, _6401, ])
// [KnfOpt] Inline threshold 27
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 0
// [KnfOpt] Inline decision range.43 accepted
// [KnfOpt] Inline threshold 16
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 0
// [KnfOpt] Inline decision concat.31 accepted
// [KnfOpt] Inline threshold 3
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 0
// [KnfOpt] Inline decision addx.59 accepted
// [KnfOpt] Inline threshold 20
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 0
// [KnfOpt] Inline decision map.1 accepted
// [KnfOpt] Inline threshold 5
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 0
// [KnfOpt] Inline decision gt.79 accepted
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 5
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 0
// [KnfOpt] Inline decision le.83 accepted
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.6425: Int = (x.6426: Int, y.6427: Int) {
// [KnfOpt]   Add(x.6426, y.6427)
// [KnfOpt] }
// [KnfOpt] let _6428: Int = Int(0)
// [KnfOpt] let join fold.6429: Int = (stream.6430: Fun([Unit], Tuple([Int, Int])), f.6431: Fun([Int, Int], Int), acc.6432: Int) {
// [KnfOpt]   let _6433: Unit = Unit
// [KnfOpt]   let _6434: Tuple([Int, Int]) = Apply(stream.6430, [_6433, ])
// [KnfOpt]   let (ok.6435: Var({val: Some(Int)}), val.6436: Var({val: Some(Int)})) = _6434
// [KnfOpt]   let _6437: Int = Int(0)
// [KnfOpt]   if (ok.6435 == _6437) then {
// [KnfOpt]     let sum.104: Int = Var(acc.6432)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _6438: Int = Apply(f.6431, [acc.6432, val.6436, ])
// [KnfOpt]     Jump(fold.6429, [stream.6430, f.6431, _6438, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.6429, [under1200.103, add.6425, _6428, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(le) let _102: Fun([Int], Int) = Unit
// [KnfOpt] let rec aux.6439: Tuple([Int, Int]) = (u.6440: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.6441: Tuple([Int, Int]) = (u.6442: Var({val: Some(Unit)})) {
// [KnfOpt]     let _6443: Unit = Unit
// [KnfOpt]     let _6444: Tuple([Int, Int]) = Apply(over50.100, [_6443, ])
// [KnfOpt]     let (ok.6445: Var({val: Some(Int)}), val.6446: Var({val: Some(Int)})) = _6444
// [KnfOpt]     let _6447: Int = Int(0)
// [KnfOpt]     if (ok.6445 == _6447) then {
// [KnfOpt]       let _6448: Int = Int(0)
// [KnfOpt]       let _6449: Int = Int(0)
// [KnfOpt]       Tuple([_6448, _6449, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.6450: Int = Apply(_102, [val.6446, ])
// [KnfOpt]       let _6451: Int = Int(0)
// [KnfOpt]       if (r.6450 == _6451) then {
// [KnfOpt]         let _6452: Int = Int(1)
// [KnfOpt]         Tuple([_6452, val.6446, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _6453: Unit = Unit
// [KnfOpt]         Jump(aux.6441, [_6453, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.6441, [u.6440, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.6439)
// [KnfOpt] let rec add.6454: Int = (x.6455: Int, y.6456: Int) {
// [KnfOpt]   Add(x.6455, y.6456)
// [KnfOpt] }
// [KnfOpt] let _6457: Int = Int(0)
// [KnfOpt] let join fold.6458: Int = (stream.6459: Fun([Unit], Tuple([Int, Int])), f.6460: Fun([Int, Int], Int), acc.6461: Int) {
// [KnfOpt]   let _6462: Unit = Unit
// [KnfOpt]   let _6463: Tuple([Int, Int]) = Apply(stream.6459, [_6462, ])
// [KnfOpt]   let (ok.6464: Var({val: Some(Int)}), val.6465: Var({val: Some(Int)})) = _6463
// [KnfOpt]   let _6466: Int = Int(0)
// [KnfOpt]   if (ok.6464 == _6466) then {
// [KnfOpt]     let sum.104: Int = Var(acc.6461)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _6467: Int = Apply(f.6460, [acc.6461, val.6465, ])
// [KnfOpt]     Jump(fold.6458, [stream.6459, f.6460, _6467, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.6458, [under1200.103, add.6454, _6457, ])
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.6470: Int = (x.6471: Int, y.6472: Int) {
// [KnfOpt]   Add(x.6471, y.6472)
// [KnfOpt] }
// [KnfOpt] let _6473: Int = Int(0)
// [KnfOpt] let join fold.6474: Int = (stream.6475: Fun([Unit], Tuple([Int, Int])), f.6476: Fun([Int, Int], Int), acc.6477: Int) {
// [KnfOpt]   let _6478: Unit = Unit
// [KnfOpt]   let _6479: Tuple([Int, Int]) = Apply(stream.6475, [_6478, ])
// [KnfOpt]   let (ok.6480: Var({val: Some(Int)}), val.6481: Var({val: Some(Int)})) = _6479
// [KnfOpt]   let _6482: Int = Int(0)
// [KnfOpt]   if (ok.6480 == _6482) then {
// [KnfOpt]     let sum.104: Int = Var(acc.6477)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _6483: Int = Apply(f.6476, [acc.6477, val.6481, ])
// [KnfOpt]     Jump(fold.6474, [stream.6475, f.6476, _6483, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.6474, [under1200.103, add.6470, _6473, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let over50.100: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let _101: Int = Int(1200)
// [KnfOpt] let rec aux.6468: Int = (y.6469: Int) {
// [KnfOpt]   if (y.6469 <= _101) then {
// [KnfOpt]     Int(0)
// [KnfOpt]   } else {
// [KnfOpt]     Int(1)
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] let _102: Fun([Int], Int) = Var(aux.6468)
// [KnfOpt] let rec aux.6484: Tuple([Int, Int]) = (u.6485: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.6486: Tuple([Int, Int]) = (u.6487: Var({val: Some(Unit)})) {
// [KnfOpt]     let _6488: Unit = Unit
// [KnfOpt]     let _6489: Tuple([Int, Int]) = Apply(over50.100, [_6488, ])
// [KnfOpt]     let (ok.6490: Var({val: Some(Int)}), val.6491: Var({val: Some(Int)})) = _6489
// [KnfOpt]     let _6492: Int = Int(0)
// [KnfOpt]     if (ok.6490 == _6492) then {
// [KnfOpt]       let _6493: Int = Int(0)
// [KnfOpt]       let _6494: Int = Int(0)
// [KnfOpt]       Tuple([_6493, _6494, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.6495: Int = Apply(_102, [val.6491, ])
// [KnfOpt]       let _6496: Int = Int(0)
// [KnfOpt]       if (r.6495 == _6496) then {
// [KnfOpt]         let _6497: Int = Int(1)
// [KnfOpt]         Tuple([_6497, val.6491, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _6498: Unit = Unit
// [KnfOpt]         Jump(aux.6486, [_6498, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.6486, [u.6485, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.6484)
// [KnfOpt] let rec add.6499: Int = (x.6500: Int, y.6501: Int) {
// [KnfOpt]   Add(x.6500, y.6501)
// [KnfOpt] }
// [KnfOpt] let _6502: Int = Int(0)
// [KnfOpt] let join fold.6503: Int = (stream.6504: Fun([Unit], Tuple([Int, Int])), f.6505: Fun([Int, Int], Int), acc.6506: Int) {
// [KnfOpt]   let _6507: Unit = Unit
// [KnfOpt]   let _6508: Tuple([Int, Int]) = Apply(stream.6504, [_6507, ])
// [KnfOpt]   let (ok.6509: Var({val: Some(Int)}), val.6510: Var({val: Some(Int)})) = _6508
// [KnfOpt]   let _6511: Int = Int(0)
// [KnfOpt]   if (ok.6509 == _6511) then {
// [KnfOpt]     let sum.104: Int = Var(acc.6506)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _6512: Int = Apply(f.6505, [acc.6506, val.6510, ])
// [KnfOpt]     Jump(fold.6503, [stream.6504, f.6505, _6512, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.6503, [under1200.103, add.6499, _6502, ])
// [KnfOpt] Inline threshold 5
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 0
// [KnfOpt] Inline decision le.83 accepted
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.6528: Int = (x.6529: Int, y.6530: Int) {
// [KnfOpt]   Add(x.6529, y.6530)
// [KnfOpt] }
// [KnfOpt] let _6531: Int = Int(0)
// [KnfOpt] let join fold.6532: Int = (stream.6533: Fun([Unit], Tuple([Int, Int])), f.6534: Fun([Int, Int], Int), acc.6535: Int) {
// [KnfOpt]   let _6536: Unit = Unit
// [KnfOpt]   let _6537: Tuple([Int, Int]) = Apply(stream.6533, [_6536, ])
// [KnfOpt]   let (ok.6538: Var({val: Some(Int)}), val.6539: Var({val: Some(Int)})) = _6537
// [KnfOpt]   let _6540: Int = Int(0)
// [KnfOpt]   if (ok.6538 == _6540) then {
// [KnfOpt]     let sum.104: Int = Var(acc.6535)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _6541: Int = Apply(f.6534, [acc.6535, val.6539, ])
// [KnfOpt]     Jump(fold.6532, [stream.6533, f.6534, _6541, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.6532, [under1200.103, add.6528, _6531, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(le) let _102: Fun([Int], Int) = Unit
// [KnfOpt] let rec aux.6542: Tuple([Int, Int]) = (u.6543: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.6544: Tuple([Int, Int]) = (u.6545: Var({val: Some(Unit)})) {
// [KnfOpt]     let _6546: Unit = Unit
// [KnfOpt]     let _6547: Tuple([Int, Int]) = Apply(over50.100, [_6546, ])
// [KnfOpt]     let (ok.6548: Var({val: Some(Int)}), val.6549: Var({val: Some(Int)})) = _6547
// [KnfOpt]     let _6550: Int = Int(0)
// [KnfOpt]     if (ok.6548 == _6550) then {
// [KnfOpt]       let _6551: Int = Int(0)
// [KnfOpt]       let _6552: Int = Int(0)
// [KnfOpt]       Tuple([_6551, _6552, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.6553: Int = Apply(_102, [val.6549, ])
// [KnfOpt]       let _6554: Int = Int(0)
// [KnfOpt]       if (r.6553 == _6554) then {
// [KnfOpt]         let _6555: Int = Int(1)
// [KnfOpt]         Tuple([_6555, val.6549, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _6556: Unit = Unit
// [KnfOpt]         Jump(aux.6544, [_6556, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.6544, [u.6543, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.6542)
// [KnfOpt] let rec add.6557: Int = (x.6558: Int, y.6559: Int) {
// [KnfOpt]   Add(x.6558, y.6559)
// [KnfOpt] }
// [KnfOpt] let _6560: Int = Int(0)
// [KnfOpt] let join fold.6561: Int = (stream.6562: Fun([Unit], Tuple([Int, Int])), f.6563: Fun([Int, Int], Int), acc.6564: Int) {
// [KnfOpt]   let _6565: Unit = Unit
// [KnfOpt]   let _6566: Tuple([Int, Int]) = Apply(stream.6562, [_6565, ])
// [KnfOpt]   let (ok.6567: Var({val: Some(Int)}), val.6568: Var({val: Some(Int)})) = _6566
// [KnfOpt]   let _6569: Int = Int(0)
// [KnfOpt]   if (ok.6567 == _6569) then {
// [KnfOpt]     let sum.104: Int = Var(acc.6564)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _6570: Int = Apply(f.6563, [acc.6564, val.6568, ])
// [KnfOpt]     Jump(fold.6561, [stream.6562, f.6563, _6570, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.6561, [under1200.103, add.6557, _6560, ])
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.6573: Int = (x.6574: Int, y.6575: Int) {
// [KnfOpt]   Add(x.6574, y.6575)
// [KnfOpt] }
// [KnfOpt] let _6576: Int = Int(0)
// [KnfOpt] let join fold.6577: Int = (stream.6578: Fun([Unit], Tuple([Int, Int])), f.6579: Fun([Int, Int], Int), acc.6580: Int) {
// [KnfOpt]   let _6581: Unit = Unit
// [KnfOpt]   let _6582: Tuple([Int, Int]) = Apply(stream.6578, [_6581, ])
// [KnfOpt]   let (ok.6583: Var({val: Some(Int)}), val.6584: Var({val: Some(Int)})) = _6582
// [KnfOpt]   let _6585: Int = Int(0)
// [KnfOpt]   if (ok.6583 == _6585) then {
// [KnfOpt]     let sum.104: Int = Var(acc.6580)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _6586: Int = Apply(f.6579, [acc.6580, val.6584, ])
// [KnfOpt]     Jump(fold.6577, [stream.6578, f.6579, _6586, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.6577, [under1200.103, add.6573, _6576, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(gt) let _99: Fun([Int], Int) = Unit
// [KnfOpt] let rec aux.6513: Tuple([Int, Int]) = (u.6514: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.6515: Tuple([Int, Int]) = (u.6516: Var({val: Some(Unit)})) {
// [KnfOpt]     let _6517: Unit = Unit
// [KnfOpt]     let _6518: Tuple([Int, Int]) = Apply(addone.97, [_6517, ])
// [KnfOpt]     let (ok.6519: Var({val: Some(Int)}), val.6520: Var({val: Some(Int)})) = _6518
// [KnfOpt]     let _6521: Int = Int(0)
// [KnfOpt]     if (ok.6519 == _6521) then {
// [KnfOpt]       let _6522: Int = Int(0)
// [KnfOpt]       let _6523: Int = Int(0)
// [KnfOpt]       Tuple([_6522, _6523, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.6524: Int = Apply(_99, [val.6520, ])
// [KnfOpt]       let _6525: Int = Int(0)
// [KnfOpt]       if (r.6524 == _6525) then {
// [KnfOpt]         let _6526: Int = Int(1)
// [KnfOpt]         Tuple([_6526, val.6520, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _6527: Unit = Unit
// [KnfOpt]         Jump(aux.6515, [_6527, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.6515, [u.6514, ])
// [KnfOpt] }
// [KnfOpt] let over50.100: Fun([Unit], Tuple([Int, Int])) = Var(aux.6513)
// [KnfOpt] let _101: Int = Int(1200)
// [KnfOpt] let rec aux.6571: Int = (y.6572: Int) {
// [KnfOpt]   if (y.6572 <= _101) then {
// [KnfOpt]     Int(0)
// [KnfOpt]   } else {
// [KnfOpt]     Int(1)
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] let _102: Fun([Int], Int) = Var(aux.6571)
// [KnfOpt] let rec aux.6587: Tuple([Int, Int]) = (u.6588: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.6589: Tuple([Int, Int]) = (u.6590: Var({val: Some(Unit)})) {
// [KnfOpt]     let _6591: Unit = Unit
// [KnfOpt]     let _6592: Tuple([Int, Int]) = Apply(over50.100, [_6591, ])
// [KnfOpt]     let (ok.6593: Var({val: Some(Int)}), val.6594: Var({val: Some(Int)})) = _6592
// [KnfOpt]     let _6595: Int = Int(0)
// [KnfOpt]     if (ok.6593 == _6595) then {
// [KnfOpt]       let _6596: Int = Int(0)
// [KnfOpt]       let _6597: Int = Int(0)
// [KnfOpt]       Tuple([_6596, _6597, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.6598: Int = Apply(_102, [val.6594, ])
// [KnfOpt]       let _6599: Int = Int(0)
// [KnfOpt]       if (r.6598 == _6599) then {
// [KnfOpt]         let _6600: Int = Int(1)
// [KnfOpt]         Tuple([_6600, val.6594, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _6601: Unit = Unit
// [KnfOpt]         Jump(aux.6589, [_6601, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.6589, [u.6588, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.6587)
// [KnfOpt] let rec add.6602: Int = (x.6603: Int, y.6604: Int) {
// [KnfOpt]   Add(x.6603, y.6604)
// [KnfOpt] }
// [KnfOpt] let _6605: Int = Int(0)
// [KnfOpt] let join fold.6606: Int = (stream.6607: Fun([Unit], Tuple([Int, Int])), f.6608: Fun([Int, Int], Int), acc.6609: Int) {
// [KnfOpt]   let _6610: Unit = Unit
// [KnfOpt]   let _6611: Tuple([Int, Int]) = Apply(stream.6607, [_6610, ])
// [KnfOpt]   let (ok.6612: Var({val: Some(Int)}), val.6613: Var({val: Some(Int)})) = _6611
// [KnfOpt]   let _6614: Int = Int(0)
// [KnfOpt]   if (ok.6612 == _6614) then {
// [KnfOpt]     let sum.104: Int = Var(acc.6609)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _6615: Int = Apply(f.6608, [acc.6609, val.6613, ])
// [KnfOpt]     Jump(fold.6606, [stream.6607, f.6608, _6615, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.6606, [under1200.103, add.6602, _6605, ])
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 5
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 0
// [KnfOpt] Inline decision le.83 accepted
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.6618: Int = (x.6619: Int, y.6620: Int) {
// [KnfOpt]   Add(x.6619, y.6620)
// [KnfOpt] }
// [KnfOpt] let _6621: Int = Int(0)
// [KnfOpt] let join fold.6622: Int = (stream.6623: Fun([Unit], Tuple([Int, Int])), f.6624: Fun([Int, Int], Int), acc.6625: Int) {
// [KnfOpt]   let _6626: Unit = Unit
// [KnfOpt]   let _6627: Tuple([Int, Int]) = Apply(stream.6623, [_6626, ])
// [KnfOpt]   let (ok.6628: Var({val: Some(Int)}), val.6629: Var({val: Some(Int)})) = _6627
// [KnfOpt]   let _6630: Int = Int(0)
// [KnfOpt]   if (ok.6628 == _6630) then {
// [KnfOpt]     let sum.104: Int = Var(acc.6625)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _6631: Int = Apply(f.6624, [acc.6625, val.6629, ])
// [KnfOpt]     Jump(fold.6622, [stream.6623, f.6624, _6631, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.6622, [under1200.103, add.6618, _6621, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(le) let _102: Fun([Int], Int) = Unit
// [KnfOpt] let rec aux.6632: Tuple([Int, Int]) = (u.6633: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.6634: Tuple([Int, Int]) = (u.6635: Var({val: Some(Unit)})) {
// [KnfOpt]     let _6636: Unit = Unit
// [KnfOpt]     let _6637: Tuple([Int, Int]) = Apply(over50.100, [_6636, ])
// [KnfOpt]     let (ok.6638: Var({val: Some(Int)}), val.6639: Var({val: Some(Int)})) = _6637
// [KnfOpt]     let _6640: Int = Int(0)
// [KnfOpt]     if (ok.6638 == _6640) then {
// [KnfOpt]       let _6641: Int = Int(0)
// [KnfOpt]       let _6642: Int = Int(0)
// [KnfOpt]       Tuple([_6641, _6642, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.6643: Int = Apply(_102, [val.6639, ])
// [KnfOpt]       let _6644: Int = Int(0)
// [KnfOpt]       if (r.6643 == _6644) then {
// [KnfOpt]         let _6645: Int = Int(1)
// [KnfOpt]         Tuple([_6645, val.6639, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _6646: Unit = Unit
// [KnfOpt]         Jump(aux.6634, [_6646, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.6634, [u.6633, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.6632)
// [KnfOpt] let rec add.6647: Int = (x.6648: Int, y.6649: Int) {
// [KnfOpt]   Add(x.6648, y.6649)
// [KnfOpt] }
// [KnfOpt] let _6650: Int = Int(0)
// [KnfOpt] let join fold.6651: Int = (stream.6652: Fun([Unit], Tuple([Int, Int])), f.6653: Fun([Int, Int], Int), acc.6654: Int) {
// [KnfOpt]   let _6655: Unit = Unit
// [KnfOpt]   let _6656: Tuple([Int, Int]) = Apply(stream.6652, [_6655, ])
// [KnfOpt]   let (ok.6657: Var({val: Some(Int)}), val.6658: Var({val: Some(Int)})) = _6656
// [KnfOpt]   let _6659: Int = Int(0)
// [KnfOpt]   if (ok.6657 == _6659) then {
// [KnfOpt]     let sum.104: Int = Var(acc.6654)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _6660: Int = Apply(f.6653, [acc.6654, val.6658, ])
// [KnfOpt]     Jump(fold.6651, [stream.6652, f.6653, _6660, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.6651, [under1200.103, add.6647, _6650, ])
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.6663: Int = (x.6664: Int, y.6665: Int) {
// [KnfOpt]   Add(x.6664, y.6665)
// [KnfOpt] }
// [KnfOpt] let _6666: Int = Int(0)
// [KnfOpt] let join fold.6667: Int = (stream.6668: Fun([Unit], Tuple([Int, Int])), f.6669: Fun([Int, Int], Int), acc.6670: Int) {
// [KnfOpt]   let _6671: Unit = Unit
// [KnfOpt]   let _6672: Tuple([Int, Int]) = Apply(stream.6668, [_6671, ])
// [KnfOpt]   let (ok.6673: Var({val: Some(Int)}), val.6674: Var({val: Some(Int)})) = _6672
// [KnfOpt]   let _6675: Int = Int(0)
// [KnfOpt]   if (ok.6673 == _6675) then {
// [KnfOpt]     let sum.104: Int = Var(acc.6670)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _6676: Int = Apply(f.6669, [acc.6670, val.6674, ])
// [KnfOpt]     Jump(fold.6667, [stream.6668, f.6669, _6676, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.6667, [under1200.103, add.6663, _6666, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let over50.100: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let _101: Int = Int(1200)
// [KnfOpt] let rec aux.6661: Int = (y.6662: Int) {
// [KnfOpt]   if (y.6662 <= _101) then {
// [KnfOpt]     Int(0)
// [KnfOpt]   } else {
// [KnfOpt]     Int(1)
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] let _102: Fun([Int], Int) = Var(aux.6661)
// [KnfOpt] let rec aux.6677: Tuple([Int, Int]) = (u.6678: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.6679: Tuple([Int, Int]) = (u.6680: Var({val: Some(Unit)})) {
// [KnfOpt]     let _6681: Unit = Unit
// [KnfOpt]     let _6682: Tuple([Int, Int]) = Apply(over50.100, [_6681, ])
// [KnfOpt]     let (ok.6683: Var({val: Some(Int)}), val.6684: Var({val: Some(Int)})) = _6682
// [KnfOpt]     let _6685: Int = Int(0)
// [KnfOpt]     if (ok.6683 == _6685) then {
// [KnfOpt]       let _6686: Int = Int(0)
// [KnfOpt]       let _6687: Int = Int(0)
// [KnfOpt]       Tuple([_6686, _6687, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.6688: Int = Apply(_102, [val.6684, ])
// [KnfOpt]       let _6689: Int = Int(0)
// [KnfOpt]       if (r.6688 == _6689) then {
// [KnfOpt]         let _6690: Int = Int(1)
// [KnfOpt]         Tuple([_6690, val.6684, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _6691: Unit = Unit
// [KnfOpt]         Jump(aux.6679, [_6691, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.6679, [u.6678, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.6677)
// [KnfOpt] let rec add.6692: Int = (x.6693: Int, y.6694: Int) {
// [KnfOpt]   Add(x.6693, y.6694)
// [KnfOpt] }
// [KnfOpt] let _6695: Int = Int(0)
// [KnfOpt] let join fold.6696: Int = (stream.6697: Fun([Unit], Tuple([Int, Int])), f.6698: Fun([Int, Int], Int), acc.6699: Int) {
// [KnfOpt]   let _6700: Unit = Unit
// [KnfOpt]   let _6701: Tuple([Int, Int]) = Apply(stream.6697, [_6700, ])
// [KnfOpt]   let (ok.6702: Var({val: Some(Int)}), val.6703: Var({val: Some(Int)})) = _6701
// [KnfOpt]   let _6704: Int = Int(0)
// [KnfOpt]   if (ok.6702 == _6704) then {
// [KnfOpt]     let sum.104: Int = Var(acc.6699)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _6705: Int = Apply(f.6698, [acc.6699, val.6703, ])
// [KnfOpt]     Jump(fold.6696, [stream.6697, f.6698, _6705, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.6696, [under1200.103, add.6692, _6695, ])
// [KnfOpt] Inline threshold 5
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 0
// [KnfOpt] Inline decision le.83 accepted
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.6721: Int = (x.6722: Int, y.6723: Int) {
// [KnfOpt]   Add(x.6722, y.6723)
// [KnfOpt] }
// [KnfOpt] let _6724: Int = Int(0)
// [KnfOpt] let join fold.6725: Int = (stream.6726: Fun([Unit], Tuple([Int, Int])), f.6727: Fun([Int, Int], Int), acc.6728: Int) {
// [KnfOpt]   let _6729: Unit = Unit
// [KnfOpt]   let _6730: Tuple([Int, Int]) = Apply(stream.6726, [_6729, ])
// [KnfOpt]   let (ok.6731: Var({val: Some(Int)}), val.6732: Var({val: Some(Int)})) = _6730
// [KnfOpt]   let _6733: Int = Int(0)
// [KnfOpt]   if (ok.6731 == _6733) then {
// [KnfOpt]     let sum.104: Int = Var(acc.6728)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _6734: Int = Apply(f.6727, [acc.6728, val.6732, ])
// [KnfOpt]     Jump(fold.6725, [stream.6726, f.6727, _6734, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.6725, [under1200.103, add.6721, _6724, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(le) let _102: Fun([Int], Int) = Unit
// [KnfOpt] let rec aux.6735: Tuple([Int, Int]) = (u.6736: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.6737: Tuple([Int, Int]) = (u.6738: Var({val: Some(Unit)})) {
// [KnfOpt]     let _6739: Unit = Unit
// [KnfOpt]     let _6740: Tuple([Int, Int]) = Apply(over50.100, [_6739, ])
// [KnfOpt]     let (ok.6741: Var({val: Some(Int)}), val.6742: Var({val: Some(Int)})) = _6740
// [KnfOpt]     let _6743: Int = Int(0)
// [KnfOpt]     if (ok.6741 == _6743) then {
// [KnfOpt]       let _6744: Int = Int(0)
// [KnfOpt]       let _6745: Int = Int(0)
// [KnfOpt]       Tuple([_6744, _6745, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.6746: Int = Apply(_102, [val.6742, ])
// [KnfOpt]       let _6747: Int = Int(0)
// [KnfOpt]       if (r.6746 == _6747) then {
// [KnfOpt]         let _6748: Int = Int(1)
// [KnfOpt]         Tuple([_6748, val.6742, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _6749: Unit = Unit
// [KnfOpt]         Jump(aux.6737, [_6749, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.6737, [u.6736, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.6735)
// [KnfOpt] let rec add.6750: Int = (x.6751: Int, y.6752: Int) {
// [KnfOpt]   Add(x.6751, y.6752)
// [KnfOpt] }
// [KnfOpt] let _6753: Int = Int(0)
// [KnfOpt] let join fold.6754: Int = (stream.6755: Fun([Unit], Tuple([Int, Int])), f.6756: Fun([Int, Int], Int), acc.6757: Int) {
// [KnfOpt]   let _6758: Unit = Unit
// [KnfOpt]   let _6759: Tuple([Int, Int]) = Apply(stream.6755, [_6758, ])
// [KnfOpt]   let (ok.6760: Var({val: Some(Int)}), val.6761: Var({val: Some(Int)})) = _6759
// [KnfOpt]   let _6762: Int = Int(0)
// [KnfOpt]   if (ok.6760 == _6762) then {
// [KnfOpt]     let sum.104: Int = Var(acc.6757)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _6763: Int = Apply(f.6756, [acc.6757, val.6761, ])
// [KnfOpt]     Jump(fold.6754, [stream.6755, f.6756, _6763, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.6754, [under1200.103, add.6750, _6753, ])
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.6766: Int = (x.6767: Int, y.6768: Int) {
// [KnfOpt]   Add(x.6767, y.6768)
// [KnfOpt] }
// [KnfOpt] let _6769: Int = Int(0)
// [KnfOpt] let join fold.6770: Int = (stream.6771: Fun([Unit], Tuple([Int, Int])), f.6772: Fun([Int, Int], Int), acc.6773: Int) {
// [KnfOpt]   let _6774: Unit = Unit
// [KnfOpt]   let _6775: Tuple([Int, Int]) = Apply(stream.6771, [_6774, ])
// [KnfOpt]   let (ok.6776: Var({val: Some(Int)}), val.6777: Var({val: Some(Int)})) = _6775
// [KnfOpt]   let _6778: Int = Int(0)
// [KnfOpt]   if (ok.6776 == _6778) then {
// [KnfOpt]     let sum.104: Int = Var(acc.6773)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _6779: Int = Apply(f.6772, [acc.6773, val.6777, ])
// [KnfOpt]     Jump(fold.6770, [stream.6771, f.6772, _6779, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.6770, [under1200.103, add.6766, _6769, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(map) let addone.97: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let _98: Int = Int(50)
// [KnfOpt] let rec aux.6616: Int = (y.6617: Int) {
// [KnfOpt]   if (_98 <= y.6617) then {
// [KnfOpt]     Int(0)
// [KnfOpt]   } else {
// [KnfOpt]     Int(1)
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] let _99: Fun([Int], Int) = Var(aux.6616)
// [KnfOpt] let rec aux.6706: Tuple([Int, Int]) = (u.6707: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.6708: Tuple([Int, Int]) = (u.6709: Var({val: Some(Unit)})) {
// [KnfOpt]     let _6710: Unit = Unit
// [KnfOpt]     let _6711: Tuple([Int, Int]) = Apply(addone.97, [_6710, ])
// [KnfOpt]     let (ok.6712: Var({val: Some(Int)}), val.6713: Var({val: Some(Int)})) = _6711
// [KnfOpt]     let _6714: Int = Int(0)
// [KnfOpt]     if (ok.6712 == _6714) then {
// [KnfOpt]       let _6715: Int = Int(0)
// [KnfOpt]       let _6716: Int = Int(0)
// [KnfOpt]       Tuple([_6715, _6716, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.6717: Int = Apply(_99, [val.6713, ])
// [KnfOpt]       let _6718: Int = Int(0)
// [KnfOpt]       if (r.6717 == _6718) then {
// [KnfOpt]         let _6719: Int = Int(1)
// [KnfOpt]         Tuple([_6719, val.6713, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _6720: Unit = Unit
// [KnfOpt]         Jump(aux.6708, [_6720, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.6708, [u.6707, ])
// [KnfOpt] }
// [KnfOpt] let over50.100: Fun([Unit], Tuple([Int, Int])) = Var(aux.6706)
// [KnfOpt] let _101: Int = Int(1200)
// [KnfOpt] let rec aux.6764: Int = (y.6765: Int) {
// [KnfOpt]   if (y.6765 <= _101) then {
// [KnfOpt]     Int(0)
// [KnfOpt]   } else {
// [KnfOpt]     Int(1)
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] let _102: Fun([Int], Int) = Var(aux.6764)
// [KnfOpt] let rec aux.6780: Tuple([Int, Int]) = (u.6781: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.6782: Tuple([Int, Int]) = (u.6783: Var({val: Some(Unit)})) {
// [KnfOpt]     let _6784: Unit = Unit
// [KnfOpt]     let _6785: Tuple([Int, Int]) = Apply(over50.100, [_6784, ])
// [KnfOpt]     let (ok.6786: Var({val: Some(Int)}), val.6787: Var({val: Some(Int)})) = _6785
// [KnfOpt]     let _6788: Int = Int(0)
// [KnfOpt]     if (ok.6786 == _6788) then {
// [KnfOpt]       let _6789: Int = Int(0)
// [KnfOpt]       let _6790: Int = Int(0)
// [KnfOpt]       Tuple([_6789, _6790, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.6791: Int = Apply(_102, [val.6787, ])
// [KnfOpt]       let _6792: Int = Int(0)
// [KnfOpt]       if (r.6791 == _6792) then {
// [KnfOpt]         let _6793: Int = Int(1)
// [KnfOpt]         Tuple([_6793, val.6787, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _6794: Unit = Unit
// [KnfOpt]         Jump(aux.6782, [_6794, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.6782, [u.6781, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.6780)
// [KnfOpt] let rec add.6795: Int = (x.6796: Int, y.6797: Int) {
// [KnfOpt]   Add(x.6796, y.6797)
// [KnfOpt] }
// [KnfOpt] let _6798: Int = Int(0)
// [KnfOpt] let join fold.6799: Int = (stream.6800: Fun([Unit], Tuple([Int, Int])), f.6801: Fun([Int, Int], Int), acc.6802: Int) {
// [KnfOpt]   let _6803: Unit = Unit
// [KnfOpt]   let _6804: Tuple([Int, Int]) = Apply(stream.6800, [_6803, ])
// [KnfOpt]   let (ok.6805: Var({val: Some(Int)}), val.6806: Var({val: Some(Int)})) = _6804
// [KnfOpt]   let _6807: Int = Int(0)
// [KnfOpt]   if (ok.6805 == _6807) then {
// [KnfOpt]     let sum.104: Int = Var(acc.6802)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _6808: Int = Apply(f.6801, [acc.6802, val.6806, ])
// [KnfOpt]     Jump(fold.6799, [stream.6800, f.6801, _6808, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.6799, [under1200.103, add.6795, _6798, ])
// [KnfOpt] Inline threshold 5
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 0
// [KnfOpt] Inline decision gt.79 accepted
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 5
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 0
// [KnfOpt] Inline decision le.83 accepted
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.6820: Int = (x.6821: Int, y.6822: Int) {
// [KnfOpt]   Add(x.6821, y.6822)
// [KnfOpt] }
// [KnfOpt] let _6823: Int = Int(0)
// [KnfOpt] let join fold.6824: Int = (stream.6825: Fun([Unit], Tuple([Int, Int])), f.6826: Fun([Int, Int], Int), acc.6827: Int) {
// [KnfOpt]   let _6828: Unit = Unit
// [KnfOpt]   let _6829: Tuple([Int, Int]) = Apply(stream.6825, [_6828, ])
// [KnfOpt]   let (ok.6830: Var({val: Some(Int)}), val.6831: Var({val: Some(Int)})) = _6829
// [KnfOpt]   let _6832: Int = Int(0)
// [KnfOpt]   if (ok.6830 == _6832) then {
// [KnfOpt]     let sum.104: Int = Var(acc.6827)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _6833: Int = Apply(f.6826, [acc.6827, val.6831, ])
// [KnfOpt]     Jump(fold.6824, [stream.6825, f.6826, _6833, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.6824, [under1200.103, add.6820, _6823, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(le) let _102: Fun([Int], Int) = Unit
// [KnfOpt] let rec aux.6834: Tuple([Int, Int]) = (u.6835: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.6836: Tuple([Int, Int]) = (u.6837: Var({val: Some(Unit)})) {
// [KnfOpt]     let _6838: Unit = Unit
// [KnfOpt]     let _6839: Tuple([Int, Int]) = Apply(over50.100, [_6838, ])
// [KnfOpt]     let (ok.6840: Var({val: Some(Int)}), val.6841: Var({val: Some(Int)})) = _6839
// [KnfOpt]     let _6842: Int = Int(0)
// [KnfOpt]     if (ok.6840 == _6842) then {
// [KnfOpt]       let _6843: Int = Int(0)
// [KnfOpt]       let _6844: Int = Int(0)
// [KnfOpt]       Tuple([_6843, _6844, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.6845: Int = Apply(_102, [val.6841, ])
// [KnfOpt]       let _6846: Int = Int(0)
// [KnfOpt]       if (r.6845 == _6846) then {
// [KnfOpt]         let _6847: Int = Int(1)
// [KnfOpt]         Tuple([_6847, val.6841, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _6848: Unit = Unit
// [KnfOpt]         Jump(aux.6836, [_6848, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.6836, [u.6835, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.6834)
// [KnfOpt] let rec add.6849: Int = (x.6850: Int, y.6851: Int) {
// [KnfOpt]   Add(x.6850, y.6851)
// [KnfOpt] }
// [KnfOpt] let _6852: Int = Int(0)
// [KnfOpt] let join fold.6853: Int = (stream.6854: Fun([Unit], Tuple([Int, Int])), f.6855: Fun([Int, Int], Int), acc.6856: Int) {
// [KnfOpt]   let _6857: Unit = Unit
// [KnfOpt]   let _6858: Tuple([Int, Int]) = Apply(stream.6854, [_6857, ])
// [KnfOpt]   let (ok.6859: Var({val: Some(Int)}), val.6860: Var({val: Some(Int)})) = _6858
// [KnfOpt]   let _6861: Int = Int(0)
// [KnfOpt]   if (ok.6859 == _6861) then {
// [KnfOpt]     let sum.104: Int = Var(acc.6856)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _6862: Int = Apply(f.6855, [acc.6856, val.6860, ])
// [KnfOpt]     Jump(fold.6853, [stream.6854, f.6855, _6862, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.6853, [under1200.103, add.6849, _6852, ])
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.6865: Int = (x.6866: Int, y.6867: Int) {
// [KnfOpt]   Add(x.6866, y.6867)
// [KnfOpt] }
// [KnfOpt] let _6868: Int = Int(0)
// [KnfOpt] let join fold.6869: Int = (stream.6870: Fun([Unit], Tuple([Int, Int])), f.6871: Fun([Int, Int], Int), acc.6872: Int) {
// [KnfOpt]   let _6873: Unit = Unit
// [KnfOpt]   let _6874: Tuple([Int, Int]) = Apply(stream.6870, [_6873, ])
// [KnfOpt]   let (ok.6875: Var({val: Some(Int)}), val.6876: Var({val: Some(Int)})) = _6874
// [KnfOpt]   let _6877: Int = Int(0)
// [KnfOpt]   if (ok.6875 == _6877) then {
// [KnfOpt]     let sum.104: Int = Var(acc.6872)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _6878: Int = Apply(f.6871, [acc.6872, val.6876, ])
// [KnfOpt]     Jump(fold.6869, [stream.6870, f.6871, _6878, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.6869, [under1200.103, add.6865, _6868, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let over50.100: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let _101: Int = Int(1200)
// [KnfOpt] let rec aux.6863: Int = (y.6864: Int) {
// [KnfOpt]   if (y.6864 <= _101) then {
// [KnfOpt]     Int(0)
// [KnfOpt]   } else {
// [KnfOpt]     Int(1)
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] let _102: Fun([Int], Int) = Var(aux.6863)
// [KnfOpt] let rec aux.6879: Tuple([Int, Int]) = (u.6880: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.6881: Tuple([Int, Int]) = (u.6882: Var({val: Some(Unit)})) {
// [KnfOpt]     let _6883: Unit = Unit
// [KnfOpt]     let _6884: Tuple([Int, Int]) = Apply(over50.100, [_6883, ])
// [KnfOpt]     let (ok.6885: Var({val: Some(Int)}), val.6886: Var({val: Some(Int)})) = _6884
// [KnfOpt]     let _6887: Int = Int(0)
// [KnfOpt]     if (ok.6885 == _6887) then {
// [KnfOpt]       let _6888: Int = Int(0)
// [KnfOpt]       let _6889: Int = Int(0)
// [KnfOpt]       Tuple([_6888, _6889, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.6890: Int = Apply(_102, [val.6886, ])
// [KnfOpt]       let _6891: Int = Int(0)
// [KnfOpt]       if (r.6890 == _6891) then {
// [KnfOpt]         let _6892: Int = Int(1)
// [KnfOpt]         Tuple([_6892, val.6886, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _6893: Unit = Unit
// [KnfOpt]         Jump(aux.6881, [_6893, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.6881, [u.6880, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.6879)
// [KnfOpt] let rec add.6894: Int = (x.6895: Int, y.6896: Int) {
// [KnfOpt]   Add(x.6895, y.6896)
// [KnfOpt] }
// [KnfOpt] let _6897: Int = Int(0)
// [KnfOpt] let join fold.6898: Int = (stream.6899: Fun([Unit], Tuple([Int, Int])), f.6900: Fun([Int, Int], Int), acc.6901: Int) {
// [KnfOpt]   let _6902: Unit = Unit
// [KnfOpt]   let _6903: Tuple([Int, Int]) = Apply(stream.6899, [_6902, ])
// [KnfOpt]   let (ok.6904: Var({val: Some(Int)}), val.6905: Var({val: Some(Int)})) = _6903
// [KnfOpt]   let _6906: Int = Int(0)
// [KnfOpt]   if (ok.6904 == _6906) then {
// [KnfOpt]     let sum.104: Int = Var(acc.6901)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _6907: Int = Apply(f.6900, [acc.6901, val.6905, ])
// [KnfOpt]     Jump(fold.6898, [stream.6899, f.6900, _6907, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.6898, [under1200.103, add.6894, _6897, ])
// [KnfOpt] Inline threshold 5
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 0
// [KnfOpt] Inline decision le.83 accepted
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.6923: Int = (x.6924: Int, y.6925: Int) {
// [KnfOpt]   Add(x.6924, y.6925)
// [KnfOpt] }
// [KnfOpt] let _6926: Int = Int(0)
// [KnfOpt] let join fold.6927: Int = (stream.6928: Fun([Unit], Tuple([Int, Int])), f.6929: Fun([Int, Int], Int), acc.6930: Int) {
// [KnfOpt]   let _6931: Unit = Unit
// [KnfOpt]   let _6932: Tuple([Int, Int]) = Apply(stream.6928, [_6931, ])
// [KnfOpt]   let (ok.6933: Var({val: Some(Int)}), val.6934: Var({val: Some(Int)})) = _6932
// [KnfOpt]   let _6935: Int = Int(0)
// [KnfOpt]   if (ok.6933 == _6935) then {
// [KnfOpt]     let sum.104: Int = Var(acc.6930)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _6936: Int = Apply(f.6929, [acc.6930, val.6934, ])
// [KnfOpt]     Jump(fold.6927, [stream.6928, f.6929, _6936, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.6927, [under1200.103, add.6923, _6926, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(le) let _102: Fun([Int], Int) = Unit
// [KnfOpt] let rec aux.6937: Tuple([Int, Int]) = (u.6938: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.6939: Tuple([Int, Int]) = (u.6940: Var({val: Some(Unit)})) {
// [KnfOpt]     let _6941: Unit = Unit
// [KnfOpt]     let _6942: Tuple([Int, Int]) = Apply(over50.100, [_6941, ])
// [KnfOpt]     let (ok.6943: Var({val: Some(Int)}), val.6944: Var({val: Some(Int)})) = _6942
// [KnfOpt]     let _6945: Int = Int(0)
// [KnfOpt]     if (ok.6943 == _6945) then {
// [KnfOpt]       let _6946: Int = Int(0)
// [KnfOpt]       let _6947: Int = Int(0)
// [KnfOpt]       Tuple([_6946, _6947, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.6948: Int = Apply(_102, [val.6944, ])
// [KnfOpt]       let _6949: Int = Int(0)
// [KnfOpt]       if (r.6948 == _6949) then {
// [KnfOpt]         let _6950: Int = Int(1)
// [KnfOpt]         Tuple([_6950, val.6944, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _6951: Unit = Unit
// [KnfOpt]         Jump(aux.6939, [_6951, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.6939, [u.6938, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.6937)
// [KnfOpt] let rec add.6952: Int = (x.6953: Int, y.6954: Int) {
// [KnfOpt]   Add(x.6953, y.6954)
// [KnfOpt] }
// [KnfOpt] let _6955: Int = Int(0)
// [KnfOpt] let join fold.6956: Int = (stream.6957: Fun([Unit], Tuple([Int, Int])), f.6958: Fun([Int, Int], Int), acc.6959: Int) {
// [KnfOpt]   let _6960: Unit = Unit
// [KnfOpt]   let _6961: Tuple([Int, Int]) = Apply(stream.6957, [_6960, ])
// [KnfOpt]   let (ok.6962: Var({val: Some(Int)}), val.6963: Var({val: Some(Int)})) = _6961
// [KnfOpt]   let _6964: Int = Int(0)
// [KnfOpt]   if (ok.6962 == _6964) then {
// [KnfOpt]     let sum.104: Int = Var(acc.6959)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _6965: Int = Apply(f.6958, [acc.6959, val.6963, ])
// [KnfOpt]     Jump(fold.6956, [stream.6957, f.6958, _6965, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.6956, [under1200.103, add.6952, _6955, ])
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.6968: Int = (x.6969: Int, y.6970: Int) {
// [KnfOpt]   Add(x.6969, y.6970)
// [KnfOpt] }
// [KnfOpt] let _6971: Int = Int(0)
// [KnfOpt] let join fold.6972: Int = (stream.6973: Fun([Unit], Tuple([Int, Int])), f.6974: Fun([Int, Int], Int), acc.6975: Int) {
// [KnfOpt]   let _6976: Unit = Unit
// [KnfOpt]   let _6977: Tuple([Int, Int]) = Apply(stream.6973, [_6976, ])
// [KnfOpt]   let (ok.6978: Var({val: Some(Int)}), val.6979: Var({val: Some(Int)})) = _6977
// [KnfOpt]   let _6980: Int = Int(0)
// [KnfOpt]   if (ok.6978 == _6980) then {
// [KnfOpt]     let sum.104: Int = Var(acc.6975)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _6981: Int = Apply(f.6974, [acc.6975, val.6979, ])
// [KnfOpt]     Jump(fold.6972, [stream.6973, f.6974, _6981, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.6972, [under1200.103, add.6968, _6971, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(gt) let _99: Fun([Int], Int) = Unit
// [KnfOpt] let rec aux.6908: Tuple([Int, Int]) = (u.6909: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.6910: Tuple([Int, Int]) = (u.6911: Var({val: Some(Unit)})) {
// [KnfOpt]     let _6912: Unit = Unit
// [KnfOpt]     let _6913: Tuple([Int, Int]) = Apply(addone.97, [_6912, ])
// [KnfOpt]     let (ok.6914: Var({val: Some(Int)}), val.6915: Var({val: Some(Int)})) = _6913
// [KnfOpt]     let _6916: Int = Int(0)
// [KnfOpt]     if (ok.6914 == _6916) then {
// [KnfOpt]       let _6917: Int = Int(0)
// [KnfOpt]       let _6918: Int = Int(0)
// [KnfOpt]       Tuple([_6917, _6918, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.6919: Int = Apply(_99, [val.6915, ])
// [KnfOpt]       let _6920: Int = Int(0)
// [KnfOpt]       if (r.6919 == _6920) then {
// [KnfOpt]         let _6921: Int = Int(1)
// [KnfOpt]         Tuple([_6921, val.6915, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _6922: Unit = Unit
// [KnfOpt]         Jump(aux.6910, [_6922, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.6910, [u.6909, ])
// [KnfOpt] }
// [KnfOpt] let over50.100: Fun([Unit], Tuple([Int, Int])) = Var(aux.6908)
// [KnfOpt] let _101: Int = Int(1200)
// [KnfOpt] let rec aux.6966: Int = (y.6967: Int) {
// [KnfOpt]   if (y.6967 <= _101) then {
// [KnfOpt]     Int(0)
// [KnfOpt]   } else {
// [KnfOpt]     Int(1)
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] let _102: Fun([Int], Int) = Var(aux.6966)
// [KnfOpt] let rec aux.6982: Tuple([Int, Int]) = (u.6983: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.6984: Tuple([Int, Int]) = (u.6985: Var({val: Some(Unit)})) {
// [KnfOpt]     let _6986: Unit = Unit
// [KnfOpt]     let _6987: Tuple([Int, Int]) = Apply(over50.100, [_6986, ])
// [KnfOpt]     let (ok.6988: Var({val: Some(Int)}), val.6989: Var({val: Some(Int)})) = _6987
// [KnfOpt]     let _6990: Int = Int(0)
// [KnfOpt]     if (ok.6988 == _6990) then {
// [KnfOpt]       let _6991: Int = Int(0)
// [KnfOpt]       let _6992: Int = Int(0)
// [KnfOpt]       Tuple([_6991, _6992, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.6993: Int = Apply(_102, [val.6989, ])
// [KnfOpt]       let _6994: Int = Int(0)
// [KnfOpt]       if (r.6993 == _6994) then {
// [KnfOpt]         let _6995: Int = Int(1)
// [KnfOpt]         Tuple([_6995, val.6989, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _6996: Unit = Unit
// [KnfOpt]         Jump(aux.6984, [_6996, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.6984, [u.6983, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.6982)
// [KnfOpt] let rec add.6997: Int = (x.6998: Int, y.6999: Int) {
// [KnfOpt]   Add(x.6998, y.6999)
// [KnfOpt] }
// [KnfOpt] let _7000: Int = Int(0)
// [KnfOpt] let join fold.7001: Int = (stream.7002: Fun([Unit], Tuple([Int, Int])), f.7003: Fun([Int, Int], Int), acc.7004: Int) {
// [KnfOpt]   let _7005: Unit = Unit
// [KnfOpt]   let _7006: Tuple([Int, Int]) = Apply(stream.7002, [_7005, ])
// [KnfOpt]   let (ok.7007: Var({val: Some(Int)}), val.7008: Var({val: Some(Int)})) = _7006
// [KnfOpt]   let _7009: Int = Int(0)
// [KnfOpt]   if (ok.7007 == _7009) then {
// [KnfOpt]     let sum.104: Int = Var(acc.7004)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _7010: Int = Apply(f.7003, [acc.7004, val.7008, ])
// [KnfOpt]     Jump(fold.7001, [stream.7002, f.7003, _7010, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.7001, [under1200.103, add.6997, _7000, ])
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 5
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 0
// [KnfOpt] Inline decision le.83 accepted
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.7013: Int = (x.7014: Int, y.7015: Int) {
// [KnfOpt]   Add(x.7014, y.7015)
// [KnfOpt] }
// [KnfOpt] let _7016: Int = Int(0)
// [KnfOpt] let join fold.7017: Int = (stream.7018: Fun([Unit], Tuple([Int, Int])), f.7019: Fun([Int, Int], Int), acc.7020: Int) {
// [KnfOpt]   let _7021: Unit = Unit
// [KnfOpt]   let _7022: Tuple([Int, Int]) = Apply(stream.7018, [_7021, ])
// [KnfOpt]   let (ok.7023: Var({val: Some(Int)}), val.7024: Var({val: Some(Int)})) = _7022
// [KnfOpt]   let _7025: Int = Int(0)
// [KnfOpt]   if (ok.7023 == _7025) then {
// [KnfOpt]     let sum.104: Int = Var(acc.7020)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _7026: Int = Apply(f.7019, [acc.7020, val.7024, ])
// [KnfOpt]     Jump(fold.7017, [stream.7018, f.7019, _7026, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.7017, [under1200.103, add.7013, _7016, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(le) let _102: Fun([Int], Int) = Unit
// [KnfOpt] let rec aux.7027: Tuple([Int, Int]) = (u.7028: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.7029: Tuple([Int, Int]) = (u.7030: Var({val: Some(Unit)})) {
// [KnfOpt]     let _7031: Unit = Unit
// [KnfOpt]     let _7032: Tuple([Int, Int]) = Apply(over50.100, [_7031, ])
// [KnfOpt]     let (ok.7033: Var({val: Some(Int)}), val.7034: Var({val: Some(Int)})) = _7032
// [KnfOpt]     let _7035: Int = Int(0)
// [KnfOpt]     if (ok.7033 == _7035) then {
// [KnfOpt]       let _7036: Int = Int(0)
// [KnfOpt]       let _7037: Int = Int(0)
// [KnfOpt]       Tuple([_7036, _7037, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.7038: Int = Apply(_102, [val.7034, ])
// [KnfOpt]       let _7039: Int = Int(0)
// [KnfOpt]       if (r.7038 == _7039) then {
// [KnfOpt]         let _7040: Int = Int(1)
// [KnfOpt]         Tuple([_7040, val.7034, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _7041: Unit = Unit
// [KnfOpt]         Jump(aux.7029, [_7041, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.7029, [u.7028, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.7027)
// [KnfOpt] let rec add.7042: Int = (x.7043: Int, y.7044: Int) {
// [KnfOpt]   Add(x.7043, y.7044)
// [KnfOpt] }
// [KnfOpt] let _7045: Int = Int(0)
// [KnfOpt] let join fold.7046: Int = (stream.7047: Fun([Unit], Tuple([Int, Int])), f.7048: Fun([Int, Int], Int), acc.7049: Int) {
// [KnfOpt]   let _7050: Unit = Unit
// [KnfOpt]   let _7051: Tuple([Int, Int]) = Apply(stream.7047, [_7050, ])
// [KnfOpt]   let (ok.7052: Var({val: Some(Int)}), val.7053: Var({val: Some(Int)})) = _7051
// [KnfOpt]   let _7054: Int = Int(0)
// [KnfOpt]   if (ok.7052 == _7054) then {
// [KnfOpt]     let sum.104: Int = Var(acc.7049)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _7055: Int = Apply(f.7048, [acc.7049, val.7053, ])
// [KnfOpt]     Jump(fold.7046, [stream.7047, f.7048, _7055, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.7046, [under1200.103, add.7042, _7045, ])
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.7058: Int = (x.7059: Int, y.7060: Int) {
// [KnfOpt]   Add(x.7059, y.7060)
// [KnfOpt] }
// [KnfOpt] let _7061: Int = Int(0)
// [KnfOpt] let join fold.7062: Int = (stream.7063: Fun([Unit], Tuple([Int, Int])), f.7064: Fun([Int, Int], Int), acc.7065: Int) {
// [KnfOpt]   let _7066: Unit = Unit
// [KnfOpt]   let _7067: Tuple([Int, Int]) = Apply(stream.7063, [_7066, ])
// [KnfOpt]   let (ok.7068: Var({val: Some(Int)}), val.7069: Var({val: Some(Int)})) = _7067
// [KnfOpt]   let _7070: Int = Int(0)
// [KnfOpt]   if (ok.7068 == _7070) then {
// [KnfOpt]     let sum.104: Int = Var(acc.7065)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _7071: Int = Apply(f.7064, [acc.7065, val.7069, ])
// [KnfOpt]     Jump(fold.7062, [stream.7063, f.7064, _7071, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.7062, [under1200.103, add.7058, _7061, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let over50.100: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let _101: Int = Int(1200)
// [KnfOpt] let rec aux.7056: Int = (y.7057: Int) {
// [KnfOpt]   if (y.7057 <= _101) then {
// [KnfOpt]     Int(0)
// [KnfOpt]   } else {
// [KnfOpt]     Int(1)
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] let _102: Fun([Int], Int) = Var(aux.7056)
// [KnfOpt] let rec aux.7072: Tuple([Int, Int]) = (u.7073: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.7074: Tuple([Int, Int]) = (u.7075: Var({val: Some(Unit)})) {
// [KnfOpt]     let _7076: Unit = Unit
// [KnfOpt]     let _7077: Tuple([Int, Int]) = Apply(over50.100, [_7076, ])
// [KnfOpt]     let (ok.7078: Var({val: Some(Int)}), val.7079: Var({val: Some(Int)})) = _7077
// [KnfOpt]     let _7080: Int = Int(0)
// [KnfOpt]     if (ok.7078 == _7080) then {
// [KnfOpt]       let _7081: Int = Int(0)
// [KnfOpt]       let _7082: Int = Int(0)
// [KnfOpt]       Tuple([_7081, _7082, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.7083: Int = Apply(_102, [val.7079, ])
// [KnfOpt]       let _7084: Int = Int(0)
// [KnfOpt]       if (r.7083 == _7084) then {
// [KnfOpt]         let _7085: Int = Int(1)
// [KnfOpt]         Tuple([_7085, val.7079, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _7086: Unit = Unit
// [KnfOpt]         Jump(aux.7074, [_7086, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.7074, [u.7073, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.7072)
// [KnfOpt] let rec add.7087: Int = (x.7088: Int, y.7089: Int) {
// [KnfOpt]   Add(x.7088, y.7089)
// [KnfOpt] }
// [KnfOpt] let _7090: Int = Int(0)
// [KnfOpt] let join fold.7091: Int = (stream.7092: Fun([Unit], Tuple([Int, Int])), f.7093: Fun([Int, Int], Int), acc.7094: Int) {
// [KnfOpt]   let _7095: Unit = Unit
// [KnfOpt]   let _7096: Tuple([Int, Int]) = Apply(stream.7092, [_7095, ])
// [KnfOpt]   let (ok.7097: Var({val: Some(Int)}), val.7098: Var({val: Some(Int)})) = _7096
// [KnfOpt]   let _7099: Int = Int(0)
// [KnfOpt]   if (ok.7097 == _7099) then {
// [KnfOpt]     let sum.104: Int = Var(acc.7094)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _7100: Int = Apply(f.7093, [acc.7094, val.7098, ])
// [KnfOpt]     Jump(fold.7091, [stream.7092, f.7093, _7100, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.7091, [under1200.103, add.7087, _7090, ])
// [KnfOpt] Inline threshold 5
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 0
// [KnfOpt] Inline decision le.83 accepted
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.7116: Int = (x.7117: Int, y.7118: Int) {
// [KnfOpt]   Add(x.7117, y.7118)
// [KnfOpt] }
// [KnfOpt] let _7119: Int = Int(0)
// [KnfOpt] let join fold.7120: Int = (stream.7121: Fun([Unit], Tuple([Int, Int])), f.7122: Fun([Int, Int], Int), acc.7123: Int) {
// [KnfOpt]   let _7124: Unit = Unit
// [KnfOpt]   let _7125: Tuple([Int, Int]) = Apply(stream.7121, [_7124, ])
// [KnfOpt]   let (ok.7126: Var({val: Some(Int)}), val.7127: Var({val: Some(Int)})) = _7125
// [KnfOpt]   let _7128: Int = Int(0)
// [KnfOpt]   if (ok.7126 == _7128) then {
// [KnfOpt]     let sum.104: Int = Var(acc.7123)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _7129: Int = Apply(f.7122, [acc.7123, val.7127, ])
// [KnfOpt]     Jump(fold.7120, [stream.7121, f.7122, _7129, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.7120, [under1200.103, add.7116, _7119, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(le) let _102: Fun([Int], Int) = Unit
// [KnfOpt] let rec aux.7130: Tuple([Int, Int]) = (u.7131: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.7132: Tuple([Int, Int]) = (u.7133: Var({val: Some(Unit)})) {
// [KnfOpt]     let _7134: Unit = Unit
// [KnfOpt]     let _7135: Tuple([Int, Int]) = Apply(over50.100, [_7134, ])
// [KnfOpt]     let (ok.7136: Var({val: Some(Int)}), val.7137: Var({val: Some(Int)})) = _7135
// [KnfOpt]     let _7138: Int = Int(0)
// [KnfOpt]     if (ok.7136 == _7138) then {
// [KnfOpt]       let _7139: Int = Int(0)
// [KnfOpt]       let _7140: Int = Int(0)
// [KnfOpt]       Tuple([_7139, _7140, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.7141: Int = Apply(_102, [val.7137, ])
// [KnfOpt]       let _7142: Int = Int(0)
// [KnfOpt]       if (r.7141 == _7142) then {
// [KnfOpt]         let _7143: Int = Int(1)
// [KnfOpt]         Tuple([_7143, val.7137, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _7144: Unit = Unit
// [KnfOpt]         Jump(aux.7132, [_7144, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.7132, [u.7131, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.7130)
// [KnfOpt] let rec add.7145: Int = (x.7146: Int, y.7147: Int) {
// [KnfOpt]   Add(x.7146, y.7147)
// [KnfOpt] }
// [KnfOpt] let _7148: Int = Int(0)
// [KnfOpt] let join fold.7149: Int = (stream.7150: Fun([Unit], Tuple([Int, Int])), f.7151: Fun([Int, Int], Int), acc.7152: Int) {
// [KnfOpt]   let _7153: Unit = Unit
// [KnfOpt]   let _7154: Tuple([Int, Int]) = Apply(stream.7150, [_7153, ])
// [KnfOpt]   let (ok.7155: Var({val: Some(Int)}), val.7156: Var({val: Some(Int)})) = _7154
// [KnfOpt]   let _7157: Int = Int(0)
// [KnfOpt]   if (ok.7155 == _7157) then {
// [KnfOpt]     let sum.104: Int = Var(acc.7152)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _7158: Int = Apply(f.7151, [acc.7152, val.7156, ])
// [KnfOpt]     Jump(fold.7149, [stream.7150, f.7151, _7158, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.7149, [under1200.103, add.7145, _7148, ])
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.7161: Int = (x.7162: Int, y.7163: Int) {
// [KnfOpt]   Add(x.7162, y.7163)
// [KnfOpt] }
// [KnfOpt] let _7164: Int = Int(0)
// [KnfOpt] let join fold.7165: Int = (stream.7166: Fun([Unit], Tuple([Int, Int])), f.7167: Fun([Int, Int], Int), acc.7168: Int) {
// [KnfOpt]   let _7169: Unit = Unit
// [KnfOpt]   let _7170: Tuple([Int, Int]) = Apply(stream.7166, [_7169, ])
// [KnfOpt]   let (ok.7171: Var({val: Some(Int)}), val.7172: Var({val: Some(Int)})) = _7170
// [KnfOpt]   let _7173: Int = Int(0)
// [KnfOpt]   if (ok.7171 == _7173) then {
// [KnfOpt]     let sum.104: Int = Var(acc.7168)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _7174: Int = Apply(f.7167, [acc.7168, val.7172, ])
// [KnfOpt]     Jump(fold.7165, [stream.7166, f.7167, _7174, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.7165, [under1200.103, add.7161, _7164, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(addx) let _96: Fun([Int], Int) = Unit
// [KnfOpt] let rec aux.6809: Tuple([Int, Int]) = (u.6810: Var({val: Some(Unit)})) {
// [KnfOpt]   let _6811: Unit = Unit
// [KnfOpt]   let _6812: Tuple([Int, Int]) = Apply(catt.94, [_6811, ])
// [KnfOpt]   let (ok.6813: Var({val: Some(Int)}), val.6814: Var({val: Some(Int)})) = _6812
// [KnfOpt]   let _6815: Int = Int(0)
// [KnfOpt]   if (ok.6813 == _6815) then {
// [KnfOpt]     let _6816: Int = Int(0)
// [KnfOpt]     let _6817: Int = Int(0)
// [KnfOpt]     Tuple([_6816, _6817, ])
// [KnfOpt]   } else {
// [KnfOpt]     let _6818: Int = Int(1)
// [KnfOpt]     let _6819: Int = Apply(_96, [val.6814, ])
// [KnfOpt]     Tuple([_6818, _6819, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] let addone.97: Fun([Unit], Tuple([Int, Int])) = Var(aux.6809)
// [KnfOpt] let _98: Int = Int(50)
// [KnfOpt] let rec aux.7011: Int = (y.7012: Int) {
// [KnfOpt]   if (_98 <= y.7012) then {
// [KnfOpt]     Int(0)
// [KnfOpt]   } else {
// [KnfOpt]     Int(1)
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] let _99: Fun([Int], Int) = Var(aux.7011)
// [KnfOpt] let rec aux.7101: Tuple([Int, Int]) = (u.7102: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.7103: Tuple([Int, Int]) = (u.7104: Var({val: Some(Unit)})) {
// [KnfOpt]     let _7105: Unit = Unit
// [KnfOpt]     let _7106: Tuple([Int, Int]) = Apply(addone.97, [_7105, ])
// [KnfOpt]     let (ok.7107: Var({val: Some(Int)}), val.7108: Var({val: Some(Int)})) = _7106
// [KnfOpt]     let _7109: Int = Int(0)
// [KnfOpt]     if (ok.7107 == _7109) then {
// [KnfOpt]       let _7110: Int = Int(0)
// [KnfOpt]       let _7111: Int = Int(0)
// [KnfOpt]       Tuple([_7110, _7111, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.7112: Int = Apply(_99, [val.7108, ])
// [KnfOpt]       let _7113: Int = Int(0)
// [KnfOpt]       if (r.7112 == _7113) then {
// [KnfOpt]         let _7114: Int = Int(1)
// [KnfOpt]         Tuple([_7114, val.7108, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _7115: Unit = Unit
// [KnfOpt]         Jump(aux.7103, [_7115, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.7103, [u.7102, ])
// [KnfOpt] }
// [KnfOpt] let over50.100: Fun([Unit], Tuple([Int, Int])) = Var(aux.7101)
// [KnfOpt] let _101: Int = Int(1200)
// [KnfOpt] let rec aux.7159: Int = (y.7160: Int) {
// [KnfOpt]   if (y.7160 <= _101) then {
// [KnfOpt]     Int(0)
// [KnfOpt]   } else {
// [KnfOpt]     Int(1)
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] let _102: Fun([Int], Int) = Var(aux.7159)
// [KnfOpt] let rec aux.7175: Tuple([Int, Int]) = (u.7176: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.7177: Tuple([Int, Int]) = (u.7178: Var({val: Some(Unit)})) {
// [KnfOpt]     let _7179: Unit = Unit
// [KnfOpt]     let _7180: Tuple([Int, Int]) = Apply(over50.100, [_7179, ])
// [KnfOpt]     let (ok.7181: Var({val: Some(Int)}), val.7182: Var({val: Some(Int)})) = _7180
// [KnfOpt]     let _7183: Int = Int(0)
// [KnfOpt]     if (ok.7181 == _7183) then {
// [KnfOpt]       let _7184: Int = Int(0)
// [KnfOpt]       let _7185: Int = Int(0)
// [KnfOpt]       Tuple([_7184, _7185, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.7186: Int = Apply(_102, [val.7182, ])
// [KnfOpt]       let _7187: Int = Int(0)
// [KnfOpt]       if (r.7186 == _7187) then {
// [KnfOpt]         let _7188: Int = Int(1)
// [KnfOpt]         Tuple([_7188, val.7182, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _7189: Unit = Unit
// [KnfOpt]         Jump(aux.7177, [_7189, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.7177, [u.7176, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.7175)
// [KnfOpt] let rec add.7190: Int = (x.7191: Int, y.7192: Int) {
// [KnfOpt]   Add(x.7191, y.7192)
// [KnfOpt] }
// [KnfOpt] let _7193: Int = Int(0)
// [KnfOpt] let join fold.7194: Int = (stream.7195: Fun([Unit], Tuple([Int, Int])), f.7196: Fun([Int, Int], Int), acc.7197: Int) {
// [KnfOpt]   let _7198: Unit = Unit
// [KnfOpt]   let _7199: Tuple([Int, Int]) = Apply(stream.7195, [_7198, ])
// [KnfOpt]   let (ok.7200: Var({val: Some(Int)}), val.7201: Var({val: Some(Int)})) = _7199
// [KnfOpt]   let _7202: Int = Int(0)
// [KnfOpt]   if (ok.7200 == _7202) then {
// [KnfOpt]     let sum.104: Int = Var(acc.7197)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _7203: Int = Apply(f.7196, [acc.7197, val.7201, ])
// [KnfOpt]     Jump(fold.7194, [stream.7195, f.7196, _7203, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.7194, [under1200.103, add.7190, _7193, ])
// [KnfOpt] Inline threshold 20
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 0
// [KnfOpt] Inline decision map.1 accepted
// [KnfOpt] Inline threshold 5
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 0
// [KnfOpt] Inline decision gt.79 accepted
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 5
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 0
// [KnfOpt] Inline decision le.83 accepted
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.7206: Int = (x.7207: Int, y.7208: Int) {
// [KnfOpt]   Add(x.7207, y.7208)
// [KnfOpt] }
// [KnfOpt] let _7209: Int = Int(0)
// [KnfOpt] let join fold.7210: Int = (stream.7211: Fun([Unit], Tuple([Int, Int])), f.7212: Fun([Int, Int], Int), acc.7213: Int) {
// [KnfOpt]   let _7214: Unit = Unit
// [KnfOpt]   let _7215: Tuple([Int, Int]) = Apply(stream.7211, [_7214, ])
// [KnfOpt]   let (ok.7216: Var({val: Some(Int)}), val.7217: Var({val: Some(Int)})) = _7215
// [KnfOpt]   let _7218: Int = Int(0)
// [KnfOpt]   if (ok.7216 == _7218) then {
// [KnfOpt]     let sum.104: Int = Var(acc.7213)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _7219: Int = Apply(f.7212, [acc.7213, val.7217, ])
// [KnfOpt]     Jump(fold.7210, [stream.7211, f.7212, _7219, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.7210, [under1200.103, add.7206, _7209, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(le) let _102: Fun([Int], Int) = Unit
// [KnfOpt] let rec aux.7220: Tuple([Int, Int]) = (u.7221: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.7222: Tuple([Int, Int]) = (u.7223: Var({val: Some(Unit)})) {
// [KnfOpt]     let _7224: Unit = Unit
// [KnfOpt]     let _7225: Tuple([Int, Int]) = Apply(over50.100, [_7224, ])
// [KnfOpt]     let (ok.7226: Var({val: Some(Int)}), val.7227: Var({val: Some(Int)})) = _7225
// [KnfOpt]     let _7228: Int = Int(0)
// [KnfOpt]     if (ok.7226 == _7228) then {
// [KnfOpt]       let _7229: Int = Int(0)
// [KnfOpt]       let _7230: Int = Int(0)
// [KnfOpt]       Tuple([_7229, _7230, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.7231: Int = Apply(_102, [val.7227, ])
// [KnfOpt]       let _7232: Int = Int(0)
// [KnfOpt]       if (r.7231 == _7232) then {
// [KnfOpt]         let _7233: Int = Int(1)
// [KnfOpt]         Tuple([_7233, val.7227, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _7234: Unit = Unit
// [KnfOpt]         Jump(aux.7222, [_7234, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.7222, [u.7221, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.7220)
// [KnfOpt] let rec add.7235: Int = (x.7236: Int, y.7237: Int) {
// [KnfOpt]   Add(x.7236, y.7237)
// [KnfOpt] }
// [KnfOpt] let _7238: Int = Int(0)
// [KnfOpt] let join fold.7239: Int = (stream.7240: Fun([Unit], Tuple([Int, Int])), f.7241: Fun([Int, Int], Int), acc.7242: Int) {
// [KnfOpt]   let _7243: Unit = Unit
// [KnfOpt]   let _7244: Tuple([Int, Int]) = Apply(stream.7240, [_7243, ])
// [KnfOpt]   let (ok.7245: Var({val: Some(Int)}), val.7246: Var({val: Some(Int)})) = _7244
// [KnfOpt]   let _7247: Int = Int(0)
// [KnfOpt]   if (ok.7245 == _7247) then {
// [KnfOpt]     let sum.104: Int = Var(acc.7242)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _7248: Int = Apply(f.7241, [acc.7242, val.7246, ])
// [KnfOpt]     Jump(fold.7239, [stream.7240, f.7241, _7248, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.7239, [under1200.103, add.7235, _7238, ])
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.7251: Int = (x.7252: Int, y.7253: Int) {
// [KnfOpt]   Add(x.7252, y.7253)
// [KnfOpt] }
// [KnfOpt] let _7254: Int = Int(0)
// [KnfOpt] let join fold.7255: Int = (stream.7256: Fun([Unit], Tuple([Int, Int])), f.7257: Fun([Int, Int], Int), acc.7258: Int) {
// [KnfOpt]   let _7259: Unit = Unit
// [KnfOpt]   let _7260: Tuple([Int, Int]) = Apply(stream.7256, [_7259, ])
// [KnfOpt]   let (ok.7261: Var({val: Some(Int)}), val.7262: Var({val: Some(Int)})) = _7260
// [KnfOpt]   let _7263: Int = Int(0)
// [KnfOpt]   if (ok.7261 == _7263) then {
// [KnfOpt]     let sum.104: Int = Var(acc.7258)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _7264: Int = Apply(f.7257, [acc.7258, val.7262, ])
// [KnfOpt]     Jump(fold.7255, [stream.7256, f.7257, _7264, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.7255, [under1200.103, add.7251, _7254, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let over50.100: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let _101: Int = Int(1200)
// [KnfOpt] let rec aux.7249: Int = (y.7250: Int) {
// [KnfOpt]   if (y.7250 <= _101) then {
// [KnfOpt]     Int(0)
// [KnfOpt]   } else {
// [KnfOpt]     Int(1)
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] let _102: Fun([Int], Int) = Var(aux.7249)
// [KnfOpt] let rec aux.7265: Tuple([Int, Int]) = (u.7266: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.7267: Tuple([Int, Int]) = (u.7268: Var({val: Some(Unit)})) {
// [KnfOpt]     let _7269: Unit = Unit
// [KnfOpt]     let _7270: Tuple([Int, Int]) = Apply(over50.100, [_7269, ])
// [KnfOpt]     let (ok.7271: Var({val: Some(Int)}), val.7272: Var({val: Some(Int)})) = _7270
// [KnfOpt]     let _7273: Int = Int(0)
// [KnfOpt]     if (ok.7271 == _7273) then {
// [KnfOpt]       let _7274: Int = Int(0)
// [KnfOpt]       let _7275: Int = Int(0)
// [KnfOpt]       Tuple([_7274, _7275, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.7276: Int = Apply(_102, [val.7272, ])
// [KnfOpt]       let _7277: Int = Int(0)
// [KnfOpt]       if (r.7276 == _7277) then {
// [KnfOpt]         let _7278: Int = Int(1)
// [KnfOpt]         Tuple([_7278, val.7272, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _7279: Unit = Unit
// [KnfOpt]         Jump(aux.7267, [_7279, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.7267, [u.7266, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.7265)
// [KnfOpt] let rec add.7280: Int = (x.7281: Int, y.7282: Int) {
// [KnfOpt]   Add(x.7281, y.7282)
// [KnfOpt] }
// [KnfOpt] let _7283: Int = Int(0)
// [KnfOpt] let join fold.7284: Int = (stream.7285: Fun([Unit], Tuple([Int, Int])), f.7286: Fun([Int, Int], Int), acc.7287: Int) {
// [KnfOpt]   let _7288: Unit = Unit
// [KnfOpt]   let _7289: Tuple([Int, Int]) = Apply(stream.7285, [_7288, ])
// [KnfOpt]   let (ok.7290: Var({val: Some(Int)}), val.7291: Var({val: Some(Int)})) = _7289
// [KnfOpt]   let _7292: Int = Int(0)
// [KnfOpt]   if (ok.7290 == _7292) then {
// [KnfOpt]     let sum.104: Int = Var(acc.7287)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _7293: Int = Apply(f.7286, [acc.7287, val.7291, ])
// [KnfOpt]     Jump(fold.7284, [stream.7285, f.7286, _7293, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.7284, [under1200.103, add.7280, _7283, ])
// [KnfOpt] Inline threshold 5
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 0
// [KnfOpt] Inline decision le.83 accepted
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.7309: Int = (x.7310: Int, y.7311: Int) {
// [KnfOpt]   Add(x.7310, y.7311)
// [KnfOpt] }
// [KnfOpt] let _7312: Int = Int(0)
// [KnfOpt] let join fold.7313: Int = (stream.7314: Fun([Unit], Tuple([Int, Int])), f.7315: Fun([Int, Int], Int), acc.7316: Int) {
// [KnfOpt]   let _7317: Unit = Unit
// [KnfOpt]   let _7318: Tuple([Int, Int]) = Apply(stream.7314, [_7317, ])
// [KnfOpt]   let (ok.7319: Var({val: Some(Int)}), val.7320: Var({val: Some(Int)})) = _7318
// [KnfOpt]   let _7321: Int = Int(0)
// [KnfOpt]   if (ok.7319 == _7321) then {
// [KnfOpt]     let sum.104: Int = Var(acc.7316)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _7322: Int = Apply(f.7315, [acc.7316, val.7320, ])
// [KnfOpt]     Jump(fold.7313, [stream.7314, f.7315, _7322, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.7313, [under1200.103, add.7309, _7312, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(le) let _102: Fun([Int], Int) = Unit
// [KnfOpt] let rec aux.7323: Tuple([Int, Int]) = (u.7324: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.7325: Tuple([Int, Int]) = (u.7326: Var({val: Some(Unit)})) {
// [KnfOpt]     let _7327: Unit = Unit
// [KnfOpt]     let _7328: Tuple([Int, Int]) = Apply(over50.100, [_7327, ])
// [KnfOpt]     let (ok.7329: Var({val: Some(Int)}), val.7330: Var({val: Some(Int)})) = _7328
// [KnfOpt]     let _7331: Int = Int(0)
// [KnfOpt]     if (ok.7329 == _7331) then {
// [KnfOpt]       let _7332: Int = Int(0)
// [KnfOpt]       let _7333: Int = Int(0)
// [KnfOpt]       Tuple([_7332, _7333, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.7334: Int = Apply(_102, [val.7330, ])
// [KnfOpt]       let _7335: Int = Int(0)
// [KnfOpt]       if (r.7334 == _7335) then {
// [KnfOpt]         let _7336: Int = Int(1)
// [KnfOpt]         Tuple([_7336, val.7330, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _7337: Unit = Unit
// [KnfOpt]         Jump(aux.7325, [_7337, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.7325, [u.7324, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.7323)
// [KnfOpt] let rec add.7338: Int = (x.7339: Int, y.7340: Int) {
// [KnfOpt]   Add(x.7339, y.7340)
// [KnfOpt] }
// [KnfOpt] let _7341: Int = Int(0)
// [KnfOpt] let join fold.7342: Int = (stream.7343: Fun([Unit], Tuple([Int, Int])), f.7344: Fun([Int, Int], Int), acc.7345: Int) {
// [KnfOpt]   let _7346: Unit = Unit
// [KnfOpt]   let _7347: Tuple([Int, Int]) = Apply(stream.7343, [_7346, ])
// [KnfOpt]   let (ok.7348: Var({val: Some(Int)}), val.7349: Var({val: Some(Int)})) = _7347
// [KnfOpt]   let _7350: Int = Int(0)
// [KnfOpt]   if (ok.7348 == _7350) then {
// [KnfOpt]     let sum.104: Int = Var(acc.7345)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _7351: Int = Apply(f.7344, [acc.7345, val.7349, ])
// [KnfOpt]     Jump(fold.7342, [stream.7343, f.7344, _7351, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.7342, [under1200.103, add.7338, _7341, ])
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.7354: Int = (x.7355: Int, y.7356: Int) {
// [KnfOpt]   Add(x.7355, y.7356)
// [KnfOpt] }
// [KnfOpt] let _7357: Int = Int(0)
// [KnfOpt] let join fold.7358: Int = (stream.7359: Fun([Unit], Tuple([Int, Int])), f.7360: Fun([Int, Int], Int), acc.7361: Int) {
// [KnfOpt]   let _7362: Unit = Unit
// [KnfOpt]   let _7363: Tuple([Int, Int]) = Apply(stream.7359, [_7362, ])
// [KnfOpt]   let (ok.7364: Var({val: Some(Int)}), val.7365: Var({val: Some(Int)})) = _7363
// [KnfOpt]   let _7366: Int = Int(0)
// [KnfOpt]   if (ok.7364 == _7366) then {
// [KnfOpt]     let sum.104: Int = Var(acc.7361)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _7367: Int = Apply(f.7360, [acc.7361, val.7365, ])
// [KnfOpt]     Jump(fold.7358, [stream.7359, f.7360, _7367, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.7358, [under1200.103, add.7354, _7357, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(gt) let _99: Fun([Int], Int) = Unit
// [KnfOpt] let rec aux.7294: Tuple([Int, Int]) = (u.7295: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.7296: Tuple([Int, Int]) = (u.7297: Var({val: Some(Unit)})) {
// [KnfOpt]     let _7298: Unit = Unit
// [KnfOpt]     let _7299: Tuple([Int, Int]) = Apply(addone.97, [_7298, ])
// [KnfOpt]     let (ok.7300: Var({val: Some(Int)}), val.7301: Var({val: Some(Int)})) = _7299
// [KnfOpt]     let _7302: Int = Int(0)
// [KnfOpt]     if (ok.7300 == _7302) then {
// [KnfOpt]       let _7303: Int = Int(0)
// [KnfOpt]       let _7304: Int = Int(0)
// [KnfOpt]       Tuple([_7303, _7304, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.7305: Int = Apply(_99, [val.7301, ])
// [KnfOpt]       let _7306: Int = Int(0)
// [KnfOpt]       if (r.7305 == _7306) then {
// [KnfOpt]         let _7307: Int = Int(1)
// [KnfOpt]         Tuple([_7307, val.7301, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _7308: Unit = Unit
// [KnfOpt]         Jump(aux.7296, [_7308, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.7296, [u.7295, ])
// [KnfOpt] }
// [KnfOpt] let over50.100: Fun([Unit], Tuple([Int, Int])) = Var(aux.7294)
// [KnfOpt] let _101: Int = Int(1200)
// [KnfOpt] let rec aux.7352: Int = (y.7353: Int) {
// [KnfOpt]   if (y.7353 <= _101) then {
// [KnfOpt]     Int(0)
// [KnfOpt]   } else {
// [KnfOpt]     Int(1)
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] let _102: Fun([Int], Int) = Var(aux.7352)
// [KnfOpt] let rec aux.7368: Tuple([Int, Int]) = (u.7369: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.7370: Tuple([Int, Int]) = (u.7371: Var({val: Some(Unit)})) {
// [KnfOpt]     let _7372: Unit = Unit
// [KnfOpt]     let _7373: Tuple([Int, Int]) = Apply(over50.100, [_7372, ])
// [KnfOpt]     let (ok.7374: Var({val: Some(Int)}), val.7375: Var({val: Some(Int)})) = _7373
// [KnfOpt]     let _7376: Int = Int(0)
// [KnfOpt]     if (ok.7374 == _7376) then {
// [KnfOpt]       let _7377: Int = Int(0)
// [KnfOpt]       let _7378: Int = Int(0)
// [KnfOpt]       Tuple([_7377, _7378, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.7379: Int = Apply(_102, [val.7375, ])
// [KnfOpt]       let _7380: Int = Int(0)
// [KnfOpt]       if (r.7379 == _7380) then {
// [KnfOpt]         let _7381: Int = Int(1)
// [KnfOpt]         Tuple([_7381, val.7375, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _7382: Unit = Unit
// [KnfOpt]         Jump(aux.7370, [_7382, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.7370, [u.7369, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.7368)
// [KnfOpt] let rec add.7383: Int = (x.7384: Int, y.7385: Int) {
// [KnfOpt]   Add(x.7384, y.7385)
// [KnfOpt] }
// [KnfOpt] let _7386: Int = Int(0)
// [KnfOpt] let join fold.7387: Int = (stream.7388: Fun([Unit], Tuple([Int, Int])), f.7389: Fun([Int, Int], Int), acc.7390: Int) {
// [KnfOpt]   let _7391: Unit = Unit
// [KnfOpt]   let _7392: Tuple([Int, Int]) = Apply(stream.7388, [_7391, ])
// [KnfOpt]   let (ok.7393: Var({val: Some(Int)}), val.7394: Var({val: Some(Int)})) = _7392
// [KnfOpt]   let _7395: Int = Int(0)
// [KnfOpt]   if (ok.7393 == _7395) then {
// [KnfOpt]     let sum.104: Int = Var(acc.7390)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _7396: Int = Apply(f.7389, [acc.7390, val.7394, ])
// [KnfOpt]     Jump(fold.7387, [stream.7388, f.7389, _7396, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.7387, [under1200.103, add.7383, _7386, ])
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 5
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 0
// [KnfOpt] Inline decision le.83 accepted
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.7399: Int = (x.7400: Int, y.7401: Int) {
// [KnfOpt]   Add(x.7400, y.7401)
// [KnfOpt] }
// [KnfOpt] let _7402: Int = Int(0)
// [KnfOpt] let join fold.7403: Int = (stream.7404: Fun([Unit], Tuple([Int, Int])), f.7405: Fun([Int, Int], Int), acc.7406: Int) {
// [KnfOpt]   let _7407: Unit = Unit
// [KnfOpt]   let _7408: Tuple([Int, Int]) = Apply(stream.7404, [_7407, ])
// [KnfOpt]   let (ok.7409: Var({val: Some(Int)}), val.7410: Var({val: Some(Int)})) = _7408
// [KnfOpt]   let _7411: Int = Int(0)
// [KnfOpt]   if (ok.7409 == _7411) then {
// [KnfOpt]     let sum.104: Int = Var(acc.7406)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _7412: Int = Apply(f.7405, [acc.7406, val.7410, ])
// [KnfOpt]     Jump(fold.7403, [stream.7404, f.7405, _7412, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.7403, [under1200.103, add.7399, _7402, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(le) let _102: Fun([Int], Int) = Unit
// [KnfOpt] let rec aux.7413: Tuple([Int, Int]) = (u.7414: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.7415: Tuple([Int, Int]) = (u.7416: Var({val: Some(Unit)})) {
// [KnfOpt]     let _7417: Unit = Unit
// [KnfOpt]     let _7418: Tuple([Int, Int]) = Apply(over50.100, [_7417, ])
// [KnfOpt]     let (ok.7419: Var({val: Some(Int)}), val.7420: Var({val: Some(Int)})) = _7418
// [KnfOpt]     let _7421: Int = Int(0)
// [KnfOpt]     if (ok.7419 == _7421) then {
// [KnfOpt]       let _7422: Int = Int(0)
// [KnfOpt]       let _7423: Int = Int(0)
// [KnfOpt]       Tuple([_7422, _7423, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.7424: Int = Apply(_102, [val.7420, ])
// [KnfOpt]       let _7425: Int = Int(0)
// [KnfOpt]       if (r.7424 == _7425) then {
// [KnfOpt]         let _7426: Int = Int(1)
// [KnfOpt]         Tuple([_7426, val.7420, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _7427: Unit = Unit
// [KnfOpt]         Jump(aux.7415, [_7427, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.7415, [u.7414, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.7413)
// [KnfOpt] let rec add.7428: Int = (x.7429: Int, y.7430: Int) {
// [KnfOpt]   Add(x.7429, y.7430)
// [KnfOpt] }
// [KnfOpt] let _7431: Int = Int(0)
// [KnfOpt] let join fold.7432: Int = (stream.7433: Fun([Unit], Tuple([Int, Int])), f.7434: Fun([Int, Int], Int), acc.7435: Int) {
// [KnfOpt]   let _7436: Unit = Unit
// [KnfOpt]   let _7437: Tuple([Int, Int]) = Apply(stream.7433, [_7436, ])
// [KnfOpt]   let (ok.7438: Var({val: Some(Int)}), val.7439: Var({val: Some(Int)})) = _7437
// [KnfOpt]   let _7440: Int = Int(0)
// [KnfOpt]   if (ok.7438 == _7440) then {
// [KnfOpt]     let sum.104: Int = Var(acc.7435)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _7441: Int = Apply(f.7434, [acc.7435, val.7439, ])
// [KnfOpt]     Jump(fold.7432, [stream.7433, f.7434, _7441, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.7432, [under1200.103, add.7428, _7431, ])
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.7444: Int = (x.7445: Int, y.7446: Int) {
// [KnfOpt]   Add(x.7445, y.7446)
// [KnfOpt] }
// [KnfOpt] let _7447: Int = Int(0)
// [KnfOpt] let join fold.7448: Int = (stream.7449: Fun([Unit], Tuple([Int, Int])), f.7450: Fun([Int, Int], Int), acc.7451: Int) {
// [KnfOpt]   let _7452: Unit = Unit
// [KnfOpt]   let _7453: Tuple([Int, Int]) = Apply(stream.7449, [_7452, ])
// [KnfOpt]   let (ok.7454: Var({val: Some(Int)}), val.7455: Var({val: Some(Int)})) = _7453
// [KnfOpt]   let _7456: Int = Int(0)
// [KnfOpt]   if (ok.7454 == _7456) then {
// [KnfOpt]     let sum.104: Int = Var(acc.7451)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _7457: Int = Apply(f.7450, [acc.7451, val.7455, ])
// [KnfOpt]     Jump(fold.7448, [stream.7449, f.7450, _7457, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.7448, [under1200.103, add.7444, _7447, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let over50.100: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let _101: Int = Int(1200)
// [KnfOpt] let rec aux.7442: Int = (y.7443: Int) {
// [KnfOpt]   if (y.7443 <= _101) then {
// [KnfOpt]     Int(0)
// [KnfOpt]   } else {
// [KnfOpt]     Int(1)
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] let _102: Fun([Int], Int) = Var(aux.7442)
// [KnfOpt] let rec aux.7458: Tuple([Int, Int]) = (u.7459: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.7460: Tuple([Int, Int]) = (u.7461: Var({val: Some(Unit)})) {
// [KnfOpt]     let _7462: Unit = Unit
// [KnfOpt]     let _7463: Tuple([Int, Int]) = Apply(over50.100, [_7462, ])
// [KnfOpt]     let (ok.7464: Var({val: Some(Int)}), val.7465: Var({val: Some(Int)})) = _7463
// [KnfOpt]     let _7466: Int = Int(0)
// [KnfOpt]     if (ok.7464 == _7466) then {
// [KnfOpt]       let _7467: Int = Int(0)
// [KnfOpt]       let _7468: Int = Int(0)
// [KnfOpt]       Tuple([_7467, _7468, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.7469: Int = Apply(_102, [val.7465, ])
// [KnfOpt]       let _7470: Int = Int(0)
// [KnfOpt]       if (r.7469 == _7470) then {
// [KnfOpt]         let _7471: Int = Int(1)
// [KnfOpt]         Tuple([_7471, val.7465, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _7472: Unit = Unit
// [KnfOpt]         Jump(aux.7460, [_7472, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.7460, [u.7459, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.7458)
// [KnfOpt] let rec add.7473: Int = (x.7474: Int, y.7475: Int) {
// [KnfOpt]   Add(x.7474, y.7475)
// [KnfOpt] }
// [KnfOpt] let _7476: Int = Int(0)
// [KnfOpt] let join fold.7477: Int = (stream.7478: Fun([Unit], Tuple([Int, Int])), f.7479: Fun([Int, Int], Int), acc.7480: Int) {
// [KnfOpt]   let _7481: Unit = Unit
// [KnfOpt]   let _7482: Tuple([Int, Int]) = Apply(stream.7478, [_7481, ])
// [KnfOpt]   let (ok.7483: Var({val: Some(Int)}), val.7484: Var({val: Some(Int)})) = _7482
// [KnfOpt]   let _7485: Int = Int(0)
// [KnfOpt]   if (ok.7483 == _7485) then {
// [KnfOpt]     let sum.104: Int = Var(acc.7480)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _7486: Int = Apply(f.7479, [acc.7480, val.7484, ])
// [KnfOpt]     Jump(fold.7477, [stream.7478, f.7479, _7486, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.7477, [under1200.103, add.7473, _7476, ])
// [KnfOpt] Inline threshold 5
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 0
// [KnfOpt] Inline decision le.83 accepted
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.7502: Int = (x.7503: Int, y.7504: Int) {
// [KnfOpt]   Add(x.7503, y.7504)
// [KnfOpt] }
// [KnfOpt] let _7505: Int = Int(0)
// [KnfOpt] let join fold.7506: Int = (stream.7507: Fun([Unit], Tuple([Int, Int])), f.7508: Fun([Int, Int], Int), acc.7509: Int) {
// [KnfOpt]   let _7510: Unit = Unit
// [KnfOpt]   let _7511: Tuple([Int, Int]) = Apply(stream.7507, [_7510, ])
// [KnfOpt]   let (ok.7512: Var({val: Some(Int)}), val.7513: Var({val: Some(Int)})) = _7511
// [KnfOpt]   let _7514: Int = Int(0)
// [KnfOpt]   if (ok.7512 == _7514) then {
// [KnfOpt]     let sum.104: Int = Var(acc.7509)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _7515: Int = Apply(f.7508, [acc.7509, val.7513, ])
// [KnfOpt]     Jump(fold.7506, [stream.7507, f.7508, _7515, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.7506, [under1200.103, add.7502, _7505, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(le) let _102: Fun([Int], Int) = Unit
// [KnfOpt] let rec aux.7516: Tuple([Int, Int]) = (u.7517: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.7518: Tuple([Int, Int]) = (u.7519: Var({val: Some(Unit)})) {
// [KnfOpt]     let _7520: Unit = Unit
// [KnfOpt]     let _7521: Tuple([Int, Int]) = Apply(over50.100, [_7520, ])
// [KnfOpt]     let (ok.7522: Var({val: Some(Int)}), val.7523: Var({val: Some(Int)})) = _7521
// [KnfOpt]     let _7524: Int = Int(0)
// [KnfOpt]     if (ok.7522 == _7524) then {
// [KnfOpt]       let _7525: Int = Int(0)
// [KnfOpt]       let _7526: Int = Int(0)
// [KnfOpt]       Tuple([_7525, _7526, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.7527: Int = Apply(_102, [val.7523, ])
// [KnfOpt]       let _7528: Int = Int(0)
// [KnfOpt]       if (r.7527 == _7528) then {
// [KnfOpt]         let _7529: Int = Int(1)
// [KnfOpt]         Tuple([_7529, val.7523, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _7530: Unit = Unit
// [KnfOpt]         Jump(aux.7518, [_7530, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.7518, [u.7517, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.7516)
// [KnfOpt] let rec add.7531: Int = (x.7532: Int, y.7533: Int) {
// [KnfOpt]   Add(x.7532, y.7533)
// [KnfOpt] }
// [KnfOpt] let _7534: Int = Int(0)
// [KnfOpt] let join fold.7535: Int = (stream.7536: Fun([Unit], Tuple([Int, Int])), f.7537: Fun([Int, Int], Int), acc.7538: Int) {
// [KnfOpt]   let _7539: Unit = Unit
// [KnfOpt]   let _7540: Tuple([Int, Int]) = Apply(stream.7536, [_7539, ])
// [KnfOpt]   let (ok.7541: Var({val: Some(Int)}), val.7542: Var({val: Some(Int)})) = _7540
// [KnfOpt]   let _7543: Int = Int(0)
// [KnfOpt]   if (ok.7541 == _7543) then {
// [KnfOpt]     let sum.104: Int = Var(acc.7538)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _7544: Int = Apply(f.7537, [acc.7538, val.7542, ])
// [KnfOpt]     Jump(fold.7535, [stream.7536, f.7537, _7544, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.7535, [under1200.103, add.7531, _7534, ])
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.7547: Int = (x.7548: Int, y.7549: Int) {
// [KnfOpt]   Add(x.7548, y.7549)
// [KnfOpt] }
// [KnfOpt] let _7550: Int = Int(0)
// [KnfOpt] let join fold.7551: Int = (stream.7552: Fun([Unit], Tuple([Int, Int])), f.7553: Fun([Int, Int], Int), acc.7554: Int) {
// [KnfOpt]   let _7555: Unit = Unit
// [KnfOpt]   let _7556: Tuple([Int, Int]) = Apply(stream.7552, [_7555, ])
// [KnfOpt]   let (ok.7557: Var({val: Some(Int)}), val.7558: Var({val: Some(Int)})) = _7556
// [KnfOpt]   let _7559: Int = Int(0)
// [KnfOpt]   if (ok.7557 == _7559) then {
// [KnfOpt]     let sum.104: Int = Var(acc.7554)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _7560: Int = Apply(f.7553, [acc.7554, val.7558, ])
// [KnfOpt]     Jump(fold.7551, [stream.7552, f.7553, _7560, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.7551, [under1200.103, add.7547, _7550, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(map) let addone.97: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let _98: Int = Int(50)
// [KnfOpt] let rec aux.7397: Int = (y.7398: Int) {
// [KnfOpt]   if (_98 <= y.7398) then {
// [KnfOpt]     Int(0)
// [KnfOpt]   } else {
// [KnfOpt]     Int(1)
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] let _99: Fun([Int], Int) = Var(aux.7397)
// [KnfOpt] let rec aux.7487: Tuple([Int, Int]) = (u.7488: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.7489: Tuple([Int, Int]) = (u.7490: Var({val: Some(Unit)})) {
// [KnfOpt]     let _7491: Unit = Unit
// [KnfOpt]     let _7492: Tuple([Int, Int]) = Apply(addone.97, [_7491, ])
// [KnfOpt]     let (ok.7493: Var({val: Some(Int)}), val.7494: Var({val: Some(Int)})) = _7492
// [KnfOpt]     let _7495: Int = Int(0)
// [KnfOpt]     if (ok.7493 == _7495) then {
// [KnfOpt]       let _7496: Int = Int(0)
// [KnfOpt]       let _7497: Int = Int(0)
// [KnfOpt]       Tuple([_7496, _7497, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.7498: Int = Apply(_99, [val.7494, ])
// [KnfOpt]       let _7499: Int = Int(0)
// [KnfOpt]       if (r.7498 == _7499) then {
// [KnfOpt]         let _7500: Int = Int(1)
// [KnfOpt]         Tuple([_7500, val.7494, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _7501: Unit = Unit
// [KnfOpt]         Jump(aux.7489, [_7501, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.7489, [u.7488, ])
// [KnfOpt] }
// [KnfOpt] let over50.100: Fun([Unit], Tuple([Int, Int])) = Var(aux.7487)
// [KnfOpt] let _101: Int = Int(1200)
// [KnfOpt] let rec aux.7545: Int = (y.7546: Int) {
// [KnfOpt]   if (y.7546 <= _101) then {
// [KnfOpt]     Int(0)
// [KnfOpt]   } else {
// [KnfOpt]     Int(1)
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] let _102: Fun([Int], Int) = Var(aux.7545)
// [KnfOpt] let rec aux.7561: Tuple([Int, Int]) = (u.7562: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.7563: Tuple([Int, Int]) = (u.7564: Var({val: Some(Unit)})) {
// [KnfOpt]     let _7565: Unit = Unit
// [KnfOpt]     let _7566: Tuple([Int, Int]) = Apply(over50.100, [_7565, ])
// [KnfOpt]     let (ok.7567: Var({val: Some(Int)}), val.7568: Var({val: Some(Int)})) = _7566
// [KnfOpt]     let _7569: Int = Int(0)
// [KnfOpt]     if (ok.7567 == _7569) then {
// [KnfOpt]       let _7570: Int = Int(0)
// [KnfOpt]       let _7571: Int = Int(0)
// [KnfOpt]       Tuple([_7570, _7571, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.7572: Int = Apply(_102, [val.7568, ])
// [KnfOpt]       let _7573: Int = Int(0)
// [KnfOpt]       if (r.7572 == _7573) then {
// [KnfOpt]         let _7574: Int = Int(1)
// [KnfOpt]         Tuple([_7574, val.7568, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _7575: Unit = Unit
// [KnfOpt]         Jump(aux.7563, [_7575, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.7563, [u.7562, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.7561)
// [KnfOpt] let rec add.7576: Int = (x.7577: Int, y.7578: Int) {
// [KnfOpt]   Add(x.7577, y.7578)
// [KnfOpt] }
// [KnfOpt] let _7579: Int = Int(0)
// [KnfOpt] let join fold.7580: Int = (stream.7581: Fun([Unit], Tuple([Int, Int])), f.7582: Fun([Int, Int], Int), acc.7583: Int) {
// [KnfOpt]   let _7584: Unit = Unit
// [KnfOpt]   let _7585: Tuple([Int, Int]) = Apply(stream.7581, [_7584, ])
// [KnfOpt]   let (ok.7586: Var({val: Some(Int)}), val.7587: Var({val: Some(Int)})) = _7585
// [KnfOpt]   let _7588: Int = Int(0)
// [KnfOpt]   if (ok.7586 == _7588) then {
// [KnfOpt]     let sum.104: Int = Var(acc.7583)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _7589: Int = Apply(f.7582, [acc.7583, val.7587, ])
// [KnfOpt]     Jump(fold.7580, [stream.7581, f.7582, _7589, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.7580, [under1200.103, add.7576, _7579, ])
// [KnfOpt] Inline threshold 5
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 0
// [KnfOpt] Inline decision gt.79 accepted
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 5
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 0
// [KnfOpt] Inline decision le.83 accepted
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.7601: Int = (x.7602: Int, y.7603: Int) {
// [KnfOpt]   Add(x.7602, y.7603)
// [KnfOpt] }
// [KnfOpt] let _7604: Int = Int(0)
// [KnfOpt] let join fold.7605: Int = (stream.7606: Fun([Unit], Tuple([Int, Int])), f.7607: Fun([Int, Int], Int), acc.7608: Int) {
// [KnfOpt]   let _7609: Unit = Unit
// [KnfOpt]   let _7610: Tuple([Int, Int]) = Apply(stream.7606, [_7609, ])
// [KnfOpt]   let (ok.7611: Var({val: Some(Int)}), val.7612: Var({val: Some(Int)})) = _7610
// [KnfOpt]   let _7613: Int = Int(0)
// [KnfOpt]   if (ok.7611 == _7613) then {
// [KnfOpt]     let sum.104: Int = Var(acc.7608)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _7614: Int = Apply(f.7607, [acc.7608, val.7612, ])
// [KnfOpt]     Jump(fold.7605, [stream.7606, f.7607, _7614, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.7605, [under1200.103, add.7601, _7604, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(le) let _102: Fun([Int], Int) = Unit
// [KnfOpt] let rec aux.7615: Tuple([Int, Int]) = (u.7616: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.7617: Tuple([Int, Int]) = (u.7618: Var({val: Some(Unit)})) {
// [KnfOpt]     let _7619: Unit = Unit
// [KnfOpt]     let _7620: Tuple([Int, Int]) = Apply(over50.100, [_7619, ])
// [KnfOpt]     let (ok.7621: Var({val: Some(Int)}), val.7622: Var({val: Some(Int)})) = _7620
// [KnfOpt]     let _7623: Int = Int(0)
// [KnfOpt]     if (ok.7621 == _7623) then {
// [KnfOpt]       let _7624: Int = Int(0)
// [KnfOpt]       let _7625: Int = Int(0)
// [KnfOpt]       Tuple([_7624, _7625, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.7626: Int = Apply(_102, [val.7622, ])
// [KnfOpt]       let _7627: Int = Int(0)
// [KnfOpt]       if (r.7626 == _7627) then {
// [KnfOpt]         let _7628: Int = Int(1)
// [KnfOpt]         Tuple([_7628, val.7622, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _7629: Unit = Unit
// [KnfOpt]         Jump(aux.7617, [_7629, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.7617, [u.7616, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.7615)
// [KnfOpt] let rec add.7630: Int = (x.7631: Int, y.7632: Int) {
// [KnfOpt]   Add(x.7631, y.7632)
// [KnfOpt] }
// [KnfOpt] let _7633: Int = Int(0)
// [KnfOpt] let join fold.7634: Int = (stream.7635: Fun([Unit], Tuple([Int, Int])), f.7636: Fun([Int, Int], Int), acc.7637: Int) {
// [KnfOpt]   let _7638: Unit = Unit
// [KnfOpt]   let _7639: Tuple([Int, Int]) = Apply(stream.7635, [_7638, ])
// [KnfOpt]   let (ok.7640: Var({val: Some(Int)}), val.7641: Var({val: Some(Int)})) = _7639
// [KnfOpt]   let _7642: Int = Int(0)
// [KnfOpt]   if (ok.7640 == _7642) then {
// [KnfOpt]     let sum.104: Int = Var(acc.7637)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _7643: Int = Apply(f.7636, [acc.7637, val.7641, ])
// [KnfOpt]     Jump(fold.7634, [stream.7635, f.7636, _7643, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.7634, [under1200.103, add.7630, _7633, ])
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.7646: Int = (x.7647: Int, y.7648: Int) {
// [KnfOpt]   Add(x.7647, y.7648)
// [KnfOpt] }
// [KnfOpt] let _7649: Int = Int(0)
// [KnfOpt] let join fold.7650: Int = (stream.7651: Fun([Unit], Tuple([Int, Int])), f.7652: Fun([Int, Int], Int), acc.7653: Int) {
// [KnfOpt]   let _7654: Unit = Unit
// [KnfOpt]   let _7655: Tuple([Int, Int]) = Apply(stream.7651, [_7654, ])
// [KnfOpt]   let (ok.7656: Var({val: Some(Int)}), val.7657: Var({val: Some(Int)})) = _7655
// [KnfOpt]   let _7658: Int = Int(0)
// [KnfOpt]   if (ok.7656 == _7658) then {
// [KnfOpt]     let sum.104: Int = Var(acc.7653)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _7659: Int = Apply(f.7652, [acc.7653, val.7657, ])
// [KnfOpt]     Jump(fold.7650, [stream.7651, f.7652, _7659, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.7650, [under1200.103, add.7646, _7649, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let over50.100: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let _101: Int = Int(1200)
// [KnfOpt] let rec aux.7644: Int = (y.7645: Int) {
// [KnfOpt]   if (y.7645 <= _101) then {
// [KnfOpt]     Int(0)
// [KnfOpt]   } else {
// [KnfOpt]     Int(1)
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] let _102: Fun([Int], Int) = Var(aux.7644)
// [KnfOpt] let rec aux.7660: Tuple([Int, Int]) = (u.7661: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.7662: Tuple([Int, Int]) = (u.7663: Var({val: Some(Unit)})) {
// [KnfOpt]     let _7664: Unit = Unit
// [KnfOpt]     let _7665: Tuple([Int, Int]) = Apply(over50.100, [_7664, ])
// [KnfOpt]     let (ok.7666: Var({val: Some(Int)}), val.7667: Var({val: Some(Int)})) = _7665
// [KnfOpt]     let _7668: Int = Int(0)
// [KnfOpt]     if (ok.7666 == _7668) then {
// [KnfOpt]       let _7669: Int = Int(0)
// [KnfOpt]       let _7670: Int = Int(0)
// [KnfOpt]       Tuple([_7669, _7670, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.7671: Int = Apply(_102, [val.7667, ])
// [KnfOpt]       let _7672: Int = Int(0)
// [KnfOpt]       if (r.7671 == _7672) then {
// [KnfOpt]         let _7673: Int = Int(1)
// [KnfOpt]         Tuple([_7673, val.7667, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _7674: Unit = Unit
// [KnfOpt]         Jump(aux.7662, [_7674, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.7662, [u.7661, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.7660)
// [KnfOpt] let rec add.7675: Int = (x.7676: Int, y.7677: Int) {
// [KnfOpt]   Add(x.7676, y.7677)
// [KnfOpt] }
// [KnfOpt] let _7678: Int = Int(0)
// [KnfOpt] let join fold.7679: Int = (stream.7680: Fun([Unit], Tuple([Int, Int])), f.7681: Fun([Int, Int], Int), acc.7682: Int) {
// [KnfOpt]   let _7683: Unit = Unit
// [KnfOpt]   let _7684: Tuple([Int, Int]) = Apply(stream.7680, [_7683, ])
// [KnfOpt]   let (ok.7685: Var({val: Some(Int)}), val.7686: Var({val: Some(Int)})) = _7684
// [KnfOpt]   let _7687: Int = Int(0)
// [KnfOpt]   if (ok.7685 == _7687) then {
// [KnfOpt]     let sum.104: Int = Var(acc.7682)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _7688: Int = Apply(f.7681, [acc.7682, val.7686, ])
// [KnfOpt]     Jump(fold.7679, [stream.7680, f.7681, _7688, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.7679, [under1200.103, add.7675, _7678, ])
// [KnfOpt] Inline threshold 5
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 0
// [KnfOpt] Inline decision le.83 accepted
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.7704: Int = (x.7705: Int, y.7706: Int) {
// [KnfOpt]   Add(x.7705, y.7706)
// [KnfOpt] }
// [KnfOpt] let _7707: Int = Int(0)
// [KnfOpt] let join fold.7708: Int = (stream.7709: Fun([Unit], Tuple([Int, Int])), f.7710: Fun([Int, Int], Int), acc.7711: Int) {
// [KnfOpt]   let _7712: Unit = Unit
// [KnfOpt]   let _7713: Tuple([Int, Int]) = Apply(stream.7709, [_7712, ])
// [KnfOpt]   let (ok.7714: Var({val: Some(Int)}), val.7715: Var({val: Some(Int)})) = _7713
// [KnfOpt]   let _7716: Int = Int(0)
// [KnfOpt]   if (ok.7714 == _7716) then {
// [KnfOpt]     let sum.104: Int = Var(acc.7711)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _7717: Int = Apply(f.7710, [acc.7711, val.7715, ])
// [KnfOpt]     Jump(fold.7708, [stream.7709, f.7710, _7717, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.7708, [under1200.103, add.7704, _7707, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(le) let _102: Fun([Int], Int) = Unit
// [KnfOpt] let rec aux.7718: Tuple([Int, Int]) = (u.7719: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.7720: Tuple([Int, Int]) = (u.7721: Var({val: Some(Unit)})) {
// [KnfOpt]     let _7722: Unit = Unit
// [KnfOpt]     let _7723: Tuple([Int, Int]) = Apply(over50.100, [_7722, ])
// [KnfOpt]     let (ok.7724: Var({val: Some(Int)}), val.7725: Var({val: Some(Int)})) = _7723
// [KnfOpt]     let _7726: Int = Int(0)
// [KnfOpt]     if (ok.7724 == _7726) then {
// [KnfOpt]       let _7727: Int = Int(0)
// [KnfOpt]       let _7728: Int = Int(0)
// [KnfOpt]       Tuple([_7727, _7728, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.7729: Int = Apply(_102, [val.7725, ])
// [KnfOpt]       let _7730: Int = Int(0)
// [KnfOpt]       if (r.7729 == _7730) then {
// [KnfOpt]         let _7731: Int = Int(1)
// [KnfOpt]         Tuple([_7731, val.7725, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _7732: Unit = Unit
// [KnfOpt]         Jump(aux.7720, [_7732, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.7720, [u.7719, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.7718)
// [KnfOpt] let rec add.7733: Int = (x.7734: Int, y.7735: Int) {
// [KnfOpt]   Add(x.7734, y.7735)
// [KnfOpt] }
// [KnfOpt] let _7736: Int = Int(0)
// [KnfOpt] let join fold.7737: Int = (stream.7738: Fun([Unit], Tuple([Int, Int])), f.7739: Fun([Int, Int], Int), acc.7740: Int) {
// [KnfOpt]   let _7741: Unit = Unit
// [KnfOpt]   let _7742: Tuple([Int, Int]) = Apply(stream.7738, [_7741, ])
// [KnfOpt]   let (ok.7743: Var({val: Some(Int)}), val.7744: Var({val: Some(Int)})) = _7742
// [KnfOpt]   let _7745: Int = Int(0)
// [KnfOpt]   if (ok.7743 == _7745) then {
// [KnfOpt]     let sum.104: Int = Var(acc.7740)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _7746: Int = Apply(f.7739, [acc.7740, val.7744, ])
// [KnfOpt]     Jump(fold.7737, [stream.7738, f.7739, _7746, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.7737, [under1200.103, add.7733, _7736, ])
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.7749: Int = (x.7750: Int, y.7751: Int) {
// [KnfOpt]   Add(x.7750, y.7751)
// [KnfOpt] }
// [KnfOpt] let _7752: Int = Int(0)
// [KnfOpt] let join fold.7753: Int = (stream.7754: Fun([Unit], Tuple([Int, Int])), f.7755: Fun([Int, Int], Int), acc.7756: Int) {
// [KnfOpt]   let _7757: Unit = Unit
// [KnfOpt]   let _7758: Tuple([Int, Int]) = Apply(stream.7754, [_7757, ])
// [KnfOpt]   let (ok.7759: Var({val: Some(Int)}), val.7760: Var({val: Some(Int)})) = _7758
// [KnfOpt]   let _7761: Int = Int(0)
// [KnfOpt]   if (ok.7759 == _7761) then {
// [KnfOpt]     let sum.104: Int = Var(acc.7756)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _7762: Int = Apply(f.7755, [acc.7756, val.7760, ])
// [KnfOpt]     Jump(fold.7753, [stream.7754, f.7755, _7762, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.7753, [under1200.103, add.7749, _7752, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(gt) let _99: Fun([Int], Int) = Unit
// [KnfOpt] let rec aux.7689: Tuple([Int, Int]) = (u.7690: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.7691: Tuple([Int, Int]) = (u.7692: Var({val: Some(Unit)})) {
// [KnfOpt]     let _7693: Unit = Unit
// [KnfOpt]     let _7694: Tuple([Int, Int]) = Apply(addone.97, [_7693, ])
// [KnfOpt]     let (ok.7695: Var({val: Some(Int)}), val.7696: Var({val: Some(Int)})) = _7694
// [KnfOpt]     let _7697: Int = Int(0)
// [KnfOpt]     if (ok.7695 == _7697) then {
// [KnfOpt]       let _7698: Int = Int(0)
// [KnfOpt]       let _7699: Int = Int(0)
// [KnfOpt]       Tuple([_7698, _7699, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.7700: Int = Apply(_99, [val.7696, ])
// [KnfOpt]       let _7701: Int = Int(0)
// [KnfOpt]       if (r.7700 == _7701) then {
// [KnfOpt]         let _7702: Int = Int(1)
// [KnfOpt]         Tuple([_7702, val.7696, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _7703: Unit = Unit
// [KnfOpt]         Jump(aux.7691, [_7703, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.7691, [u.7690, ])
// [KnfOpt] }
// [KnfOpt] let over50.100: Fun([Unit], Tuple([Int, Int])) = Var(aux.7689)
// [KnfOpt] let _101: Int = Int(1200)
// [KnfOpt] let rec aux.7747: Int = (y.7748: Int) {
// [KnfOpt]   if (y.7748 <= _101) then {
// [KnfOpt]     Int(0)
// [KnfOpt]   } else {
// [KnfOpt]     Int(1)
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] let _102: Fun([Int], Int) = Var(aux.7747)
// [KnfOpt] let rec aux.7763: Tuple([Int, Int]) = (u.7764: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.7765: Tuple([Int, Int]) = (u.7766: Var({val: Some(Unit)})) {
// [KnfOpt]     let _7767: Unit = Unit
// [KnfOpt]     let _7768: Tuple([Int, Int]) = Apply(over50.100, [_7767, ])
// [KnfOpt]     let (ok.7769: Var({val: Some(Int)}), val.7770: Var({val: Some(Int)})) = _7768
// [KnfOpt]     let _7771: Int = Int(0)
// [KnfOpt]     if (ok.7769 == _7771) then {
// [KnfOpt]       let _7772: Int = Int(0)
// [KnfOpt]       let _7773: Int = Int(0)
// [KnfOpt]       Tuple([_7772, _7773, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.7774: Int = Apply(_102, [val.7770, ])
// [KnfOpt]       let _7775: Int = Int(0)
// [KnfOpt]       if (r.7774 == _7775) then {
// [KnfOpt]         let _7776: Int = Int(1)
// [KnfOpt]         Tuple([_7776, val.7770, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _7777: Unit = Unit
// [KnfOpt]         Jump(aux.7765, [_7777, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.7765, [u.7764, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.7763)
// [KnfOpt] let rec add.7778: Int = (x.7779: Int, y.7780: Int) {
// [KnfOpt]   Add(x.7779, y.7780)
// [KnfOpt] }
// [KnfOpt] let _7781: Int = Int(0)
// [KnfOpt] let join fold.7782: Int = (stream.7783: Fun([Unit], Tuple([Int, Int])), f.7784: Fun([Int, Int], Int), acc.7785: Int) {
// [KnfOpt]   let _7786: Unit = Unit
// [KnfOpt]   let _7787: Tuple([Int, Int]) = Apply(stream.7783, [_7786, ])
// [KnfOpt]   let (ok.7788: Var({val: Some(Int)}), val.7789: Var({val: Some(Int)})) = _7787
// [KnfOpt]   let _7790: Int = Int(0)
// [KnfOpt]   if (ok.7788 == _7790) then {
// [KnfOpt]     let sum.104: Int = Var(acc.7785)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _7791: Int = Apply(f.7784, [acc.7785, val.7789, ])
// [KnfOpt]     Jump(fold.7782, [stream.7783, f.7784, _7791, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.7782, [under1200.103, add.7778, _7781, ])
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 5
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 0
// [KnfOpt] Inline decision le.83 accepted
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.7794: Int = (x.7795: Int, y.7796: Int) {
// [KnfOpt]   Add(x.7795, y.7796)
// [KnfOpt] }
// [KnfOpt] let _7797: Int = Int(0)
// [KnfOpt] let join fold.7798: Int = (stream.7799: Fun([Unit], Tuple([Int, Int])), f.7800: Fun([Int, Int], Int), acc.7801: Int) {
// [KnfOpt]   let _7802: Unit = Unit
// [KnfOpt]   let _7803: Tuple([Int, Int]) = Apply(stream.7799, [_7802, ])
// [KnfOpt]   let (ok.7804: Var({val: Some(Int)}), val.7805: Var({val: Some(Int)})) = _7803
// [KnfOpt]   let _7806: Int = Int(0)
// [KnfOpt]   if (ok.7804 == _7806) then {
// [KnfOpt]     let sum.104: Int = Var(acc.7801)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _7807: Int = Apply(f.7800, [acc.7801, val.7805, ])
// [KnfOpt]     Jump(fold.7798, [stream.7799, f.7800, _7807, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.7798, [under1200.103, add.7794, _7797, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(le) let _102: Fun([Int], Int) = Unit
// [KnfOpt] let rec aux.7808: Tuple([Int, Int]) = (u.7809: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.7810: Tuple([Int, Int]) = (u.7811: Var({val: Some(Unit)})) {
// [KnfOpt]     let _7812: Unit = Unit
// [KnfOpt]     let _7813: Tuple([Int, Int]) = Apply(over50.100, [_7812, ])
// [KnfOpt]     let (ok.7814: Var({val: Some(Int)}), val.7815: Var({val: Some(Int)})) = _7813
// [KnfOpt]     let _7816: Int = Int(0)
// [KnfOpt]     if (ok.7814 == _7816) then {
// [KnfOpt]       let _7817: Int = Int(0)
// [KnfOpt]       let _7818: Int = Int(0)
// [KnfOpt]       Tuple([_7817, _7818, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.7819: Int = Apply(_102, [val.7815, ])
// [KnfOpt]       let _7820: Int = Int(0)
// [KnfOpt]       if (r.7819 == _7820) then {
// [KnfOpt]         let _7821: Int = Int(1)
// [KnfOpt]         Tuple([_7821, val.7815, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _7822: Unit = Unit
// [KnfOpt]         Jump(aux.7810, [_7822, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.7810, [u.7809, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.7808)
// [KnfOpt] let rec add.7823: Int = (x.7824: Int, y.7825: Int) {
// [KnfOpt]   Add(x.7824, y.7825)
// [KnfOpt] }
// [KnfOpt] let _7826: Int = Int(0)
// [KnfOpt] let join fold.7827: Int = (stream.7828: Fun([Unit], Tuple([Int, Int])), f.7829: Fun([Int, Int], Int), acc.7830: Int) {
// [KnfOpt]   let _7831: Unit = Unit
// [KnfOpt]   let _7832: Tuple([Int, Int]) = Apply(stream.7828, [_7831, ])
// [KnfOpt]   let (ok.7833: Var({val: Some(Int)}), val.7834: Var({val: Some(Int)})) = _7832
// [KnfOpt]   let _7835: Int = Int(0)
// [KnfOpt]   if (ok.7833 == _7835) then {
// [KnfOpt]     let sum.104: Int = Var(acc.7830)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _7836: Int = Apply(f.7829, [acc.7830, val.7834, ])
// [KnfOpt]     Jump(fold.7827, [stream.7828, f.7829, _7836, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.7827, [under1200.103, add.7823, _7826, ])
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.7839: Int = (x.7840: Int, y.7841: Int) {
// [KnfOpt]   Add(x.7840, y.7841)
// [KnfOpt] }
// [KnfOpt] let _7842: Int = Int(0)
// [KnfOpt] let join fold.7843: Int = (stream.7844: Fun([Unit], Tuple([Int, Int])), f.7845: Fun([Int, Int], Int), acc.7846: Int) {
// [KnfOpt]   let _7847: Unit = Unit
// [KnfOpt]   let _7848: Tuple([Int, Int]) = Apply(stream.7844, [_7847, ])
// [KnfOpt]   let (ok.7849: Var({val: Some(Int)}), val.7850: Var({val: Some(Int)})) = _7848
// [KnfOpt]   let _7851: Int = Int(0)
// [KnfOpt]   if (ok.7849 == _7851) then {
// [KnfOpt]     let sum.104: Int = Var(acc.7846)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _7852: Int = Apply(f.7845, [acc.7846, val.7850, ])
// [KnfOpt]     Jump(fold.7843, [stream.7844, f.7845, _7852, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.7843, [under1200.103, add.7839, _7842, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let over50.100: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let _101: Int = Int(1200)
// [KnfOpt] let rec aux.7837: Int = (y.7838: Int) {
// [KnfOpt]   if (y.7838 <= _101) then {
// [KnfOpt]     Int(0)
// [KnfOpt]   } else {
// [KnfOpt]     Int(1)
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] let _102: Fun([Int], Int) = Var(aux.7837)
// [KnfOpt] let rec aux.7853: Tuple([Int, Int]) = (u.7854: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.7855: Tuple([Int, Int]) = (u.7856: Var({val: Some(Unit)})) {
// [KnfOpt]     let _7857: Unit = Unit
// [KnfOpt]     let _7858: Tuple([Int, Int]) = Apply(over50.100, [_7857, ])
// [KnfOpt]     let (ok.7859: Var({val: Some(Int)}), val.7860: Var({val: Some(Int)})) = _7858
// [KnfOpt]     let _7861: Int = Int(0)
// [KnfOpt]     if (ok.7859 == _7861) then {
// [KnfOpt]       let _7862: Int = Int(0)
// [KnfOpt]       let _7863: Int = Int(0)
// [KnfOpt]       Tuple([_7862, _7863, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.7864: Int = Apply(_102, [val.7860, ])
// [KnfOpt]       let _7865: Int = Int(0)
// [KnfOpt]       if (r.7864 == _7865) then {
// [KnfOpt]         let _7866: Int = Int(1)
// [KnfOpt]         Tuple([_7866, val.7860, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _7867: Unit = Unit
// [KnfOpt]         Jump(aux.7855, [_7867, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.7855, [u.7854, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.7853)
// [KnfOpt] let rec add.7868: Int = (x.7869: Int, y.7870: Int) {
// [KnfOpt]   Add(x.7869, y.7870)
// [KnfOpt] }
// [KnfOpt] let _7871: Int = Int(0)
// [KnfOpt] let join fold.7872: Int = (stream.7873: Fun([Unit], Tuple([Int, Int])), f.7874: Fun([Int, Int], Int), acc.7875: Int) {
// [KnfOpt]   let _7876: Unit = Unit
// [KnfOpt]   let _7877: Tuple([Int, Int]) = Apply(stream.7873, [_7876, ])
// [KnfOpt]   let (ok.7878: Var({val: Some(Int)}), val.7879: Var({val: Some(Int)})) = _7877
// [KnfOpt]   let _7880: Int = Int(0)
// [KnfOpt]   if (ok.7878 == _7880) then {
// [KnfOpt]     let sum.104: Int = Var(acc.7875)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _7881: Int = Apply(f.7874, [acc.7875, val.7879, ])
// [KnfOpt]     Jump(fold.7872, [stream.7873, f.7874, _7881, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.7872, [under1200.103, add.7868, _7871, ])
// [KnfOpt] Inline threshold 5
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 0
// [KnfOpt] Inline decision le.83 accepted
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.7897: Int = (x.7898: Int, y.7899: Int) {
// [KnfOpt]   Add(x.7898, y.7899)
// [KnfOpt] }
// [KnfOpt] let _7900: Int = Int(0)
// [KnfOpt] let join fold.7901: Int = (stream.7902: Fun([Unit], Tuple([Int, Int])), f.7903: Fun([Int, Int], Int), acc.7904: Int) {
// [KnfOpt]   let _7905: Unit = Unit
// [KnfOpt]   let _7906: Tuple([Int, Int]) = Apply(stream.7902, [_7905, ])
// [KnfOpt]   let (ok.7907: Var({val: Some(Int)}), val.7908: Var({val: Some(Int)})) = _7906
// [KnfOpt]   let _7909: Int = Int(0)
// [KnfOpt]   if (ok.7907 == _7909) then {
// [KnfOpt]     let sum.104: Int = Var(acc.7904)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _7910: Int = Apply(f.7903, [acc.7904, val.7908, ])
// [KnfOpt]     Jump(fold.7901, [stream.7902, f.7903, _7910, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.7901, [under1200.103, add.7897, _7900, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(le) let _102: Fun([Int], Int) = Unit
// [KnfOpt] let rec aux.7911: Tuple([Int, Int]) = (u.7912: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.7913: Tuple([Int, Int]) = (u.7914: Var({val: Some(Unit)})) {
// [KnfOpt]     let _7915: Unit = Unit
// [KnfOpt]     let _7916: Tuple([Int, Int]) = Apply(over50.100, [_7915, ])
// [KnfOpt]     let (ok.7917: Var({val: Some(Int)}), val.7918: Var({val: Some(Int)})) = _7916
// [KnfOpt]     let _7919: Int = Int(0)
// [KnfOpt]     if (ok.7917 == _7919) then {
// [KnfOpt]       let _7920: Int = Int(0)
// [KnfOpt]       let _7921: Int = Int(0)
// [KnfOpt]       Tuple([_7920, _7921, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.7922: Int = Apply(_102, [val.7918, ])
// [KnfOpt]       let _7923: Int = Int(0)
// [KnfOpt]       if (r.7922 == _7923) then {
// [KnfOpt]         let _7924: Int = Int(1)
// [KnfOpt]         Tuple([_7924, val.7918, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _7925: Unit = Unit
// [KnfOpt]         Jump(aux.7913, [_7925, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.7913, [u.7912, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.7911)
// [KnfOpt] let rec add.7926: Int = (x.7927: Int, y.7928: Int) {
// [KnfOpt]   Add(x.7927, y.7928)
// [KnfOpt] }
// [KnfOpt] let _7929: Int = Int(0)
// [KnfOpt] let join fold.7930: Int = (stream.7931: Fun([Unit], Tuple([Int, Int])), f.7932: Fun([Int, Int], Int), acc.7933: Int) {
// [KnfOpt]   let _7934: Unit = Unit
// [KnfOpt]   let _7935: Tuple([Int, Int]) = Apply(stream.7931, [_7934, ])
// [KnfOpt]   let (ok.7936: Var({val: Some(Int)}), val.7937: Var({val: Some(Int)})) = _7935
// [KnfOpt]   let _7938: Int = Int(0)
// [KnfOpt]   if (ok.7936 == _7938) then {
// [KnfOpt]     let sum.104: Int = Var(acc.7933)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _7939: Int = Apply(f.7932, [acc.7933, val.7937, ])
// [KnfOpt]     Jump(fold.7930, [stream.7931, f.7932, _7939, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.7930, [under1200.103, add.7926, _7929, ])
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.7942: Int = (x.7943: Int, y.7944: Int) {
// [KnfOpt]   Add(x.7943, y.7944)
// [KnfOpt] }
// [KnfOpt] let _7945: Int = Int(0)
// [KnfOpt] let join fold.7946: Int = (stream.7947: Fun([Unit], Tuple([Int, Int])), f.7948: Fun([Int, Int], Int), acc.7949: Int) {
// [KnfOpt]   let _7950: Unit = Unit
// [KnfOpt]   let _7951: Tuple([Int, Int]) = Apply(stream.7947, [_7950, ])
// [KnfOpt]   let (ok.7952: Var({val: Some(Int)}), val.7953: Var({val: Some(Int)})) = _7951
// [KnfOpt]   let _7954: Int = Int(0)
// [KnfOpt]   if (ok.7952 == _7954) then {
// [KnfOpt]     let sum.104: Int = Var(acc.7949)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _7955: Int = Apply(f.7948, [acc.7949, val.7953, ])
// [KnfOpt]     Jump(fold.7946, [stream.7947, f.7948, _7955, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.7946, [under1200.103, add.7942, _7945, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(concat) let catt.94: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let _95: Int = Int(1)
// [KnfOpt] let rec aux.7204: Int = (y.7205: Int) {
// [KnfOpt]   Add(_95, y.7205)
// [KnfOpt] }
// [KnfOpt] let _96: Fun([Int], Int) = Var(aux.7204)
// [KnfOpt] let rec aux.7590: Tuple([Int, Int]) = (u.7591: Var({val: Some(Unit)})) {
// [KnfOpt]   let _7592: Unit = Unit
// [KnfOpt]   let _7593: Tuple([Int, Int]) = Apply(catt.94, [_7592, ])
// [KnfOpt]   let (ok.7594: Var({val: Some(Int)}), val.7595: Var({val: Some(Int)})) = _7593
// [KnfOpt]   let _7596: Int = Int(0)
// [KnfOpt]   if (ok.7594 == _7596) then {
// [KnfOpt]     let _7597: Int = Int(0)
// [KnfOpt]     let _7598: Int = Int(0)
// [KnfOpt]     Tuple([_7597, _7598, ])
// [KnfOpt]   } else {
// [KnfOpt]     let _7599: Int = Int(1)
// [KnfOpt]     let _7600: Int = Apply(_96, [val.7595, ])
// [KnfOpt]     Tuple([_7599, _7600, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] let addone.97: Fun([Unit], Tuple([Int, Int])) = Var(aux.7590)
// [KnfOpt] let _98: Int = Int(50)
// [KnfOpt] let rec aux.7792: Int = (y.7793: Int) {
// [KnfOpt]   if (_98 <= y.7793) then {
// [KnfOpt]     Int(0)
// [KnfOpt]   } else {
// [KnfOpt]     Int(1)
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] let _99: Fun([Int], Int) = Var(aux.7792)
// [KnfOpt] let rec aux.7882: Tuple([Int, Int]) = (u.7883: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.7884: Tuple([Int, Int]) = (u.7885: Var({val: Some(Unit)})) {
// [KnfOpt]     let _7886: Unit = Unit
// [KnfOpt]     let _7887: Tuple([Int, Int]) = Apply(addone.97, [_7886, ])
// [KnfOpt]     let (ok.7888: Var({val: Some(Int)}), val.7889: Var({val: Some(Int)})) = _7887
// [KnfOpt]     let _7890: Int = Int(0)
// [KnfOpt]     if (ok.7888 == _7890) then {
// [KnfOpt]       let _7891: Int = Int(0)
// [KnfOpt]       let _7892: Int = Int(0)
// [KnfOpt]       Tuple([_7891, _7892, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.7893: Int = Apply(_99, [val.7889, ])
// [KnfOpt]       let _7894: Int = Int(0)
// [KnfOpt]       if (r.7893 == _7894) then {
// [KnfOpt]         let _7895: Int = Int(1)
// [KnfOpt]         Tuple([_7895, val.7889, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _7896: Unit = Unit
// [KnfOpt]         Jump(aux.7884, [_7896, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.7884, [u.7883, ])
// [KnfOpt] }
// [KnfOpt] let over50.100: Fun([Unit], Tuple([Int, Int])) = Var(aux.7882)
// [KnfOpt] let _101: Int = Int(1200)
// [KnfOpt] let rec aux.7940: Int = (y.7941: Int) {
// [KnfOpt]   if (y.7941 <= _101) then {
// [KnfOpt]     Int(0)
// [KnfOpt]   } else {
// [KnfOpt]     Int(1)
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] let _102: Fun([Int], Int) = Var(aux.7940)
// [KnfOpt] let rec aux.7956: Tuple([Int, Int]) = (u.7957: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.7958: Tuple([Int, Int]) = (u.7959: Var({val: Some(Unit)})) {
// [KnfOpt]     let _7960: Unit = Unit
// [KnfOpt]     let _7961: Tuple([Int, Int]) = Apply(over50.100, [_7960, ])
// [KnfOpt]     let (ok.7962: Var({val: Some(Int)}), val.7963: Var({val: Some(Int)})) = _7961
// [KnfOpt]     let _7964: Int = Int(0)
// [KnfOpt]     if (ok.7962 == _7964) then {
// [KnfOpt]       let _7965: Int = Int(0)
// [KnfOpt]       let _7966: Int = Int(0)
// [KnfOpt]       Tuple([_7965, _7966, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.7967: Int = Apply(_102, [val.7963, ])
// [KnfOpt]       let _7968: Int = Int(0)
// [KnfOpt]       if (r.7967 == _7968) then {
// [KnfOpt]         let _7969: Int = Int(1)
// [KnfOpt]         Tuple([_7969, val.7963, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _7970: Unit = Unit
// [KnfOpt]         Jump(aux.7958, [_7970, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.7958, [u.7957, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.7956)
// [KnfOpt] let rec add.7971: Int = (x.7972: Int, y.7973: Int) {
// [KnfOpt]   Add(x.7972, y.7973)
// [KnfOpt] }
// [KnfOpt] let _7974: Int = Int(0)
// [KnfOpt] let join fold.7975: Int = (stream.7976: Fun([Unit], Tuple([Int, Int])), f.7977: Fun([Int, Int], Int), acc.7978: Int) {
// [KnfOpt]   let _7979: Unit = Unit
// [KnfOpt]   let _7980: Tuple([Int, Int]) = Apply(stream.7976, [_7979, ])
// [KnfOpt]   let (ok.7981: Var({val: Some(Int)}), val.7982: Var({val: Some(Int)})) = _7980
// [KnfOpt]   let _7983: Int = Int(0)
// [KnfOpt]   if (ok.7981 == _7983) then {
// [KnfOpt]     let sum.104: Int = Var(acc.7978)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _7984: Int = Apply(f.7977, [acc.7978, val.7982, ])
// [KnfOpt]     Jump(fold.7975, [stream.7976, f.7977, _7984, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.7975, [under1200.103, add.7971, _7974, ])
// [KnfOpt] Inline threshold 3
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 0
// [KnfOpt] Inline decision addx.59 accepted
// [KnfOpt] Inline threshold 20
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 0
// [KnfOpt] Inline decision map.1 accepted
// [KnfOpt] Inline threshold 5
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 0
// [KnfOpt] Inline decision gt.79 accepted
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 5
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 0
// [KnfOpt] Inline decision le.83 accepted
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.7994: Int = (x.7995: Int, y.7996: Int) {
// [KnfOpt]   Add(x.7995, y.7996)
// [KnfOpt] }
// [KnfOpt] let _7997: Int = Int(0)
// [KnfOpt] let join fold.7998: Int = (stream.7999: Fun([Unit], Tuple([Int, Int])), f.8000: Fun([Int, Int], Int), acc.8001: Int) {
// [KnfOpt]   let _8002: Unit = Unit
// [KnfOpt]   let _8003: Tuple([Int, Int]) = Apply(stream.7999, [_8002, ])
// [KnfOpt]   let (ok.8004: Var({val: Some(Int)}), val.8005: Var({val: Some(Int)})) = _8003
// [KnfOpt]   let _8006: Int = Int(0)
// [KnfOpt]   if (ok.8004 == _8006) then {
// [KnfOpt]     let sum.104: Int = Var(acc.8001)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _8007: Int = Apply(f.8000, [acc.8001, val.8005, ])
// [KnfOpt]     Jump(fold.7998, [stream.7999, f.8000, _8007, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.7998, [under1200.103, add.7994, _7997, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(le) let _102: Fun([Int], Int) = Unit
// [KnfOpt] let rec aux.8008: Tuple([Int, Int]) = (u.8009: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.8010: Tuple([Int, Int]) = (u.8011: Var({val: Some(Unit)})) {
// [KnfOpt]     let _8012: Unit = Unit
// [KnfOpt]     let _8013: Tuple([Int, Int]) = Apply(over50.100, [_8012, ])
// [KnfOpt]     let (ok.8014: Var({val: Some(Int)}), val.8015: Var({val: Some(Int)})) = _8013
// [KnfOpt]     let _8016: Int = Int(0)
// [KnfOpt]     if (ok.8014 == _8016) then {
// [KnfOpt]       let _8017: Int = Int(0)
// [KnfOpt]       let _8018: Int = Int(0)
// [KnfOpt]       Tuple([_8017, _8018, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.8019: Int = Apply(_102, [val.8015, ])
// [KnfOpt]       let _8020: Int = Int(0)
// [KnfOpt]       if (r.8019 == _8020) then {
// [KnfOpt]         let _8021: Int = Int(1)
// [KnfOpt]         Tuple([_8021, val.8015, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _8022: Unit = Unit
// [KnfOpt]         Jump(aux.8010, [_8022, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.8010, [u.8009, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.8008)
// [KnfOpt] let rec add.8023: Int = (x.8024: Int, y.8025: Int) {
// [KnfOpt]   Add(x.8024, y.8025)
// [KnfOpt] }
// [KnfOpt] let _8026: Int = Int(0)
// [KnfOpt] let join fold.8027: Int = (stream.8028: Fun([Unit], Tuple([Int, Int])), f.8029: Fun([Int, Int], Int), acc.8030: Int) {
// [KnfOpt]   let _8031: Unit = Unit
// [KnfOpt]   let _8032: Tuple([Int, Int]) = Apply(stream.8028, [_8031, ])
// [KnfOpt]   let (ok.8033: Var({val: Some(Int)}), val.8034: Var({val: Some(Int)})) = _8032
// [KnfOpt]   let _8035: Int = Int(0)
// [KnfOpt]   if (ok.8033 == _8035) then {
// [KnfOpt]     let sum.104: Int = Var(acc.8030)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _8036: Int = Apply(f.8029, [acc.8030, val.8034, ])
// [KnfOpt]     Jump(fold.8027, [stream.8028, f.8029, _8036, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.8027, [under1200.103, add.8023, _8026, ])
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.8039: Int = (x.8040: Int, y.8041: Int) {
// [KnfOpt]   Add(x.8040, y.8041)
// [KnfOpt] }
// [KnfOpt] let _8042: Int = Int(0)
// [KnfOpt] let join fold.8043: Int = (stream.8044: Fun([Unit], Tuple([Int, Int])), f.8045: Fun([Int, Int], Int), acc.8046: Int) {
// [KnfOpt]   let _8047: Unit = Unit
// [KnfOpt]   let _8048: Tuple([Int, Int]) = Apply(stream.8044, [_8047, ])
// [KnfOpt]   let (ok.8049: Var({val: Some(Int)}), val.8050: Var({val: Some(Int)})) = _8048
// [KnfOpt]   let _8051: Int = Int(0)
// [KnfOpt]   if (ok.8049 == _8051) then {
// [KnfOpt]     let sum.104: Int = Var(acc.8046)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _8052: Int = Apply(f.8045, [acc.8046, val.8050, ])
// [KnfOpt]     Jump(fold.8043, [stream.8044, f.8045, _8052, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.8043, [under1200.103, add.8039, _8042, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let over50.100: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let _101: Int = Int(1200)
// [KnfOpt] let rec aux.8037: Int = (y.8038: Int) {
// [KnfOpt]   if (y.8038 <= _101) then {
// [KnfOpt]     Int(0)
// [KnfOpt]   } else {
// [KnfOpt]     Int(1)
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] let _102: Fun([Int], Int) = Var(aux.8037)
// [KnfOpt] let rec aux.8053: Tuple([Int, Int]) = (u.8054: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.8055: Tuple([Int, Int]) = (u.8056: Var({val: Some(Unit)})) {
// [KnfOpt]     let _8057: Unit = Unit
// [KnfOpt]     let _8058: Tuple([Int, Int]) = Apply(over50.100, [_8057, ])
// [KnfOpt]     let (ok.8059: Var({val: Some(Int)}), val.8060: Var({val: Some(Int)})) = _8058
// [KnfOpt]     let _8061: Int = Int(0)
// [KnfOpt]     if (ok.8059 == _8061) then {
// [KnfOpt]       let _8062: Int = Int(0)
// [KnfOpt]       let _8063: Int = Int(0)
// [KnfOpt]       Tuple([_8062, _8063, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.8064: Int = Apply(_102, [val.8060, ])
// [KnfOpt]       let _8065: Int = Int(0)
// [KnfOpt]       if (r.8064 == _8065) then {
// [KnfOpt]         let _8066: Int = Int(1)
// [KnfOpt]         Tuple([_8066, val.8060, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _8067: Unit = Unit
// [KnfOpt]         Jump(aux.8055, [_8067, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.8055, [u.8054, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.8053)
// [KnfOpt] let rec add.8068: Int = (x.8069: Int, y.8070: Int) {
// [KnfOpt]   Add(x.8069, y.8070)
// [KnfOpt] }
// [KnfOpt] let _8071: Int = Int(0)
// [KnfOpt] let join fold.8072: Int = (stream.8073: Fun([Unit], Tuple([Int, Int])), f.8074: Fun([Int, Int], Int), acc.8075: Int) {
// [KnfOpt]   let _8076: Unit = Unit
// [KnfOpt]   let _8077: Tuple([Int, Int]) = Apply(stream.8073, [_8076, ])
// [KnfOpt]   let (ok.8078: Var({val: Some(Int)}), val.8079: Var({val: Some(Int)})) = _8077
// [KnfOpt]   let _8080: Int = Int(0)
// [KnfOpt]   if (ok.8078 == _8080) then {
// [KnfOpt]     let sum.104: Int = Var(acc.8075)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _8081: Int = Apply(f.8074, [acc.8075, val.8079, ])
// [KnfOpt]     Jump(fold.8072, [stream.8073, f.8074, _8081, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.8072, [under1200.103, add.8068, _8071, ])
// [KnfOpt] Inline threshold 5
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 0
// [KnfOpt] Inline decision le.83 accepted
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.8097: Int = (x.8098: Int, y.8099: Int) {
// [KnfOpt]   Add(x.8098, y.8099)
// [KnfOpt] }
// [KnfOpt] let _8100: Int = Int(0)
// [KnfOpt] let join fold.8101: Int = (stream.8102: Fun([Unit], Tuple([Int, Int])), f.8103: Fun([Int, Int], Int), acc.8104: Int) {
// [KnfOpt]   let _8105: Unit = Unit
// [KnfOpt]   let _8106: Tuple([Int, Int]) = Apply(stream.8102, [_8105, ])
// [KnfOpt]   let (ok.8107: Var({val: Some(Int)}), val.8108: Var({val: Some(Int)})) = _8106
// [KnfOpt]   let _8109: Int = Int(0)
// [KnfOpt]   if (ok.8107 == _8109) then {
// [KnfOpt]     let sum.104: Int = Var(acc.8104)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _8110: Int = Apply(f.8103, [acc.8104, val.8108, ])
// [KnfOpt]     Jump(fold.8101, [stream.8102, f.8103, _8110, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.8101, [under1200.103, add.8097, _8100, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(le) let _102: Fun([Int], Int) = Unit
// [KnfOpt] let rec aux.8111: Tuple([Int, Int]) = (u.8112: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.8113: Tuple([Int, Int]) = (u.8114: Var({val: Some(Unit)})) {
// [KnfOpt]     let _8115: Unit = Unit
// [KnfOpt]     let _8116: Tuple([Int, Int]) = Apply(over50.100, [_8115, ])
// [KnfOpt]     let (ok.8117: Var({val: Some(Int)}), val.8118: Var({val: Some(Int)})) = _8116
// [KnfOpt]     let _8119: Int = Int(0)
// [KnfOpt]     if (ok.8117 == _8119) then {
// [KnfOpt]       let _8120: Int = Int(0)
// [KnfOpt]       let _8121: Int = Int(0)
// [KnfOpt]       Tuple([_8120, _8121, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.8122: Int = Apply(_102, [val.8118, ])
// [KnfOpt]       let _8123: Int = Int(0)
// [KnfOpt]       if (r.8122 == _8123) then {
// [KnfOpt]         let _8124: Int = Int(1)
// [KnfOpt]         Tuple([_8124, val.8118, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _8125: Unit = Unit
// [KnfOpt]         Jump(aux.8113, [_8125, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.8113, [u.8112, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.8111)
// [KnfOpt] let rec add.8126: Int = (x.8127: Int, y.8128: Int) {
// [KnfOpt]   Add(x.8127, y.8128)
// [KnfOpt] }
// [KnfOpt] let _8129: Int = Int(0)
// [KnfOpt] let join fold.8130: Int = (stream.8131: Fun([Unit], Tuple([Int, Int])), f.8132: Fun([Int, Int], Int), acc.8133: Int) {
// [KnfOpt]   let _8134: Unit = Unit
// [KnfOpt]   let _8135: Tuple([Int, Int]) = Apply(stream.8131, [_8134, ])
// [KnfOpt]   let (ok.8136: Var({val: Some(Int)}), val.8137: Var({val: Some(Int)})) = _8135
// [KnfOpt]   let _8138: Int = Int(0)
// [KnfOpt]   if (ok.8136 == _8138) then {
// [KnfOpt]     let sum.104: Int = Var(acc.8133)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _8139: Int = Apply(f.8132, [acc.8133, val.8137, ])
// [KnfOpt]     Jump(fold.8130, [stream.8131, f.8132, _8139, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.8130, [under1200.103, add.8126, _8129, ])
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.8142: Int = (x.8143: Int, y.8144: Int) {
// [KnfOpt]   Add(x.8143, y.8144)
// [KnfOpt] }
// [KnfOpt] let _8145: Int = Int(0)
// [KnfOpt] let join fold.8146: Int = (stream.8147: Fun([Unit], Tuple([Int, Int])), f.8148: Fun([Int, Int], Int), acc.8149: Int) {
// [KnfOpt]   let _8150: Unit = Unit
// [KnfOpt]   let _8151: Tuple([Int, Int]) = Apply(stream.8147, [_8150, ])
// [KnfOpt]   let (ok.8152: Var({val: Some(Int)}), val.8153: Var({val: Some(Int)})) = _8151
// [KnfOpt]   let _8154: Int = Int(0)
// [KnfOpt]   if (ok.8152 == _8154) then {
// [KnfOpt]     let sum.104: Int = Var(acc.8149)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _8155: Int = Apply(f.8148, [acc.8149, val.8153, ])
// [KnfOpt]     Jump(fold.8146, [stream.8147, f.8148, _8155, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.8146, [under1200.103, add.8142, _8145, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(gt) let _99: Fun([Int], Int) = Unit
// [KnfOpt] let rec aux.8082: Tuple([Int, Int]) = (u.8083: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.8084: Tuple([Int, Int]) = (u.8085: Var({val: Some(Unit)})) {
// [KnfOpt]     let _8086: Unit = Unit
// [KnfOpt]     let _8087: Tuple([Int, Int]) = Apply(addone.97, [_8086, ])
// [KnfOpt]     let (ok.8088: Var({val: Some(Int)}), val.8089: Var({val: Some(Int)})) = _8087
// [KnfOpt]     let _8090: Int = Int(0)
// [KnfOpt]     if (ok.8088 == _8090) then {
// [KnfOpt]       let _8091: Int = Int(0)
// [KnfOpt]       let _8092: Int = Int(0)
// [KnfOpt]       Tuple([_8091, _8092, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.8093: Int = Apply(_99, [val.8089, ])
// [KnfOpt]       let _8094: Int = Int(0)
// [KnfOpt]       if (r.8093 == _8094) then {
// [KnfOpt]         let _8095: Int = Int(1)
// [KnfOpt]         Tuple([_8095, val.8089, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _8096: Unit = Unit
// [KnfOpt]         Jump(aux.8084, [_8096, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.8084, [u.8083, ])
// [KnfOpt] }
// [KnfOpt] let over50.100: Fun([Unit], Tuple([Int, Int])) = Var(aux.8082)
// [KnfOpt] let _101: Int = Int(1200)
// [KnfOpt] let rec aux.8140: Int = (y.8141: Int) {
// [KnfOpt]   if (y.8141 <= _101) then {
// [KnfOpt]     Int(0)
// [KnfOpt]   } else {
// [KnfOpt]     Int(1)
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] let _102: Fun([Int], Int) = Var(aux.8140)
// [KnfOpt] let rec aux.8156: Tuple([Int, Int]) = (u.8157: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.8158: Tuple([Int, Int]) = (u.8159: Var({val: Some(Unit)})) {
// [KnfOpt]     let _8160: Unit = Unit
// [KnfOpt]     let _8161: Tuple([Int, Int]) = Apply(over50.100, [_8160, ])
// [KnfOpt]     let (ok.8162: Var({val: Some(Int)}), val.8163: Var({val: Some(Int)})) = _8161
// [KnfOpt]     let _8164: Int = Int(0)
// [KnfOpt]     if (ok.8162 == _8164) then {
// [KnfOpt]       let _8165: Int = Int(0)
// [KnfOpt]       let _8166: Int = Int(0)
// [KnfOpt]       Tuple([_8165, _8166, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.8167: Int = Apply(_102, [val.8163, ])
// [KnfOpt]       let _8168: Int = Int(0)
// [KnfOpt]       if (r.8167 == _8168) then {
// [KnfOpt]         let _8169: Int = Int(1)
// [KnfOpt]         Tuple([_8169, val.8163, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _8170: Unit = Unit
// [KnfOpt]         Jump(aux.8158, [_8170, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.8158, [u.8157, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.8156)
// [KnfOpt] let rec add.8171: Int = (x.8172: Int, y.8173: Int) {
// [KnfOpt]   Add(x.8172, y.8173)
// [KnfOpt] }
// [KnfOpt] let _8174: Int = Int(0)
// [KnfOpt] let join fold.8175: Int = (stream.8176: Fun([Unit], Tuple([Int, Int])), f.8177: Fun([Int, Int], Int), acc.8178: Int) {
// [KnfOpt]   let _8179: Unit = Unit
// [KnfOpt]   let _8180: Tuple([Int, Int]) = Apply(stream.8176, [_8179, ])
// [KnfOpt]   let (ok.8181: Var({val: Some(Int)}), val.8182: Var({val: Some(Int)})) = _8180
// [KnfOpt]   let _8183: Int = Int(0)
// [KnfOpt]   if (ok.8181 == _8183) then {
// [KnfOpt]     let sum.104: Int = Var(acc.8178)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _8184: Int = Apply(f.8177, [acc.8178, val.8182, ])
// [KnfOpt]     Jump(fold.8175, [stream.8176, f.8177, _8184, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.8175, [under1200.103, add.8171, _8174, ])
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 5
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 0
// [KnfOpt] Inline decision le.83 accepted
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.8187: Int = (x.8188: Int, y.8189: Int) {
// [KnfOpt]   Add(x.8188, y.8189)
// [KnfOpt] }
// [KnfOpt] let _8190: Int = Int(0)
// [KnfOpt] let join fold.8191: Int = (stream.8192: Fun([Unit], Tuple([Int, Int])), f.8193: Fun([Int, Int], Int), acc.8194: Int) {
// [KnfOpt]   let _8195: Unit = Unit
// [KnfOpt]   let _8196: Tuple([Int, Int]) = Apply(stream.8192, [_8195, ])
// [KnfOpt]   let (ok.8197: Var({val: Some(Int)}), val.8198: Var({val: Some(Int)})) = _8196
// [KnfOpt]   let _8199: Int = Int(0)
// [KnfOpt]   if (ok.8197 == _8199) then {
// [KnfOpt]     let sum.104: Int = Var(acc.8194)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _8200: Int = Apply(f.8193, [acc.8194, val.8198, ])
// [KnfOpt]     Jump(fold.8191, [stream.8192, f.8193, _8200, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.8191, [under1200.103, add.8187, _8190, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(le) let _102: Fun([Int], Int) = Unit
// [KnfOpt] let rec aux.8201: Tuple([Int, Int]) = (u.8202: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.8203: Tuple([Int, Int]) = (u.8204: Var({val: Some(Unit)})) {
// [KnfOpt]     let _8205: Unit = Unit
// [KnfOpt]     let _8206: Tuple([Int, Int]) = Apply(over50.100, [_8205, ])
// [KnfOpt]     let (ok.8207: Var({val: Some(Int)}), val.8208: Var({val: Some(Int)})) = _8206
// [KnfOpt]     let _8209: Int = Int(0)
// [KnfOpt]     if (ok.8207 == _8209) then {
// [KnfOpt]       let _8210: Int = Int(0)
// [KnfOpt]       let _8211: Int = Int(0)
// [KnfOpt]       Tuple([_8210, _8211, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.8212: Int = Apply(_102, [val.8208, ])
// [KnfOpt]       let _8213: Int = Int(0)
// [KnfOpt]       if (r.8212 == _8213) then {
// [KnfOpt]         let _8214: Int = Int(1)
// [KnfOpt]         Tuple([_8214, val.8208, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _8215: Unit = Unit
// [KnfOpt]         Jump(aux.8203, [_8215, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.8203, [u.8202, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.8201)
// [KnfOpt] let rec add.8216: Int = (x.8217: Int, y.8218: Int) {
// [KnfOpt]   Add(x.8217, y.8218)
// [KnfOpt] }
// [KnfOpt] let _8219: Int = Int(0)
// [KnfOpt] let join fold.8220: Int = (stream.8221: Fun([Unit], Tuple([Int, Int])), f.8222: Fun([Int, Int], Int), acc.8223: Int) {
// [KnfOpt]   let _8224: Unit = Unit
// [KnfOpt]   let _8225: Tuple([Int, Int]) = Apply(stream.8221, [_8224, ])
// [KnfOpt]   let (ok.8226: Var({val: Some(Int)}), val.8227: Var({val: Some(Int)})) = _8225
// [KnfOpt]   let _8228: Int = Int(0)
// [KnfOpt]   if (ok.8226 == _8228) then {
// [KnfOpt]     let sum.104: Int = Var(acc.8223)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _8229: Int = Apply(f.8222, [acc.8223, val.8227, ])
// [KnfOpt]     Jump(fold.8220, [stream.8221, f.8222, _8229, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.8220, [under1200.103, add.8216, _8219, ])
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.8232: Int = (x.8233: Int, y.8234: Int) {
// [KnfOpt]   Add(x.8233, y.8234)
// [KnfOpt] }
// [KnfOpt] let _8235: Int = Int(0)
// [KnfOpt] let join fold.8236: Int = (stream.8237: Fun([Unit], Tuple([Int, Int])), f.8238: Fun([Int, Int], Int), acc.8239: Int) {
// [KnfOpt]   let _8240: Unit = Unit
// [KnfOpt]   let _8241: Tuple([Int, Int]) = Apply(stream.8237, [_8240, ])
// [KnfOpt]   let (ok.8242: Var({val: Some(Int)}), val.8243: Var({val: Some(Int)})) = _8241
// [KnfOpt]   let _8244: Int = Int(0)
// [KnfOpt]   if (ok.8242 == _8244) then {
// [KnfOpt]     let sum.104: Int = Var(acc.8239)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _8245: Int = Apply(f.8238, [acc.8239, val.8243, ])
// [KnfOpt]     Jump(fold.8236, [stream.8237, f.8238, _8245, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.8236, [under1200.103, add.8232, _8235, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let over50.100: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let _101: Int = Int(1200)
// [KnfOpt] let rec aux.8230: Int = (y.8231: Int) {
// [KnfOpt]   if (y.8231 <= _101) then {
// [KnfOpt]     Int(0)
// [KnfOpt]   } else {
// [KnfOpt]     Int(1)
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] let _102: Fun([Int], Int) = Var(aux.8230)
// [KnfOpt] let rec aux.8246: Tuple([Int, Int]) = (u.8247: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.8248: Tuple([Int, Int]) = (u.8249: Var({val: Some(Unit)})) {
// [KnfOpt]     let _8250: Unit = Unit
// [KnfOpt]     let _8251: Tuple([Int, Int]) = Apply(over50.100, [_8250, ])
// [KnfOpt]     let (ok.8252: Var({val: Some(Int)}), val.8253: Var({val: Some(Int)})) = _8251
// [KnfOpt]     let _8254: Int = Int(0)
// [KnfOpt]     if (ok.8252 == _8254) then {
// [KnfOpt]       let _8255: Int = Int(0)
// [KnfOpt]       let _8256: Int = Int(0)
// [KnfOpt]       Tuple([_8255, _8256, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.8257: Int = Apply(_102, [val.8253, ])
// [KnfOpt]       let _8258: Int = Int(0)
// [KnfOpt]       if (r.8257 == _8258) then {
// [KnfOpt]         let _8259: Int = Int(1)
// [KnfOpt]         Tuple([_8259, val.8253, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _8260: Unit = Unit
// [KnfOpt]         Jump(aux.8248, [_8260, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.8248, [u.8247, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.8246)
// [KnfOpt] let rec add.8261: Int = (x.8262: Int, y.8263: Int) {
// [KnfOpt]   Add(x.8262, y.8263)
// [KnfOpt] }
// [KnfOpt] let _8264: Int = Int(0)
// [KnfOpt] let join fold.8265: Int = (stream.8266: Fun([Unit], Tuple([Int, Int])), f.8267: Fun([Int, Int], Int), acc.8268: Int) {
// [KnfOpt]   let _8269: Unit = Unit
// [KnfOpt]   let _8270: Tuple([Int, Int]) = Apply(stream.8266, [_8269, ])
// [KnfOpt]   let (ok.8271: Var({val: Some(Int)}), val.8272: Var({val: Some(Int)})) = _8270
// [KnfOpt]   let _8273: Int = Int(0)
// [KnfOpt]   if (ok.8271 == _8273) then {
// [KnfOpt]     let sum.104: Int = Var(acc.8268)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _8274: Int = Apply(f.8267, [acc.8268, val.8272, ])
// [KnfOpt]     Jump(fold.8265, [stream.8266, f.8267, _8274, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.8265, [under1200.103, add.8261, _8264, ])
// [KnfOpt] Inline threshold 5
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 0
// [KnfOpt] Inline decision le.83 accepted
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.8290: Int = (x.8291: Int, y.8292: Int) {
// [KnfOpt]   Add(x.8291, y.8292)
// [KnfOpt] }
// [KnfOpt] let _8293: Int = Int(0)
// [KnfOpt] let join fold.8294: Int = (stream.8295: Fun([Unit], Tuple([Int, Int])), f.8296: Fun([Int, Int], Int), acc.8297: Int) {
// [KnfOpt]   let _8298: Unit = Unit
// [KnfOpt]   let _8299: Tuple([Int, Int]) = Apply(stream.8295, [_8298, ])
// [KnfOpt]   let (ok.8300: Var({val: Some(Int)}), val.8301: Var({val: Some(Int)})) = _8299
// [KnfOpt]   let _8302: Int = Int(0)
// [KnfOpt]   if (ok.8300 == _8302) then {
// [KnfOpt]     let sum.104: Int = Var(acc.8297)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _8303: Int = Apply(f.8296, [acc.8297, val.8301, ])
// [KnfOpt]     Jump(fold.8294, [stream.8295, f.8296, _8303, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.8294, [under1200.103, add.8290, _8293, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(le) let _102: Fun([Int], Int) = Unit
// [KnfOpt] let rec aux.8304: Tuple([Int, Int]) = (u.8305: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.8306: Tuple([Int, Int]) = (u.8307: Var({val: Some(Unit)})) {
// [KnfOpt]     let _8308: Unit = Unit
// [KnfOpt]     let _8309: Tuple([Int, Int]) = Apply(over50.100, [_8308, ])
// [KnfOpt]     let (ok.8310: Var({val: Some(Int)}), val.8311: Var({val: Some(Int)})) = _8309
// [KnfOpt]     let _8312: Int = Int(0)
// [KnfOpt]     if (ok.8310 == _8312) then {
// [KnfOpt]       let _8313: Int = Int(0)
// [KnfOpt]       let _8314: Int = Int(0)
// [KnfOpt]       Tuple([_8313, _8314, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.8315: Int = Apply(_102, [val.8311, ])
// [KnfOpt]       let _8316: Int = Int(0)
// [KnfOpt]       if (r.8315 == _8316) then {
// [KnfOpt]         let _8317: Int = Int(1)
// [KnfOpt]         Tuple([_8317, val.8311, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _8318: Unit = Unit
// [KnfOpt]         Jump(aux.8306, [_8318, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.8306, [u.8305, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.8304)
// [KnfOpt] let rec add.8319: Int = (x.8320: Int, y.8321: Int) {
// [KnfOpt]   Add(x.8320, y.8321)
// [KnfOpt] }
// [KnfOpt] let _8322: Int = Int(0)
// [KnfOpt] let join fold.8323: Int = (stream.8324: Fun([Unit], Tuple([Int, Int])), f.8325: Fun([Int, Int], Int), acc.8326: Int) {
// [KnfOpt]   let _8327: Unit = Unit
// [KnfOpt]   let _8328: Tuple([Int, Int]) = Apply(stream.8324, [_8327, ])
// [KnfOpt]   let (ok.8329: Var({val: Some(Int)}), val.8330: Var({val: Some(Int)})) = _8328
// [KnfOpt]   let _8331: Int = Int(0)
// [KnfOpt]   if (ok.8329 == _8331) then {
// [KnfOpt]     let sum.104: Int = Var(acc.8326)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _8332: Int = Apply(f.8325, [acc.8326, val.8330, ])
// [KnfOpt]     Jump(fold.8323, [stream.8324, f.8325, _8332, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.8323, [under1200.103, add.8319, _8322, ])
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.8335: Int = (x.8336: Int, y.8337: Int) {
// [KnfOpt]   Add(x.8336, y.8337)
// [KnfOpt] }
// [KnfOpt] let _8338: Int = Int(0)
// [KnfOpt] let join fold.8339: Int = (stream.8340: Fun([Unit], Tuple([Int, Int])), f.8341: Fun([Int, Int], Int), acc.8342: Int) {
// [KnfOpt]   let _8343: Unit = Unit
// [KnfOpt]   let _8344: Tuple([Int, Int]) = Apply(stream.8340, [_8343, ])
// [KnfOpt]   let (ok.8345: Var({val: Some(Int)}), val.8346: Var({val: Some(Int)})) = _8344
// [KnfOpt]   let _8347: Int = Int(0)
// [KnfOpt]   if (ok.8345 == _8347) then {
// [KnfOpt]     let sum.104: Int = Var(acc.8342)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _8348: Int = Apply(f.8341, [acc.8342, val.8346, ])
// [KnfOpt]     Jump(fold.8339, [stream.8340, f.8341, _8348, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.8339, [under1200.103, add.8335, _8338, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(map) let addone.97: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let _98: Int = Int(50)
// [KnfOpt] let rec aux.8185: Int = (y.8186: Int) {
// [KnfOpt]   if (_98 <= y.8186) then {
// [KnfOpt]     Int(0)
// [KnfOpt]   } else {
// [KnfOpt]     Int(1)
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] let _99: Fun([Int], Int) = Var(aux.8185)
// [KnfOpt] let rec aux.8275: Tuple([Int, Int]) = (u.8276: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.8277: Tuple([Int, Int]) = (u.8278: Var({val: Some(Unit)})) {
// [KnfOpt]     let _8279: Unit = Unit
// [KnfOpt]     let _8280: Tuple([Int, Int]) = Apply(addone.97, [_8279, ])
// [KnfOpt]     let (ok.8281: Var({val: Some(Int)}), val.8282: Var({val: Some(Int)})) = _8280
// [KnfOpt]     let _8283: Int = Int(0)
// [KnfOpt]     if (ok.8281 == _8283) then {
// [KnfOpt]       let _8284: Int = Int(0)
// [KnfOpt]       let _8285: Int = Int(0)
// [KnfOpt]       Tuple([_8284, _8285, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.8286: Int = Apply(_99, [val.8282, ])
// [KnfOpt]       let _8287: Int = Int(0)
// [KnfOpt]       if (r.8286 == _8287) then {
// [KnfOpt]         let _8288: Int = Int(1)
// [KnfOpt]         Tuple([_8288, val.8282, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _8289: Unit = Unit
// [KnfOpt]         Jump(aux.8277, [_8289, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.8277, [u.8276, ])
// [KnfOpt] }
// [KnfOpt] let over50.100: Fun([Unit], Tuple([Int, Int])) = Var(aux.8275)
// [KnfOpt] let _101: Int = Int(1200)
// [KnfOpt] let rec aux.8333: Int = (y.8334: Int) {
// [KnfOpt]   if (y.8334 <= _101) then {
// [KnfOpt]     Int(0)
// [KnfOpt]   } else {
// [KnfOpt]     Int(1)
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] let _102: Fun([Int], Int) = Var(aux.8333)
// [KnfOpt] let rec aux.8349: Tuple([Int, Int]) = (u.8350: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.8351: Tuple([Int, Int]) = (u.8352: Var({val: Some(Unit)})) {
// [KnfOpt]     let _8353: Unit = Unit
// [KnfOpt]     let _8354: Tuple([Int, Int]) = Apply(over50.100, [_8353, ])
// [KnfOpt]     let (ok.8355: Var({val: Some(Int)}), val.8356: Var({val: Some(Int)})) = _8354
// [KnfOpt]     let _8357: Int = Int(0)
// [KnfOpt]     if (ok.8355 == _8357) then {
// [KnfOpt]       let _8358: Int = Int(0)
// [KnfOpt]       let _8359: Int = Int(0)
// [KnfOpt]       Tuple([_8358, _8359, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.8360: Int = Apply(_102, [val.8356, ])
// [KnfOpt]       let _8361: Int = Int(0)
// [KnfOpt]       if (r.8360 == _8361) then {
// [KnfOpt]         let _8362: Int = Int(1)
// [KnfOpt]         Tuple([_8362, val.8356, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _8363: Unit = Unit
// [KnfOpt]         Jump(aux.8351, [_8363, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.8351, [u.8350, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.8349)
// [KnfOpt] let rec add.8364: Int = (x.8365: Int, y.8366: Int) {
// [KnfOpt]   Add(x.8365, y.8366)
// [KnfOpt] }
// [KnfOpt] let _8367: Int = Int(0)
// [KnfOpt] let join fold.8368: Int = (stream.8369: Fun([Unit], Tuple([Int, Int])), f.8370: Fun([Int, Int], Int), acc.8371: Int) {
// [KnfOpt]   let _8372: Unit = Unit
// [KnfOpt]   let _8373: Tuple([Int, Int]) = Apply(stream.8369, [_8372, ])
// [KnfOpt]   let (ok.8374: Var({val: Some(Int)}), val.8375: Var({val: Some(Int)})) = _8373
// [KnfOpt]   let _8376: Int = Int(0)
// [KnfOpt]   if (ok.8374 == _8376) then {
// [KnfOpt]     let sum.104: Int = Var(acc.8371)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _8377: Int = Apply(f.8370, [acc.8371, val.8375, ])
// [KnfOpt]     Jump(fold.8368, [stream.8369, f.8370, _8377, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.8368, [under1200.103, add.8364, _8367, ])
// [KnfOpt] Inline threshold 5
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 0
// [KnfOpt] Inline decision gt.79 accepted
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 5
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 0
// [KnfOpt] Inline decision le.83 accepted
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.8389: Int = (x.8390: Int, y.8391: Int) {
// [KnfOpt]   Add(x.8390, y.8391)
// [KnfOpt] }
// [KnfOpt] let _8392: Int = Int(0)
// [KnfOpt] let join fold.8393: Int = (stream.8394: Fun([Unit], Tuple([Int, Int])), f.8395: Fun([Int, Int], Int), acc.8396: Int) {
// [KnfOpt]   let _8397: Unit = Unit
// [KnfOpt]   let _8398: Tuple([Int, Int]) = Apply(stream.8394, [_8397, ])
// [KnfOpt]   let (ok.8399: Var({val: Some(Int)}), val.8400: Var({val: Some(Int)})) = _8398
// [KnfOpt]   let _8401: Int = Int(0)
// [KnfOpt]   if (ok.8399 == _8401) then {
// [KnfOpt]     let sum.104: Int = Var(acc.8396)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _8402: Int = Apply(f.8395, [acc.8396, val.8400, ])
// [KnfOpt]     Jump(fold.8393, [stream.8394, f.8395, _8402, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.8393, [under1200.103, add.8389, _8392, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(le) let _102: Fun([Int], Int) = Unit
// [KnfOpt] let rec aux.8403: Tuple([Int, Int]) = (u.8404: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.8405: Tuple([Int, Int]) = (u.8406: Var({val: Some(Unit)})) {
// [KnfOpt]     let _8407: Unit = Unit
// [KnfOpt]     let _8408: Tuple([Int, Int]) = Apply(over50.100, [_8407, ])
// [KnfOpt]     let (ok.8409: Var({val: Some(Int)}), val.8410: Var({val: Some(Int)})) = _8408
// [KnfOpt]     let _8411: Int = Int(0)
// [KnfOpt]     if (ok.8409 == _8411) then {
// [KnfOpt]       let _8412: Int = Int(0)
// [KnfOpt]       let _8413: Int = Int(0)
// [KnfOpt]       Tuple([_8412, _8413, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.8414: Int = Apply(_102, [val.8410, ])
// [KnfOpt]       let _8415: Int = Int(0)
// [KnfOpt]       if (r.8414 == _8415) then {
// [KnfOpt]         let _8416: Int = Int(1)
// [KnfOpt]         Tuple([_8416, val.8410, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _8417: Unit = Unit
// [KnfOpt]         Jump(aux.8405, [_8417, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.8405, [u.8404, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.8403)
// [KnfOpt] let rec add.8418: Int = (x.8419: Int, y.8420: Int) {
// [KnfOpt]   Add(x.8419, y.8420)
// [KnfOpt] }
// [KnfOpt] let _8421: Int = Int(0)
// [KnfOpt] let join fold.8422: Int = (stream.8423: Fun([Unit], Tuple([Int, Int])), f.8424: Fun([Int, Int], Int), acc.8425: Int) {
// [KnfOpt]   let _8426: Unit = Unit
// [KnfOpt]   let _8427: Tuple([Int, Int]) = Apply(stream.8423, [_8426, ])
// [KnfOpt]   let (ok.8428: Var({val: Some(Int)}), val.8429: Var({val: Some(Int)})) = _8427
// [KnfOpt]   let _8430: Int = Int(0)
// [KnfOpt]   if (ok.8428 == _8430) then {
// [KnfOpt]     let sum.104: Int = Var(acc.8425)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _8431: Int = Apply(f.8424, [acc.8425, val.8429, ])
// [KnfOpt]     Jump(fold.8422, [stream.8423, f.8424, _8431, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.8422, [under1200.103, add.8418, _8421, ])
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.8434: Int = (x.8435: Int, y.8436: Int) {
// [KnfOpt]   Add(x.8435, y.8436)
// [KnfOpt] }
// [KnfOpt] let _8437: Int = Int(0)
// [KnfOpt] let join fold.8438: Int = (stream.8439: Fun([Unit], Tuple([Int, Int])), f.8440: Fun([Int, Int], Int), acc.8441: Int) {
// [KnfOpt]   let _8442: Unit = Unit
// [KnfOpt]   let _8443: Tuple([Int, Int]) = Apply(stream.8439, [_8442, ])
// [KnfOpt]   let (ok.8444: Var({val: Some(Int)}), val.8445: Var({val: Some(Int)})) = _8443
// [KnfOpt]   let _8446: Int = Int(0)
// [KnfOpt]   if (ok.8444 == _8446) then {
// [KnfOpt]     let sum.104: Int = Var(acc.8441)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _8447: Int = Apply(f.8440, [acc.8441, val.8445, ])
// [KnfOpt]     Jump(fold.8438, [stream.8439, f.8440, _8447, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.8438, [under1200.103, add.8434, _8437, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let over50.100: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let _101: Int = Int(1200)
// [KnfOpt] let rec aux.8432: Int = (y.8433: Int) {
// [KnfOpt]   if (y.8433 <= _101) then {
// [KnfOpt]     Int(0)
// [KnfOpt]   } else {
// [KnfOpt]     Int(1)
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] let _102: Fun([Int], Int) = Var(aux.8432)
// [KnfOpt] let rec aux.8448: Tuple([Int, Int]) = (u.8449: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.8450: Tuple([Int, Int]) = (u.8451: Var({val: Some(Unit)})) {
// [KnfOpt]     let _8452: Unit = Unit
// [KnfOpt]     let _8453: Tuple([Int, Int]) = Apply(over50.100, [_8452, ])
// [KnfOpt]     let (ok.8454: Var({val: Some(Int)}), val.8455: Var({val: Some(Int)})) = _8453
// [KnfOpt]     let _8456: Int = Int(0)
// [KnfOpt]     if (ok.8454 == _8456) then {
// [KnfOpt]       let _8457: Int = Int(0)
// [KnfOpt]       let _8458: Int = Int(0)
// [KnfOpt]       Tuple([_8457, _8458, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.8459: Int = Apply(_102, [val.8455, ])
// [KnfOpt]       let _8460: Int = Int(0)
// [KnfOpt]       if (r.8459 == _8460) then {
// [KnfOpt]         let _8461: Int = Int(1)
// [KnfOpt]         Tuple([_8461, val.8455, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _8462: Unit = Unit
// [KnfOpt]         Jump(aux.8450, [_8462, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.8450, [u.8449, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.8448)
// [KnfOpt] let rec add.8463: Int = (x.8464: Int, y.8465: Int) {
// [KnfOpt]   Add(x.8464, y.8465)
// [KnfOpt] }
// [KnfOpt] let _8466: Int = Int(0)
// [KnfOpt] let join fold.8467: Int = (stream.8468: Fun([Unit], Tuple([Int, Int])), f.8469: Fun([Int, Int], Int), acc.8470: Int) {
// [KnfOpt]   let _8471: Unit = Unit
// [KnfOpt]   let _8472: Tuple([Int, Int]) = Apply(stream.8468, [_8471, ])
// [KnfOpt]   let (ok.8473: Var({val: Some(Int)}), val.8474: Var({val: Some(Int)})) = _8472
// [KnfOpt]   let _8475: Int = Int(0)
// [KnfOpt]   if (ok.8473 == _8475) then {
// [KnfOpt]     let sum.104: Int = Var(acc.8470)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _8476: Int = Apply(f.8469, [acc.8470, val.8474, ])
// [KnfOpt]     Jump(fold.8467, [stream.8468, f.8469, _8476, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.8467, [under1200.103, add.8463, _8466, ])
// [KnfOpt] Inline threshold 5
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 0
// [KnfOpt] Inline decision le.83 accepted
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.8492: Int = (x.8493: Int, y.8494: Int) {
// [KnfOpt]   Add(x.8493, y.8494)
// [KnfOpt] }
// [KnfOpt] let _8495: Int = Int(0)
// [KnfOpt] let join fold.8496: Int = (stream.8497: Fun([Unit], Tuple([Int, Int])), f.8498: Fun([Int, Int], Int), acc.8499: Int) {
// [KnfOpt]   let _8500: Unit = Unit
// [KnfOpt]   let _8501: Tuple([Int, Int]) = Apply(stream.8497, [_8500, ])
// [KnfOpt]   let (ok.8502: Var({val: Some(Int)}), val.8503: Var({val: Some(Int)})) = _8501
// [KnfOpt]   let _8504: Int = Int(0)
// [KnfOpt]   if (ok.8502 == _8504) then {
// [KnfOpt]     let sum.104: Int = Var(acc.8499)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _8505: Int = Apply(f.8498, [acc.8499, val.8503, ])
// [KnfOpt]     Jump(fold.8496, [stream.8497, f.8498, _8505, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.8496, [under1200.103, add.8492, _8495, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(le) let _102: Fun([Int], Int) = Unit
// [KnfOpt] let rec aux.8506: Tuple([Int, Int]) = (u.8507: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.8508: Tuple([Int, Int]) = (u.8509: Var({val: Some(Unit)})) {
// [KnfOpt]     let _8510: Unit = Unit
// [KnfOpt]     let _8511: Tuple([Int, Int]) = Apply(over50.100, [_8510, ])
// [KnfOpt]     let (ok.8512: Var({val: Some(Int)}), val.8513: Var({val: Some(Int)})) = _8511
// [KnfOpt]     let _8514: Int = Int(0)
// [KnfOpt]     if (ok.8512 == _8514) then {
// [KnfOpt]       let _8515: Int = Int(0)
// [KnfOpt]       let _8516: Int = Int(0)
// [KnfOpt]       Tuple([_8515, _8516, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.8517: Int = Apply(_102, [val.8513, ])
// [KnfOpt]       let _8518: Int = Int(0)
// [KnfOpt]       if (r.8517 == _8518) then {
// [KnfOpt]         let _8519: Int = Int(1)
// [KnfOpt]         Tuple([_8519, val.8513, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _8520: Unit = Unit
// [KnfOpt]         Jump(aux.8508, [_8520, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.8508, [u.8507, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.8506)
// [KnfOpt] let rec add.8521: Int = (x.8522: Int, y.8523: Int) {
// [KnfOpt]   Add(x.8522, y.8523)
// [KnfOpt] }
// [KnfOpt] let _8524: Int = Int(0)
// [KnfOpt] let join fold.8525: Int = (stream.8526: Fun([Unit], Tuple([Int, Int])), f.8527: Fun([Int, Int], Int), acc.8528: Int) {
// [KnfOpt]   let _8529: Unit = Unit
// [KnfOpt]   let _8530: Tuple([Int, Int]) = Apply(stream.8526, [_8529, ])
// [KnfOpt]   let (ok.8531: Var({val: Some(Int)}), val.8532: Var({val: Some(Int)})) = _8530
// [KnfOpt]   let _8533: Int = Int(0)
// [KnfOpt]   if (ok.8531 == _8533) then {
// [KnfOpt]     let sum.104: Int = Var(acc.8528)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _8534: Int = Apply(f.8527, [acc.8528, val.8532, ])
// [KnfOpt]     Jump(fold.8525, [stream.8526, f.8527, _8534, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.8525, [under1200.103, add.8521, _8524, ])
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.8537: Int = (x.8538: Int, y.8539: Int) {
// [KnfOpt]   Add(x.8538, y.8539)
// [KnfOpt] }
// [KnfOpt] let _8540: Int = Int(0)
// [KnfOpt] let join fold.8541: Int = (stream.8542: Fun([Unit], Tuple([Int, Int])), f.8543: Fun([Int, Int], Int), acc.8544: Int) {
// [KnfOpt]   let _8545: Unit = Unit
// [KnfOpt]   let _8546: Tuple([Int, Int]) = Apply(stream.8542, [_8545, ])
// [KnfOpt]   let (ok.8547: Var({val: Some(Int)}), val.8548: Var({val: Some(Int)})) = _8546
// [KnfOpt]   let _8549: Int = Int(0)
// [KnfOpt]   if (ok.8547 == _8549) then {
// [KnfOpt]     let sum.104: Int = Var(acc.8544)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _8550: Int = Apply(f.8543, [acc.8544, val.8548, ])
// [KnfOpt]     Jump(fold.8541, [stream.8542, f.8543, _8550, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.8541, [under1200.103, add.8537, _8540, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(gt) let _99: Fun([Int], Int) = Unit
// [KnfOpt] let rec aux.8477: Tuple([Int, Int]) = (u.8478: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.8479: Tuple([Int, Int]) = (u.8480: Var({val: Some(Unit)})) {
// [KnfOpt]     let _8481: Unit = Unit
// [KnfOpt]     let _8482: Tuple([Int, Int]) = Apply(addone.97, [_8481, ])
// [KnfOpt]     let (ok.8483: Var({val: Some(Int)}), val.8484: Var({val: Some(Int)})) = _8482
// [KnfOpt]     let _8485: Int = Int(0)
// [KnfOpt]     if (ok.8483 == _8485) then {
// [KnfOpt]       let _8486: Int = Int(0)
// [KnfOpt]       let _8487: Int = Int(0)
// [KnfOpt]       Tuple([_8486, _8487, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.8488: Int = Apply(_99, [val.8484, ])
// [KnfOpt]       let _8489: Int = Int(0)
// [KnfOpt]       if (r.8488 == _8489) then {
// [KnfOpt]         let _8490: Int = Int(1)
// [KnfOpt]         Tuple([_8490, val.8484, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _8491: Unit = Unit
// [KnfOpt]         Jump(aux.8479, [_8491, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.8479, [u.8478, ])
// [KnfOpt] }
// [KnfOpt] let over50.100: Fun([Unit], Tuple([Int, Int])) = Var(aux.8477)
// [KnfOpt] let _101: Int = Int(1200)
// [KnfOpt] let rec aux.8535: Int = (y.8536: Int) {
// [KnfOpt]   if (y.8536 <= _101) then {
// [KnfOpt]     Int(0)
// [KnfOpt]   } else {
// [KnfOpt]     Int(1)
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] let _102: Fun([Int], Int) = Var(aux.8535)
// [KnfOpt] let rec aux.8551: Tuple([Int, Int]) = (u.8552: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.8553: Tuple([Int, Int]) = (u.8554: Var({val: Some(Unit)})) {
// [KnfOpt]     let _8555: Unit = Unit
// [KnfOpt]     let _8556: Tuple([Int, Int]) = Apply(over50.100, [_8555, ])
// [KnfOpt]     let (ok.8557: Var({val: Some(Int)}), val.8558: Var({val: Some(Int)})) = _8556
// [KnfOpt]     let _8559: Int = Int(0)
// [KnfOpt]     if (ok.8557 == _8559) then {
// [KnfOpt]       let _8560: Int = Int(0)
// [KnfOpt]       let _8561: Int = Int(0)
// [KnfOpt]       Tuple([_8560, _8561, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.8562: Int = Apply(_102, [val.8558, ])
// [KnfOpt]       let _8563: Int = Int(0)
// [KnfOpt]       if (r.8562 == _8563) then {
// [KnfOpt]         let _8564: Int = Int(1)
// [KnfOpt]         Tuple([_8564, val.8558, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _8565: Unit = Unit
// [KnfOpt]         Jump(aux.8553, [_8565, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.8553, [u.8552, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.8551)
// [KnfOpt] let rec add.8566: Int = (x.8567: Int, y.8568: Int) {
// [KnfOpt]   Add(x.8567, y.8568)
// [KnfOpt] }
// [KnfOpt] let _8569: Int = Int(0)
// [KnfOpt] let join fold.8570: Int = (stream.8571: Fun([Unit], Tuple([Int, Int])), f.8572: Fun([Int, Int], Int), acc.8573: Int) {
// [KnfOpt]   let _8574: Unit = Unit
// [KnfOpt]   let _8575: Tuple([Int, Int]) = Apply(stream.8571, [_8574, ])
// [KnfOpt]   let (ok.8576: Var({val: Some(Int)}), val.8577: Var({val: Some(Int)})) = _8575
// [KnfOpt]   let _8578: Int = Int(0)
// [KnfOpt]   if (ok.8576 == _8578) then {
// [KnfOpt]     let sum.104: Int = Var(acc.8573)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _8579: Int = Apply(f.8572, [acc.8573, val.8577, ])
// [KnfOpt]     Jump(fold.8570, [stream.8571, f.8572, _8579, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.8570, [under1200.103, add.8566, _8569, ])
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 5
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 0
// [KnfOpt] Inline decision le.83 accepted
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.8582: Int = (x.8583: Int, y.8584: Int) {
// [KnfOpt]   Add(x.8583, y.8584)
// [KnfOpt] }
// [KnfOpt] let _8585: Int = Int(0)
// [KnfOpt] let join fold.8586: Int = (stream.8587: Fun([Unit], Tuple([Int, Int])), f.8588: Fun([Int, Int], Int), acc.8589: Int) {
// [KnfOpt]   let _8590: Unit = Unit
// [KnfOpt]   let _8591: Tuple([Int, Int]) = Apply(stream.8587, [_8590, ])
// [KnfOpt]   let (ok.8592: Var({val: Some(Int)}), val.8593: Var({val: Some(Int)})) = _8591
// [KnfOpt]   let _8594: Int = Int(0)
// [KnfOpt]   if (ok.8592 == _8594) then {
// [KnfOpt]     let sum.104: Int = Var(acc.8589)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _8595: Int = Apply(f.8588, [acc.8589, val.8593, ])
// [KnfOpt]     Jump(fold.8586, [stream.8587, f.8588, _8595, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.8586, [under1200.103, add.8582, _8585, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(le) let _102: Fun([Int], Int) = Unit
// [KnfOpt] let rec aux.8596: Tuple([Int, Int]) = (u.8597: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.8598: Tuple([Int, Int]) = (u.8599: Var({val: Some(Unit)})) {
// [KnfOpt]     let _8600: Unit = Unit
// [KnfOpt]     let _8601: Tuple([Int, Int]) = Apply(over50.100, [_8600, ])
// [KnfOpt]     let (ok.8602: Var({val: Some(Int)}), val.8603: Var({val: Some(Int)})) = _8601
// [KnfOpt]     let _8604: Int = Int(0)
// [KnfOpt]     if (ok.8602 == _8604) then {
// [KnfOpt]       let _8605: Int = Int(0)
// [KnfOpt]       let _8606: Int = Int(0)
// [KnfOpt]       Tuple([_8605, _8606, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.8607: Int = Apply(_102, [val.8603, ])
// [KnfOpt]       let _8608: Int = Int(0)
// [KnfOpt]       if (r.8607 == _8608) then {
// [KnfOpt]         let _8609: Int = Int(1)
// [KnfOpt]         Tuple([_8609, val.8603, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _8610: Unit = Unit
// [KnfOpt]         Jump(aux.8598, [_8610, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.8598, [u.8597, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.8596)
// [KnfOpt] let rec add.8611: Int = (x.8612: Int, y.8613: Int) {
// [KnfOpt]   Add(x.8612, y.8613)
// [KnfOpt] }
// [KnfOpt] let _8614: Int = Int(0)
// [KnfOpt] let join fold.8615: Int = (stream.8616: Fun([Unit], Tuple([Int, Int])), f.8617: Fun([Int, Int], Int), acc.8618: Int) {
// [KnfOpt]   let _8619: Unit = Unit
// [KnfOpt]   let _8620: Tuple([Int, Int]) = Apply(stream.8616, [_8619, ])
// [KnfOpt]   let (ok.8621: Var({val: Some(Int)}), val.8622: Var({val: Some(Int)})) = _8620
// [KnfOpt]   let _8623: Int = Int(0)
// [KnfOpt]   if (ok.8621 == _8623) then {
// [KnfOpt]     let sum.104: Int = Var(acc.8618)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _8624: Int = Apply(f.8617, [acc.8618, val.8622, ])
// [KnfOpt]     Jump(fold.8615, [stream.8616, f.8617, _8624, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.8615, [under1200.103, add.8611, _8614, ])
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.8627: Int = (x.8628: Int, y.8629: Int) {
// [KnfOpt]   Add(x.8628, y.8629)
// [KnfOpt] }
// [KnfOpt] let _8630: Int = Int(0)
// [KnfOpt] let join fold.8631: Int = (stream.8632: Fun([Unit], Tuple([Int, Int])), f.8633: Fun([Int, Int], Int), acc.8634: Int) {
// [KnfOpt]   let _8635: Unit = Unit
// [KnfOpt]   let _8636: Tuple([Int, Int]) = Apply(stream.8632, [_8635, ])
// [KnfOpt]   let (ok.8637: Var({val: Some(Int)}), val.8638: Var({val: Some(Int)})) = _8636
// [KnfOpt]   let _8639: Int = Int(0)
// [KnfOpt]   if (ok.8637 == _8639) then {
// [KnfOpt]     let sum.104: Int = Var(acc.8634)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _8640: Int = Apply(f.8633, [acc.8634, val.8638, ])
// [KnfOpt]     Jump(fold.8631, [stream.8632, f.8633, _8640, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.8631, [under1200.103, add.8627, _8630, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let over50.100: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let _101: Int = Int(1200)
// [KnfOpt] let rec aux.8625: Int = (y.8626: Int) {
// [KnfOpt]   if (y.8626 <= _101) then {
// [KnfOpt]     Int(0)
// [KnfOpt]   } else {
// [KnfOpt]     Int(1)
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] let _102: Fun([Int], Int) = Var(aux.8625)
// [KnfOpt] let rec aux.8641: Tuple([Int, Int]) = (u.8642: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.8643: Tuple([Int, Int]) = (u.8644: Var({val: Some(Unit)})) {
// [KnfOpt]     let _8645: Unit = Unit
// [KnfOpt]     let _8646: Tuple([Int, Int]) = Apply(over50.100, [_8645, ])
// [KnfOpt]     let (ok.8647: Var({val: Some(Int)}), val.8648: Var({val: Some(Int)})) = _8646
// [KnfOpt]     let _8649: Int = Int(0)
// [KnfOpt]     if (ok.8647 == _8649) then {
// [KnfOpt]       let _8650: Int = Int(0)
// [KnfOpt]       let _8651: Int = Int(0)
// [KnfOpt]       Tuple([_8650, _8651, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.8652: Int = Apply(_102, [val.8648, ])
// [KnfOpt]       let _8653: Int = Int(0)
// [KnfOpt]       if (r.8652 == _8653) then {
// [KnfOpt]         let _8654: Int = Int(1)
// [KnfOpt]         Tuple([_8654, val.8648, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _8655: Unit = Unit
// [KnfOpt]         Jump(aux.8643, [_8655, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.8643, [u.8642, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.8641)
// [KnfOpt] let rec add.8656: Int = (x.8657: Int, y.8658: Int) {
// [KnfOpt]   Add(x.8657, y.8658)
// [KnfOpt] }
// [KnfOpt] let _8659: Int = Int(0)
// [KnfOpt] let join fold.8660: Int = (stream.8661: Fun([Unit], Tuple([Int, Int])), f.8662: Fun([Int, Int], Int), acc.8663: Int) {
// [KnfOpt]   let _8664: Unit = Unit
// [KnfOpt]   let _8665: Tuple([Int, Int]) = Apply(stream.8661, [_8664, ])
// [KnfOpt]   let (ok.8666: Var({val: Some(Int)}), val.8667: Var({val: Some(Int)})) = _8665
// [KnfOpt]   let _8668: Int = Int(0)
// [KnfOpt]   if (ok.8666 == _8668) then {
// [KnfOpt]     let sum.104: Int = Var(acc.8663)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _8669: Int = Apply(f.8662, [acc.8663, val.8667, ])
// [KnfOpt]     Jump(fold.8660, [stream.8661, f.8662, _8669, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.8660, [under1200.103, add.8656, _8659, ])
// [KnfOpt] Inline threshold 5
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 0
// [KnfOpt] Inline decision le.83 accepted
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.8685: Int = (x.8686: Int, y.8687: Int) {
// [KnfOpt]   Add(x.8686, y.8687)
// [KnfOpt] }
// [KnfOpt] let _8688: Int = Int(0)
// [KnfOpt] let join fold.8689: Int = (stream.8690: Fun([Unit], Tuple([Int, Int])), f.8691: Fun([Int, Int], Int), acc.8692: Int) {
// [KnfOpt]   let _8693: Unit = Unit
// [KnfOpt]   let _8694: Tuple([Int, Int]) = Apply(stream.8690, [_8693, ])
// [KnfOpt]   let (ok.8695: Var({val: Some(Int)}), val.8696: Var({val: Some(Int)})) = _8694
// [KnfOpt]   let _8697: Int = Int(0)
// [KnfOpt]   if (ok.8695 == _8697) then {
// [KnfOpt]     let sum.104: Int = Var(acc.8692)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _8698: Int = Apply(f.8691, [acc.8692, val.8696, ])
// [KnfOpt]     Jump(fold.8689, [stream.8690, f.8691, _8698, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.8689, [under1200.103, add.8685, _8688, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(le) let _102: Fun([Int], Int) = Unit
// [KnfOpt] let rec aux.8699: Tuple([Int, Int]) = (u.8700: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.8701: Tuple([Int, Int]) = (u.8702: Var({val: Some(Unit)})) {
// [KnfOpt]     let _8703: Unit = Unit
// [KnfOpt]     let _8704: Tuple([Int, Int]) = Apply(over50.100, [_8703, ])
// [KnfOpt]     let (ok.8705: Var({val: Some(Int)}), val.8706: Var({val: Some(Int)})) = _8704
// [KnfOpt]     let _8707: Int = Int(0)
// [KnfOpt]     if (ok.8705 == _8707) then {
// [KnfOpt]       let _8708: Int = Int(0)
// [KnfOpt]       let _8709: Int = Int(0)
// [KnfOpt]       Tuple([_8708, _8709, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.8710: Int = Apply(_102, [val.8706, ])
// [KnfOpt]       let _8711: Int = Int(0)
// [KnfOpt]       if (r.8710 == _8711) then {
// [KnfOpt]         let _8712: Int = Int(1)
// [KnfOpt]         Tuple([_8712, val.8706, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _8713: Unit = Unit
// [KnfOpt]         Jump(aux.8701, [_8713, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.8701, [u.8700, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.8699)
// [KnfOpt] let rec add.8714: Int = (x.8715: Int, y.8716: Int) {
// [KnfOpt]   Add(x.8715, y.8716)
// [KnfOpt] }
// [KnfOpt] let _8717: Int = Int(0)
// [KnfOpt] let join fold.8718: Int = (stream.8719: Fun([Unit], Tuple([Int, Int])), f.8720: Fun([Int, Int], Int), acc.8721: Int) {
// [KnfOpt]   let _8722: Unit = Unit
// [KnfOpt]   let _8723: Tuple([Int, Int]) = Apply(stream.8719, [_8722, ])
// [KnfOpt]   let (ok.8724: Var({val: Some(Int)}), val.8725: Var({val: Some(Int)})) = _8723
// [KnfOpt]   let _8726: Int = Int(0)
// [KnfOpt]   if (ok.8724 == _8726) then {
// [KnfOpt]     let sum.104: Int = Var(acc.8721)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _8727: Int = Apply(f.8720, [acc.8721, val.8725, ])
// [KnfOpt]     Jump(fold.8718, [stream.8719, f.8720, _8727, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.8718, [under1200.103, add.8714, _8717, ])
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.8730: Int = (x.8731: Int, y.8732: Int) {
// [KnfOpt]   Add(x.8731, y.8732)
// [KnfOpt] }
// [KnfOpt] let _8733: Int = Int(0)
// [KnfOpt] let join fold.8734: Int = (stream.8735: Fun([Unit], Tuple([Int, Int])), f.8736: Fun([Int, Int], Int), acc.8737: Int) {
// [KnfOpt]   let _8738: Unit = Unit
// [KnfOpt]   let _8739: Tuple([Int, Int]) = Apply(stream.8735, [_8738, ])
// [KnfOpt]   let (ok.8740: Var({val: Some(Int)}), val.8741: Var({val: Some(Int)})) = _8739
// [KnfOpt]   let _8742: Int = Int(0)
// [KnfOpt]   if (ok.8740 == _8742) then {
// [KnfOpt]     let sum.104: Int = Var(acc.8737)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _8743: Int = Apply(f.8736, [acc.8737, val.8741, ])
// [KnfOpt]     Jump(fold.8734, [stream.8735, f.8736, _8743, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.8734, [under1200.103, add.8730, _8733, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(addx) let _96: Fun([Int], Int) = Unit
// [KnfOpt] let rec aux.8378: Tuple([Int, Int]) = (u.8379: Var({val: Some(Unit)})) {
// [KnfOpt]   let _8380: Unit = Unit
// [KnfOpt]   let _8381: Tuple([Int, Int]) = Apply(catt.94, [_8380, ])
// [KnfOpt]   let (ok.8382: Var({val: Some(Int)}), val.8383: Var({val: Some(Int)})) = _8381
// [KnfOpt]   let _8384: Int = Int(0)
// [KnfOpt]   if (ok.8382 == _8384) then {
// [KnfOpt]     let _8385: Int = Int(0)
// [KnfOpt]     let _8386: Int = Int(0)
// [KnfOpt]     Tuple([_8385, _8386, ])
// [KnfOpt]   } else {
// [KnfOpt]     let _8387: Int = Int(1)
// [KnfOpt]     let _8388: Int = Apply(_96, [val.8383, ])
// [KnfOpt]     Tuple([_8387, _8388, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] let addone.97: Fun([Unit], Tuple([Int, Int])) = Var(aux.8378)
// [KnfOpt] let _98: Int = Int(50)
// [KnfOpt] let rec aux.8580: Int = (y.8581: Int) {
// [KnfOpt]   if (_98 <= y.8581) then {
// [KnfOpt]     Int(0)
// [KnfOpt]   } else {
// [KnfOpt]     Int(1)
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] let _99: Fun([Int], Int) = Var(aux.8580)
// [KnfOpt] let rec aux.8670: Tuple([Int, Int]) = (u.8671: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.8672: Tuple([Int, Int]) = (u.8673: Var({val: Some(Unit)})) {
// [KnfOpt]     let _8674: Unit = Unit
// [KnfOpt]     let _8675: Tuple([Int, Int]) = Apply(addone.97, [_8674, ])
// [KnfOpt]     let (ok.8676: Var({val: Some(Int)}), val.8677: Var({val: Some(Int)})) = _8675
// [KnfOpt]     let _8678: Int = Int(0)
// [KnfOpt]     if (ok.8676 == _8678) then {
// [KnfOpt]       let _8679: Int = Int(0)
// [KnfOpt]       let _8680: Int = Int(0)
// [KnfOpt]       Tuple([_8679, _8680, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.8681: Int = Apply(_99, [val.8677, ])
// [KnfOpt]       let _8682: Int = Int(0)
// [KnfOpt]       if (r.8681 == _8682) then {
// [KnfOpt]         let _8683: Int = Int(1)
// [KnfOpt]         Tuple([_8683, val.8677, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _8684: Unit = Unit
// [KnfOpt]         Jump(aux.8672, [_8684, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.8672, [u.8671, ])
// [KnfOpt] }
// [KnfOpt] let over50.100: Fun([Unit], Tuple([Int, Int])) = Var(aux.8670)
// [KnfOpt] let _101: Int = Int(1200)
// [KnfOpt] let rec aux.8728: Int = (y.8729: Int) {
// [KnfOpt]   if (y.8729 <= _101) then {
// [KnfOpt]     Int(0)
// [KnfOpt]   } else {
// [KnfOpt]     Int(1)
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] let _102: Fun([Int], Int) = Var(aux.8728)
// [KnfOpt] let rec aux.8744: Tuple([Int, Int]) = (u.8745: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.8746: Tuple([Int, Int]) = (u.8747: Var({val: Some(Unit)})) {
// [KnfOpt]     let _8748: Unit = Unit
// [KnfOpt]     let _8749: Tuple([Int, Int]) = Apply(over50.100, [_8748, ])
// [KnfOpt]     let (ok.8750: Var({val: Some(Int)}), val.8751: Var({val: Some(Int)})) = _8749
// [KnfOpt]     let _8752: Int = Int(0)
// [KnfOpt]     if (ok.8750 == _8752) then {
// [KnfOpt]       let _8753: Int = Int(0)
// [KnfOpt]       let _8754: Int = Int(0)
// [KnfOpt]       Tuple([_8753, _8754, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.8755: Int = Apply(_102, [val.8751, ])
// [KnfOpt]       let _8756: Int = Int(0)
// [KnfOpt]       if (r.8755 == _8756) then {
// [KnfOpt]         let _8757: Int = Int(1)
// [KnfOpt]         Tuple([_8757, val.8751, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _8758: Unit = Unit
// [KnfOpt]         Jump(aux.8746, [_8758, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.8746, [u.8745, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.8744)
// [KnfOpt] let rec add.8759: Int = (x.8760: Int, y.8761: Int) {
// [KnfOpt]   Add(x.8760, y.8761)
// [KnfOpt] }
// [KnfOpt] let _8762: Int = Int(0)
// [KnfOpt] let join fold.8763: Int = (stream.8764: Fun([Unit], Tuple([Int, Int])), f.8765: Fun([Int, Int], Int), acc.8766: Int) {
// [KnfOpt]   let _8767: Unit = Unit
// [KnfOpt]   let _8768: Tuple([Int, Int]) = Apply(stream.8764, [_8767, ])
// [KnfOpt]   let (ok.8769: Var({val: Some(Int)}), val.8770: Var({val: Some(Int)})) = _8768
// [KnfOpt]   let _8771: Int = Int(0)
// [KnfOpt]   if (ok.8769 == _8771) then {
// [KnfOpt]     let sum.104: Int = Var(acc.8766)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _8772: Int = Apply(f.8765, [acc.8766, val.8770, ])
// [KnfOpt]     Jump(fold.8763, [stream.8764, f.8765, _8772, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.8763, [under1200.103, add.8759, _8762, ])
// [KnfOpt] Inline threshold 20
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 0
// [KnfOpt] Inline decision map.1 accepted
// [KnfOpt] Inline threshold 5
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 0
// [KnfOpt] Inline decision gt.79 accepted
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 5
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 0
// [KnfOpt] Inline decision le.83 accepted
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.8775: Int = (x.8776: Int, y.8777: Int) {
// [KnfOpt]   Add(x.8776, y.8777)
// [KnfOpt] }
// [KnfOpt] let _8778: Int = Int(0)
// [KnfOpt] let join fold.8779: Int = (stream.8780: Fun([Unit], Tuple([Int, Int])), f.8781: Fun([Int, Int], Int), acc.8782: Int) {
// [KnfOpt]   let _8783: Unit = Unit
// [KnfOpt]   let _8784: Tuple([Int, Int]) = Apply(stream.8780, [_8783, ])
// [KnfOpt]   let (ok.8785: Var({val: Some(Int)}), val.8786: Var({val: Some(Int)})) = _8784
// [KnfOpt]   let _8787: Int = Int(0)
// [KnfOpt]   if (ok.8785 == _8787) then {
// [KnfOpt]     let sum.104: Int = Var(acc.8782)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _8788: Int = Apply(f.8781, [acc.8782, val.8786, ])
// [KnfOpt]     Jump(fold.8779, [stream.8780, f.8781, _8788, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.8779, [under1200.103, add.8775, _8778, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(le) let _102: Fun([Int], Int) = Unit
// [KnfOpt] let rec aux.8789: Tuple([Int, Int]) = (u.8790: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.8791: Tuple([Int, Int]) = (u.8792: Var({val: Some(Unit)})) {
// [KnfOpt]     let _8793: Unit = Unit
// [KnfOpt]     let _8794: Tuple([Int, Int]) = Apply(over50.100, [_8793, ])
// [KnfOpt]     let (ok.8795: Var({val: Some(Int)}), val.8796: Var({val: Some(Int)})) = _8794
// [KnfOpt]     let _8797: Int = Int(0)
// [KnfOpt]     if (ok.8795 == _8797) then {
// [KnfOpt]       let _8798: Int = Int(0)
// [KnfOpt]       let _8799: Int = Int(0)
// [KnfOpt]       Tuple([_8798, _8799, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.8800: Int = Apply(_102, [val.8796, ])
// [KnfOpt]       let _8801: Int = Int(0)
// [KnfOpt]       if (r.8800 == _8801) then {
// [KnfOpt]         let _8802: Int = Int(1)
// [KnfOpt]         Tuple([_8802, val.8796, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _8803: Unit = Unit
// [KnfOpt]         Jump(aux.8791, [_8803, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.8791, [u.8790, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.8789)
// [KnfOpt] let rec add.8804: Int = (x.8805: Int, y.8806: Int) {
// [KnfOpt]   Add(x.8805, y.8806)
// [KnfOpt] }
// [KnfOpt] let _8807: Int = Int(0)
// [KnfOpt] let join fold.8808: Int = (stream.8809: Fun([Unit], Tuple([Int, Int])), f.8810: Fun([Int, Int], Int), acc.8811: Int) {
// [KnfOpt]   let _8812: Unit = Unit
// [KnfOpt]   let _8813: Tuple([Int, Int]) = Apply(stream.8809, [_8812, ])
// [KnfOpt]   let (ok.8814: Var({val: Some(Int)}), val.8815: Var({val: Some(Int)})) = _8813
// [KnfOpt]   let _8816: Int = Int(0)
// [KnfOpt]   if (ok.8814 == _8816) then {
// [KnfOpt]     let sum.104: Int = Var(acc.8811)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _8817: Int = Apply(f.8810, [acc.8811, val.8815, ])
// [KnfOpt]     Jump(fold.8808, [stream.8809, f.8810, _8817, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.8808, [under1200.103, add.8804, _8807, ])
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.8820: Int = (x.8821: Int, y.8822: Int) {
// [KnfOpt]   Add(x.8821, y.8822)
// [KnfOpt] }
// [KnfOpt] let _8823: Int = Int(0)
// [KnfOpt] let join fold.8824: Int = (stream.8825: Fun([Unit], Tuple([Int, Int])), f.8826: Fun([Int, Int], Int), acc.8827: Int) {
// [KnfOpt]   let _8828: Unit = Unit
// [KnfOpt]   let _8829: Tuple([Int, Int]) = Apply(stream.8825, [_8828, ])
// [KnfOpt]   let (ok.8830: Var({val: Some(Int)}), val.8831: Var({val: Some(Int)})) = _8829
// [KnfOpt]   let _8832: Int = Int(0)
// [KnfOpt]   if (ok.8830 == _8832) then {
// [KnfOpt]     let sum.104: Int = Var(acc.8827)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _8833: Int = Apply(f.8826, [acc.8827, val.8831, ])
// [KnfOpt]     Jump(fold.8824, [stream.8825, f.8826, _8833, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.8824, [under1200.103, add.8820, _8823, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let over50.100: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let _101: Int = Int(1200)
// [KnfOpt] let rec aux.8818: Int = (y.8819: Int) {
// [KnfOpt]   if (y.8819 <= _101) then {
// [KnfOpt]     Int(0)
// [KnfOpt]   } else {
// [KnfOpt]     Int(1)
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] let _102: Fun([Int], Int) = Var(aux.8818)
// [KnfOpt] let rec aux.8834: Tuple([Int, Int]) = (u.8835: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.8836: Tuple([Int, Int]) = (u.8837: Var({val: Some(Unit)})) {
// [KnfOpt]     let _8838: Unit = Unit
// [KnfOpt]     let _8839: Tuple([Int, Int]) = Apply(over50.100, [_8838, ])
// [KnfOpt]     let (ok.8840: Var({val: Some(Int)}), val.8841: Var({val: Some(Int)})) = _8839
// [KnfOpt]     let _8842: Int = Int(0)
// [KnfOpt]     if (ok.8840 == _8842) then {
// [KnfOpt]       let _8843: Int = Int(0)
// [KnfOpt]       let _8844: Int = Int(0)
// [KnfOpt]       Tuple([_8843, _8844, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.8845: Int = Apply(_102, [val.8841, ])
// [KnfOpt]       let _8846: Int = Int(0)
// [KnfOpt]       if (r.8845 == _8846) then {
// [KnfOpt]         let _8847: Int = Int(1)
// [KnfOpt]         Tuple([_8847, val.8841, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _8848: Unit = Unit
// [KnfOpt]         Jump(aux.8836, [_8848, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.8836, [u.8835, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.8834)
// [KnfOpt] let rec add.8849: Int = (x.8850: Int, y.8851: Int) {
// [KnfOpt]   Add(x.8850, y.8851)
// [KnfOpt] }
// [KnfOpt] let _8852: Int = Int(0)
// [KnfOpt] let join fold.8853: Int = (stream.8854: Fun([Unit], Tuple([Int, Int])), f.8855: Fun([Int, Int], Int), acc.8856: Int) {
// [KnfOpt]   let _8857: Unit = Unit
// [KnfOpt]   let _8858: Tuple([Int, Int]) = Apply(stream.8854, [_8857, ])
// [KnfOpt]   let (ok.8859: Var({val: Some(Int)}), val.8860: Var({val: Some(Int)})) = _8858
// [KnfOpt]   let _8861: Int = Int(0)
// [KnfOpt]   if (ok.8859 == _8861) then {
// [KnfOpt]     let sum.104: Int = Var(acc.8856)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _8862: Int = Apply(f.8855, [acc.8856, val.8860, ])
// [KnfOpt]     Jump(fold.8853, [stream.8854, f.8855, _8862, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.8853, [under1200.103, add.8849, _8852, ])
// [KnfOpt] Inline threshold 5
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 0
// [KnfOpt] Inline decision le.83 accepted
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.8878: Int = (x.8879: Int, y.8880: Int) {
// [KnfOpt]   Add(x.8879, y.8880)
// [KnfOpt] }
// [KnfOpt] let _8881: Int = Int(0)
// [KnfOpt] let join fold.8882: Int = (stream.8883: Fun([Unit], Tuple([Int, Int])), f.8884: Fun([Int, Int], Int), acc.8885: Int) {
// [KnfOpt]   let _8886: Unit = Unit
// [KnfOpt]   let _8887: Tuple([Int, Int]) = Apply(stream.8883, [_8886, ])
// [KnfOpt]   let (ok.8888: Var({val: Some(Int)}), val.8889: Var({val: Some(Int)})) = _8887
// [KnfOpt]   let _8890: Int = Int(0)
// [KnfOpt]   if (ok.8888 == _8890) then {
// [KnfOpt]     let sum.104: Int = Var(acc.8885)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _8891: Int = Apply(f.8884, [acc.8885, val.8889, ])
// [KnfOpt]     Jump(fold.8882, [stream.8883, f.8884, _8891, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.8882, [under1200.103, add.8878, _8881, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(le) let _102: Fun([Int], Int) = Unit
// [KnfOpt] let rec aux.8892: Tuple([Int, Int]) = (u.8893: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.8894: Tuple([Int, Int]) = (u.8895: Var({val: Some(Unit)})) {
// [KnfOpt]     let _8896: Unit = Unit
// [KnfOpt]     let _8897: Tuple([Int, Int]) = Apply(over50.100, [_8896, ])
// [KnfOpt]     let (ok.8898: Var({val: Some(Int)}), val.8899: Var({val: Some(Int)})) = _8897
// [KnfOpt]     let _8900: Int = Int(0)
// [KnfOpt]     if (ok.8898 == _8900) then {
// [KnfOpt]       let _8901: Int = Int(0)
// [KnfOpt]       let _8902: Int = Int(0)
// [KnfOpt]       Tuple([_8901, _8902, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.8903: Int = Apply(_102, [val.8899, ])
// [KnfOpt]       let _8904: Int = Int(0)
// [KnfOpt]       if (r.8903 == _8904) then {
// [KnfOpt]         let _8905: Int = Int(1)
// [KnfOpt]         Tuple([_8905, val.8899, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _8906: Unit = Unit
// [KnfOpt]         Jump(aux.8894, [_8906, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.8894, [u.8893, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.8892)
// [KnfOpt] let rec add.8907: Int = (x.8908: Int, y.8909: Int) {
// [KnfOpt]   Add(x.8908, y.8909)
// [KnfOpt] }
// [KnfOpt] let _8910: Int = Int(0)
// [KnfOpt] let join fold.8911: Int = (stream.8912: Fun([Unit], Tuple([Int, Int])), f.8913: Fun([Int, Int], Int), acc.8914: Int) {
// [KnfOpt]   let _8915: Unit = Unit
// [KnfOpt]   let _8916: Tuple([Int, Int]) = Apply(stream.8912, [_8915, ])
// [KnfOpt]   let (ok.8917: Var({val: Some(Int)}), val.8918: Var({val: Some(Int)})) = _8916
// [KnfOpt]   let _8919: Int = Int(0)
// [KnfOpt]   if (ok.8917 == _8919) then {
// [KnfOpt]     let sum.104: Int = Var(acc.8914)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _8920: Int = Apply(f.8913, [acc.8914, val.8918, ])
// [KnfOpt]     Jump(fold.8911, [stream.8912, f.8913, _8920, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.8911, [under1200.103, add.8907, _8910, ])
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.8923: Int = (x.8924: Int, y.8925: Int) {
// [KnfOpt]   Add(x.8924, y.8925)
// [KnfOpt] }
// [KnfOpt] let _8926: Int = Int(0)
// [KnfOpt] let join fold.8927: Int = (stream.8928: Fun([Unit], Tuple([Int, Int])), f.8929: Fun([Int, Int], Int), acc.8930: Int) {
// [KnfOpt]   let _8931: Unit = Unit
// [KnfOpt]   let _8932: Tuple([Int, Int]) = Apply(stream.8928, [_8931, ])
// [KnfOpt]   let (ok.8933: Var({val: Some(Int)}), val.8934: Var({val: Some(Int)})) = _8932
// [KnfOpt]   let _8935: Int = Int(0)
// [KnfOpt]   if (ok.8933 == _8935) then {
// [KnfOpt]     let sum.104: Int = Var(acc.8930)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _8936: Int = Apply(f.8929, [acc.8930, val.8934, ])
// [KnfOpt]     Jump(fold.8927, [stream.8928, f.8929, _8936, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.8927, [under1200.103, add.8923, _8926, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(gt) let _99: Fun([Int], Int) = Unit
// [KnfOpt] let rec aux.8863: Tuple([Int, Int]) = (u.8864: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.8865: Tuple([Int, Int]) = (u.8866: Var({val: Some(Unit)})) {
// [KnfOpt]     let _8867: Unit = Unit
// [KnfOpt]     let _8868: Tuple([Int, Int]) = Apply(addone.97, [_8867, ])
// [KnfOpt]     let (ok.8869: Var({val: Some(Int)}), val.8870: Var({val: Some(Int)})) = _8868
// [KnfOpt]     let _8871: Int = Int(0)
// [KnfOpt]     if (ok.8869 == _8871) then {
// [KnfOpt]       let _8872: Int = Int(0)
// [KnfOpt]       let _8873: Int = Int(0)
// [KnfOpt]       Tuple([_8872, _8873, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.8874: Int = Apply(_99, [val.8870, ])
// [KnfOpt]       let _8875: Int = Int(0)
// [KnfOpt]       if (r.8874 == _8875) then {
// [KnfOpt]         let _8876: Int = Int(1)
// [KnfOpt]         Tuple([_8876, val.8870, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _8877: Unit = Unit
// [KnfOpt]         Jump(aux.8865, [_8877, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.8865, [u.8864, ])
// [KnfOpt] }
// [KnfOpt] let over50.100: Fun([Unit], Tuple([Int, Int])) = Var(aux.8863)
// [KnfOpt] let _101: Int = Int(1200)
// [KnfOpt] let rec aux.8921: Int = (y.8922: Int) {
// [KnfOpt]   if (y.8922 <= _101) then {
// [KnfOpt]     Int(0)
// [KnfOpt]   } else {
// [KnfOpt]     Int(1)
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] let _102: Fun([Int], Int) = Var(aux.8921)
// [KnfOpt] let rec aux.8937: Tuple([Int, Int]) = (u.8938: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.8939: Tuple([Int, Int]) = (u.8940: Var({val: Some(Unit)})) {
// [KnfOpt]     let _8941: Unit = Unit
// [KnfOpt]     let _8942: Tuple([Int, Int]) = Apply(over50.100, [_8941, ])
// [KnfOpt]     let (ok.8943: Var({val: Some(Int)}), val.8944: Var({val: Some(Int)})) = _8942
// [KnfOpt]     let _8945: Int = Int(0)
// [KnfOpt]     if (ok.8943 == _8945) then {
// [KnfOpt]       let _8946: Int = Int(0)
// [KnfOpt]       let _8947: Int = Int(0)
// [KnfOpt]       Tuple([_8946, _8947, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.8948: Int = Apply(_102, [val.8944, ])
// [KnfOpt]       let _8949: Int = Int(0)
// [KnfOpt]       if (r.8948 == _8949) then {
// [KnfOpt]         let _8950: Int = Int(1)
// [KnfOpt]         Tuple([_8950, val.8944, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _8951: Unit = Unit
// [KnfOpt]         Jump(aux.8939, [_8951, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.8939, [u.8938, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.8937)
// [KnfOpt] let rec add.8952: Int = (x.8953: Int, y.8954: Int) {
// [KnfOpt]   Add(x.8953, y.8954)
// [KnfOpt] }
// [KnfOpt] let _8955: Int = Int(0)
// [KnfOpt] let join fold.8956: Int = (stream.8957: Fun([Unit], Tuple([Int, Int])), f.8958: Fun([Int, Int], Int), acc.8959: Int) {
// [KnfOpt]   let _8960: Unit = Unit
// [KnfOpt]   let _8961: Tuple([Int, Int]) = Apply(stream.8957, [_8960, ])
// [KnfOpt]   let (ok.8962: Var({val: Some(Int)}), val.8963: Var({val: Some(Int)})) = _8961
// [KnfOpt]   let _8964: Int = Int(0)
// [KnfOpt]   if (ok.8962 == _8964) then {
// [KnfOpt]     let sum.104: Int = Var(acc.8959)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _8965: Int = Apply(f.8958, [acc.8959, val.8963, ])
// [KnfOpt]     Jump(fold.8956, [stream.8957, f.8958, _8965, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.8956, [under1200.103, add.8952, _8955, ])
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 5
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 0
// [KnfOpt] Inline decision le.83 accepted
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.8968: Int = (x.8969: Int, y.8970: Int) {
// [KnfOpt]   Add(x.8969, y.8970)
// [KnfOpt] }
// [KnfOpt] let _8971: Int = Int(0)
// [KnfOpt] let join fold.8972: Int = (stream.8973: Fun([Unit], Tuple([Int, Int])), f.8974: Fun([Int, Int], Int), acc.8975: Int) {
// [KnfOpt]   let _8976: Unit = Unit
// [KnfOpt]   let _8977: Tuple([Int, Int]) = Apply(stream.8973, [_8976, ])
// [KnfOpt]   let (ok.8978: Var({val: Some(Int)}), val.8979: Var({val: Some(Int)})) = _8977
// [KnfOpt]   let _8980: Int = Int(0)
// [KnfOpt]   if (ok.8978 == _8980) then {
// [KnfOpt]     let sum.104: Int = Var(acc.8975)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _8981: Int = Apply(f.8974, [acc.8975, val.8979, ])
// [KnfOpt]     Jump(fold.8972, [stream.8973, f.8974, _8981, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.8972, [under1200.103, add.8968, _8971, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(le) let _102: Fun([Int], Int) = Unit
// [KnfOpt] let rec aux.8982: Tuple([Int, Int]) = (u.8983: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.8984: Tuple([Int, Int]) = (u.8985: Var({val: Some(Unit)})) {
// [KnfOpt]     let _8986: Unit = Unit
// [KnfOpt]     let _8987: Tuple([Int, Int]) = Apply(over50.100, [_8986, ])
// [KnfOpt]     let (ok.8988: Var({val: Some(Int)}), val.8989: Var({val: Some(Int)})) = _8987
// [KnfOpt]     let _8990: Int = Int(0)
// [KnfOpt]     if (ok.8988 == _8990) then {
// [KnfOpt]       let _8991: Int = Int(0)
// [KnfOpt]       let _8992: Int = Int(0)
// [KnfOpt]       Tuple([_8991, _8992, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.8993: Int = Apply(_102, [val.8989, ])
// [KnfOpt]       let _8994: Int = Int(0)
// [KnfOpt]       if (r.8993 == _8994) then {
// [KnfOpt]         let _8995: Int = Int(1)
// [KnfOpt]         Tuple([_8995, val.8989, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _8996: Unit = Unit
// [KnfOpt]         Jump(aux.8984, [_8996, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.8984, [u.8983, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.8982)
// [KnfOpt] let rec add.8997: Int = (x.8998: Int, y.8999: Int) {
// [KnfOpt]   Add(x.8998, y.8999)
// [KnfOpt] }
// [KnfOpt] let _9000: Int = Int(0)
// [KnfOpt] let join fold.9001: Int = (stream.9002: Fun([Unit], Tuple([Int, Int])), f.9003: Fun([Int, Int], Int), acc.9004: Int) {
// [KnfOpt]   let _9005: Unit = Unit
// [KnfOpt]   let _9006: Tuple([Int, Int]) = Apply(stream.9002, [_9005, ])
// [KnfOpt]   let (ok.9007: Var({val: Some(Int)}), val.9008: Var({val: Some(Int)})) = _9006
// [KnfOpt]   let _9009: Int = Int(0)
// [KnfOpt]   if (ok.9007 == _9009) then {
// [KnfOpt]     let sum.104: Int = Var(acc.9004)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _9010: Int = Apply(f.9003, [acc.9004, val.9008, ])
// [KnfOpt]     Jump(fold.9001, [stream.9002, f.9003, _9010, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.9001, [under1200.103, add.8997, _9000, ])
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.9013: Int = (x.9014: Int, y.9015: Int) {
// [KnfOpt]   Add(x.9014, y.9015)
// [KnfOpt] }
// [KnfOpt] let _9016: Int = Int(0)
// [KnfOpt] let join fold.9017: Int = (stream.9018: Fun([Unit], Tuple([Int, Int])), f.9019: Fun([Int, Int], Int), acc.9020: Int) {
// [KnfOpt]   let _9021: Unit = Unit
// [KnfOpt]   let _9022: Tuple([Int, Int]) = Apply(stream.9018, [_9021, ])
// [KnfOpt]   let (ok.9023: Var({val: Some(Int)}), val.9024: Var({val: Some(Int)})) = _9022
// [KnfOpt]   let _9025: Int = Int(0)
// [KnfOpt]   if (ok.9023 == _9025) then {
// [KnfOpt]     let sum.104: Int = Var(acc.9020)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _9026: Int = Apply(f.9019, [acc.9020, val.9024, ])
// [KnfOpt]     Jump(fold.9017, [stream.9018, f.9019, _9026, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.9017, [under1200.103, add.9013, _9016, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let over50.100: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let _101: Int = Int(1200)
// [KnfOpt] let rec aux.9011: Int = (y.9012: Int) {
// [KnfOpt]   if (y.9012 <= _101) then {
// [KnfOpt]     Int(0)
// [KnfOpt]   } else {
// [KnfOpt]     Int(1)
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] let _102: Fun([Int], Int) = Var(aux.9011)
// [KnfOpt] let rec aux.9027: Tuple([Int, Int]) = (u.9028: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.9029: Tuple([Int, Int]) = (u.9030: Var({val: Some(Unit)})) {
// [KnfOpt]     let _9031: Unit = Unit
// [KnfOpt]     let _9032: Tuple([Int, Int]) = Apply(over50.100, [_9031, ])
// [KnfOpt]     let (ok.9033: Var({val: Some(Int)}), val.9034: Var({val: Some(Int)})) = _9032
// [KnfOpt]     let _9035: Int = Int(0)
// [KnfOpt]     if (ok.9033 == _9035) then {
// [KnfOpt]       let _9036: Int = Int(0)
// [KnfOpt]       let _9037: Int = Int(0)
// [KnfOpt]       Tuple([_9036, _9037, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.9038: Int = Apply(_102, [val.9034, ])
// [KnfOpt]       let _9039: Int = Int(0)
// [KnfOpt]       if (r.9038 == _9039) then {
// [KnfOpt]         let _9040: Int = Int(1)
// [KnfOpt]         Tuple([_9040, val.9034, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _9041: Unit = Unit
// [KnfOpt]         Jump(aux.9029, [_9041, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.9029, [u.9028, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.9027)
// [KnfOpt] let rec add.9042: Int = (x.9043: Int, y.9044: Int) {
// [KnfOpt]   Add(x.9043, y.9044)
// [KnfOpt] }
// [KnfOpt] let _9045: Int = Int(0)
// [KnfOpt] let join fold.9046: Int = (stream.9047: Fun([Unit], Tuple([Int, Int])), f.9048: Fun([Int, Int], Int), acc.9049: Int) {
// [KnfOpt]   let _9050: Unit = Unit
// [KnfOpt]   let _9051: Tuple([Int, Int]) = Apply(stream.9047, [_9050, ])
// [KnfOpt]   let (ok.9052: Var({val: Some(Int)}), val.9053: Var({val: Some(Int)})) = _9051
// [KnfOpt]   let _9054: Int = Int(0)
// [KnfOpt]   if (ok.9052 == _9054) then {
// [KnfOpt]     let sum.104: Int = Var(acc.9049)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _9055: Int = Apply(f.9048, [acc.9049, val.9053, ])
// [KnfOpt]     Jump(fold.9046, [stream.9047, f.9048, _9055, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.9046, [under1200.103, add.9042, _9045, ])
// [KnfOpt] Inline threshold 5
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 0
// [KnfOpt] Inline decision le.83 accepted
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.9071: Int = (x.9072: Int, y.9073: Int) {
// [KnfOpt]   Add(x.9072, y.9073)
// [KnfOpt] }
// [KnfOpt] let _9074: Int = Int(0)
// [KnfOpt] let join fold.9075: Int = (stream.9076: Fun([Unit], Tuple([Int, Int])), f.9077: Fun([Int, Int], Int), acc.9078: Int) {
// [KnfOpt]   let _9079: Unit = Unit
// [KnfOpt]   let _9080: Tuple([Int, Int]) = Apply(stream.9076, [_9079, ])
// [KnfOpt]   let (ok.9081: Var({val: Some(Int)}), val.9082: Var({val: Some(Int)})) = _9080
// [KnfOpt]   let _9083: Int = Int(0)
// [KnfOpt]   if (ok.9081 == _9083) then {
// [KnfOpt]     let sum.104: Int = Var(acc.9078)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _9084: Int = Apply(f.9077, [acc.9078, val.9082, ])
// [KnfOpt]     Jump(fold.9075, [stream.9076, f.9077, _9084, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.9075, [under1200.103, add.9071, _9074, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(le) let _102: Fun([Int], Int) = Unit
// [KnfOpt] let rec aux.9085: Tuple([Int, Int]) = (u.9086: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.9087: Tuple([Int, Int]) = (u.9088: Var({val: Some(Unit)})) {
// [KnfOpt]     let _9089: Unit = Unit
// [KnfOpt]     let _9090: Tuple([Int, Int]) = Apply(over50.100, [_9089, ])
// [KnfOpt]     let (ok.9091: Var({val: Some(Int)}), val.9092: Var({val: Some(Int)})) = _9090
// [KnfOpt]     let _9093: Int = Int(0)
// [KnfOpt]     if (ok.9091 == _9093) then {
// [KnfOpt]       let _9094: Int = Int(0)
// [KnfOpt]       let _9095: Int = Int(0)
// [KnfOpt]       Tuple([_9094, _9095, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.9096: Int = Apply(_102, [val.9092, ])
// [KnfOpt]       let _9097: Int = Int(0)
// [KnfOpt]       if (r.9096 == _9097) then {
// [KnfOpt]         let _9098: Int = Int(1)
// [KnfOpt]         Tuple([_9098, val.9092, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _9099: Unit = Unit
// [KnfOpt]         Jump(aux.9087, [_9099, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.9087, [u.9086, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.9085)
// [KnfOpt] let rec add.9100: Int = (x.9101: Int, y.9102: Int) {
// [KnfOpt]   Add(x.9101, y.9102)
// [KnfOpt] }
// [KnfOpt] let _9103: Int = Int(0)
// [KnfOpt] let join fold.9104: Int = (stream.9105: Fun([Unit], Tuple([Int, Int])), f.9106: Fun([Int, Int], Int), acc.9107: Int) {
// [KnfOpt]   let _9108: Unit = Unit
// [KnfOpt]   let _9109: Tuple([Int, Int]) = Apply(stream.9105, [_9108, ])
// [KnfOpt]   let (ok.9110: Var({val: Some(Int)}), val.9111: Var({val: Some(Int)})) = _9109
// [KnfOpt]   let _9112: Int = Int(0)
// [KnfOpt]   if (ok.9110 == _9112) then {
// [KnfOpt]     let sum.104: Int = Var(acc.9107)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _9113: Int = Apply(f.9106, [acc.9107, val.9111, ])
// [KnfOpt]     Jump(fold.9104, [stream.9105, f.9106, _9113, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.9104, [under1200.103, add.9100, _9103, ])
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.9116: Int = (x.9117: Int, y.9118: Int) {
// [KnfOpt]   Add(x.9117, y.9118)
// [KnfOpt] }
// [KnfOpt] let _9119: Int = Int(0)
// [KnfOpt] let join fold.9120: Int = (stream.9121: Fun([Unit], Tuple([Int, Int])), f.9122: Fun([Int, Int], Int), acc.9123: Int) {
// [KnfOpt]   let _9124: Unit = Unit
// [KnfOpt]   let _9125: Tuple([Int, Int]) = Apply(stream.9121, [_9124, ])
// [KnfOpt]   let (ok.9126: Var({val: Some(Int)}), val.9127: Var({val: Some(Int)})) = _9125
// [KnfOpt]   let _9128: Int = Int(0)
// [KnfOpt]   if (ok.9126 == _9128) then {
// [KnfOpt]     let sum.104: Int = Var(acc.9123)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _9129: Int = Apply(f.9122, [acc.9123, val.9127, ])
// [KnfOpt]     Jump(fold.9120, [stream.9121, f.9122, _9129, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.9120, [under1200.103, add.9116, _9119, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(map) let addone.97: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let _98: Int = Int(50)
// [KnfOpt] let rec aux.8966: Int = (y.8967: Int) {
// [KnfOpt]   if (_98 <= y.8967) then {
// [KnfOpt]     Int(0)
// [KnfOpt]   } else {
// [KnfOpt]     Int(1)
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] let _99: Fun([Int], Int) = Var(aux.8966)
// [KnfOpt] let rec aux.9056: Tuple([Int, Int]) = (u.9057: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.9058: Tuple([Int, Int]) = (u.9059: Var({val: Some(Unit)})) {
// [KnfOpt]     let _9060: Unit = Unit
// [KnfOpt]     let _9061: Tuple([Int, Int]) = Apply(addone.97, [_9060, ])
// [KnfOpt]     let (ok.9062: Var({val: Some(Int)}), val.9063: Var({val: Some(Int)})) = _9061
// [KnfOpt]     let _9064: Int = Int(0)
// [KnfOpt]     if (ok.9062 == _9064) then {
// [KnfOpt]       let _9065: Int = Int(0)
// [KnfOpt]       let _9066: Int = Int(0)
// [KnfOpt]       Tuple([_9065, _9066, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.9067: Int = Apply(_99, [val.9063, ])
// [KnfOpt]       let _9068: Int = Int(0)
// [KnfOpt]       if (r.9067 == _9068) then {
// [KnfOpt]         let _9069: Int = Int(1)
// [KnfOpt]         Tuple([_9069, val.9063, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _9070: Unit = Unit
// [KnfOpt]         Jump(aux.9058, [_9070, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.9058, [u.9057, ])
// [KnfOpt] }
// [KnfOpt] let over50.100: Fun([Unit], Tuple([Int, Int])) = Var(aux.9056)
// [KnfOpt] let _101: Int = Int(1200)
// [KnfOpt] let rec aux.9114: Int = (y.9115: Int) {
// [KnfOpt]   if (y.9115 <= _101) then {
// [KnfOpt]     Int(0)
// [KnfOpt]   } else {
// [KnfOpt]     Int(1)
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] let _102: Fun([Int], Int) = Var(aux.9114)
// [KnfOpt] let rec aux.9130: Tuple([Int, Int]) = (u.9131: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.9132: Tuple([Int, Int]) = (u.9133: Var({val: Some(Unit)})) {
// [KnfOpt]     let _9134: Unit = Unit
// [KnfOpt]     let _9135: Tuple([Int, Int]) = Apply(over50.100, [_9134, ])
// [KnfOpt]     let (ok.9136: Var({val: Some(Int)}), val.9137: Var({val: Some(Int)})) = _9135
// [KnfOpt]     let _9138: Int = Int(0)
// [KnfOpt]     if (ok.9136 == _9138) then {
// [KnfOpt]       let _9139: Int = Int(0)
// [KnfOpt]       let _9140: Int = Int(0)
// [KnfOpt]       Tuple([_9139, _9140, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.9141: Int = Apply(_102, [val.9137, ])
// [KnfOpt]       let _9142: Int = Int(0)
// [KnfOpt]       if (r.9141 == _9142) then {
// [KnfOpt]         let _9143: Int = Int(1)
// [KnfOpt]         Tuple([_9143, val.9137, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _9144: Unit = Unit
// [KnfOpt]         Jump(aux.9132, [_9144, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.9132, [u.9131, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.9130)
// [KnfOpt] let rec add.9145: Int = (x.9146: Int, y.9147: Int) {
// [KnfOpt]   Add(x.9146, y.9147)
// [KnfOpt] }
// [KnfOpt] let _9148: Int = Int(0)
// [KnfOpt] let join fold.9149: Int = (stream.9150: Fun([Unit], Tuple([Int, Int])), f.9151: Fun([Int, Int], Int), acc.9152: Int) {
// [KnfOpt]   let _9153: Unit = Unit
// [KnfOpt]   let _9154: Tuple([Int, Int]) = Apply(stream.9150, [_9153, ])
// [KnfOpt]   let (ok.9155: Var({val: Some(Int)}), val.9156: Var({val: Some(Int)})) = _9154
// [KnfOpt]   let _9157: Int = Int(0)
// [KnfOpt]   if (ok.9155 == _9157) then {
// [KnfOpt]     let sum.104: Int = Var(acc.9152)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _9158: Int = Apply(f.9151, [acc.9152, val.9156, ])
// [KnfOpt]     Jump(fold.9149, [stream.9150, f.9151, _9158, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.9149, [under1200.103, add.9145, _9148, ])
// [KnfOpt] Inline threshold 5
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 0
// [KnfOpt] Inline decision gt.79 accepted
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 5
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 0
// [KnfOpt] Inline decision le.83 accepted
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.9170: Int = (x.9171: Int, y.9172: Int) {
// [KnfOpt]   Add(x.9171, y.9172)
// [KnfOpt] }
// [KnfOpt] let _9173: Int = Int(0)
// [KnfOpt] let join fold.9174: Int = (stream.9175: Fun([Unit], Tuple([Int, Int])), f.9176: Fun([Int, Int], Int), acc.9177: Int) {
// [KnfOpt]   let _9178: Unit = Unit
// [KnfOpt]   let _9179: Tuple([Int, Int]) = Apply(stream.9175, [_9178, ])
// [KnfOpt]   let (ok.9180: Var({val: Some(Int)}), val.9181: Var({val: Some(Int)})) = _9179
// [KnfOpt]   let _9182: Int = Int(0)
// [KnfOpt]   if (ok.9180 == _9182) then {
// [KnfOpt]     let sum.104: Int = Var(acc.9177)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _9183: Int = Apply(f.9176, [acc.9177, val.9181, ])
// [KnfOpt]     Jump(fold.9174, [stream.9175, f.9176, _9183, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.9174, [under1200.103, add.9170, _9173, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(le) let _102: Fun([Int], Int) = Unit
// [KnfOpt] let rec aux.9184: Tuple([Int, Int]) = (u.9185: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.9186: Tuple([Int, Int]) = (u.9187: Var({val: Some(Unit)})) {
// [KnfOpt]     let _9188: Unit = Unit
// [KnfOpt]     let _9189: Tuple([Int, Int]) = Apply(over50.100, [_9188, ])
// [KnfOpt]     let (ok.9190: Var({val: Some(Int)}), val.9191: Var({val: Some(Int)})) = _9189
// [KnfOpt]     let _9192: Int = Int(0)
// [KnfOpt]     if (ok.9190 == _9192) then {
// [KnfOpt]       let _9193: Int = Int(0)
// [KnfOpt]       let _9194: Int = Int(0)
// [KnfOpt]       Tuple([_9193, _9194, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.9195: Int = Apply(_102, [val.9191, ])
// [KnfOpt]       let _9196: Int = Int(0)
// [KnfOpt]       if (r.9195 == _9196) then {
// [KnfOpt]         let _9197: Int = Int(1)
// [KnfOpt]         Tuple([_9197, val.9191, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _9198: Unit = Unit
// [KnfOpt]         Jump(aux.9186, [_9198, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.9186, [u.9185, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.9184)
// [KnfOpt] let rec add.9199: Int = (x.9200: Int, y.9201: Int) {
// [KnfOpt]   Add(x.9200, y.9201)
// [KnfOpt] }
// [KnfOpt] let _9202: Int = Int(0)
// [KnfOpt] let join fold.9203: Int = (stream.9204: Fun([Unit], Tuple([Int, Int])), f.9205: Fun([Int, Int], Int), acc.9206: Int) {
// [KnfOpt]   let _9207: Unit = Unit
// [KnfOpt]   let _9208: Tuple([Int, Int]) = Apply(stream.9204, [_9207, ])
// [KnfOpt]   let (ok.9209: Var({val: Some(Int)}), val.9210: Var({val: Some(Int)})) = _9208
// [KnfOpt]   let _9211: Int = Int(0)
// [KnfOpt]   if (ok.9209 == _9211) then {
// [KnfOpt]     let sum.104: Int = Var(acc.9206)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _9212: Int = Apply(f.9205, [acc.9206, val.9210, ])
// [KnfOpt]     Jump(fold.9203, [stream.9204, f.9205, _9212, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.9203, [under1200.103, add.9199, _9202, ])
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.9215: Int = (x.9216: Int, y.9217: Int) {
// [KnfOpt]   Add(x.9216, y.9217)
// [KnfOpt] }
// [KnfOpt] let _9218: Int = Int(0)
// [KnfOpt] let join fold.9219: Int = (stream.9220: Fun([Unit], Tuple([Int, Int])), f.9221: Fun([Int, Int], Int), acc.9222: Int) {
// [KnfOpt]   let _9223: Unit = Unit
// [KnfOpt]   let _9224: Tuple([Int, Int]) = Apply(stream.9220, [_9223, ])
// [KnfOpt]   let (ok.9225: Var({val: Some(Int)}), val.9226: Var({val: Some(Int)})) = _9224
// [KnfOpt]   let _9227: Int = Int(0)
// [KnfOpt]   if (ok.9225 == _9227) then {
// [KnfOpt]     let sum.104: Int = Var(acc.9222)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _9228: Int = Apply(f.9221, [acc.9222, val.9226, ])
// [KnfOpt]     Jump(fold.9219, [stream.9220, f.9221, _9228, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.9219, [under1200.103, add.9215, _9218, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let over50.100: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let _101: Int = Int(1200)
// [KnfOpt] let rec aux.9213: Int = (y.9214: Int) {
// [KnfOpt]   if (y.9214 <= _101) then {
// [KnfOpt]     Int(0)
// [KnfOpt]   } else {
// [KnfOpt]     Int(1)
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] let _102: Fun([Int], Int) = Var(aux.9213)
// [KnfOpt] let rec aux.9229: Tuple([Int, Int]) = (u.9230: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.9231: Tuple([Int, Int]) = (u.9232: Var({val: Some(Unit)})) {
// [KnfOpt]     let _9233: Unit = Unit
// [KnfOpt]     let _9234: Tuple([Int, Int]) = Apply(over50.100, [_9233, ])
// [KnfOpt]     let (ok.9235: Var({val: Some(Int)}), val.9236: Var({val: Some(Int)})) = _9234
// [KnfOpt]     let _9237: Int = Int(0)
// [KnfOpt]     if (ok.9235 == _9237) then {
// [KnfOpt]       let _9238: Int = Int(0)
// [KnfOpt]       let _9239: Int = Int(0)
// [KnfOpt]       Tuple([_9238, _9239, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.9240: Int = Apply(_102, [val.9236, ])
// [KnfOpt]       let _9241: Int = Int(0)
// [KnfOpt]       if (r.9240 == _9241) then {
// [KnfOpt]         let _9242: Int = Int(1)
// [KnfOpt]         Tuple([_9242, val.9236, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _9243: Unit = Unit
// [KnfOpt]         Jump(aux.9231, [_9243, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.9231, [u.9230, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.9229)
// [KnfOpt] let rec add.9244: Int = (x.9245: Int, y.9246: Int) {
// [KnfOpt]   Add(x.9245, y.9246)
// [KnfOpt] }
// [KnfOpt] let _9247: Int = Int(0)
// [KnfOpt] let join fold.9248: Int = (stream.9249: Fun([Unit], Tuple([Int, Int])), f.9250: Fun([Int, Int], Int), acc.9251: Int) {
// [KnfOpt]   let _9252: Unit = Unit
// [KnfOpt]   let _9253: Tuple([Int, Int]) = Apply(stream.9249, [_9252, ])
// [KnfOpt]   let (ok.9254: Var({val: Some(Int)}), val.9255: Var({val: Some(Int)})) = _9253
// [KnfOpt]   let _9256: Int = Int(0)
// [KnfOpt]   if (ok.9254 == _9256) then {
// [KnfOpt]     let sum.104: Int = Var(acc.9251)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _9257: Int = Apply(f.9250, [acc.9251, val.9255, ])
// [KnfOpt]     Jump(fold.9248, [stream.9249, f.9250, _9257, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.9248, [under1200.103, add.9244, _9247, ])
// [KnfOpt] Inline threshold 5
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 0
// [KnfOpt] Inline decision le.83 accepted
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.9273: Int = (x.9274: Int, y.9275: Int) {
// [KnfOpt]   Add(x.9274, y.9275)
// [KnfOpt] }
// [KnfOpt] let _9276: Int = Int(0)
// [KnfOpt] let join fold.9277: Int = (stream.9278: Fun([Unit], Tuple([Int, Int])), f.9279: Fun([Int, Int], Int), acc.9280: Int) {
// [KnfOpt]   let _9281: Unit = Unit
// [KnfOpt]   let _9282: Tuple([Int, Int]) = Apply(stream.9278, [_9281, ])
// [KnfOpt]   let (ok.9283: Var({val: Some(Int)}), val.9284: Var({val: Some(Int)})) = _9282
// [KnfOpt]   let _9285: Int = Int(0)
// [KnfOpt]   if (ok.9283 == _9285) then {
// [KnfOpt]     let sum.104: Int = Var(acc.9280)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _9286: Int = Apply(f.9279, [acc.9280, val.9284, ])
// [KnfOpt]     Jump(fold.9277, [stream.9278, f.9279, _9286, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.9277, [under1200.103, add.9273, _9276, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(le) let _102: Fun([Int], Int) = Unit
// [KnfOpt] let rec aux.9287: Tuple([Int, Int]) = (u.9288: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.9289: Tuple([Int, Int]) = (u.9290: Var({val: Some(Unit)})) {
// [KnfOpt]     let _9291: Unit = Unit
// [KnfOpt]     let _9292: Tuple([Int, Int]) = Apply(over50.100, [_9291, ])
// [KnfOpt]     let (ok.9293: Var({val: Some(Int)}), val.9294: Var({val: Some(Int)})) = _9292
// [KnfOpt]     let _9295: Int = Int(0)
// [KnfOpt]     if (ok.9293 == _9295) then {
// [KnfOpt]       let _9296: Int = Int(0)
// [KnfOpt]       let _9297: Int = Int(0)
// [KnfOpt]       Tuple([_9296, _9297, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.9298: Int = Apply(_102, [val.9294, ])
// [KnfOpt]       let _9299: Int = Int(0)
// [KnfOpt]       if (r.9298 == _9299) then {
// [KnfOpt]         let _9300: Int = Int(1)
// [KnfOpt]         Tuple([_9300, val.9294, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _9301: Unit = Unit
// [KnfOpt]         Jump(aux.9289, [_9301, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.9289, [u.9288, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.9287)
// [KnfOpt] let rec add.9302: Int = (x.9303: Int, y.9304: Int) {
// [KnfOpt]   Add(x.9303, y.9304)
// [KnfOpt] }
// [KnfOpt] let _9305: Int = Int(0)
// [KnfOpt] let join fold.9306: Int = (stream.9307: Fun([Unit], Tuple([Int, Int])), f.9308: Fun([Int, Int], Int), acc.9309: Int) {
// [KnfOpt]   let _9310: Unit = Unit
// [KnfOpt]   let _9311: Tuple([Int, Int]) = Apply(stream.9307, [_9310, ])
// [KnfOpt]   let (ok.9312: Var({val: Some(Int)}), val.9313: Var({val: Some(Int)})) = _9311
// [KnfOpt]   let _9314: Int = Int(0)
// [KnfOpt]   if (ok.9312 == _9314) then {
// [KnfOpt]     let sum.104: Int = Var(acc.9309)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _9315: Int = Apply(f.9308, [acc.9309, val.9313, ])
// [KnfOpt]     Jump(fold.9306, [stream.9307, f.9308, _9315, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.9306, [under1200.103, add.9302, _9305, ])
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.9318: Int = (x.9319: Int, y.9320: Int) {
// [KnfOpt]   Add(x.9319, y.9320)
// [KnfOpt] }
// [KnfOpt] let _9321: Int = Int(0)
// [KnfOpt] let join fold.9322: Int = (stream.9323: Fun([Unit], Tuple([Int, Int])), f.9324: Fun([Int, Int], Int), acc.9325: Int) {
// [KnfOpt]   let _9326: Unit = Unit
// [KnfOpt]   let _9327: Tuple([Int, Int]) = Apply(stream.9323, [_9326, ])
// [KnfOpt]   let (ok.9328: Var({val: Some(Int)}), val.9329: Var({val: Some(Int)})) = _9327
// [KnfOpt]   let _9330: Int = Int(0)
// [KnfOpt]   if (ok.9328 == _9330) then {
// [KnfOpt]     let sum.104: Int = Var(acc.9325)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _9331: Int = Apply(f.9324, [acc.9325, val.9329, ])
// [KnfOpt]     Jump(fold.9322, [stream.9323, f.9324, _9331, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.9322, [under1200.103, add.9318, _9321, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(gt) let _99: Fun([Int], Int) = Unit
// [KnfOpt] let rec aux.9258: Tuple([Int, Int]) = (u.9259: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.9260: Tuple([Int, Int]) = (u.9261: Var({val: Some(Unit)})) {
// [KnfOpt]     let _9262: Unit = Unit
// [KnfOpt]     let _9263: Tuple([Int, Int]) = Apply(addone.97, [_9262, ])
// [KnfOpt]     let (ok.9264: Var({val: Some(Int)}), val.9265: Var({val: Some(Int)})) = _9263
// [KnfOpt]     let _9266: Int = Int(0)
// [KnfOpt]     if (ok.9264 == _9266) then {
// [KnfOpt]       let _9267: Int = Int(0)
// [KnfOpt]       let _9268: Int = Int(0)
// [KnfOpt]       Tuple([_9267, _9268, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.9269: Int = Apply(_99, [val.9265, ])
// [KnfOpt]       let _9270: Int = Int(0)
// [KnfOpt]       if (r.9269 == _9270) then {
// [KnfOpt]         let _9271: Int = Int(1)
// [KnfOpt]         Tuple([_9271, val.9265, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _9272: Unit = Unit
// [KnfOpt]         Jump(aux.9260, [_9272, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.9260, [u.9259, ])
// [KnfOpt] }
// [KnfOpt] let over50.100: Fun([Unit], Tuple([Int, Int])) = Var(aux.9258)
// [KnfOpt] let _101: Int = Int(1200)
// [KnfOpt] let rec aux.9316: Int = (y.9317: Int) {
// [KnfOpt]   if (y.9317 <= _101) then {
// [KnfOpt]     Int(0)
// [KnfOpt]   } else {
// [KnfOpt]     Int(1)
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] let _102: Fun([Int], Int) = Var(aux.9316)
// [KnfOpt] let rec aux.9332: Tuple([Int, Int]) = (u.9333: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.9334: Tuple([Int, Int]) = (u.9335: Var({val: Some(Unit)})) {
// [KnfOpt]     let _9336: Unit = Unit
// [KnfOpt]     let _9337: Tuple([Int, Int]) = Apply(over50.100, [_9336, ])
// [KnfOpt]     let (ok.9338: Var({val: Some(Int)}), val.9339: Var({val: Some(Int)})) = _9337
// [KnfOpt]     let _9340: Int = Int(0)
// [KnfOpt]     if (ok.9338 == _9340) then {
// [KnfOpt]       let _9341: Int = Int(0)
// [KnfOpt]       let _9342: Int = Int(0)
// [KnfOpt]       Tuple([_9341, _9342, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.9343: Int = Apply(_102, [val.9339, ])
// [KnfOpt]       let _9344: Int = Int(0)
// [KnfOpt]       if (r.9343 == _9344) then {
// [KnfOpt]         let _9345: Int = Int(1)
// [KnfOpt]         Tuple([_9345, val.9339, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _9346: Unit = Unit
// [KnfOpt]         Jump(aux.9334, [_9346, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.9334, [u.9333, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.9332)
// [KnfOpt] let rec add.9347: Int = (x.9348: Int, y.9349: Int) {
// [KnfOpt]   Add(x.9348, y.9349)
// [KnfOpt] }
// [KnfOpt] let _9350: Int = Int(0)
// [KnfOpt] let join fold.9351: Int = (stream.9352: Fun([Unit], Tuple([Int, Int])), f.9353: Fun([Int, Int], Int), acc.9354: Int) {
// [KnfOpt]   let _9355: Unit = Unit
// [KnfOpt]   let _9356: Tuple([Int, Int]) = Apply(stream.9352, [_9355, ])
// [KnfOpt]   let (ok.9357: Var({val: Some(Int)}), val.9358: Var({val: Some(Int)})) = _9356
// [KnfOpt]   let _9359: Int = Int(0)
// [KnfOpt]   if (ok.9357 == _9359) then {
// [KnfOpt]     let sum.104: Int = Var(acc.9354)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _9360: Int = Apply(f.9353, [acc.9354, val.9358, ])
// [KnfOpt]     Jump(fold.9351, [stream.9352, f.9353, _9360, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.9351, [under1200.103, add.9347, _9350, ])
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 5
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 0
// [KnfOpt] Inline decision le.83 accepted
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.9363: Int = (x.9364: Int, y.9365: Int) {
// [KnfOpt]   Add(x.9364, y.9365)
// [KnfOpt] }
// [KnfOpt] let _9366: Int = Int(0)
// [KnfOpt] let join fold.9367: Int = (stream.9368: Fun([Unit], Tuple([Int, Int])), f.9369: Fun([Int, Int], Int), acc.9370: Int) {
// [KnfOpt]   let _9371: Unit = Unit
// [KnfOpt]   let _9372: Tuple([Int, Int]) = Apply(stream.9368, [_9371, ])
// [KnfOpt]   let (ok.9373: Var({val: Some(Int)}), val.9374: Var({val: Some(Int)})) = _9372
// [KnfOpt]   let _9375: Int = Int(0)
// [KnfOpt]   if (ok.9373 == _9375) then {
// [KnfOpt]     let sum.104: Int = Var(acc.9370)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _9376: Int = Apply(f.9369, [acc.9370, val.9374, ])
// [KnfOpt]     Jump(fold.9367, [stream.9368, f.9369, _9376, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.9367, [under1200.103, add.9363, _9366, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(le) let _102: Fun([Int], Int) = Unit
// [KnfOpt] let rec aux.9377: Tuple([Int, Int]) = (u.9378: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.9379: Tuple([Int, Int]) = (u.9380: Var({val: Some(Unit)})) {
// [KnfOpt]     let _9381: Unit = Unit
// [KnfOpt]     let _9382: Tuple([Int, Int]) = Apply(over50.100, [_9381, ])
// [KnfOpt]     let (ok.9383: Var({val: Some(Int)}), val.9384: Var({val: Some(Int)})) = _9382
// [KnfOpt]     let _9385: Int = Int(0)
// [KnfOpt]     if (ok.9383 == _9385) then {
// [KnfOpt]       let _9386: Int = Int(0)
// [KnfOpt]       let _9387: Int = Int(0)
// [KnfOpt]       Tuple([_9386, _9387, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.9388: Int = Apply(_102, [val.9384, ])
// [KnfOpt]       let _9389: Int = Int(0)
// [KnfOpt]       if (r.9388 == _9389) then {
// [KnfOpt]         let _9390: Int = Int(1)
// [KnfOpt]         Tuple([_9390, val.9384, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _9391: Unit = Unit
// [KnfOpt]         Jump(aux.9379, [_9391, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.9379, [u.9378, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.9377)
// [KnfOpt] let rec add.9392: Int = (x.9393: Int, y.9394: Int) {
// [KnfOpt]   Add(x.9393, y.9394)
// [KnfOpt] }
// [KnfOpt] let _9395: Int = Int(0)
// [KnfOpt] let join fold.9396: Int = (stream.9397: Fun([Unit], Tuple([Int, Int])), f.9398: Fun([Int, Int], Int), acc.9399: Int) {
// [KnfOpt]   let _9400: Unit = Unit
// [KnfOpt]   let _9401: Tuple([Int, Int]) = Apply(stream.9397, [_9400, ])
// [KnfOpt]   let (ok.9402: Var({val: Some(Int)}), val.9403: Var({val: Some(Int)})) = _9401
// [KnfOpt]   let _9404: Int = Int(0)
// [KnfOpt]   if (ok.9402 == _9404) then {
// [KnfOpt]     let sum.104: Int = Var(acc.9399)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _9405: Int = Apply(f.9398, [acc.9399, val.9403, ])
// [KnfOpt]     Jump(fold.9396, [stream.9397, f.9398, _9405, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.9396, [under1200.103, add.9392, _9395, ])
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.9408: Int = (x.9409: Int, y.9410: Int) {
// [KnfOpt]   Add(x.9409, y.9410)
// [KnfOpt] }
// [KnfOpt] let _9411: Int = Int(0)
// [KnfOpt] let join fold.9412: Int = (stream.9413: Fun([Unit], Tuple([Int, Int])), f.9414: Fun([Int, Int], Int), acc.9415: Int) {
// [KnfOpt]   let _9416: Unit = Unit
// [KnfOpt]   let _9417: Tuple([Int, Int]) = Apply(stream.9413, [_9416, ])
// [KnfOpt]   let (ok.9418: Var({val: Some(Int)}), val.9419: Var({val: Some(Int)})) = _9417
// [KnfOpt]   let _9420: Int = Int(0)
// [KnfOpt]   if (ok.9418 == _9420) then {
// [KnfOpt]     let sum.104: Int = Var(acc.9415)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _9421: Int = Apply(f.9414, [acc.9415, val.9419, ])
// [KnfOpt]     Jump(fold.9412, [stream.9413, f.9414, _9421, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.9412, [under1200.103, add.9408, _9411, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let over50.100: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let _101: Int = Int(1200)
// [KnfOpt] let rec aux.9406: Int = (y.9407: Int) {
// [KnfOpt]   if (y.9407 <= _101) then {
// [KnfOpt]     Int(0)
// [KnfOpt]   } else {
// [KnfOpt]     Int(1)
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] let _102: Fun([Int], Int) = Var(aux.9406)
// [KnfOpt] let rec aux.9422: Tuple([Int, Int]) = (u.9423: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.9424: Tuple([Int, Int]) = (u.9425: Var({val: Some(Unit)})) {
// [KnfOpt]     let _9426: Unit = Unit
// [KnfOpt]     let _9427: Tuple([Int, Int]) = Apply(over50.100, [_9426, ])
// [KnfOpt]     let (ok.9428: Var({val: Some(Int)}), val.9429: Var({val: Some(Int)})) = _9427
// [KnfOpt]     let _9430: Int = Int(0)
// [KnfOpt]     if (ok.9428 == _9430) then {
// [KnfOpt]       let _9431: Int = Int(0)
// [KnfOpt]       let _9432: Int = Int(0)
// [KnfOpt]       Tuple([_9431, _9432, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.9433: Int = Apply(_102, [val.9429, ])
// [KnfOpt]       let _9434: Int = Int(0)
// [KnfOpt]       if (r.9433 == _9434) then {
// [KnfOpt]         let _9435: Int = Int(1)
// [KnfOpt]         Tuple([_9435, val.9429, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _9436: Unit = Unit
// [KnfOpt]         Jump(aux.9424, [_9436, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.9424, [u.9423, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.9422)
// [KnfOpt] let rec add.9437: Int = (x.9438: Int, y.9439: Int) {
// [KnfOpt]   Add(x.9438, y.9439)
// [KnfOpt] }
// [KnfOpt] let _9440: Int = Int(0)
// [KnfOpt] let join fold.9441: Int = (stream.9442: Fun([Unit], Tuple([Int, Int])), f.9443: Fun([Int, Int], Int), acc.9444: Int) {
// [KnfOpt]   let _9445: Unit = Unit
// [KnfOpt]   let _9446: Tuple([Int, Int]) = Apply(stream.9442, [_9445, ])
// [KnfOpt]   let (ok.9447: Var({val: Some(Int)}), val.9448: Var({val: Some(Int)})) = _9446
// [KnfOpt]   let _9449: Int = Int(0)
// [KnfOpt]   if (ok.9447 == _9449) then {
// [KnfOpt]     let sum.104: Int = Var(acc.9444)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _9450: Int = Apply(f.9443, [acc.9444, val.9448, ])
// [KnfOpt]     Jump(fold.9441, [stream.9442, f.9443, _9450, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.9441, [under1200.103, add.9437, _9440, ])
// [KnfOpt] Inline threshold 5
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 0
// [KnfOpt] Inline decision le.83 accepted
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.9466: Int = (x.9467: Int, y.9468: Int) {
// [KnfOpt]   Add(x.9467, y.9468)
// [KnfOpt] }
// [KnfOpt] let _9469: Int = Int(0)
// [KnfOpt] let join fold.9470: Int = (stream.9471: Fun([Unit], Tuple([Int, Int])), f.9472: Fun([Int, Int], Int), acc.9473: Int) {
// [KnfOpt]   let _9474: Unit = Unit
// [KnfOpt]   let _9475: Tuple([Int, Int]) = Apply(stream.9471, [_9474, ])
// [KnfOpt]   let (ok.9476: Var({val: Some(Int)}), val.9477: Var({val: Some(Int)})) = _9475
// [KnfOpt]   let _9478: Int = Int(0)
// [KnfOpt]   if (ok.9476 == _9478) then {
// [KnfOpt]     let sum.104: Int = Var(acc.9473)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _9479: Int = Apply(f.9472, [acc.9473, val.9477, ])
// [KnfOpt]     Jump(fold.9470, [stream.9471, f.9472, _9479, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.9470, [under1200.103, add.9466, _9469, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(le) let _102: Fun([Int], Int) = Unit
// [KnfOpt] let rec aux.9480: Tuple([Int, Int]) = (u.9481: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.9482: Tuple([Int, Int]) = (u.9483: Var({val: Some(Unit)})) {
// [KnfOpt]     let _9484: Unit = Unit
// [KnfOpt]     let _9485: Tuple([Int, Int]) = Apply(over50.100, [_9484, ])
// [KnfOpt]     let (ok.9486: Var({val: Some(Int)}), val.9487: Var({val: Some(Int)})) = _9485
// [KnfOpt]     let _9488: Int = Int(0)
// [KnfOpt]     if (ok.9486 == _9488) then {
// [KnfOpt]       let _9489: Int = Int(0)
// [KnfOpt]       let _9490: Int = Int(0)
// [KnfOpt]       Tuple([_9489, _9490, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.9491: Int = Apply(_102, [val.9487, ])
// [KnfOpt]       let _9492: Int = Int(0)
// [KnfOpt]       if (r.9491 == _9492) then {
// [KnfOpt]         let _9493: Int = Int(1)
// [KnfOpt]         Tuple([_9493, val.9487, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _9494: Unit = Unit
// [KnfOpt]         Jump(aux.9482, [_9494, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.9482, [u.9481, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.9480)
// [KnfOpt] let rec add.9495: Int = (x.9496: Int, y.9497: Int) {
// [KnfOpt]   Add(x.9496, y.9497)
// [KnfOpt] }
// [KnfOpt] let _9498: Int = Int(0)
// [KnfOpt] let join fold.9499: Int = (stream.9500: Fun([Unit], Tuple([Int, Int])), f.9501: Fun([Int, Int], Int), acc.9502: Int) {
// [KnfOpt]   let _9503: Unit = Unit
// [KnfOpt]   let _9504: Tuple([Int, Int]) = Apply(stream.9500, [_9503, ])
// [KnfOpt]   let (ok.9505: Var({val: Some(Int)}), val.9506: Var({val: Some(Int)})) = _9504
// [KnfOpt]   let _9507: Int = Int(0)
// [KnfOpt]   if (ok.9505 == _9507) then {
// [KnfOpt]     let sum.104: Int = Var(acc.9502)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _9508: Int = Apply(f.9501, [acc.9502, val.9506, ])
// [KnfOpt]     Jump(fold.9499, [stream.9500, f.9501, _9508, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.9499, [under1200.103, add.9495, _9498, ])
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.9511: Int = (x.9512: Int, y.9513: Int) {
// [KnfOpt]   Add(x.9512, y.9513)
// [KnfOpt] }
// [KnfOpt] let _9514: Int = Int(0)
// [KnfOpt] let join fold.9515: Int = (stream.9516: Fun([Unit], Tuple([Int, Int])), f.9517: Fun([Int, Int], Int), acc.9518: Int) {
// [KnfOpt]   let _9519: Unit = Unit
// [KnfOpt]   let _9520: Tuple([Int, Int]) = Apply(stream.9516, [_9519, ])
// [KnfOpt]   let (ok.9521: Var({val: Some(Int)}), val.9522: Var({val: Some(Int)})) = _9520
// [KnfOpt]   let _9523: Int = Int(0)
// [KnfOpt]   if (ok.9521 == _9523) then {
// [KnfOpt]     let sum.104: Int = Var(acc.9518)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _9524: Int = Apply(f.9517, [acc.9518, val.9522, ])
// [KnfOpt]     Jump(fold.9515, [stream.9516, f.9517, _9524, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.9515, [under1200.103, add.9511, _9514, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(range) let range1000.93: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec aux.7985: Tuple([Int, Int]) = (u.7986: Var({val: Some(Unit)})) {
// [KnfOpt]   let _7987: Unit = Unit
// [KnfOpt]   let _7988: Tuple([Int, Int]) = Apply(range100.90, [_7987, ])
// [KnfOpt]   let (ok.7989: Var({val: Some(Int)}), val.7990: Var({val: Some(Int)})) = _7988
// [KnfOpt]   let _7991: Int = Int(0)
// [KnfOpt]   if (ok.7989 == _7991) then {
// [KnfOpt]     let _7992: Unit = Unit
// [KnfOpt]     Apply(range1000.93, [_7992, ])
// [KnfOpt]   } else {
// [KnfOpt]     let _7993: Int = Int(1)
// [KnfOpt]     Tuple([_7993, val.7990, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] let catt.94: Fun([Unit], Tuple([Int, Int])) = Var(aux.7985)
// [KnfOpt] let _95: Int = Int(1)
// [KnfOpt] let rec aux.8773: Int = (y.8774: Int) {
// [KnfOpt]   Add(_95, y.8774)
// [KnfOpt] }
// [KnfOpt] let _96: Fun([Int], Int) = Var(aux.8773)
// [KnfOpt] let rec aux.9159: Tuple([Int, Int]) = (u.9160: Var({val: Some(Unit)})) {
// [KnfOpt]   let _9161: Unit = Unit
// [KnfOpt]   let _9162: Tuple([Int, Int]) = Apply(catt.94, [_9161, ])
// [KnfOpt]   let (ok.9163: Var({val: Some(Int)}), val.9164: Var({val: Some(Int)})) = _9162
// [KnfOpt]   let _9165: Int = Int(0)
// [KnfOpt]   if (ok.9163 == _9165) then {
// [KnfOpt]     let _9166: Int = Int(0)
// [KnfOpt]     let _9167: Int = Int(0)
// [KnfOpt]     Tuple([_9166, _9167, ])
// [KnfOpt]   } else {
// [KnfOpt]     let _9168: Int = Int(1)
// [KnfOpt]     let _9169: Int = Apply(_96, [val.9164, ])
// [KnfOpt]     Tuple([_9168, _9169, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] let addone.97: Fun([Unit], Tuple([Int, Int])) = Var(aux.9159)
// [KnfOpt] let _98: Int = Int(50)
// [KnfOpt] let rec aux.9361: Int = (y.9362: Int) {
// [KnfOpt]   if (_98 <= y.9362) then {
// [KnfOpt]     Int(0)
// [KnfOpt]   } else {
// [KnfOpt]     Int(1)
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] let _99: Fun([Int], Int) = Var(aux.9361)
// [KnfOpt] let rec aux.9451: Tuple([Int, Int]) = (u.9452: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.9453: Tuple([Int, Int]) = (u.9454: Var({val: Some(Unit)})) {
// [KnfOpt]     let _9455: Unit = Unit
// [KnfOpt]     let _9456: Tuple([Int, Int]) = Apply(addone.97, [_9455, ])
// [KnfOpt]     let (ok.9457: Var({val: Some(Int)}), val.9458: Var({val: Some(Int)})) = _9456
// [KnfOpt]     let _9459: Int = Int(0)
// [KnfOpt]     if (ok.9457 == _9459) then {
// [KnfOpt]       let _9460: Int = Int(0)
// [KnfOpt]       let _9461: Int = Int(0)
// [KnfOpt]       Tuple([_9460, _9461, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.9462: Int = Apply(_99, [val.9458, ])
// [KnfOpt]       let _9463: Int = Int(0)
// [KnfOpt]       if (r.9462 == _9463) then {
// [KnfOpt]         let _9464: Int = Int(1)
// [KnfOpt]         Tuple([_9464, val.9458, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _9465: Unit = Unit
// [KnfOpt]         Jump(aux.9453, [_9465, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.9453, [u.9452, ])
// [KnfOpt] }
// [KnfOpt] let over50.100: Fun([Unit], Tuple([Int, Int])) = Var(aux.9451)
// [KnfOpt] let _101: Int = Int(1200)
// [KnfOpt] let rec aux.9509: Int = (y.9510: Int) {
// [KnfOpt]   if (y.9510 <= _101) then {
// [KnfOpt]     Int(0)
// [KnfOpt]   } else {
// [KnfOpt]     Int(1)
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] let _102: Fun([Int], Int) = Var(aux.9509)
// [KnfOpt] let rec aux.9525: Tuple([Int, Int]) = (u.9526: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.9527: Tuple([Int, Int]) = (u.9528: Var({val: Some(Unit)})) {
// [KnfOpt]     let _9529: Unit = Unit
// [KnfOpt]     let _9530: Tuple([Int, Int]) = Apply(over50.100, [_9529, ])
// [KnfOpt]     let (ok.9531: Var({val: Some(Int)}), val.9532: Var({val: Some(Int)})) = _9530
// [KnfOpt]     let _9533: Int = Int(0)
// [KnfOpt]     if (ok.9531 == _9533) then {
// [KnfOpt]       let _9534: Int = Int(0)
// [KnfOpt]       let _9535: Int = Int(0)
// [KnfOpt]       Tuple([_9534, _9535, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.9536: Int = Apply(_102, [val.9532, ])
// [KnfOpt]       let _9537: Int = Int(0)
// [KnfOpt]       if (r.9536 == _9537) then {
// [KnfOpt]         let _9538: Int = Int(1)
// [KnfOpt]         Tuple([_9538, val.9532, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _9539: Unit = Unit
// [KnfOpt]         Jump(aux.9527, [_9539, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.9527, [u.9526, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.9525)
// [KnfOpt] let rec add.9540: Int = (x.9541: Int, y.9542: Int) {
// [KnfOpt]   Add(x.9541, y.9542)
// [KnfOpt] }
// [KnfOpt] let _9543: Int = Int(0)
// [KnfOpt] let join fold.9544: Int = (stream.9545: Fun([Unit], Tuple([Int, Int])), f.9546: Fun([Int, Int], Int), acc.9547: Int) {
// [KnfOpt]   let _9548: Unit = Unit
// [KnfOpt]   let _9549: Tuple([Int, Int]) = Apply(stream.9545, [_9548, ])
// [KnfOpt]   let (ok.9550: Var({val: Some(Int)}), val.9551: Var({val: Some(Int)})) = _9549
// [KnfOpt]   let _9552: Int = Int(0)
// [KnfOpt]   if (ok.9550 == _9552) then {
// [KnfOpt]     let sum.104: Int = Var(acc.9547)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _9553: Int = Apply(f.9546, [acc.9547, val.9551, ])
// [KnfOpt]     Jump(fold.9544, [stream.9545, f.9546, _9553, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.9544, [under1200.103, add.9540, _9543, ])
// [KnfOpt] Inline threshold 16
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 0
// [KnfOpt] Inline decision concat.31 accepted
// [KnfOpt] Inline threshold 3
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 0
// [KnfOpt] Inline decision addx.59 accepted
// [KnfOpt] Inline threshold 20
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 0
// [KnfOpt] Inline decision map.1 accepted
// [KnfOpt] Inline threshold 5
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 0
// [KnfOpt] Inline decision gt.79 accepted
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 5
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 0
// [KnfOpt] Inline decision le.83 accepted
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.9567: Int = (x.9568: Int, y.9569: Int) {
// [KnfOpt]   Add(x.9568, y.9569)
// [KnfOpt] }
// [KnfOpt] let _9570: Int = Int(0)
// [KnfOpt] let join fold.9571: Int = (stream.9572: Fun([Unit], Tuple([Int, Int])), f.9573: Fun([Int, Int], Int), acc.9574: Int) {
// [KnfOpt]   let _9575: Unit = Unit
// [KnfOpt]   let _9576: Tuple([Int, Int]) = Apply(stream.9572, [_9575, ])
// [KnfOpt]   let (ok.9577: Var({val: Some(Int)}), val.9578: Var({val: Some(Int)})) = _9576
// [KnfOpt]   let _9579: Int = Int(0)
// [KnfOpt]   if (ok.9577 == _9579) then {
// [KnfOpt]     let sum.104: Int = Var(acc.9574)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _9580: Int = Apply(f.9573, [acc.9574, val.9578, ])
// [KnfOpt]     Jump(fold.9571, [stream.9572, f.9573, _9580, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.9571, [under1200.103, add.9567, _9570, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(le) let _102: Fun([Int], Int) = Unit
// [KnfOpt] let rec aux.9581: Tuple([Int, Int]) = (u.9582: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.9583: Tuple([Int, Int]) = (u.9584: Var({val: Some(Unit)})) {
// [KnfOpt]     let _9585: Unit = Unit
// [KnfOpt]     let _9586: Tuple([Int, Int]) = Apply(over50.100, [_9585, ])
// [KnfOpt]     let (ok.9587: Var({val: Some(Int)}), val.9588: Var({val: Some(Int)})) = _9586
// [KnfOpt]     let _9589: Int = Int(0)
// [KnfOpt]     if (ok.9587 == _9589) then {
// [KnfOpt]       let _9590: Int = Int(0)
// [KnfOpt]       let _9591: Int = Int(0)
// [KnfOpt]       Tuple([_9590, _9591, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.9592: Int = Apply(_102, [val.9588, ])
// [KnfOpt]       let _9593: Int = Int(0)
// [KnfOpt]       if (r.9592 == _9593) then {
// [KnfOpt]         let _9594: Int = Int(1)
// [KnfOpt]         Tuple([_9594, val.9588, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _9595: Unit = Unit
// [KnfOpt]         Jump(aux.9583, [_9595, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.9583, [u.9582, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.9581)
// [KnfOpt] let rec add.9596: Int = (x.9597: Int, y.9598: Int) {
// [KnfOpt]   Add(x.9597, y.9598)
// [KnfOpt] }
// [KnfOpt] let _9599: Int = Int(0)
// [KnfOpt] let join fold.9600: Int = (stream.9601: Fun([Unit], Tuple([Int, Int])), f.9602: Fun([Int, Int], Int), acc.9603: Int) {
// [KnfOpt]   let _9604: Unit = Unit
// [KnfOpt]   let _9605: Tuple([Int, Int]) = Apply(stream.9601, [_9604, ])
// [KnfOpt]   let (ok.9606: Var({val: Some(Int)}), val.9607: Var({val: Some(Int)})) = _9605
// [KnfOpt]   let _9608: Int = Int(0)
// [KnfOpt]   if (ok.9606 == _9608) then {
// [KnfOpt]     let sum.104: Int = Var(acc.9603)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _9609: Int = Apply(f.9602, [acc.9603, val.9607, ])
// [KnfOpt]     Jump(fold.9600, [stream.9601, f.9602, _9609, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.9600, [under1200.103, add.9596, _9599, ])
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.9612: Int = (x.9613: Int, y.9614: Int) {
// [KnfOpt]   Add(x.9613, y.9614)
// [KnfOpt] }
// [KnfOpt] let _9615: Int = Int(0)
// [KnfOpt] let join fold.9616: Int = (stream.9617: Fun([Unit], Tuple([Int, Int])), f.9618: Fun([Int, Int], Int), acc.9619: Int) {
// [KnfOpt]   let _9620: Unit = Unit
// [KnfOpt]   let _9621: Tuple([Int, Int]) = Apply(stream.9617, [_9620, ])
// [KnfOpt]   let (ok.9622: Var({val: Some(Int)}), val.9623: Var({val: Some(Int)})) = _9621
// [KnfOpt]   let _9624: Int = Int(0)
// [KnfOpt]   if (ok.9622 == _9624) then {
// [KnfOpt]     let sum.104: Int = Var(acc.9619)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _9625: Int = Apply(f.9618, [acc.9619, val.9623, ])
// [KnfOpt]     Jump(fold.9616, [stream.9617, f.9618, _9625, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.9616, [under1200.103, add.9612, _9615, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let over50.100: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let _101: Int = Int(1200)
// [KnfOpt] let rec aux.9610: Int = (y.9611: Int) {
// [KnfOpt]   if (y.9611 <= _101) then {
// [KnfOpt]     Int(0)
// [KnfOpt]   } else {
// [KnfOpt]     Int(1)
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] let _102: Fun([Int], Int) = Var(aux.9610)
// [KnfOpt] let rec aux.9626: Tuple([Int, Int]) = (u.9627: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.9628: Tuple([Int, Int]) = (u.9629: Var({val: Some(Unit)})) {
// [KnfOpt]     let _9630: Unit = Unit
// [KnfOpt]     let _9631: Tuple([Int, Int]) = Apply(over50.100, [_9630, ])
// [KnfOpt]     let (ok.9632: Var({val: Some(Int)}), val.9633: Var({val: Some(Int)})) = _9631
// [KnfOpt]     let _9634: Int = Int(0)
// [KnfOpt]     if (ok.9632 == _9634) then {
// [KnfOpt]       let _9635: Int = Int(0)
// [KnfOpt]       let _9636: Int = Int(0)
// [KnfOpt]       Tuple([_9635, _9636, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.9637: Int = Apply(_102, [val.9633, ])
// [KnfOpt]       let _9638: Int = Int(0)
// [KnfOpt]       if (r.9637 == _9638) then {
// [KnfOpt]         let _9639: Int = Int(1)
// [KnfOpt]         Tuple([_9639, val.9633, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _9640: Unit = Unit
// [KnfOpt]         Jump(aux.9628, [_9640, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.9628, [u.9627, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.9626)
// [KnfOpt] let rec add.9641: Int = (x.9642: Int, y.9643: Int) {
// [KnfOpt]   Add(x.9642, y.9643)
// [KnfOpt] }
// [KnfOpt] let _9644: Int = Int(0)
// [KnfOpt] let join fold.9645: Int = (stream.9646: Fun([Unit], Tuple([Int, Int])), f.9647: Fun([Int, Int], Int), acc.9648: Int) {
// [KnfOpt]   let _9649: Unit = Unit
// [KnfOpt]   let _9650: Tuple([Int, Int]) = Apply(stream.9646, [_9649, ])
// [KnfOpt]   let (ok.9651: Var({val: Some(Int)}), val.9652: Var({val: Some(Int)})) = _9650
// [KnfOpt]   let _9653: Int = Int(0)
// [KnfOpt]   if (ok.9651 == _9653) then {
// [KnfOpt]     let sum.104: Int = Var(acc.9648)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _9654: Int = Apply(f.9647, [acc.9648, val.9652, ])
// [KnfOpt]     Jump(fold.9645, [stream.9646, f.9647, _9654, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.9645, [under1200.103, add.9641, _9644, ])
// [KnfOpt] Inline threshold 5
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 0
// [KnfOpt] Inline decision le.83 accepted
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.9670: Int = (x.9671: Int, y.9672: Int) {
// [KnfOpt]   Add(x.9671, y.9672)
// [KnfOpt] }
// [KnfOpt] let _9673: Int = Int(0)
// [KnfOpt] let join fold.9674: Int = (stream.9675: Fun([Unit], Tuple([Int, Int])), f.9676: Fun([Int, Int], Int), acc.9677: Int) {
// [KnfOpt]   let _9678: Unit = Unit
// [KnfOpt]   let _9679: Tuple([Int, Int]) = Apply(stream.9675, [_9678, ])
// [KnfOpt]   let (ok.9680: Var({val: Some(Int)}), val.9681: Var({val: Some(Int)})) = _9679
// [KnfOpt]   let _9682: Int = Int(0)
// [KnfOpt]   if (ok.9680 == _9682) then {
// [KnfOpt]     let sum.104: Int = Var(acc.9677)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _9683: Int = Apply(f.9676, [acc.9677, val.9681, ])
// [KnfOpt]     Jump(fold.9674, [stream.9675, f.9676, _9683, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.9674, [under1200.103, add.9670, _9673, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(le) let _102: Fun([Int], Int) = Unit
// [KnfOpt] let rec aux.9684: Tuple([Int, Int]) = (u.9685: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.9686: Tuple([Int, Int]) = (u.9687: Var({val: Some(Unit)})) {
// [KnfOpt]     let _9688: Unit = Unit
// [KnfOpt]     let _9689: Tuple([Int, Int]) = Apply(over50.100, [_9688, ])
// [KnfOpt]     let (ok.9690: Var({val: Some(Int)}), val.9691: Var({val: Some(Int)})) = _9689
// [KnfOpt]     let _9692: Int = Int(0)
// [KnfOpt]     if (ok.9690 == _9692) then {
// [KnfOpt]       let _9693: Int = Int(0)
// [KnfOpt]       let _9694: Int = Int(0)
// [KnfOpt]       Tuple([_9693, _9694, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.9695: Int = Apply(_102, [val.9691, ])
// [KnfOpt]       let _9696: Int = Int(0)
// [KnfOpt]       if (r.9695 == _9696) then {
// [KnfOpt]         let _9697: Int = Int(1)
// [KnfOpt]         Tuple([_9697, val.9691, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _9698: Unit = Unit
// [KnfOpt]         Jump(aux.9686, [_9698, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.9686, [u.9685, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.9684)
// [KnfOpt] let rec add.9699: Int = (x.9700: Int, y.9701: Int) {
// [KnfOpt]   Add(x.9700, y.9701)
// [KnfOpt] }
// [KnfOpt] let _9702: Int = Int(0)
// [KnfOpt] let join fold.9703: Int = (stream.9704: Fun([Unit], Tuple([Int, Int])), f.9705: Fun([Int, Int], Int), acc.9706: Int) {
// [KnfOpt]   let _9707: Unit = Unit
// [KnfOpt]   let _9708: Tuple([Int, Int]) = Apply(stream.9704, [_9707, ])
// [KnfOpt]   let (ok.9709: Var({val: Some(Int)}), val.9710: Var({val: Some(Int)})) = _9708
// [KnfOpt]   let _9711: Int = Int(0)
// [KnfOpt]   if (ok.9709 == _9711) then {
// [KnfOpt]     let sum.104: Int = Var(acc.9706)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _9712: Int = Apply(f.9705, [acc.9706, val.9710, ])
// [KnfOpt]     Jump(fold.9703, [stream.9704, f.9705, _9712, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.9703, [under1200.103, add.9699, _9702, ])
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.9715: Int = (x.9716: Int, y.9717: Int) {
// [KnfOpt]   Add(x.9716, y.9717)
// [KnfOpt] }
// [KnfOpt] let _9718: Int = Int(0)
// [KnfOpt] let join fold.9719: Int = (stream.9720: Fun([Unit], Tuple([Int, Int])), f.9721: Fun([Int, Int], Int), acc.9722: Int) {
// [KnfOpt]   let _9723: Unit = Unit
// [KnfOpt]   let _9724: Tuple([Int, Int]) = Apply(stream.9720, [_9723, ])
// [KnfOpt]   let (ok.9725: Var({val: Some(Int)}), val.9726: Var({val: Some(Int)})) = _9724
// [KnfOpt]   let _9727: Int = Int(0)
// [KnfOpt]   if (ok.9725 == _9727) then {
// [KnfOpt]     let sum.104: Int = Var(acc.9722)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _9728: Int = Apply(f.9721, [acc.9722, val.9726, ])
// [KnfOpt]     Jump(fold.9719, [stream.9720, f.9721, _9728, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.9719, [under1200.103, add.9715, _9718, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(gt) let _99: Fun([Int], Int) = Unit
// [KnfOpt] let rec aux.9655: Tuple([Int, Int]) = (u.9656: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.9657: Tuple([Int, Int]) = (u.9658: Var({val: Some(Unit)})) {
// [KnfOpt]     let _9659: Unit = Unit
// [KnfOpt]     let _9660: Tuple([Int, Int]) = Apply(addone.97, [_9659, ])
// [KnfOpt]     let (ok.9661: Var({val: Some(Int)}), val.9662: Var({val: Some(Int)})) = _9660
// [KnfOpt]     let _9663: Int = Int(0)
// [KnfOpt]     if (ok.9661 == _9663) then {
// [KnfOpt]       let _9664: Int = Int(0)
// [KnfOpt]       let _9665: Int = Int(0)
// [KnfOpt]       Tuple([_9664, _9665, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.9666: Int = Apply(_99, [val.9662, ])
// [KnfOpt]       let _9667: Int = Int(0)
// [KnfOpt]       if (r.9666 == _9667) then {
// [KnfOpt]         let _9668: Int = Int(1)
// [KnfOpt]         Tuple([_9668, val.9662, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _9669: Unit = Unit
// [KnfOpt]         Jump(aux.9657, [_9669, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.9657, [u.9656, ])
// [KnfOpt] }
// [KnfOpt] let over50.100: Fun([Unit], Tuple([Int, Int])) = Var(aux.9655)
// [KnfOpt] let _101: Int = Int(1200)
// [KnfOpt] let rec aux.9713: Int = (y.9714: Int) {
// [KnfOpt]   if (y.9714 <= _101) then {
// [KnfOpt]     Int(0)
// [KnfOpt]   } else {
// [KnfOpt]     Int(1)
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] let _102: Fun([Int], Int) = Var(aux.9713)
// [KnfOpt] let rec aux.9729: Tuple([Int, Int]) = (u.9730: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.9731: Tuple([Int, Int]) = (u.9732: Var({val: Some(Unit)})) {
// [KnfOpt]     let _9733: Unit = Unit
// [KnfOpt]     let _9734: Tuple([Int, Int]) = Apply(over50.100, [_9733, ])
// [KnfOpt]     let (ok.9735: Var({val: Some(Int)}), val.9736: Var({val: Some(Int)})) = _9734
// [KnfOpt]     let _9737: Int = Int(0)
// [KnfOpt]     if (ok.9735 == _9737) then {
// [KnfOpt]       let _9738: Int = Int(0)
// [KnfOpt]       let _9739: Int = Int(0)
// [KnfOpt]       Tuple([_9738, _9739, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.9740: Int = Apply(_102, [val.9736, ])
// [KnfOpt]       let _9741: Int = Int(0)
// [KnfOpt]       if (r.9740 == _9741) then {
// [KnfOpt]         let _9742: Int = Int(1)
// [KnfOpt]         Tuple([_9742, val.9736, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _9743: Unit = Unit
// [KnfOpt]         Jump(aux.9731, [_9743, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.9731, [u.9730, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.9729)
// [KnfOpt] let rec add.9744: Int = (x.9745: Int, y.9746: Int) {
// [KnfOpt]   Add(x.9745, y.9746)
// [KnfOpt] }
// [KnfOpt] let _9747: Int = Int(0)
// [KnfOpt] let join fold.9748: Int = (stream.9749: Fun([Unit], Tuple([Int, Int])), f.9750: Fun([Int, Int], Int), acc.9751: Int) {
// [KnfOpt]   let _9752: Unit = Unit
// [KnfOpt]   let _9753: Tuple([Int, Int]) = Apply(stream.9749, [_9752, ])
// [KnfOpt]   let (ok.9754: Var({val: Some(Int)}), val.9755: Var({val: Some(Int)})) = _9753
// [KnfOpt]   let _9756: Int = Int(0)
// [KnfOpt]   if (ok.9754 == _9756) then {
// [KnfOpt]     let sum.104: Int = Var(acc.9751)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _9757: Int = Apply(f.9750, [acc.9751, val.9755, ])
// [KnfOpt]     Jump(fold.9748, [stream.9749, f.9750, _9757, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.9748, [under1200.103, add.9744, _9747, ])
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 5
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 0
// [KnfOpt] Inline decision le.83 accepted
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.9760: Int = (x.9761: Int, y.9762: Int) {
// [KnfOpt]   Add(x.9761, y.9762)
// [KnfOpt] }
// [KnfOpt] let _9763: Int = Int(0)
// [KnfOpt] let join fold.9764: Int = (stream.9765: Fun([Unit], Tuple([Int, Int])), f.9766: Fun([Int, Int], Int), acc.9767: Int) {
// [KnfOpt]   let _9768: Unit = Unit
// [KnfOpt]   let _9769: Tuple([Int, Int]) = Apply(stream.9765, [_9768, ])
// [KnfOpt]   let (ok.9770: Var({val: Some(Int)}), val.9771: Var({val: Some(Int)})) = _9769
// [KnfOpt]   let _9772: Int = Int(0)
// [KnfOpt]   if (ok.9770 == _9772) then {
// [KnfOpt]     let sum.104: Int = Var(acc.9767)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _9773: Int = Apply(f.9766, [acc.9767, val.9771, ])
// [KnfOpt]     Jump(fold.9764, [stream.9765, f.9766, _9773, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.9764, [under1200.103, add.9760, _9763, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(le) let _102: Fun([Int], Int) = Unit
// [KnfOpt] let rec aux.9774: Tuple([Int, Int]) = (u.9775: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.9776: Tuple([Int, Int]) = (u.9777: Var({val: Some(Unit)})) {
// [KnfOpt]     let _9778: Unit = Unit
// [KnfOpt]     let _9779: Tuple([Int, Int]) = Apply(over50.100, [_9778, ])
// [KnfOpt]     let (ok.9780: Var({val: Some(Int)}), val.9781: Var({val: Some(Int)})) = _9779
// [KnfOpt]     let _9782: Int = Int(0)
// [KnfOpt]     if (ok.9780 == _9782) then {
// [KnfOpt]       let _9783: Int = Int(0)
// [KnfOpt]       let _9784: Int = Int(0)
// [KnfOpt]       Tuple([_9783, _9784, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.9785: Int = Apply(_102, [val.9781, ])
// [KnfOpt]       let _9786: Int = Int(0)
// [KnfOpt]       if (r.9785 == _9786) then {
// [KnfOpt]         let _9787: Int = Int(1)
// [KnfOpt]         Tuple([_9787, val.9781, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _9788: Unit = Unit
// [KnfOpt]         Jump(aux.9776, [_9788, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.9776, [u.9775, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.9774)
// [KnfOpt] let rec add.9789: Int = (x.9790: Int, y.9791: Int) {
// [KnfOpt]   Add(x.9790, y.9791)
// [KnfOpt] }
// [KnfOpt] let _9792: Int = Int(0)
// [KnfOpt] let join fold.9793: Int = (stream.9794: Fun([Unit], Tuple([Int, Int])), f.9795: Fun([Int, Int], Int), acc.9796: Int) {
// [KnfOpt]   let _9797: Unit = Unit
// [KnfOpt]   let _9798: Tuple([Int, Int]) = Apply(stream.9794, [_9797, ])
// [KnfOpt]   let (ok.9799: Var({val: Some(Int)}), val.9800: Var({val: Some(Int)})) = _9798
// [KnfOpt]   let _9801: Int = Int(0)
// [KnfOpt]   if (ok.9799 == _9801) then {
// [KnfOpt]     let sum.104: Int = Var(acc.9796)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _9802: Int = Apply(f.9795, [acc.9796, val.9800, ])
// [KnfOpt]     Jump(fold.9793, [stream.9794, f.9795, _9802, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.9793, [under1200.103, add.9789, _9792, ])
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.9805: Int = (x.9806: Int, y.9807: Int) {
// [KnfOpt]   Add(x.9806, y.9807)
// [KnfOpt] }
// [KnfOpt] let _9808: Int = Int(0)
// [KnfOpt] let join fold.9809: Int = (stream.9810: Fun([Unit], Tuple([Int, Int])), f.9811: Fun([Int, Int], Int), acc.9812: Int) {
// [KnfOpt]   let _9813: Unit = Unit
// [KnfOpt]   let _9814: Tuple([Int, Int]) = Apply(stream.9810, [_9813, ])
// [KnfOpt]   let (ok.9815: Var({val: Some(Int)}), val.9816: Var({val: Some(Int)})) = _9814
// [KnfOpt]   let _9817: Int = Int(0)
// [KnfOpt]   if (ok.9815 == _9817) then {
// [KnfOpt]     let sum.104: Int = Var(acc.9812)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _9818: Int = Apply(f.9811, [acc.9812, val.9816, ])
// [KnfOpt]     Jump(fold.9809, [stream.9810, f.9811, _9818, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.9809, [under1200.103, add.9805, _9808, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let over50.100: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let _101: Int = Int(1200)
// [KnfOpt] let rec aux.9803: Int = (y.9804: Int) {
// [KnfOpt]   if (y.9804 <= _101) then {
// [KnfOpt]     Int(0)
// [KnfOpt]   } else {
// [KnfOpt]     Int(1)
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] let _102: Fun([Int], Int) = Var(aux.9803)
// [KnfOpt] let rec aux.9819: Tuple([Int, Int]) = (u.9820: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.9821: Tuple([Int, Int]) = (u.9822: Var({val: Some(Unit)})) {
// [KnfOpt]     let _9823: Unit = Unit
// [KnfOpt]     let _9824: Tuple([Int, Int]) = Apply(over50.100, [_9823, ])
// [KnfOpt]     let (ok.9825: Var({val: Some(Int)}), val.9826: Var({val: Some(Int)})) = _9824
// [KnfOpt]     let _9827: Int = Int(0)
// [KnfOpt]     if (ok.9825 == _9827) then {
// [KnfOpt]       let _9828: Int = Int(0)
// [KnfOpt]       let _9829: Int = Int(0)
// [KnfOpt]       Tuple([_9828, _9829, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.9830: Int = Apply(_102, [val.9826, ])
// [KnfOpt]       let _9831: Int = Int(0)
// [KnfOpt]       if (r.9830 == _9831) then {
// [KnfOpt]         let _9832: Int = Int(1)
// [KnfOpt]         Tuple([_9832, val.9826, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _9833: Unit = Unit
// [KnfOpt]         Jump(aux.9821, [_9833, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.9821, [u.9820, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.9819)
// [KnfOpt] let rec add.9834: Int = (x.9835: Int, y.9836: Int) {
// [KnfOpt]   Add(x.9835, y.9836)
// [KnfOpt] }
// [KnfOpt] let _9837: Int = Int(0)
// [KnfOpt] let join fold.9838: Int = (stream.9839: Fun([Unit], Tuple([Int, Int])), f.9840: Fun([Int, Int], Int), acc.9841: Int) {
// [KnfOpt]   let _9842: Unit = Unit
// [KnfOpt]   let _9843: Tuple([Int, Int]) = Apply(stream.9839, [_9842, ])
// [KnfOpt]   let (ok.9844: Var({val: Some(Int)}), val.9845: Var({val: Some(Int)})) = _9843
// [KnfOpt]   let _9846: Int = Int(0)
// [KnfOpt]   if (ok.9844 == _9846) then {
// [KnfOpt]     let sum.104: Int = Var(acc.9841)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _9847: Int = Apply(f.9840, [acc.9841, val.9845, ])
// [KnfOpt]     Jump(fold.9838, [stream.9839, f.9840, _9847, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.9838, [under1200.103, add.9834, _9837, ])
// [KnfOpt] Inline threshold 5
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 0
// [KnfOpt] Inline decision le.83 accepted
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.9863: Int = (x.9864: Int, y.9865: Int) {
// [KnfOpt]   Add(x.9864, y.9865)
// [KnfOpt] }
// [KnfOpt] let _9866: Int = Int(0)
// [KnfOpt] let join fold.9867: Int = (stream.9868: Fun([Unit], Tuple([Int, Int])), f.9869: Fun([Int, Int], Int), acc.9870: Int) {
// [KnfOpt]   let _9871: Unit = Unit
// [KnfOpt]   let _9872: Tuple([Int, Int]) = Apply(stream.9868, [_9871, ])
// [KnfOpt]   let (ok.9873: Var({val: Some(Int)}), val.9874: Var({val: Some(Int)})) = _9872
// [KnfOpt]   let _9875: Int = Int(0)
// [KnfOpt]   if (ok.9873 == _9875) then {
// [KnfOpt]     let sum.104: Int = Var(acc.9870)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _9876: Int = Apply(f.9869, [acc.9870, val.9874, ])
// [KnfOpt]     Jump(fold.9867, [stream.9868, f.9869, _9876, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.9867, [under1200.103, add.9863, _9866, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(le) let _102: Fun([Int], Int) = Unit
// [KnfOpt] let rec aux.9877: Tuple([Int, Int]) = (u.9878: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.9879: Tuple([Int, Int]) = (u.9880: Var({val: Some(Unit)})) {
// [KnfOpt]     let _9881: Unit = Unit
// [KnfOpt]     let _9882: Tuple([Int, Int]) = Apply(over50.100, [_9881, ])
// [KnfOpt]     let (ok.9883: Var({val: Some(Int)}), val.9884: Var({val: Some(Int)})) = _9882
// [KnfOpt]     let _9885: Int = Int(0)
// [KnfOpt]     if (ok.9883 == _9885) then {
// [KnfOpt]       let _9886: Int = Int(0)
// [KnfOpt]       let _9887: Int = Int(0)
// [KnfOpt]       Tuple([_9886, _9887, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.9888: Int = Apply(_102, [val.9884, ])
// [KnfOpt]       let _9889: Int = Int(0)
// [KnfOpt]       if (r.9888 == _9889) then {
// [KnfOpt]         let _9890: Int = Int(1)
// [KnfOpt]         Tuple([_9890, val.9884, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _9891: Unit = Unit
// [KnfOpt]         Jump(aux.9879, [_9891, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.9879, [u.9878, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.9877)
// [KnfOpt] let rec add.9892: Int = (x.9893: Int, y.9894: Int) {
// [KnfOpt]   Add(x.9893, y.9894)
// [KnfOpt] }
// [KnfOpt] let _9895: Int = Int(0)
// [KnfOpt] let join fold.9896: Int = (stream.9897: Fun([Unit], Tuple([Int, Int])), f.9898: Fun([Int, Int], Int), acc.9899: Int) {
// [KnfOpt]   let _9900: Unit = Unit
// [KnfOpt]   let _9901: Tuple([Int, Int]) = Apply(stream.9897, [_9900, ])
// [KnfOpt]   let (ok.9902: Var({val: Some(Int)}), val.9903: Var({val: Some(Int)})) = _9901
// [KnfOpt]   let _9904: Int = Int(0)
// [KnfOpt]   if (ok.9902 == _9904) then {
// [KnfOpt]     let sum.104: Int = Var(acc.9899)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _9905: Int = Apply(f.9898, [acc.9899, val.9903, ])
// [KnfOpt]     Jump(fold.9896, [stream.9897, f.9898, _9905, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.9896, [under1200.103, add.9892, _9895, ])
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.9908: Int = (x.9909: Int, y.9910: Int) {
// [KnfOpt]   Add(x.9909, y.9910)
// [KnfOpt] }
// [KnfOpt] let _9911: Int = Int(0)
// [KnfOpt] let join fold.9912: Int = (stream.9913: Fun([Unit], Tuple([Int, Int])), f.9914: Fun([Int, Int], Int), acc.9915: Int) {
// [KnfOpt]   let _9916: Unit = Unit
// [KnfOpt]   let _9917: Tuple([Int, Int]) = Apply(stream.9913, [_9916, ])
// [KnfOpt]   let (ok.9918: Var({val: Some(Int)}), val.9919: Var({val: Some(Int)})) = _9917
// [KnfOpt]   let _9920: Int = Int(0)
// [KnfOpt]   if (ok.9918 == _9920) then {
// [KnfOpt]     let sum.104: Int = Var(acc.9915)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _9921: Int = Apply(f.9914, [acc.9915, val.9919, ])
// [KnfOpt]     Jump(fold.9912, [stream.9913, f.9914, _9921, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.9912, [under1200.103, add.9908, _9911, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(map) let addone.97: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let _98: Int = Int(50)
// [KnfOpt] let rec aux.9758: Int = (y.9759: Int) {
// [KnfOpt]   if (_98 <= y.9759) then {
// [KnfOpt]     Int(0)
// [KnfOpt]   } else {
// [KnfOpt]     Int(1)
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] let _99: Fun([Int], Int) = Var(aux.9758)
// [KnfOpt] let rec aux.9848: Tuple([Int, Int]) = (u.9849: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.9850: Tuple([Int, Int]) = (u.9851: Var({val: Some(Unit)})) {
// [KnfOpt]     let _9852: Unit = Unit
// [KnfOpt]     let _9853: Tuple([Int, Int]) = Apply(addone.97, [_9852, ])
// [KnfOpt]     let (ok.9854: Var({val: Some(Int)}), val.9855: Var({val: Some(Int)})) = _9853
// [KnfOpt]     let _9856: Int = Int(0)
// [KnfOpt]     if (ok.9854 == _9856) then {
// [KnfOpt]       let _9857: Int = Int(0)
// [KnfOpt]       let _9858: Int = Int(0)
// [KnfOpt]       Tuple([_9857, _9858, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.9859: Int = Apply(_99, [val.9855, ])
// [KnfOpt]       let _9860: Int = Int(0)
// [KnfOpt]       if (r.9859 == _9860) then {
// [KnfOpt]         let _9861: Int = Int(1)
// [KnfOpt]         Tuple([_9861, val.9855, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _9862: Unit = Unit
// [KnfOpt]         Jump(aux.9850, [_9862, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.9850, [u.9849, ])
// [KnfOpt] }
// [KnfOpt] let over50.100: Fun([Unit], Tuple([Int, Int])) = Var(aux.9848)
// [KnfOpt] let _101: Int = Int(1200)
// [KnfOpt] let rec aux.9906: Int = (y.9907: Int) {
// [KnfOpt]   if (y.9907 <= _101) then {
// [KnfOpt]     Int(0)
// [KnfOpt]   } else {
// [KnfOpt]     Int(1)
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] let _102: Fun([Int], Int) = Var(aux.9906)
// [KnfOpt] let rec aux.9922: Tuple([Int, Int]) = (u.9923: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.9924: Tuple([Int, Int]) = (u.9925: Var({val: Some(Unit)})) {
// [KnfOpt]     let _9926: Unit = Unit
// [KnfOpt]     let _9927: Tuple([Int, Int]) = Apply(over50.100, [_9926, ])
// [KnfOpt]     let (ok.9928: Var({val: Some(Int)}), val.9929: Var({val: Some(Int)})) = _9927
// [KnfOpt]     let _9930: Int = Int(0)
// [KnfOpt]     if (ok.9928 == _9930) then {
// [KnfOpt]       let _9931: Int = Int(0)
// [KnfOpt]       let _9932: Int = Int(0)
// [KnfOpt]       Tuple([_9931, _9932, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.9933: Int = Apply(_102, [val.9929, ])
// [KnfOpt]       let _9934: Int = Int(0)
// [KnfOpt]       if (r.9933 == _9934) then {
// [KnfOpt]         let _9935: Int = Int(1)
// [KnfOpt]         Tuple([_9935, val.9929, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _9936: Unit = Unit
// [KnfOpt]         Jump(aux.9924, [_9936, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.9924, [u.9923, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.9922)
// [KnfOpt] let rec add.9937: Int = (x.9938: Int, y.9939: Int) {
// [KnfOpt]   Add(x.9938, y.9939)
// [KnfOpt] }
// [KnfOpt] let _9940: Int = Int(0)
// [KnfOpt] let join fold.9941: Int = (stream.9942: Fun([Unit], Tuple([Int, Int])), f.9943: Fun([Int, Int], Int), acc.9944: Int) {
// [KnfOpt]   let _9945: Unit = Unit
// [KnfOpt]   let _9946: Tuple([Int, Int]) = Apply(stream.9942, [_9945, ])
// [KnfOpt]   let (ok.9947: Var({val: Some(Int)}), val.9948: Var({val: Some(Int)})) = _9946
// [KnfOpt]   let _9949: Int = Int(0)
// [KnfOpt]   if (ok.9947 == _9949) then {
// [KnfOpt]     let sum.104: Int = Var(acc.9944)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _9950: Int = Apply(f.9943, [acc.9944, val.9948, ])
// [KnfOpt]     Jump(fold.9941, [stream.9942, f.9943, _9950, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.9941, [under1200.103, add.9937, _9940, ])
// [KnfOpt] Inline threshold 5
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 0
// [KnfOpt] Inline decision gt.79 accepted
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 5
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 0
// [KnfOpt] Inline decision le.83 accepted
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.9962: Int = (x.9963: Int, y.9964: Int) {
// [KnfOpt]   Add(x.9963, y.9964)
// [KnfOpt] }
// [KnfOpt] let _9965: Int = Int(0)
// [KnfOpt] let join fold.9966: Int = (stream.9967: Fun([Unit], Tuple([Int, Int])), f.9968: Fun([Int, Int], Int), acc.9969: Int) {
// [KnfOpt]   let _9970: Unit = Unit
// [KnfOpt]   let _9971: Tuple([Int, Int]) = Apply(stream.9967, [_9970, ])
// [KnfOpt]   let (ok.9972: Var({val: Some(Int)}), val.9973: Var({val: Some(Int)})) = _9971
// [KnfOpt]   let _9974: Int = Int(0)
// [KnfOpt]   if (ok.9972 == _9974) then {
// [KnfOpt]     let sum.104: Int = Var(acc.9969)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _9975: Int = Apply(f.9968, [acc.9969, val.9973, ])
// [KnfOpt]     Jump(fold.9966, [stream.9967, f.9968, _9975, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.9966, [under1200.103, add.9962, _9965, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(le) let _102: Fun([Int], Int) = Unit
// [KnfOpt] let rec aux.9976: Tuple([Int, Int]) = (u.9977: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.9978: Tuple([Int, Int]) = (u.9979: Var({val: Some(Unit)})) {
// [KnfOpt]     let _9980: Unit = Unit
// [KnfOpt]     let _9981: Tuple([Int, Int]) = Apply(over50.100, [_9980, ])
// [KnfOpt]     let (ok.9982: Var({val: Some(Int)}), val.9983: Var({val: Some(Int)})) = _9981
// [KnfOpt]     let _9984: Int = Int(0)
// [KnfOpt]     if (ok.9982 == _9984) then {
// [KnfOpt]       let _9985: Int = Int(0)
// [KnfOpt]       let _9986: Int = Int(0)
// [KnfOpt]       Tuple([_9985, _9986, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.9987: Int = Apply(_102, [val.9983, ])
// [KnfOpt]       let _9988: Int = Int(0)
// [KnfOpt]       if (r.9987 == _9988) then {
// [KnfOpt]         let _9989: Int = Int(1)
// [KnfOpt]         Tuple([_9989, val.9983, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _9990: Unit = Unit
// [KnfOpt]         Jump(aux.9978, [_9990, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.9978, [u.9977, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.9976)
// [KnfOpt] let rec add.9991: Int = (x.9992: Int, y.9993: Int) {
// [KnfOpt]   Add(x.9992, y.9993)
// [KnfOpt] }
// [KnfOpt] let _9994: Int = Int(0)
// [KnfOpt] let join fold.9995: Int = (stream.9996: Fun([Unit], Tuple([Int, Int])), f.9997: Fun([Int, Int], Int), acc.9998: Int) {
// [KnfOpt]   let _9999: Unit = Unit
// [KnfOpt]   let _10000: Tuple([Int, Int]) = Apply(stream.9996, [_9999, ])
// [KnfOpt]   let (ok.10001: Var({val: Some(Int)}), val.10002: Var({val: Some(Int)})) = _10000
// [KnfOpt]   let _10003: Int = Int(0)
// [KnfOpt]   if (ok.10001 == _10003) then {
// [KnfOpt]     let sum.104: Int = Var(acc.9998)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _10004: Int = Apply(f.9997, [acc.9998, val.10002, ])
// [KnfOpt]     Jump(fold.9995, [stream.9996, f.9997, _10004, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.9995, [under1200.103, add.9991, _9994, ])
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.10007: Int = (x.10008: Int, y.10009: Int) {
// [KnfOpt]   Add(x.10008, y.10009)
// [KnfOpt] }
// [KnfOpt] let _10010: Int = Int(0)
// [KnfOpt] let join fold.10011: Int = (stream.10012: Fun([Unit], Tuple([Int, Int])), f.10013: Fun([Int, Int], Int), acc.10014: Int) {
// [KnfOpt]   let _10015: Unit = Unit
// [KnfOpt]   let _10016: Tuple([Int, Int]) = Apply(stream.10012, [_10015, ])
// [KnfOpt]   let (ok.10017: Var({val: Some(Int)}), val.10018: Var({val: Some(Int)})) = _10016
// [KnfOpt]   let _10019: Int = Int(0)
// [KnfOpt]   if (ok.10017 == _10019) then {
// [KnfOpt]     let sum.104: Int = Var(acc.10014)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _10020: Int = Apply(f.10013, [acc.10014, val.10018, ])
// [KnfOpt]     Jump(fold.10011, [stream.10012, f.10013, _10020, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.10011, [under1200.103, add.10007, _10010, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let over50.100: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let _101: Int = Int(1200)
// [KnfOpt] let rec aux.10005: Int = (y.10006: Int) {
// [KnfOpt]   if (y.10006 <= _101) then {
// [KnfOpt]     Int(0)
// [KnfOpt]   } else {
// [KnfOpt]     Int(1)
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] let _102: Fun([Int], Int) = Var(aux.10005)
// [KnfOpt] let rec aux.10021: Tuple([Int, Int]) = (u.10022: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.10023: Tuple([Int, Int]) = (u.10024: Var({val: Some(Unit)})) {
// [KnfOpt]     let _10025: Unit = Unit
// [KnfOpt]     let _10026: Tuple([Int, Int]) = Apply(over50.100, [_10025, ])
// [KnfOpt]     let (ok.10027: Var({val: Some(Int)}), val.10028: Var({val: Some(Int)})) = _10026
// [KnfOpt]     let _10029: Int = Int(0)
// [KnfOpt]     if (ok.10027 == _10029) then {
// [KnfOpt]       let _10030: Int = Int(0)
// [KnfOpt]       let _10031: Int = Int(0)
// [KnfOpt]       Tuple([_10030, _10031, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.10032: Int = Apply(_102, [val.10028, ])
// [KnfOpt]       let _10033: Int = Int(0)
// [KnfOpt]       if (r.10032 == _10033) then {
// [KnfOpt]         let _10034: Int = Int(1)
// [KnfOpt]         Tuple([_10034, val.10028, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _10035: Unit = Unit
// [KnfOpt]         Jump(aux.10023, [_10035, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.10023, [u.10022, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.10021)
// [KnfOpt] let rec add.10036: Int = (x.10037: Int, y.10038: Int) {
// [KnfOpt]   Add(x.10037, y.10038)
// [KnfOpt] }
// [KnfOpt] let _10039: Int = Int(0)
// [KnfOpt] let join fold.10040: Int = (stream.10041: Fun([Unit], Tuple([Int, Int])), f.10042: Fun([Int, Int], Int), acc.10043: Int) {
// [KnfOpt]   let _10044: Unit = Unit
// [KnfOpt]   let _10045: Tuple([Int, Int]) = Apply(stream.10041, [_10044, ])
// [KnfOpt]   let (ok.10046: Var({val: Some(Int)}), val.10047: Var({val: Some(Int)})) = _10045
// [KnfOpt]   let _10048: Int = Int(0)
// [KnfOpt]   if (ok.10046 == _10048) then {
// [KnfOpt]     let sum.104: Int = Var(acc.10043)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _10049: Int = Apply(f.10042, [acc.10043, val.10047, ])
// [KnfOpt]     Jump(fold.10040, [stream.10041, f.10042, _10049, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.10040, [under1200.103, add.10036, _10039, ])
// [KnfOpt] Inline threshold 5
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 0
// [KnfOpt] Inline decision le.83 accepted
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.10065: Int = (x.10066: Int, y.10067: Int) {
// [KnfOpt]   Add(x.10066, y.10067)
// [KnfOpt] }
// [KnfOpt] let _10068: Int = Int(0)
// [KnfOpt] let join fold.10069: Int = (stream.10070: Fun([Unit], Tuple([Int, Int])), f.10071: Fun([Int, Int], Int), acc.10072: Int) {
// [KnfOpt]   let _10073: Unit = Unit
// [KnfOpt]   let _10074: Tuple([Int, Int]) = Apply(stream.10070, [_10073, ])
// [KnfOpt]   let (ok.10075: Var({val: Some(Int)}), val.10076: Var({val: Some(Int)})) = _10074
// [KnfOpt]   let _10077: Int = Int(0)
// [KnfOpt]   if (ok.10075 == _10077) then {
// [KnfOpt]     let sum.104: Int = Var(acc.10072)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _10078: Int = Apply(f.10071, [acc.10072, val.10076, ])
// [KnfOpt]     Jump(fold.10069, [stream.10070, f.10071, _10078, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.10069, [under1200.103, add.10065, _10068, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(le) let _102: Fun([Int], Int) = Unit
// [KnfOpt] let rec aux.10079: Tuple([Int, Int]) = (u.10080: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.10081: Tuple([Int, Int]) = (u.10082: Var({val: Some(Unit)})) {
// [KnfOpt]     let _10083: Unit = Unit
// [KnfOpt]     let _10084: Tuple([Int, Int]) = Apply(over50.100, [_10083, ])
// [KnfOpt]     let (ok.10085: Var({val: Some(Int)}), val.10086: Var({val: Some(Int)})) = _10084
// [KnfOpt]     let _10087: Int = Int(0)
// [KnfOpt]     if (ok.10085 == _10087) then {
// [KnfOpt]       let _10088: Int = Int(0)
// [KnfOpt]       let _10089: Int = Int(0)
// [KnfOpt]       Tuple([_10088, _10089, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.10090: Int = Apply(_102, [val.10086, ])
// [KnfOpt]       let _10091: Int = Int(0)
// [KnfOpt]       if (r.10090 == _10091) then {
// [KnfOpt]         let _10092: Int = Int(1)
// [KnfOpt]         Tuple([_10092, val.10086, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _10093: Unit = Unit
// [KnfOpt]         Jump(aux.10081, [_10093, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.10081, [u.10080, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.10079)
// [KnfOpt] let rec add.10094: Int = (x.10095: Int, y.10096: Int) {
// [KnfOpt]   Add(x.10095, y.10096)
// [KnfOpt] }
// [KnfOpt] let _10097: Int = Int(0)
// [KnfOpt] let join fold.10098: Int = (stream.10099: Fun([Unit], Tuple([Int, Int])), f.10100: Fun([Int, Int], Int), acc.10101: Int) {
// [KnfOpt]   let _10102: Unit = Unit
// [KnfOpt]   let _10103: Tuple([Int, Int]) = Apply(stream.10099, [_10102, ])
// [KnfOpt]   let (ok.10104: Var({val: Some(Int)}), val.10105: Var({val: Some(Int)})) = _10103
// [KnfOpt]   let _10106: Int = Int(0)
// [KnfOpt]   if (ok.10104 == _10106) then {
// [KnfOpt]     let sum.104: Int = Var(acc.10101)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _10107: Int = Apply(f.10100, [acc.10101, val.10105, ])
// [KnfOpt]     Jump(fold.10098, [stream.10099, f.10100, _10107, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.10098, [under1200.103, add.10094, _10097, ])
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.10110: Int = (x.10111: Int, y.10112: Int) {
// [KnfOpt]   Add(x.10111, y.10112)
// [KnfOpt] }
// [KnfOpt] let _10113: Int = Int(0)
// [KnfOpt] let join fold.10114: Int = (stream.10115: Fun([Unit], Tuple([Int, Int])), f.10116: Fun([Int, Int], Int), acc.10117: Int) {
// [KnfOpt]   let _10118: Unit = Unit
// [KnfOpt]   let _10119: Tuple([Int, Int]) = Apply(stream.10115, [_10118, ])
// [KnfOpt]   let (ok.10120: Var({val: Some(Int)}), val.10121: Var({val: Some(Int)})) = _10119
// [KnfOpt]   let _10122: Int = Int(0)
// [KnfOpt]   if (ok.10120 == _10122) then {
// [KnfOpt]     let sum.104: Int = Var(acc.10117)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _10123: Int = Apply(f.10116, [acc.10117, val.10121, ])
// [KnfOpt]     Jump(fold.10114, [stream.10115, f.10116, _10123, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.10114, [under1200.103, add.10110, _10113, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(gt) let _99: Fun([Int], Int) = Unit
// [KnfOpt] let rec aux.10050: Tuple([Int, Int]) = (u.10051: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.10052: Tuple([Int, Int]) = (u.10053: Var({val: Some(Unit)})) {
// [KnfOpt]     let _10054: Unit = Unit
// [KnfOpt]     let _10055: Tuple([Int, Int]) = Apply(addone.97, [_10054, ])
// [KnfOpt]     let (ok.10056: Var({val: Some(Int)}), val.10057: Var({val: Some(Int)})) = _10055
// [KnfOpt]     let _10058: Int = Int(0)
// [KnfOpt]     if (ok.10056 == _10058) then {
// [KnfOpt]       let _10059: Int = Int(0)
// [KnfOpt]       let _10060: Int = Int(0)
// [KnfOpt]       Tuple([_10059, _10060, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.10061: Int = Apply(_99, [val.10057, ])
// [KnfOpt]       let _10062: Int = Int(0)
// [KnfOpt]       if (r.10061 == _10062) then {
// [KnfOpt]         let _10063: Int = Int(1)
// [KnfOpt]         Tuple([_10063, val.10057, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _10064: Unit = Unit
// [KnfOpt]         Jump(aux.10052, [_10064, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.10052, [u.10051, ])
// [KnfOpt] }
// [KnfOpt] let over50.100: Fun([Unit], Tuple([Int, Int])) = Var(aux.10050)
// [KnfOpt] let _101: Int = Int(1200)
// [KnfOpt] let rec aux.10108: Int = (y.10109: Int) {
// [KnfOpt]   if (y.10109 <= _101) then {
// [KnfOpt]     Int(0)
// [KnfOpt]   } else {
// [KnfOpt]     Int(1)
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] let _102: Fun([Int], Int) = Var(aux.10108)
// [KnfOpt] let rec aux.10124: Tuple([Int, Int]) = (u.10125: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.10126: Tuple([Int, Int]) = (u.10127: Var({val: Some(Unit)})) {
// [KnfOpt]     let _10128: Unit = Unit
// [KnfOpt]     let _10129: Tuple([Int, Int]) = Apply(over50.100, [_10128, ])
// [KnfOpt]     let (ok.10130: Var({val: Some(Int)}), val.10131: Var({val: Some(Int)})) = _10129
// [KnfOpt]     let _10132: Int = Int(0)
// [KnfOpt]     if (ok.10130 == _10132) then {
// [KnfOpt]       let _10133: Int = Int(0)
// [KnfOpt]       let _10134: Int = Int(0)
// [KnfOpt]       Tuple([_10133, _10134, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.10135: Int = Apply(_102, [val.10131, ])
// [KnfOpt]       let _10136: Int = Int(0)
// [KnfOpt]       if (r.10135 == _10136) then {
// [KnfOpt]         let _10137: Int = Int(1)
// [KnfOpt]         Tuple([_10137, val.10131, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _10138: Unit = Unit
// [KnfOpt]         Jump(aux.10126, [_10138, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.10126, [u.10125, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.10124)
// [KnfOpt] let rec add.10139: Int = (x.10140: Int, y.10141: Int) {
// [KnfOpt]   Add(x.10140, y.10141)
// [KnfOpt] }
// [KnfOpt] let _10142: Int = Int(0)
// [KnfOpt] let join fold.10143: Int = (stream.10144: Fun([Unit], Tuple([Int, Int])), f.10145: Fun([Int, Int], Int), acc.10146: Int) {
// [KnfOpt]   let _10147: Unit = Unit
// [KnfOpt]   let _10148: Tuple([Int, Int]) = Apply(stream.10144, [_10147, ])
// [KnfOpt]   let (ok.10149: Var({val: Some(Int)}), val.10150: Var({val: Some(Int)})) = _10148
// [KnfOpt]   let _10151: Int = Int(0)
// [KnfOpt]   if (ok.10149 == _10151) then {
// [KnfOpt]     let sum.104: Int = Var(acc.10146)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _10152: Int = Apply(f.10145, [acc.10146, val.10150, ])
// [KnfOpt]     Jump(fold.10143, [stream.10144, f.10145, _10152, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.10143, [under1200.103, add.10139, _10142, ])
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 5
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 0
// [KnfOpt] Inline decision le.83 accepted
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.10155: Int = (x.10156: Int, y.10157: Int) {
// [KnfOpt]   Add(x.10156, y.10157)
// [KnfOpt] }
// [KnfOpt] let _10158: Int = Int(0)
// [KnfOpt] let join fold.10159: Int = (stream.10160: Fun([Unit], Tuple([Int, Int])), f.10161: Fun([Int, Int], Int), acc.10162: Int) {
// [KnfOpt]   let _10163: Unit = Unit
// [KnfOpt]   let _10164: Tuple([Int, Int]) = Apply(stream.10160, [_10163, ])
// [KnfOpt]   let (ok.10165: Var({val: Some(Int)}), val.10166: Var({val: Some(Int)})) = _10164
// [KnfOpt]   let _10167: Int = Int(0)
// [KnfOpt]   if (ok.10165 == _10167) then {
// [KnfOpt]     let sum.104: Int = Var(acc.10162)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _10168: Int = Apply(f.10161, [acc.10162, val.10166, ])
// [KnfOpt]     Jump(fold.10159, [stream.10160, f.10161, _10168, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.10159, [under1200.103, add.10155, _10158, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(le) let _102: Fun([Int], Int) = Unit
// [KnfOpt] let rec aux.10169: Tuple([Int, Int]) = (u.10170: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.10171: Tuple([Int, Int]) = (u.10172: Var({val: Some(Unit)})) {
// [KnfOpt]     let _10173: Unit = Unit
// [KnfOpt]     let _10174: Tuple([Int, Int]) = Apply(over50.100, [_10173, ])
// [KnfOpt]     let (ok.10175: Var({val: Some(Int)}), val.10176: Var({val: Some(Int)})) = _10174
// [KnfOpt]     let _10177: Int = Int(0)
// [KnfOpt]     if (ok.10175 == _10177) then {
// [KnfOpt]       let _10178: Int = Int(0)
// [KnfOpt]       let _10179: Int = Int(0)
// [KnfOpt]       Tuple([_10178, _10179, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.10180: Int = Apply(_102, [val.10176, ])
// [KnfOpt]       let _10181: Int = Int(0)
// [KnfOpt]       if (r.10180 == _10181) then {
// [KnfOpt]         let _10182: Int = Int(1)
// [KnfOpt]         Tuple([_10182, val.10176, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _10183: Unit = Unit
// [KnfOpt]         Jump(aux.10171, [_10183, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.10171, [u.10170, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.10169)
// [KnfOpt] let rec add.10184: Int = (x.10185: Int, y.10186: Int) {
// [KnfOpt]   Add(x.10185, y.10186)
// [KnfOpt] }
// [KnfOpt] let _10187: Int = Int(0)
// [KnfOpt] let join fold.10188: Int = (stream.10189: Fun([Unit], Tuple([Int, Int])), f.10190: Fun([Int, Int], Int), acc.10191: Int) {
// [KnfOpt]   let _10192: Unit = Unit
// [KnfOpt]   let _10193: Tuple([Int, Int]) = Apply(stream.10189, [_10192, ])
// [KnfOpt]   let (ok.10194: Var({val: Some(Int)}), val.10195: Var({val: Some(Int)})) = _10193
// [KnfOpt]   let _10196: Int = Int(0)
// [KnfOpt]   if (ok.10194 == _10196) then {
// [KnfOpt]     let sum.104: Int = Var(acc.10191)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _10197: Int = Apply(f.10190, [acc.10191, val.10195, ])
// [KnfOpt]     Jump(fold.10188, [stream.10189, f.10190, _10197, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.10188, [under1200.103, add.10184, _10187, ])
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.10200: Int = (x.10201: Int, y.10202: Int) {
// [KnfOpt]   Add(x.10201, y.10202)
// [KnfOpt] }
// [KnfOpt] let _10203: Int = Int(0)
// [KnfOpt] let join fold.10204: Int = (stream.10205: Fun([Unit], Tuple([Int, Int])), f.10206: Fun([Int, Int], Int), acc.10207: Int) {
// [KnfOpt]   let _10208: Unit = Unit
// [KnfOpt]   let _10209: Tuple([Int, Int]) = Apply(stream.10205, [_10208, ])
// [KnfOpt]   let (ok.10210: Var({val: Some(Int)}), val.10211: Var({val: Some(Int)})) = _10209
// [KnfOpt]   let _10212: Int = Int(0)
// [KnfOpt]   if (ok.10210 == _10212) then {
// [KnfOpt]     let sum.104: Int = Var(acc.10207)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _10213: Int = Apply(f.10206, [acc.10207, val.10211, ])
// [KnfOpt]     Jump(fold.10204, [stream.10205, f.10206, _10213, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.10204, [under1200.103, add.10200, _10203, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let over50.100: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let _101: Int = Int(1200)
// [KnfOpt] let rec aux.10198: Int = (y.10199: Int) {
// [KnfOpt]   if (y.10199 <= _101) then {
// [KnfOpt]     Int(0)
// [KnfOpt]   } else {
// [KnfOpt]     Int(1)
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] let _102: Fun([Int], Int) = Var(aux.10198)
// [KnfOpt] let rec aux.10214: Tuple([Int, Int]) = (u.10215: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.10216: Tuple([Int, Int]) = (u.10217: Var({val: Some(Unit)})) {
// [KnfOpt]     let _10218: Unit = Unit
// [KnfOpt]     let _10219: Tuple([Int, Int]) = Apply(over50.100, [_10218, ])
// [KnfOpt]     let (ok.10220: Var({val: Some(Int)}), val.10221: Var({val: Some(Int)})) = _10219
// [KnfOpt]     let _10222: Int = Int(0)
// [KnfOpt]     if (ok.10220 == _10222) then {
// [KnfOpt]       let _10223: Int = Int(0)
// [KnfOpt]       let _10224: Int = Int(0)
// [KnfOpt]       Tuple([_10223, _10224, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.10225: Int = Apply(_102, [val.10221, ])
// [KnfOpt]       let _10226: Int = Int(0)
// [KnfOpt]       if (r.10225 == _10226) then {
// [KnfOpt]         let _10227: Int = Int(1)
// [KnfOpt]         Tuple([_10227, val.10221, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _10228: Unit = Unit
// [KnfOpt]         Jump(aux.10216, [_10228, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.10216, [u.10215, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.10214)
// [KnfOpt] let rec add.10229: Int = (x.10230: Int, y.10231: Int) {
// [KnfOpt]   Add(x.10230, y.10231)
// [KnfOpt] }
// [KnfOpt] let _10232: Int = Int(0)
// [KnfOpt] let join fold.10233: Int = (stream.10234: Fun([Unit], Tuple([Int, Int])), f.10235: Fun([Int, Int], Int), acc.10236: Int) {
// [KnfOpt]   let _10237: Unit = Unit
// [KnfOpt]   let _10238: Tuple([Int, Int]) = Apply(stream.10234, [_10237, ])
// [KnfOpt]   let (ok.10239: Var({val: Some(Int)}), val.10240: Var({val: Some(Int)})) = _10238
// [KnfOpt]   let _10241: Int = Int(0)
// [KnfOpt]   if (ok.10239 == _10241) then {
// [KnfOpt]     let sum.104: Int = Var(acc.10236)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _10242: Int = Apply(f.10235, [acc.10236, val.10240, ])
// [KnfOpt]     Jump(fold.10233, [stream.10234, f.10235, _10242, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.10233, [under1200.103, add.10229, _10232, ])
// [KnfOpt] Inline threshold 5
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 0
// [KnfOpt] Inline decision le.83 accepted
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.10258: Int = (x.10259: Int, y.10260: Int) {
// [KnfOpt]   Add(x.10259, y.10260)
// [KnfOpt] }
// [KnfOpt] let _10261: Int = Int(0)
// [KnfOpt] let join fold.10262: Int = (stream.10263: Fun([Unit], Tuple([Int, Int])), f.10264: Fun([Int, Int], Int), acc.10265: Int) {
// [KnfOpt]   let _10266: Unit = Unit
// [KnfOpt]   let _10267: Tuple([Int, Int]) = Apply(stream.10263, [_10266, ])
// [KnfOpt]   let (ok.10268: Var({val: Some(Int)}), val.10269: Var({val: Some(Int)})) = _10267
// [KnfOpt]   let _10270: Int = Int(0)
// [KnfOpt]   if (ok.10268 == _10270) then {
// [KnfOpt]     let sum.104: Int = Var(acc.10265)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _10271: Int = Apply(f.10264, [acc.10265, val.10269, ])
// [KnfOpt]     Jump(fold.10262, [stream.10263, f.10264, _10271, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.10262, [under1200.103, add.10258, _10261, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(le) let _102: Fun([Int], Int) = Unit
// [KnfOpt] let rec aux.10272: Tuple([Int, Int]) = (u.10273: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.10274: Tuple([Int, Int]) = (u.10275: Var({val: Some(Unit)})) {
// [KnfOpt]     let _10276: Unit = Unit
// [KnfOpt]     let _10277: Tuple([Int, Int]) = Apply(over50.100, [_10276, ])
// [KnfOpt]     let (ok.10278: Var({val: Some(Int)}), val.10279: Var({val: Some(Int)})) = _10277
// [KnfOpt]     let _10280: Int = Int(0)
// [KnfOpt]     if (ok.10278 == _10280) then {
// [KnfOpt]       let _10281: Int = Int(0)
// [KnfOpt]       let _10282: Int = Int(0)
// [KnfOpt]       Tuple([_10281, _10282, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.10283: Int = Apply(_102, [val.10279, ])
// [KnfOpt]       let _10284: Int = Int(0)
// [KnfOpt]       if (r.10283 == _10284) then {
// [KnfOpt]         let _10285: Int = Int(1)
// [KnfOpt]         Tuple([_10285, val.10279, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _10286: Unit = Unit
// [KnfOpt]         Jump(aux.10274, [_10286, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.10274, [u.10273, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.10272)
// [KnfOpt] let rec add.10287: Int = (x.10288: Int, y.10289: Int) {
// [KnfOpt]   Add(x.10288, y.10289)
// [KnfOpt] }
// [KnfOpt] let _10290: Int = Int(0)
// [KnfOpt] let join fold.10291: Int = (stream.10292: Fun([Unit], Tuple([Int, Int])), f.10293: Fun([Int, Int], Int), acc.10294: Int) {
// [KnfOpt]   let _10295: Unit = Unit
// [KnfOpt]   let _10296: Tuple([Int, Int]) = Apply(stream.10292, [_10295, ])
// [KnfOpt]   let (ok.10297: Var({val: Some(Int)}), val.10298: Var({val: Some(Int)})) = _10296
// [KnfOpt]   let _10299: Int = Int(0)
// [KnfOpt]   if (ok.10297 == _10299) then {
// [KnfOpt]     let sum.104: Int = Var(acc.10294)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _10300: Int = Apply(f.10293, [acc.10294, val.10298, ])
// [KnfOpt]     Jump(fold.10291, [stream.10292, f.10293, _10300, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.10291, [under1200.103, add.10287, _10290, ])
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.10303: Int = (x.10304: Int, y.10305: Int) {
// [KnfOpt]   Add(x.10304, y.10305)
// [KnfOpt] }
// [KnfOpt] let _10306: Int = Int(0)
// [KnfOpt] let join fold.10307: Int = (stream.10308: Fun([Unit], Tuple([Int, Int])), f.10309: Fun([Int, Int], Int), acc.10310: Int) {
// [KnfOpt]   let _10311: Unit = Unit
// [KnfOpt]   let _10312: Tuple([Int, Int]) = Apply(stream.10308, [_10311, ])
// [KnfOpt]   let (ok.10313: Var({val: Some(Int)}), val.10314: Var({val: Some(Int)})) = _10312
// [KnfOpt]   let _10315: Int = Int(0)
// [KnfOpt]   if (ok.10313 == _10315) then {
// [KnfOpt]     let sum.104: Int = Var(acc.10310)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _10316: Int = Apply(f.10309, [acc.10310, val.10314, ])
// [KnfOpt]     Jump(fold.10307, [stream.10308, f.10309, _10316, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.10307, [under1200.103, add.10303, _10306, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(addx) let _96: Fun([Int], Int) = Unit
// [KnfOpt] let rec aux.9951: Tuple([Int, Int]) = (u.9952: Var({val: Some(Unit)})) {
// [KnfOpt]   let _9953: Unit = Unit
// [KnfOpt]   let _9954: Tuple([Int, Int]) = Apply(catt.94, [_9953, ])
// [KnfOpt]   let (ok.9955: Var({val: Some(Int)}), val.9956: Var({val: Some(Int)})) = _9954
// [KnfOpt]   let _9957: Int = Int(0)
// [KnfOpt]   if (ok.9955 == _9957) then {
// [KnfOpt]     let _9958: Int = Int(0)
// [KnfOpt]     let _9959: Int = Int(0)
// [KnfOpt]     Tuple([_9958, _9959, ])
// [KnfOpt]   } else {
// [KnfOpt]     let _9960: Int = Int(1)
// [KnfOpt]     let _9961: Int = Apply(_96, [val.9956, ])
// [KnfOpt]     Tuple([_9960, _9961, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] let addone.97: Fun([Unit], Tuple([Int, Int])) = Var(aux.9951)
// [KnfOpt] let _98: Int = Int(50)
// [KnfOpt] let rec aux.10153: Int = (y.10154: Int) {
// [KnfOpt]   if (_98 <= y.10154) then {
// [KnfOpt]     Int(0)
// [KnfOpt]   } else {
// [KnfOpt]     Int(1)
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] let _99: Fun([Int], Int) = Var(aux.10153)
// [KnfOpt] let rec aux.10243: Tuple([Int, Int]) = (u.10244: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.10245: Tuple([Int, Int]) = (u.10246: Var({val: Some(Unit)})) {
// [KnfOpt]     let _10247: Unit = Unit
// [KnfOpt]     let _10248: Tuple([Int, Int]) = Apply(addone.97, [_10247, ])
// [KnfOpt]     let (ok.10249: Var({val: Some(Int)}), val.10250: Var({val: Some(Int)})) = _10248
// [KnfOpt]     let _10251: Int = Int(0)
// [KnfOpt]     if (ok.10249 == _10251) then {
// [KnfOpt]       let _10252: Int = Int(0)
// [KnfOpt]       let _10253: Int = Int(0)
// [KnfOpt]       Tuple([_10252, _10253, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.10254: Int = Apply(_99, [val.10250, ])
// [KnfOpt]       let _10255: Int = Int(0)
// [KnfOpt]       if (r.10254 == _10255) then {
// [KnfOpt]         let _10256: Int = Int(1)
// [KnfOpt]         Tuple([_10256, val.10250, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _10257: Unit = Unit
// [KnfOpt]         Jump(aux.10245, [_10257, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.10245, [u.10244, ])
// [KnfOpt] }
// [KnfOpt] let over50.100: Fun([Unit], Tuple([Int, Int])) = Var(aux.10243)
// [KnfOpt] let _101: Int = Int(1200)
// [KnfOpt] let rec aux.10301: Int = (y.10302: Int) {
// [KnfOpt]   if (y.10302 <= _101) then {
// [KnfOpt]     Int(0)
// [KnfOpt]   } else {
// [KnfOpt]     Int(1)
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] let _102: Fun([Int], Int) = Var(aux.10301)
// [KnfOpt] let rec aux.10317: Tuple([Int, Int]) = (u.10318: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.10319: Tuple([Int, Int]) = (u.10320: Var({val: Some(Unit)})) {
// [KnfOpt]     let _10321: Unit = Unit
// [KnfOpt]     let _10322: Tuple([Int, Int]) = Apply(over50.100, [_10321, ])
// [KnfOpt]     let (ok.10323: Var({val: Some(Int)}), val.10324: Var({val: Some(Int)})) = _10322
// [KnfOpt]     let _10325: Int = Int(0)
// [KnfOpt]     if (ok.10323 == _10325) then {
// [KnfOpt]       let _10326: Int = Int(0)
// [KnfOpt]       let _10327: Int = Int(0)
// [KnfOpt]       Tuple([_10326, _10327, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.10328: Int = Apply(_102, [val.10324, ])
// [KnfOpt]       let _10329: Int = Int(0)
// [KnfOpt]       if (r.10328 == _10329) then {
// [KnfOpt]         let _10330: Int = Int(1)
// [KnfOpt]         Tuple([_10330, val.10324, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _10331: Unit = Unit
// [KnfOpt]         Jump(aux.10319, [_10331, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.10319, [u.10318, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.10317)
// [KnfOpt] let rec add.10332: Int = (x.10333: Int, y.10334: Int) {
// [KnfOpt]   Add(x.10333, y.10334)
// [KnfOpt] }
// [KnfOpt] let _10335: Int = Int(0)
// [KnfOpt] let join fold.10336: Int = (stream.10337: Fun([Unit], Tuple([Int, Int])), f.10338: Fun([Int, Int], Int), acc.10339: Int) {
// [KnfOpt]   let _10340: Unit = Unit
// [KnfOpt]   let _10341: Tuple([Int, Int]) = Apply(stream.10337, [_10340, ])
// [KnfOpt]   let (ok.10342: Var({val: Some(Int)}), val.10343: Var({val: Some(Int)})) = _10341
// [KnfOpt]   let _10344: Int = Int(0)
// [KnfOpt]   if (ok.10342 == _10344) then {
// [KnfOpt]     let sum.104: Int = Var(acc.10339)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _10345: Int = Apply(f.10338, [acc.10339, val.10343, ])
// [KnfOpt]     Jump(fold.10336, [stream.10337, f.10338, _10345, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.10336, [under1200.103, add.10332, _10335, ])
// [KnfOpt] Inline threshold 20
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 0
// [KnfOpt] Inline decision map.1 accepted
// [KnfOpt] Inline threshold 5
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 0
// [KnfOpt] Inline decision gt.79 accepted
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 5
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 0
// [KnfOpt] Inline decision le.83 accepted
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.10348: Int = (x.10349: Int, y.10350: Int) {
// [KnfOpt]   Add(x.10349, y.10350)
// [KnfOpt] }
// [KnfOpt] let _10351: Int = Int(0)
// [KnfOpt] let join fold.10352: Int = (stream.10353: Fun([Unit], Tuple([Int, Int])), f.10354: Fun([Int, Int], Int), acc.10355: Int) {
// [KnfOpt]   let _10356: Unit = Unit
// [KnfOpt]   let _10357: Tuple([Int, Int]) = Apply(stream.10353, [_10356, ])
// [KnfOpt]   let (ok.10358: Var({val: Some(Int)}), val.10359: Var({val: Some(Int)})) = _10357
// [KnfOpt]   let _10360: Int = Int(0)
// [KnfOpt]   if (ok.10358 == _10360) then {
// [KnfOpt]     let sum.104: Int = Var(acc.10355)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _10361: Int = Apply(f.10354, [acc.10355, val.10359, ])
// [KnfOpt]     Jump(fold.10352, [stream.10353, f.10354, _10361, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.10352, [under1200.103, add.10348, _10351, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(le) let _102: Fun([Int], Int) = Unit
// [KnfOpt] let rec aux.10362: Tuple([Int, Int]) = (u.10363: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.10364: Tuple([Int, Int]) = (u.10365: Var({val: Some(Unit)})) {
// [KnfOpt]     let _10366: Unit = Unit
// [KnfOpt]     let _10367: Tuple([Int, Int]) = Apply(over50.100, [_10366, ])
// [KnfOpt]     let (ok.10368: Var({val: Some(Int)}), val.10369: Var({val: Some(Int)})) = _10367
// [KnfOpt]     let _10370: Int = Int(0)
// [KnfOpt]     if (ok.10368 == _10370) then {
// [KnfOpt]       let _10371: Int = Int(0)
// [KnfOpt]       let _10372: Int = Int(0)
// [KnfOpt]       Tuple([_10371, _10372, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.10373: Int = Apply(_102, [val.10369, ])
// [KnfOpt]       let _10374: Int = Int(0)
// [KnfOpt]       if (r.10373 == _10374) then {
// [KnfOpt]         let _10375: Int = Int(1)
// [KnfOpt]         Tuple([_10375, val.10369, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _10376: Unit = Unit
// [KnfOpt]         Jump(aux.10364, [_10376, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.10364, [u.10363, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.10362)
// [KnfOpt] let rec add.10377: Int = (x.10378: Int, y.10379: Int) {
// [KnfOpt]   Add(x.10378, y.10379)
// [KnfOpt] }
// [KnfOpt] let _10380: Int = Int(0)
// [KnfOpt] let join fold.10381: Int = (stream.10382: Fun([Unit], Tuple([Int, Int])), f.10383: Fun([Int, Int], Int), acc.10384: Int) {
// [KnfOpt]   let _10385: Unit = Unit
// [KnfOpt]   let _10386: Tuple([Int, Int]) = Apply(stream.10382, [_10385, ])
// [KnfOpt]   let (ok.10387: Var({val: Some(Int)}), val.10388: Var({val: Some(Int)})) = _10386
// [KnfOpt]   let _10389: Int = Int(0)
// [KnfOpt]   if (ok.10387 == _10389) then {
// [KnfOpt]     let sum.104: Int = Var(acc.10384)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _10390: Int = Apply(f.10383, [acc.10384, val.10388, ])
// [KnfOpt]     Jump(fold.10381, [stream.10382, f.10383, _10390, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.10381, [under1200.103, add.10377, _10380, ])
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.10393: Int = (x.10394: Int, y.10395: Int) {
// [KnfOpt]   Add(x.10394, y.10395)
// [KnfOpt] }
// [KnfOpt] let _10396: Int = Int(0)
// [KnfOpt] let join fold.10397: Int = (stream.10398: Fun([Unit], Tuple([Int, Int])), f.10399: Fun([Int, Int], Int), acc.10400: Int) {
// [KnfOpt]   let _10401: Unit = Unit
// [KnfOpt]   let _10402: Tuple([Int, Int]) = Apply(stream.10398, [_10401, ])
// [KnfOpt]   let (ok.10403: Var({val: Some(Int)}), val.10404: Var({val: Some(Int)})) = _10402
// [KnfOpt]   let _10405: Int = Int(0)
// [KnfOpt]   if (ok.10403 == _10405) then {
// [KnfOpt]     let sum.104: Int = Var(acc.10400)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _10406: Int = Apply(f.10399, [acc.10400, val.10404, ])
// [KnfOpt]     Jump(fold.10397, [stream.10398, f.10399, _10406, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.10397, [under1200.103, add.10393, _10396, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let over50.100: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let _101: Int = Int(1200)
// [KnfOpt] let rec aux.10391: Int = (y.10392: Int) {
// [KnfOpt]   if (y.10392 <= _101) then {
// [KnfOpt]     Int(0)
// [KnfOpt]   } else {
// [KnfOpt]     Int(1)
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] let _102: Fun([Int], Int) = Var(aux.10391)
// [KnfOpt] let rec aux.10407: Tuple([Int, Int]) = (u.10408: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.10409: Tuple([Int, Int]) = (u.10410: Var({val: Some(Unit)})) {
// [KnfOpt]     let _10411: Unit = Unit
// [KnfOpt]     let _10412: Tuple([Int, Int]) = Apply(over50.100, [_10411, ])
// [KnfOpt]     let (ok.10413: Var({val: Some(Int)}), val.10414: Var({val: Some(Int)})) = _10412
// [KnfOpt]     let _10415: Int = Int(0)
// [KnfOpt]     if (ok.10413 == _10415) then {
// [KnfOpt]       let _10416: Int = Int(0)
// [KnfOpt]       let _10417: Int = Int(0)
// [KnfOpt]       Tuple([_10416, _10417, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.10418: Int = Apply(_102, [val.10414, ])
// [KnfOpt]       let _10419: Int = Int(0)
// [KnfOpt]       if (r.10418 == _10419) then {
// [KnfOpt]         let _10420: Int = Int(1)
// [KnfOpt]         Tuple([_10420, val.10414, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _10421: Unit = Unit
// [KnfOpt]         Jump(aux.10409, [_10421, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.10409, [u.10408, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.10407)
// [KnfOpt] let rec add.10422: Int = (x.10423: Int, y.10424: Int) {
// [KnfOpt]   Add(x.10423, y.10424)
// [KnfOpt] }
// [KnfOpt] let _10425: Int = Int(0)
// [KnfOpt] let join fold.10426: Int = (stream.10427: Fun([Unit], Tuple([Int, Int])), f.10428: Fun([Int, Int], Int), acc.10429: Int) {
// [KnfOpt]   let _10430: Unit = Unit
// [KnfOpt]   let _10431: Tuple([Int, Int]) = Apply(stream.10427, [_10430, ])
// [KnfOpt]   let (ok.10432: Var({val: Some(Int)}), val.10433: Var({val: Some(Int)})) = _10431
// [KnfOpt]   let _10434: Int = Int(0)
// [KnfOpt]   if (ok.10432 == _10434) then {
// [KnfOpt]     let sum.104: Int = Var(acc.10429)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _10435: Int = Apply(f.10428, [acc.10429, val.10433, ])
// [KnfOpt]     Jump(fold.10426, [stream.10427, f.10428, _10435, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.10426, [under1200.103, add.10422, _10425, ])
// [KnfOpt] Inline threshold 5
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 0
// [KnfOpt] Inline decision le.83 accepted
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.10451: Int = (x.10452: Int, y.10453: Int) {
// [KnfOpt]   Add(x.10452, y.10453)
// [KnfOpt] }
// [KnfOpt] let _10454: Int = Int(0)
// [KnfOpt] let join fold.10455: Int = (stream.10456: Fun([Unit], Tuple([Int, Int])), f.10457: Fun([Int, Int], Int), acc.10458: Int) {
// [KnfOpt]   let _10459: Unit = Unit
// [KnfOpt]   let _10460: Tuple([Int, Int]) = Apply(stream.10456, [_10459, ])
// [KnfOpt]   let (ok.10461: Var({val: Some(Int)}), val.10462: Var({val: Some(Int)})) = _10460
// [KnfOpt]   let _10463: Int = Int(0)
// [KnfOpt]   if (ok.10461 == _10463) then {
// [KnfOpt]     let sum.104: Int = Var(acc.10458)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _10464: Int = Apply(f.10457, [acc.10458, val.10462, ])
// [KnfOpt]     Jump(fold.10455, [stream.10456, f.10457, _10464, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.10455, [under1200.103, add.10451, _10454, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(le) let _102: Fun([Int], Int) = Unit
// [KnfOpt] let rec aux.10465: Tuple([Int, Int]) = (u.10466: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.10467: Tuple([Int, Int]) = (u.10468: Var({val: Some(Unit)})) {
// [KnfOpt]     let _10469: Unit = Unit
// [KnfOpt]     let _10470: Tuple([Int, Int]) = Apply(over50.100, [_10469, ])
// [KnfOpt]     let (ok.10471: Var({val: Some(Int)}), val.10472: Var({val: Some(Int)})) = _10470
// [KnfOpt]     let _10473: Int = Int(0)
// [KnfOpt]     if (ok.10471 == _10473) then {
// [KnfOpt]       let _10474: Int = Int(0)
// [KnfOpt]       let _10475: Int = Int(0)
// [KnfOpt]       Tuple([_10474, _10475, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.10476: Int = Apply(_102, [val.10472, ])
// [KnfOpt]       let _10477: Int = Int(0)
// [KnfOpt]       if (r.10476 == _10477) then {
// [KnfOpt]         let _10478: Int = Int(1)
// [KnfOpt]         Tuple([_10478, val.10472, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _10479: Unit = Unit
// [KnfOpt]         Jump(aux.10467, [_10479, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.10467, [u.10466, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.10465)
// [KnfOpt] let rec add.10480: Int = (x.10481: Int, y.10482: Int) {
// [KnfOpt]   Add(x.10481, y.10482)
// [KnfOpt] }
// [KnfOpt] let _10483: Int = Int(0)
// [KnfOpt] let join fold.10484: Int = (stream.10485: Fun([Unit], Tuple([Int, Int])), f.10486: Fun([Int, Int], Int), acc.10487: Int) {
// [KnfOpt]   let _10488: Unit = Unit
// [KnfOpt]   let _10489: Tuple([Int, Int]) = Apply(stream.10485, [_10488, ])
// [KnfOpt]   let (ok.10490: Var({val: Some(Int)}), val.10491: Var({val: Some(Int)})) = _10489
// [KnfOpt]   let _10492: Int = Int(0)
// [KnfOpt]   if (ok.10490 == _10492) then {
// [KnfOpt]     let sum.104: Int = Var(acc.10487)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _10493: Int = Apply(f.10486, [acc.10487, val.10491, ])
// [KnfOpt]     Jump(fold.10484, [stream.10485, f.10486, _10493, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.10484, [under1200.103, add.10480, _10483, ])
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.10496: Int = (x.10497: Int, y.10498: Int) {
// [KnfOpt]   Add(x.10497, y.10498)
// [KnfOpt] }
// [KnfOpt] let _10499: Int = Int(0)
// [KnfOpt] let join fold.10500: Int = (stream.10501: Fun([Unit], Tuple([Int, Int])), f.10502: Fun([Int, Int], Int), acc.10503: Int) {
// [KnfOpt]   let _10504: Unit = Unit
// [KnfOpt]   let _10505: Tuple([Int, Int]) = Apply(stream.10501, [_10504, ])
// [KnfOpt]   let (ok.10506: Var({val: Some(Int)}), val.10507: Var({val: Some(Int)})) = _10505
// [KnfOpt]   let _10508: Int = Int(0)
// [KnfOpt]   if (ok.10506 == _10508) then {
// [KnfOpt]     let sum.104: Int = Var(acc.10503)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _10509: Int = Apply(f.10502, [acc.10503, val.10507, ])
// [KnfOpt]     Jump(fold.10500, [stream.10501, f.10502, _10509, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.10500, [under1200.103, add.10496, _10499, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(gt) let _99: Fun([Int], Int) = Unit
// [KnfOpt] let rec aux.10436: Tuple([Int, Int]) = (u.10437: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.10438: Tuple([Int, Int]) = (u.10439: Var({val: Some(Unit)})) {
// [KnfOpt]     let _10440: Unit = Unit
// [KnfOpt]     let _10441: Tuple([Int, Int]) = Apply(addone.97, [_10440, ])
// [KnfOpt]     let (ok.10442: Var({val: Some(Int)}), val.10443: Var({val: Some(Int)})) = _10441
// [KnfOpt]     let _10444: Int = Int(0)
// [KnfOpt]     if (ok.10442 == _10444) then {
// [KnfOpt]       let _10445: Int = Int(0)
// [KnfOpt]       let _10446: Int = Int(0)
// [KnfOpt]       Tuple([_10445, _10446, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.10447: Int = Apply(_99, [val.10443, ])
// [KnfOpt]       let _10448: Int = Int(0)
// [KnfOpt]       if (r.10447 == _10448) then {
// [KnfOpt]         let _10449: Int = Int(1)
// [KnfOpt]         Tuple([_10449, val.10443, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _10450: Unit = Unit
// [KnfOpt]         Jump(aux.10438, [_10450, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.10438, [u.10437, ])
// [KnfOpt] }
// [KnfOpt] let over50.100: Fun([Unit], Tuple([Int, Int])) = Var(aux.10436)
// [KnfOpt] let _101: Int = Int(1200)
// [KnfOpt] let rec aux.10494: Int = (y.10495: Int) {
// [KnfOpt]   if (y.10495 <= _101) then {
// [KnfOpt]     Int(0)
// [KnfOpt]   } else {
// [KnfOpt]     Int(1)
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] let _102: Fun([Int], Int) = Var(aux.10494)
// [KnfOpt] let rec aux.10510: Tuple([Int, Int]) = (u.10511: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.10512: Tuple([Int, Int]) = (u.10513: Var({val: Some(Unit)})) {
// [KnfOpt]     let _10514: Unit = Unit
// [KnfOpt]     let _10515: Tuple([Int, Int]) = Apply(over50.100, [_10514, ])
// [KnfOpt]     let (ok.10516: Var({val: Some(Int)}), val.10517: Var({val: Some(Int)})) = _10515
// [KnfOpt]     let _10518: Int = Int(0)
// [KnfOpt]     if (ok.10516 == _10518) then {
// [KnfOpt]       let _10519: Int = Int(0)
// [KnfOpt]       let _10520: Int = Int(0)
// [KnfOpt]       Tuple([_10519, _10520, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.10521: Int = Apply(_102, [val.10517, ])
// [KnfOpt]       let _10522: Int = Int(0)
// [KnfOpt]       if (r.10521 == _10522) then {
// [KnfOpt]         let _10523: Int = Int(1)
// [KnfOpt]         Tuple([_10523, val.10517, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _10524: Unit = Unit
// [KnfOpt]         Jump(aux.10512, [_10524, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.10512, [u.10511, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.10510)
// [KnfOpt] let rec add.10525: Int = (x.10526: Int, y.10527: Int) {
// [KnfOpt]   Add(x.10526, y.10527)
// [KnfOpt] }
// [KnfOpt] let _10528: Int = Int(0)
// [KnfOpt] let join fold.10529: Int = (stream.10530: Fun([Unit], Tuple([Int, Int])), f.10531: Fun([Int, Int], Int), acc.10532: Int) {
// [KnfOpt]   let _10533: Unit = Unit
// [KnfOpt]   let _10534: Tuple([Int, Int]) = Apply(stream.10530, [_10533, ])
// [KnfOpt]   let (ok.10535: Var({val: Some(Int)}), val.10536: Var({val: Some(Int)})) = _10534
// [KnfOpt]   let _10537: Int = Int(0)
// [KnfOpt]   if (ok.10535 == _10537) then {
// [KnfOpt]     let sum.104: Int = Var(acc.10532)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _10538: Int = Apply(f.10531, [acc.10532, val.10536, ])
// [KnfOpt]     Jump(fold.10529, [stream.10530, f.10531, _10538, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.10529, [under1200.103, add.10525, _10528, ])
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 5
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 0
// [KnfOpt] Inline decision le.83 accepted
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.10541: Int = (x.10542: Int, y.10543: Int) {
// [KnfOpt]   Add(x.10542, y.10543)
// [KnfOpt] }
// [KnfOpt] let _10544: Int = Int(0)
// [KnfOpt] let join fold.10545: Int = (stream.10546: Fun([Unit], Tuple([Int, Int])), f.10547: Fun([Int, Int], Int), acc.10548: Int) {
// [KnfOpt]   let _10549: Unit = Unit
// [KnfOpt]   let _10550: Tuple([Int, Int]) = Apply(stream.10546, [_10549, ])
// [KnfOpt]   let (ok.10551: Var({val: Some(Int)}), val.10552: Var({val: Some(Int)})) = _10550
// [KnfOpt]   let _10553: Int = Int(0)
// [KnfOpt]   if (ok.10551 == _10553) then {
// [KnfOpt]     let sum.104: Int = Var(acc.10548)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _10554: Int = Apply(f.10547, [acc.10548, val.10552, ])
// [KnfOpt]     Jump(fold.10545, [stream.10546, f.10547, _10554, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.10545, [under1200.103, add.10541, _10544, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(le) let _102: Fun([Int], Int) = Unit
// [KnfOpt] let rec aux.10555: Tuple([Int, Int]) = (u.10556: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.10557: Tuple([Int, Int]) = (u.10558: Var({val: Some(Unit)})) {
// [KnfOpt]     let _10559: Unit = Unit
// [KnfOpt]     let _10560: Tuple([Int, Int]) = Apply(over50.100, [_10559, ])
// [KnfOpt]     let (ok.10561: Var({val: Some(Int)}), val.10562: Var({val: Some(Int)})) = _10560
// [KnfOpt]     let _10563: Int = Int(0)
// [KnfOpt]     if (ok.10561 == _10563) then {
// [KnfOpt]       let _10564: Int = Int(0)
// [KnfOpt]       let _10565: Int = Int(0)
// [KnfOpt]       Tuple([_10564, _10565, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.10566: Int = Apply(_102, [val.10562, ])
// [KnfOpt]       let _10567: Int = Int(0)
// [KnfOpt]       if (r.10566 == _10567) then {
// [KnfOpt]         let _10568: Int = Int(1)
// [KnfOpt]         Tuple([_10568, val.10562, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _10569: Unit = Unit
// [KnfOpt]         Jump(aux.10557, [_10569, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.10557, [u.10556, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.10555)
// [KnfOpt] let rec add.10570: Int = (x.10571: Int, y.10572: Int) {
// [KnfOpt]   Add(x.10571, y.10572)
// [KnfOpt] }
// [KnfOpt] let _10573: Int = Int(0)
// [KnfOpt] let join fold.10574: Int = (stream.10575: Fun([Unit], Tuple([Int, Int])), f.10576: Fun([Int, Int], Int), acc.10577: Int) {
// [KnfOpt]   let _10578: Unit = Unit
// [KnfOpt]   let _10579: Tuple([Int, Int]) = Apply(stream.10575, [_10578, ])
// [KnfOpt]   let (ok.10580: Var({val: Some(Int)}), val.10581: Var({val: Some(Int)})) = _10579
// [KnfOpt]   let _10582: Int = Int(0)
// [KnfOpt]   if (ok.10580 == _10582) then {
// [KnfOpt]     let sum.104: Int = Var(acc.10577)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _10583: Int = Apply(f.10576, [acc.10577, val.10581, ])
// [KnfOpt]     Jump(fold.10574, [stream.10575, f.10576, _10583, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.10574, [under1200.103, add.10570, _10573, ])
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.10586: Int = (x.10587: Int, y.10588: Int) {
// [KnfOpt]   Add(x.10587, y.10588)
// [KnfOpt] }
// [KnfOpt] let _10589: Int = Int(0)
// [KnfOpt] let join fold.10590: Int = (stream.10591: Fun([Unit], Tuple([Int, Int])), f.10592: Fun([Int, Int], Int), acc.10593: Int) {
// [KnfOpt]   let _10594: Unit = Unit
// [KnfOpt]   let _10595: Tuple([Int, Int]) = Apply(stream.10591, [_10594, ])
// [KnfOpt]   let (ok.10596: Var({val: Some(Int)}), val.10597: Var({val: Some(Int)})) = _10595
// [KnfOpt]   let _10598: Int = Int(0)
// [KnfOpt]   if (ok.10596 == _10598) then {
// [KnfOpt]     let sum.104: Int = Var(acc.10593)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _10599: Int = Apply(f.10592, [acc.10593, val.10597, ])
// [KnfOpt]     Jump(fold.10590, [stream.10591, f.10592, _10599, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.10590, [under1200.103, add.10586, _10589, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let over50.100: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let _101: Int = Int(1200)
// [KnfOpt] let rec aux.10584: Int = (y.10585: Int) {
// [KnfOpt]   if (y.10585 <= _101) then {
// [KnfOpt]     Int(0)
// [KnfOpt]   } else {
// [KnfOpt]     Int(1)
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] let _102: Fun([Int], Int) = Var(aux.10584)
// [KnfOpt] let rec aux.10600: Tuple([Int, Int]) = (u.10601: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.10602: Tuple([Int, Int]) = (u.10603: Var({val: Some(Unit)})) {
// [KnfOpt]     let _10604: Unit = Unit
// [KnfOpt]     let _10605: Tuple([Int, Int]) = Apply(over50.100, [_10604, ])
// [KnfOpt]     let (ok.10606: Var({val: Some(Int)}), val.10607: Var({val: Some(Int)})) = _10605
// [KnfOpt]     let _10608: Int = Int(0)
// [KnfOpt]     if (ok.10606 == _10608) then {
// [KnfOpt]       let _10609: Int = Int(0)
// [KnfOpt]       let _10610: Int = Int(0)
// [KnfOpt]       Tuple([_10609, _10610, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.10611: Int = Apply(_102, [val.10607, ])
// [KnfOpt]       let _10612: Int = Int(0)
// [KnfOpt]       if (r.10611 == _10612) then {
// [KnfOpt]         let _10613: Int = Int(1)
// [KnfOpt]         Tuple([_10613, val.10607, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _10614: Unit = Unit
// [KnfOpt]         Jump(aux.10602, [_10614, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.10602, [u.10601, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.10600)
// [KnfOpt] let rec add.10615: Int = (x.10616: Int, y.10617: Int) {
// [KnfOpt]   Add(x.10616, y.10617)
// [KnfOpt] }
// [KnfOpt] let _10618: Int = Int(0)
// [KnfOpt] let join fold.10619: Int = (stream.10620: Fun([Unit], Tuple([Int, Int])), f.10621: Fun([Int, Int], Int), acc.10622: Int) {
// [KnfOpt]   let _10623: Unit = Unit
// [KnfOpt]   let _10624: Tuple([Int, Int]) = Apply(stream.10620, [_10623, ])
// [KnfOpt]   let (ok.10625: Var({val: Some(Int)}), val.10626: Var({val: Some(Int)})) = _10624
// [KnfOpt]   let _10627: Int = Int(0)
// [KnfOpt]   if (ok.10625 == _10627) then {
// [KnfOpt]     let sum.104: Int = Var(acc.10622)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _10628: Int = Apply(f.10621, [acc.10622, val.10626, ])
// [KnfOpt]     Jump(fold.10619, [stream.10620, f.10621, _10628, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.10619, [under1200.103, add.10615, _10618, ])
// [KnfOpt] Inline threshold 5
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 0
// [KnfOpt] Inline decision le.83 accepted
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.10644: Int = (x.10645: Int, y.10646: Int) {
// [KnfOpt]   Add(x.10645, y.10646)
// [KnfOpt] }
// [KnfOpt] let _10647: Int = Int(0)
// [KnfOpt] let join fold.10648: Int = (stream.10649: Fun([Unit], Tuple([Int, Int])), f.10650: Fun([Int, Int], Int), acc.10651: Int) {
// [KnfOpt]   let _10652: Unit = Unit
// [KnfOpt]   let _10653: Tuple([Int, Int]) = Apply(stream.10649, [_10652, ])
// [KnfOpt]   let (ok.10654: Var({val: Some(Int)}), val.10655: Var({val: Some(Int)})) = _10653
// [KnfOpt]   let _10656: Int = Int(0)
// [KnfOpt]   if (ok.10654 == _10656) then {
// [KnfOpt]     let sum.104: Int = Var(acc.10651)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _10657: Int = Apply(f.10650, [acc.10651, val.10655, ])
// [KnfOpt]     Jump(fold.10648, [stream.10649, f.10650, _10657, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.10648, [under1200.103, add.10644, _10647, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(le) let _102: Fun([Int], Int) = Unit
// [KnfOpt] let rec aux.10658: Tuple([Int, Int]) = (u.10659: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.10660: Tuple([Int, Int]) = (u.10661: Var({val: Some(Unit)})) {
// [KnfOpt]     let _10662: Unit = Unit
// [KnfOpt]     let _10663: Tuple([Int, Int]) = Apply(over50.100, [_10662, ])
// [KnfOpt]     let (ok.10664: Var({val: Some(Int)}), val.10665: Var({val: Some(Int)})) = _10663
// [KnfOpt]     let _10666: Int = Int(0)
// [KnfOpt]     if (ok.10664 == _10666) then {
// [KnfOpt]       let _10667: Int = Int(0)
// [KnfOpt]       let _10668: Int = Int(0)
// [KnfOpt]       Tuple([_10667, _10668, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.10669: Int = Apply(_102, [val.10665, ])
// [KnfOpt]       let _10670: Int = Int(0)
// [KnfOpt]       if (r.10669 == _10670) then {
// [KnfOpt]         let _10671: Int = Int(1)
// [KnfOpt]         Tuple([_10671, val.10665, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _10672: Unit = Unit
// [KnfOpt]         Jump(aux.10660, [_10672, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.10660, [u.10659, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.10658)
// [KnfOpt] let rec add.10673: Int = (x.10674: Int, y.10675: Int) {
// [KnfOpt]   Add(x.10674, y.10675)
// [KnfOpt] }
// [KnfOpt] let _10676: Int = Int(0)
// [KnfOpt] let join fold.10677: Int = (stream.10678: Fun([Unit], Tuple([Int, Int])), f.10679: Fun([Int, Int], Int), acc.10680: Int) {
// [KnfOpt]   let _10681: Unit = Unit
// [KnfOpt]   let _10682: Tuple([Int, Int]) = Apply(stream.10678, [_10681, ])
// [KnfOpt]   let (ok.10683: Var({val: Some(Int)}), val.10684: Var({val: Some(Int)})) = _10682
// [KnfOpt]   let _10685: Int = Int(0)
// [KnfOpt]   if (ok.10683 == _10685) then {
// [KnfOpt]     let sum.104: Int = Var(acc.10680)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _10686: Int = Apply(f.10679, [acc.10680, val.10684, ])
// [KnfOpt]     Jump(fold.10677, [stream.10678, f.10679, _10686, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.10677, [under1200.103, add.10673, _10676, ])
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.10689: Int = (x.10690: Int, y.10691: Int) {
// [KnfOpt]   Add(x.10690, y.10691)
// [KnfOpt] }
// [KnfOpt] let _10692: Int = Int(0)
// [KnfOpt] let join fold.10693: Int = (stream.10694: Fun([Unit], Tuple([Int, Int])), f.10695: Fun([Int, Int], Int), acc.10696: Int) {
// [KnfOpt]   let _10697: Unit = Unit
// [KnfOpt]   let _10698: Tuple([Int, Int]) = Apply(stream.10694, [_10697, ])
// [KnfOpt]   let (ok.10699: Var({val: Some(Int)}), val.10700: Var({val: Some(Int)})) = _10698
// [KnfOpt]   let _10701: Int = Int(0)
// [KnfOpt]   if (ok.10699 == _10701) then {
// [KnfOpt]     let sum.104: Int = Var(acc.10696)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _10702: Int = Apply(f.10695, [acc.10696, val.10700, ])
// [KnfOpt]     Jump(fold.10693, [stream.10694, f.10695, _10702, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.10693, [under1200.103, add.10689, _10692, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(map) let addone.97: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let _98: Int = Int(50)
// [KnfOpt] let rec aux.10539: Int = (y.10540: Int) {
// [KnfOpt]   if (_98 <= y.10540) then {
// [KnfOpt]     Int(0)
// [KnfOpt]   } else {
// [KnfOpt]     Int(1)
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] let _99: Fun([Int], Int) = Var(aux.10539)
// [KnfOpt] let rec aux.10629: Tuple([Int, Int]) = (u.10630: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.10631: Tuple([Int, Int]) = (u.10632: Var({val: Some(Unit)})) {
// [KnfOpt]     let _10633: Unit = Unit
// [KnfOpt]     let _10634: Tuple([Int, Int]) = Apply(addone.97, [_10633, ])
// [KnfOpt]     let (ok.10635: Var({val: Some(Int)}), val.10636: Var({val: Some(Int)})) = _10634
// [KnfOpt]     let _10637: Int = Int(0)
// [KnfOpt]     if (ok.10635 == _10637) then {
// [KnfOpt]       let _10638: Int = Int(0)
// [KnfOpt]       let _10639: Int = Int(0)
// [KnfOpt]       Tuple([_10638, _10639, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.10640: Int = Apply(_99, [val.10636, ])
// [KnfOpt]       let _10641: Int = Int(0)
// [KnfOpt]       if (r.10640 == _10641) then {
// [KnfOpt]         let _10642: Int = Int(1)
// [KnfOpt]         Tuple([_10642, val.10636, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _10643: Unit = Unit
// [KnfOpt]         Jump(aux.10631, [_10643, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.10631, [u.10630, ])
// [KnfOpt] }
// [KnfOpt] let over50.100: Fun([Unit], Tuple([Int, Int])) = Var(aux.10629)
// [KnfOpt] let _101: Int = Int(1200)
// [KnfOpt] let rec aux.10687: Int = (y.10688: Int) {
// [KnfOpt]   if (y.10688 <= _101) then {
// [KnfOpt]     Int(0)
// [KnfOpt]   } else {
// [KnfOpt]     Int(1)
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] let _102: Fun([Int], Int) = Var(aux.10687)
// [KnfOpt] let rec aux.10703: Tuple([Int, Int]) = (u.10704: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.10705: Tuple([Int, Int]) = (u.10706: Var({val: Some(Unit)})) {
// [KnfOpt]     let _10707: Unit = Unit
// [KnfOpt]     let _10708: Tuple([Int, Int]) = Apply(over50.100, [_10707, ])
// [KnfOpt]     let (ok.10709: Var({val: Some(Int)}), val.10710: Var({val: Some(Int)})) = _10708
// [KnfOpt]     let _10711: Int = Int(0)
// [KnfOpt]     if (ok.10709 == _10711) then {
// [KnfOpt]       let _10712: Int = Int(0)
// [KnfOpt]       let _10713: Int = Int(0)
// [KnfOpt]       Tuple([_10712, _10713, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.10714: Int = Apply(_102, [val.10710, ])
// [KnfOpt]       let _10715: Int = Int(0)
// [KnfOpt]       if (r.10714 == _10715) then {
// [KnfOpt]         let _10716: Int = Int(1)
// [KnfOpt]         Tuple([_10716, val.10710, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _10717: Unit = Unit
// [KnfOpt]         Jump(aux.10705, [_10717, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.10705, [u.10704, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.10703)
// [KnfOpt] let rec add.10718: Int = (x.10719: Int, y.10720: Int) {
// [KnfOpt]   Add(x.10719, y.10720)
// [KnfOpt] }
// [KnfOpt] let _10721: Int = Int(0)
// [KnfOpt] let join fold.10722: Int = (stream.10723: Fun([Unit], Tuple([Int, Int])), f.10724: Fun([Int, Int], Int), acc.10725: Int) {
// [KnfOpt]   let _10726: Unit = Unit
// [KnfOpt]   let _10727: Tuple([Int, Int]) = Apply(stream.10723, [_10726, ])
// [KnfOpt]   let (ok.10728: Var({val: Some(Int)}), val.10729: Var({val: Some(Int)})) = _10727
// [KnfOpt]   let _10730: Int = Int(0)
// [KnfOpt]   if (ok.10728 == _10730) then {
// [KnfOpt]     let sum.104: Int = Var(acc.10725)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _10731: Int = Apply(f.10724, [acc.10725, val.10729, ])
// [KnfOpt]     Jump(fold.10722, [stream.10723, f.10724, _10731, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.10722, [under1200.103, add.10718, _10721, ])
// [KnfOpt] Inline threshold 5
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 0
// [KnfOpt] Inline decision gt.79 accepted
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 5
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 0
// [KnfOpt] Inline decision le.83 accepted
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.10743: Int = (x.10744: Int, y.10745: Int) {
// [KnfOpt]   Add(x.10744, y.10745)
// [KnfOpt] }
// [KnfOpt] let _10746: Int = Int(0)
// [KnfOpt] let join fold.10747: Int = (stream.10748: Fun([Unit], Tuple([Int, Int])), f.10749: Fun([Int, Int], Int), acc.10750: Int) {
// [KnfOpt]   let _10751: Unit = Unit
// [KnfOpt]   let _10752: Tuple([Int, Int]) = Apply(stream.10748, [_10751, ])
// [KnfOpt]   let (ok.10753: Var({val: Some(Int)}), val.10754: Var({val: Some(Int)})) = _10752
// [KnfOpt]   let _10755: Int = Int(0)
// [KnfOpt]   if (ok.10753 == _10755) then {
// [KnfOpt]     let sum.104: Int = Var(acc.10750)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _10756: Int = Apply(f.10749, [acc.10750, val.10754, ])
// [KnfOpt]     Jump(fold.10747, [stream.10748, f.10749, _10756, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.10747, [under1200.103, add.10743, _10746, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(le) let _102: Fun([Int], Int) = Unit
// [KnfOpt] let rec aux.10757: Tuple([Int, Int]) = (u.10758: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.10759: Tuple([Int, Int]) = (u.10760: Var({val: Some(Unit)})) {
// [KnfOpt]     let _10761: Unit = Unit
// [KnfOpt]     let _10762: Tuple([Int, Int]) = Apply(over50.100, [_10761, ])
// [KnfOpt]     let (ok.10763: Var({val: Some(Int)}), val.10764: Var({val: Some(Int)})) = _10762
// [KnfOpt]     let _10765: Int = Int(0)
// [KnfOpt]     if (ok.10763 == _10765) then {
// [KnfOpt]       let _10766: Int = Int(0)
// [KnfOpt]       let _10767: Int = Int(0)
// [KnfOpt]       Tuple([_10766, _10767, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.10768: Int = Apply(_102, [val.10764, ])
// [KnfOpt]       let _10769: Int = Int(0)
// [KnfOpt]       if (r.10768 == _10769) then {
// [KnfOpt]         let _10770: Int = Int(1)
// [KnfOpt]         Tuple([_10770, val.10764, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _10771: Unit = Unit
// [KnfOpt]         Jump(aux.10759, [_10771, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.10759, [u.10758, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.10757)
// [KnfOpt] let rec add.10772: Int = (x.10773: Int, y.10774: Int) {
// [KnfOpt]   Add(x.10773, y.10774)
// [KnfOpt] }
// [KnfOpt] let _10775: Int = Int(0)
// [KnfOpt] let join fold.10776: Int = (stream.10777: Fun([Unit], Tuple([Int, Int])), f.10778: Fun([Int, Int], Int), acc.10779: Int) {
// [KnfOpt]   let _10780: Unit = Unit
// [KnfOpt]   let _10781: Tuple([Int, Int]) = Apply(stream.10777, [_10780, ])
// [KnfOpt]   let (ok.10782: Var({val: Some(Int)}), val.10783: Var({val: Some(Int)})) = _10781
// [KnfOpt]   let _10784: Int = Int(0)
// [KnfOpt]   if (ok.10782 == _10784) then {
// [KnfOpt]     let sum.104: Int = Var(acc.10779)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _10785: Int = Apply(f.10778, [acc.10779, val.10783, ])
// [KnfOpt]     Jump(fold.10776, [stream.10777, f.10778, _10785, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.10776, [under1200.103, add.10772, _10775, ])
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.10788: Int = (x.10789: Int, y.10790: Int) {
// [KnfOpt]   Add(x.10789, y.10790)
// [KnfOpt] }
// [KnfOpt] let _10791: Int = Int(0)
// [KnfOpt] let join fold.10792: Int = (stream.10793: Fun([Unit], Tuple([Int, Int])), f.10794: Fun([Int, Int], Int), acc.10795: Int) {
// [KnfOpt]   let _10796: Unit = Unit
// [KnfOpt]   let _10797: Tuple([Int, Int]) = Apply(stream.10793, [_10796, ])
// [KnfOpt]   let (ok.10798: Var({val: Some(Int)}), val.10799: Var({val: Some(Int)})) = _10797
// [KnfOpt]   let _10800: Int = Int(0)
// [KnfOpt]   if (ok.10798 == _10800) then {
// [KnfOpt]     let sum.104: Int = Var(acc.10795)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _10801: Int = Apply(f.10794, [acc.10795, val.10799, ])
// [KnfOpt]     Jump(fold.10792, [stream.10793, f.10794, _10801, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.10792, [under1200.103, add.10788, _10791, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let over50.100: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let _101: Int = Int(1200)
// [KnfOpt] let rec aux.10786: Int = (y.10787: Int) {
// [KnfOpt]   if (y.10787 <= _101) then {
// [KnfOpt]     Int(0)
// [KnfOpt]   } else {
// [KnfOpt]     Int(1)
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] let _102: Fun([Int], Int) = Var(aux.10786)
// [KnfOpt] let rec aux.10802: Tuple([Int, Int]) = (u.10803: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.10804: Tuple([Int, Int]) = (u.10805: Var({val: Some(Unit)})) {
// [KnfOpt]     let _10806: Unit = Unit
// [KnfOpt]     let _10807: Tuple([Int, Int]) = Apply(over50.100, [_10806, ])
// [KnfOpt]     let (ok.10808: Var({val: Some(Int)}), val.10809: Var({val: Some(Int)})) = _10807
// [KnfOpt]     let _10810: Int = Int(0)
// [KnfOpt]     if (ok.10808 == _10810) then {
// [KnfOpt]       let _10811: Int = Int(0)
// [KnfOpt]       let _10812: Int = Int(0)
// [KnfOpt]       Tuple([_10811, _10812, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.10813: Int = Apply(_102, [val.10809, ])
// [KnfOpt]       let _10814: Int = Int(0)
// [KnfOpt]       if (r.10813 == _10814) then {
// [KnfOpt]         let _10815: Int = Int(1)
// [KnfOpt]         Tuple([_10815, val.10809, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _10816: Unit = Unit
// [KnfOpt]         Jump(aux.10804, [_10816, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.10804, [u.10803, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.10802)
// [KnfOpt] let rec add.10817: Int = (x.10818: Int, y.10819: Int) {
// [KnfOpt]   Add(x.10818, y.10819)
// [KnfOpt] }
// [KnfOpt] let _10820: Int = Int(0)
// [KnfOpt] let join fold.10821: Int = (stream.10822: Fun([Unit], Tuple([Int, Int])), f.10823: Fun([Int, Int], Int), acc.10824: Int) {
// [KnfOpt]   let _10825: Unit = Unit
// [KnfOpt]   let _10826: Tuple([Int, Int]) = Apply(stream.10822, [_10825, ])
// [KnfOpt]   let (ok.10827: Var({val: Some(Int)}), val.10828: Var({val: Some(Int)})) = _10826
// [KnfOpt]   let _10829: Int = Int(0)
// [KnfOpt]   if (ok.10827 == _10829) then {
// [KnfOpt]     let sum.104: Int = Var(acc.10824)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _10830: Int = Apply(f.10823, [acc.10824, val.10828, ])
// [KnfOpt]     Jump(fold.10821, [stream.10822, f.10823, _10830, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.10821, [under1200.103, add.10817, _10820, ])
// [KnfOpt] Inline threshold 5
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 0
// [KnfOpt] Inline decision le.83 accepted
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.10846: Int = (x.10847: Int, y.10848: Int) {
// [KnfOpt]   Add(x.10847, y.10848)
// [KnfOpt] }
// [KnfOpt] let _10849: Int = Int(0)
// [KnfOpt] let join fold.10850: Int = (stream.10851: Fun([Unit], Tuple([Int, Int])), f.10852: Fun([Int, Int], Int), acc.10853: Int) {
// [KnfOpt]   let _10854: Unit = Unit
// [KnfOpt]   let _10855: Tuple([Int, Int]) = Apply(stream.10851, [_10854, ])
// [KnfOpt]   let (ok.10856: Var({val: Some(Int)}), val.10857: Var({val: Some(Int)})) = _10855
// [KnfOpt]   let _10858: Int = Int(0)
// [KnfOpt]   if (ok.10856 == _10858) then {
// [KnfOpt]     let sum.104: Int = Var(acc.10853)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _10859: Int = Apply(f.10852, [acc.10853, val.10857, ])
// [KnfOpt]     Jump(fold.10850, [stream.10851, f.10852, _10859, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.10850, [under1200.103, add.10846, _10849, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(le) let _102: Fun([Int], Int) = Unit
// [KnfOpt] let rec aux.10860: Tuple([Int, Int]) = (u.10861: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.10862: Tuple([Int, Int]) = (u.10863: Var({val: Some(Unit)})) {
// [KnfOpt]     let _10864: Unit = Unit
// [KnfOpt]     let _10865: Tuple([Int, Int]) = Apply(over50.100, [_10864, ])
// [KnfOpt]     let (ok.10866: Var({val: Some(Int)}), val.10867: Var({val: Some(Int)})) = _10865
// [KnfOpt]     let _10868: Int = Int(0)
// [KnfOpt]     if (ok.10866 == _10868) then {
// [KnfOpt]       let _10869: Int = Int(0)
// [KnfOpt]       let _10870: Int = Int(0)
// [KnfOpt]       Tuple([_10869, _10870, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.10871: Int = Apply(_102, [val.10867, ])
// [KnfOpt]       let _10872: Int = Int(0)
// [KnfOpt]       if (r.10871 == _10872) then {
// [KnfOpt]         let _10873: Int = Int(1)
// [KnfOpt]         Tuple([_10873, val.10867, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _10874: Unit = Unit
// [KnfOpt]         Jump(aux.10862, [_10874, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.10862, [u.10861, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.10860)
// [KnfOpt] let rec add.10875: Int = (x.10876: Int, y.10877: Int) {
// [KnfOpt]   Add(x.10876, y.10877)
// [KnfOpt] }
// [KnfOpt] let _10878: Int = Int(0)
// [KnfOpt] let join fold.10879: Int = (stream.10880: Fun([Unit], Tuple([Int, Int])), f.10881: Fun([Int, Int], Int), acc.10882: Int) {
// [KnfOpt]   let _10883: Unit = Unit
// [KnfOpt]   let _10884: Tuple([Int, Int]) = Apply(stream.10880, [_10883, ])
// [KnfOpt]   let (ok.10885: Var({val: Some(Int)}), val.10886: Var({val: Some(Int)})) = _10884
// [KnfOpt]   let _10887: Int = Int(0)
// [KnfOpt]   if (ok.10885 == _10887) then {
// [KnfOpt]     let sum.104: Int = Var(acc.10882)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _10888: Int = Apply(f.10881, [acc.10882, val.10886, ])
// [KnfOpt]     Jump(fold.10879, [stream.10880, f.10881, _10888, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.10879, [under1200.103, add.10875, _10878, ])
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.10891: Int = (x.10892: Int, y.10893: Int) {
// [KnfOpt]   Add(x.10892, y.10893)
// [KnfOpt] }
// [KnfOpt] let _10894: Int = Int(0)
// [KnfOpt] let join fold.10895: Int = (stream.10896: Fun([Unit], Tuple([Int, Int])), f.10897: Fun([Int, Int], Int), acc.10898: Int) {
// [KnfOpt]   let _10899: Unit = Unit
// [KnfOpt]   let _10900: Tuple([Int, Int]) = Apply(stream.10896, [_10899, ])
// [KnfOpt]   let (ok.10901: Var({val: Some(Int)}), val.10902: Var({val: Some(Int)})) = _10900
// [KnfOpt]   let _10903: Int = Int(0)
// [KnfOpt]   if (ok.10901 == _10903) then {
// [KnfOpt]     let sum.104: Int = Var(acc.10898)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _10904: Int = Apply(f.10897, [acc.10898, val.10902, ])
// [KnfOpt]     Jump(fold.10895, [stream.10896, f.10897, _10904, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.10895, [under1200.103, add.10891, _10894, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(gt) let _99: Fun([Int], Int) = Unit
// [KnfOpt] let rec aux.10831: Tuple([Int, Int]) = (u.10832: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.10833: Tuple([Int, Int]) = (u.10834: Var({val: Some(Unit)})) {
// [KnfOpt]     let _10835: Unit = Unit
// [KnfOpt]     let _10836: Tuple([Int, Int]) = Apply(addone.97, [_10835, ])
// [KnfOpt]     let (ok.10837: Var({val: Some(Int)}), val.10838: Var({val: Some(Int)})) = _10836
// [KnfOpt]     let _10839: Int = Int(0)
// [KnfOpt]     if (ok.10837 == _10839) then {
// [KnfOpt]       let _10840: Int = Int(0)
// [KnfOpt]       let _10841: Int = Int(0)
// [KnfOpt]       Tuple([_10840, _10841, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.10842: Int = Apply(_99, [val.10838, ])
// [KnfOpt]       let _10843: Int = Int(0)
// [KnfOpt]       if (r.10842 == _10843) then {
// [KnfOpt]         let _10844: Int = Int(1)
// [KnfOpt]         Tuple([_10844, val.10838, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _10845: Unit = Unit
// [KnfOpt]         Jump(aux.10833, [_10845, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.10833, [u.10832, ])
// [KnfOpt] }
// [KnfOpt] let over50.100: Fun([Unit], Tuple([Int, Int])) = Var(aux.10831)
// [KnfOpt] let _101: Int = Int(1200)
// [KnfOpt] let rec aux.10889: Int = (y.10890: Int) {
// [KnfOpt]   if (y.10890 <= _101) then {
// [KnfOpt]     Int(0)
// [KnfOpt]   } else {
// [KnfOpt]     Int(1)
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] let _102: Fun([Int], Int) = Var(aux.10889)
// [KnfOpt] let rec aux.10905: Tuple([Int, Int]) = (u.10906: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.10907: Tuple([Int, Int]) = (u.10908: Var({val: Some(Unit)})) {
// [KnfOpt]     let _10909: Unit = Unit
// [KnfOpt]     let _10910: Tuple([Int, Int]) = Apply(over50.100, [_10909, ])
// [KnfOpt]     let (ok.10911: Var({val: Some(Int)}), val.10912: Var({val: Some(Int)})) = _10910
// [KnfOpt]     let _10913: Int = Int(0)
// [KnfOpt]     if (ok.10911 == _10913) then {
// [KnfOpt]       let _10914: Int = Int(0)
// [KnfOpt]       let _10915: Int = Int(0)
// [KnfOpt]       Tuple([_10914, _10915, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.10916: Int = Apply(_102, [val.10912, ])
// [KnfOpt]       let _10917: Int = Int(0)
// [KnfOpt]       if (r.10916 == _10917) then {
// [KnfOpt]         let _10918: Int = Int(1)
// [KnfOpt]         Tuple([_10918, val.10912, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _10919: Unit = Unit
// [KnfOpt]         Jump(aux.10907, [_10919, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.10907, [u.10906, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.10905)
// [KnfOpt] let rec add.10920: Int = (x.10921: Int, y.10922: Int) {
// [KnfOpt]   Add(x.10921, y.10922)
// [KnfOpt] }
// [KnfOpt] let _10923: Int = Int(0)
// [KnfOpt] let join fold.10924: Int = (stream.10925: Fun([Unit], Tuple([Int, Int])), f.10926: Fun([Int, Int], Int), acc.10927: Int) {
// [KnfOpt]   let _10928: Unit = Unit
// [KnfOpt]   let _10929: Tuple([Int, Int]) = Apply(stream.10925, [_10928, ])
// [KnfOpt]   let (ok.10930: Var({val: Some(Int)}), val.10931: Var({val: Some(Int)})) = _10929
// [KnfOpt]   let _10932: Int = Int(0)
// [KnfOpt]   if (ok.10930 == _10932) then {
// [KnfOpt]     let sum.104: Int = Var(acc.10927)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _10933: Int = Apply(f.10926, [acc.10927, val.10931, ])
// [KnfOpt]     Jump(fold.10924, [stream.10925, f.10926, _10933, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.10924, [under1200.103, add.10920, _10923, ])
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 5
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 0
// [KnfOpt] Inline decision le.83 accepted
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.10936: Int = (x.10937: Int, y.10938: Int) {
// [KnfOpt]   Add(x.10937, y.10938)
// [KnfOpt] }
// [KnfOpt] let _10939: Int = Int(0)
// [KnfOpt] let join fold.10940: Int = (stream.10941: Fun([Unit], Tuple([Int, Int])), f.10942: Fun([Int, Int], Int), acc.10943: Int) {
// [KnfOpt]   let _10944: Unit = Unit
// [KnfOpt]   let _10945: Tuple([Int, Int]) = Apply(stream.10941, [_10944, ])
// [KnfOpt]   let (ok.10946: Var({val: Some(Int)}), val.10947: Var({val: Some(Int)})) = _10945
// [KnfOpt]   let _10948: Int = Int(0)
// [KnfOpt]   if (ok.10946 == _10948) then {
// [KnfOpt]     let sum.104: Int = Var(acc.10943)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _10949: Int = Apply(f.10942, [acc.10943, val.10947, ])
// [KnfOpt]     Jump(fold.10940, [stream.10941, f.10942, _10949, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.10940, [under1200.103, add.10936, _10939, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(le) let _102: Fun([Int], Int) = Unit
// [KnfOpt] let rec aux.10950: Tuple([Int, Int]) = (u.10951: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.10952: Tuple([Int, Int]) = (u.10953: Var({val: Some(Unit)})) {
// [KnfOpt]     let _10954: Unit = Unit
// [KnfOpt]     let _10955: Tuple([Int, Int]) = Apply(over50.100, [_10954, ])
// [KnfOpt]     let (ok.10956: Var({val: Some(Int)}), val.10957: Var({val: Some(Int)})) = _10955
// [KnfOpt]     let _10958: Int = Int(0)
// [KnfOpt]     if (ok.10956 == _10958) then {
// [KnfOpt]       let _10959: Int = Int(0)
// [KnfOpt]       let _10960: Int = Int(0)
// [KnfOpt]       Tuple([_10959, _10960, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.10961: Int = Apply(_102, [val.10957, ])
// [KnfOpt]       let _10962: Int = Int(0)
// [KnfOpt]       if (r.10961 == _10962) then {
// [KnfOpt]         let _10963: Int = Int(1)
// [KnfOpt]         Tuple([_10963, val.10957, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _10964: Unit = Unit
// [KnfOpt]         Jump(aux.10952, [_10964, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.10952, [u.10951, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.10950)
// [KnfOpt] let rec add.10965: Int = (x.10966: Int, y.10967: Int) {
// [KnfOpt]   Add(x.10966, y.10967)
// [KnfOpt] }
// [KnfOpt] let _10968: Int = Int(0)
// [KnfOpt] let join fold.10969: Int = (stream.10970: Fun([Unit], Tuple([Int, Int])), f.10971: Fun([Int, Int], Int), acc.10972: Int) {
// [KnfOpt]   let _10973: Unit = Unit
// [KnfOpt]   let _10974: Tuple([Int, Int]) = Apply(stream.10970, [_10973, ])
// [KnfOpt]   let (ok.10975: Var({val: Some(Int)}), val.10976: Var({val: Some(Int)})) = _10974
// [KnfOpt]   let _10977: Int = Int(0)
// [KnfOpt]   if (ok.10975 == _10977) then {
// [KnfOpt]     let sum.104: Int = Var(acc.10972)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _10978: Int = Apply(f.10971, [acc.10972, val.10976, ])
// [KnfOpt]     Jump(fold.10969, [stream.10970, f.10971, _10978, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.10969, [under1200.103, add.10965, _10968, ])
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.10981: Int = (x.10982: Int, y.10983: Int) {
// [KnfOpt]   Add(x.10982, y.10983)
// [KnfOpt] }
// [KnfOpt] let _10984: Int = Int(0)
// [KnfOpt] let join fold.10985: Int = (stream.10986: Fun([Unit], Tuple([Int, Int])), f.10987: Fun([Int, Int], Int), acc.10988: Int) {
// [KnfOpt]   let _10989: Unit = Unit
// [KnfOpt]   let _10990: Tuple([Int, Int]) = Apply(stream.10986, [_10989, ])
// [KnfOpt]   let (ok.10991: Var({val: Some(Int)}), val.10992: Var({val: Some(Int)})) = _10990
// [KnfOpt]   let _10993: Int = Int(0)
// [KnfOpt]   if (ok.10991 == _10993) then {
// [KnfOpt]     let sum.104: Int = Var(acc.10988)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _10994: Int = Apply(f.10987, [acc.10988, val.10992, ])
// [KnfOpt]     Jump(fold.10985, [stream.10986, f.10987, _10994, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.10985, [under1200.103, add.10981, _10984, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let over50.100: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let _101: Int = Int(1200)
// [KnfOpt] let rec aux.10979: Int = (y.10980: Int) {
// [KnfOpt]   if (y.10980 <= _101) then {
// [KnfOpt]     Int(0)
// [KnfOpt]   } else {
// [KnfOpt]     Int(1)
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] let _102: Fun([Int], Int) = Var(aux.10979)
// [KnfOpt] let rec aux.10995: Tuple([Int, Int]) = (u.10996: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.10997: Tuple([Int, Int]) = (u.10998: Var({val: Some(Unit)})) {
// [KnfOpt]     let _10999: Unit = Unit
// [KnfOpt]     let _11000: Tuple([Int, Int]) = Apply(over50.100, [_10999, ])
// [KnfOpt]     let (ok.11001: Var({val: Some(Int)}), val.11002: Var({val: Some(Int)})) = _11000
// [KnfOpt]     let _11003: Int = Int(0)
// [KnfOpt]     if (ok.11001 == _11003) then {
// [KnfOpt]       let _11004: Int = Int(0)
// [KnfOpt]       let _11005: Int = Int(0)
// [KnfOpt]       Tuple([_11004, _11005, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.11006: Int = Apply(_102, [val.11002, ])
// [KnfOpt]       let _11007: Int = Int(0)
// [KnfOpt]       if (r.11006 == _11007) then {
// [KnfOpt]         let _11008: Int = Int(1)
// [KnfOpt]         Tuple([_11008, val.11002, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _11009: Unit = Unit
// [KnfOpt]         Jump(aux.10997, [_11009, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.10997, [u.10996, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.10995)
// [KnfOpt] let rec add.11010: Int = (x.11011: Int, y.11012: Int) {
// [KnfOpt]   Add(x.11011, y.11012)
// [KnfOpt] }
// [KnfOpt] let _11013: Int = Int(0)
// [KnfOpt] let join fold.11014: Int = (stream.11015: Fun([Unit], Tuple([Int, Int])), f.11016: Fun([Int, Int], Int), acc.11017: Int) {
// [KnfOpt]   let _11018: Unit = Unit
// [KnfOpt]   let _11019: Tuple([Int, Int]) = Apply(stream.11015, [_11018, ])
// [KnfOpt]   let (ok.11020: Var({val: Some(Int)}), val.11021: Var({val: Some(Int)})) = _11019
// [KnfOpt]   let _11022: Int = Int(0)
// [KnfOpt]   if (ok.11020 == _11022) then {
// [KnfOpt]     let sum.104: Int = Var(acc.11017)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _11023: Int = Apply(f.11016, [acc.11017, val.11021, ])
// [KnfOpt]     Jump(fold.11014, [stream.11015, f.11016, _11023, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.11014, [under1200.103, add.11010, _11013, ])
// [KnfOpt] Inline threshold 5
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 0
// [KnfOpt] Inline decision le.83 accepted
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.11039: Int = (x.11040: Int, y.11041: Int) {
// [KnfOpt]   Add(x.11040, y.11041)
// [KnfOpt] }
// [KnfOpt] let _11042: Int = Int(0)
// [KnfOpt] let join fold.11043: Int = (stream.11044: Fun([Unit], Tuple([Int, Int])), f.11045: Fun([Int, Int], Int), acc.11046: Int) {
// [KnfOpt]   let _11047: Unit = Unit
// [KnfOpt]   let _11048: Tuple([Int, Int]) = Apply(stream.11044, [_11047, ])
// [KnfOpt]   let (ok.11049: Var({val: Some(Int)}), val.11050: Var({val: Some(Int)})) = _11048
// [KnfOpt]   let _11051: Int = Int(0)
// [KnfOpt]   if (ok.11049 == _11051) then {
// [KnfOpt]     let sum.104: Int = Var(acc.11046)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _11052: Int = Apply(f.11045, [acc.11046, val.11050, ])
// [KnfOpt]     Jump(fold.11043, [stream.11044, f.11045, _11052, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.11043, [under1200.103, add.11039, _11042, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(le) let _102: Fun([Int], Int) = Unit
// [KnfOpt] let rec aux.11053: Tuple([Int, Int]) = (u.11054: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.11055: Tuple([Int, Int]) = (u.11056: Var({val: Some(Unit)})) {
// [KnfOpt]     let _11057: Unit = Unit
// [KnfOpt]     let _11058: Tuple([Int, Int]) = Apply(over50.100, [_11057, ])
// [KnfOpt]     let (ok.11059: Var({val: Some(Int)}), val.11060: Var({val: Some(Int)})) = _11058
// [KnfOpt]     let _11061: Int = Int(0)
// [KnfOpt]     if (ok.11059 == _11061) then {
// [KnfOpt]       let _11062: Int = Int(0)
// [KnfOpt]       let _11063: Int = Int(0)
// [KnfOpt]       Tuple([_11062, _11063, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.11064: Int = Apply(_102, [val.11060, ])
// [KnfOpt]       let _11065: Int = Int(0)
// [KnfOpt]       if (r.11064 == _11065) then {
// [KnfOpt]         let _11066: Int = Int(1)
// [KnfOpt]         Tuple([_11066, val.11060, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _11067: Unit = Unit
// [KnfOpt]         Jump(aux.11055, [_11067, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.11055, [u.11054, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.11053)
// [KnfOpt] let rec add.11068: Int = (x.11069: Int, y.11070: Int) {
// [KnfOpt]   Add(x.11069, y.11070)
// [KnfOpt] }
// [KnfOpt] let _11071: Int = Int(0)
// [KnfOpt] let join fold.11072: Int = (stream.11073: Fun([Unit], Tuple([Int, Int])), f.11074: Fun([Int, Int], Int), acc.11075: Int) {
// [KnfOpt]   let _11076: Unit = Unit
// [KnfOpt]   let _11077: Tuple([Int, Int]) = Apply(stream.11073, [_11076, ])
// [KnfOpt]   let (ok.11078: Var({val: Some(Int)}), val.11079: Var({val: Some(Int)})) = _11077
// [KnfOpt]   let _11080: Int = Int(0)
// [KnfOpt]   if (ok.11078 == _11080) then {
// [KnfOpt]     let sum.104: Int = Var(acc.11075)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _11081: Int = Apply(f.11074, [acc.11075, val.11079, ])
// [KnfOpt]     Jump(fold.11072, [stream.11073, f.11074, _11081, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.11072, [under1200.103, add.11068, _11071, ])
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.11084: Int = (x.11085: Int, y.11086: Int) {
// [KnfOpt]   Add(x.11085, y.11086)
// [KnfOpt] }
// [KnfOpt] let _11087: Int = Int(0)
// [KnfOpt] let join fold.11088: Int = (stream.11089: Fun([Unit], Tuple([Int, Int])), f.11090: Fun([Int, Int], Int), acc.11091: Int) {
// [KnfOpt]   let _11092: Unit = Unit
// [KnfOpt]   let _11093: Tuple([Int, Int]) = Apply(stream.11089, [_11092, ])
// [KnfOpt]   let (ok.11094: Var({val: Some(Int)}), val.11095: Var({val: Some(Int)})) = _11093
// [KnfOpt]   let _11096: Int = Int(0)
// [KnfOpt]   if (ok.11094 == _11096) then {
// [KnfOpt]     let sum.104: Int = Var(acc.11091)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _11097: Int = Apply(f.11090, [acc.11091, val.11095, ])
// [KnfOpt]     Jump(fold.11088, [stream.11089, f.11090, _11097, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.11088, [under1200.103, add.11084, _11087, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(concat) let catt.94: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let _95: Int = Int(1)
// [KnfOpt] let rec aux.10346: Int = (y.10347: Int) {
// [KnfOpt]   Add(_95, y.10347)
// [KnfOpt] }
// [KnfOpt] let _96: Fun([Int], Int) = Var(aux.10346)
// [KnfOpt] let rec aux.10732: Tuple([Int, Int]) = (u.10733: Var({val: Some(Unit)})) {
// [KnfOpt]   let _10734: Unit = Unit
// [KnfOpt]   let _10735: Tuple([Int, Int]) = Apply(catt.94, [_10734, ])
// [KnfOpt]   let (ok.10736: Var({val: Some(Int)}), val.10737: Var({val: Some(Int)})) = _10735
// [KnfOpt]   let _10738: Int = Int(0)
// [KnfOpt]   if (ok.10736 == _10738) then {
// [KnfOpt]     let _10739: Int = Int(0)
// [KnfOpt]     let _10740: Int = Int(0)
// [KnfOpt]     Tuple([_10739, _10740, ])
// [KnfOpt]   } else {
// [KnfOpt]     let _10741: Int = Int(1)
// [KnfOpt]     let _10742: Int = Apply(_96, [val.10737, ])
// [KnfOpt]     Tuple([_10741, _10742, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] let addone.97: Fun([Unit], Tuple([Int, Int])) = Var(aux.10732)
// [KnfOpt] let _98: Int = Int(50)
// [KnfOpt] let rec aux.10934: Int = (y.10935: Int) {
// [KnfOpt]   if (_98 <= y.10935) then {
// [KnfOpt]     Int(0)
// [KnfOpt]   } else {
// [KnfOpt]     Int(1)
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] let _99: Fun([Int], Int) = Var(aux.10934)
// [KnfOpt] let rec aux.11024: Tuple([Int, Int]) = (u.11025: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.11026: Tuple([Int, Int]) = (u.11027: Var({val: Some(Unit)})) {
// [KnfOpt]     let _11028: Unit = Unit
// [KnfOpt]     let _11029: Tuple([Int, Int]) = Apply(addone.97, [_11028, ])
// [KnfOpt]     let (ok.11030: Var({val: Some(Int)}), val.11031: Var({val: Some(Int)})) = _11029
// [KnfOpt]     let _11032: Int = Int(0)
// [KnfOpt]     if (ok.11030 == _11032) then {
// [KnfOpt]       let _11033: Int = Int(0)
// [KnfOpt]       let _11034: Int = Int(0)
// [KnfOpt]       Tuple([_11033, _11034, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.11035: Int = Apply(_99, [val.11031, ])
// [KnfOpt]       let _11036: Int = Int(0)
// [KnfOpt]       if (r.11035 == _11036) then {
// [KnfOpt]         let _11037: Int = Int(1)
// [KnfOpt]         Tuple([_11037, val.11031, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _11038: Unit = Unit
// [KnfOpt]         Jump(aux.11026, [_11038, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.11026, [u.11025, ])
// [KnfOpt] }
// [KnfOpt] let over50.100: Fun([Unit], Tuple([Int, Int])) = Var(aux.11024)
// [KnfOpt] let _101: Int = Int(1200)
// [KnfOpt] let rec aux.11082: Int = (y.11083: Int) {
// [KnfOpt]   if (y.11083 <= _101) then {
// [KnfOpt]     Int(0)
// [KnfOpt]   } else {
// [KnfOpt]     Int(1)
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] let _102: Fun([Int], Int) = Var(aux.11082)
// [KnfOpt] let rec aux.11098: Tuple([Int, Int]) = (u.11099: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.11100: Tuple([Int, Int]) = (u.11101: Var({val: Some(Unit)})) {
// [KnfOpt]     let _11102: Unit = Unit
// [KnfOpt]     let _11103: Tuple([Int, Int]) = Apply(over50.100, [_11102, ])
// [KnfOpt]     let (ok.11104: Var({val: Some(Int)}), val.11105: Var({val: Some(Int)})) = _11103
// [KnfOpt]     let _11106: Int = Int(0)
// [KnfOpt]     if (ok.11104 == _11106) then {
// [KnfOpt]       let _11107: Int = Int(0)
// [KnfOpt]       let _11108: Int = Int(0)
// [KnfOpt]       Tuple([_11107, _11108, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.11109: Int = Apply(_102, [val.11105, ])
// [KnfOpt]       let _11110: Int = Int(0)
// [KnfOpt]       if (r.11109 == _11110) then {
// [KnfOpt]         let _11111: Int = Int(1)
// [KnfOpt]         Tuple([_11111, val.11105, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _11112: Unit = Unit
// [KnfOpt]         Jump(aux.11100, [_11112, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.11100, [u.11099, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.11098)
// [KnfOpt] let rec add.11113: Int = (x.11114: Int, y.11115: Int) {
// [KnfOpt]   Add(x.11114, y.11115)
// [KnfOpt] }
// [KnfOpt] let _11116: Int = Int(0)
// [KnfOpt] let join fold.11117: Int = (stream.11118: Fun([Unit], Tuple([Int, Int])), f.11119: Fun([Int, Int], Int), acc.11120: Int) {
// [KnfOpt]   let _11121: Unit = Unit
// [KnfOpt]   let _11122: Tuple([Int, Int]) = Apply(stream.11118, [_11121, ])
// [KnfOpt]   let (ok.11123: Var({val: Some(Int)}), val.11124: Var({val: Some(Int)})) = _11122
// [KnfOpt]   let _11125: Int = Int(0)
// [KnfOpt]   if (ok.11123 == _11125) then {
// [KnfOpt]     let sum.104: Int = Var(acc.11120)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _11126: Int = Apply(f.11119, [acc.11120, val.11124, ])
// [KnfOpt]     Jump(fold.11117, [stream.11118, f.11119, _11126, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.11117, [under1200.103, add.11113, _11116, ])
// [KnfOpt] Inline threshold 3
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 0
// [KnfOpt] Inline decision addx.59 accepted
// [KnfOpt] Inline threshold 20
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 0
// [KnfOpt] Inline decision map.1 accepted
// [KnfOpt] Inline threshold 5
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 0
// [KnfOpt] Inline decision gt.79 accepted
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 5
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 0
// [KnfOpt] Inline decision le.83 accepted
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.11136: Int = (x.11137: Int, y.11138: Int) {
// [KnfOpt]   Add(x.11137, y.11138)
// [KnfOpt] }
// [KnfOpt] let _11139: Int = Int(0)
// [KnfOpt] let join fold.11140: Int = (stream.11141: Fun([Unit], Tuple([Int, Int])), f.11142: Fun([Int, Int], Int), acc.11143: Int) {
// [KnfOpt]   let _11144: Unit = Unit
// [KnfOpt]   let _11145: Tuple([Int, Int]) = Apply(stream.11141, [_11144, ])
// [KnfOpt]   let (ok.11146: Var({val: Some(Int)}), val.11147: Var({val: Some(Int)})) = _11145
// [KnfOpt]   let _11148: Int = Int(0)
// [KnfOpt]   if (ok.11146 == _11148) then {
// [KnfOpt]     let sum.104: Int = Var(acc.11143)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _11149: Int = Apply(f.11142, [acc.11143, val.11147, ])
// [KnfOpt]     Jump(fold.11140, [stream.11141, f.11142, _11149, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.11140, [under1200.103, add.11136, _11139, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(le) let _102: Fun([Int], Int) = Unit
// [KnfOpt] let rec aux.11150: Tuple([Int, Int]) = (u.11151: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.11152: Tuple([Int, Int]) = (u.11153: Var({val: Some(Unit)})) {
// [KnfOpt]     let _11154: Unit = Unit
// [KnfOpt]     let _11155: Tuple([Int, Int]) = Apply(over50.100, [_11154, ])
// [KnfOpt]     let (ok.11156: Var({val: Some(Int)}), val.11157: Var({val: Some(Int)})) = _11155
// [KnfOpt]     let _11158: Int = Int(0)
// [KnfOpt]     if (ok.11156 == _11158) then {
// [KnfOpt]       let _11159: Int = Int(0)
// [KnfOpt]       let _11160: Int = Int(0)
// [KnfOpt]       Tuple([_11159, _11160, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.11161: Int = Apply(_102, [val.11157, ])
// [KnfOpt]       let _11162: Int = Int(0)
// [KnfOpt]       if (r.11161 == _11162) then {
// [KnfOpt]         let _11163: Int = Int(1)
// [KnfOpt]         Tuple([_11163, val.11157, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _11164: Unit = Unit
// [KnfOpt]         Jump(aux.11152, [_11164, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.11152, [u.11151, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.11150)
// [KnfOpt] let rec add.11165: Int = (x.11166: Int, y.11167: Int) {
// [KnfOpt]   Add(x.11166, y.11167)
// [KnfOpt] }
// [KnfOpt] let _11168: Int = Int(0)
// [KnfOpt] let join fold.11169: Int = (stream.11170: Fun([Unit], Tuple([Int, Int])), f.11171: Fun([Int, Int], Int), acc.11172: Int) {
// [KnfOpt]   let _11173: Unit = Unit
// [KnfOpt]   let _11174: Tuple([Int, Int]) = Apply(stream.11170, [_11173, ])
// [KnfOpt]   let (ok.11175: Var({val: Some(Int)}), val.11176: Var({val: Some(Int)})) = _11174
// [KnfOpt]   let _11177: Int = Int(0)
// [KnfOpt]   if (ok.11175 == _11177) then {
// [KnfOpt]     let sum.104: Int = Var(acc.11172)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _11178: Int = Apply(f.11171, [acc.11172, val.11176, ])
// [KnfOpt]     Jump(fold.11169, [stream.11170, f.11171, _11178, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.11169, [under1200.103, add.11165, _11168, ])
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.11181: Int = (x.11182: Int, y.11183: Int) {
// [KnfOpt]   Add(x.11182, y.11183)
// [KnfOpt] }
// [KnfOpt] let _11184: Int = Int(0)
// [KnfOpt] let join fold.11185: Int = (stream.11186: Fun([Unit], Tuple([Int, Int])), f.11187: Fun([Int, Int], Int), acc.11188: Int) {
// [KnfOpt]   let _11189: Unit = Unit
// [KnfOpt]   let _11190: Tuple([Int, Int]) = Apply(stream.11186, [_11189, ])
// [KnfOpt]   let (ok.11191: Var({val: Some(Int)}), val.11192: Var({val: Some(Int)})) = _11190
// [KnfOpt]   let _11193: Int = Int(0)
// [KnfOpt]   if (ok.11191 == _11193) then {
// [KnfOpt]     let sum.104: Int = Var(acc.11188)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _11194: Int = Apply(f.11187, [acc.11188, val.11192, ])
// [KnfOpt]     Jump(fold.11185, [stream.11186, f.11187, _11194, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.11185, [under1200.103, add.11181, _11184, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let over50.100: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let _101: Int = Int(1200)
// [KnfOpt] let rec aux.11179: Int = (y.11180: Int) {
// [KnfOpt]   if (y.11180 <= _101) then {
// [KnfOpt]     Int(0)
// [KnfOpt]   } else {
// [KnfOpt]     Int(1)
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] let _102: Fun([Int], Int) = Var(aux.11179)
// [KnfOpt] let rec aux.11195: Tuple([Int, Int]) = (u.11196: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.11197: Tuple([Int, Int]) = (u.11198: Var({val: Some(Unit)})) {
// [KnfOpt]     let _11199: Unit = Unit
// [KnfOpt]     let _11200: Tuple([Int, Int]) = Apply(over50.100, [_11199, ])
// [KnfOpt]     let (ok.11201: Var({val: Some(Int)}), val.11202: Var({val: Some(Int)})) = _11200
// [KnfOpt]     let _11203: Int = Int(0)
// [KnfOpt]     if (ok.11201 == _11203) then {
// [KnfOpt]       let _11204: Int = Int(0)
// [KnfOpt]       let _11205: Int = Int(0)
// [KnfOpt]       Tuple([_11204, _11205, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.11206: Int = Apply(_102, [val.11202, ])
// [KnfOpt]       let _11207: Int = Int(0)
// [KnfOpt]       if (r.11206 == _11207) then {
// [KnfOpt]         let _11208: Int = Int(1)
// [KnfOpt]         Tuple([_11208, val.11202, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _11209: Unit = Unit
// [KnfOpt]         Jump(aux.11197, [_11209, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.11197, [u.11196, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.11195)
// [KnfOpt] let rec add.11210: Int = (x.11211: Int, y.11212: Int) {
// [KnfOpt]   Add(x.11211, y.11212)
// [KnfOpt] }
// [KnfOpt] let _11213: Int = Int(0)
// [KnfOpt] let join fold.11214: Int = (stream.11215: Fun([Unit], Tuple([Int, Int])), f.11216: Fun([Int, Int], Int), acc.11217: Int) {
// [KnfOpt]   let _11218: Unit = Unit
// [KnfOpt]   let _11219: Tuple([Int, Int]) = Apply(stream.11215, [_11218, ])
// [KnfOpt]   let (ok.11220: Var({val: Some(Int)}), val.11221: Var({val: Some(Int)})) = _11219
// [KnfOpt]   let _11222: Int = Int(0)
// [KnfOpt]   if (ok.11220 == _11222) then {
// [KnfOpt]     let sum.104: Int = Var(acc.11217)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _11223: Int = Apply(f.11216, [acc.11217, val.11221, ])
// [KnfOpt]     Jump(fold.11214, [stream.11215, f.11216, _11223, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.11214, [under1200.103, add.11210, _11213, ])
// [KnfOpt] Inline threshold 5
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 0
// [KnfOpt] Inline decision le.83 accepted
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.11239: Int = (x.11240: Int, y.11241: Int) {
// [KnfOpt]   Add(x.11240, y.11241)
// [KnfOpt] }
// [KnfOpt] let _11242: Int = Int(0)
// [KnfOpt] let join fold.11243: Int = (stream.11244: Fun([Unit], Tuple([Int, Int])), f.11245: Fun([Int, Int], Int), acc.11246: Int) {
// [KnfOpt]   let _11247: Unit = Unit
// [KnfOpt]   let _11248: Tuple([Int, Int]) = Apply(stream.11244, [_11247, ])
// [KnfOpt]   let (ok.11249: Var({val: Some(Int)}), val.11250: Var({val: Some(Int)})) = _11248
// [KnfOpt]   let _11251: Int = Int(0)
// [KnfOpt]   if (ok.11249 == _11251) then {
// [KnfOpt]     let sum.104: Int = Var(acc.11246)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _11252: Int = Apply(f.11245, [acc.11246, val.11250, ])
// [KnfOpt]     Jump(fold.11243, [stream.11244, f.11245, _11252, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.11243, [under1200.103, add.11239, _11242, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(le) let _102: Fun([Int], Int) = Unit
// [KnfOpt] let rec aux.11253: Tuple([Int, Int]) = (u.11254: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.11255: Tuple([Int, Int]) = (u.11256: Var({val: Some(Unit)})) {
// [KnfOpt]     let _11257: Unit = Unit
// [KnfOpt]     let _11258: Tuple([Int, Int]) = Apply(over50.100, [_11257, ])
// [KnfOpt]     let (ok.11259: Var({val: Some(Int)}), val.11260: Var({val: Some(Int)})) = _11258
// [KnfOpt]     let _11261: Int = Int(0)
// [KnfOpt]     if (ok.11259 == _11261) then {
// [KnfOpt]       let _11262: Int = Int(0)
// [KnfOpt]       let _11263: Int = Int(0)
// [KnfOpt]       Tuple([_11262, _11263, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.11264: Int = Apply(_102, [val.11260, ])
// [KnfOpt]       let _11265: Int = Int(0)
// [KnfOpt]       if (r.11264 == _11265) then {
// [KnfOpt]         let _11266: Int = Int(1)
// [KnfOpt]         Tuple([_11266, val.11260, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _11267: Unit = Unit
// [KnfOpt]         Jump(aux.11255, [_11267, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.11255, [u.11254, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.11253)
// [KnfOpt] let rec add.11268: Int = (x.11269: Int, y.11270: Int) {
// [KnfOpt]   Add(x.11269, y.11270)
// [KnfOpt] }
// [KnfOpt] let _11271: Int = Int(0)
// [KnfOpt] let join fold.11272: Int = (stream.11273: Fun([Unit], Tuple([Int, Int])), f.11274: Fun([Int, Int], Int), acc.11275: Int) {
// [KnfOpt]   let _11276: Unit = Unit
// [KnfOpt]   let _11277: Tuple([Int, Int]) = Apply(stream.11273, [_11276, ])
// [KnfOpt]   let (ok.11278: Var({val: Some(Int)}), val.11279: Var({val: Some(Int)})) = _11277
// [KnfOpt]   let _11280: Int = Int(0)
// [KnfOpt]   if (ok.11278 == _11280) then {
// [KnfOpt]     let sum.104: Int = Var(acc.11275)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _11281: Int = Apply(f.11274, [acc.11275, val.11279, ])
// [KnfOpt]     Jump(fold.11272, [stream.11273, f.11274, _11281, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.11272, [under1200.103, add.11268, _11271, ])
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.11284: Int = (x.11285: Int, y.11286: Int) {
// [KnfOpt]   Add(x.11285, y.11286)
// [KnfOpt] }
// [KnfOpt] let _11287: Int = Int(0)
// [KnfOpt] let join fold.11288: Int = (stream.11289: Fun([Unit], Tuple([Int, Int])), f.11290: Fun([Int, Int], Int), acc.11291: Int) {
// [KnfOpt]   let _11292: Unit = Unit
// [KnfOpt]   let _11293: Tuple([Int, Int]) = Apply(stream.11289, [_11292, ])
// [KnfOpt]   let (ok.11294: Var({val: Some(Int)}), val.11295: Var({val: Some(Int)})) = _11293
// [KnfOpt]   let _11296: Int = Int(0)
// [KnfOpt]   if (ok.11294 == _11296) then {
// [KnfOpt]     let sum.104: Int = Var(acc.11291)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _11297: Int = Apply(f.11290, [acc.11291, val.11295, ])
// [KnfOpt]     Jump(fold.11288, [stream.11289, f.11290, _11297, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.11288, [under1200.103, add.11284, _11287, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(gt) let _99: Fun([Int], Int) = Unit
// [KnfOpt] let rec aux.11224: Tuple([Int, Int]) = (u.11225: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.11226: Tuple([Int, Int]) = (u.11227: Var({val: Some(Unit)})) {
// [KnfOpt]     let _11228: Unit = Unit
// [KnfOpt]     let _11229: Tuple([Int, Int]) = Apply(addone.97, [_11228, ])
// [KnfOpt]     let (ok.11230: Var({val: Some(Int)}), val.11231: Var({val: Some(Int)})) = _11229
// [KnfOpt]     let _11232: Int = Int(0)
// [KnfOpt]     if (ok.11230 == _11232) then {
// [KnfOpt]       let _11233: Int = Int(0)
// [KnfOpt]       let _11234: Int = Int(0)
// [KnfOpt]       Tuple([_11233, _11234, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.11235: Int = Apply(_99, [val.11231, ])
// [KnfOpt]       let _11236: Int = Int(0)
// [KnfOpt]       if (r.11235 == _11236) then {
// [KnfOpt]         let _11237: Int = Int(1)
// [KnfOpt]         Tuple([_11237, val.11231, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _11238: Unit = Unit
// [KnfOpt]         Jump(aux.11226, [_11238, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.11226, [u.11225, ])
// [KnfOpt] }
// [KnfOpt] let over50.100: Fun([Unit], Tuple([Int, Int])) = Var(aux.11224)
// [KnfOpt] let _101: Int = Int(1200)
// [KnfOpt] let rec aux.11282: Int = (y.11283: Int) {
// [KnfOpt]   if (y.11283 <= _101) then {
// [KnfOpt]     Int(0)
// [KnfOpt]   } else {
// [KnfOpt]     Int(1)
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] let _102: Fun([Int], Int) = Var(aux.11282)
// [KnfOpt] let rec aux.11298: Tuple([Int, Int]) = (u.11299: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.11300: Tuple([Int, Int]) = (u.11301: Var({val: Some(Unit)})) {
// [KnfOpt]     let _11302: Unit = Unit
// [KnfOpt]     let _11303: Tuple([Int, Int]) = Apply(over50.100, [_11302, ])
// [KnfOpt]     let (ok.11304: Var({val: Some(Int)}), val.11305: Var({val: Some(Int)})) = _11303
// [KnfOpt]     let _11306: Int = Int(0)
// [KnfOpt]     if (ok.11304 == _11306) then {
// [KnfOpt]       let _11307: Int = Int(0)
// [KnfOpt]       let _11308: Int = Int(0)
// [KnfOpt]       Tuple([_11307, _11308, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.11309: Int = Apply(_102, [val.11305, ])
// [KnfOpt]       let _11310: Int = Int(0)
// [KnfOpt]       if (r.11309 == _11310) then {
// [KnfOpt]         let _11311: Int = Int(1)
// [KnfOpt]         Tuple([_11311, val.11305, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _11312: Unit = Unit
// [KnfOpt]         Jump(aux.11300, [_11312, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.11300, [u.11299, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.11298)
// [KnfOpt] let rec add.11313: Int = (x.11314: Int, y.11315: Int) {
// [KnfOpt]   Add(x.11314, y.11315)
// [KnfOpt] }
// [KnfOpt] let _11316: Int = Int(0)
// [KnfOpt] let join fold.11317: Int = (stream.11318: Fun([Unit], Tuple([Int, Int])), f.11319: Fun([Int, Int], Int), acc.11320: Int) {
// [KnfOpt]   let _11321: Unit = Unit
// [KnfOpt]   let _11322: Tuple([Int, Int]) = Apply(stream.11318, [_11321, ])
// [KnfOpt]   let (ok.11323: Var({val: Some(Int)}), val.11324: Var({val: Some(Int)})) = _11322
// [KnfOpt]   let _11325: Int = Int(0)
// [KnfOpt]   if (ok.11323 == _11325) then {
// [KnfOpt]     let sum.104: Int = Var(acc.11320)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _11326: Int = Apply(f.11319, [acc.11320, val.11324, ])
// [KnfOpt]     Jump(fold.11317, [stream.11318, f.11319, _11326, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.11317, [under1200.103, add.11313, _11316, ])
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 5
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 0
// [KnfOpt] Inline decision le.83 accepted
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.11329: Int = (x.11330: Int, y.11331: Int) {
// [KnfOpt]   Add(x.11330, y.11331)
// [KnfOpt] }
// [KnfOpt] let _11332: Int = Int(0)
// [KnfOpt] let join fold.11333: Int = (stream.11334: Fun([Unit], Tuple([Int, Int])), f.11335: Fun([Int, Int], Int), acc.11336: Int) {
// [KnfOpt]   let _11337: Unit = Unit
// [KnfOpt]   let _11338: Tuple([Int, Int]) = Apply(stream.11334, [_11337, ])
// [KnfOpt]   let (ok.11339: Var({val: Some(Int)}), val.11340: Var({val: Some(Int)})) = _11338
// [KnfOpt]   let _11341: Int = Int(0)
// [KnfOpt]   if (ok.11339 == _11341) then {
// [KnfOpt]     let sum.104: Int = Var(acc.11336)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _11342: Int = Apply(f.11335, [acc.11336, val.11340, ])
// [KnfOpt]     Jump(fold.11333, [stream.11334, f.11335, _11342, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.11333, [under1200.103, add.11329, _11332, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(le) let _102: Fun([Int], Int) = Unit
// [KnfOpt] let rec aux.11343: Tuple([Int, Int]) = (u.11344: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.11345: Tuple([Int, Int]) = (u.11346: Var({val: Some(Unit)})) {
// [KnfOpt]     let _11347: Unit = Unit
// [KnfOpt]     let _11348: Tuple([Int, Int]) = Apply(over50.100, [_11347, ])
// [KnfOpt]     let (ok.11349: Var({val: Some(Int)}), val.11350: Var({val: Some(Int)})) = _11348
// [KnfOpt]     let _11351: Int = Int(0)
// [KnfOpt]     if (ok.11349 == _11351) then {
// [KnfOpt]       let _11352: Int = Int(0)
// [KnfOpt]       let _11353: Int = Int(0)
// [KnfOpt]       Tuple([_11352, _11353, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.11354: Int = Apply(_102, [val.11350, ])
// [KnfOpt]       let _11355: Int = Int(0)
// [KnfOpt]       if (r.11354 == _11355) then {
// [KnfOpt]         let _11356: Int = Int(1)
// [KnfOpt]         Tuple([_11356, val.11350, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _11357: Unit = Unit
// [KnfOpt]         Jump(aux.11345, [_11357, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.11345, [u.11344, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.11343)
// [KnfOpt] let rec add.11358: Int = (x.11359: Int, y.11360: Int) {
// [KnfOpt]   Add(x.11359, y.11360)
// [KnfOpt] }
// [KnfOpt] let _11361: Int = Int(0)
// [KnfOpt] let join fold.11362: Int = (stream.11363: Fun([Unit], Tuple([Int, Int])), f.11364: Fun([Int, Int], Int), acc.11365: Int) {
// [KnfOpt]   let _11366: Unit = Unit
// [KnfOpt]   let _11367: Tuple([Int, Int]) = Apply(stream.11363, [_11366, ])
// [KnfOpt]   let (ok.11368: Var({val: Some(Int)}), val.11369: Var({val: Some(Int)})) = _11367
// [KnfOpt]   let _11370: Int = Int(0)
// [KnfOpt]   if (ok.11368 == _11370) then {
// [KnfOpt]     let sum.104: Int = Var(acc.11365)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _11371: Int = Apply(f.11364, [acc.11365, val.11369, ])
// [KnfOpt]     Jump(fold.11362, [stream.11363, f.11364, _11371, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.11362, [under1200.103, add.11358, _11361, ])
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.11374: Int = (x.11375: Int, y.11376: Int) {
// [KnfOpt]   Add(x.11375, y.11376)
// [KnfOpt] }
// [KnfOpt] let _11377: Int = Int(0)
// [KnfOpt] let join fold.11378: Int = (stream.11379: Fun([Unit], Tuple([Int, Int])), f.11380: Fun([Int, Int], Int), acc.11381: Int) {
// [KnfOpt]   let _11382: Unit = Unit
// [KnfOpt]   let _11383: Tuple([Int, Int]) = Apply(stream.11379, [_11382, ])
// [KnfOpt]   let (ok.11384: Var({val: Some(Int)}), val.11385: Var({val: Some(Int)})) = _11383
// [KnfOpt]   let _11386: Int = Int(0)
// [KnfOpt]   if (ok.11384 == _11386) then {
// [KnfOpt]     let sum.104: Int = Var(acc.11381)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _11387: Int = Apply(f.11380, [acc.11381, val.11385, ])
// [KnfOpt]     Jump(fold.11378, [stream.11379, f.11380, _11387, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.11378, [under1200.103, add.11374, _11377, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let over50.100: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let _101: Int = Int(1200)
// [KnfOpt] let rec aux.11372: Int = (y.11373: Int) {
// [KnfOpt]   if (y.11373 <= _101) then {
// [KnfOpt]     Int(0)
// [KnfOpt]   } else {
// [KnfOpt]     Int(1)
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] let _102: Fun([Int], Int) = Var(aux.11372)
// [KnfOpt] let rec aux.11388: Tuple([Int, Int]) = (u.11389: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.11390: Tuple([Int, Int]) = (u.11391: Var({val: Some(Unit)})) {
// [KnfOpt]     let _11392: Unit = Unit
// [KnfOpt]     let _11393: Tuple([Int, Int]) = Apply(over50.100, [_11392, ])
// [KnfOpt]     let (ok.11394: Var({val: Some(Int)}), val.11395: Var({val: Some(Int)})) = _11393
// [KnfOpt]     let _11396: Int = Int(0)
// [KnfOpt]     if (ok.11394 == _11396) then {
// [KnfOpt]       let _11397: Int = Int(0)
// [KnfOpt]       let _11398: Int = Int(0)
// [KnfOpt]       Tuple([_11397, _11398, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.11399: Int = Apply(_102, [val.11395, ])
// [KnfOpt]       let _11400: Int = Int(0)
// [KnfOpt]       if (r.11399 == _11400) then {
// [KnfOpt]         let _11401: Int = Int(1)
// [KnfOpt]         Tuple([_11401, val.11395, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _11402: Unit = Unit
// [KnfOpt]         Jump(aux.11390, [_11402, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.11390, [u.11389, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.11388)
// [KnfOpt] let rec add.11403: Int = (x.11404: Int, y.11405: Int) {
// [KnfOpt]   Add(x.11404, y.11405)
// [KnfOpt] }
// [KnfOpt] let _11406: Int = Int(0)
// [KnfOpt] let join fold.11407: Int = (stream.11408: Fun([Unit], Tuple([Int, Int])), f.11409: Fun([Int, Int], Int), acc.11410: Int) {
// [KnfOpt]   let _11411: Unit = Unit
// [KnfOpt]   let _11412: Tuple([Int, Int]) = Apply(stream.11408, [_11411, ])
// [KnfOpt]   let (ok.11413: Var({val: Some(Int)}), val.11414: Var({val: Some(Int)})) = _11412
// [KnfOpt]   let _11415: Int = Int(0)
// [KnfOpt]   if (ok.11413 == _11415) then {
// [KnfOpt]     let sum.104: Int = Var(acc.11410)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _11416: Int = Apply(f.11409, [acc.11410, val.11414, ])
// [KnfOpt]     Jump(fold.11407, [stream.11408, f.11409, _11416, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.11407, [under1200.103, add.11403, _11406, ])
// [KnfOpt] Inline threshold 5
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 0
// [KnfOpt] Inline decision le.83 accepted
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.11432: Int = (x.11433: Int, y.11434: Int) {
// [KnfOpt]   Add(x.11433, y.11434)
// [KnfOpt] }
// [KnfOpt] let _11435: Int = Int(0)
// [KnfOpt] let join fold.11436: Int = (stream.11437: Fun([Unit], Tuple([Int, Int])), f.11438: Fun([Int, Int], Int), acc.11439: Int) {
// [KnfOpt]   let _11440: Unit = Unit
// [KnfOpt]   let _11441: Tuple([Int, Int]) = Apply(stream.11437, [_11440, ])
// [KnfOpt]   let (ok.11442: Var({val: Some(Int)}), val.11443: Var({val: Some(Int)})) = _11441
// [KnfOpt]   let _11444: Int = Int(0)
// [KnfOpt]   if (ok.11442 == _11444) then {
// [KnfOpt]     let sum.104: Int = Var(acc.11439)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _11445: Int = Apply(f.11438, [acc.11439, val.11443, ])
// [KnfOpt]     Jump(fold.11436, [stream.11437, f.11438, _11445, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.11436, [under1200.103, add.11432, _11435, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(le) let _102: Fun([Int], Int) = Unit
// [KnfOpt] let rec aux.11446: Tuple([Int, Int]) = (u.11447: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.11448: Tuple([Int, Int]) = (u.11449: Var({val: Some(Unit)})) {
// [KnfOpt]     let _11450: Unit = Unit
// [KnfOpt]     let _11451: Tuple([Int, Int]) = Apply(over50.100, [_11450, ])
// [KnfOpt]     let (ok.11452: Var({val: Some(Int)}), val.11453: Var({val: Some(Int)})) = _11451
// [KnfOpt]     let _11454: Int = Int(0)
// [KnfOpt]     if (ok.11452 == _11454) then {
// [KnfOpt]       let _11455: Int = Int(0)
// [KnfOpt]       let _11456: Int = Int(0)
// [KnfOpt]       Tuple([_11455, _11456, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.11457: Int = Apply(_102, [val.11453, ])
// [KnfOpt]       let _11458: Int = Int(0)
// [KnfOpt]       if (r.11457 == _11458) then {
// [KnfOpt]         let _11459: Int = Int(1)
// [KnfOpt]         Tuple([_11459, val.11453, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _11460: Unit = Unit
// [KnfOpt]         Jump(aux.11448, [_11460, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.11448, [u.11447, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.11446)
// [KnfOpt] let rec add.11461: Int = (x.11462: Int, y.11463: Int) {
// [KnfOpt]   Add(x.11462, y.11463)
// [KnfOpt] }
// [KnfOpt] let _11464: Int = Int(0)
// [KnfOpt] let join fold.11465: Int = (stream.11466: Fun([Unit], Tuple([Int, Int])), f.11467: Fun([Int, Int], Int), acc.11468: Int) {
// [KnfOpt]   let _11469: Unit = Unit
// [KnfOpt]   let _11470: Tuple([Int, Int]) = Apply(stream.11466, [_11469, ])
// [KnfOpt]   let (ok.11471: Var({val: Some(Int)}), val.11472: Var({val: Some(Int)})) = _11470
// [KnfOpt]   let _11473: Int = Int(0)
// [KnfOpt]   if (ok.11471 == _11473) then {
// [KnfOpt]     let sum.104: Int = Var(acc.11468)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _11474: Int = Apply(f.11467, [acc.11468, val.11472, ])
// [KnfOpt]     Jump(fold.11465, [stream.11466, f.11467, _11474, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.11465, [under1200.103, add.11461, _11464, ])
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.11477: Int = (x.11478: Int, y.11479: Int) {
// [KnfOpt]   Add(x.11478, y.11479)
// [KnfOpt] }
// [KnfOpt] let _11480: Int = Int(0)
// [KnfOpt] let join fold.11481: Int = (stream.11482: Fun([Unit], Tuple([Int, Int])), f.11483: Fun([Int, Int], Int), acc.11484: Int) {
// [KnfOpt]   let _11485: Unit = Unit
// [KnfOpt]   let _11486: Tuple([Int, Int]) = Apply(stream.11482, [_11485, ])
// [KnfOpt]   let (ok.11487: Var({val: Some(Int)}), val.11488: Var({val: Some(Int)})) = _11486
// [KnfOpt]   let _11489: Int = Int(0)
// [KnfOpt]   if (ok.11487 == _11489) then {
// [KnfOpt]     let sum.104: Int = Var(acc.11484)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _11490: Int = Apply(f.11483, [acc.11484, val.11488, ])
// [KnfOpt]     Jump(fold.11481, [stream.11482, f.11483, _11490, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.11481, [under1200.103, add.11477, _11480, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(map) let addone.97: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let _98: Int = Int(50)
// [KnfOpt] let rec aux.11327: Int = (y.11328: Int) {
// [KnfOpt]   if (_98 <= y.11328) then {
// [KnfOpt]     Int(0)
// [KnfOpt]   } else {
// [KnfOpt]     Int(1)
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] let _99: Fun([Int], Int) = Var(aux.11327)
// [KnfOpt] let rec aux.11417: Tuple([Int, Int]) = (u.11418: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.11419: Tuple([Int, Int]) = (u.11420: Var({val: Some(Unit)})) {
// [KnfOpt]     let _11421: Unit = Unit
// [KnfOpt]     let _11422: Tuple([Int, Int]) = Apply(addone.97, [_11421, ])
// [KnfOpt]     let (ok.11423: Var({val: Some(Int)}), val.11424: Var({val: Some(Int)})) = _11422
// [KnfOpt]     let _11425: Int = Int(0)
// [KnfOpt]     if (ok.11423 == _11425) then {
// [KnfOpt]       let _11426: Int = Int(0)
// [KnfOpt]       let _11427: Int = Int(0)
// [KnfOpt]       Tuple([_11426, _11427, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.11428: Int = Apply(_99, [val.11424, ])
// [KnfOpt]       let _11429: Int = Int(0)
// [KnfOpt]       if (r.11428 == _11429) then {
// [KnfOpt]         let _11430: Int = Int(1)
// [KnfOpt]         Tuple([_11430, val.11424, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _11431: Unit = Unit
// [KnfOpt]         Jump(aux.11419, [_11431, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.11419, [u.11418, ])
// [KnfOpt] }
// [KnfOpt] let over50.100: Fun([Unit], Tuple([Int, Int])) = Var(aux.11417)
// [KnfOpt] let _101: Int = Int(1200)
// [KnfOpt] let rec aux.11475: Int = (y.11476: Int) {
// [KnfOpt]   if (y.11476 <= _101) then {
// [KnfOpt]     Int(0)
// [KnfOpt]   } else {
// [KnfOpt]     Int(1)
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] let _102: Fun([Int], Int) = Var(aux.11475)
// [KnfOpt] let rec aux.11491: Tuple([Int, Int]) = (u.11492: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.11493: Tuple([Int, Int]) = (u.11494: Var({val: Some(Unit)})) {
// [KnfOpt]     let _11495: Unit = Unit
// [KnfOpt]     let _11496: Tuple([Int, Int]) = Apply(over50.100, [_11495, ])
// [KnfOpt]     let (ok.11497: Var({val: Some(Int)}), val.11498: Var({val: Some(Int)})) = _11496
// [KnfOpt]     let _11499: Int = Int(0)
// [KnfOpt]     if (ok.11497 == _11499) then {
// [KnfOpt]       let _11500: Int = Int(0)
// [KnfOpt]       let _11501: Int = Int(0)
// [KnfOpt]       Tuple([_11500, _11501, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.11502: Int = Apply(_102, [val.11498, ])
// [KnfOpt]       let _11503: Int = Int(0)
// [KnfOpt]       if (r.11502 == _11503) then {
// [KnfOpt]         let _11504: Int = Int(1)
// [KnfOpt]         Tuple([_11504, val.11498, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _11505: Unit = Unit
// [KnfOpt]         Jump(aux.11493, [_11505, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.11493, [u.11492, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.11491)
// [KnfOpt] let rec add.11506: Int = (x.11507: Int, y.11508: Int) {
// [KnfOpt]   Add(x.11507, y.11508)
// [KnfOpt] }
// [KnfOpt] let _11509: Int = Int(0)
// [KnfOpt] let join fold.11510: Int = (stream.11511: Fun([Unit], Tuple([Int, Int])), f.11512: Fun([Int, Int], Int), acc.11513: Int) {
// [KnfOpt]   let _11514: Unit = Unit
// [KnfOpt]   let _11515: Tuple([Int, Int]) = Apply(stream.11511, [_11514, ])
// [KnfOpt]   let (ok.11516: Var({val: Some(Int)}), val.11517: Var({val: Some(Int)})) = _11515
// [KnfOpt]   let _11518: Int = Int(0)
// [KnfOpt]   if (ok.11516 == _11518) then {
// [KnfOpt]     let sum.104: Int = Var(acc.11513)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _11519: Int = Apply(f.11512, [acc.11513, val.11517, ])
// [KnfOpt]     Jump(fold.11510, [stream.11511, f.11512, _11519, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.11510, [under1200.103, add.11506, _11509, ])
// [KnfOpt] Inline threshold 5
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 0
// [KnfOpt] Inline decision gt.79 accepted
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 5
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 0
// [KnfOpt] Inline decision le.83 accepted
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.11531: Int = (x.11532: Int, y.11533: Int) {
// [KnfOpt]   Add(x.11532, y.11533)
// [KnfOpt] }
// [KnfOpt] let _11534: Int = Int(0)
// [KnfOpt] let join fold.11535: Int = (stream.11536: Fun([Unit], Tuple([Int, Int])), f.11537: Fun([Int, Int], Int), acc.11538: Int) {
// [KnfOpt]   let _11539: Unit = Unit
// [KnfOpt]   let _11540: Tuple([Int, Int]) = Apply(stream.11536, [_11539, ])
// [KnfOpt]   let (ok.11541: Var({val: Some(Int)}), val.11542: Var({val: Some(Int)})) = _11540
// [KnfOpt]   let _11543: Int = Int(0)
// [KnfOpt]   if (ok.11541 == _11543) then {
// [KnfOpt]     let sum.104: Int = Var(acc.11538)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _11544: Int = Apply(f.11537, [acc.11538, val.11542, ])
// [KnfOpt]     Jump(fold.11535, [stream.11536, f.11537, _11544, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.11535, [under1200.103, add.11531, _11534, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(le) let _102: Fun([Int], Int) = Unit
// [KnfOpt] let rec aux.11545: Tuple([Int, Int]) = (u.11546: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.11547: Tuple([Int, Int]) = (u.11548: Var({val: Some(Unit)})) {
// [KnfOpt]     let _11549: Unit = Unit
// [KnfOpt]     let _11550: Tuple([Int, Int]) = Apply(over50.100, [_11549, ])
// [KnfOpt]     let (ok.11551: Var({val: Some(Int)}), val.11552: Var({val: Some(Int)})) = _11550
// [KnfOpt]     let _11553: Int = Int(0)
// [KnfOpt]     if (ok.11551 == _11553) then {
// [KnfOpt]       let _11554: Int = Int(0)
// [KnfOpt]       let _11555: Int = Int(0)
// [KnfOpt]       Tuple([_11554, _11555, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.11556: Int = Apply(_102, [val.11552, ])
// [KnfOpt]       let _11557: Int = Int(0)
// [KnfOpt]       if (r.11556 == _11557) then {
// [KnfOpt]         let _11558: Int = Int(1)
// [KnfOpt]         Tuple([_11558, val.11552, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _11559: Unit = Unit
// [KnfOpt]         Jump(aux.11547, [_11559, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.11547, [u.11546, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.11545)
// [KnfOpt] let rec add.11560: Int = (x.11561: Int, y.11562: Int) {
// [KnfOpt]   Add(x.11561, y.11562)
// [KnfOpt] }
// [KnfOpt] let _11563: Int = Int(0)
// [KnfOpt] let join fold.11564: Int = (stream.11565: Fun([Unit], Tuple([Int, Int])), f.11566: Fun([Int, Int], Int), acc.11567: Int) {
// [KnfOpt]   let _11568: Unit = Unit
// [KnfOpt]   let _11569: Tuple([Int, Int]) = Apply(stream.11565, [_11568, ])
// [KnfOpt]   let (ok.11570: Var({val: Some(Int)}), val.11571: Var({val: Some(Int)})) = _11569
// [KnfOpt]   let _11572: Int = Int(0)
// [KnfOpt]   if (ok.11570 == _11572) then {
// [KnfOpt]     let sum.104: Int = Var(acc.11567)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _11573: Int = Apply(f.11566, [acc.11567, val.11571, ])
// [KnfOpt]     Jump(fold.11564, [stream.11565, f.11566, _11573, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.11564, [under1200.103, add.11560, _11563, ])
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.11576: Int = (x.11577: Int, y.11578: Int) {
// [KnfOpt]   Add(x.11577, y.11578)
// [KnfOpt] }
// [KnfOpt] let _11579: Int = Int(0)
// [KnfOpt] let join fold.11580: Int = (stream.11581: Fun([Unit], Tuple([Int, Int])), f.11582: Fun([Int, Int], Int), acc.11583: Int) {
// [KnfOpt]   let _11584: Unit = Unit
// [KnfOpt]   let _11585: Tuple([Int, Int]) = Apply(stream.11581, [_11584, ])
// [KnfOpt]   let (ok.11586: Var({val: Some(Int)}), val.11587: Var({val: Some(Int)})) = _11585
// [KnfOpt]   let _11588: Int = Int(0)
// [KnfOpt]   if (ok.11586 == _11588) then {
// [KnfOpt]     let sum.104: Int = Var(acc.11583)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _11589: Int = Apply(f.11582, [acc.11583, val.11587, ])
// [KnfOpt]     Jump(fold.11580, [stream.11581, f.11582, _11589, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.11580, [under1200.103, add.11576, _11579, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let over50.100: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let _101: Int = Int(1200)
// [KnfOpt] let rec aux.11574: Int = (y.11575: Int) {
// [KnfOpt]   if (y.11575 <= _101) then {
// [KnfOpt]     Int(0)
// [KnfOpt]   } else {
// [KnfOpt]     Int(1)
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] let _102: Fun([Int], Int) = Var(aux.11574)
// [KnfOpt] let rec aux.11590: Tuple([Int, Int]) = (u.11591: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.11592: Tuple([Int, Int]) = (u.11593: Var({val: Some(Unit)})) {
// [KnfOpt]     let _11594: Unit = Unit
// [KnfOpt]     let _11595: Tuple([Int, Int]) = Apply(over50.100, [_11594, ])
// [KnfOpt]     let (ok.11596: Var({val: Some(Int)}), val.11597: Var({val: Some(Int)})) = _11595
// [KnfOpt]     let _11598: Int = Int(0)
// [KnfOpt]     if (ok.11596 == _11598) then {
// [KnfOpt]       let _11599: Int = Int(0)
// [KnfOpt]       let _11600: Int = Int(0)
// [KnfOpt]       Tuple([_11599, _11600, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.11601: Int = Apply(_102, [val.11597, ])
// [KnfOpt]       let _11602: Int = Int(0)
// [KnfOpt]       if (r.11601 == _11602) then {
// [KnfOpt]         let _11603: Int = Int(1)
// [KnfOpt]         Tuple([_11603, val.11597, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _11604: Unit = Unit
// [KnfOpt]         Jump(aux.11592, [_11604, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.11592, [u.11591, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.11590)
// [KnfOpt] let rec add.11605: Int = (x.11606: Int, y.11607: Int) {
// [KnfOpt]   Add(x.11606, y.11607)
// [KnfOpt] }
// [KnfOpt] let _11608: Int = Int(0)
// [KnfOpt] let join fold.11609: Int = (stream.11610: Fun([Unit], Tuple([Int, Int])), f.11611: Fun([Int, Int], Int), acc.11612: Int) {
// [KnfOpt]   let _11613: Unit = Unit
// [KnfOpt]   let _11614: Tuple([Int, Int]) = Apply(stream.11610, [_11613, ])
// [KnfOpt]   let (ok.11615: Var({val: Some(Int)}), val.11616: Var({val: Some(Int)})) = _11614
// [KnfOpt]   let _11617: Int = Int(0)
// [KnfOpt]   if (ok.11615 == _11617) then {
// [KnfOpt]     let sum.104: Int = Var(acc.11612)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _11618: Int = Apply(f.11611, [acc.11612, val.11616, ])
// [KnfOpt]     Jump(fold.11609, [stream.11610, f.11611, _11618, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.11609, [under1200.103, add.11605, _11608, ])
// [KnfOpt] Inline threshold 5
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 0
// [KnfOpt] Inline decision le.83 accepted
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.11634: Int = (x.11635: Int, y.11636: Int) {
// [KnfOpt]   Add(x.11635, y.11636)
// [KnfOpt] }
// [KnfOpt] let _11637: Int = Int(0)
// [KnfOpt] let join fold.11638: Int = (stream.11639: Fun([Unit], Tuple([Int, Int])), f.11640: Fun([Int, Int], Int), acc.11641: Int) {
// [KnfOpt]   let _11642: Unit = Unit
// [KnfOpt]   let _11643: Tuple([Int, Int]) = Apply(stream.11639, [_11642, ])
// [KnfOpt]   let (ok.11644: Var({val: Some(Int)}), val.11645: Var({val: Some(Int)})) = _11643
// [KnfOpt]   let _11646: Int = Int(0)
// [KnfOpt]   if (ok.11644 == _11646) then {
// [KnfOpt]     let sum.104: Int = Var(acc.11641)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _11647: Int = Apply(f.11640, [acc.11641, val.11645, ])
// [KnfOpt]     Jump(fold.11638, [stream.11639, f.11640, _11647, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.11638, [under1200.103, add.11634, _11637, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(le) let _102: Fun([Int], Int) = Unit
// [KnfOpt] let rec aux.11648: Tuple([Int, Int]) = (u.11649: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.11650: Tuple([Int, Int]) = (u.11651: Var({val: Some(Unit)})) {
// [KnfOpt]     let _11652: Unit = Unit
// [KnfOpt]     let _11653: Tuple([Int, Int]) = Apply(over50.100, [_11652, ])
// [KnfOpt]     let (ok.11654: Var({val: Some(Int)}), val.11655: Var({val: Some(Int)})) = _11653
// [KnfOpt]     let _11656: Int = Int(0)
// [KnfOpt]     if (ok.11654 == _11656) then {
// [KnfOpt]       let _11657: Int = Int(0)
// [KnfOpt]       let _11658: Int = Int(0)
// [KnfOpt]       Tuple([_11657, _11658, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.11659: Int = Apply(_102, [val.11655, ])
// [KnfOpt]       let _11660: Int = Int(0)
// [KnfOpt]       if (r.11659 == _11660) then {
// [KnfOpt]         let _11661: Int = Int(1)
// [KnfOpt]         Tuple([_11661, val.11655, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _11662: Unit = Unit
// [KnfOpt]         Jump(aux.11650, [_11662, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.11650, [u.11649, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.11648)
// [KnfOpt] let rec add.11663: Int = (x.11664: Int, y.11665: Int) {
// [KnfOpt]   Add(x.11664, y.11665)
// [KnfOpt] }
// [KnfOpt] let _11666: Int = Int(0)
// [KnfOpt] let join fold.11667: Int = (stream.11668: Fun([Unit], Tuple([Int, Int])), f.11669: Fun([Int, Int], Int), acc.11670: Int) {
// [KnfOpt]   let _11671: Unit = Unit
// [KnfOpt]   let _11672: Tuple([Int, Int]) = Apply(stream.11668, [_11671, ])
// [KnfOpt]   let (ok.11673: Var({val: Some(Int)}), val.11674: Var({val: Some(Int)})) = _11672
// [KnfOpt]   let _11675: Int = Int(0)
// [KnfOpt]   if (ok.11673 == _11675) then {
// [KnfOpt]     let sum.104: Int = Var(acc.11670)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _11676: Int = Apply(f.11669, [acc.11670, val.11674, ])
// [KnfOpt]     Jump(fold.11667, [stream.11668, f.11669, _11676, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.11667, [under1200.103, add.11663, _11666, ])
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.11679: Int = (x.11680: Int, y.11681: Int) {
// [KnfOpt]   Add(x.11680, y.11681)
// [KnfOpt] }
// [KnfOpt] let _11682: Int = Int(0)
// [KnfOpt] let join fold.11683: Int = (stream.11684: Fun([Unit], Tuple([Int, Int])), f.11685: Fun([Int, Int], Int), acc.11686: Int) {
// [KnfOpt]   let _11687: Unit = Unit
// [KnfOpt]   let _11688: Tuple([Int, Int]) = Apply(stream.11684, [_11687, ])
// [KnfOpt]   let (ok.11689: Var({val: Some(Int)}), val.11690: Var({val: Some(Int)})) = _11688
// [KnfOpt]   let _11691: Int = Int(0)
// [KnfOpt]   if (ok.11689 == _11691) then {
// [KnfOpt]     let sum.104: Int = Var(acc.11686)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _11692: Int = Apply(f.11685, [acc.11686, val.11690, ])
// [KnfOpt]     Jump(fold.11683, [stream.11684, f.11685, _11692, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.11683, [under1200.103, add.11679, _11682, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(gt) let _99: Fun([Int], Int) = Unit
// [KnfOpt] let rec aux.11619: Tuple([Int, Int]) = (u.11620: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.11621: Tuple([Int, Int]) = (u.11622: Var({val: Some(Unit)})) {
// [KnfOpt]     let _11623: Unit = Unit
// [KnfOpt]     let _11624: Tuple([Int, Int]) = Apply(addone.97, [_11623, ])
// [KnfOpt]     let (ok.11625: Var({val: Some(Int)}), val.11626: Var({val: Some(Int)})) = _11624
// [KnfOpt]     let _11627: Int = Int(0)
// [KnfOpt]     if (ok.11625 == _11627) then {
// [KnfOpt]       let _11628: Int = Int(0)
// [KnfOpt]       let _11629: Int = Int(0)
// [KnfOpt]       Tuple([_11628, _11629, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.11630: Int = Apply(_99, [val.11626, ])
// [KnfOpt]       let _11631: Int = Int(0)
// [KnfOpt]       if (r.11630 == _11631) then {
// [KnfOpt]         let _11632: Int = Int(1)
// [KnfOpt]         Tuple([_11632, val.11626, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _11633: Unit = Unit
// [KnfOpt]         Jump(aux.11621, [_11633, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.11621, [u.11620, ])
// [KnfOpt] }
// [KnfOpt] let over50.100: Fun([Unit], Tuple([Int, Int])) = Var(aux.11619)
// [KnfOpt] let _101: Int = Int(1200)
// [KnfOpt] let rec aux.11677: Int = (y.11678: Int) {
// [KnfOpt]   if (y.11678 <= _101) then {
// [KnfOpt]     Int(0)
// [KnfOpt]   } else {
// [KnfOpt]     Int(1)
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] let _102: Fun([Int], Int) = Var(aux.11677)
// [KnfOpt] let rec aux.11693: Tuple([Int, Int]) = (u.11694: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.11695: Tuple([Int, Int]) = (u.11696: Var({val: Some(Unit)})) {
// [KnfOpt]     let _11697: Unit = Unit
// [KnfOpt]     let _11698: Tuple([Int, Int]) = Apply(over50.100, [_11697, ])
// [KnfOpt]     let (ok.11699: Var({val: Some(Int)}), val.11700: Var({val: Some(Int)})) = _11698
// [KnfOpt]     let _11701: Int = Int(0)
// [KnfOpt]     if (ok.11699 == _11701) then {
// [KnfOpt]       let _11702: Int = Int(0)
// [KnfOpt]       let _11703: Int = Int(0)
// [KnfOpt]       Tuple([_11702, _11703, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.11704: Int = Apply(_102, [val.11700, ])
// [KnfOpt]       let _11705: Int = Int(0)
// [KnfOpt]       if (r.11704 == _11705) then {
// [KnfOpt]         let _11706: Int = Int(1)
// [KnfOpt]         Tuple([_11706, val.11700, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _11707: Unit = Unit
// [KnfOpt]         Jump(aux.11695, [_11707, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.11695, [u.11694, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.11693)
// [KnfOpt] let rec add.11708: Int = (x.11709: Int, y.11710: Int) {
// [KnfOpt]   Add(x.11709, y.11710)
// [KnfOpt] }
// [KnfOpt] let _11711: Int = Int(0)
// [KnfOpt] let join fold.11712: Int = (stream.11713: Fun([Unit], Tuple([Int, Int])), f.11714: Fun([Int, Int], Int), acc.11715: Int) {
// [KnfOpt]   let _11716: Unit = Unit
// [KnfOpt]   let _11717: Tuple([Int, Int]) = Apply(stream.11713, [_11716, ])
// [KnfOpt]   let (ok.11718: Var({val: Some(Int)}), val.11719: Var({val: Some(Int)})) = _11717
// [KnfOpt]   let _11720: Int = Int(0)
// [KnfOpt]   if (ok.11718 == _11720) then {
// [KnfOpt]     let sum.104: Int = Var(acc.11715)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _11721: Int = Apply(f.11714, [acc.11715, val.11719, ])
// [KnfOpt]     Jump(fold.11712, [stream.11713, f.11714, _11721, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.11712, [under1200.103, add.11708, _11711, ])
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 5
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 0
// [KnfOpt] Inline decision le.83 accepted
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.11724: Int = (x.11725: Int, y.11726: Int) {
// [KnfOpt]   Add(x.11725, y.11726)
// [KnfOpt] }
// [KnfOpt] let _11727: Int = Int(0)
// [KnfOpt] let join fold.11728: Int = (stream.11729: Fun([Unit], Tuple([Int, Int])), f.11730: Fun([Int, Int], Int), acc.11731: Int) {
// [KnfOpt]   let _11732: Unit = Unit
// [KnfOpt]   let _11733: Tuple([Int, Int]) = Apply(stream.11729, [_11732, ])
// [KnfOpt]   let (ok.11734: Var({val: Some(Int)}), val.11735: Var({val: Some(Int)})) = _11733
// [KnfOpt]   let _11736: Int = Int(0)
// [KnfOpt]   if (ok.11734 == _11736) then {
// [KnfOpt]     let sum.104: Int = Var(acc.11731)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _11737: Int = Apply(f.11730, [acc.11731, val.11735, ])
// [KnfOpt]     Jump(fold.11728, [stream.11729, f.11730, _11737, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.11728, [under1200.103, add.11724, _11727, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(le) let _102: Fun([Int], Int) = Unit
// [KnfOpt] let rec aux.11738: Tuple([Int, Int]) = (u.11739: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.11740: Tuple([Int, Int]) = (u.11741: Var({val: Some(Unit)})) {
// [KnfOpt]     let _11742: Unit = Unit
// [KnfOpt]     let _11743: Tuple([Int, Int]) = Apply(over50.100, [_11742, ])
// [KnfOpt]     let (ok.11744: Var({val: Some(Int)}), val.11745: Var({val: Some(Int)})) = _11743
// [KnfOpt]     let _11746: Int = Int(0)
// [KnfOpt]     if (ok.11744 == _11746) then {
// [KnfOpt]       let _11747: Int = Int(0)
// [KnfOpt]       let _11748: Int = Int(0)
// [KnfOpt]       Tuple([_11747, _11748, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.11749: Int = Apply(_102, [val.11745, ])
// [KnfOpt]       let _11750: Int = Int(0)
// [KnfOpt]       if (r.11749 == _11750) then {
// [KnfOpt]         let _11751: Int = Int(1)
// [KnfOpt]         Tuple([_11751, val.11745, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _11752: Unit = Unit
// [KnfOpt]         Jump(aux.11740, [_11752, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.11740, [u.11739, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.11738)
// [KnfOpt] let rec add.11753: Int = (x.11754: Int, y.11755: Int) {
// [KnfOpt]   Add(x.11754, y.11755)
// [KnfOpt] }
// [KnfOpt] let _11756: Int = Int(0)
// [KnfOpt] let join fold.11757: Int = (stream.11758: Fun([Unit], Tuple([Int, Int])), f.11759: Fun([Int, Int], Int), acc.11760: Int) {
// [KnfOpt]   let _11761: Unit = Unit
// [KnfOpt]   let _11762: Tuple([Int, Int]) = Apply(stream.11758, [_11761, ])
// [KnfOpt]   let (ok.11763: Var({val: Some(Int)}), val.11764: Var({val: Some(Int)})) = _11762
// [KnfOpt]   let _11765: Int = Int(0)
// [KnfOpt]   if (ok.11763 == _11765) then {
// [KnfOpt]     let sum.104: Int = Var(acc.11760)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _11766: Int = Apply(f.11759, [acc.11760, val.11764, ])
// [KnfOpt]     Jump(fold.11757, [stream.11758, f.11759, _11766, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.11757, [under1200.103, add.11753, _11756, ])
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.11769: Int = (x.11770: Int, y.11771: Int) {
// [KnfOpt]   Add(x.11770, y.11771)
// [KnfOpt] }
// [KnfOpt] let _11772: Int = Int(0)
// [KnfOpt] let join fold.11773: Int = (stream.11774: Fun([Unit], Tuple([Int, Int])), f.11775: Fun([Int, Int], Int), acc.11776: Int) {
// [KnfOpt]   let _11777: Unit = Unit
// [KnfOpt]   let _11778: Tuple([Int, Int]) = Apply(stream.11774, [_11777, ])
// [KnfOpt]   let (ok.11779: Var({val: Some(Int)}), val.11780: Var({val: Some(Int)})) = _11778
// [KnfOpt]   let _11781: Int = Int(0)
// [KnfOpt]   if (ok.11779 == _11781) then {
// [KnfOpt]     let sum.104: Int = Var(acc.11776)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _11782: Int = Apply(f.11775, [acc.11776, val.11780, ])
// [KnfOpt]     Jump(fold.11773, [stream.11774, f.11775, _11782, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.11773, [under1200.103, add.11769, _11772, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let over50.100: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let _101: Int = Int(1200)
// [KnfOpt] let rec aux.11767: Int = (y.11768: Int) {
// [KnfOpt]   if (y.11768 <= _101) then {
// [KnfOpt]     Int(0)
// [KnfOpt]   } else {
// [KnfOpt]     Int(1)
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] let _102: Fun([Int], Int) = Var(aux.11767)
// [KnfOpt] let rec aux.11783: Tuple([Int, Int]) = (u.11784: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.11785: Tuple([Int, Int]) = (u.11786: Var({val: Some(Unit)})) {
// [KnfOpt]     let _11787: Unit = Unit
// [KnfOpt]     let _11788: Tuple([Int, Int]) = Apply(over50.100, [_11787, ])
// [KnfOpt]     let (ok.11789: Var({val: Some(Int)}), val.11790: Var({val: Some(Int)})) = _11788
// [KnfOpt]     let _11791: Int = Int(0)
// [KnfOpt]     if (ok.11789 == _11791) then {
// [KnfOpt]       let _11792: Int = Int(0)
// [KnfOpt]       let _11793: Int = Int(0)
// [KnfOpt]       Tuple([_11792, _11793, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.11794: Int = Apply(_102, [val.11790, ])
// [KnfOpt]       let _11795: Int = Int(0)
// [KnfOpt]       if (r.11794 == _11795) then {
// [KnfOpt]         let _11796: Int = Int(1)
// [KnfOpt]         Tuple([_11796, val.11790, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _11797: Unit = Unit
// [KnfOpt]         Jump(aux.11785, [_11797, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.11785, [u.11784, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.11783)
// [KnfOpt] let rec add.11798: Int = (x.11799: Int, y.11800: Int) {
// [KnfOpt]   Add(x.11799, y.11800)
// [KnfOpt] }
// [KnfOpt] let _11801: Int = Int(0)
// [KnfOpt] let join fold.11802: Int = (stream.11803: Fun([Unit], Tuple([Int, Int])), f.11804: Fun([Int, Int], Int), acc.11805: Int) {
// [KnfOpt]   let _11806: Unit = Unit
// [KnfOpt]   let _11807: Tuple([Int, Int]) = Apply(stream.11803, [_11806, ])
// [KnfOpt]   let (ok.11808: Var({val: Some(Int)}), val.11809: Var({val: Some(Int)})) = _11807
// [KnfOpt]   let _11810: Int = Int(0)
// [KnfOpt]   if (ok.11808 == _11810) then {
// [KnfOpt]     let sum.104: Int = Var(acc.11805)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _11811: Int = Apply(f.11804, [acc.11805, val.11809, ])
// [KnfOpt]     Jump(fold.11802, [stream.11803, f.11804, _11811, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.11802, [under1200.103, add.11798, _11801, ])
// [KnfOpt] Inline threshold 5
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 0
// [KnfOpt] Inline decision le.83 accepted
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.11827: Int = (x.11828: Int, y.11829: Int) {
// [KnfOpt]   Add(x.11828, y.11829)
// [KnfOpt] }
// [KnfOpt] let _11830: Int = Int(0)
// [KnfOpt] let join fold.11831: Int = (stream.11832: Fun([Unit], Tuple([Int, Int])), f.11833: Fun([Int, Int], Int), acc.11834: Int) {
// [KnfOpt]   let _11835: Unit = Unit
// [KnfOpt]   let _11836: Tuple([Int, Int]) = Apply(stream.11832, [_11835, ])
// [KnfOpt]   let (ok.11837: Var({val: Some(Int)}), val.11838: Var({val: Some(Int)})) = _11836
// [KnfOpt]   let _11839: Int = Int(0)
// [KnfOpt]   if (ok.11837 == _11839) then {
// [KnfOpt]     let sum.104: Int = Var(acc.11834)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _11840: Int = Apply(f.11833, [acc.11834, val.11838, ])
// [KnfOpt]     Jump(fold.11831, [stream.11832, f.11833, _11840, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.11831, [under1200.103, add.11827, _11830, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(le) let _102: Fun([Int], Int) = Unit
// [KnfOpt] let rec aux.11841: Tuple([Int, Int]) = (u.11842: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.11843: Tuple([Int, Int]) = (u.11844: Var({val: Some(Unit)})) {
// [KnfOpt]     let _11845: Unit = Unit
// [KnfOpt]     let _11846: Tuple([Int, Int]) = Apply(over50.100, [_11845, ])
// [KnfOpt]     let (ok.11847: Var({val: Some(Int)}), val.11848: Var({val: Some(Int)})) = _11846
// [KnfOpt]     let _11849: Int = Int(0)
// [KnfOpt]     if (ok.11847 == _11849) then {
// [KnfOpt]       let _11850: Int = Int(0)
// [KnfOpt]       let _11851: Int = Int(0)
// [KnfOpt]       Tuple([_11850, _11851, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.11852: Int = Apply(_102, [val.11848, ])
// [KnfOpt]       let _11853: Int = Int(0)
// [KnfOpt]       if (r.11852 == _11853) then {
// [KnfOpt]         let _11854: Int = Int(1)
// [KnfOpt]         Tuple([_11854, val.11848, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _11855: Unit = Unit
// [KnfOpt]         Jump(aux.11843, [_11855, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.11843, [u.11842, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.11841)
// [KnfOpt] let rec add.11856: Int = (x.11857: Int, y.11858: Int) {
// [KnfOpt]   Add(x.11857, y.11858)
// [KnfOpt] }
// [KnfOpt] let _11859: Int = Int(0)
// [KnfOpt] let join fold.11860: Int = (stream.11861: Fun([Unit], Tuple([Int, Int])), f.11862: Fun([Int, Int], Int), acc.11863: Int) {
// [KnfOpt]   let _11864: Unit = Unit
// [KnfOpt]   let _11865: Tuple([Int, Int]) = Apply(stream.11861, [_11864, ])
// [KnfOpt]   let (ok.11866: Var({val: Some(Int)}), val.11867: Var({val: Some(Int)})) = _11865
// [KnfOpt]   let _11868: Int = Int(0)
// [KnfOpt]   if (ok.11866 == _11868) then {
// [KnfOpt]     let sum.104: Int = Var(acc.11863)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _11869: Int = Apply(f.11862, [acc.11863, val.11867, ])
// [KnfOpt]     Jump(fold.11860, [stream.11861, f.11862, _11869, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.11860, [under1200.103, add.11856, _11859, ])
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.11872: Int = (x.11873: Int, y.11874: Int) {
// [KnfOpt]   Add(x.11873, y.11874)
// [KnfOpt] }
// [KnfOpt] let _11875: Int = Int(0)
// [KnfOpt] let join fold.11876: Int = (stream.11877: Fun([Unit], Tuple([Int, Int])), f.11878: Fun([Int, Int], Int), acc.11879: Int) {
// [KnfOpt]   let _11880: Unit = Unit
// [KnfOpt]   let _11881: Tuple([Int, Int]) = Apply(stream.11877, [_11880, ])
// [KnfOpt]   let (ok.11882: Var({val: Some(Int)}), val.11883: Var({val: Some(Int)})) = _11881
// [KnfOpt]   let _11884: Int = Int(0)
// [KnfOpt]   if (ok.11882 == _11884) then {
// [KnfOpt]     let sum.104: Int = Var(acc.11879)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _11885: Int = Apply(f.11878, [acc.11879, val.11883, ])
// [KnfOpt]     Jump(fold.11876, [stream.11877, f.11878, _11885, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.11876, [under1200.103, add.11872, _11875, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(addx) let _96: Fun([Int], Int) = Unit
// [KnfOpt] let rec aux.11520: Tuple([Int, Int]) = (u.11521: Var({val: Some(Unit)})) {
// [KnfOpt]   let _11522: Unit = Unit
// [KnfOpt]   let _11523: Tuple([Int, Int]) = Apply(catt.94, [_11522, ])
// [KnfOpt]   let (ok.11524: Var({val: Some(Int)}), val.11525: Var({val: Some(Int)})) = _11523
// [KnfOpt]   let _11526: Int = Int(0)
// [KnfOpt]   if (ok.11524 == _11526) then {
// [KnfOpt]     let _11527: Int = Int(0)
// [KnfOpt]     let _11528: Int = Int(0)
// [KnfOpt]     Tuple([_11527, _11528, ])
// [KnfOpt]   } else {
// [KnfOpt]     let _11529: Int = Int(1)
// [KnfOpt]     let _11530: Int = Apply(_96, [val.11525, ])
// [KnfOpt]     Tuple([_11529, _11530, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] let addone.97: Fun([Unit], Tuple([Int, Int])) = Var(aux.11520)
// [KnfOpt] let _98: Int = Int(50)
// [KnfOpt] let rec aux.11722: Int = (y.11723: Int) {
// [KnfOpt]   if (_98 <= y.11723) then {
// [KnfOpt]     Int(0)
// [KnfOpt]   } else {
// [KnfOpt]     Int(1)
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] let _99: Fun([Int], Int) = Var(aux.11722)
// [KnfOpt] let rec aux.11812: Tuple([Int, Int]) = (u.11813: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.11814: Tuple([Int, Int]) = (u.11815: Var({val: Some(Unit)})) {
// [KnfOpt]     let _11816: Unit = Unit
// [KnfOpt]     let _11817: Tuple([Int, Int]) = Apply(addone.97, [_11816, ])
// [KnfOpt]     let (ok.11818: Var({val: Some(Int)}), val.11819: Var({val: Some(Int)})) = _11817
// [KnfOpt]     let _11820: Int = Int(0)
// [KnfOpt]     if (ok.11818 == _11820) then {
// [KnfOpt]       let _11821: Int = Int(0)
// [KnfOpt]       let _11822: Int = Int(0)
// [KnfOpt]       Tuple([_11821, _11822, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.11823: Int = Apply(_99, [val.11819, ])
// [KnfOpt]       let _11824: Int = Int(0)
// [KnfOpt]       if (r.11823 == _11824) then {
// [KnfOpt]         let _11825: Int = Int(1)
// [KnfOpt]         Tuple([_11825, val.11819, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _11826: Unit = Unit
// [KnfOpt]         Jump(aux.11814, [_11826, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.11814, [u.11813, ])
// [KnfOpt] }
// [KnfOpt] let over50.100: Fun([Unit], Tuple([Int, Int])) = Var(aux.11812)
// [KnfOpt] let _101: Int = Int(1200)
// [KnfOpt] let rec aux.11870: Int = (y.11871: Int) {
// [KnfOpt]   if (y.11871 <= _101) then {
// [KnfOpt]     Int(0)
// [KnfOpt]   } else {
// [KnfOpt]     Int(1)
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] let _102: Fun([Int], Int) = Var(aux.11870)
// [KnfOpt] let rec aux.11886: Tuple([Int, Int]) = (u.11887: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.11888: Tuple([Int, Int]) = (u.11889: Var({val: Some(Unit)})) {
// [KnfOpt]     let _11890: Unit = Unit
// [KnfOpt]     let _11891: Tuple([Int, Int]) = Apply(over50.100, [_11890, ])
// [KnfOpt]     let (ok.11892: Var({val: Some(Int)}), val.11893: Var({val: Some(Int)})) = _11891
// [KnfOpt]     let _11894: Int = Int(0)
// [KnfOpt]     if (ok.11892 == _11894) then {
// [KnfOpt]       let _11895: Int = Int(0)
// [KnfOpt]       let _11896: Int = Int(0)
// [KnfOpt]       Tuple([_11895, _11896, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.11897: Int = Apply(_102, [val.11893, ])
// [KnfOpt]       let _11898: Int = Int(0)
// [KnfOpt]       if (r.11897 == _11898) then {
// [KnfOpt]         let _11899: Int = Int(1)
// [KnfOpt]         Tuple([_11899, val.11893, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _11900: Unit = Unit
// [KnfOpt]         Jump(aux.11888, [_11900, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.11888, [u.11887, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.11886)
// [KnfOpt] let rec add.11901: Int = (x.11902: Int, y.11903: Int) {
// [KnfOpt]   Add(x.11902, y.11903)
// [KnfOpt] }
// [KnfOpt] let _11904: Int = Int(0)
// [KnfOpt] let join fold.11905: Int = (stream.11906: Fun([Unit], Tuple([Int, Int])), f.11907: Fun([Int, Int], Int), acc.11908: Int) {
// [KnfOpt]   let _11909: Unit = Unit
// [KnfOpt]   let _11910: Tuple([Int, Int]) = Apply(stream.11906, [_11909, ])
// [KnfOpt]   let (ok.11911: Var({val: Some(Int)}), val.11912: Var({val: Some(Int)})) = _11910
// [KnfOpt]   let _11913: Int = Int(0)
// [KnfOpt]   if (ok.11911 == _11913) then {
// [KnfOpt]     let sum.104: Int = Var(acc.11908)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _11914: Int = Apply(f.11907, [acc.11908, val.11912, ])
// [KnfOpt]     Jump(fold.11905, [stream.11906, f.11907, _11914, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.11905, [under1200.103, add.11901, _11904, ])
// [KnfOpt] Inline threshold 20
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 0
// [KnfOpt] Inline decision map.1 accepted
// [KnfOpt] Inline threshold 5
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 0
// [KnfOpt] Inline decision gt.79 accepted
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 5
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 0
// [KnfOpt] Inline decision le.83 accepted
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.11917: Int = (x.11918: Int, y.11919: Int) {
// [KnfOpt]   Add(x.11918, y.11919)
// [KnfOpt] }
// [KnfOpt] let _11920: Int = Int(0)
// [KnfOpt] let join fold.11921: Int = (stream.11922: Fun([Unit], Tuple([Int, Int])), f.11923: Fun([Int, Int], Int), acc.11924: Int) {
// [KnfOpt]   let _11925: Unit = Unit
// [KnfOpt]   let _11926: Tuple([Int, Int]) = Apply(stream.11922, [_11925, ])
// [KnfOpt]   let (ok.11927: Var({val: Some(Int)}), val.11928: Var({val: Some(Int)})) = _11926
// [KnfOpt]   let _11929: Int = Int(0)
// [KnfOpt]   if (ok.11927 == _11929) then {
// [KnfOpt]     let sum.104: Int = Var(acc.11924)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _11930: Int = Apply(f.11923, [acc.11924, val.11928, ])
// [KnfOpt]     Jump(fold.11921, [stream.11922, f.11923, _11930, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.11921, [under1200.103, add.11917, _11920, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(le) let _102: Fun([Int], Int) = Unit
// [KnfOpt] let rec aux.11931: Tuple([Int, Int]) = (u.11932: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.11933: Tuple([Int, Int]) = (u.11934: Var({val: Some(Unit)})) {
// [KnfOpt]     let _11935: Unit = Unit
// [KnfOpt]     let _11936: Tuple([Int, Int]) = Apply(over50.100, [_11935, ])
// [KnfOpt]     let (ok.11937: Var({val: Some(Int)}), val.11938: Var({val: Some(Int)})) = _11936
// [KnfOpt]     let _11939: Int = Int(0)
// [KnfOpt]     if (ok.11937 == _11939) then {
// [KnfOpt]       let _11940: Int = Int(0)
// [KnfOpt]       let _11941: Int = Int(0)
// [KnfOpt]       Tuple([_11940, _11941, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.11942: Int = Apply(_102, [val.11938, ])
// [KnfOpt]       let _11943: Int = Int(0)
// [KnfOpt]       if (r.11942 == _11943) then {
// [KnfOpt]         let _11944: Int = Int(1)
// [KnfOpt]         Tuple([_11944, val.11938, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _11945: Unit = Unit
// [KnfOpt]         Jump(aux.11933, [_11945, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.11933, [u.11932, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.11931)
// [KnfOpt] let rec add.11946: Int = (x.11947: Int, y.11948: Int) {
// [KnfOpt]   Add(x.11947, y.11948)
// [KnfOpt] }
// [KnfOpt] let _11949: Int = Int(0)
// [KnfOpt] let join fold.11950: Int = (stream.11951: Fun([Unit], Tuple([Int, Int])), f.11952: Fun([Int, Int], Int), acc.11953: Int) {
// [KnfOpt]   let _11954: Unit = Unit
// [KnfOpt]   let _11955: Tuple([Int, Int]) = Apply(stream.11951, [_11954, ])
// [KnfOpt]   let (ok.11956: Var({val: Some(Int)}), val.11957: Var({val: Some(Int)})) = _11955
// [KnfOpt]   let _11958: Int = Int(0)
// [KnfOpt]   if (ok.11956 == _11958) then {
// [KnfOpt]     let sum.104: Int = Var(acc.11953)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _11959: Int = Apply(f.11952, [acc.11953, val.11957, ])
// [KnfOpt]     Jump(fold.11950, [stream.11951, f.11952, _11959, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.11950, [under1200.103, add.11946, _11949, ])
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.11962: Int = (x.11963: Int, y.11964: Int) {
// [KnfOpt]   Add(x.11963, y.11964)
// [KnfOpt] }
// [KnfOpt] let _11965: Int = Int(0)
// [KnfOpt] let join fold.11966: Int = (stream.11967: Fun([Unit], Tuple([Int, Int])), f.11968: Fun([Int, Int], Int), acc.11969: Int) {
// [KnfOpt]   let _11970: Unit = Unit
// [KnfOpt]   let _11971: Tuple([Int, Int]) = Apply(stream.11967, [_11970, ])
// [KnfOpt]   let (ok.11972: Var({val: Some(Int)}), val.11973: Var({val: Some(Int)})) = _11971
// [KnfOpt]   let _11974: Int = Int(0)
// [KnfOpt]   if (ok.11972 == _11974) then {
// [KnfOpt]     let sum.104: Int = Var(acc.11969)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _11975: Int = Apply(f.11968, [acc.11969, val.11973, ])
// [KnfOpt]     Jump(fold.11966, [stream.11967, f.11968, _11975, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.11966, [under1200.103, add.11962, _11965, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let over50.100: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let _101: Int = Int(1200)
// [KnfOpt] let rec aux.11960: Int = (y.11961: Int) {
// [KnfOpt]   if (y.11961 <= _101) then {
// [KnfOpt]     Int(0)
// [KnfOpt]   } else {
// [KnfOpt]     Int(1)
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] let _102: Fun([Int], Int) = Var(aux.11960)
// [KnfOpt] let rec aux.11976: Tuple([Int, Int]) = (u.11977: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.11978: Tuple([Int, Int]) = (u.11979: Var({val: Some(Unit)})) {
// [KnfOpt]     let _11980: Unit = Unit
// [KnfOpt]     let _11981: Tuple([Int, Int]) = Apply(over50.100, [_11980, ])
// [KnfOpt]     let (ok.11982: Var({val: Some(Int)}), val.11983: Var({val: Some(Int)})) = _11981
// [KnfOpt]     let _11984: Int = Int(0)
// [KnfOpt]     if (ok.11982 == _11984) then {
// [KnfOpt]       let _11985: Int = Int(0)
// [KnfOpt]       let _11986: Int = Int(0)
// [KnfOpt]       Tuple([_11985, _11986, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.11987: Int = Apply(_102, [val.11983, ])
// [KnfOpt]       let _11988: Int = Int(0)
// [KnfOpt]       if (r.11987 == _11988) then {
// [KnfOpt]         let _11989: Int = Int(1)
// [KnfOpt]         Tuple([_11989, val.11983, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _11990: Unit = Unit
// [KnfOpt]         Jump(aux.11978, [_11990, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.11978, [u.11977, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.11976)
// [KnfOpt] let rec add.11991: Int = (x.11992: Int, y.11993: Int) {
// [KnfOpt]   Add(x.11992, y.11993)
// [KnfOpt] }
// [KnfOpt] let _11994: Int = Int(0)
// [KnfOpt] let join fold.11995: Int = (stream.11996: Fun([Unit], Tuple([Int, Int])), f.11997: Fun([Int, Int], Int), acc.11998: Int) {
// [KnfOpt]   let _11999: Unit = Unit
// [KnfOpt]   let _12000: Tuple([Int, Int]) = Apply(stream.11996, [_11999, ])
// [KnfOpt]   let (ok.12001: Var({val: Some(Int)}), val.12002: Var({val: Some(Int)})) = _12000
// [KnfOpt]   let _12003: Int = Int(0)
// [KnfOpt]   if (ok.12001 == _12003) then {
// [KnfOpt]     let sum.104: Int = Var(acc.11998)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _12004: Int = Apply(f.11997, [acc.11998, val.12002, ])
// [KnfOpt]     Jump(fold.11995, [stream.11996, f.11997, _12004, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.11995, [under1200.103, add.11991, _11994, ])
// [KnfOpt] Inline threshold 5
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 0
// [KnfOpt] Inline decision le.83 accepted
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.12020: Int = (x.12021: Int, y.12022: Int) {
// [KnfOpt]   Add(x.12021, y.12022)
// [KnfOpt] }
// [KnfOpt] let _12023: Int = Int(0)
// [KnfOpt] let join fold.12024: Int = (stream.12025: Fun([Unit], Tuple([Int, Int])), f.12026: Fun([Int, Int], Int), acc.12027: Int) {
// [KnfOpt]   let _12028: Unit = Unit
// [KnfOpt]   let _12029: Tuple([Int, Int]) = Apply(stream.12025, [_12028, ])
// [KnfOpt]   let (ok.12030: Var({val: Some(Int)}), val.12031: Var({val: Some(Int)})) = _12029
// [KnfOpt]   let _12032: Int = Int(0)
// [KnfOpt]   if (ok.12030 == _12032) then {
// [KnfOpt]     let sum.104: Int = Var(acc.12027)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _12033: Int = Apply(f.12026, [acc.12027, val.12031, ])
// [KnfOpt]     Jump(fold.12024, [stream.12025, f.12026, _12033, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.12024, [under1200.103, add.12020, _12023, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(le) let _102: Fun([Int], Int) = Unit
// [KnfOpt] let rec aux.12034: Tuple([Int, Int]) = (u.12035: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.12036: Tuple([Int, Int]) = (u.12037: Var({val: Some(Unit)})) {
// [KnfOpt]     let _12038: Unit = Unit
// [KnfOpt]     let _12039: Tuple([Int, Int]) = Apply(over50.100, [_12038, ])
// [KnfOpt]     let (ok.12040: Var({val: Some(Int)}), val.12041: Var({val: Some(Int)})) = _12039
// [KnfOpt]     let _12042: Int = Int(0)
// [KnfOpt]     if (ok.12040 == _12042) then {
// [KnfOpt]       let _12043: Int = Int(0)
// [KnfOpt]       let _12044: Int = Int(0)
// [KnfOpt]       Tuple([_12043, _12044, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.12045: Int = Apply(_102, [val.12041, ])
// [KnfOpt]       let _12046: Int = Int(0)
// [KnfOpt]       if (r.12045 == _12046) then {
// [KnfOpt]         let _12047: Int = Int(1)
// [KnfOpt]         Tuple([_12047, val.12041, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _12048: Unit = Unit
// [KnfOpt]         Jump(aux.12036, [_12048, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.12036, [u.12035, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.12034)
// [KnfOpt] let rec add.12049: Int = (x.12050: Int, y.12051: Int) {
// [KnfOpt]   Add(x.12050, y.12051)
// [KnfOpt] }
// [KnfOpt] let _12052: Int = Int(0)
// [KnfOpt] let join fold.12053: Int = (stream.12054: Fun([Unit], Tuple([Int, Int])), f.12055: Fun([Int, Int], Int), acc.12056: Int) {
// [KnfOpt]   let _12057: Unit = Unit
// [KnfOpt]   let _12058: Tuple([Int, Int]) = Apply(stream.12054, [_12057, ])
// [KnfOpt]   let (ok.12059: Var({val: Some(Int)}), val.12060: Var({val: Some(Int)})) = _12058
// [KnfOpt]   let _12061: Int = Int(0)
// [KnfOpt]   if (ok.12059 == _12061) then {
// [KnfOpt]     let sum.104: Int = Var(acc.12056)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _12062: Int = Apply(f.12055, [acc.12056, val.12060, ])
// [KnfOpt]     Jump(fold.12053, [stream.12054, f.12055, _12062, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.12053, [under1200.103, add.12049, _12052, ])
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.12065: Int = (x.12066: Int, y.12067: Int) {
// [KnfOpt]   Add(x.12066, y.12067)
// [KnfOpt] }
// [KnfOpt] let _12068: Int = Int(0)
// [KnfOpt] let join fold.12069: Int = (stream.12070: Fun([Unit], Tuple([Int, Int])), f.12071: Fun([Int, Int], Int), acc.12072: Int) {
// [KnfOpt]   let _12073: Unit = Unit
// [KnfOpt]   let _12074: Tuple([Int, Int]) = Apply(stream.12070, [_12073, ])
// [KnfOpt]   let (ok.12075: Var({val: Some(Int)}), val.12076: Var({val: Some(Int)})) = _12074
// [KnfOpt]   let _12077: Int = Int(0)
// [KnfOpt]   if (ok.12075 == _12077) then {
// [KnfOpt]     let sum.104: Int = Var(acc.12072)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _12078: Int = Apply(f.12071, [acc.12072, val.12076, ])
// [KnfOpt]     Jump(fold.12069, [stream.12070, f.12071, _12078, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.12069, [under1200.103, add.12065, _12068, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(gt) let _99: Fun([Int], Int) = Unit
// [KnfOpt] let rec aux.12005: Tuple([Int, Int]) = (u.12006: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.12007: Tuple([Int, Int]) = (u.12008: Var({val: Some(Unit)})) {
// [KnfOpt]     let _12009: Unit = Unit
// [KnfOpt]     let _12010: Tuple([Int, Int]) = Apply(addone.97, [_12009, ])
// [KnfOpt]     let (ok.12011: Var({val: Some(Int)}), val.12012: Var({val: Some(Int)})) = _12010
// [KnfOpt]     let _12013: Int = Int(0)
// [KnfOpt]     if (ok.12011 == _12013) then {
// [KnfOpt]       let _12014: Int = Int(0)
// [KnfOpt]       let _12015: Int = Int(0)
// [KnfOpt]       Tuple([_12014, _12015, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.12016: Int = Apply(_99, [val.12012, ])
// [KnfOpt]       let _12017: Int = Int(0)
// [KnfOpt]       if (r.12016 == _12017) then {
// [KnfOpt]         let _12018: Int = Int(1)
// [KnfOpt]         Tuple([_12018, val.12012, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _12019: Unit = Unit
// [KnfOpt]         Jump(aux.12007, [_12019, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.12007, [u.12006, ])
// [KnfOpt] }
// [KnfOpt] let over50.100: Fun([Unit], Tuple([Int, Int])) = Var(aux.12005)
// [KnfOpt] let _101: Int = Int(1200)
// [KnfOpt] let rec aux.12063: Int = (y.12064: Int) {
// [KnfOpt]   if (y.12064 <= _101) then {
// [KnfOpt]     Int(0)
// [KnfOpt]   } else {
// [KnfOpt]     Int(1)
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] let _102: Fun([Int], Int) = Var(aux.12063)
// [KnfOpt] let rec aux.12079: Tuple([Int, Int]) = (u.12080: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.12081: Tuple([Int, Int]) = (u.12082: Var({val: Some(Unit)})) {
// [KnfOpt]     let _12083: Unit = Unit
// [KnfOpt]     let _12084: Tuple([Int, Int]) = Apply(over50.100, [_12083, ])
// [KnfOpt]     let (ok.12085: Var({val: Some(Int)}), val.12086: Var({val: Some(Int)})) = _12084
// [KnfOpt]     let _12087: Int = Int(0)
// [KnfOpt]     if (ok.12085 == _12087) then {
// [KnfOpt]       let _12088: Int = Int(0)
// [KnfOpt]       let _12089: Int = Int(0)
// [KnfOpt]       Tuple([_12088, _12089, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.12090: Int = Apply(_102, [val.12086, ])
// [KnfOpt]       let _12091: Int = Int(0)
// [KnfOpt]       if (r.12090 == _12091) then {
// [KnfOpt]         let _12092: Int = Int(1)
// [KnfOpt]         Tuple([_12092, val.12086, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _12093: Unit = Unit
// [KnfOpt]         Jump(aux.12081, [_12093, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.12081, [u.12080, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.12079)
// [KnfOpt] let rec add.12094: Int = (x.12095: Int, y.12096: Int) {
// [KnfOpt]   Add(x.12095, y.12096)
// [KnfOpt] }
// [KnfOpt] let _12097: Int = Int(0)
// [KnfOpt] let join fold.12098: Int = (stream.12099: Fun([Unit], Tuple([Int, Int])), f.12100: Fun([Int, Int], Int), acc.12101: Int) {
// [KnfOpt]   let _12102: Unit = Unit
// [KnfOpt]   let _12103: Tuple([Int, Int]) = Apply(stream.12099, [_12102, ])
// [KnfOpt]   let (ok.12104: Var({val: Some(Int)}), val.12105: Var({val: Some(Int)})) = _12103
// [KnfOpt]   let _12106: Int = Int(0)
// [KnfOpt]   if (ok.12104 == _12106) then {
// [KnfOpt]     let sum.104: Int = Var(acc.12101)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _12107: Int = Apply(f.12100, [acc.12101, val.12105, ])
// [KnfOpt]     Jump(fold.12098, [stream.12099, f.12100, _12107, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.12098, [under1200.103, add.12094, _12097, ])
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 5
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 0
// [KnfOpt] Inline decision le.83 accepted
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.12110: Int = (x.12111: Int, y.12112: Int) {
// [KnfOpt]   Add(x.12111, y.12112)
// [KnfOpt] }
// [KnfOpt] let _12113: Int = Int(0)
// [KnfOpt] let join fold.12114: Int = (stream.12115: Fun([Unit], Tuple([Int, Int])), f.12116: Fun([Int, Int], Int), acc.12117: Int) {
// [KnfOpt]   let _12118: Unit = Unit
// [KnfOpt]   let _12119: Tuple([Int, Int]) = Apply(stream.12115, [_12118, ])
// [KnfOpt]   let (ok.12120: Var({val: Some(Int)}), val.12121: Var({val: Some(Int)})) = _12119
// [KnfOpt]   let _12122: Int = Int(0)
// [KnfOpt]   if (ok.12120 == _12122) then {
// [KnfOpt]     let sum.104: Int = Var(acc.12117)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _12123: Int = Apply(f.12116, [acc.12117, val.12121, ])
// [KnfOpt]     Jump(fold.12114, [stream.12115, f.12116, _12123, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.12114, [under1200.103, add.12110, _12113, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(le) let _102: Fun([Int], Int) = Unit
// [KnfOpt] let rec aux.12124: Tuple([Int, Int]) = (u.12125: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.12126: Tuple([Int, Int]) = (u.12127: Var({val: Some(Unit)})) {
// [KnfOpt]     let _12128: Unit = Unit
// [KnfOpt]     let _12129: Tuple([Int, Int]) = Apply(over50.100, [_12128, ])
// [KnfOpt]     let (ok.12130: Var({val: Some(Int)}), val.12131: Var({val: Some(Int)})) = _12129
// [KnfOpt]     let _12132: Int = Int(0)
// [KnfOpt]     if (ok.12130 == _12132) then {
// [KnfOpt]       let _12133: Int = Int(0)
// [KnfOpt]       let _12134: Int = Int(0)
// [KnfOpt]       Tuple([_12133, _12134, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.12135: Int = Apply(_102, [val.12131, ])
// [KnfOpt]       let _12136: Int = Int(0)
// [KnfOpt]       if (r.12135 == _12136) then {
// [KnfOpt]         let _12137: Int = Int(1)
// [KnfOpt]         Tuple([_12137, val.12131, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _12138: Unit = Unit
// [KnfOpt]         Jump(aux.12126, [_12138, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.12126, [u.12125, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.12124)
// [KnfOpt] let rec add.12139: Int = (x.12140: Int, y.12141: Int) {
// [KnfOpt]   Add(x.12140, y.12141)
// [KnfOpt] }
// [KnfOpt] let _12142: Int = Int(0)
// [KnfOpt] let join fold.12143: Int = (stream.12144: Fun([Unit], Tuple([Int, Int])), f.12145: Fun([Int, Int], Int), acc.12146: Int) {
// [KnfOpt]   let _12147: Unit = Unit
// [KnfOpt]   let _12148: Tuple([Int, Int]) = Apply(stream.12144, [_12147, ])
// [KnfOpt]   let (ok.12149: Var({val: Some(Int)}), val.12150: Var({val: Some(Int)})) = _12148
// [KnfOpt]   let _12151: Int = Int(0)
// [KnfOpt]   if (ok.12149 == _12151) then {
// [KnfOpt]     let sum.104: Int = Var(acc.12146)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _12152: Int = Apply(f.12145, [acc.12146, val.12150, ])
// [KnfOpt]     Jump(fold.12143, [stream.12144, f.12145, _12152, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.12143, [under1200.103, add.12139, _12142, ])
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.12155: Int = (x.12156: Int, y.12157: Int) {
// [KnfOpt]   Add(x.12156, y.12157)
// [KnfOpt] }
// [KnfOpt] let _12158: Int = Int(0)
// [KnfOpt] let join fold.12159: Int = (stream.12160: Fun([Unit], Tuple([Int, Int])), f.12161: Fun([Int, Int], Int), acc.12162: Int) {
// [KnfOpt]   let _12163: Unit = Unit
// [KnfOpt]   let _12164: Tuple([Int, Int]) = Apply(stream.12160, [_12163, ])
// [KnfOpt]   let (ok.12165: Var({val: Some(Int)}), val.12166: Var({val: Some(Int)})) = _12164
// [KnfOpt]   let _12167: Int = Int(0)
// [KnfOpt]   if (ok.12165 == _12167) then {
// [KnfOpt]     let sum.104: Int = Var(acc.12162)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _12168: Int = Apply(f.12161, [acc.12162, val.12166, ])
// [KnfOpt]     Jump(fold.12159, [stream.12160, f.12161, _12168, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.12159, [under1200.103, add.12155, _12158, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let over50.100: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let _101: Int = Int(1200)
// [KnfOpt] let rec aux.12153: Int = (y.12154: Int) {
// [KnfOpt]   if (y.12154 <= _101) then {
// [KnfOpt]     Int(0)
// [KnfOpt]   } else {
// [KnfOpt]     Int(1)
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] let _102: Fun([Int], Int) = Var(aux.12153)
// [KnfOpt] let rec aux.12169: Tuple([Int, Int]) = (u.12170: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.12171: Tuple([Int, Int]) = (u.12172: Var({val: Some(Unit)})) {
// [KnfOpt]     let _12173: Unit = Unit
// [KnfOpt]     let _12174: Tuple([Int, Int]) = Apply(over50.100, [_12173, ])
// [KnfOpt]     let (ok.12175: Var({val: Some(Int)}), val.12176: Var({val: Some(Int)})) = _12174
// [KnfOpt]     let _12177: Int = Int(0)
// [KnfOpt]     if (ok.12175 == _12177) then {
// [KnfOpt]       let _12178: Int = Int(0)
// [KnfOpt]       let _12179: Int = Int(0)
// [KnfOpt]       Tuple([_12178, _12179, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.12180: Int = Apply(_102, [val.12176, ])
// [KnfOpt]       let _12181: Int = Int(0)
// [KnfOpt]       if (r.12180 == _12181) then {
// [KnfOpt]         let _12182: Int = Int(1)
// [KnfOpt]         Tuple([_12182, val.12176, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _12183: Unit = Unit
// [KnfOpt]         Jump(aux.12171, [_12183, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.12171, [u.12170, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.12169)
// [KnfOpt] let rec add.12184: Int = (x.12185: Int, y.12186: Int) {
// [KnfOpt]   Add(x.12185, y.12186)
// [KnfOpt] }
// [KnfOpt] let _12187: Int = Int(0)
// [KnfOpt] let join fold.12188: Int = (stream.12189: Fun([Unit], Tuple([Int, Int])), f.12190: Fun([Int, Int], Int), acc.12191: Int) {
// [KnfOpt]   let _12192: Unit = Unit
// [KnfOpt]   let _12193: Tuple([Int, Int]) = Apply(stream.12189, [_12192, ])
// [KnfOpt]   let (ok.12194: Var({val: Some(Int)}), val.12195: Var({val: Some(Int)})) = _12193
// [KnfOpt]   let _12196: Int = Int(0)
// [KnfOpt]   if (ok.12194 == _12196) then {
// [KnfOpt]     let sum.104: Int = Var(acc.12191)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _12197: Int = Apply(f.12190, [acc.12191, val.12195, ])
// [KnfOpt]     Jump(fold.12188, [stream.12189, f.12190, _12197, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.12188, [under1200.103, add.12184, _12187, ])
// [KnfOpt] Inline threshold 5
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 0
// [KnfOpt] Inline decision le.83 accepted
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.12213: Int = (x.12214: Int, y.12215: Int) {
// [KnfOpt]   Add(x.12214, y.12215)
// [KnfOpt] }
// [KnfOpt] let _12216: Int = Int(0)
// [KnfOpt] let join fold.12217: Int = (stream.12218: Fun([Unit], Tuple([Int, Int])), f.12219: Fun([Int, Int], Int), acc.12220: Int) {
// [KnfOpt]   let _12221: Unit = Unit
// [KnfOpt]   let _12222: Tuple([Int, Int]) = Apply(stream.12218, [_12221, ])
// [KnfOpt]   let (ok.12223: Var({val: Some(Int)}), val.12224: Var({val: Some(Int)})) = _12222
// [KnfOpt]   let _12225: Int = Int(0)
// [KnfOpt]   if (ok.12223 == _12225) then {
// [KnfOpt]     let sum.104: Int = Var(acc.12220)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _12226: Int = Apply(f.12219, [acc.12220, val.12224, ])
// [KnfOpt]     Jump(fold.12217, [stream.12218, f.12219, _12226, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.12217, [under1200.103, add.12213, _12216, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(le) let _102: Fun([Int], Int) = Unit
// [KnfOpt] let rec aux.12227: Tuple([Int, Int]) = (u.12228: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.12229: Tuple([Int, Int]) = (u.12230: Var({val: Some(Unit)})) {
// [KnfOpt]     let _12231: Unit = Unit
// [KnfOpt]     let _12232: Tuple([Int, Int]) = Apply(over50.100, [_12231, ])
// [KnfOpt]     let (ok.12233: Var({val: Some(Int)}), val.12234: Var({val: Some(Int)})) = _12232
// [KnfOpt]     let _12235: Int = Int(0)
// [KnfOpt]     if (ok.12233 == _12235) then {
// [KnfOpt]       let _12236: Int = Int(0)
// [KnfOpt]       let _12237: Int = Int(0)
// [KnfOpt]       Tuple([_12236, _12237, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.12238: Int = Apply(_102, [val.12234, ])
// [KnfOpt]       let _12239: Int = Int(0)
// [KnfOpt]       if (r.12238 == _12239) then {
// [KnfOpt]         let _12240: Int = Int(1)
// [KnfOpt]         Tuple([_12240, val.12234, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _12241: Unit = Unit
// [KnfOpt]         Jump(aux.12229, [_12241, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.12229, [u.12228, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.12227)
// [KnfOpt] let rec add.12242: Int = (x.12243: Int, y.12244: Int) {
// [KnfOpt]   Add(x.12243, y.12244)
// [KnfOpt] }
// [KnfOpt] let _12245: Int = Int(0)
// [KnfOpt] let join fold.12246: Int = (stream.12247: Fun([Unit], Tuple([Int, Int])), f.12248: Fun([Int, Int], Int), acc.12249: Int) {
// [KnfOpt]   let _12250: Unit = Unit
// [KnfOpt]   let _12251: Tuple([Int, Int]) = Apply(stream.12247, [_12250, ])
// [KnfOpt]   let (ok.12252: Var({val: Some(Int)}), val.12253: Var({val: Some(Int)})) = _12251
// [KnfOpt]   let _12254: Int = Int(0)
// [KnfOpt]   if (ok.12252 == _12254) then {
// [KnfOpt]     let sum.104: Int = Var(acc.12249)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _12255: Int = Apply(f.12248, [acc.12249, val.12253, ])
// [KnfOpt]     Jump(fold.12246, [stream.12247, f.12248, _12255, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.12246, [under1200.103, add.12242, _12245, ])
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.12258: Int = (x.12259: Int, y.12260: Int) {
// [KnfOpt]   Add(x.12259, y.12260)
// [KnfOpt] }
// [KnfOpt] let _12261: Int = Int(0)
// [KnfOpt] let join fold.12262: Int = (stream.12263: Fun([Unit], Tuple([Int, Int])), f.12264: Fun([Int, Int], Int), acc.12265: Int) {
// [KnfOpt]   let _12266: Unit = Unit
// [KnfOpt]   let _12267: Tuple([Int, Int]) = Apply(stream.12263, [_12266, ])
// [KnfOpt]   let (ok.12268: Var({val: Some(Int)}), val.12269: Var({val: Some(Int)})) = _12267
// [KnfOpt]   let _12270: Int = Int(0)
// [KnfOpt]   if (ok.12268 == _12270) then {
// [KnfOpt]     let sum.104: Int = Var(acc.12265)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _12271: Int = Apply(f.12264, [acc.12265, val.12269, ])
// [KnfOpt]     Jump(fold.12262, [stream.12263, f.12264, _12271, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.12262, [under1200.103, add.12258, _12261, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(map) let addone.97: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let _98: Int = Int(50)
// [KnfOpt] let rec aux.12108: Int = (y.12109: Int) {
// [KnfOpt]   if (_98 <= y.12109) then {
// [KnfOpt]     Int(0)
// [KnfOpt]   } else {
// [KnfOpt]     Int(1)
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] let _99: Fun([Int], Int) = Var(aux.12108)
// [KnfOpt] let rec aux.12198: Tuple([Int, Int]) = (u.12199: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.12200: Tuple([Int, Int]) = (u.12201: Var({val: Some(Unit)})) {
// [KnfOpt]     let _12202: Unit = Unit
// [KnfOpt]     let _12203: Tuple([Int, Int]) = Apply(addone.97, [_12202, ])
// [KnfOpt]     let (ok.12204: Var({val: Some(Int)}), val.12205: Var({val: Some(Int)})) = _12203
// [KnfOpt]     let _12206: Int = Int(0)
// [KnfOpt]     if (ok.12204 == _12206) then {
// [KnfOpt]       let _12207: Int = Int(0)
// [KnfOpt]       let _12208: Int = Int(0)
// [KnfOpt]       Tuple([_12207, _12208, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.12209: Int = Apply(_99, [val.12205, ])
// [KnfOpt]       let _12210: Int = Int(0)
// [KnfOpt]       if (r.12209 == _12210) then {
// [KnfOpt]         let _12211: Int = Int(1)
// [KnfOpt]         Tuple([_12211, val.12205, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _12212: Unit = Unit
// [KnfOpt]         Jump(aux.12200, [_12212, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.12200, [u.12199, ])
// [KnfOpt] }
// [KnfOpt] let over50.100: Fun([Unit], Tuple([Int, Int])) = Var(aux.12198)
// [KnfOpt] let _101: Int = Int(1200)
// [KnfOpt] let rec aux.12256: Int = (y.12257: Int) {
// [KnfOpt]   if (y.12257 <= _101) then {
// [KnfOpt]     Int(0)
// [KnfOpt]   } else {
// [KnfOpt]     Int(1)
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] let _102: Fun([Int], Int) = Var(aux.12256)
// [KnfOpt] let rec aux.12272: Tuple([Int, Int]) = (u.12273: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.12274: Tuple([Int, Int]) = (u.12275: Var({val: Some(Unit)})) {
// [KnfOpt]     let _12276: Unit = Unit
// [KnfOpt]     let _12277: Tuple([Int, Int]) = Apply(over50.100, [_12276, ])
// [KnfOpt]     let (ok.12278: Var({val: Some(Int)}), val.12279: Var({val: Some(Int)})) = _12277
// [KnfOpt]     let _12280: Int = Int(0)
// [KnfOpt]     if (ok.12278 == _12280) then {
// [KnfOpt]       let _12281: Int = Int(0)
// [KnfOpt]       let _12282: Int = Int(0)
// [KnfOpt]       Tuple([_12281, _12282, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.12283: Int = Apply(_102, [val.12279, ])
// [KnfOpt]       let _12284: Int = Int(0)
// [KnfOpt]       if (r.12283 == _12284) then {
// [KnfOpt]         let _12285: Int = Int(1)
// [KnfOpt]         Tuple([_12285, val.12279, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _12286: Unit = Unit
// [KnfOpt]         Jump(aux.12274, [_12286, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.12274, [u.12273, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.12272)
// [KnfOpt] let rec add.12287: Int = (x.12288: Int, y.12289: Int) {
// [KnfOpt]   Add(x.12288, y.12289)
// [KnfOpt] }
// [KnfOpt] let _12290: Int = Int(0)
// [KnfOpt] let join fold.12291: Int = (stream.12292: Fun([Unit], Tuple([Int, Int])), f.12293: Fun([Int, Int], Int), acc.12294: Int) {
// [KnfOpt]   let _12295: Unit = Unit
// [KnfOpt]   let _12296: Tuple([Int, Int]) = Apply(stream.12292, [_12295, ])
// [KnfOpt]   let (ok.12297: Var({val: Some(Int)}), val.12298: Var({val: Some(Int)})) = _12296
// [KnfOpt]   let _12299: Int = Int(0)
// [KnfOpt]   if (ok.12297 == _12299) then {
// [KnfOpt]     let sum.104: Int = Var(acc.12294)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _12300: Int = Apply(f.12293, [acc.12294, val.12298, ])
// [KnfOpt]     Jump(fold.12291, [stream.12292, f.12293, _12300, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.12291, [under1200.103, add.12287, _12290, ])
// [KnfOpt] Inline threshold 5
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 0
// [KnfOpt] Inline decision gt.79 accepted
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 5
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 0
// [KnfOpt] Inline decision le.83 accepted
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.12312: Int = (x.12313: Int, y.12314: Int) {
// [KnfOpt]   Add(x.12313, y.12314)
// [KnfOpt] }
// [KnfOpt] let _12315: Int = Int(0)
// [KnfOpt] let join fold.12316: Int = (stream.12317: Fun([Unit], Tuple([Int, Int])), f.12318: Fun([Int, Int], Int), acc.12319: Int) {
// [KnfOpt]   let _12320: Unit = Unit
// [KnfOpt]   let _12321: Tuple([Int, Int]) = Apply(stream.12317, [_12320, ])
// [KnfOpt]   let (ok.12322: Var({val: Some(Int)}), val.12323: Var({val: Some(Int)})) = _12321
// [KnfOpt]   let _12324: Int = Int(0)
// [KnfOpt]   if (ok.12322 == _12324) then {
// [KnfOpt]     let sum.104: Int = Var(acc.12319)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _12325: Int = Apply(f.12318, [acc.12319, val.12323, ])
// [KnfOpt]     Jump(fold.12316, [stream.12317, f.12318, _12325, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.12316, [under1200.103, add.12312, _12315, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(le) let _102: Fun([Int], Int) = Unit
// [KnfOpt] let rec aux.12326: Tuple([Int, Int]) = (u.12327: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.12328: Tuple([Int, Int]) = (u.12329: Var({val: Some(Unit)})) {
// [KnfOpt]     let _12330: Unit = Unit
// [KnfOpt]     let _12331: Tuple([Int, Int]) = Apply(over50.100, [_12330, ])
// [KnfOpt]     let (ok.12332: Var({val: Some(Int)}), val.12333: Var({val: Some(Int)})) = _12331
// [KnfOpt]     let _12334: Int = Int(0)
// [KnfOpt]     if (ok.12332 == _12334) then {
// [KnfOpt]       let _12335: Int = Int(0)
// [KnfOpt]       let _12336: Int = Int(0)
// [KnfOpt]       Tuple([_12335, _12336, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.12337: Int = Apply(_102, [val.12333, ])
// [KnfOpt]       let _12338: Int = Int(0)
// [KnfOpt]       if (r.12337 == _12338) then {
// [KnfOpt]         let _12339: Int = Int(1)
// [KnfOpt]         Tuple([_12339, val.12333, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _12340: Unit = Unit
// [KnfOpt]         Jump(aux.12328, [_12340, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.12328, [u.12327, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.12326)
// [KnfOpt] let rec add.12341: Int = (x.12342: Int, y.12343: Int) {
// [KnfOpt]   Add(x.12342, y.12343)
// [KnfOpt] }
// [KnfOpt] let _12344: Int = Int(0)
// [KnfOpt] let join fold.12345: Int = (stream.12346: Fun([Unit], Tuple([Int, Int])), f.12347: Fun([Int, Int], Int), acc.12348: Int) {
// [KnfOpt]   let _12349: Unit = Unit
// [KnfOpt]   let _12350: Tuple([Int, Int]) = Apply(stream.12346, [_12349, ])
// [KnfOpt]   let (ok.12351: Var({val: Some(Int)}), val.12352: Var({val: Some(Int)})) = _12350
// [KnfOpt]   let _12353: Int = Int(0)
// [KnfOpt]   if (ok.12351 == _12353) then {
// [KnfOpt]     let sum.104: Int = Var(acc.12348)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _12354: Int = Apply(f.12347, [acc.12348, val.12352, ])
// [KnfOpt]     Jump(fold.12345, [stream.12346, f.12347, _12354, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.12345, [under1200.103, add.12341, _12344, ])
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.12357: Int = (x.12358: Int, y.12359: Int) {
// [KnfOpt]   Add(x.12358, y.12359)
// [KnfOpt] }
// [KnfOpt] let _12360: Int = Int(0)
// [KnfOpt] let join fold.12361: Int = (stream.12362: Fun([Unit], Tuple([Int, Int])), f.12363: Fun([Int, Int], Int), acc.12364: Int) {
// [KnfOpt]   let _12365: Unit = Unit
// [KnfOpt]   let _12366: Tuple([Int, Int]) = Apply(stream.12362, [_12365, ])
// [KnfOpt]   let (ok.12367: Var({val: Some(Int)}), val.12368: Var({val: Some(Int)})) = _12366
// [KnfOpt]   let _12369: Int = Int(0)
// [KnfOpt]   if (ok.12367 == _12369) then {
// [KnfOpt]     let sum.104: Int = Var(acc.12364)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _12370: Int = Apply(f.12363, [acc.12364, val.12368, ])
// [KnfOpt]     Jump(fold.12361, [stream.12362, f.12363, _12370, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.12361, [under1200.103, add.12357, _12360, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let over50.100: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let _101: Int = Int(1200)
// [KnfOpt] let rec aux.12355: Int = (y.12356: Int) {
// [KnfOpt]   if (y.12356 <= _101) then {
// [KnfOpt]     Int(0)
// [KnfOpt]   } else {
// [KnfOpt]     Int(1)
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] let _102: Fun([Int], Int) = Var(aux.12355)
// [KnfOpt] let rec aux.12371: Tuple([Int, Int]) = (u.12372: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.12373: Tuple([Int, Int]) = (u.12374: Var({val: Some(Unit)})) {
// [KnfOpt]     let _12375: Unit = Unit
// [KnfOpt]     let _12376: Tuple([Int, Int]) = Apply(over50.100, [_12375, ])
// [KnfOpt]     let (ok.12377: Var({val: Some(Int)}), val.12378: Var({val: Some(Int)})) = _12376
// [KnfOpt]     let _12379: Int = Int(0)
// [KnfOpt]     if (ok.12377 == _12379) then {
// [KnfOpt]       let _12380: Int = Int(0)
// [KnfOpt]       let _12381: Int = Int(0)
// [KnfOpt]       Tuple([_12380, _12381, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.12382: Int = Apply(_102, [val.12378, ])
// [KnfOpt]       let _12383: Int = Int(0)
// [KnfOpt]       if (r.12382 == _12383) then {
// [KnfOpt]         let _12384: Int = Int(1)
// [KnfOpt]         Tuple([_12384, val.12378, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _12385: Unit = Unit
// [KnfOpt]         Jump(aux.12373, [_12385, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.12373, [u.12372, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.12371)
// [KnfOpt] let rec add.12386: Int = (x.12387: Int, y.12388: Int) {
// [KnfOpt]   Add(x.12387, y.12388)
// [KnfOpt] }
// [KnfOpt] let _12389: Int = Int(0)
// [KnfOpt] let join fold.12390: Int = (stream.12391: Fun([Unit], Tuple([Int, Int])), f.12392: Fun([Int, Int], Int), acc.12393: Int) {
// [KnfOpt]   let _12394: Unit = Unit
// [KnfOpt]   let _12395: Tuple([Int, Int]) = Apply(stream.12391, [_12394, ])
// [KnfOpt]   let (ok.12396: Var({val: Some(Int)}), val.12397: Var({val: Some(Int)})) = _12395
// [KnfOpt]   let _12398: Int = Int(0)
// [KnfOpt]   if (ok.12396 == _12398) then {
// [KnfOpt]     let sum.104: Int = Var(acc.12393)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _12399: Int = Apply(f.12392, [acc.12393, val.12397, ])
// [KnfOpt]     Jump(fold.12390, [stream.12391, f.12392, _12399, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.12390, [under1200.103, add.12386, _12389, ])
// [KnfOpt] Inline threshold 5
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 0
// [KnfOpt] Inline decision le.83 accepted
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.12415: Int = (x.12416: Int, y.12417: Int) {
// [KnfOpt]   Add(x.12416, y.12417)
// [KnfOpt] }
// [KnfOpt] let _12418: Int = Int(0)
// [KnfOpt] let join fold.12419: Int = (stream.12420: Fun([Unit], Tuple([Int, Int])), f.12421: Fun([Int, Int], Int), acc.12422: Int) {
// [KnfOpt]   let _12423: Unit = Unit
// [KnfOpt]   let _12424: Tuple([Int, Int]) = Apply(stream.12420, [_12423, ])
// [KnfOpt]   let (ok.12425: Var({val: Some(Int)}), val.12426: Var({val: Some(Int)})) = _12424
// [KnfOpt]   let _12427: Int = Int(0)
// [KnfOpt]   if (ok.12425 == _12427) then {
// [KnfOpt]     let sum.104: Int = Var(acc.12422)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _12428: Int = Apply(f.12421, [acc.12422, val.12426, ])
// [KnfOpt]     Jump(fold.12419, [stream.12420, f.12421, _12428, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.12419, [under1200.103, add.12415, _12418, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(le) let _102: Fun([Int], Int) = Unit
// [KnfOpt] let rec aux.12429: Tuple([Int, Int]) = (u.12430: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.12431: Tuple([Int, Int]) = (u.12432: Var({val: Some(Unit)})) {
// [KnfOpt]     let _12433: Unit = Unit
// [KnfOpt]     let _12434: Tuple([Int, Int]) = Apply(over50.100, [_12433, ])
// [KnfOpt]     let (ok.12435: Var({val: Some(Int)}), val.12436: Var({val: Some(Int)})) = _12434
// [KnfOpt]     let _12437: Int = Int(0)
// [KnfOpt]     if (ok.12435 == _12437) then {
// [KnfOpt]       let _12438: Int = Int(0)
// [KnfOpt]       let _12439: Int = Int(0)
// [KnfOpt]       Tuple([_12438, _12439, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.12440: Int = Apply(_102, [val.12436, ])
// [KnfOpt]       let _12441: Int = Int(0)
// [KnfOpt]       if (r.12440 == _12441) then {
// [KnfOpt]         let _12442: Int = Int(1)
// [KnfOpt]         Tuple([_12442, val.12436, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _12443: Unit = Unit
// [KnfOpt]         Jump(aux.12431, [_12443, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.12431, [u.12430, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.12429)
// [KnfOpt] let rec add.12444: Int = (x.12445: Int, y.12446: Int) {
// [KnfOpt]   Add(x.12445, y.12446)
// [KnfOpt] }
// [KnfOpt] let _12447: Int = Int(0)
// [KnfOpt] let join fold.12448: Int = (stream.12449: Fun([Unit], Tuple([Int, Int])), f.12450: Fun([Int, Int], Int), acc.12451: Int) {
// [KnfOpt]   let _12452: Unit = Unit
// [KnfOpt]   let _12453: Tuple([Int, Int]) = Apply(stream.12449, [_12452, ])
// [KnfOpt]   let (ok.12454: Var({val: Some(Int)}), val.12455: Var({val: Some(Int)})) = _12453
// [KnfOpt]   let _12456: Int = Int(0)
// [KnfOpt]   if (ok.12454 == _12456) then {
// [KnfOpt]     let sum.104: Int = Var(acc.12451)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _12457: Int = Apply(f.12450, [acc.12451, val.12455, ])
// [KnfOpt]     Jump(fold.12448, [stream.12449, f.12450, _12457, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.12448, [under1200.103, add.12444, _12447, ])
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.12460: Int = (x.12461: Int, y.12462: Int) {
// [KnfOpt]   Add(x.12461, y.12462)
// [KnfOpt] }
// [KnfOpt] let _12463: Int = Int(0)
// [KnfOpt] let join fold.12464: Int = (stream.12465: Fun([Unit], Tuple([Int, Int])), f.12466: Fun([Int, Int], Int), acc.12467: Int) {
// [KnfOpt]   let _12468: Unit = Unit
// [KnfOpt]   let _12469: Tuple([Int, Int]) = Apply(stream.12465, [_12468, ])
// [KnfOpt]   let (ok.12470: Var({val: Some(Int)}), val.12471: Var({val: Some(Int)})) = _12469
// [KnfOpt]   let _12472: Int = Int(0)
// [KnfOpt]   if (ok.12470 == _12472) then {
// [KnfOpt]     let sum.104: Int = Var(acc.12467)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _12473: Int = Apply(f.12466, [acc.12467, val.12471, ])
// [KnfOpt]     Jump(fold.12464, [stream.12465, f.12466, _12473, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.12464, [under1200.103, add.12460, _12463, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(gt) let _99: Fun([Int], Int) = Unit
// [KnfOpt] let rec aux.12400: Tuple([Int, Int]) = (u.12401: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.12402: Tuple([Int, Int]) = (u.12403: Var({val: Some(Unit)})) {
// [KnfOpt]     let _12404: Unit = Unit
// [KnfOpt]     let _12405: Tuple([Int, Int]) = Apply(addone.97, [_12404, ])
// [KnfOpt]     let (ok.12406: Var({val: Some(Int)}), val.12407: Var({val: Some(Int)})) = _12405
// [KnfOpt]     let _12408: Int = Int(0)
// [KnfOpt]     if (ok.12406 == _12408) then {
// [KnfOpt]       let _12409: Int = Int(0)
// [KnfOpt]       let _12410: Int = Int(0)
// [KnfOpt]       Tuple([_12409, _12410, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.12411: Int = Apply(_99, [val.12407, ])
// [KnfOpt]       let _12412: Int = Int(0)
// [KnfOpt]       if (r.12411 == _12412) then {
// [KnfOpt]         let _12413: Int = Int(1)
// [KnfOpt]         Tuple([_12413, val.12407, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _12414: Unit = Unit
// [KnfOpt]         Jump(aux.12402, [_12414, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.12402, [u.12401, ])
// [KnfOpt] }
// [KnfOpt] let over50.100: Fun([Unit], Tuple([Int, Int])) = Var(aux.12400)
// [KnfOpt] let _101: Int = Int(1200)
// [KnfOpt] let rec aux.12458: Int = (y.12459: Int) {
// [KnfOpt]   if (y.12459 <= _101) then {
// [KnfOpt]     Int(0)
// [KnfOpt]   } else {
// [KnfOpt]     Int(1)
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] let _102: Fun([Int], Int) = Var(aux.12458)
// [KnfOpt] let rec aux.12474: Tuple([Int, Int]) = (u.12475: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.12476: Tuple([Int, Int]) = (u.12477: Var({val: Some(Unit)})) {
// [KnfOpt]     let _12478: Unit = Unit
// [KnfOpt]     let _12479: Tuple([Int, Int]) = Apply(over50.100, [_12478, ])
// [KnfOpt]     let (ok.12480: Var({val: Some(Int)}), val.12481: Var({val: Some(Int)})) = _12479
// [KnfOpt]     let _12482: Int = Int(0)
// [KnfOpt]     if (ok.12480 == _12482) then {
// [KnfOpt]       let _12483: Int = Int(0)
// [KnfOpt]       let _12484: Int = Int(0)
// [KnfOpt]       Tuple([_12483, _12484, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.12485: Int = Apply(_102, [val.12481, ])
// [KnfOpt]       let _12486: Int = Int(0)
// [KnfOpt]       if (r.12485 == _12486) then {
// [KnfOpt]         let _12487: Int = Int(1)
// [KnfOpt]         Tuple([_12487, val.12481, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _12488: Unit = Unit
// [KnfOpt]         Jump(aux.12476, [_12488, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.12476, [u.12475, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.12474)
// [KnfOpt] let rec add.12489: Int = (x.12490: Int, y.12491: Int) {
// [KnfOpt]   Add(x.12490, y.12491)
// [KnfOpt] }
// [KnfOpt] let _12492: Int = Int(0)
// [KnfOpt] let join fold.12493: Int = (stream.12494: Fun([Unit], Tuple([Int, Int])), f.12495: Fun([Int, Int], Int), acc.12496: Int) {
// [KnfOpt]   let _12497: Unit = Unit
// [KnfOpt]   let _12498: Tuple([Int, Int]) = Apply(stream.12494, [_12497, ])
// [KnfOpt]   let (ok.12499: Var({val: Some(Int)}), val.12500: Var({val: Some(Int)})) = _12498
// [KnfOpt]   let _12501: Int = Int(0)
// [KnfOpt]   if (ok.12499 == _12501) then {
// [KnfOpt]     let sum.104: Int = Var(acc.12496)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _12502: Int = Apply(f.12495, [acc.12496, val.12500, ])
// [KnfOpt]     Jump(fold.12493, [stream.12494, f.12495, _12502, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.12493, [under1200.103, add.12489, _12492, ])
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 5
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 0
// [KnfOpt] Inline decision le.83 accepted
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.12505: Int = (x.12506: Int, y.12507: Int) {
// [KnfOpt]   Add(x.12506, y.12507)
// [KnfOpt] }
// [KnfOpt] let _12508: Int = Int(0)
// [KnfOpt] let join fold.12509: Int = (stream.12510: Fun([Unit], Tuple([Int, Int])), f.12511: Fun([Int, Int], Int), acc.12512: Int) {
// [KnfOpt]   let _12513: Unit = Unit
// [KnfOpt]   let _12514: Tuple([Int, Int]) = Apply(stream.12510, [_12513, ])
// [KnfOpt]   let (ok.12515: Var({val: Some(Int)}), val.12516: Var({val: Some(Int)})) = _12514
// [KnfOpt]   let _12517: Int = Int(0)
// [KnfOpt]   if (ok.12515 == _12517) then {
// [KnfOpt]     let sum.104: Int = Var(acc.12512)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _12518: Int = Apply(f.12511, [acc.12512, val.12516, ])
// [KnfOpt]     Jump(fold.12509, [stream.12510, f.12511, _12518, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.12509, [under1200.103, add.12505, _12508, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(le) let _102: Fun([Int], Int) = Unit
// [KnfOpt] let rec aux.12519: Tuple([Int, Int]) = (u.12520: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.12521: Tuple([Int, Int]) = (u.12522: Var({val: Some(Unit)})) {
// [KnfOpt]     let _12523: Unit = Unit
// [KnfOpt]     let _12524: Tuple([Int, Int]) = Apply(over50.100, [_12523, ])
// [KnfOpt]     let (ok.12525: Var({val: Some(Int)}), val.12526: Var({val: Some(Int)})) = _12524
// [KnfOpt]     let _12527: Int = Int(0)
// [KnfOpt]     if (ok.12525 == _12527) then {
// [KnfOpt]       let _12528: Int = Int(0)
// [KnfOpt]       let _12529: Int = Int(0)
// [KnfOpt]       Tuple([_12528, _12529, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.12530: Int = Apply(_102, [val.12526, ])
// [KnfOpt]       let _12531: Int = Int(0)
// [KnfOpt]       if (r.12530 == _12531) then {
// [KnfOpt]         let _12532: Int = Int(1)
// [KnfOpt]         Tuple([_12532, val.12526, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _12533: Unit = Unit
// [KnfOpt]         Jump(aux.12521, [_12533, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.12521, [u.12520, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.12519)
// [KnfOpt] let rec add.12534: Int = (x.12535: Int, y.12536: Int) {
// [KnfOpt]   Add(x.12535, y.12536)
// [KnfOpt] }
// [KnfOpt] let _12537: Int = Int(0)
// [KnfOpt] let join fold.12538: Int = (stream.12539: Fun([Unit], Tuple([Int, Int])), f.12540: Fun([Int, Int], Int), acc.12541: Int) {
// [KnfOpt]   let _12542: Unit = Unit
// [KnfOpt]   let _12543: Tuple([Int, Int]) = Apply(stream.12539, [_12542, ])
// [KnfOpt]   let (ok.12544: Var({val: Some(Int)}), val.12545: Var({val: Some(Int)})) = _12543
// [KnfOpt]   let _12546: Int = Int(0)
// [KnfOpt]   if (ok.12544 == _12546) then {
// [KnfOpt]     let sum.104: Int = Var(acc.12541)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _12547: Int = Apply(f.12540, [acc.12541, val.12545, ])
// [KnfOpt]     Jump(fold.12538, [stream.12539, f.12540, _12547, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.12538, [under1200.103, add.12534, _12537, ])
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.12550: Int = (x.12551: Int, y.12552: Int) {
// [KnfOpt]   Add(x.12551, y.12552)
// [KnfOpt] }
// [KnfOpt] let _12553: Int = Int(0)
// [KnfOpt] let join fold.12554: Int = (stream.12555: Fun([Unit], Tuple([Int, Int])), f.12556: Fun([Int, Int], Int), acc.12557: Int) {
// [KnfOpt]   let _12558: Unit = Unit
// [KnfOpt]   let _12559: Tuple([Int, Int]) = Apply(stream.12555, [_12558, ])
// [KnfOpt]   let (ok.12560: Var({val: Some(Int)}), val.12561: Var({val: Some(Int)})) = _12559
// [KnfOpt]   let _12562: Int = Int(0)
// [KnfOpt]   if (ok.12560 == _12562) then {
// [KnfOpt]     let sum.104: Int = Var(acc.12557)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _12563: Int = Apply(f.12556, [acc.12557, val.12561, ])
// [KnfOpt]     Jump(fold.12554, [stream.12555, f.12556, _12563, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.12554, [under1200.103, add.12550, _12553, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let over50.100: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let _101: Int = Int(1200)
// [KnfOpt] let rec aux.12548: Int = (y.12549: Int) {
// [KnfOpt]   if (y.12549 <= _101) then {
// [KnfOpt]     Int(0)
// [KnfOpt]   } else {
// [KnfOpt]     Int(1)
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] let _102: Fun([Int], Int) = Var(aux.12548)
// [KnfOpt] let rec aux.12564: Tuple([Int, Int]) = (u.12565: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.12566: Tuple([Int, Int]) = (u.12567: Var({val: Some(Unit)})) {
// [KnfOpt]     let _12568: Unit = Unit
// [KnfOpt]     let _12569: Tuple([Int, Int]) = Apply(over50.100, [_12568, ])
// [KnfOpt]     let (ok.12570: Var({val: Some(Int)}), val.12571: Var({val: Some(Int)})) = _12569
// [KnfOpt]     let _12572: Int = Int(0)
// [KnfOpt]     if (ok.12570 == _12572) then {
// [KnfOpt]       let _12573: Int = Int(0)
// [KnfOpt]       let _12574: Int = Int(0)
// [KnfOpt]       Tuple([_12573, _12574, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.12575: Int = Apply(_102, [val.12571, ])
// [KnfOpt]       let _12576: Int = Int(0)
// [KnfOpt]       if (r.12575 == _12576) then {
// [KnfOpt]         let _12577: Int = Int(1)
// [KnfOpt]         Tuple([_12577, val.12571, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _12578: Unit = Unit
// [KnfOpt]         Jump(aux.12566, [_12578, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.12566, [u.12565, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.12564)
// [KnfOpt] let rec add.12579: Int = (x.12580: Int, y.12581: Int) {
// [KnfOpt]   Add(x.12580, y.12581)
// [KnfOpt] }
// [KnfOpt] let _12582: Int = Int(0)
// [KnfOpt] let join fold.12583: Int = (stream.12584: Fun([Unit], Tuple([Int, Int])), f.12585: Fun([Int, Int], Int), acc.12586: Int) {
// [KnfOpt]   let _12587: Unit = Unit
// [KnfOpt]   let _12588: Tuple([Int, Int]) = Apply(stream.12584, [_12587, ])
// [KnfOpt]   let (ok.12589: Var({val: Some(Int)}), val.12590: Var({val: Some(Int)})) = _12588
// [KnfOpt]   let _12591: Int = Int(0)
// [KnfOpt]   if (ok.12589 == _12591) then {
// [KnfOpt]     let sum.104: Int = Var(acc.12586)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _12592: Int = Apply(f.12585, [acc.12586, val.12590, ])
// [KnfOpt]     Jump(fold.12583, [stream.12584, f.12585, _12592, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.12583, [under1200.103, add.12579, _12582, ])
// [KnfOpt] Inline threshold 5
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 0
// [KnfOpt] Inline decision le.83 accepted
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.12608: Int = (x.12609: Int, y.12610: Int) {
// [KnfOpt]   Add(x.12609, y.12610)
// [KnfOpt] }
// [KnfOpt] let _12611: Int = Int(0)
// [KnfOpt] let join fold.12612: Int = (stream.12613: Fun([Unit], Tuple([Int, Int])), f.12614: Fun([Int, Int], Int), acc.12615: Int) {
// [KnfOpt]   let _12616: Unit = Unit
// [KnfOpt]   let _12617: Tuple([Int, Int]) = Apply(stream.12613, [_12616, ])
// [KnfOpt]   let (ok.12618: Var({val: Some(Int)}), val.12619: Var({val: Some(Int)})) = _12617
// [KnfOpt]   let _12620: Int = Int(0)
// [KnfOpt]   if (ok.12618 == _12620) then {
// [KnfOpt]     let sum.104: Int = Var(acc.12615)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _12621: Int = Apply(f.12614, [acc.12615, val.12619, ])
// [KnfOpt]     Jump(fold.12612, [stream.12613, f.12614, _12621, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.12612, [under1200.103, add.12608, _12611, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(le) let _102: Fun([Int], Int) = Unit
// [KnfOpt] let rec aux.12622: Tuple([Int, Int]) = (u.12623: Var({val: Some(Unit)})) {
// [KnfOpt]   let join aux.12624: Tuple([Int, Int]) = (u.12625: Var({val: Some(Unit)})) {
// [KnfOpt]     let _12626: Unit = Unit
// [KnfOpt]     let _12627: Tuple([Int, Int]) = Apply(over50.100, [_12626, ])
// [KnfOpt]     let (ok.12628: Var({val: Some(Int)}), val.12629: Var({val: Some(Int)})) = _12627
// [KnfOpt]     let _12630: Int = Int(0)
// [KnfOpt]     if (ok.12628 == _12630) then {
// [KnfOpt]       let _12631: Int = Int(0)
// [KnfOpt]       let _12632: Int = Int(0)
// [KnfOpt]       Tuple([_12631, _12632, ])
// [KnfOpt]     } else {
// [KnfOpt]       let r.12633: Int = Apply(_102, [val.12629, ])
// [KnfOpt]       let _12634: Int = Int(0)
// [KnfOpt]       if (r.12633 == _12634) then {
// [KnfOpt]         let _12635: Int = Int(1)
// [KnfOpt]         Tuple([_12635, val.12629, ])
// [KnfOpt]       } else {
// [KnfOpt]         let _12636: Unit = Unit
// [KnfOpt]         Jump(aux.12624, [_12636, ])
// [KnfOpt]       }
// [KnfOpt]     }
// [KnfOpt]   }
// [KnfOpt]   Jump(aux.12624, [u.12623, ])
// [KnfOpt] }
// [KnfOpt] let under1200.103: Fun([Unit], Tuple([Int, Int])) = Var(aux.12622)
// [KnfOpt] let rec add.12637: Int = (x.12638: Int, y.12639: Int) {
// [KnfOpt]   Add(x.12638, y.12639)
// [KnfOpt] }
// [KnfOpt] let _12640: Int = Int(0)
// [KnfOpt] let join fold.12641: Int = (stream.12642: Fun([Unit], Tuple([Int, Int])), f.12643: Fun([Int, Int], Int), acc.12644: Int) {
// [KnfOpt]   let _12645: Unit = Unit
// [KnfOpt]   let _12646: Tuple([Int, Int]) = Apply(stream.12642, [_12645, ])
// [KnfOpt]   let (ok.12647: Var({val: Some(Int)}), val.12648: Var({val: Some(Int)})) = _12646
// [KnfOpt]   let _12649: Int = Int(0)
// [KnfOpt]   if (ok.12647 == _12649) then {
// [KnfOpt]     let sum.104: Int = Var(acc.12644)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _12650: Int = Apply(f.12643, [acc.12644, val.12648, ])
// [KnfOpt]     Jump(fold.12641, [stream.12642, f.12643, _12650, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.12641, [under1200.103, add.12637, _12640, ])
// [KnfOpt] Inline threshold 28
// [KnfOpt] Fn like 3
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision filter.15 accepted
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Knf inline Some(filter) let under1200.103: Fun([Unit], Tuple([Int, Int])) = Unit
// [KnfOpt] let rec add.12653: Int = (x.12654: Int, y.12655: Int) {
// [KnfOpt]   Add(x.12654, y.12655)
// [KnfOpt] }
// [KnfOpt] let _12656: Int = Int(0)
// [KnfOpt] let join fold.12657: Int = (stream.12658: Fun([Unit], Tuple([Int, Int])), f.12659: Fun([Int, Int], Int), acc.12660: Int) {
// [KnfOpt]   let _12661: Unit = Unit
// [KnfOpt]   let _12662: Tuple([Int, Int]) = Apply(stream.12658, [_12661, ])
// [KnfOpt]   let (ok.12663: Var({val: Some(Int)}), val.12664: Var({val: Some(Int)})) = _12662
// [KnfOpt]   let _12665: Int = Int(0)
// [KnfOpt]   if (ok.12663 == _12665) then {
// [KnfOpt]     let sum.104: Int = Var(acc.12660)
// [KnfOpt]     let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt]     let _106: Int = Int(10)
// [KnfOpt]     let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt]     Unit
// [KnfOpt]   } else {
// [KnfOpt]     let _12666: Int = Apply(f.12659, [acc.12660, val.12664, ])
// [KnfOpt]     Jump(fold.12657, [stream.12658, f.12659, _12666, ])
// [KnfOpt]   }
// [KnfOpt] }
// [KnfOpt] Jump(fold.12657, [under1200.103, add.12653, _12656, ])
// [KnfOpt] Inline threshold 18
// [KnfOpt] Fn like 1
// [KnfOpt] Join point count 1
// [KnfOpt] Inline decision sum.73 accepted
// [KnfOpt] Knf inline Some(sum) let sum.104: Int = Unit
// [KnfOpt] let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
// [KnfOpt] let _106: Int = Int(10)
// [KnfOpt] let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
// [KnfOpt] Unit
// [KnfOpt] Numbers of let rec: 11 13 2
// [Parser] flags: []
// [CoreOpt] Call frequnce: FnCallFreq({f6: Once, f4: Once, f8: Once, f9: Once, f0: Once, f26: Once, f1: Once, f10: Once, f5: Once, f2: Once, f3: Once, f24: MaybeInClosure, f7: Once, f22: MaybeInClosure})
// [CoreOpt] post splitting: Insn(iref=%5) -> BlockParam(bref=b9, bpref=$b.0)
// [CoreOpt] post splitting: Insn(iref=%5) -> BlockParam(bref=b9, bpref=$b.0)
// [CoreOpt] post splitting: Insn(iref=%5) -> BlockParam(bref=b9, bpref=$b.0)
// [CoreOpt] post splitting: Insn(iref=%5) -> BlockParam(bref=b9, bpref=$b.0)
// [CoreOpt] post splitting: Insn(iref=%5) -> BlockParam(bref=b9, bpref=$b.0)
// [CoreOpt] post splitting: Insn(iref=%5) -> BlockParam(bref=b9, bpref=$b.0)
// [CoreOpt] post splitting: Insn(iref=%5) -> BlockParam(bref=b9, bpref=$b.0)
// [CoreOpt] post splitting: Insn(iref=%5) -> BlockParam(bref=b9, bpref=$b.0)
// [CoreOpt] post splitting: Insn(iref=%0) -> BlockParam(bref=b10, bpref=$b.0)
// [CoreOpt] post splitting: Insn(iref=%0) -> BlockParam(bref=b10, bpref=$b.0)
// [CoreOpt] post splitting: Insn(iref=%0) -> BlockParam(bref=b10, bpref=$b.0)
// [CoreOpt] post splitting: Insn(iref=%0) -> BlockParam(bref=b10, bpref=$b.0)
// [CoreOpt] post splitting: Insn(iref=%0) -> BlockParam(bref=b10, bpref=$b.0)
// [CoreOpt] post splitting: Insn(iref=%0) -> BlockParam(bref=b10, bpref=$b.0)
// [CoreOpt] post splitting: Insn(iref=%0) -> BlockParam(bref=b10, bpref=$b.0)
// [CoreOpt] post splitting: Insn(iref=%0) -> BlockParam(bref=b10, bpref=$b.0)
// [CoreOpt] post splitting: Insn(iref=%0) -> BlockParam(bref=b10, bpref=$b.0)
// [CoreOpt] post splitting: Insn(iref=%0) -> BlockParam(bref=b4, bpref=$b.0)
// [CoreOpt] post splitting: Insn(iref=%0) -> BlockParam(bref=b4, bpref=$b.0)
// [CoreOpt] post splitting: Insn(iref=%0) -> BlockParam(bref=b4, bpref=$b.0)
// [CoreOpt] post splitting: Insn(iref=%0) -> BlockParam(bref=b4, bpref=$b.0)
// [CoreOpt] post splitting: Insn(iref=%5) -> BlockParam(bref=b5, bpref=$b.0)
// [CoreOpt] post splitting: Insn(iref=%5) -> BlockParam(bref=b5, bpref=$b.0)
// [CoreOpt] post splitting: Insn(iref=%5) -> BlockParam(bref=b5, bpref=$b.0)
// [CoreOpt] post splitting: Insn(iref=%5) -> BlockParam(bref=b5, bpref=$b.0)
// [CoreOpt] post splitting: Insn(iref=%5) -> BlockParam(bref=b5, bpref=$b.0)
// [CoreOpt] post splitting: Insn(iref=%5) -> BlockParam(bref=b9, bpref=$b.0)
// [CoreOpt] post splitting: Insn(iref=%5) -> BlockParam(bref=b9, bpref=$b.0)
// [CoreOpt] post splitting: Insn(iref=%5) -> BlockParam(bref=b9, bpref=$b.0)
// [CoreOpt] post splitting: Insn(iref=%5) -> BlockParam(bref=b9, bpref=$b.0)
// [CoreOpt] post splitting: Insn(iref=%5) -> BlockParam(bref=b9, bpref=$b.0)
// [CoreOpt] post splitting: Insn(iref=%5) -> BlockParam(bref=b9, bpref=$b.0)
// [CoreOpt] post splitting: Insn(iref=%5) -> BlockParam(bref=b9, bpref=$b.0)
// [CoreOpt] post splitting: Insn(iref=%5) -> BlockParam(bref=b9, bpref=$b.0)
// [CoreOpt] post splitting: Insn(iref=%0) -> BlockParam(bref=b10, bpref=$b.0)
// [CoreOpt] post splitting: Insn(iref=%0) -> BlockParam(bref=b10, bpref=$b.0)
// [CoreOpt] post splitting: Insn(iref=%0) -> BlockParam(bref=b10, bpref=$b.0)
// [CoreOpt] post splitting: Insn(iref=%0) -> BlockParam(bref=b10, bpref=$b.0)
// [CoreOpt] post splitting: Insn(iref=%0) -> BlockParam(bref=b10, bpref=$b.0)
// [CoreOpt] post splitting: Insn(iref=%0) -> BlockParam(bref=b10, bpref=$b.0)
// [CoreOpt] post splitting: Insn(iref=%0) -> BlockParam(bref=b10, bpref=$b.0)
// [CoreOpt] post splitting: Insn(iref=%0) -> BlockParam(bref=b10, bpref=$b.0)
// [CoreOpt] post splitting: Insn(iref=%0) -> BlockParam(bref=b10, bpref=$b.0)
// [CoreOpt] post splitting: Insn(iref=%0) -> BlockParam(bref=b4, bpref=$b.0)
// [CoreOpt] post splitting: Insn(iref=%0) -> BlockParam(bref=b4, bpref=$b.0)
// [CoreOpt] post splitting: Insn(iref=%0) -> BlockParam(bref=b4, bpref=$b.0)
// [CoreOpt] post splitting: Insn(iref=%0) -> BlockParam(bref=b4, bpref=$b.0)
// [CoreOpt] aux.12703 is inlining Call(ty=Int32, f=f5, args=[Insn(iref=%2), FnParam(fref=f6, fpref=$f.4)])
// [CoreOpt] shifted callee .fn aux.12702 #f5 : fn(int32, int32) -> int32
// [CoreOpt] .freevars ()
// [CoreOpt] .entry b11 {
// [CoreOpt]   .bb #b11 () {
// [CoreOpt]     let %8: bool = le($f1, $f0)
// [CoreOpt]     br %8 b12() b13()
// [CoreOpt]   }
// [CoreOpt]   .bb #b12 () {
// [CoreOpt]     jump b14(0)
// [CoreOpt]   }
// [CoreOpt]   .bb #b13 () {
// [CoreOpt]     jump b14(1)
// [CoreOpt]   }
// [CoreOpt]   .bb #b14 (int32) {
// [CoreOpt]     return $b14.0
// [CoreOpt]   }
// [CoreOpt] }
// [CoreOpt] 
// [CoreOpt] aux.12703 is inlining Call(ty=Tuple(fields=[Int32, Int32]), f=f4, args=[Unit, FnParam(fref=f6, fpref=$f.1), FnParam(fref=f6, fpref=$f.2), FnParam(fref=f6, fpref=$f.3), FnParam(fref=f6, fpref=$f.5), FnParam(fref=f6, fpref=$f.6)])
// [CoreOpt] shifted callee .fn aux.12701 #f4 : fn(unit, int32, int32, int32, array[int32], array[int32]) -> (int32, int32)
// [CoreOpt] .freevars ()
// [CoreOpt] .entry b15 {
// [CoreOpt]   .bb #b15 () {
// [CoreOpt]     let %9: (int32, int32) = call f2((), $f1, $f2, $f4, $f5)
// [CoreOpt]     jump b19(%9)
// [CoreOpt]   }
// [CoreOpt]   .bb #b16 () {
// [CoreOpt]     let _ = alloc <m15: (int32, int32) heap(2)> <- [0] = 0, [1] = 0
// [CoreOpt]     jump b18(f4.m15)
// [CoreOpt]   }
// [CoreOpt]   .bb #b17 () {
// [CoreOpt]     let %14: int32 = call f3(%11, $f3)
// [CoreOpt]     jump b20(%14)
// [CoreOpt]   }
// [CoreOpt]   .bb #b18 ((int32, int32)) {
// [CoreOpt]     return $b18.0
// [CoreOpt]   }
// [CoreOpt]   .bb #b19 ((int32, int32)) {
// [CoreOpt]     let %10: int32 = load int32 field($b19.0, 0 * @(@32, @(@32, @32)))
// [CoreOpt]     let %11: int32 = load int32 field($b19.0, 1 * @(@32, @(@32, @32)))
// [CoreOpt]     let %12: bool = eq(%10, 0)
// [CoreOpt]     br %12 b16() b17()
// [CoreOpt]   }
// [CoreOpt]   .bb #b20 (int32) {
// [CoreOpt]     let _ = alloc <m16: (int32, int32) heap(2)> <- [0] = 1, [1] = $b20.0
// [CoreOpt]     jump b18(f4.m16)
// [CoreOpt]   }
// [CoreOpt] }
// [CoreOpt] 
// [CoreOpt] aux.12701 is inlining Call(ty=Int32, f=f3, args=[Insn(iref=%2), FnParam(fref=f4, fpref=$f.3)])
// [CoreOpt] shifted callee .fn aux.12700 #f3 : fn(int32, int32) -> int32
// [CoreOpt] .freevars ()
// [CoreOpt] .entry b7 {
// [CoreOpt]   .bb #b7 () {
// [CoreOpt]     let %7: int32 = add($f1, $f0)
// [CoreOpt]     return %7
// [CoreOpt]   }
// [CoreOpt] }
// [CoreOpt] 
// [CoreOpt] aux.12701 is inlining Call(ty=Tuple(fields=[Int32, Int32]), f=f2, args=[Unit, FnParam(fref=f4, fpref=$f.1), FnParam(fref=f4, fpref=$f.2), FnParam(fref=f4, fpref=$f.4), FnParam(fref=f4, fpref=$f.5)])
// [CoreOpt] shifted callee .fn aux.12699 #f2 : fn(unit, int32, int32, array[int32], array[int32]) -> (int32, int32)
// [CoreOpt] .freevars ()
// [CoreOpt] .entry b8 {
// [CoreOpt]   .bb #b8 () {
// [CoreOpt]     let %8: (int32, int32) = call f0((), $f1, $f3)
// [CoreOpt]     jump b12(%8)
// [CoreOpt]   }
// [CoreOpt]   .bb #b9 () {
// [CoreOpt]     let %12: (int32, int32) = call f1((), $f2, $f4)
// [CoreOpt]     jump b11(%12)
// [CoreOpt]   }
// [CoreOpt]   .bb #b10 () {
// [CoreOpt]     let _ = alloc <m8: (int32, int32) heap(2)> <- [0] = 1, [1] = %10
// [CoreOpt]     jump b11(f2.m8)
// [CoreOpt]   }
// [CoreOpt]   .bb #b11 ((int32, int32)) {
// [CoreOpt]     return $b11.0
// [CoreOpt]   }
// [CoreOpt]   .bb #b12 ((int32, int32)) {
// [CoreOpt]     let %9: int32 = load int32 field($b12.0, 0 * @(@32, @(@32, @32)))
// [CoreOpt]     let %10: int32 = load int32 field($b12.0, 1 * @(@32, @(@32, @32)))
// [CoreOpt]     let %11: bool = eq(%9, 0)
// [CoreOpt]     br %11 b9() b10()
// [CoreOpt]   }
// [CoreOpt] }
// [CoreOpt] 
// [CoreOpt] aux.12705 is inlining Call(ty=Int32, f=f7, args=[Insn(iref=%2), FnParam(fref=f8, fpref=$f.5)])
// [CoreOpt] shifted callee .fn aux.12704 #f7 : fn(int32, int32) -> int32
// [CoreOpt] .freevars ()
// [CoreOpt] .entry b11 {
// [CoreOpt]   .bb #b11 () {
// [CoreOpt]     let %8: bool = le($f0, $f1)
// [CoreOpt]     br %8 b12() b13()
// [CoreOpt]   }
// [CoreOpt]   .bb #b12 () {
// [CoreOpt]     jump b14(0)
// [CoreOpt]   }
// [CoreOpt]   .bb #b13 () {
// [CoreOpt]     jump b14(1)
// [CoreOpt]   }
// [CoreOpt]   .bb #b14 (int32) {
// [CoreOpt]     return $b14.0
// [CoreOpt]   }
// [CoreOpt] }
// [CoreOpt] 
// [CoreOpt] aux.12705 is inlining Call(ty=Tuple(fields=[Int32, Int32]), f=f6, args=[Unit, FnParam(fref=f8, fpref=$f.1), FnParam(fref=f8, fpref=$f.2), FnParam(fref=f8, fpref=$f.3), FnParam(fref=f8, fpref=$f.4), FnParam(fref=f8, fpref=$f.6), FnParam(fref=f8, fpref=$f.7)])
// [CoreOpt] shifted callee .fn aux.12703 #f6 : fn(unit, int32, int32, int32, int32, array[int32], array[int32]) -> (int32, int32)
// [CoreOpt] .freevars ()
// [CoreOpt] .entry b15 {
// [CoreOpt]   .bb #b15 () {
// [CoreOpt]     jump b16($f0)
// [CoreOpt]   }
// [CoreOpt]   .loop #b16 pre #Some(b15) header #b17 {
// [CoreOpt]     .block #b18
// [CoreOpt]     .block #b19
// [CoreOpt]     .block #b20
// [CoreOpt]     .block #b21
// [CoreOpt]     .block #b22
// [CoreOpt]     .block #b23
// [CoreOpt]   }
// [CoreOpt]   .bb #b17 (unit) {
// [CoreOpt]     jump b30()
// [CoreOpt]   }
// [CoreOpt]   .bb #b18 () {
// [CoreOpt]     let _ = alloc <m15: (int32, int32) heap(2)> <- [0] = 0, [1] = 0
// [CoreOpt]     jump b23(f6.m15)
// [CoreOpt]   }
// [CoreOpt]   .bb #b19 () {
// [CoreOpt]     jump b26()
// [CoreOpt]   }
// [CoreOpt]   .bb #b20 () {
// [CoreOpt]     let _ = alloc <m16: (int32, int32) heap(2)> <- [0] = 1, [1] = %11
// [CoreOpt]     jump b22(f6.m16)
// [CoreOpt]   }
// [CoreOpt]   .bb #b21 () {
// [CoreOpt]     jump b17(())
// [CoreOpt]   }
// [CoreOpt]   .bb #b22 ((int32, int32)) {
// [CoreOpt]     jump b23($b22.0)
// [CoreOpt]   }
// [CoreOpt]   .bb #b23 ((int32, int32)) {
// [CoreOpt]     return $b23.0
// [CoreOpt]   }
// [CoreOpt]   .bb #b24 (int32) {
// [CoreOpt]     let %15: bool = eq($b24.0, 0)
// [CoreOpt]     br %15 b20() b21()
// [CoreOpt]   }
// [CoreOpt]   .bb #b25 ((int32, int32)) {
// [CoreOpt]     let %10: int32 = load int32 field($b25.0, 0 * @(@32, @(@32, @32)))
// [CoreOpt]     let %11: int32 = load int32 field($b25.0, 1 * @(@32, @(@32, @32)))
// [CoreOpt]     let %12: bool = eq(%10, 0)
// [CoreOpt]     br %12 b18() b19()
// [CoreOpt]   }
// [CoreOpt]   .bb #b26 () {
// [CoreOpt]     let %17: bool = le($f4, %11)
// [CoreOpt]     br %17 b27() b28()
// [CoreOpt]   }
// [CoreOpt]   .bb #b27 () {
// [CoreOpt]     jump b29(0)
// [CoreOpt]   }
// [CoreOpt]   .bb #b28 () {
// [CoreOpt]     jump b29(1)
// [CoreOpt]   }
// [CoreOpt]   .bb #b29 (int32) {
// [CoreOpt]     jump b24($b29.0)
// [CoreOpt]   }
// [CoreOpt]   .bb #b30 () {
// [CoreOpt]     let %18: (int32, int32) = call f2((), $f1, $f2, $f5, $f6)
// [CoreOpt]     jump b34(%18)
// [CoreOpt]   }
// [CoreOpt]   .bb #b31 () {
// [CoreOpt]     let _ = alloc <m30: (int32, int32) heap(2)> <- [0] = 0, [1] = 0
// [CoreOpt]     jump b33(f6.m30)
// [CoreOpt]   }
// [CoreOpt]   .bb #b32 () {
// [CoreOpt]     let %23: int32 = call f3(%20, $f3)
// [CoreOpt]     jump b35(%23)
// [CoreOpt]   }
// [CoreOpt]   .bb #b33 ((int32, int32)) {
// [CoreOpt]     jump b25($b33.0)
// [CoreOpt]   }
// [CoreOpt]   .bb #b34 ((int32, int32)) {
// [CoreOpt]     let %19: int32 = load int32 field($b34.0, 0 * @(@32, @(@32, @32)))
// [CoreOpt]     let %20: int32 = load int32 field($b34.0, 1 * @(@32, @(@32, @32)))
// [CoreOpt]     let %21: bool = eq(%19, 0)
// [CoreOpt]     br %21 b31() b32()
// [CoreOpt]   }
// [CoreOpt]   .bb #b35 (int32) {
// [CoreOpt]     let _ = alloc <m31: (int32, int32) heap(2)> <- [0] = 1, [1] = $b35.0
// [CoreOpt]     jump b33(f6.m31)
// [CoreOpt]   }
// [CoreOpt] }
// [CoreOpt] 
// [CoreOpt] aux.12699 is inlining Call(ty=Tuple(fields=[Int32, Int32]), f=f0, args=[Unit, FnParam(fref=f2, fpref=$f.1), FnParam(fref=f2, fpref=$f.3)])
// [CoreOpt] shifted callee .fn aux.12697 #f0 : fn(unit, int32, array[int32]) -> (int32, int32)
// [CoreOpt] .freevars ()
// [CoreOpt] .entry b6 {
// [CoreOpt]   .bb #b6 () {
// [CoreOpt]     let %6: int32 = load int32 field($f2, 0 * @32)
// [CoreOpt]     let %7: bool = eq(%6, $f1)
// [CoreOpt]     br %7 b7() b8()
// [CoreOpt]   }
// [CoreOpt]   .bb #b7 () {
// [CoreOpt]     let _ = alloc <m6: (int32, int32) heap(2)> <- [0] = 0, [1] = 0
// [CoreOpt]     jump b9(f0.m6)
// [CoreOpt]   }
// [CoreOpt]   .bb #b8 () {
// [CoreOpt]     let %9: int32 = add(%6, 1)
// [CoreOpt]     let _ = store int32 field($f2, 0 * @32) <- %9
// [CoreOpt]     let _ = alloc <m7: (int32, int32) heap(2)> <- [0] = 1, [1] = %6
// [CoreOpt]     jump b9(f0.m7)
// [CoreOpt]   }
// [CoreOpt]   .bb #b9 ((int32, int32)) {
// [CoreOpt]     return $b9.0
// [CoreOpt]   }
// [CoreOpt] }
// [CoreOpt] 
// [CoreOpt] Remove dead function: f6
// [CoreOpt] Remove dead function: f4
// [CoreOpt] Remove dead function: f5
// [CoreOpt] Remove dead function: f7
