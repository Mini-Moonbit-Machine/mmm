let rec filter.15: Fun([Unit], Tuple([Int, Int])) = (stream.16: Fun([Unit], Tuple([Int, Int])), f.17: Fun([Int], Int)) {
  let rec aux.18: Tuple([Int, Int]) = (u.19: Var({val: Some(Unit)})) {
    let _20: Unit = Unit
    let _21: Tuple([Int, Int]) = Apply(stream.16, [_20, ])
    let (ok.22: Var({val: Some(Int)}), val.23: Var({val: Some(Int)})) = _21
    let _24: Int = Int(0)
    if (ok.22 == _24) then {
      let _25: Int = Int(0)
      let _26: Int = Int(0)
      Tuple([_25, _26, ])
    } else {
      let r.27: Int = Apply(f.17, [val.23, ])
      let _28: Int = Int(0)
      if (r.27 == _28) then {
        let _29: Int = Int(1)
        Tuple([_29, val.23, ])
      } else {
        let _30: Unit = Unit
        Apply(aux.18, [_30, ])
      }
    }
  }
  Var(aux.18)
}
let rec range.43: Fun([Unit], Tuple([Int, Int])) = (from.44: Int, to.45: Int) {
  let _46: Int = Int(1)
  let state.47: Array(Int) = ExtApply(minimbt_create_array, [_46, from.44, ])
  let rec aux.48: Tuple([Int, Int]) = (u.49: Var({val: Some(Unit)})) {
    let _50: Int = Int(0)
    let val.51: Int = Get state.47[_50]
    if (val.51 == to.45) then {
      let _52: Int = Int(0)
      let _53: Int = Int(0)
      Tuple([_52, _53, ])
    } else {
      let _54: Int = Int(0)
      let _55: Int = Int(1)
      let _56: Int = Add(val.51, _55)
      let _57: Unit = Put state.47[_54] = _56
      let _58: Int = Int(1)
      Tuple([_58, val.51, ])
    }
  }
  Var(aux.48)
}
let rec fold.63: Int = (stream.64: Fun([Unit], Tuple([Int, Int])), f.65: Fun([Int, Int], Int), acc.66: Int) {
  let _67: Unit = Unit
  let _68: Tuple([Int, Int]) = Apply(stream.64, [_67, ])
  let (ok.69: Var({val: Some(Int)}), val.70: Var({val: Some(Int)})) = _68
  let _71: Int = Int(0)
  if (ok.69 == _71) then {
    Var(acc.66)
  } else {
    let _72: Int = Apply(f.65, [acc.66, val.70, ])
    let _108: Unit = Unit
    let _109: Tuple([Int, Int]) = Apply(stream.64, [_108, ])
    let (ok.110: Var({val: Some(Int)}), val.111: Var({val: Some(Int)})) = _109
    let _112: Int = Int(0)
    if (ok.110 == _112) then {
      Var(_72)
    } else {
      let _113: Int = Apply(f.65, [_72, val.111, ])
      Apply(fold.63, [stream.64, f.65, _113, ])
    }
  }
}
let rec main.87: Var({val: Some(Unit)}) = () {
  let _88: Int = Int(0)
  let _89: Int = Int(100)
  let range100.90: Fun([Unit], Tuple([Int, Int])) = Apply(range.43, [_88, _89, ])
  let _91: Int = Int(0)
  let _92: Int = Int(1000)
  let range1000.93: Fun([Unit], Tuple([Int, Int])) = Apply(range.43, [_91, _92, ])
  let rec aux.232: Tuple([Int, Int]) = (u.233: Var({val: Some(Unit)})) {
    let _234: Unit = Unit
    let _235: Tuple([Int, Int]) = Apply(range100.90, [_234, ])
    let (ok.236: Var({val: Some(Int)}), val.237: Var({val: Some(Int)})) = _235
    let _238: Int = Int(0)
    if (ok.236 == _238) then {
      let _239: Unit = Unit
      Apply(range1000.93, [_239, ])
    } else {
      let _240: Int = Int(1)
      Tuple([_240, val.237, ])
    }
  }
  let catt.94: Fun([Unit], Tuple([Int, Int])) = Var(aux.232)
  let _95: Int = Int(1)
  let rec aux.296: Int = (y.297: Int) {
    Add(_95, y.297)
  }
  let _96: Fun([Int], Int) = Var(aux.296)
  let rec aux.320: Tuple([Int, Int]) = (u.321: Var({val: Some(Unit)})) {
    let _322: Unit = Unit
    let _323: Tuple([Int, Int]) = Apply(catt.94, [_322, ])
    let (ok.324: Var({val: Some(Int)}), val.325: Var({val: Some(Int)})) = _323
    let _326: Int = Int(0)
    if (ok.324 == _326) then {
      let _327: Int = Int(0)
      let _328: Int = Int(0)
      Tuple([_327, _328, ])
    } else {
      let _329: Int = Int(1)
      let _330: Int = Apply(_96, [val.325, ])
      Tuple([_329, _330, ])
    }
  }
  let addone.97: Fun([Unit], Tuple([Int, Int])) = Var(aux.320)
  let _98: Int = Int(50)
  let rec aux.341: Int = (y.342: Int) {
    if (_98 <= y.342) then {
      Int(0)
    } else {
      Int(1)
    }
  }
  let _99: Fun([Int], Int) = Var(aux.341)
  let over50.100: Fun([Unit], Tuple([Int, Int])) = Apply(filter.15, [addone.97, _99, ])
  let _101: Int = Int(1200)
  let rec aux.347: Int = (y.348: Int) {
    if (y.348 <= _101) then {
      Int(0)
    } else {
      Int(1)
    }
  }
  let _102: Fun([Int], Int) = Var(aux.347)
  let under1200.103: Fun([Unit], Tuple([Int, Int])) = Apply(filter.15, [over50.100, _102, ])
  let rec add.349: Int = (x.350: Int, y.351: Int) {
    Add(x.350, y.351)
  }
  let _352: Int = Int(0)
  let sum.104: Int = Apply(fold.63, [under1200.103, add.349, _352, ])
  let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
  let _106: Int = Int(10)
  let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
  Unit
}
Apply(main.87, [])