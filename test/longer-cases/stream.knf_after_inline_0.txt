let rec fold.63: Int = (stream.64: Fun([Unit], Tuple([Int, Int])), f.65: Fun([Int, Int], Int), acc.66: Int) {
  let _67: Unit = Unit
  let _68: Tuple([Int, Int]) = Apply(stream.64, [_67, ])
  let (ok.69: Var({val: Some(Int)}), val.70: Var({val: Some(Int)})) = _68
  let _71: Int = Int(0)
  if (ok.69 == _71) then {
    Var(acc.66)
  } else {
    let _72: Int = Apply(f.65, [acc.66, val.70, ])
    let _108: Unit = Unit
    let _109: Tuple([Int, Int]) = Apply(stream.64, [_108, ])
    let (ok.110: Var({val: Some(Int)}), val.111: Var({val: Some(Int)})) = _109
    let _112: Int = Int(0)
    if (ok.110 == _112) then {
      Var(_72)
    } else {
      let _113: Int = Apply(f.65, [_72, val.111, ])
      Apply(fold.63, [stream.64, f.65, _113, ])
    }
  }
}
let rec main.87: Var({val: Some(Unit)}) = () {
  let _88: Int = Int(0)
  let _89: Int = Int(100)
  let range100.90: Fun([Unit], Tuple([Int, Int])) = 
    let _120: Int = Int(1)
    let state.121: Array(Int) = ExtApply(minimbt_create_array, [_120, _88, ])
    let rec aux.122: Tuple([Int, Int]) = (u.123: Var({val: Some(Unit)})) {
      let _124: Int = Int(0)
      let val.125: Int = Get state.121[_124]
      if (val.125 == _89) then {
        let _126: Int = Int(0)
        let _127: Int = Int(0)
        Tuple([_126, _127, ])
      } else {
        let _128: Int = Int(0)
        let _129: Int = Int(1)
        let _130: Int = Add(val.125, _129)
        let _131: Unit = Put state.121[_128] = _130
        let _132: Int = Int(1)
        Tuple([_132, val.125, ])
      }
    }
    Var(aux.122)
  let _91: Int = Int(0)
  let _92: Int = Int(1000)
  let range1000.93: Fun([Unit], Tuple([Int, Int])) = 
    let _133: Int = Int(1)
    let state.134: Array(Int) = ExtApply(minimbt_create_array, [_133, _91, ])
    let rec aux.135: Tuple([Int, Int]) = (u.136: Var({val: Some(Unit)})) {
      let _137: Int = Int(0)
      let val.138: Int = Get state.134[_137]
      if (val.138 == _92) then {
        let _139: Int = Int(0)
        let _140: Int = Int(0)
        Tuple([_139, _140, ])
      } else {
        let _141: Int = Int(0)
        let _142: Int = Int(1)
        let _143: Int = Add(val.138, _142)
        let _144: Unit = Put state.134[_141] = _143
        let _145: Int = Int(1)
        Tuple([_145, val.138, ])
      }
    }
    Var(aux.135)
  let catt.94: Fun([Unit], Tuple([Int, Int])) = 
    let rec aux.146: Tuple([Int, Int]) = (u.147: Var({val: Some(Unit)})) {
      let _148: Unit = Unit
      let _149: Tuple([Int, Int]) = Apply(range100.90, [_148, ])
      let (ok.150: Var({val: Some(Int)}), val.151: Var({val: Some(Int)})) = _149
      let _152: Int = Int(0)
      if (ok.150 == _152) then {
        let _153: Unit = Unit
        Apply(range1000.93, [_153, ])
      } else {
        let _154: Int = Int(1)
        Tuple([_154, val.151, ])
      }
    }
    Var(aux.146)
  let _95: Int = Int(1)
  let _96: Fun([Int], Int) = 
    let rec aux.155: Int = (y.156: Int) {
      Add(_95, y.156)
    }
    Var(aux.155)
  let addone.97: Fun([Unit], Tuple([Int, Int])) = 
    let rec aux.157: Tuple([Int, Int]) = (u.158: Var({val: Some(Unit)})) {
      let _159: Unit = Unit
      let _160: Tuple([Int, Int]) = Apply(catt.94, [_159, ])
      let (ok.161: Var({val: Some(Int)}), val.162: Var({val: Some(Int)})) = _160
      let _163: Int = Int(0)
      if (ok.161 == _163) then {
        let _164: Int = Int(0)
        let _165: Int = Int(0)
        Tuple([_164, _165, ])
      } else {
        let _166: Int = Int(1)
        let _167: Int = Apply(_96, [val.162, ])
        Tuple([_166, _167, ])
      }
    }
    Var(aux.157)
  let _98: Int = Int(50)
  let _99: Fun([Int], Int) = 
    let rec aux.168: Int = (y.169: Int) {
      if (_98 <= y.169) then {
        Int(0)
      } else {
        Int(1)
      }
    }
    Var(aux.168)
  let over50.100: Fun([Unit], Tuple([Int, Int])) = 
    let rec aux.170: Tuple([Int, Int]) = (u.171: Var({val: Some(Unit)})) {
      let _172: Unit = Unit
      let _173: Tuple([Int, Int]) = Apply(addone.97, [_172, ])
      let (ok.174: Var({val: Some(Int)}), val.175: Var({val: Some(Int)})) = _173
      let _176: Int = Int(0)
      if (ok.174 == _176) then {
        let _177: Int = Int(0)
        let _178: Int = Int(0)
        Tuple([_177, _178, ])
      } else {
        let r.179: Int = Apply(_99, [val.175, ])
        let _180: Int = Int(0)
        if (r.179 == _180) then {
          let _181: Int = Int(1)
          Tuple([_181, val.175, ])
        } else {
          let _182: Unit = Unit
          Apply(aux.170, [_182, ])
        }
      }
    }
    Var(aux.170)
  let _101: Int = Int(1200)
  let _102: Fun([Int], Int) = 
    let rec aux.183: Int = (y.184: Int) {
      if (y.184 <= _101) then {
        Int(0)
      } else {
        Int(1)
      }
    }
    Var(aux.183)
  let under1200.103: Fun([Unit], Tuple([Int, Int])) = 
    let rec aux.185: Tuple([Int, Int]) = (u.186: Var({val: Some(Unit)})) {
      let _187: Unit = Unit
      let _188: Tuple([Int, Int]) = Apply(over50.100, [_187, ])
      let (ok.189: Var({val: Some(Int)}), val.190: Var({val: Some(Int)})) = _188
      let _191: Int = Int(0)
      if (ok.189 == _191) then {
        let _192: Int = Int(0)
        let _193: Int = Int(0)
        Tuple([_192, _193, ])
      } else {
        let r.194: Int = Apply(_102, [val.190, ])
        let _195: Int = Int(0)
        if (r.194 == _195) then {
          let _196: Int = Int(1)
          Tuple([_196, val.190, ])
        } else {
          let _197: Unit = Unit
          Apply(aux.185, [_197, ])
        }
      }
    }
    Var(aux.185)
  let sum.104: Int = 
    let rec add.198: Int = (x.199: Int, y.200: Int) {
      Add(x.199, y.200)
    }
    let _201: Int = Int(0)
    Apply(fold.63, [under1200.103, add.198, _201, ])
  let _105: Unit = ExtApply(minimbt_print_int, [sum.104, ])
  let _106: Int = Int(10)
  let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
  Unit
}
Apply(main.87, [])