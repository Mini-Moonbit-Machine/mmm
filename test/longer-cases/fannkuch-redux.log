// [Main] function thunk_main(k) {
// [Main]   function fannkuch_1(n_3, k) {
// [Main]     function gen_perm1_4(len_6, k) {
// [Main]       const _7 = 0;
// [Main]       const arr_8 = minimbt_create_array($force(len_6), $force(_7));
// [Main]       function init_arr_9(i_11, k) {
// [Main]         const _12 = 1;
// [Main]         const _13 = len_6 - _12;
// [Main]         if (i_11 <= _13) {
// [Main]           const _15 = arr_8[i_11] = i_11;
// [Main]           const _16 = 1;
// [Main]           const _17 = i_11 + _16;
// [Main]           return $thunk(() => init_arr_9(_17, k))
// [Main]         } else {
// [Main]           return k(null)
// [Main]         }
// [Main]       }
// [Main]       const _18 = 0;
// [Main]       return $thunk(() => init_arr_9(_18, function (_20) {
// [Main]         return $thunk(() => k(arr_8))
// [Main]       }
// [Main]       ))
// [Main]     }
// [Main]     return $thunk(() => gen_perm1_4(n_3, function (perm1_21) {
// [Main]       const _22 = 0;
// [Main]       const perm_23 = minimbt_create_array($force(n_3), $force(_22));
// [Main]       const _24 = 0;
// [Main]       const count_25 = minimbt_create_array($force(n_3), $force(_24));
// [Main]       const _26 = 1;
// [Main]       const _27 = 0;
// [Main]       const flips_28 = minimbt_create_array($force(_26), $force(_27));
// [Main]       const _29 = 1;
// [Main]       const _30 = 0;
// [Main]       const max_flips_31 = minimbt_create_array($force(_29), $force(_30));
// [Main]       const _32 = 1;
// [Main]       const _33 = 0;
// [Main]       const check_sum_34 = minimbt_create_array($force(_32), $force(_33));
// [Main]       const _35 = 1;
// [Main]       const _36 = 0;
// [Main]       const nperm_37 = minimbt_create_array($force(_35), $force(_36));
// [Main]       const _38 = 1;
// [Main]       const r_39 = minimbt_create_array($force(_38), $force(n_3));
// [Main]       function compute_40(r_42, k) {
// [Main]         const _43 = 1;
// [Main]         const _44 = 0;
// [Main]         const _45 = r_42[_44];
// [Main]         if (_43 <= _45) {
// [Main]           function copy_perm_46(i_48, k) {
// [Main]             const _49 = 1;
// [Main]             const _50 = n_3 - _49;
// [Main]             if (i_48 <= _50) {
// [Main]               const _51 = perm1_21[i_48];
// [Main]               const _53 = perm_23[i_48] = _51;
// [Main]               const _54 = 1;
// [Main]               const _55 = i_48 + _54;
// [Main]               return $thunk(() => copy_perm_46(_55, k))
// [Main]             } else {
// [Main]               return k(null)
// [Main]             }
// [Main]           }
// [Main]           const _56 = 0;
// [Main]           return $thunk(() => copy_perm_46(_56, function (_58) {
// [Main]             function init_count_59(k) {
// [Main]               const _60 = 0;
// [Main]               const _61 = r_42[_60];
// [Main]               const _62 = 1;
// [Main]               const _79 = $force((() => {
// [Main]                 if (_61 === _62) {
// [Main]                   return null
// [Main]                 } else {
// [Main]                   const _63 = 0;
// [Main]                   const _64 = r_42[_63];
// [Main]                   const _65 = 1;
// [Main]                   const _66 = _64 - _65;
// [Main]                   const _67 = 0;
// [Main]                   const _68 = r_42[_67];
// [Main]                   const _70 = count_25[_66] = _68;
// [Main]                   const _71 = 0;
// [Main]                   const _72 = 0;
// [Main]                   const _73 = r_42[_72];
// [Main]                   const _74 = 1;
// [Main]                   const _75 = _73 - _74;
// [Main]                   const _77 = r_42[_71] = _75;
// [Main]                   return $thunk(() => init_count_59(k))
// [Main]                 }
// [Main]               })());
// [Main]               return k(null)
// [Main]             }
// [Main]             return $thunk(() => init_count_59(function (_81) {
// [Main]               const _82 = 0;
// [Main]               const _83 = 0;
// [Main]               const _85 = flips_28[_82] = _83;
// [Main]               const _86 = 1;
// [Main]               const _87 = 0;
// [Main]               const _88 = perm_23[_87];
// [Main]               const k_89 = minimbt_create_array($force(_86), $force(_88));
// [Main]               function do_flip_90(k_92, k) {
// [Main]                 const _93 = 0;
// [Main]                 const _94 = k_92[_93];
// [Main]                 const _95 = 0;
// [Main]                 if (_94 === _95) {
// [Main]                   return k(null)
// [Main]                 } else {
// [Main]                   const _96 = 1;
// [Main]                   const _97 = 0;
// [Main]                   const t_98 = minimbt_create_array($force(_96), $force(_97));
// [Main]                   function flip_loop_99(i_101, k) {
// [Main]                     const _102 = 0;
// [Main]                     const _103 = k_92[_102];
// [Main]                     const _104 = 2;
// [Main]                     const _105 = _103 / _104;
// [Main]                     if (i_101 <= _105) {
// [Main]                       const _106 = 0;
// [Main]                       const _107 = perm_23[i_101];
// [Main]                       const _109 = t_98[_106] = _107;
// [Main]                       const _110 = 0;
// [Main]                       const _111 = k_92[_110];
// [Main]                       const _112 = _111 - i_101;
// [Main]                       const _113 = perm_23[_112];
// [Main]                       const _115 = perm_23[i_101] = _113;
// [Main]                       const _116 = 0;
// [Main]                       const _117 = k_92[_116];
// [Main]                       const _118 = _117 - i_101;
// [Main]                       const _119 = 0;
// [Main]                       const _120 = t_98[_119];
// [Main]                       const _122 = perm_23[_118] = _120;
// [Main]                       const _123 = 1;
// [Main]                       const _124 = i_101 + _123;
// [Main]                       return $thunk(() => flip_loop_99(_124, k))
// [Main]                     } else {
// [Main]                       return k(null)
// [Main]                     }
// [Main]                   }
// [Main]                   const _125 = 0;
// [Main]                   return $thunk(() => flip_loop_99(_125, function (_127) {
// [Main]                     const _128 = 0;
// [Main]                     const _129 = 0;
// [Main]                     const _130 = perm_23[_129];
// [Main]                     const _132 = k_92[_128] = _130;
// [Main]                     const _133 = 0;
// [Main]                     const _134 = 0;
// [Main]                     const _135 = flips_28[_134];
// [Main]                     const _136 = 1;
// [Main]                     const _137 = _135 + _136;
// [Main]                     const _139 = flips_28[_133] = _137;
// [Main]                     return $thunk(() => do_flip_90(k_92, k))
// [Main]                   }
// [Main]                   ))
// [Main]                 }
// [Main]               }
// [Main]               return $thunk(() => do_flip_90(k_89, function (_141) {
// [Main]                 const _142 = 0;
// [Main]                 const _143 = max_flips_31[_142];
// [Main]                 const _144 = 0;
// [Main]                 const _145 = flips_28[_144];
// [Main]                 const _150 = $force((() => {
// [Main]                   if (_143 <= _145) {
// [Main]                     const _146 = 0;
// [Main]                     const _147 = 0;
// [Main]                     const _148 = flips_28[_147];
// [Main]                     max_flips_31[_146] = _148;
// [Main]                     return null;
// [Main]                   } else {
// [Main]                     return null
// [Main]                   }
// [Main]                 })());
// [Main]                 const _151 = 0;
// [Main]                 const _152 = 0;
// [Main]                 const _153 = check_sum_34[_152];
// [Main]                 const _154 = 0;
// [Main]                 const _155 = flips_28[_154];
// [Main]                 const _156 = 1;
// [Main]                 const _157 = 0;
// [Main]                 const _158 = nperm_37[_157];
// [Main]                 const _159 = 0;
// [Main]                 const _160 = nperm_37[_159];
// [Main]                 const _161 = 2;
// [Main]                 const _162 = _160 / _161;
// [Main]                 const _163 = 2;
// [Main]                 const _164 = _162 * _163;
// [Main]                 const _165 = _158 - _164;
// [Main]                 const _166 = 2;
// [Main]                 const _167 = _165 * _166;
// [Main]                 const _168 = _156 - _167;
// [Main]                 const _169 = _155 * _168;
// [Main]                 const _170 = _153 + _169;
// [Main]                 const _172 = check_sum_34[_151] = _170;
// [Main]                 const _173 = 1;
// [Main]                 const _174 = true;
// [Main]                 const go_175 = minimbt_create_array($force(_173), $force(_174));
// [Main]                 const _176 = 1;
// [Main]                 const _177 = 0;
// [Main]                 const t_178 = minimbt_create_array($force(_176), $force(_177));
// [Main]                 function go_loop_179(k) {
// [Main]                   const _180 = 0;
// [Main]                   const _181 = go_175[_180];
// [Main]                   const _246 = true;
// [Main]                   if (_181 === _246) {
// [Main]                     const _182 = 0;
// [Main]                     const _183 = r_42[_182];
// [Main]                     const _245 = $force((() => {
// [Main]                       if (_183 === n_3) {
// [Main]                         const _184 = 0;
// [Main]                         const _185 = false;
// [Main]                         const _187 = go_175[_184] = _185;
// [Main]                         const _188 = 0;
// [Main]                         const _189 = 0;
// [Main]                         const _191 = r_42[_188] = _189;
// [Main]                         return null
// [Main]                       } else {
// [Main]                         const _192 = 0;
// [Main]                         const _193 = 0;
// [Main]                         const _194 = perm1_21[_193];
// [Main]                         const _196 = t_178[_192] = _194;
// [Main]                         function move_perm1_forward_197(i_199, k) {
// [Main]                           const _200 = 0;
// [Main]                           const _201 = r_42[_200];
// [Main]                           const _202 = 1;
// [Main]                           const _203 = _201 - _202;
// [Main]                           if (i_199 <= _203) {
// [Main]                             const _204 = 1;
// [Main]                             const _205 = i_199 + _204;
// [Main]                             const _206 = perm1_21[_205];
// [Main]                             const _208 = perm1_21[i_199] = _206;
// [Main]                             const _209 = 1;
// [Main]                             const _210 = i_199 + _209;
// [Main]                             return $thunk(() => move_perm1_forward_197(_210, function (_212) {
// [Main]                               return $thunk(() => k(null))
// [Main]                             }
// [Main]                             ))
// [Main]                           } else {
// [Main]                             return k(null)
// [Main]                           }
// [Main]                         }
// [Main]                         const _213 = 0;
// [Main]                         return $thunk(() => move_perm1_forward_197(_213, function (_215) {
// [Main]                           const _216 = 0;
// [Main]                           const _217 = r_42[_216];
// [Main]                           const _218 = 0;
// [Main]                           const _219 = t_178[_218];
// [Main]                           const _221 = perm1_21[_217] = _219;
// [Main]                           const _222 = 0;
// [Main]                           const _223 = r_42[_222];
// [Main]                           const _224 = 0;
// [Main]                           const _225 = r_42[_224];
// [Main]                           const _226 = count_25[_225];
// [Main]                           const _227 = 1;
// [Main]                           const _228 = _226 - _227;
// [Main]                           const _230 = count_25[_223] = _228;
// [Main]                           const _231 = 1;
// [Main]                           const _232 = 0;
// [Main]                           const _233 = r_42[_232];
// [Main]                           const _234 = count_25[_233];
// [Main]                           const _243 = $force((() => {
// [Main]                             if (_231 <= _234) {
// [Main]                               const _235 = 0;
// [Main]                               const _236 = false;
// [Main]                               go_175[_235] = _236;
// [Main]                               return null;
// [Main]                             } else {
// [Main]                               const _237 = 0;
// [Main]                               const _238 = 0;
// [Main]                               const _239 = r_42[_238];
// [Main]                               const _240 = 1;
// [Main]                               const _241 = _239 + _240;
// [Main]                               r_42[_237] = _241;
// [Main]                               return null;
// [Main]                             }
// [Main]                           })());
// [Main]                           return $thunk(() => null)
// [Main]                         }
// [Main]                         ))
// [Main]                       }
// [Main]                     })());
// [Main]                     return $thunk(() => go_loop_179(k))
// [Main]                   } else {
// [Main]                     return k(null)
// [Main]                   }
// [Main]                 }
// [Main]                 return $thunk(() => go_loop_179(function (_248) {
// [Main]                   const _249 = 0;
// [Main]                   const _250 = 0;
// [Main]                   const _251 = nperm_37[_250];
// [Main]                   const _252 = 1;
// [Main]                   const _253 = _251 + _252;
// [Main]                   const _255 = nperm_37[_249] = _253;
// [Main]                   return $thunk(() => compute_40(r_42, k))
// [Main]                 }
// [Main]                 ))
// [Main]               }
// [Main]               ))
// [Main]             }
// [Main]             ))
// [Main]           }
// [Main]           ))
// [Main]         } else {
// [Main]           return k(null)
// [Main]         }
// [Main]       }
// [Main]       return $thunk(() => compute_40(r_39, function (_257) {
// [Main]         const _258 = 0;
// [Main]         const _259 = max_flips_31[_258];
// [Main]         const _260 = 0;
// [Main]         const _261 = check_sum_34[_260];
// [Main]         return $thunk(() => $thunk(() => k([_259, _261])))
// [Main]       }
// [Main]       ))
// [Main]     }
// [Main]     ))
// [Main]   }
// [Main]   function main_262(k) {
// [Main]     const _263 = 9;
// [Main]     return $thunk(() => fannkuch_1(_263, function (_264) {
// [Main]       const [max_flips_266, check_sum_268] = _264;const _270 = minimbt_print_int($force(check_sum_268));
// [Main]       return $thunk(() => k(minimbt_print_int($force(max_flips_266))))
// [Main]     }
// [Main]     ))
// [Main]   }
// [Main]   return $thunk(() => main_262(k))
// [Main] }
// [Main] 
// [Main] function $thunk(lambda) {
// [Main]   return { thunk: lambda };
// [Main] }
// [Main] function $is_thunk(x) {
// [Main]   return x && x.hasOwnProperty('thunk') && x.thunk !== undefined;
// [Main] }
// [Main] function $force(x) {
// [Main]   while ($is_thunk(x)) {
// [Main]     x = x.thunk();
// [Main]   }
// [Main]   return x;
// [Main] }
// [Main] function $trampoline(f, ...args) {
// [Main]   let x = f(...args);
// [Main]   return $force(x);
// [Main] }
// [Main] export default () => $trampoline(thunk_main, x => x);
// [Typer] check: LetRec({tyvars: [], name: ("fannkuch", Tuple([Int, Int])), args: [("n", Int)], body: LetRec({tyvars: [], name: ("gen_perm1", Array(Int)), args: [("len", Int)], body: Let(("arr", Var({val: None})), Array(Var("len"), Int(0)), LetRec({tyvars: [], name: ("init_arr", Unit), args: [("i", Int)], body: If(LE(Var("i"), Prim(Var("len"), Int(1), Sub, kind=None)), Let(("_", Var({val: None})), Put(Var("arr"), Var("i"), Var("i")), App(Var("init_arr"), [Prim(Var("i"), Int(1), Add, kind=None)])), Unit)}, Let(("_", Var({val: None})), App(Var("init_arr"), [Int(0)]), Var("arr"))))}, Let(("perm1", Var({val: None})), App(Var("gen_perm1"), [Var("n")]), Let(("perm", Var({val: None})), Array(Var("n"), Int(0)), Let(("count", Var({val: None})), Array(Var("n"), Int(0)), Let(("flips", Var({val: None})), Array(Int(1), Int(0)), Let(("max_flips", Var({val: None})), Array(Int(1), Int(0)), Let(("check_sum", Var({val: None})), Array(Int(1), Int(0)), Let(("nperm", Var({val: None})), Array(Int(1), Int(0)), Let(("r", Var({val: None})), Array(Int(1), Var("n")), LetRec({tyvars: [], name: ("compute", Unit), args: [("r", Array(Int))], body: If(LE(Int(1), Get(Var("r"), Int(0))), LetRec({tyvars: [], name: ("copy_perm", Unit), args: [("i", Int)], body: If(LE(Var("i"), Prim(Var("n"), Int(1), Sub, kind=None)), Let(("_", Var({val: None})), Put(Var("perm"), Var("i"), Get(Var("perm1"), Var("i"))), App(Var("copy_perm"), [Prim(Var("i"), Int(1), Add, kind=None)])), Unit)}, Let(("_", Var({val: None})), App(Var("copy_perm"), [Int(0)]), LetRec({tyvars: [], name: ("init_count", Unit), args: [], body: Let(("_", Var({val: None})), If(Not(Eq(Get(Var("r"), Int(0)), Int(1))), Let(("_", Var({val: None})), Put(Var("count"), Prim(Get(Var("r"), Int(0)), Int(1), Sub, kind=None), Get(Var("r"), Int(0))), Let(("_", Var({val: None})), Put(Var("r"), Int(0), Prim(Get(Var("r"), Int(0)), Int(1), Sub, kind=None)), App(Var("init_count"), []))), Unit), Unit)}, Let(("_", Var({val: None})), App(Var("init_count"), []), Let(("_", Var({val: None})), Put(Var("flips"), Int(0), Int(0)), Let(("k", Var({val: None})), Array(Int(1), Get(Var("perm"), Int(0))), LetRec({tyvars: [], name: ("do_flip", Unit), args: [("k", Array(Int))], body: If(Not(Eq(Get(Var("k"), Int(0)), Int(0))), Let(("t", Var({val: None})), Array(Int(1), Int(0)), LetRec({tyvars: [], name: ("flip_loop", Unit), args: [("i", Int)], body: If(LE(Var("i"), Prim(Get(Var("k"), Int(0)), Int(2), Div, kind=None)), Let(("_", Var({val: None})), Put(Var("t"), Int(0), Get(Var("perm"), Var("i"))), Let(("_", Var({val: None})), Put(Var("perm"), Var("i"), Get(Var("perm"), Prim(Get(Var("k"), Int(0)), Var("i"), Sub, kind=None))), Let(("_", Var({val: None})), Put(Var("perm"), Prim(Get(Var("k"), Int(0)), Var("i"), Sub, kind=None), Get(Var("t"), Int(0))), App(Var("flip_loop"), [Prim(Var("i"), Int(1), Add, kind=None)])))), Unit)}, Let(("_", Var({val: None})), App(Var("flip_loop"), [Int(0)]), Let(("_", Var({val: None})), Put(Var("k"), Int(0), Get(Var("perm"), Int(0))), Let(("_", Var({val: None})), Put(Var("flips"), Int(0), Prim(Get(Var("flips"), Int(0)), Int(1), Add, kind=None)), App(Var("do_flip"), [Var("k")])))))), Unit)}, Let(("_", Var({val: None})), App(Var("do_flip"), [Var("k")]), Let(("_", Var({val: None})), If(LE(Get(Var("max_flips"), Int(0)), Get(Var("flips"), Int(0))), Put(Var("max_flips"), Int(0), Get(Var("flips"), Int(0))), Unit), Let(("_", Var({val: None})), Put(Var("check_sum"), Int(0), Prim(Get(Var("check_sum"), Int(0)), Prim(Get(Var("flips"), Int(0)), Prim(Int(1), Prim(Prim(Get(Var("nperm"), Int(0)), Prim(Prim(Get(Var("nperm"), Int(0)), Int(2), Div, kind=None), Int(2), Mul, kind=None), Sub, kind=None), Int(2), Mul, kind=None), Sub, kind=None), Mul, kind=None), Add, kind=None)), Let(("go", Var({val: None})), Array(Int(1), Bool(true)), Let(("t", Var({val: None})), Array(Int(1), Int(0)), LetRec({tyvars: [], name: ("go_loop", Unit), args: [], body: If(Get(Var("go"), Int(0)), Let(("_", Var({val: None})), If(Eq(Get(Var("r"), Int(0)), Var("n")), Let(("_", Var({val: None})), Put(Var("go"), Int(0), Bool(false)), Let(("_", Var({val: None})), Put(Var("r"), Int(0), Int(0)), Unit)), Let(("_", Var({val: None})), Put(Var("t"), Int(0), Get(Var("perm1"), Int(0))), LetRec({tyvars: [], name: ("move_perm1_forward", Unit), args: [("i", Int)], body: If(LE(Var("i"), Prim(Get(Var("r"), Int(0)), Int(1), Sub, kind=None)), Let(("_", Var({val: None})), Put(Var("perm1"), Var("i"), Get(Var("perm1"), Prim(Var("i"), Int(1), Add, kind=None))), Let(("_", Var({val: None})), App(Var("move_perm1_forward"), [Prim(Var("i"), Int(1), Add, kind=None)]), Unit)), Unit)}, Let(("_", Var({val: None})), App(Var("move_perm1_forward"), [Int(0)]), Let(("_", Var({val: None})), Put(Var("perm1"), Get(Var("r"), Int(0)), Get(Var("t"), Int(0))), Let(("_", Var({val: None})), Put(Var("count"), Get(Var("r"), Int(0)), Prim(Get(Var("count"), Get(Var("r"), Int(0))), Int(1), Sub, kind=None)), Let(("_", Var({val: None})), If(LE(Int(1), Get(Var("count"), Get(Var("r"), Int(0)))), Put(Var("go"), Int(0), Bool(false)), Put(Var("r"), Int(0), Prim(Get(Var("r"), Int(0)), Int(1), Add, kind=None))), Unit))))))), App(Var("go_loop"), [])), Unit)}, Let(("_", Var({val: None})), App(Var("go_loop"), []), Let(("_", Var({val: None})), Put(Var("nperm"), Int(0), Prim(Get(Var("nperm"), Int(0)), Int(1), Add, kind=None)), App(Var("compute"), [Var("r")])))))))))))))))), Unit)}, Let(("_", Var({val: None})), App(Var("compute"), [Var("r")]), Tuple([Get(Var("max_flips"), Int(0)), Get(Var("check_sum"), Int(0))]))))))))))))}, LetRec({tyvars: [], name: ("main", Var({val: None})), args: [], body: LetTuple([("max_flips", Var({val: None})), ("check_sum", Var({val: None}))], App(Var("fannkuch"), [Int(9)]), Let(("_", Var({val: None})), App(Var("print_int"), [Var("check_sum")]), App(Var("print_int"), [Var("max_flips")])))}, Unit)) against Unit
// [Typer] typevars: []
// [Typer] check: LetRec({tyvars: [], name: ("gen_perm1", Array(Int)), args: [("len", Int)], body: Let(("arr", Var({val: None})), Array(Var("len"), Int(0)), LetRec({tyvars: [], name: ("init_arr", Unit), args: [("i", Int)], body: If(LE(Var("i"), Prim(Var("len"), Int(1), Sub, kind=None)), Let(("_", Var({val: None})), Put(Var("arr"), Var("i"), Var("i")), App(Var("init_arr"), [Prim(Var("i"), Int(1), Add, kind=None)])), Unit)}, Let(("_", Var({val: None})), App(Var("init_arr"), [Int(0)]), Var("arr"))))}, Let(("perm1", Var({val: None})), App(Var("gen_perm1"), [Var("n")]), Let(("perm", Var({val: None})), Array(Var("n"), Int(0)), Let(("count", Var({val: None})), Array(Var("n"), Int(0)), Let(("flips", Var({val: None})), Array(Int(1), Int(0)), Let(("max_flips", Var({val: None})), Array(Int(1), Int(0)), Let(("check_sum", Var({val: None})), Array(Int(1), Int(0)), Let(("nperm", Var({val: None})), Array(Int(1), Int(0)), Let(("r", Var({val: None})), Array(Int(1), Var("n")), LetRec({tyvars: [], name: ("compute", Unit), args: [("r", Array(Int))], body: If(LE(Int(1), Get(Var("r"), Int(0))), LetRec({tyvars: [], name: ("copy_perm", Unit), args: [("i", Int)], body: If(LE(Var("i"), Prim(Var("n"), Int(1), Sub, kind=None)), Let(("_", Var({val: None})), Put(Var("perm"), Var("i"), Get(Var("perm1"), Var("i"))), App(Var("copy_perm"), [Prim(Var("i"), Int(1), Add, kind=None)])), Unit)}, Let(("_", Var({val: None})), App(Var("copy_perm"), [Int(0)]), LetRec({tyvars: [], name: ("init_count", Unit), args: [], body: Let(("_", Var({val: None})), If(Not(Eq(Get(Var("r"), Int(0)), Int(1))), Let(("_", Var({val: None})), Put(Var("count"), Prim(Get(Var("r"), Int(0)), Int(1), Sub, kind=None), Get(Var("r"), Int(0))), Let(("_", Var({val: None})), Put(Var("r"), Int(0), Prim(Get(Var("r"), Int(0)), Int(1), Sub, kind=None)), App(Var("init_count"), []))), Unit), Unit)}, Let(("_", Var({val: None})), App(Var("init_count"), []), Let(("_", Var({val: None})), Put(Var("flips"), Int(0), Int(0)), Let(("k", Var({val: None})), Array(Int(1), Get(Var("perm"), Int(0))), LetRec({tyvars: [], name: ("do_flip", Unit), args: [("k", Array(Int))], body: If(Not(Eq(Get(Var("k"), Int(0)), Int(0))), Let(("t", Var({val: None})), Array(Int(1), Int(0)), LetRec({tyvars: [], name: ("flip_loop", Unit), args: [("i", Int)], body: If(LE(Var("i"), Prim(Get(Var("k"), Int(0)), Int(2), Div, kind=None)), Let(("_", Var({val: None})), Put(Var("t"), Int(0), Get(Var("perm"), Var("i"))), Let(("_", Var({val: None})), Put(Var("perm"), Var("i"), Get(Var("perm"), Prim(Get(Var("k"), Int(0)), Var("i"), Sub, kind=None))), Let(("_", Var({val: None})), Put(Var("perm"), Prim(Get(Var("k"), Int(0)), Var("i"), Sub, kind=None), Get(Var("t"), Int(0))), App(Var("flip_loop"), [Prim(Var("i"), Int(1), Add, kind=None)])))), Unit)}, Let(("_", Var({val: None})), App(Var("flip_loop"), [Int(0)]), Let(("_", Var({val: None})), Put(Var("k"), Int(0), Get(Var("perm"), Int(0))), Let(("_", Var({val: None})), Put(Var("flips"), Int(0), Prim(Get(Var("flips"), Int(0)), Int(1), Add, kind=None)), App(Var("do_flip"), [Var("k")])))))), Unit)}, Let(("_", Var({val: None})), App(Var("do_flip"), [Var("k")]), Let(("_", Var({val: None})), If(LE(Get(Var("max_flips"), Int(0)), Get(Var("flips"), Int(0))), Put(Var("max_flips"), Int(0), Get(Var("flips"), Int(0))), Unit), Let(("_", Var({val: None})), Put(Var("check_sum"), Int(0), Prim(Get(Var("check_sum"), Int(0)), Prim(Get(Var("flips"), Int(0)), Prim(Int(1), Prim(Prim(Get(Var("nperm"), Int(0)), Prim(Prim(Get(Var("nperm"), Int(0)), Int(2), Div, kind=None), Int(2), Mul, kind=None), Sub, kind=None), Int(2), Mul, kind=None), Sub, kind=None), Mul, kind=None), Add, kind=None)), Let(("go", Var({val: None})), Array(Int(1), Bool(true)), Let(("t", Var({val: None})), Array(Int(1), Int(0)), LetRec({tyvars: [], name: ("go_loop", Unit), args: [], body: If(Get(Var("go"), Int(0)), Let(("_", Var({val: None})), If(Eq(Get(Var("r"), Int(0)), Var("n")), Let(("_", Var({val: None})), Put(Var("go"), Int(0), Bool(false)), Let(("_", Var({val: None})), Put(Var("r"), Int(0), Int(0)), Unit)), Let(("_", Var({val: None})), Put(Var("t"), Int(0), Get(Var("perm1"), Int(0))), LetRec({tyvars: [], name: ("move_perm1_forward", Unit), args: [("i", Int)], body: If(LE(Var("i"), Prim(Get(Var("r"), Int(0)), Int(1), Sub, kind=None)), Let(("_", Var({val: None})), Put(Var("perm1"), Var("i"), Get(Var("perm1"), Prim(Var("i"), Int(1), Add, kind=None))), Let(("_", Var({val: None})), App(Var("move_perm1_forward"), [Prim(Var("i"), Int(1), Add, kind=None)]), Unit)), Unit)}, Let(("_", Var({val: None})), App(Var("move_perm1_forward"), [Int(0)]), Let(("_", Var({val: None})), Put(Var("perm1"), Get(Var("r"), Int(0)), Get(Var("t"), Int(0))), Let(("_", Var({val: None})), Put(Var("count"), Get(Var("r"), Int(0)), Prim(Get(Var("count"), Get(Var("r"), Int(0))), Int(1), Sub, kind=None)), Let(("_", Var({val: None})), If(LE(Int(1), Get(Var("count"), Get(Var("r"), Int(0)))), Put(Var("go"), Int(0), Bool(false)), Put(Var("r"), Int(0), Prim(Get(Var("r"), Int(0)), Int(1), Add, kind=None))), Unit))))))), App(Var("go_loop"), [])), Unit)}, Let(("_", Var({val: None})), App(Var("go_loop"), []), Let(("_", Var({val: None})), Put(Var("nperm"), Int(0), Prim(Get(Var("nperm"), Int(0)), Int(1), Add, kind=None)), App(Var("compute"), [Var("r")])))))))))))))))), Unit)}, Let(("_", Var({val: None})), App(Var("compute"), [Var("r")]), Tuple([Get(Var("max_flips"), Int(0)), Get(Var("check_sum"), Int(0))])))))))))))) against Tuple([Int, Int])
// [Typer] typevars: []
// [Typer] check: Let(("arr", Var({val: None})), Array(Var("len"), Int(0)), LetRec({tyvars: [], name: ("init_arr", Unit), args: [("i", Int)], body: If(LE(Var("i"), Prim(Var("len"), Int(1), Sub, kind=None)), Let(("_", Var({val: None})), Put(Var("arr"), Var("i"), Var("i")), App(Var("init_arr"), [Prim(Var("i"), Int(1), Add, kind=None)])), Unit)}, Let(("_", Var({val: None})), App(Var("init_arr"), [Int(0)]), Var("arr")))) against Array(Int)
// [Typer] infer: Array(Var("len"), Int(0))
// [Typer] infer: Int(0)
// [Typer] check: Var("len") against Int
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] unify: Var({val: None}) and Array(Int)
// [Typer] union: Var({val: None}) and Array(Int)
// [Typer] check: LetRec({tyvars: [], name: ("init_arr", Unit), args: [("i", Int)], body: If(LE(Var("i"), Prim(Var("len"), Int(1), Sub, kind=None)), Let(("_", Var({val: None})), Put(Var("arr"), Var("i"), Var("i")), App(Var("init_arr"), [Prim(Var("i"), Int(1), Add, kind=None)])), Unit)}, Let(("_", Var({val: None})), App(Var("init_arr"), [Int(0)]), Var("arr"))) against Array(Int)
// [Typer] typevars: []
// [Typer] check: If(LE(Var("i"), Prim(Var("len"), Int(1), Sub, kind=None)), Let(("_", Var({val: None})), Put(Var("arr"), Var("i"), Var("i")), App(Var("init_arr"), [Prim(Var("i"), Int(1), Add, kind=None)])), Unit) against Unit
// [Typer] check: LE(Var("i"), Prim(Var("len"), Int(1), Sub, kind=None)) against Bool
// [Typer] infer: Var("i")
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] infer: Prim(Var("len"), Int(1), Sub, kind=None)
// [Typer] infer: Var("len")
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] infer: Int(1)
// [Typer] unify: Int and Int
// [Typer] unify: Int and Int
// [Typer] check: Let(("_", Var({val: None})), Put(Var("arr"), Var("i"), Var("i")), App(Var("init_arr"), [Prim(Var("i"), Int(1), Add, kind=None)])) against Unit
// [Typer] infer: Put(Var("arr"), Var("i"), Var("i"))
// [Typer] infer: Var("i")
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] check: Var("arr") against Array(Int)
// [Typer] inst: TypeScheme(([], Var({val: Some(Array(Int))})))
// [Typer] inst result: Array(Int)
// [Typer] unify: Array(Int) and Array(Int)
// [Typer] unify: Int and Int
// [Typer] check: Var("i") against Int
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] unify: Var({val: None}) and Unit
// [Typer] union: Var({val: None}) and Unit
// [Typer] check: App(Var("init_arr"), [Prim(Var("i"), Int(1), Add, kind=None)]) against Unit
// [Typer] infer: Prim(Var("i"), Int(1), Add, kind=None)
// [Typer] infer: Var("i")
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] infer: Int(1)
// [Typer] unify: Int and Int
// [Typer] check: Var("init_arr") against Fun([Int], Unit)
// [Typer] inst: TypeScheme(([], Fun([Int], Unit)))
// [Typer] inst result: Fun([Int], Unit)
// [Typer] unify: Fun([Int], Unit) and Fun([Int], Unit)
// [Typer] unify: Int and Int
// [Typer] unify: Unit and Unit
// [Typer] check: Unit against Unit
// [Typer] check: Let(("_", Var({val: None})), App(Var("init_arr"), [Int(0)]), Var("arr")) against Array(Int)
// [Typer] infer: App(Var("init_arr"), [Int(0)])
// [Typer] infer: Var("init_arr")
// [Typer] inst: TypeScheme(([], Fun([Int], Unit)))
// [Typer] inst result: Fun([Int], Unit)
// [Typer] check: Int(0) against Int
// [Typer] unify: Var({val: None}) and Unit
// [Typer] union: Var({val: None}) and Unit
// [Typer] check: Var("arr") against Array(Int)
// [Typer] inst: TypeScheme(([], Var({val: Some(Array(Int))})))
// [Typer] inst result: Array(Int)
// [Typer] unify: Array(Int) and Array(Int)
// [Typer] unify: Int and Int
// [Typer] check: Let(("perm1", Var({val: None})), App(Var("gen_perm1"), [Var("n")]), Let(("perm", Var({val: None})), Array(Var("n"), Int(0)), Let(("count", Var({val: None})), Array(Var("n"), Int(0)), Let(("flips", Var({val: None})), Array(Int(1), Int(0)), Let(("max_flips", Var({val: None})), Array(Int(1), Int(0)), Let(("check_sum", Var({val: None})), Array(Int(1), Int(0)), Let(("nperm", Var({val: None})), Array(Int(1), Int(0)), Let(("r", Var({val: None})), Array(Int(1), Var("n")), LetRec({tyvars: [], name: ("compute", Unit), args: [("r", Array(Int))], body: If(LE(Int(1), Get(Var("r"), Int(0))), LetRec({tyvars: [], name: ("copy_perm", Unit), args: [("i", Int)], body: If(LE(Var("i"), Prim(Var("n"), Int(1), Sub, kind=None)), Let(("_", Var({val: None})), Put(Var("perm"), Var("i"), Get(Var("perm1"), Var("i"))), App(Var("copy_perm"), [Prim(Var("i"), Int(1), Add, kind=None)])), Unit)}, Let(("_", Var({val: None})), App(Var("copy_perm"), [Int(0)]), LetRec({tyvars: [], name: ("init_count", Unit), args: [], body: Let(("_", Var({val: None})), If(Not(Eq(Get(Var("r"), Int(0)), Int(1))), Let(("_", Var({val: None})), Put(Var("count"), Prim(Get(Var("r"), Int(0)), Int(1), Sub, kind=None), Get(Var("r"), Int(0))), Let(("_", Var({val: None})), Put(Var("r"), Int(0), Prim(Get(Var("r"), Int(0)), Int(1), Sub, kind=None)), App(Var("init_count"), []))), Unit), Unit)}, Let(("_", Var({val: None})), App(Var("init_count"), []), Let(("_", Var({val: None})), Put(Var("flips"), Int(0), Int(0)), Let(("k", Var({val: None})), Array(Int(1), Get(Var("perm"), Int(0))), LetRec({tyvars: [], name: ("do_flip", Unit), args: [("k", Array(Int))], body: If(Not(Eq(Get(Var("k"), Int(0)), Int(0))), Let(("t", Var({val: None})), Array(Int(1), Int(0)), LetRec({tyvars: [], name: ("flip_loop", Unit), args: [("i", Int)], body: If(LE(Var("i"), Prim(Get(Var("k"), Int(0)), Int(2), Div, kind=None)), Let(("_", Var({val: None})), Put(Var("t"), Int(0), Get(Var("perm"), Var("i"))), Let(("_", Var({val: None})), Put(Var("perm"), Var("i"), Get(Var("perm"), Prim(Get(Var("k"), Int(0)), Var("i"), Sub, kind=None))), Let(("_", Var({val: None})), Put(Var("perm"), Prim(Get(Var("k"), Int(0)), Var("i"), Sub, kind=None), Get(Var("t"), Int(0))), App(Var("flip_loop"), [Prim(Var("i"), Int(1), Add, kind=None)])))), Unit)}, Let(("_", Var({val: None})), App(Var("flip_loop"), [Int(0)]), Let(("_", Var({val: None})), Put(Var("k"), Int(0), Get(Var("perm"), Int(0))), Let(("_", Var({val: None})), Put(Var("flips"), Int(0), Prim(Get(Var("flips"), Int(0)), Int(1), Add, kind=None)), App(Var("do_flip"), [Var("k")])))))), Unit)}, Let(("_", Var({val: None})), App(Var("do_flip"), [Var("k")]), Let(("_", Var({val: None})), If(LE(Get(Var("max_flips"), Int(0)), Get(Var("flips"), Int(0))), Put(Var("max_flips"), Int(0), Get(Var("flips"), Int(0))), Unit), Let(("_", Var({val: None})), Put(Var("check_sum"), Int(0), Prim(Get(Var("check_sum"), Int(0)), Prim(Get(Var("flips"), Int(0)), Prim(Int(1), Prim(Prim(Get(Var("nperm"), Int(0)), Prim(Prim(Get(Var("nperm"), Int(0)), Int(2), Div, kind=None), Int(2), Mul, kind=None), Sub, kind=None), Int(2), Mul, kind=None), Sub, kind=None), Mul, kind=None), Add, kind=None)), Let(("go", Var({val: None})), Array(Int(1), Bool(true)), Let(("t", Var({val: None})), Array(Int(1), Int(0)), LetRec({tyvars: [], name: ("go_loop", Unit), args: [], body: If(Get(Var("go"), Int(0)), Let(("_", Var({val: None})), If(Eq(Get(Var("r"), Int(0)), Var("n")), Let(("_", Var({val: None})), Put(Var("go"), Int(0), Bool(false)), Let(("_", Var({val: None})), Put(Var("r"), Int(0), Int(0)), Unit)), Let(("_", Var({val: None})), Put(Var("t"), Int(0), Get(Var("perm1"), Int(0))), LetRec({tyvars: [], name: ("move_perm1_forward", Unit), args: [("i", Int)], body: If(LE(Var("i"), Prim(Get(Var("r"), Int(0)), Int(1), Sub, kind=None)), Let(("_", Var({val: None})), Put(Var("perm1"), Var("i"), Get(Var("perm1"), Prim(Var("i"), Int(1), Add, kind=None))), Let(("_", Var({val: None})), App(Var("move_perm1_forward"), [Prim(Var("i"), Int(1), Add, kind=None)]), Unit)), Unit)}, Let(("_", Var({val: None})), App(Var("move_perm1_forward"), [Int(0)]), Let(("_", Var({val: None})), Put(Var("perm1"), Get(Var("r"), Int(0)), Get(Var("t"), Int(0))), Let(("_", Var({val: None})), Put(Var("count"), Get(Var("r"), Int(0)), Prim(Get(Var("count"), Get(Var("r"), Int(0))), Int(1), Sub, kind=None)), Let(("_", Var({val: None})), If(LE(Int(1), Get(Var("count"), Get(Var("r"), Int(0)))), Put(Var("go"), Int(0), Bool(false)), Put(Var("r"), Int(0), Prim(Get(Var("r"), Int(0)), Int(1), Add, kind=None))), Unit))))))), App(Var("go_loop"), [])), Unit)}, Let(("_", Var({val: None})), App(Var("go_loop"), []), Let(("_", Var({val: None})), Put(Var("nperm"), Int(0), Prim(Get(Var("nperm"), Int(0)), Int(1), Add, kind=None)), App(Var("compute"), [Var("r")])))))))))))))))), Unit)}, Let(("_", Var({val: None})), App(Var("compute"), [Var("r")]), Tuple([Get(Var("max_flips"), Int(0)), Get(Var("check_sum"), Int(0))]))))))))))) against Tuple([Int, Int])
// [Typer] infer: App(Var("gen_perm1"), [Var("n")])
// [Typer] infer: Var("gen_perm1")
// [Typer] inst: TypeScheme(([], Fun([Int], Array(Int))))
// [Typer] inst result: Fun([Int], Array(Int))
// [Typer] check: Var("n") against Int
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] unify: Var({val: None}) and Array(Int)
// [Typer] union: Var({val: None}) and Array(Int)
// [Typer] check: Let(("perm", Var({val: None})), Array(Var("n"), Int(0)), Let(("count", Var({val: None})), Array(Var("n"), Int(0)), Let(("flips", Var({val: None})), Array(Int(1), Int(0)), Let(("max_flips", Var({val: None})), Array(Int(1), Int(0)), Let(("check_sum", Var({val: None})), Array(Int(1), Int(0)), Let(("nperm", Var({val: None})), Array(Int(1), Int(0)), Let(("r", Var({val: None})), Array(Int(1), Var("n")), LetRec({tyvars: [], name: ("compute", Unit), args: [("r", Array(Int))], body: If(LE(Int(1), Get(Var("r"), Int(0))), LetRec({tyvars: [], name: ("copy_perm", Unit), args: [("i", Int)], body: If(LE(Var("i"), Prim(Var("n"), Int(1), Sub, kind=None)), Let(("_", Var({val: None})), Put(Var("perm"), Var("i"), Get(Var("perm1"), Var("i"))), App(Var("copy_perm"), [Prim(Var("i"), Int(1), Add, kind=None)])), Unit)}, Let(("_", Var({val: None})), App(Var("copy_perm"), [Int(0)]), LetRec({tyvars: [], name: ("init_count", Unit), args: [], body: Let(("_", Var({val: None})), If(Not(Eq(Get(Var("r"), Int(0)), Int(1))), Let(("_", Var({val: None})), Put(Var("count"), Prim(Get(Var("r"), Int(0)), Int(1), Sub, kind=None), Get(Var("r"), Int(0))), Let(("_", Var({val: None})), Put(Var("r"), Int(0), Prim(Get(Var("r"), Int(0)), Int(1), Sub, kind=None)), App(Var("init_count"), []))), Unit), Unit)}, Let(("_", Var({val: None})), App(Var("init_count"), []), Let(("_", Var({val: None})), Put(Var("flips"), Int(0), Int(0)), Let(("k", Var({val: None})), Array(Int(1), Get(Var("perm"), Int(0))), LetRec({tyvars: [], name: ("do_flip", Unit), args: [("k", Array(Int))], body: If(Not(Eq(Get(Var("k"), Int(0)), Int(0))), Let(("t", Var({val: None})), Array(Int(1), Int(0)), LetRec({tyvars: [], name: ("flip_loop", Unit), args: [("i", Int)], body: If(LE(Var("i"), Prim(Get(Var("k"), Int(0)), Int(2), Div, kind=None)), Let(("_", Var({val: None})), Put(Var("t"), Int(0), Get(Var("perm"), Var("i"))), Let(("_", Var({val: None})), Put(Var("perm"), Var("i"), Get(Var("perm"), Prim(Get(Var("k"), Int(0)), Var("i"), Sub, kind=None))), Let(("_", Var({val: None})), Put(Var("perm"), Prim(Get(Var("k"), Int(0)), Var("i"), Sub, kind=None), Get(Var("t"), Int(0))), App(Var("flip_loop"), [Prim(Var("i"), Int(1), Add, kind=None)])))), Unit)}, Let(("_", Var({val: None})), App(Var("flip_loop"), [Int(0)]), Let(("_", Var({val: None})), Put(Var("k"), Int(0), Get(Var("perm"), Int(0))), Let(("_", Var({val: None})), Put(Var("flips"), Int(0), Prim(Get(Var("flips"), Int(0)), Int(1), Add, kind=None)), App(Var("do_flip"), [Var("k")])))))), Unit)}, Let(("_", Var({val: None})), App(Var("do_flip"), [Var("k")]), Let(("_", Var({val: None})), If(LE(Get(Var("max_flips"), Int(0)), Get(Var("flips"), Int(0))), Put(Var("max_flips"), Int(0), Get(Var("flips"), Int(0))), Unit), Let(("_", Var({val: None})), Put(Var("check_sum"), Int(0), Prim(Get(Var("check_sum"), Int(0)), Prim(Get(Var("flips"), Int(0)), Prim(Int(1), Prim(Prim(Get(Var("nperm"), Int(0)), Prim(Prim(Get(Var("nperm"), Int(0)), Int(2), Div, kind=None), Int(2), Mul, kind=None), Sub, kind=None), Int(2), Mul, kind=None), Sub, kind=None), Mul, kind=None), Add, kind=None)), Let(("go", Var({val: None})), Array(Int(1), Bool(true)), Let(("t", Var({val: None})), Array(Int(1), Int(0)), LetRec({tyvars: [], name: ("go_loop", Unit), args: [], body: If(Get(Var("go"), Int(0)), Let(("_", Var({val: None})), If(Eq(Get(Var("r"), Int(0)), Var("n")), Let(("_", Var({val: None})), Put(Var("go"), Int(0), Bool(false)), Let(("_", Var({val: None})), Put(Var("r"), Int(0), Int(0)), Unit)), Let(("_", Var({val: None})), Put(Var("t"), Int(0), Get(Var("perm1"), Int(0))), LetRec({tyvars: [], name: ("move_perm1_forward", Unit), args: [("i", Int)], body: If(LE(Var("i"), Prim(Get(Var("r"), Int(0)), Int(1), Sub, kind=None)), Let(("_", Var({val: None})), Put(Var("perm1"), Var("i"), Get(Var("perm1"), Prim(Var("i"), Int(1), Add, kind=None))), Let(("_", Var({val: None})), App(Var("move_perm1_forward"), [Prim(Var("i"), Int(1), Add, kind=None)]), Unit)), Unit)}, Let(("_", Var({val: None})), App(Var("move_perm1_forward"), [Int(0)]), Let(("_", Var({val: None})), Put(Var("perm1"), Get(Var("r"), Int(0)), Get(Var("t"), Int(0))), Let(("_", Var({val: None})), Put(Var("count"), Get(Var("r"), Int(0)), Prim(Get(Var("count"), Get(Var("r"), Int(0))), Int(1), Sub, kind=None)), Let(("_", Var({val: None})), If(LE(Int(1), Get(Var("count"), Get(Var("r"), Int(0)))), Put(Var("go"), Int(0), Bool(false)), Put(Var("r"), Int(0), Prim(Get(Var("r"), Int(0)), Int(1), Add, kind=None))), Unit))))))), App(Var("go_loop"), [])), Unit)}, Let(("_", Var({val: None})), App(Var("go_loop"), []), Let(("_", Var({val: None})), Put(Var("nperm"), Int(0), Prim(Get(Var("nperm"), Int(0)), Int(1), Add, kind=None)), App(Var("compute"), [Var("r")])))))))))))))))), Unit)}, Let(("_", Var({val: None})), App(Var("compute"), [Var("r")]), Tuple([Get(Var("max_flips"), Int(0)), Get(Var("check_sum"), Int(0))])))))))))) against Tuple([Int, Int])
// [Typer] infer: Array(Var("n"), Int(0))
// [Typer] infer: Int(0)
// [Typer] check: Var("n") against Int
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] unify: Var({val: None}) and Array(Int)
// [Typer] union: Var({val: None}) and Array(Int)
// [Typer] check: Let(("count", Var({val: None})), Array(Var("n"), Int(0)), Let(("flips", Var({val: None})), Array(Int(1), Int(0)), Let(("max_flips", Var({val: None})), Array(Int(1), Int(0)), Let(("check_sum", Var({val: None})), Array(Int(1), Int(0)), Let(("nperm", Var({val: None})), Array(Int(1), Int(0)), Let(("r", Var({val: None})), Array(Int(1), Var("n")), LetRec({tyvars: [], name: ("compute", Unit), args: [("r", Array(Int))], body: If(LE(Int(1), Get(Var("r"), Int(0))), LetRec({tyvars: [], name: ("copy_perm", Unit), args: [("i", Int)], body: If(LE(Var("i"), Prim(Var("n"), Int(1), Sub, kind=None)), Let(("_", Var({val: None})), Put(Var("perm"), Var("i"), Get(Var("perm1"), Var("i"))), App(Var("copy_perm"), [Prim(Var("i"), Int(1), Add, kind=None)])), Unit)}, Let(("_", Var({val: None})), App(Var("copy_perm"), [Int(0)]), LetRec({tyvars: [], name: ("init_count", Unit), args: [], body: Let(("_", Var({val: None})), If(Not(Eq(Get(Var("r"), Int(0)), Int(1))), Let(("_", Var({val: None})), Put(Var("count"), Prim(Get(Var("r"), Int(0)), Int(1), Sub, kind=None), Get(Var("r"), Int(0))), Let(("_", Var({val: None})), Put(Var("r"), Int(0), Prim(Get(Var("r"), Int(0)), Int(1), Sub, kind=None)), App(Var("init_count"), []))), Unit), Unit)}, Let(("_", Var({val: None})), App(Var("init_count"), []), Let(("_", Var({val: None})), Put(Var("flips"), Int(0), Int(0)), Let(("k", Var({val: None})), Array(Int(1), Get(Var("perm"), Int(0))), LetRec({tyvars: [], name: ("do_flip", Unit), args: [("k", Array(Int))], body: If(Not(Eq(Get(Var("k"), Int(0)), Int(0))), Let(("t", Var({val: None})), Array(Int(1), Int(0)), LetRec({tyvars: [], name: ("flip_loop", Unit), args: [("i", Int)], body: If(LE(Var("i"), Prim(Get(Var("k"), Int(0)), Int(2), Div, kind=None)), Let(("_", Var({val: None})), Put(Var("t"), Int(0), Get(Var("perm"), Var("i"))), Let(("_", Var({val: None})), Put(Var("perm"), Var("i"), Get(Var("perm"), Prim(Get(Var("k"), Int(0)), Var("i"), Sub, kind=None))), Let(("_", Var({val: None})), Put(Var("perm"), Prim(Get(Var("k"), Int(0)), Var("i"), Sub, kind=None), Get(Var("t"), Int(0))), App(Var("flip_loop"), [Prim(Var("i"), Int(1), Add, kind=None)])))), Unit)}, Let(("_", Var({val: None})), App(Var("flip_loop"), [Int(0)]), Let(("_", Var({val: None})), Put(Var("k"), Int(0), Get(Var("perm"), Int(0))), Let(("_", Var({val: None})), Put(Var("flips"), Int(0), Prim(Get(Var("flips"), Int(0)), Int(1), Add, kind=None)), App(Var("do_flip"), [Var("k")])))))), Unit)}, Let(("_", Var({val: None})), App(Var("do_flip"), [Var("k")]), Let(("_", Var({val: None})), If(LE(Get(Var("max_flips"), Int(0)), Get(Var("flips"), Int(0))), Put(Var("max_flips"), Int(0), Get(Var("flips"), Int(0))), Unit), Let(("_", Var({val: None})), Put(Var("check_sum"), Int(0), Prim(Get(Var("check_sum"), Int(0)), Prim(Get(Var("flips"), Int(0)), Prim(Int(1), Prim(Prim(Get(Var("nperm"), Int(0)), Prim(Prim(Get(Var("nperm"), Int(0)), Int(2), Div, kind=None), Int(2), Mul, kind=None), Sub, kind=None), Int(2), Mul, kind=None), Sub, kind=None), Mul, kind=None), Add, kind=None)), Let(("go", Var({val: None})), Array(Int(1), Bool(true)), Let(("t", Var({val: None})), Array(Int(1), Int(0)), LetRec({tyvars: [], name: ("go_loop", Unit), args: [], body: If(Get(Var("go"), Int(0)), Let(("_", Var({val: None})), If(Eq(Get(Var("r"), Int(0)), Var("n")), Let(("_", Var({val: None})), Put(Var("go"), Int(0), Bool(false)), Let(("_", Var({val: None})), Put(Var("r"), Int(0), Int(0)), Unit)), Let(("_", Var({val: None})), Put(Var("t"), Int(0), Get(Var("perm1"), Int(0))), LetRec({tyvars: [], name: ("move_perm1_forward", Unit), args: [("i", Int)], body: If(LE(Var("i"), Prim(Get(Var("r"), Int(0)), Int(1), Sub, kind=None)), Let(("_", Var({val: None})), Put(Var("perm1"), Var("i"), Get(Var("perm1"), Prim(Var("i"), Int(1), Add, kind=None))), Let(("_", Var({val: None})), App(Var("move_perm1_forward"), [Prim(Var("i"), Int(1), Add, kind=None)]), Unit)), Unit)}, Let(("_", Var({val: None})), App(Var("move_perm1_forward"), [Int(0)]), Let(("_", Var({val: None})), Put(Var("perm1"), Get(Var("r"), Int(0)), Get(Var("t"), Int(0))), Let(("_", Var({val: None})), Put(Var("count"), Get(Var("r"), Int(0)), Prim(Get(Var("count"), Get(Var("r"), Int(0))), Int(1), Sub, kind=None)), Let(("_", Var({val: None})), If(LE(Int(1), Get(Var("count"), Get(Var("r"), Int(0)))), Put(Var("go"), Int(0), Bool(false)), Put(Var("r"), Int(0), Prim(Get(Var("r"), Int(0)), Int(1), Add, kind=None))), Unit))))))), App(Var("go_loop"), [])), Unit)}, Let(("_", Var({val: None})), App(Var("go_loop"), []), Let(("_", Var({val: None})), Put(Var("nperm"), Int(0), Prim(Get(Var("nperm"), Int(0)), Int(1), Add, kind=None)), App(Var("compute"), [Var("r")])))))))))))))))), Unit)}, Let(("_", Var({val: None})), App(Var("compute"), [Var("r")]), Tuple([Get(Var("max_flips"), Int(0)), Get(Var("check_sum"), Int(0))]))))))))) against Tuple([Int, Int])
// [Typer] infer: Array(Var("n"), Int(0))
// [Typer] infer: Int(0)
// [Typer] check: Var("n") against Int
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] unify: Var({val: None}) and Array(Int)
// [Typer] union: Var({val: None}) and Array(Int)
// [Typer] check: Let(("flips", Var({val: None})), Array(Int(1), Int(0)), Let(("max_flips", Var({val: None})), Array(Int(1), Int(0)), Let(("check_sum", Var({val: None})), Array(Int(1), Int(0)), Let(("nperm", Var({val: None})), Array(Int(1), Int(0)), Let(("r", Var({val: None})), Array(Int(1), Var("n")), LetRec({tyvars: [], name: ("compute", Unit), args: [("r", Array(Int))], body: If(LE(Int(1), Get(Var("r"), Int(0))), LetRec({tyvars: [], name: ("copy_perm", Unit), args: [("i", Int)], body: If(LE(Var("i"), Prim(Var("n"), Int(1), Sub, kind=None)), Let(("_", Var({val: None})), Put(Var("perm"), Var("i"), Get(Var("perm1"), Var("i"))), App(Var("copy_perm"), [Prim(Var("i"), Int(1), Add, kind=None)])), Unit)}, Let(("_", Var({val: None})), App(Var("copy_perm"), [Int(0)]), LetRec({tyvars: [], name: ("init_count", Unit), args: [], body: Let(("_", Var({val: None})), If(Not(Eq(Get(Var("r"), Int(0)), Int(1))), Let(("_", Var({val: None})), Put(Var("count"), Prim(Get(Var("r"), Int(0)), Int(1), Sub, kind=None), Get(Var("r"), Int(0))), Let(("_", Var({val: None})), Put(Var("r"), Int(0), Prim(Get(Var("r"), Int(0)), Int(1), Sub, kind=None)), App(Var("init_count"), []))), Unit), Unit)}, Let(("_", Var({val: None})), App(Var("init_count"), []), Let(("_", Var({val: None})), Put(Var("flips"), Int(0), Int(0)), Let(("k", Var({val: None})), Array(Int(1), Get(Var("perm"), Int(0))), LetRec({tyvars: [], name: ("do_flip", Unit), args: [("k", Array(Int))], body: If(Not(Eq(Get(Var("k"), Int(0)), Int(0))), Let(("t", Var({val: None})), Array(Int(1), Int(0)), LetRec({tyvars: [], name: ("flip_loop", Unit), args: [("i", Int)], body: If(LE(Var("i"), Prim(Get(Var("k"), Int(0)), Int(2), Div, kind=None)), Let(("_", Var({val: None})), Put(Var("t"), Int(0), Get(Var("perm"), Var("i"))), Let(("_", Var({val: None})), Put(Var("perm"), Var("i"), Get(Var("perm"), Prim(Get(Var("k"), Int(0)), Var("i"), Sub, kind=None))), Let(("_", Var({val: None})), Put(Var("perm"), Prim(Get(Var("k"), Int(0)), Var("i"), Sub, kind=None), Get(Var("t"), Int(0))), App(Var("flip_loop"), [Prim(Var("i"), Int(1), Add, kind=None)])))), Unit)}, Let(("_", Var({val: None})), App(Var("flip_loop"), [Int(0)]), Let(("_", Var({val: None})), Put(Var("k"), Int(0), Get(Var("perm"), Int(0))), Let(("_", Var({val: None})), Put(Var("flips"), Int(0), Prim(Get(Var("flips"), Int(0)), Int(1), Add, kind=None)), App(Var("do_flip"), [Var("k")])))))), Unit)}, Let(("_", Var({val: None})), App(Var("do_flip"), [Var("k")]), Let(("_", Var({val: None})), If(LE(Get(Var("max_flips"), Int(0)), Get(Var("flips"), Int(0))), Put(Var("max_flips"), Int(0), Get(Var("flips"), Int(0))), Unit), Let(("_", Var({val: None})), Put(Var("check_sum"), Int(0), Prim(Get(Var("check_sum"), Int(0)), Prim(Get(Var("flips"), Int(0)), Prim(Int(1), Prim(Prim(Get(Var("nperm"), Int(0)), Prim(Prim(Get(Var("nperm"), Int(0)), Int(2), Div, kind=None), Int(2), Mul, kind=None), Sub, kind=None), Int(2), Mul, kind=None), Sub, kind=None), Mul, kind=None), Add, kind=None)), Let(("go", Var({val: None})), Array(Int(1), Bool(true)), Let(("t", Var({val: None})), Array(Int(1), Int(0)), LetRec({tyvars: [], name: ("go_loop", Unit), args: [], body: If(Get(Var("go"), Int(0)), Let(("_", Var({val: None})), If(Eq(Get(Var("r"), Int(0)), Var("n")), Let(("_", Var({val: None})), Put(Var("go"), Int(0), Bool(false)), Let(("_", Var({val: None})), Put(Var("r"), Int(0), Int(0)), Unit)), Let(("_", Var({val: None})), Put(Var("t"), Int(0), Get(Var("perm1"), Int(0))), LetRec({tyvars: [], name: ("move_perm1_forward", Unit), args: [("i", Int)], body: If(LE(Var("i"), Prim(Get(Var("r"), Int(0)), Int(1), Sub, kind=None)), Let(("_", Var({val: None})), Put(Var("perm1"), Var("i"), Get(Var("perm1"), Prim(Var("i"), Int(1), Add, kind=None))), Let(("_", Var({val: None})), App(Var("move_perm1_forward"), [Prim(Var("i"), Int(1), Add, kind=None)]), Unit)), Unit)}, Let(("_", Var({val: None})), App(Var("move_perm1_forward"), [Int(0)]), Let(("_", Var({val: None})), Put(Var("perm1"), Get(Var("r"), Int(0)), Get(Var("t"), Int(0))), Let(("_", Var({val: None})), Put(Var("count"), Get(Var("r"), Int(0)), Prim(Get(Var("count"), Get(Var("r"), Int(0))), Int(1), Sub, kind=None)), Let(("_", Var({val: None})), If(LE(Int(1), Get(Var("count"), Get(Var("r"), Int(0)))), Put(Var("go"), Int(0), Bool(false)), Put(Var("r"), Int(0), Prim(Get(Var("r"), Int(0)), Int(1), Add, kind=None))), Unit))))))), App(Var("go_loop"), [])), Unit)}, Let(("_", Var({val: None})), App(Var("go_loop"), []), Let(("_", Var({val: None})), Put(Var("nperm"), Int(0), Prim(Get(Var("nperm"), Int(0)), Int(1), Add, kind=None)), App(Var("compute"), [Var("r")])))))))))))))))), Unit)}, Let(("_", Var({val: None})), App(Var("compute"), [Var("r")]), Tuple([Get(Var("max_flips"), Int(0)), Get(Var("check_sum"), Int(0))])))))))) against Tuple([Int, Int])
// [Typer] infer: Array(Int(1), Int(0))
// [Typer] infer: Int(0)
// [Typer] check: Int(1) against Int
// [Typer] unify: Var({val: None}) and Array(Int)
// [Typer] union: Var({val: None}) and Array(Int)
// [Typer] check: Let(("max_flips", Var({val: None})), Array(Int(1), Int(0)), Let(("check_sum", Var({val: None})), Array(Int(1), Int(0)), Let(("nperm", Var({val: None})), Array(Int(1), Int(0)), Let(("r", Var({val: None})), Array(Int(1), Var("n")), LetRec({tyvars: [], name: ("compute", Unit), args: [("r", Array(Int))], body: If(LE(Int(1), Get(Var("r"), Int(0))), LetRec({tyvars: [], name: ("copy_perm", Unit), args: [("i", Int)], body: If(LE(Var("i"), Prim(Var("n"), Int(1), Sub, kind=None)), Let(("_", Var({val: None})), Put(Var("perm"), Var("i"), Get(Var("perm1"), Var("i"))), App(Var("copy_perm"), [Prim(Var("i"), Int(1), Add, kind=None)])), Unit)}, Let(("_", Var({val: None})), App(Var("copy_perm"), [Int(0)]), LetRec({tyvars: [], name: ("init_count", Unit), args: [], body: Let(("_", Var({val: None})), If(Not(Eq(Get(Var("r"), Int(0)), Int(1))), Let(("_", Var({val: None})), Put(Var("count"), Prim(Get(Var("r"), Int(0)), Int(1), Sub, kind=None), Get(Var("r"), Int(0))), Let(("_", Var({val: None})), Put(Var("r"), Int(0), Prim(Get(Var("r"), Int(0)), Int(1), Sub, kind=None)), App(Var("init_count"), []))), Unit), Unit)}, Let(("_", Var({val: None})), App(Var("init_count"), []), Let(("_", Var({val: None})), Put(Var("flips"), Int(0), Int(0)), Let(("k", Var({val: None})), Array(Int(1), Get(Var("perm"), Int(0))), LetRec({tyvars: [], name: ("do_flip", Unit), args: [("k", Array(Int))], body: If(Not(Eq(Get(Var("k"), Int(0)), Int(0))), Let(("t", Var({val: None})), Array(Int(1), Int(0)), LetRec({tyvars: [], name: ("flip_loop", Unit), args: [("i", Int)], body: If(LE(Var("i"), Prim(Get(Var("k"), Int(0)), Int(2), Div, kind=None)), Let(("_", Var({val: None})), Put(Var("t"), Int(0), Get(Var("perm"), Var("i"))), Let(("_", Var({val: None})), Put(Var("perm"), Var("i"), Get(Var("perm"), Prim(Get(Var("k"), Int(0)), Var("i"), Sub, kind=None))), Let(("_", Var({val: None})), Put(Var("perm"), Prim(Get(Var("k"), Int(0)), Var("i"), Sub, kind=None), Get(Var("t"), Int(0))), App(Var("flip_loop"), [Prim(Var("i"), Int(1), Add, kind=None)])))), Unit)}, Let(("_", Var({val: None})), App(Var("flip_loop"), [Int(0)]), Let(("_", Var({val: None})), Put(Var("k"), Int(0), Get(Var("perm"), Int(0))), Let(("_", Var({val: None})), Put(Var("flips"), Int(0), Prim(Get(Var("flips"), Int(0)), Int(1), Add, kind=None)), App(Var("do_flip"), [Var("k")])))))), Unit)}, Let(("_", Var({val: None})), App(Var("do_flip"), [Var("k")]), Let(("_", Var({val: None})), If(LE(Get(Var("max_flips"), Int(0)), Get(Var("flips"), Int(0))), Put(Var("max_flips"), Int(0), Get(Var("flips"), Int(0))), Unit), Let(("_", Var({val: None})), Put(Var("check_sum"), Int(0), Prim(Get(Var("check_sum"), Int(0)), Prim(Get(Var("flips"), Int(0)), Prim(Int(1), Prim(Prim(Get(Var("nperm"), Int(0)), Prim(Prim(Get(Var("nperm"), Int(0)), Int(2), Div, kind=None), Int(2), Mul, kind=None), Sub, kind=None), Int(2), Mul, kind=None), Sub, kind=None), Mul, kind=None), Add, kind=None)), Let(("go", Var({val: None})), Array(Int(1), Bool(true)), Let(("t", Var({val: None})), Array(Int(1), Int(0)), LetRec({tyvars: [], name: ("go_loop", Unit), args: [], body: If(Get(Var("go"), Int(0)), Let(("_", Var({val: None})), If(Eq(Get(Var("r"), Int(0)), Var("n")), Let(("_", Var({val: None})), Put(Var("go"), Int(0), Bool(false)), Let(("_", Var({val: None})), Put(Var("r"), Int(0), Int(0)), Unit)), Let(("_", Var({val: None})), Put(Var("t"), Int(0), Get(Var("perm1"), Int(0))), LetRec({tyvars: [], name: ("move_perm1_forward", Unit), args: [("i", Int)], body: If(LE(Var("i"), Prim(Get(Var("r"), Int(0)), Int(1), Sub, kind=None)), Let(("_", Var({val: None})), Put(Var("perm1"), Var("i"), Get(Var("perm1"), Prim(Var("i"), Int(1), Add, kind=None))), Let(("_", Var({val: None})), App(Var("move_perm1_forward"), [Prim(Var("i"), Int(1), Add, kind=None)]), Unit)), Unit)}, Let(("_", Var({val: None})), App(Var("move_perm1_forward"), [Int(0)]), Let(("_", Var({val: None})), Put(Var("perm1"), Get(Var("r"), Int(0)), Get(Var("t"), Int(0))), Let(("_", Var({val: None})), Put(Var("count"), Get(Var("r"), Int(0)), Prim(Get(Var("count"), Get(Var("r"), Int(0))), Int(1), Sub, kind=None)), Let(("_", Var({val: None})), If(LE(Int(1), Get(Var("count"), Get(Var("r"), Int(0)))), Put(Var("go"), Int(0), Bool(false)), Put(Var("r"), Int(0), Prim(Get(Var("r"), Int(0)), Int(1), Add, kind=None))), Unit))))))), App(Var("go_loop"), [])), Unit)}, Let(("_", Var({val: None})), App(Var("go_loop"), []), Let(("_", Var({val: None})), Put(Var("nperm"), Int(0), Prim(Get(Var("nperm"), Int(0)), Int(1), Add, kind=None)), App(Var("compute"), [Var("r")])))))))))))))))), Unit)}, Let(("_", Var({val: None})), App(Var("compute"), [Var("r")]), Tuple([Get(Var("max_flips"), Int(0)), Get(Var("check_sum"), Int(0))]))))))) against Tuple([Int, Int])
// [Typer] infer: Array(Int(1), Int(0))
// [Typer] infer: Int(0)
// [Typer] check: Int(1) against Int
// [Typer] unify: Var({val: None}) and Array(Int)
// [Typer] union: Var({val: None}) and Array(Int)
// [Typer] check: Let(("check_sum", Var({val: None})), Array(Int(1), Int(0)), Let(("nperm", Var({val: None})), Array(Int(1), Int(0)), Let(("r", Var({val: None})), Array(Int(1), Var("n")), LetRec({tyvars: [], name: ("compute", Unit), args: [("r", Array(Int))], body: If(LE(Int(1), Get(Var("r"), Int(0))), LetRec({tyvars: [], name: ("copy_perm", Unit), args: [("i", Int)], body: If(LE(Var("i"), Prim(Var("n"), Int(1), Sub, kind=None)), Let(("_", Var({val: None})), Put(Var("perm"), Var("i"), Get(Var("perm1"), Var("i"))), App(Var("copy_perm"), [Prim(Var("i"), Int(1), Add, kind=None)])), Unit)}, Let(("_", Var({val: None})), App(Var("copy_perm"), [Int(0)]), LetRec({tyvars: [], name: ("init_count", Unit), args: [], body: Let(("_", Var({val: None})), If(Not(Eq(Get(Var("r"), Int(0)), Int(1))), Let(("_", Var({val: None})), Put(Var("count"), Prim(Get(Var("r"), Int(0)), Int(1), Sub, kind=None), Get(Var("r"), Int(0))), Let(("_", Var({val: None})), Put(Var("r"), Int(0), Prim(Get(Var("r"), Int(0)), Int(1), Sub, kind=None)), App(Var("init_count"), []))), Unit), Unit)}, Let(("_", Var({val: None})), App(Var("init_count"), []), Let(("_", Var({val: None})), Put(Var("flips"), Int(0), Int(0)), Let(("k", Var({val: None})), Array(Int(1), Get(Var("perm"), Int(0))), LetRec({tyvars: [], name: ("do_flip", Unit), args: [("k", Array(Int))], body: If(Not(Eq(Get(Var("k"), Int(0)), Int(0))), Let(("t", Var({val: None})), Array(Int(1), Int(0)), LetRec({tyvars: [], name: ("flip_loop", Unit), args: [("i", Int)], body: If(LE(Var("i"), Prim(Get(Var("k"), Int(0)), Int(2), Div, kind=None)), Let(("_", Var({val: None})), Put(Var("t"), Int(0), Get(Var("perm"), Var("i"))), Let(("_", Var({val: None})), Put(Var("perm"), Var("i"), Get(Var("perm"), Prim(Get(Var("k"), Int(0)), Var("i"), Sub, kind=None))), Let(("_", Var({val: None})), Put(Var("perm"), Prim(Get(Var("k"), Int(0)), Var("i"), Sub, kind=None), Get(Var("t"), Int(0))), App(Var("flip_loop"), [Prim(Var("i"), Int(1), Add, kind=None)])))), Unit)}, Let(("_", Var({val: None})), App(Var("flip_loop"), [Int(0)]), Let(("_", Var({val: None})), Put(Var("k"), Int(0), Get(Var("perm"), Int(0))), Let(("_", Var({val: None})), Put(Var("flips"), Int(0), Prim(Get(Var("flips"), Int(0)), Int(1), Add, kind=None)), App(Var("do_flip"), [Var("k")])))))), Unit)}, Let(("_", Var({val: None})), App(Var("do_flip"), [Var("k")]), Let(("_", Var({val: None})), If(LE(Get(Var("max_flips"), Int(0)), Get(Var("flips"), Int(0))), Put(Var("max_flips"), Int(0), Get(Var("flips"), Int(0))), Unit), Let(("_", Var({val: None})), Put(Var("check_sum"), Int(0), Prim(Get(Var("check_sum"), Int(0)), Prim(Get(Var("flips"), Int(0)), Prim(Int(1), Prim(Prim(Get(Var("nperm"), Int(0)), Prim(Prim(Get(Var("nperm"), Int(0)), Int(2), Div, kind=None), Int(2), Mul, kind=None), Sub, kind=None), Int(2), Mul, kind=None), Sub, kind=None), Mul, kind=None), Add, kind=None)), Let(("go", Var({val: None})), Array(Int(1), Bool(true)), Let(("t", Var({val: None})), Array(Int(1), Int(0)), LetRec({tyvars: [], name: ("go_loop", Unit), args: [], body: If(Get(Var("go"), Int(0)), Let(("_", Var({val: None})), If(Eq(Get(Var("r"), Int(0)), Var("n")), Let(("_", Var({val: None})), Put(Var("go"), Int(0), Bool(false)), Let(("_", Var({val: None})), Put(Var("r"), Int(0), Int(0)), Unit)), Let(("_", Var({val: None})), Put(Var("t"), Int(0), Get(Var("perm1"), Int(0))), LetRec({tyvars: [], name: ("move_perm1_forward", Unit), args: [("i", Int)], body: If(LE(Var("i"), Prim(Get(Var("r"), Int(0)), Int(1), Sub, kind=None)), Let(("_", Var({val: None})), Put(Var("perm1"), Var("i"), Get(Var("perm1"), Prim(Var("i"), Int(1), Add, kind=None))), Let(("_", Var({val: None})), App(Var("move_perm1_forward"), [Prim(Var("i"), Int(1), Add, kind=None)]), Unit)), Unit)}, Let(("_", Var({val: None})), App(Var("move_perm1_forward"), [Int(0)]), Let(("_", Var({val: None})), Put(Var("perm1"), Get(Var("r"), Int(0)), Get(Var("t"), Int(0))), Let(("_", Var({val: None})), Put(Var("count"), Get(Var("r"), Int(0)), Prim(Get(Var("count"), Get(Var("r"), Int(0))), Int(1), Sub, kind=None)), Let(("_", Var({val: None})), If(LE(Int(1), Get(Var("count"), Get(Var("r"), Int(0)))), Put(Var("go"), Int(0), Bool(false)), Put(Var("r"), Int(0), Prim(Get(Var("r"), Int(0)), Int(1), Add, kind=None))), Unit))))))), App(Var("go_loop"), [])), Unit)}, Let(("_", Var({val: None})), App(Var("go_loop"), []), Let(("_", Var({val: None})), Put(Var("nperm"), Int(0), Prim(Get(Var("nperm"), Int(0)), Int(1), Add, kind=None)), App(Var("compute"), [Var("r")])))))))))))))))), Unit)}, Let(("_", Var({val: None})), App(Var("compute"), [Var("r")]), Tuple([Get(Var("max_flips"), Int(0)), Get(Var("check_sum"), Int(0))])))))) against Tuple([Int, Int])
// [Typer] infer: Array(Int(1), Int(0))
// [Typer] infer: Int(0)
// [Typer] check: Int(1) against Int
// [Typer] unify: Var({val: None}) and Array(Int)
// [Typer] union: Var({val: None}) and Array(Int)
// [Typer] check: Let(("nperm", Var({val: None})), Array(Int(1), Int(0)), Let(("r", Var({val: None})), Array(Int(1), Var("n")), LetRec({tyvars: [], name: ("compute", Unit), args: [("r", Array(Int))], body: If(LE(Int(1), Get(Var("r"), Int(0))), LetRec({tyvars: [], name: ("copy_perm", Unit), args: [("i", Int)], body: If(LE(Var("i"), Prim(Var("n"), Int(1), Sub, kind=None)), Let(("_", Var({val: None})), Put(Var("perm"), Var("i"), Get(Var("perm1"), Var("i"))), App(Var("copy_perm"), [Prim(Var("i"), Int(1), Add, kind=None)])), Unit)}, Let(("_", Var({val: None})), App(Var("copy_perm"), [Int(0)]), LetRec({tyvars: [], name: ("init_count", Unit), args: [], body: Let(("_", Var({val: None})), If(Not(Eq(Get(Var("r"), Int(0)), Int(1))), Let(("_", Var({val: None})), Put(Var("count"), Prim(Get(Var("r"), Int(0)), Int(1), Sub, kind=None), Get(Var("r"), Int(0))), Let(("_", Var({val: None})), Put(Var("r"), Int(0), Prim(Get(Var("r"), Int(0)), Int(1), Sub, kind=None)), App(Var("init_count"), []))), Unit), Unit)}, Let(("_", Var({val: None})), App(Var("init_count"), []), Let(("_", Var({val: None})), Put(Var("flips"), Int(0), Int(0)), Let(("k", Var({val: None})), Array(Int(1), Get(Var("perm"), Int(0))), LetRec({tyvars: [], name: ("do_flip", Unit), args: [("k", Array(Int))], body: If(Not(Eq(Get(Var("k"), Int(0)), Int(0))), Let(("t", Var({val: None})), Array(Int(1), Int(0)), LetRec({tyvars: [], name: ("flip_loop", Unit), args: [("i", Int)], body: If(LE(Var("i"), Prim(Get(Var("k"), Int(0)), Int(2), Div, kind=None)), Let(("_", Var({val: None})), Put(Var("t"), Int(0), Get(Var("perm"), Var("i"))), Let(("_", Var({val: None})), Put(Var("perm"), Var("i"), Get(Var("perm"), Prim(Get(Var("k"), Int(0)), Var("i"), Sub, kind=None))), Let(("_", Var({val: None})), Put(Var("perm"), Prim(Get(Var("k"), Int(0)), Var("i"), Sub, kind=None), Get(Var("t"), Int(0))), App(Var("flip_loop"), [Prim(Var("i"), Int(1), Add, kind=None)])))), Unit)}, Let(("_", Var({val: None})), App(Var("flip_loop"), [Int(0)]), Let(("_", Var({val: None})), Put(Var("k"), Int(0), Get(Var("perm"), Int(0))), Let(("_", Var({val: None})), Put(Var("flips"), Int(0), Prim(Get(Var("flips"), Int(0)), Int(1), Add, kind=None)), App(Var("do_flip"), [Var("k")])))))), Unit)}, Let(("_", Var({val: None})), App(Var("do_flip"), [Var("k")]), Let(("_", Var({val: None})), If(LE(Get(Var("max_flips"), Int(0)), Get(Var("flips"), Int(0))), Put(Var("max_flips"), Int(0), Get(Var("flips"), Int(0))), Unit), Let(("_", Var({val: None})), Put(Var("check_sum"), Int(0), Prim(Get(Var("check_sum"), Int(0)), Prim(Get(Var("flips"), Int(0)), Prim(Int(1), Prim(Prim(Get(Var("nperm"), Int(0)), Prim(Prim(Get(Var("nperm"), Int(0)), Int(2), Div, kind=None), Int(2), Mul, kind=None), Sub, kind=None), Int(2), Mul, kind=None), Sub, kind=None), Mul, kind=None), Add, kind=None)), Let(("go", Var({val: None})), Array(Int(1), Bool(true)), Let(("t", Var({val: None})), Array(Int(1), Int(0)), LetRec({tyvars: [], name: ("go_loop", Unit), args: [], body: If(Get(Var("go"), Int(0)), Let(("_", Var({val: None})), If(Eq(Get(Var("r"), Int(0)), Var("n")), Let(("_", Var({val: None})), Put(Var("go"), Int(0), Bool(false)), Let(("_", Var({val: None})), Put(Var("r"), Int(0), Int(0)), Unit)), Let(("_", Var({val: None})), Put(Var("t"), Int(0), Get(Var("perm1"), Int(0))), LetRec({tyvars: [], name: ("move_perm1_forward", Unit), args: [("i", Int)], body: If(LE(Var("i"), Prim(Get(Var("r"), Int(0)), Int(1), Sub, kind=None)), Let(("_", Var({val: None})), Put(Var("perm1"), Var("i"), Get(Var("perm1"), Prim(Var("i"), Int(1), Add, kind=None))), Let(("_", Var({val: None})), App(Var("move_perm1_forward"), [Prim(Var("i"), Int(1), Add, kind=None)]), Unit)), Unit)}, Let(("_", Var({val: None})), App(Var("move_perm1_forward"), [Int(0)]), Let(("_", Var({val: None})), Put(Var("perm1"), Get(Var("r"), Int(0)), Get(Var("t"), Int(0))), Let(("_", Var({val: None})), Put(Var("count"), Get(Var("r"), Int(0)), Prim(Get(Var("count"), Get(Var("r"), Int(0))), Int(1), Sub, kind=None)), Let(("_", Var({val: None})), If(LE(Int(1), Get(Var("count"), Get(Var("r"), Int(0)))), Put(Var("go"), Int(0), Bool(false)), Put(Var("r"), Int(0), Prim(Get(Var("r"), Int(0)), Int(1), Add, kind=None))), Unit))))))), App(Var("go_loop"), [])), Unit)}, Let(("_", Var({val: None})), App(Var("go_loop"), []), Let(("_", Var({val: None})), Put(Var("nperm"), Int(0), Prim(Get(Var("nperm"), Int(0)), Int(1), Add, kind=None)), App(Var("compute"), [Var("r")])))))))))))))))), Unit)}, Let(("_", Var({val: None})), App(Var("compute"), [Var("r")]), Tuple([Get(Var("max_flips"), Int(0)), Get(Var("check_sum"), Int(0))]))))) against Tuple([Int, Int])
// [Typer] infer: Array(Int(1), Int(0))
// [Typer] infer: Int(0)
// [Typer] check: Int(1) against Int
// [Typer] unify: Var({val: None}) and Array(Int)
// [Typer] union: Var({val: None}) and Array(Int)
// [Typer] check: Let(("r", Var({val: None})), Array(Int(1), Var("n")), LetRec({tyvars: [], name: ("compute", Unit), args: [("r", Array(Int))], body: If(LE(Int(1), Get(Var("r"), Int(0))), LetRec({tyvars: [], name: ("copy_perm", Unit), args: [("i", Int)], body: If(LE(Var("i"), Prim(Var("n"), Int(1), Sub, kind=None)), Let(("_", Var({val: None})), Put(Var("perm"), Var("i"), Get(Var("perm1"), Var("i"))), App(Var("copy_perm"), [Prim(Var("i"), Int(1), Add, kind=None)])), Unit)}, Let(("_", Var({val: None})), App(Var("copy_perm"), [Int(0)]), LetRec({tyvars: [], name: ("init_count", Unit), args: [], body: Let(("_", Var({val: None})), If(Not(Eq(Get(Var("r"), Int(0)), Int(1))), Let(("_", Var({val: None})), Put(Var("count"), Prim(Get(Var("r"), Int(0)), Int(1), Sub, kind=None), Get(Var("r"), Int(0))), Let(("_", Var({val: None})), Put(Var("r"), Int(0), Prim(Get(Var("r"), Int(0)), Int(1), Sub, kind=None)), App(Var("init_count"), []))), Unit), Unit)}, Let(("_", Var({val: None})), App(Var("init_count"), []), Let(("_", Var({val: None})), Put(Var("flips"), Int(0), Int(0)), Let(("k", Var({val: None})), Array(Int(1), Get(Var("perm"), Int(0))), LetRec({tyvars: [], name: ("do_flip", Unit), args: [("k", Array(Int))], body: If(Not(Eq(Get(Var("k"), Int(0)), Int(0))), Let(("t", Var({val: None})), Array(Int(1), Int(0)), LetRec({tyvars: [], name: ("flip_loop", Unit), args: [("i", Int)], body: If(LE(Var("i"), Prim(Get(Var("k"), Int(0)), Int(2), Div, kind=None)), Let(("_", Var({val: None})), Put(Var("t"), Int(0), Get(Var("perm"), Var("i"))), Let(("_", Var({val: None})), Put(Var("perm"), Var("i"), Get(Var("perm"), Prim(Get(Var("k"), Int(0)), Var("i"), Sub, kind=None))), Let(("_", Var({val: None})), Put(Var("perm"), Prim(Get(Var("k"), Int(0)), Var("i"), Sub, kind=None), Get(Var("t"), Int(0))), App(Var("flip_loop"), [Prim(Var("i"), Int(1), Add, kind=None)])))), Unit)}, Let(("_", Var({val: None})), App(Var("flip_loop"), [Int(0)]), Let(("_", Var({val: None})), Put(Var("k"), Int(0), Get(Var("perm"), Int(0))), Let(("_", Var({val: None})), Put(Var("flips"), Int(0), Prim(Get(Var("flips"), Int(0)), Int(1), Add, kind=None)), App(Var("do_flip"), [Var("k")])))))), Unit)}, Let(("_", Var({val: None})), App(Var("do_flip"), [Var("k")]), Let(("_", Var({val: None})), If(LE(Get(Var("max_flips"), Int(0)), Get(Var("flips"), Int(0))), Put(Var("max_flips"), Int(0), Get(Var("flips"), Int(0))), Unit), Let(("_", Var({val: None})), Put(Var("check_sum"), Int(0), Prim(Get(Var("check_sum"), Int(0)), Prim(Get(Var("flips"), Int(0)), Prim(Int(1), Prim(Prim(Get(Var("nperm"), Int(0)), Prim(Prim(Get(Var("nperm"), Int(0)), Int(2), Div, kind=None), Int(2), Mul, kind=None), Sub, kind=None), Int(2), Mul, kind=None), Sub, kind=None), Mul, kind=None), Add, kind=None)), Let(("go", Var({val: None})), Array(Int(1), Bool(true)), Let(("t", Var({val: None})), Array(Int(1), Int(0)), LetRec({tyvars: [], name: ("go_loop", Unit), args: [], body: If(Get(Var("go"), Int(0)), Let(("_", Var({val: None})), If(Eq(Get(Var("r"), Int(0)), Var("n")), Let(("_", Var({val: None})), Put(Var("go"), Int(0), Bool(false)), Let(("_", Var({val: None})), Put(Var("r"), Int(0), Int(0)), Unit)), Let(("_", Var({val: None})), Put(Var("t"), Int(0), Get(Var("perm1"), Int(0))), LetRec({tyvars: [], name: ("move_perm1_forward", Unit), args: [("i", Int)], body: If(LE(Var("i"), Prim(Get(Var("r"), Int(0)), Int(1), Sub, kind=None)), Let(("_", Var({val: None})), Put(Var("perm1"), Var("i"), Get(Var("perm1"), Prim(Var("i"), Int(1), Add, kind=None))), Let(("_", Var({val: None})), App(Var("move_perm1_forward"), [Prim(Var("i"), Int(1), Add, kind=None)]), Unit)), Unit)}, Let(("_", Var({val: None})), App(Var("move_perm1_forward"), [Int(0)]), Let(("_", Var({val: None})), Put(Var("perm1"), Get(Var("r"), Int(0)), Get(Var("t"), Int(0))), Let(("_", Var({val: None})), Put(Var("count"), Get(Var("r"), Int(0)), Prim(Get(Var("count"), Get(Var("r"), Int(0))), Int(1), Sub, kind=None)), Let(("_", Var({val: None})), If(LE(Int(1), Get(Var("count"), Get(Var("r"), Int(0)))), Put(Var("go"), Int(0), Bool(false)), Put(Var("r"), Int(0), Prim(Get(Var("r"), Int(0)), Int(1), Add, kind=None))), Unit))))))), App(Var("go_loop"), [])), Unit)}, Let(("_", Var({val: None})), App(Var("go_loop"), []), Let(("_", Var({val: None})), Put(Var("nperm"), Int(0), Prim(Get(Var("nperm"), Int(0)), Int(1), Add, kind=None)), App(Var("compute"), [Var("r")])))))))))))))))), Unit)}, Let(("_", Var({val: None})), App(Var("compute"), [Var("r")]), Tuple([Get(Var("max_flips"), Int(0)), Get(Var("check_sum"), Int(0))])))) against Tuple([Int, Int])
// [Typer] infer: Array(Int(1), Var("n"))
// [Typer] infer: Var("n")
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] check: Int(1) against Int
// [Typer] unify: Var({val: None}) and Array(Int)
// [Typer] union: Var({val: None}) and Array(Int)
// [Typer] check: LetRec({tyvars: [], name: ("compute", Unit), args: [("r", Array(Int))], body: If(LE(Int(1), Get(Var("r"), Int(0))), LetRec({tyvars: [], name: ("copy_perm", Unit), args: [("i", Int)], body: If(LE(Var("i"), Prim(Var("n"), Int(1), Sub, kind=None)), Let(("_", Var({val: None})), Put(Var("perm"), Var("i"), Get(Var("perm1"), Var("i"))), App(Var("copy_perm"), [Prim(Var("i"), Int(1), Add, kind=None)])), Unit)}, Let(("_", Var({val: None})), App(Var("copy_perm"), [Int(0)]), LetRec({tyvars: [], name: ("init_count", Unit), args: [], body: Let(("_", Var({val: None})), If(Not(Eq(Get(Var("r"), Int(0)), Int(1))), Let(("_", Var({val: None})), Put(Var("count"), Prim(Get(Var("r"), Int(0)), Int(1), Sub, kind=None), Get(Var("r"), Int(0))), Let(("_", Var({val: None})), Put(Var("r"), Int(0), Prim(Get(Var("r"), Int(0)), Int(1), Sub, kind=None)), App(Var("init_count"), []))), Unit), Unit)}, Let(("_", Var({val: None})), App(Var("init_count"), []), Let(("_", Var({val: None})), Put(Var("flips"), Int(0), Int(0)), Let(("k", Var({val: None})), Array(Int(1), Get(Var("perm"), Int(0))), LetRec({tyvars: [], name: ("do_flip", Unit), args: [("k", Array(Int))], body: If(Not(Eq(Get(Var("k"), Int(0)), Int(0))), Let(("t", Var({val: None})), Array(Int(1), Int(0)), LetRec({tyvars: [], name: ("flip_loop", Unit), args: [("i", Int)], body: If(LE(Var("i"), Prim(Get(Var("k"), Int(0)), Int(2), Div, kind=None)), Let(("_", Var({val: None})), Put(Var("t"), Int(0), Get(Var("perm"), Var("i"))), Let(("_", Var({val: None})), Put(Var("perm"), Var("i"), Get(Var("perm"), Prim(Get(Var("k"), Int(0)), Var("i"), Sub, kind=None))), Let(("_", Var({val: None})), Put(Var("perm"), Prim(Get(Var("k"), Int(0)), Var("i"), Sub, kind=None), Get(Var("t"), Int(0))), App(Var("flip_loop"), [Prim(Var("i"), Int(1), Add, kind=None)])))), Unit)}, Let(("_", Var({val: None})), App(Var("flip_loop"), [Int(0)]), Let(("_", Var({val: None})), Put(Var("k"), Int(0), Get(Var("perm"), Int(0))), Let(("_", Var({val: None})), Put(Var("flips"), Int(0), Prim(Get(Var("flips"), Int(0)), Int(1), Add, kind=None)), App(Var("do_flip"), [Var("k")])))))), Unit)}, Let(("_", Var({val: None})), App(Var("do_flip"), [Var("k")]), Let(("_", Var({val: None})), If(LE(Get(Var("max_flips"), Int(0)), Get(Var("flips"), Int(0))), Put(Var("max_flips"), Int(0), Get(Var("flips"), Int(0))), Unit), Let(("_", Var({val: None})), Put(Var("check_sum"), Int(0), Prim(Get(Var("check_sum"), Int(0)), Prim(Get(Var("flips"), Int(0)), Prim(Int(1), Prim(Prim(Get(Var("nperm"), Int(0)), Prim(Prim(Get(Var("nperm"), Int(0)), Int(2), Div, kind=None), Int(2), Mul, kind=None), Sub, kind=None), Int(2), Mul, kind=None), Sub, kind=None), Mul, kind=None), Add, kind=None)), Let(("go", Var({val: None})), Array(Int(1), Bool(true)), Let(("t", Var({val: None})), Array(Int(1), Int(0)), LetRec({tyvars: [], name: ("go_loop", Unit), args: [], body: If(Get(Var("go"), Int(0)), Let(("_", Var({val: None})), If(Eq(Get(Var("r"), Int(0)), Var("n")), Let(("_", Var({val: None})), Put(Var("go"), Int(0), Bool(false)), Let(("_", Var({val: None})), Put(Var("r"), Int(0), Int(0)), Unit)), Let(("_", Var({val: None})), Put(Var("t"), Int(0), Get(Var("perm1"), Int(0))), LetRec({tyvars: [], name: ("move_perm1_forward", Unit), args: [("i", Int)], body: If(LE(Var("i"), Prim(Get(Var("r"), Int(0)), Int(1), Sub, kind=None)), Let(("_", Var({val: None})), Put(Var("perm1"), Var("i"), Get(Var("perm1"), Prim(Var("i"), Int(1), Add, kind=None))), Let(("_", Var({val: None})), App(Var("move_perm1_forward"), [Prim(Var("i"), Int(1), Add, kind=None)]), Unit)), Unit)}, Let(("_", Var({val: None})), App(Var("move_perm1_forward"), [Int(0)]), Let(("_", Var({val: None})), Put(Var("perm1"), Get(Var("r"), Int(0)), Get(Var("t"), Int(0))), Let(("_", Var({val: None})), Put(Var("count"), Get(Var("r"), Int(0)), Prim(Get(Var("count"), Get(Var("r"), Int(0))), Int(1), Sub, kind=None)), Let(("_", Var({val: None})), If(LE(Int(1), Get(Var("count"), Get(Var("r"), Int(0)))), Put(Var("go"), Int(0), Bool(false)), Put(Var("r"), Int(0), Prim(Get(Var("r"), Int(0)), Int(1), Add, kind=None))), Unit))))))), App(Var("go_loop"), [])), Unit)}, Let(("_", Var({val: None})), App(Var("go_loop"), []), Let(("_", Var({val: None})), Put(Var("nperm"), Int(0), Prim(Get(Var("nperm"), Int(0)), Int(1), Add, kind=None)), App(Var("compute"), [Var("r")])))))))))))))))), Unit)}, Let(("_", Var({val: None})), App(Var("compute"), [Var("r")]), Tuple([Get(Var("max_flips"), Int(0)), Get(Var("check_sum"), Int(0))]))) against Tuple([Int, Int])
// [Typer] typevars: []
// [Typer] check: If(LE(Int(1), Get(Var("r"), Int(0))), LetRec({tyvars: [], name: ("copy_perm", Unit), args: [("i", Int)], body: If(LE(Var("i"), Prim(Var("n"), Int(1), Sub, kind=None)), Let(("_", Var({val: None})), Put(Var("perm"), Var("i"), Get(Var("perm1"), Var("i"))), App(Var("copy_perm"), [Prim(Var("i"), Int(1), Add, kind=None)])), Unit)}, Let(("_", Var({val: None})), App(Var("copy_perm"), [Int(0)]), LetRec({tyvars: [], name: ("init_count", Unit), args: [], body: Let(("_", Var({val: None})), If(Not(Eq(Get(Var("r"), Int(0)), Int(1))), Let(("_", Var({val: None})), Put(Var("count"), Prim(Get(Var("r"), Int(0)), Int(1), Sub, kind=None), Get(Var("r"), Int(0))), Let(("_", Var({val: None})), Put(Var("r"), Int(0), Prim(Get(Var("r"), Int(0)), Int(1), Sub, kind=None)), App(Var("init_count"), []))), Unit), Unit)}, Let(("_", Var({val: None})), App(Var("init_count"), []), Let(("_", Var({val: None})), Put(Var("flips"), Int(0), Int(0)), Let(("k", Var({val: None})), Array(Int(1), Get(Var("perm"), Int(0))), LetRec({tyvars: [], name: ("do_flip", Unit), args: [("k", Array(Int))], body: If(Not(Eq(Get(Var("k"), Int(0)), Int(0))), Let(("t", Var({val: None})), Array(Int(1), Int(0)), LetRec({tyvars: [], name: ("flip_loop", Unit), args: [("i", Int)], body: If(LE(Var("i"), Prim(Get(Var("k"), Int(0)), Int(2), Div, kind=None)), Let(("_", Var({val: None})), Put(Var("t"), Int(0), Get(Var("perm"), Var("i"))), Let(("_", Var({val: None})), Put(Var("perm"), Var("i"), Get(Var("perm"), Prim(Get(Var("k"), Int(0)), Var("i"), Sub, kind=None))), Let(("_", Var({val: None})), Put(Var("perm"), Prim(Get(Var("k"), Int(0)), Var("i"), Sub, kind=None), Get(Var("t"), Int(0))), App(Var("flip_loop"), [Prim(Var("i"), Int(1), Add, kind=None)])))), Unit)}, Let(("_", Var({val: None})), App(Var("flip_loop"), [Int(0)]), Let(("_", Var({val: None})), Put(Var("k"), Int(0), Get(Var("perm"), Int(0))), Let(("_", Var({val: None})), Put(Var("flips"), Int(0), Prim(Get(Var("flips"), Int(0)), Int(1), Add, kind=None)), App(Var("do_flip"), [Var("k")])))))), Unit)}, Let(("_", Var({val: None})), App(Var("do_flip"), [Var("k")]), Let(("_", Var({val: None})), If(LE(Get(Var("max_flips"), Int(0)), Get(Var("flips"), Int(0))), Put(Var("max_flips"), Int(0), Get(Var("flips"), Int(0))), Unit), Let(("_", Var({val: None})), Put(Var("check_sum"), Int(0), Prim(Get(Var("check_sum"), Int(0)), Prim(Get(Var("flips"), Int(0)), Prim(Int(1), Prim(Prim(Get(Var("nperm"), Int(0)), Prim(Prim(Get(Var("nperm"), Int(0)), Int(2), Div, kind=None), Int(2), Mul, kind=None), Sub, kind=None), Int(2), Mul, kind=None), Sub, kind=None), Mul, kind=None), Add, kind=None)), Let(("go", Var({val: None})), Array(Int(1), Bool(true)), Let(("t", Var({val: None})), Array(Int(1), Int(0)), LetRec({tyvars: [], name: ("go_loop", Unit), args: [], body: If(Get(Var("go"), Int(0)), Let(("_", Var({val: None})), If(Eq(Get(Var("r"), Int(0)), Var("n")), Let(("_", Var({val: None})), Put(Var("go"), Int(0), Bool(false)), Let(("_", Var({val: None})), Put(Var("r"), Int(0), Int(0)), Unit)), Let(("_", Var({val: None})), Put(Var("t"), Int(0), Get(Var("perm1"), Int(0))), LetRec({tyvars: [], name: ("move_perm1_forward", Unit), args: [("i", Int)], body: If(LE(Var("i"), Prim(Get(Var("r"), Int(0)), Int(1), Sub, kind=None)), Let(("_", Var({val: None})), Put(Var("perm1"), Var("i"), Get(Var("perm1"), Prim(Var("i"), Int(1), Add, kind=None))), Let(("_", Var({val: None})), App(Var("move_perm1_forward"), [Prim(Var("i"), Int(1), Add, kind=None)]), Unit)), Unit)}, Let(("_", Var({val: None})), App(Var("move_perm1_forward"), [Int(0)]), Let(("_", Var({val: None})), Put(Var("perm1"), Get(Var("r"), Int(0)), Get(Var("t"), Int(0))), Let(("_", Var({val: None})), Put(Var("count"), Get(Var("r"), Int(0)), Prim(Get(Var("count"), Get(Var("r"), Int(0))), Int(1), Sub, kind=None)), Let(("_", Var({val: None})), If(LE(Int(1), Get(Var("count"), Get(Var("r"), Int(0)))), Put(Var("go"), Int(0), Bool(false)), Put(Var("r"), Int(0), Prim(Get(Var("r"), Int(0)), Int(1), Add, kind=None))), Unit))))))), App(Var("go_loop"), [])), Unit)}, Let(("_", Var({val: None})), App(Var("go_loop"), []), Let(("_", Var({val: None})), Put(Var("nperm"), Int(0), Prim(Get(Var("nperm"), Int(0)), Int(1), Add, kind=None)), App(Var("compute"), [Var("r")])))))))))))))))), Unit) against Unit
// [Typer] check: LE(Int(1), Get(Var("r"), Int(0))) against Bool
// [Typer] infer: Int(1)
// [Typer] infer: Get(Var("r"), Int(0))
// [Typer] infer: Var("r")
// [Typer] inst: TypeScheme(([], Array(Int)))
// [Typer] inst result: Array(Int)
// [Typer] check: Int(0) against Int
// [Typer] unify: Int and Int
// [Typer] check: LetRec({tyvars: [], name: ("copy_perm", Unit), args: [("i", Int)], body: If(LE(Var("i"), Prim(Var("n"), Int(1), Sub, kind=None)), Let(("_", Var({val: None})), Put(Var("perm"), Var("i"), Get(Var("perm1"), Var("i"))), App(Var("copy_perm"), [Prim(Var("i"), Int(1), Add, kind=None)])), Unit)}, Let(("_", Var({val: None})), App(Var("copy_perm"), [Int(0)]), LetRec({tyvars: [], name: ("init_count", Unit), args: [], body: Let(("_", Var({val: None})), If(Not(Eq(Get(Var("r"), Int(0)), Int(1))), Let(("_", Var({val: None})), Put(Var("count"), Prim(Get(Var("r"), Int(0)), Int(1), Sub, kind=None), Get(Var("r"), Int(0))), Let(("_", Var({val: None})), Put(Var("r"), Int(0), Prim(Get(Var("r"), Int(0)), Int(1), Sub, kind=None)), App(Var("init_count"), []))), Unit), Unit)}, Let(("_", Var({val: None})), App(Var("init_count"), []), Let(("_", Var({val: None})), Put(Var("flips"), Int(0), Int(0)), Let(("k", Var({val: None})), Array(Int(1), Get(Var("perm"), Int(0))), LetRec({tyvars: [], name: ("do_flip", Unit), args: [("k", Array(Int))], body: If(Not(Eq(Get(Var("k"), Int(0)), Int(0))), Let(("t", Var({val: None})), Array(Int(1), Int(0)), LetRec({tyvars: [], name: ("flip_loop", Unit), args: [("i", Int)], body: If(LE(Var("i"), Prim(Get(Var("k"), Int(0)), Int(2), Div, kind=None)), Let(("_", Var({val: None})), Put(Var("t"), Int(0), Get(Var("perm"), Var("i"))), Let(("_", Var({val: None})), Put(Var("perm"), Var("i"), Get(Var("perm"), Prim(Get(Var("k"), Int(0)), Var("i"), Sub, kind=None))), Let(("_", Var({val: None})), Put(Var("perm"), Prim(Get(Var("k"), Int(0)), Var("i"), Sub, kind=None), Get(Var("t"), Int(0))), App(Var("flip_loop"), [Prim(Var("i"), Int(1), Add, kind=None)])))), Unit)}, Let(("_", Var({val: None})), App(Var("flip_loop"), [Int(0)]), Let(("_", Var({val: None})), Put(Var("k"), Int(0), Get(Var("perm"), Int(0))), Let(("_", Var({val: None})), Put(Var("flips"), Int(0), Prim(Get(Var("flips"), Int(0)), Int(1), Add, kind=None)), App(Var("do_flip"), [Var("k")])))))), Unit)}, Let(("_", Var({val: None})), App(Var("do_flip"), [Var("k")]), Let(("_", Var({val: None})), If(LE(Get(Var("max_flips"), Int(0)), Get(Var("flips"), Int(0))), Put(Var("max_flips"), Int(0), Get(Var("flips"), Int(0))), Unit), Let(("_", Var({val: None})), Put(Var("check_sum"), Int(0), Prim(Get(Var("check_sum"), Int(0)), Prim(Get(Var("flips"), Int(0)), Prim(Int(1), Prim(Prim(Get(Var("nperm"), Int(0)), Prim(Prim(Get(Var("nperm"), Int(0)), Int(2), Div, kind=None), Int(2), Mul, kind=None), Sub, kind=None), Int(2), Mul, kind=None), Sub, kind=None), Mul, kind=None), Add, kind=None)), Let(("go", Var({val: None})), Array(Int(1), Bool(true)), Let(("t", Var({val: None})), Array(Int(1), Int(0)), LetRec({tyvars: [], name: ("go_loop", Unit), args: [], body: If(Get(Var("go"), Int(0)), Let(("_", Var({val: None})), If(Eq(Get(Var("r"), Int(0)), Var("n")), Let(("_", Var({val: None})), Put(Var("go"), Int(0), Bool(false)), Let(("_", Var({val: None})), Put(Var("r"), Int(0), Int(0)), Unit)), Let(("_", Var({val: None})), Put(Var("t"), Int(0), Get(Var("perm1"), Int(0))), LetRec({tyvars: [], name: ("move_perm1_forward", Unit), args: [("i", Int)], body: If(LE(Var("i"), Prim(Get(Var("r"), Int(0)), Int(1), Sub, kind=None)), Let(("_", Var({val: None})), Put(Var("perm1"), Var("i"), Get(Var("perm1"), Prim(Var("i"), Int(1), Add, kind=None))), Let(("_", Var({val: None})), App(Var("move_perm1_forward"), [Prim(Var("i"), Int(1), Add, kind=None)]), Unit)), Unit)}, Let(("_", Var({val: None})), App(Var("move_perm1_forward"), [Int(0)]), Let(("_", Var({val: None})), Put(Var("perm1"), Get(Var("r"), Int(0)), Get(Var("t"), Int(0))), Let(("_", Var({val: None})), Put(Var("count"), Get(Var("r"), Int(0)), Prim(Get(Var("count"), Get(Var("r"), Int(0))), Int(1), Sub, kind=None)), Let(("_", Var({val: None})), If(LE(Int(1), Get(Var("count"), Get(Var("r"), Int(0)))), Put(Var("go"), Int(0), Bool(false)), Put(Var("r"), Int(0), Prim(Get(Var("r"), Int(0)), Int(1), Add, kind=None))), Unit))))))), App(Var("go_loop"), [])), Unit)}, Let(("_", Var({val: None})), App(Var("go_loop"), []), Let(("_", Var({val: None})), Put(Var("nperm"), Int(0), Prim(Get(Var("nperm"), Int(0)), Int(1), Add, kind=None)), App(Var("compute"), [Var("r")])))))))))))))))) against Unit
// [Typer] typevars: []
// [Typer] check: If(LE(Var("i"), Prim(Var("n"), Int(1), Sub, kind=None)), Let(("_", Var({val: None})), Put(Var("perm"), Var("i"), Get(Var("perm1"), Var("i"))), App(Var("copy_perm"), [Prim(Var("i"), Int(1), Add, kind=None)])), Unit) against Unit
// [Typer] check: LE(Var("i"), Prim(Var("n"), Int(1), Sub, kind=None)) against Bool
// [Typer] infer: Var("i")
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] infer: Prim(Var("n"), Int(1), Sub, kind=None)
// [Typer] infer: Var("n")
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] infer: Int(1)
// [Typer] unify: Int and Int
// [Typer] unify: Int and Int
// [Typer] check: Let(("_", Var({val: None})), Put(Var("perm"), Var("i"), Get(Var("perm1"), Var("i"))), App(Var("copy_perm"), [Prim(Var("i"), Int(1), Add, kind=None)])) against Unit
// [Typer] infer: Put(Var("perm"), Var("i"), Get(Var("perm1"), Var("i")))
// [Typer] infer: Get(Var("perm1"), Var("i"))
// [Typer] infer: Var("perm1")
// [Typer] inst: TypeScheme(([], Var({val: Some(Array(Int))})))
// [Typer] inst result: Array(Int)
// [Typer] check: Var("i") against Int
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] check: Var("perm") against Array(Int)
// [Typer] inst: TypeScheme(([], Var({val: Some(Array(Int))})))
// [Typer] inst result: Array(Int)
// [Typer] unify: Array(Int) and Array(Int)
// [Typer] unify: Int and Int
// [Typer] check: Var("i") against Int
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] unify: Var({val: None}) and Unit
// [Typer] union: Var({val: None}) and Unit
// [Typer] check: App(Var("copy_perm"), [Prim(Var("i"), Int(1), Add, kind=None)]) against Unit
// [Typer] infer: Prim(Var("i"), Int(1), Add, kind=None)
// [Typer] infer: Var("i")
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] infer: Int(1)
// [Typer] unify: Int and Int
// [Typer] check: Var("copy_perm") against Fun([Int], Unit)
// [Typer] inst: TypeScheme(([], Fun([Int], Unit)))
// [Typer] inst result: Fun([Int], Unit)
// [Typer] unify: Fun([Int], Unit) and Fun([Int], Unit)
// [Typer] unify: Int and Int
// [Typer] unify: Unit and Unit
// [Typer] check: Unit against Unit
// [Typer] check: Let(("_", Var({val: None})), App(Var("copy_perm"), [Int(0)]), LetRec({tyvars: [], name: ("init_count", Unit), args: [], body: Let(("_", Var({val: None})), If(Not(Eq(Get(Var("r"), Int(0)), Int(1))), Let(("_", Var({val: None})), Put(Var("count"), Prim(Get(Var("r"), Int(0)), Int(1), Sub, kind=None), Get(Var("r"), Int(0))), Let(("_", Var({val: None})), Put(Var("r"), Int(0), Prim(Get(Var("r"), Int(0)), Int(1), Sub, kind=None)), App(Var("init_count"), []))), Unit), Unit)}, Let(("_", Var({val: None})), App(Var("init_count"), []), Let(("_", Var({val: None})), Put(Var("flips"), Int(0), Int(0)), Let(("k", Var({val: None})), Array(Int(1), Get(Var("perm"), Int(0))), LetRec({tyvars: [], name: ("do_flip", Unit), args: [("k", Array(Int))], body: If(Not(Eq(Get(Var("k"), Int(0)), Int(0))), Let(("t", Var({val: None})), Array(Int(1), Int(0)), LetRec({tyvars: [], name: ("flip_loop", Unit), args: [("i", Int)], body: If(LE(Var("i"), Prim(Get(Var("k"), Int(0)), Int(2), Div, kind=None)), Let(("_", Var({val: None})), Put(Var("t"), Int(0), Get(Var("perm"), Var("i"))), Let(("_", Var({val: None})), Put(Var("perm"), Var("i"), Get(Var("perm"), Prim(Get(Var("k"), Int(0)), Var("i"), Sub, kind=None))), Let(("_", Var({val: None})), Put(Var("perm"), Prim(Get(Var("k"), Int(0)), Var("i"), Sub, kind=None), Get(Var("t"), Int(0))), App(Var("flip_loop"), [Prim(Var("i"), Int(1), Add, kind=None)])))), Unit)}, Let(("_", Var({val: None})), App(Var("flip_loop"), [Int(0)]), Let(("_", Var({val: None})), Put(Var("k"), Int(0), Get(Var("perm"), Int(0))), Let(("_", Var({val: None})), Put(Var("flips"), Int(0), Prim(Get(Var("flips"), Int(0)), Int(1), Add, kind=None)), App(Var("do_flip"), [Var("k")])))))), Unit)}, Let(("_", Var({val: None})), App(Var("do_flip"), [Var("k")]), Let(("_", Var({val: None})), If(LE(Get(Var("max_flips"), Int(0)), Get(Var("flips"), Int(0))), Put(Var("max_flips"), Int(0), Get(Var("flips"), Int(0))), Unit), Let(("_", Var({val: None})), Put(Var("check_sum"), Int(0), Prim(Get(Var("check_sum"), Int(0)), Prim(Get(Var("flips"), Int(0)), Prim(Int(1), Prim(Prim(Get(Var("nperm"), Int(0)), Prim(Prim(Get(Var("nperm"), Int(0)), Int(2), Div, kind=None), Int(2), Mul, kind=None), Sub, kind=None), Int(2), Mul, kind=None), Sub, kind=None), Mul, kind=None), Add, kind=None)), Let(("go", Var({val: None})), Array(Int(1), Bool(true)), Let(("t", Var({val: None})), Array(Int(1), Int(0)), LetRec({tyvars: [], name: ("go_loop", Unit), args: [], body: If(Get(Var("go"), Int(0)), Let(("_", Var({val: None})), If(Eq(Get(Var("r"), Int(0)), Var("n")), Let(("_", Var({val: None})), Put(Var("go"), Int(0), Bool(false)), Let(("_", Var({val: None})), Put(Var("r"), Int(0), Int(0)), Unit)), Let(("_", Var({val: None})), Put(Var("t"), Int(0), Get(Var("perm1"), Int(0))), LetRec({tyvars: [], name: ("move_perm1_forward", Unit), args: [("i", Int)], body: If(LE(Var("i"), Prim(Get(Var("r"), Int(0)), Int(1), Sub, kind=None)), Let(("_", Var({val: None})), Put(Var("perm1"), Var("i"), Get(Var("perm1"), Prim(Var("i"), Int(1), Add, kind=None))), Let(("_", Var({val: None})), App(Var("move_perm1_forward"), [Prim(Var("i"), Int(1), Add, kind=None)]), Unit)), Unit)}, Let(("_", Var({val: None})), App(Var("move_perm1_forward"), [Int(0)]), Let(("_", Var({val: None})), Put(Var("perm1"), Get(Var("r"), Int(0)), Get(Var("t"), Int(0))), Let(("_", Var({val: None})), Put(Var("count"), Get(Var("r"), Int(0)), Prim(Get(Var("count"), Get(Var("r"), Int(0))), Int(1), Sub, kind=None)), Let(("_", Var({val: None})), If(LE(Int(1), Get(Var("count"), Get(Var("r"), Int(0)))), Put(Var("go"), Int(0), Bool(false)), Put(Var("r"), Int(0), Prim(Get(Var("r"), Int(0)), Int(1), Add, kind=None))), Unit))))))), App(Var("go_loop"), [])), Unit)}, Let(("_", Var({val: None})), App(Var("go_loop"), []), Let(("_", Var({val: None})), Put(Var("nperm"), Int(0), Prim(Get(Var("nperm"), Int(0)), Int(1), Add, kind=None)), App(Var("compute"), [Var("r")]))))))))))))))) against Unit
// [Typer] infer: App(Var("copy_perm"), [Int(0)])
// [Typer] infer: Var("copy_perm")
// [Typer] inst: TypeScheme(([], Fun([Int], Unit)))
// [Typer] inst result: Fun([Int], Unit)
// [Typer] check: Int(0) against Int
// [Typer] unify: Var({val: None}) and Unit
// [Typer] union: Var({val: None}) and Unit
// [Typer] check: LetRec({tyvars: [], name: ("init_count", Unit), args: [], body: Let(("_", Var({val: None})), If(Not(Eq(Get(Var("r"), Int(0)), Int(1))), Let(("_", Var({val: None})), Put(Var("count"), Prim(Get(Var("r"), Int(0)), Int(1), Sub, kind=None), Get(Var("r"), Int(0))), Let(("_", Var({val: None})), Put(Var("r"), Int(0), Prim(Get(Var("r"), Int(0)), Int(1), Sub, kind=None)), App(Var("init_count"), []))), Unit), Unit)}, Let(("_", Var({val: None})), App(Var("init_count"), []), Let(("_", Var({val: None})), Put(Var("flips"), Int(0), Int(0)), Let(("k", Var({val: None})), Array(Int(1), Get(Var("perm"), Int(0))), LetRec({tyvars: [], name: ("do_flip", Unit), args: [("k", Array(Int))], body: If(Not(Eq(Get(Var("k"), Int(0)), Int(0))), Let(("t", Var({val: None})), Array(Int(1), Int(0)), LetRec({tyvars: [], name: ("flip_loop", Unit), args: [("i", Int)], body: If(LE(Var("i"), Prim(Get(Var("k"), Int(0)), Int(2), Div, kind=None)), Let(("_", Var({val: None})), Put(Var("t"), Int(0), Get(Var("perm"), Var("i"))), Let(("_", Var({val: None})), Put(Var("perm"), Var("i"), Get(Var("perm"), Prim(Get(Var("k"), Int(0)), Var("i"), Sub, kind=None))), Let(("_", Var({val: None})), Put(Var("perm"), Prim(Get(Var("k"), Int(0)), Var("i"), Sub, kind=None), Get(Var("t"), Int(0))), App(Var("flip_loop"), [Prim(Var("i"), Int(1), Add, kind=None)])))), Unit)}, Let(("_", Var({val: None})), App(Var("flip_loop"), [Int(0)]), Let(("_", Var({val: None})), Put(Var("k"), Int(0), Get(Var("perm"), Int(0))), Let(("_", Var({val: None})), Put(Var("flips"), Int(0), Prim(Get(Var("flips"), Int(0)), Int(1), Add, kind=None)), App(Var("do_flip"), [Var("k")])))))), Unit)}, Let(("_", Var({val: None})), App(Var("do_flip"), [Var("k")]), Let(("_", Var({val: None})), If(LE(Get(Var("max_flips"), Int(0)), Get(Var("flips"), Int(0))), Put(Var("max_flips"), Int(0), Get(Var("flips"), Int(0))), Unit), Let(("_", Var({val: None})), Put(Var("check_sum"), Int(0), Prim(Get(Var("check_sum"), Int(0)), Prim(Get(Var("flips"), Int(0)), Prim(Int(1), Prim(Prim(Get(Var("nperm"), Int(0)), Prim(Prim(Get(Var("nperm"), Int(0)), Int(2), Div, kind=None), Int(2), Mul, kind=None), Sub, kind=None), Int(2), Mul, kind=None), Sub, kind=None), Mul, kind=None), Add, kind=None)), Let(("go", Var({val: None})), Array(Int(1), Bool(true)), Let(("t", Var({val: None})), Array(Int(1), Int(0)), LetRec({tyvars: [], name: ("go_loop", Unit), args: [], body: If(Get(Var("go"), Int(0)), Let(("_", Var({val: None})), If(Eq(Get(Var("r"), Int(0)), Var("n")), Let(("_", Var({val: None})), Put(Var("go"), Int(0), Bool(false)), Let(("_", Var({val: None})), Put(Var("r"), Int(0), Int(0)), Unit)), Let(("_", Var({val: None})), Put(Var("t"), Int(0), Get(Var("perm1"), Int(0))), LetRec({tyvars: [], name: ("move_perm1_forward", Unit), args: [("i", Int)], body: If(LE(Var("i"), Prim(Get(Var("r"), Int(0)), Int(1), Sub, kind=None)), Let(("_", Var({val: None})), Put(Var("perm1"), Var("i"), Get(Var("perm1"), Prim(Var("i"), Int(1), Add, kind=None))), Let(("_", Var({val: None})), App(Var("move_perm1_forward"), [Prim(Var("i"), Int(1), Add, kind=None)]), Unit)), Unit)}, Let(("_", Var({val: None})), App(Var("move_perm1_forward"), [Int(0)]), Let(("_", Var({val: None})), Put(Var("perm1"), Get(Var("r"), Int(0)), Get(Var("t"), Int(0))), Let(("_", Var({val: None})), Put(Var("count"), Get(Var("r"), Int(0)), Prim(Get(Var("count"), Get(Var("r"), Int(0))), Int(1), Sub, kind=None)), Let(("_", Var({val: None})), If(LE(Int(1), Get(Var("count"), Get(Var("r"), Int(0)))), Put(Var("go"), Int(0), Bool(false)), Put(Var("r"), Int(0), Prim(Get(Var("r"), Int(0)), Int(1), Add, kind=None))), Unit))))))), App(Var("go_loop"), [])), Unit)}, Let(("_", Var({val: None})), App(Var("go_loop"), []), Let(("_", Var({val: None})), Put(Var("nperm"), Int(0), Prim(Get(Var("nperm"), Int(0)), Int(1), Add, kind=None)), App(Var("compute"), [Var("r")])))))))))))))) against Unit
// [Typer] typevars: []
// [Typer] check: Let(("_", Var({val: None})), If(Not(Eq(Get(Var("r"), Int(0)), Int(1))), Let(("_", Var({val: None})), Put(Var("count"), Prim(Get(Var("r"), Int(0)), Int(1), Sub, kind=None), Get(Var("r"), Int(0))), Let(("_", Var({val: None})), Put(Var("r"), Int(0), Prim(Get(Var("r"), Int(0)), Int(1), Sub, kind=None)), App(Var("init_count"), []))), Unit), Unit) against Unit
// [Typer] infer: If(Not(Eq(Get(Var("r"), Int(0)), Int(1))), Let(("_", Var({val: None})), Put(Var("count"), Prim(Get(Var("r"), Int(0)), Int(1), Sub, kind=None), Get(Var("r"), Int(0))), Let(("_", Var({val: None})), Put(Var("r"), Int(0), Prim(Get(Var("r"), Int(0)), Int(1), Sub, kind=None)), App(Var("init_count"), []))), Unit)
// [Typer] check: Not(Eq(Get(Var("r"), Int(0)), Int(1))) against Bool
// [Typer] check: Eq(Get(Var("r"), Int(0)), Int(1)) against Bool
// [Typer] infer: Get(Var("r"), Int(0))
// [Typer] infer: Var("r")
// [Typer] inst: TypeScheme(([], Array(Int)))
// [Typer] inst result: Array(Int)
// [Typer] check: Int(0) against Int
// [Typer] infer: Int(1)
// [Typer] unify: Int and Int
// [Typer] infer: Let(("_", Var({val: None})), Put(Var("count"), Prim(Get(Var("r"), Int(0)), Int(1), Sub, kind=None), Get(Var("r"), Int(0))), Let(("_", Var({val: None})), Put(Var("r"), Int(0), Prim(Get(Var("r"), Int(0)), Int(1), Sub, kind=None)), App(Var("init_count"), [])))
// [Typer] infer: Put(Var("count"), Prim(Get(Var("r"), Int(0)), Int(1), Sub, kind=None), Get(Var("r"), Int(0)))
// [Typer] infer: Get(Var("r"), Int(0))
// [Typer] infer: Var("r")
// [Typer] inst: TypeScheme(([], Array(Int)))
// [Typer] inst result: Array(Int)
// [Typer] check: Int(0) against Int
// [Typer] check: Var("count") against Array(Int)
// [Typer] inst: TypeScheme(([], Var({val: Some(Array(Int))})))
// [Typer] inst result: Array(Int)
// [Typer] unify: Array(Int) and Array(Int)
// [Typer] unify: Int and Int
// [Typer] check: Prim(Get(Var("r"), Int(0)), Int(1), Sub, kind=None) against Int
// [Typer] check: Get(Var("r"), Int(0)) against Int
// [Typer] check: Var("r") against Array(Int)
// [Typer] inst: TypeScheme(([], Array(Int)))
// [Typer] inst result: Array(Int)
// [Typer] unify: Array(Int) and Array(Int)
// [Typer] unify: Int and Int
// [Typer] check: Int(0) against Int
// [Typer] check: Int(1) against Int
// [Typer] unify: Var({val: None}) and Unit
// [Typer] union: Var({val: None}) and Unit
// [Typer] infer: Let(("_", Var({val: None})), Put(Var("r"), Int(0), Prim(Get(Var("r"), Int(0)), Int(1), Sub, kind=None)), App(Var("init_count"), []))
// [Typer] infer: Put(Var("r"), Int(0), Prim(Get(Var("r"), Int(0)), Int(1), Sub, kind=None))
// [Typer] infer: Prim(Get(Var("r"), Int(0)), Int(1), Sub, kind=None)
// [Typer] infer: Get(Var("r"), Int(0))
// [Typer] infer: Var("r")
// [Typer] inst: TypeScheme(([], Array(Int)))
// [Typer] inst result: Array(Int)
// [Typer] check: Int(0) against Int
// [Typer] infer: Int(1)
// [Typer] unify: Int and Int
// [Typer] check: Var("r") against Array(Int)
// [Typer] inst: TypeScheme(([], Array(Int)))
// [Typer] inst result: Array(Int)
// [Typer] unify: Array(Int) and Array(Int)
// [Typer] unify: Int and Int
// [Typer] check: Int(0) against Int
// [Typer] unify: Var({val: None}) and Unit
// [Typer] union: Var({val: None}) and Unit
// [Typer] infer: App(Var("init_count"), [])
// [Typer] infer: Var("init_count")
// [Typer] inst: TypeScheme(([], Fun([], Unit)))
// [Typer] inst result: Fun([], Unit)
// [Typer] infer: Unit
// [Typer] unify: Unit and Unit
// [Typer] unify: Var({val: None}) and Unit
// [Typer] union: Var({val: None}) and Unit
// [Typer] check: Unit against Unit
// [Typer] check: Let(("_", Var({val: None})), App(Var("init_count"), []), Let(("_", Var({val: None})), Put(Var("flips"), Int(0), Int(0)), Let(("k", Var({val: None})), Array(Int(1), Get(Var("perm"), Int(0))), LetRec({tyvars: [], name: ("do_flip", Unit), args: [("k", Array(Int))], body: If(Not(Eq(Get(Var("k"), Int(0)), Int(0))), Let(("t", Var({val: None})), Array(Int(1), Int(0)), LetRec({tyvars: [], name: ("flip_loop", Unit), args: [("i", Int)], body: If(LE(Var("i"), Prim(Get(Var("k"), Int(0)), Int(2), Div, kind=None)), Let(("_", Var({val: None})), Put(Var("t"), Int(0), Get(Var("perm"), Var("i"))), Let(("_", Var({val: None})), Put(Var("perm"), Var("i"), Get(Var("perm"), Prim(Get(Var("k"), Int(0)), Var("i"), Sub, kind=None))), Let(("_", Var({val: None})), Put(Var("perm"), Prim(Get(Var("k"), Int(0)), Var("i"), Sub, kind=None), Get(Var("t"), Int(0))), App(Var("flip_loop"), [Prim(Var("i"), Int(1), Add, kind=None)])))), Unit)}, Let(("_", Var({val: None})), App(Var("flip_loop"), [Int(0)]), Let(("_", Var({val: None})), Put(Var("k"), Int(0), Get(Var("perm"), Int(0))), Let(("_", Var({val: None})), Put(Var("flips"), Int(0), Prim(Get(Var("flips"), Int(0)), Int(1), Add, kind=None)), App(Var("do_flip"), [Var("k")])))))), Unit)}, Let(("_", Var({val: None})), App(Var("do_flip"), [Var("k")]), Let(("_", Var({val: None})), If(LE(Get(Var("max_flips"), Int(0)), Get(Var("flips"), Int(0))), Put(Var("max_flips"), Int(0), Get(Var("flips"), Int(0))), Unit), Let(("_", Var({val: None})), Put(Var("check_sum"), Int(0), Prim(Get(Var("check_sum"), Int(0)), Prim(Get(Var("flips"), Int(0)), Prim(Int(1), Prim(Prim(Get(Var("nperm"), Int(0)), Prim(Prim(Get(Var("nperm"), Int(0)), Int(2), Div, kind=None), Int(2), Mul, kind=None), Sub, kind=None), Int(2), Mul, kind=None), Sub, kind=None), Mul, kind=None), Add, kind=None)), Let(("go", Var({val: None})), Array(Int(1), Bool(true)), Let(("t", Var({val: None})), Array(Int(1), Int(0)), LetRec({tyvars: [], name: ("go_loop", Unit), args: [], body: If(Get(Var("go"), Int(0)), Let(("_", Var({val: None})), If(Eq(Get(Var("r"), Int(0)), Var("n")), Let(("_", Var({val: None})), Put(Var("go"), Int(0), Bool(false)), Let(("_", Var({val: None})), Put(Var("r"), Int(0), Int(0)), Unit)), Let(("_", Var({val: None})), Put(Var("t"), Int(0), Get(Var("perm1"), Int(0))), LetRec({tyvars: [], name: ("move_perm1_forward", Unit), args: [("i", Int)], body: If(LE(Var("i"), Prim(Get(Var("r"), Int(0)), Int(1), Sub, kind=None)), Let(("_", Var({val: None})), Put(Var("perm1"), Var("i"), Get(Var("perm1"), Prim(Var("i"), Int(1), Add, kind=None))), Let(("_", Var({val: None})), App(Var("move_perm1_forward"), [Prim(Var("i"), Int(1), Add, kind=None)]), Unit)), Unit)}, Let(("_", Var({val: None})), App(Var("move_perm1_forward"), [Int(0)]), Let(("_", Var({val: None})), Put(Var("perm1"), Get(Var("r"), Int(0)), Get(Var("t"), Int(0))), Let(("_", Var({val: None})), Put(Var("count"), Get(Var("r"), Int(0)), Prim(Get(Var("count"), Get(Var("r"), Int(0))), Int(1), Sub, kind=None)), Let(("_", Var({val: None})), If(LE(Int(1), Get(Var("count"), Get(Var("r"), Int(0)))), Put(Var("go"), Int(0), Bool(false)), Put(Var("r"), Int(0), Prim(Get(Var("r"), Int(0)), Int(1), Add, kind=None))), Unit))))))), App(Var("go_loop"), [])), Unit)}, Let(("_", Var({val: None})), App(Var("go_loop"), []), Let(("_", Var({val: None})), Put(Var("nperm"), Int(0), Prim(Get(Var("nperm"), Int(0)), Int(1), Add, kind=None)), App(Var("compute"), [Var("r")]))))))))))))) against Unit
// [Typer] infer: App(Var("init_count"), [])
// [Typer] infer: Var("init_count")
// [Typer] inst: TypeScheme(([], Fun([], Unit)))
// [Typer] inst result: Fun([], Unit)
// [Typer] unify: Var({val: None}) and Unit
// [Typer] union: Var({val: None}) and Unit
// [Typer] check: Let(("_", Var({val: None})), Put(Var("flips"), Int(0), Int(0)), Let(("k", Var({val: None})), Array(Int(1), Get(Var("perm"), Int(0))), LetRec({tyvars: [], name: ("do_flip", Unit), args: [("k", Array(Int))], body: If(Not(Eq(Get(Var("k"), Int(0)), Int(0))), Let(("t", Var({val: None})), Array(Int(1), Int(0)), LetRec({tyvars: [], name: ("flip_loop", Unit), args: [("i", Int)], body: If(LE(Var("i"), Prim(Get(Var("k"), Int(0)), Int(2), Div, kind=None)), Let(("_", Var({val: None})), Put(Var("t"), Int(0), Get(Var("perm"), Var("i"))), Let(("_", Var({val: None})), Put(Var("perm"), Var("i"), Get(Var("perm"), Prim(Get(Var("k"), Int(0)), Var("i"), Sub, kind=None))), Let(("_", Var({val: None})), Put(Var("perm"), Prim(Get(Var("k"), Int(0)), Var("i"), Sub, kind=None), Get(Var("t"), Int(0))), App(Var("flip_loop"), [Prim(Var("i"), Int(1), Add, kind=None)])))), Unit)}, Let(("_", Var({val: None})), App(Var("flip_loop"), [Int(0)]), Let(("_", Var({val: None})), Put(Var("k"), Int(0), Get(Var("perm"), Int(0))), Let(("_", Var({val: None})), Put(Var("flips"), Int(0), Prim(Get(Var("flips"), Int(0)), Int(1), Add, kind=None)), App(Var("do_flip"), [Var("k")])))))), Unit)}, Let(("_", Var({val: None})), App(Var("do_flip"), [Var("k")]), Let(("_", Var({val: None})), If(LE(Get(Var("max_flips"), Int(0)), Get(Var("flips"), Int(0))), Put(Var("max_flips"), Int(0), Get(Var("flips"), Int(0))), Unit), Let(("_", Var({val: None})), Put(Var("check_sum"), Int(0), Prim(Get(Var("check_sum"), Int(0)), Prim(Get(Var("flips"), Int(0)), Prim(Int(1), Prim(Prim(Get(Var("nperm"), Int(0)), Prim(Prim(Get(Var("nperm"), Int(0)), Int(2), Div, kind=None), Int(2), Mul, kind=None), Sub, kind=None), Int(2), Mul, kind=None), Sub, kind=None), Mul, kind=None), Add, kind=None)), Let(("go", Var({val: None})), Array(Int(1), Bool(true)), Let(("t", Var({val: None})), Array(Int(1), Int(0)), LetRec({tyvars: [], name: ("go_loop", Unit), args: [], body: If(Get(Var("go"), Int(0)), Let(("_", Var({val: None})), If(Eq(Get(Var("r"), Int(0)), Var("n")), Let(("_", Var({val: None})), Put(Var("go"), Int(0), Bool(false)), Let(("_", Var({val: None})), Put(Var("r"), Int(0), Int(0)), Unit)), Let(("_", Var({val: None})), Put(Var("t"), Int(0), Get(Var("perm1"), Int(0))), LetRec({tyvars: [], name: ("move_perm1_forward", Unit), args: [("i", Int)], body: If(LE(Var("i"), Prim(Get(Var("r"), Int(0)), Int(1), Sub, kind=None)), Let(("_", Var({val: None})), Put(Var("perm1"), Var("i"), Get(Var("perm1"), Prim(Var("i"), Int(1), Add, kind=None))), Let(("_", Var({val: None})), App(Var("move_perm1_forward"), [Prim(Var("i"), Int(1), Add, kind=None)]), Unit)), Unit)}, Let(("_", Var({val: None})), App(Var("move_perm1_forward"), [Int(0)]), Let(("_", Var({val: None})), Put(Var("perm1"), Get(Var("r"), Int(0)), Get(Var("t"), Int(0))), Let(("_", Var({val: None})), Put(Var("count"), Get(Var("r"), Int(0)), Prim(Get(Var("count"), Get(Var("r"), Int(0))), Int(1), Sub, kind=None)), Let(("_", Var({val: None})), If(LE(Int(1), Get(Var("count"), Get(Var("r"), Int(0)))), Put(Var("go"), Int(0), Bool(false)), Put(Var("r"), Int(0), Prim(Get(Var("r"), Int(0)), Int(1), Add, kind=None))), Unit))))))), App(Var("go_loop"), [])), Unit)}, Let(("_", Var({val: None})), App(Var("go_loop"), []), Let(("_", Var({val: None})), Put(Var("nperm"), Int(0), Prim(Get(Var("nperm"), Int(0)), Int(1), Add, kind=None)), App(Var("compute"), [Var("r")])))))))))))) against Unit
// [Typer] infer: Put(Var("flips"), Int(0), Int(0))
// [Typer] infer: Int(0)
// [Typer] check: Var("flips") against Array(Int)
// [Typer] inst: TypeScheme(([], Var({val: Some(Array(Int))})))
// [Typer] inst result: Array(Int)
// [Typer] unify: Array(Int) and Array(Int)
// [Typer] unify: Int and Int
// [Typer] check: Int(0) against Int
// [Typer] unify: Var({val: None}) and Unit
// [Typer] union: Var({val: None}) and Unit
// [Typer] check: Let(("k", Var({val: None})), Array(Int(1), Get(Var("perm"), Int(0))), LetRec({tyvars: [], name: ("do_flip", Unit), args: [("k", Array(Int))], body: If(Not(Eq(Get(Var("k"), Int(0)), Int(0))), Let(("t", Var({val: None})), Array(Int(1), Int(0)), LetRec({tyvars: [], name: ("flip_loop", Unit), args: [("i", Int)], body: If(LE(Var("i"), Prim(Get(Var("k"), Int(0)), Int(2), Div, kind=None)), Let(("_", Var({val: None})), Put(Var("t"), Int(0), Get(Var("perm"), Var("i"))), Let(("_", Var({val: None})), Put(Var("perm"), Var("i"), Get(Var("perm"), Prim(Get(Var("k"), Int(0)), Var("i"), Sub, kind=None))), Let(("_", Var({val: None})), Put(Var("perm"), Prim(Get(Var("k"), Int(0)), Var("i"), Sub, kind=None), Get(Var("t"), Int(0))), App(Var("flip_loop"), [Prim(Var("i"), Int(1), Add, kind=None)])))), Unit)}, Let(("_", Var({val: None})), App(Var("flip_loop"), [Int(0)]), Let(("_", Var({val: None})), Put(Var("k"), Int(0), Get(Var("perm"), Int(0))), Let(("_", Var({val: None})), Put(Var("flips"), Int(0), Prim(Get(Var("flips"), Int(0)), Int(1), Add, kind=None)), App(Var("do_flip"), [Var("k")])))))), Unit)}, Let(("_", Var({val: None})), App(Var("do_flip"), [Var("k")]), Let(("_", Var({val: None})), If(LE(Get(Var("max_flips"), Int(0)), Get(Var("flips"), Int(0))), Put(Var("max_flips"), Int(0), Get(Var("flips"), Int(0))), Unit), Let(("_", Var({val: None})), Put(Var("check_sum"), Int(0), Prim(Get(Var("check_sum"), Int(0)), Prim(Get(Var("flips"), Int(0)), Prim(Int(1), Prim(Prim(Get(Var("nperm"), Int(0)), Prim(Prim(Get(Var("nperm"), Int(0)), Int(2), Div, kind=None), Int(2), Mul, kind=None), Sub, kind=None), Int(2), Mul, kind=None), Sub, kind=None), Mul, kind=None), Add, kind=None)), Let(("go", Var({val: None})), Array(Int(1), Bool(true)), Let(("t", Var({val: None})), Array(Int(1), Int(0)), LetRec({tyvars: [], name: ("go_loop", Unit), args: [], body: If(Get(Var("go"), Int(0)), Let(("_", Var({val: None})), If(Eq(Get(Var("r"), Int(0)), Var("n")), Let(("_", Var({val: None})), Put(Var("go"), Int(0), Bool(false)), Let(("_", Var({val: None})), Put(Var("r"), Int(0), Int(0)), Unit)), Let(("_", Var({val: None})), Put(Var("t"), Int(0), Get(Var("perm1"), Int(0))), LetRec({tyvars: [], name: ("move_perm1_forward", Unit), args: [("i", Int)], body: If(LE(Var("i"), Prim(Get(Var("r"), Int(0)), Int(1), Sub, kind=None)), Let(("_", Var({val: None})), Put(Var("perm1"), Var("i"), Get(Var("perm1"), Prim(Var("i"), Int(1), Add, kind=None))), Let(("_", Var({val: None})), App(Var("move_perm1_forward"), [Prim(Var("i"), Int(1), Add, kind=None)]), Unit)), Unit)}, Let(("_", Var({val: None})), App(Var("move_perm1_forward"), [Int(0)]), Let(("_", Var({val: None})), Put(Var("perm1"), Get(Var("r"), Int(0)), Get(Var("t"), Int(0))), Let(("_", Var({val: None})), Put(Var("count"), Get(Var("r"), Int(0)), Prim(Get(Var("count"), Get(Var("r"), Int(0))), Int(1), Sub, kind=None)), Let(("_", Var({val: None})), If(LE(Int(1), Get(Var("count"), Get(Var("r"), Int(0)))), Put(Var("go"), Int(0), Bool(false)), Put(Var("r"), Int(0), Prim(Get(Var("r"), Int(0)), Int(1), Add, kind=None))), Unit))))))), App(Var("go_loop"), [])), Unit)}, Let(("_", Var({val: None})), App(Var("go_loop"), []), Let(("_", Var({val: None})), Put(Var("nperm"), Int(0), Prim(Get(Var("nperm"), Int(0)), Int(1), Add, kind=None)), App(Var("compute"), [Var("r")]))))))))))) against Unit
// [Typer] infer: Array(Int(1), Get(Var("perm"), Int(0)))
// [Typer] infer: Get(Var("perm"), Int(0))
// [Typer] infer: Var("perm")
// [Typer] inst: TypeScheme(([], Var({val: Some(Array(Int))})))
// [Typer] inst result: Array(Int)
// [Typer] check: Int(0) against Int
// [Typer] check: Int(1) against Int
// [Typer] unify: Var({val: None}) and Array(Int)
// [Typer] union: Var({val: None}) and Array(Int)
// [Typer] check: LetRec({tyvars: [], name: ("do_flip", Unit), args: [("k", Array(Int))], body: If(Not(Eq(Get(Var("k"), Int(0)), Int(0))), Let(("t", Var({val: None})), Array(Int(1), Int(0)), LetRec({tyvars: [], name: ("flip_loop", Unit), args: [("i", Int)], body: If(LE(Var("i"), Prim(Get(Var("k"), Int(0)), Int(2), Div, kind=None)), Let(("_", Var({val: None})), Put(Var("t"), Int(0), Get(Var("perm"), Var("i"))), Let(("_", Var({val: None})), Put(Var("perm"), Var("i"), Get(Var("perm"), Prim(Get(Var("k"), Int(0)), Var("i"), Sub, kind=None))), Let(("_", Var({val: None})), Put(Var("perm"), Prim(Get(Var("k"), Int(0)), Var("i"), Sub, kind=None), Get(Var("t"), Int(0))), App(Var("flip_loop"), [Prim(Var("i"), Int(1), Add, kind=None)])))), Unit)}, Let(("_", Var({val: None})), App(Var("flip_loop"), [Int(0)]), Let(("_", Var({val: None})), Put(Var("k"), Int(0), Get(Var("perm"), Int(0))), Let(("_", Var({val: None})), Put(Var("flips"), Int(0), Prim(Get(Var("flips"), Int(0)), Int(1), Add, kind=None)), App(Var("do_flip"), [Var("k")])))))), Unit)}, Let(("_", Var({val: None})), App(Var("do_flip"), [Var("k")]), Let(("_", Var({val: None})), If(LE(Get(Var("max_flips"), Int(0)), Get(Var("flips"), Int(0))), Put(Var("max_flips"), Int(0), Get(Var("flips"), Int(0))), Unit), Let(("_", Var({val: None})), Put(Var("check_sum"), Int(0), Prim(Get(Var("check_sum"), Int(0)), Prim(Get(Var("flips"), Int(0)), Prim(Int(1), Prim(Prim(Get(Var("nperm"), Int(0)), Prim(Prim(Get(Var("nperm"), Int(0)), Int(2), Div, kind=None), Int(2), Mul, kind=None), Sub, kind=None), Int(2), Mul, kind=None), Sub, kind=None), Mul, kind=None), Add, kind=None)), Let(("go", Var({val: None})), Array(Int(1), Bool(true)), Let(("t", Var({val: None})), Array(Int(1), Int(0)), LetRec({tyvars: [], name: ("go_loop", Unit), args: [], body: If(Get(Var("go"), Int(0)), Let(("_", Var({val: None})), If(Eq(Get(Var("r"), Int(0)), Var("n")), Let(("_", Var({val: None})), Put(Var("go"), Int(0), Bool(false)), Let(("_", Var({val: None})), Put(Var("r"), Int(0), Int(0)), Unit)), Let(("_", Var({val: None})), Put(Var("t"), Int(0), Get(Var("perm1"), Int(0))), LetRec({tyvars: [], name: ("move_perm1_forward", Unit), args: [("i", Int)], body: If(LE(Var("i"), Prim(Get(Var("r"), Int(0)), Int(1), Sub, kind=None)), Let(("_", Var({val: None})), Put(Var("perm1"), Var("i"), Get(Var("perm1"), Prim(Var("i"), Int(1), Add, kind=None))), Let(("_", Var({val: None})), App(Var("move_perm1_forward"), [Prim(Var("i"), Int(1), Add, kind=None)]), Unit)), Unit)}, Let(("_", Var({val: None})), App(Var("move_perm1_forward"), [Int(0)]), Let(("_", Var({val: None})), Put(Var("perm1"), Get(Var("r"), Int(0)), Get(Var("t"), Int(0))), Let(("_", Var({val: None})), Put(Var("count"), Get(Var("r"), Int(0)), Prim(Get(Var("count"), Get(Var("r"), Int(0))), Int(1), Sub, kind=None)), Let(("_", Var({val: None})), If(LE(Int(1), Get(Var("count"), Get(Var("r"), Int(0)))), Put(Var("go"), Int(0), Bool(false)), Put(Var("r"), Int(0), Prim(Get(Var("r"), Int(0)), Int(1), Add, kind=None))), Unit))))))), App(Var("go_loop"), [])), Unit)}, Let(("_", Var({val: None})), App(Var("go_loop"), []), Let(("_", Var({val: None})), Put(Var("nperm"), Int(0), Prim(Get(Var("nperm"), Int(0)), Int(1), Add, kind=None)), App(Var("compute"), [Var("r")])))))))))) against Unit
// [Typer] typevars: []
// [Typer] check: If(Not(Eq(Get(Var("k"), Int(0)), Int(0))), Let(("t", Var({val: None})), Array(Int(1), Int(0)), LetRec({tyvars: [], name: ("flip_loop", Unit), args: [("i", Int)], body: If(LE(Var("i"), Prim(Get(Var("k"), Int(0)), Int(2), Div, kind=None)), Let(("_", Var({val: None})), Put(Var("t"), Int(0), Get(Var("perm"), Var("i"))), Let(("_", Var({val: None})), Put(Var("perm"), Var("i"), Get(Var("perm"), Prim(Get(Var("k"), Int(0)), Var("i"), Sub, kind=None))), Let(("_", Var({val: None})), Put(Var("perm"), Prim(Get(Var("k"), Int(0)), Var("i"), Sub, kind=None), Get(Var("t"), Int(0))), App(Var("flip_loop"), [Prim(Var("i"), Int(1), Add, kind=None)])))), Unit)}, Let(("_", Var({val: None})), App(Var("flip_loop"), [Int(0)]), Let(("_", Var({val: None})), Put(Var("k"), Int(0), Get(Var("perm"), Int(0))), Let(("_", Var({val: None})), Put(Var("flips"), Int(0), Prim(Get(Var("flips"), Int(0)), Int(1), Add, kind=None)), App(Var("do_flip"), [Var("k")])))))), Unit) against Unit
// [Typer] check: Not(Eq(Get(Var("k"), Int(0)), Int(0))) against Bool
// [Typer] check: Eq(Get(Var("k"), Int(0)), Int(0)) against Bool
// [Typer] infer: Get(Var("k"), Int(0))
// [Typer] infer: Var("k")
// [Typer] inst: TypeScheme(([], Array(Int)))
// [Typer] inst result: Array(Int)
// [Typer] check: Int(0) against Int
// [Typer] infer: Int(0)
// [Typer] unify: Int and Int
// [Typer] check: Let(("t", Var({val: None})), Array(Int(1), Int(0)), LetRec({tyvars: [], name: ("flip_loop", Unit), args: [("i", Int)], body: If(LE(Var("i"), Prim(Get(Var("k"), Int(0)), Int(2), Div, kind=None)), Let(("_", Var({val: None})), Put(Var("t"), Int(0), Get(Var("perm"), Var("i"))), Let(("_", Var({val: None})), Put(Var("perm"), Var("i"), Get(Var("perm"), Prim(Get(Var("k"), Int(0)), Var("i"), Sub, kind=None))), Let(("_", Var({val: None})), Put(Var("perm"), Prim(Get(Var("k"), Int(0)), Var("i"), Sub, kind=None), Get(Var("t"), Int(0))), App(Var("flip_loop"), [Prim(Var("i"), Int(1), Add, kind=None)])))), Unit)}, Let(("_", Var({val: None})), App(Var("flip_loop"), [Int(0)]), Let(("_", Var({val: None})), Put(Var("k"), Int(0), Get(Var("perm"), Int(0))), Let(("_", Var({val: None})), Put(Var("flips"), Int(0), Prim(Get(Var("flips"), Int(0)), Int(1), Add, kind=None)), App(Var("do_flip"), [Var("k")])))))) against Unit
// [Typer] infer: Array(Int(1), Int(0))
// [Typer] infer: Int(0)
// [Typer] check: Int(1) against Int
// [Typer] unify: Var({val: None}) and Array(Int)
// [Typer] union: Var({val: None}) and Array(Int)
// [Typer] check: LetRec({tyvars: [], name: ("flip_loop", Unit), args: [("i", Int)], body: If(LE(Var("i"), Prim(Get(Var("k"), Int(0)), Int(2), Div, kind=None)), Let(("_", Var({val: None})), Put(Var("t"), Int(0), Get(Var("perm"), Var("i"))), Let(("_", Var({val: None})), Put(Var("perm"), Var("i"), Get(Var("perm"), Prim(Get(Var("k"), Int(0)), Var("i"), Sub, kind=None))), Let(("_", Var({val: None})), Put(Var("perm"), Prim(Get(Var("k"), Int(0)), Var("i"), Sub, kind=None), Get(Var("t"), Int(0))), App(Var("flip_loop"), [Prim(Var("i"), Int(1), Add, kind=None)])))), Unit)}, Let(("_", Var({val: None})), App(Var("flip_loop"), [Int(0)]), Let(("_", Var({val: None})), Put(Var("k"), Int(0), Get(Var("perm"), Int(0))), Let(("_", Var({val: None})), Put(Var("flips"), Int(0), Prim(Get(Var("flips"), Int(0)), Int(1), Add, kind=None)), App(Var("do_flip"), [Var("k")]))))) against Unit
// [Typer] typevars: []
// [Typer] check: If(LE(Var("i"), Prim(Get(Var("k"), Int(0)), Int(2), Div, kind=None)), Let(("_", Var({val: None})), Put(Var("t"), Int(0), Get(Var("perm"), Var("i"))), Let(("_", Var({val: None})), Put(Var("perm"), Var("i"), Get(Var("perm"), Prim(Get(Var("k"), Int(0)), Var("i"), Sub, kind=None))), Let(("_", Var({val: None})), Put(Var("perm"), Prim(Get(Var("k"), Int(0)), Var("i"), Sub, kind=None), Get(Var("t"), Int(0))), App(Var("flip_loop"), [Prim(Var("i"), Int(1), Add, kind=None)])))), Unit) against Unit
// [Typer] check: LE(Var("i"), Prim(Get(Var("k"), Int(0)), Int(2), Div, kind=None)) against Bool
// [Typer] infer: Var("i")
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] infer: Prim(Get(Var("k"), Int(0)), Int(2), Div, kind=None)
// [Typer] infer: Get(Var("k"), Int(0))
// [Typer] infer: Var("k")
// [Typer] inst: TypeScheme(([], Array(Int)))
// [Typer] inst result: Array(Int)
// [Typer] check: Int(0) against Int
// [Typer] infer: Int(2)
// [Typer] unify: Int and Int
// [Typer] unify: Int and Int
// [Typer] check: Let(("_", Var({val: None})), Put(Var("t"), Int(0), Get(Var("perm"), Var("i"))), Let(("_", Var({val: None})), Put(Var("perm"), Var("i"), Get(Var("perm"), Prim(Get(Var("k"), Int(0)), Var("i"), Sub, kind=None))), Let(("_", Var({val: None})), Put(Var("perm"), Prim(Get(Var("k"), Int(0)), Var("i"), Sub, kind=None), Get(Var("t"), Int(0))), App(Var("flip_loop"), [Prim(Var("i"), Int(1), Add, kind=None)])))) against Unit
// [Typer] infer: Put(Var("t"), Int(0), Get(Var("perm"), Var("i")))
// [Typer] infer: Get(Var("perm"), Var("i"))
// [Typer] infer: Var("perm")
// [Typer] inst: TypeScheme(([], Var({val: Some(Array(Int))})))
// [Typer] inst result: Array(Int)
// [Typer] check: Var("i") against Int
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] check: Var("t") against Array(Int)
// [Typer] inst: TypeScheme(([], Var({val: Some(Array(Int))})))
// [Typer] inst result: Array(Int)
// [Typer] unify: Array(Int) and Array(Int)
// [Typer] unify: Int and Int
// [Typer] check: Int(0) against Int
// [Typer] unify: Var({val: None}) and Unit
// [Typer] union: Var({val: None}) and Unit
// [Typer] check: Let(("_", Var({val: None})), Put(Var("perm"), Var("i"), Get(Var("perm"), Prim(Get(Var("k"), Int(0)), Var("i"), Sub, kind=None))), Let(("_", Var({val: None})), Put(Var("perm"), Prim(Get(Var("k"), Int(0)), Var("i"), Sub, kind=None), Get(Var("t"), Int(0))), App(Var("flip_loop"), [Prim(Var("i"), Int(1), Add, kind=None)]))) against Unit
// [Typer] infer: Put(Var("perm"), Var("i"), Get(Var("perm"), Prim(Get(Var("k"), Int(0)), Var("i"), Sub, kind=None)))
// [Typer] infer: Get(Var("perm"), Prim(Get(Var("k"), Int(0)), Var("i"), Sub, kind=None))
// [Typer] infer: Var("perm")
// [Typer] inst: TypeScheme(([], Var({val: Some(Array(Int))})))
// [Typer] inst result: Array(Int)
// [Typer] check: Prim(Get(Var("k"), Int(0)), Var("i"), Sub, kind=None) against Int
// [Typer] check: Get(Var("k"), Int(0)) against Int
// [Typer] check: Var("k") against Array(Int)
// [Typer] inst: TypeScheme(([], Array(Int)))
// [Typer] inst result: Array(Int)
// [Typer] unify: Array(Int) and Array(Int)
// [Typer] unify: Int and Int
// [Typer] check: Int(0) against Int
// [Typer] check: Var("i") against Int
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] check: Var("perm") against Array(Int)
// [Typer] inst: TypeScheme(([], Var({val: Some(Array(Int))})))
// [Typer] inst result: Array(Int)
// [Typer] unify: Array(Int) and Array(Int)
// [Typer] unify: Int and Int
// [Typer] check: Var("i") against Int
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] unify: Var({val: None}) and Unit
// [Typer] union: Var({val: None}) and Unit
// [Typer] check: Let(("_", Var({val: None})), Put(Var("perm"), Prim(Get(Var("k"), Int(0)), Var("i"), Sub, kind=None), Get(Var("t"), Int(0))), App(Var("flip_loop"), [Prim(Var("i"), Int(1), Add, kind=None)])) against Unit
// [Typer] infer: Put(Var("perm"), Prim(Get(Var("k"), Int(0)), Var("i"), Sub, kind=None), Get(Var("t"), Int(0)))
// [Typer] infer: Get(Var("t"), Int(0))
// [Typer] infer: Var("t")
// [Typer] inst: TypeScheme(([], Var({val: Some(Array(Int))})))
// [Typer] inst result: Array(Int)
// [Typer] check: Int(0) against Int
// [Typer] check: Var("perm") against Array(Int)
// [Typer] inst: TypeScheme(([], Var({val: Some(Array(Int))})))
// [Typer] inst result: Array(Int)
// [Typer] unify: Array(Int) and Array(Int)
// [Typer] unify: Int and Int
// [Typer] check: Prim(Get(Var("k"), Int(0)), Var("i"), Sub, kind=None) against Int
// [Typer] check: Get(Var("k"), Int(0)) against Int
// [Typer] check: Var("k") against Array(Int)
// [Typer] inst: TypeScheme(([], Array(Int)))
// [Typer] inst result: Array(Int)
// [Typer] unify: Array(Int) and Array(Int)
// [Typer] unify: Int and Int
// [Typer] check: Int(0) against Int
// [Typer] check: Var("i") against Int
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] unify: Var({val: None}) and Unit
// [Typer] union: Var({val: None}) and Unit
// [Typer] check: App(Var("flip_loop"), [Prim(Var("i"), Int(1), Add, kind=None)]) against Unit
// [Typer] infer: Prim(Var("i"), Int(1), Add, kind=None)
// [Typer] infer: Var("i")
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] infer: Int(1)
// [Typer] unify: Int and Int
// [Typer] check: Var("flip_loop") against Fun([Int], Unit)
// [Typer] inst: TypeScheme(([], Fun([Int], Unit)))
// [Typer] inst result: Fun([Int], Unit)
// [Typer] unify: Fun([Int], Unit) and Fun([Int], Unit)
// [Typer] unify: Int and Int
// [Typer] unify: Unit and Unit
// [Typer] check: Unit against Unit
// [Typer] check: Let(("_", Var({val: None})), App(Var("flip_loop"), [Int(0)]), Let(("_", Var({val: None})), Put(Var("k"), Int(0), Get(Var("perm"), Int(0))), Let(("_", Var({val: None})), Put(Var("flips"), Int(0), Prim(Get(Var("flips"), Int(0)), Int(1), Add, kind=None)), App(Var("do_flip"), [Var("k")])))) against Unit
// [Typer] infer: App(Var("flip_loop"), [Int(0)])
// [Typer] infer: Var("flip_loop")
// [Typer] inst: TypeScheme(([], Fun([Int], Unit)))
// [Typer] inst result: Fun([Int], Unit)
// [Typer] check: Int(0) against Int
// [Typer] unify: Var({val: None}) and Unit
// [Typer] union: Var({val: None}) and Unit
// [Typer] check: Let(("_", Var({val: None})), Put(Var("k"), Int(0), Get(Var("perm"), Int(0))), Let(("_", Var({val: None})), Put(Var("flips"), Int(0), Prim(Get(Var("flips"), Int(0)), Int(1), Add, kind=None)), App(Var("do_flip"), [Var("k")]))) against Unit
// [Typer] infer: Put(Var("k"), Int(0), Get(Var("perm"), Int(0)))
// [Typer] infer: Get(Var("perm"), Int(0))
// [Typer] infer: Var("perm")
// [Typer] inst: TypeScheme(([], Var({val: Some(Array(Int))})))
// [Typer] inst result: Array(Int)
// [Typer] check: Int(0) against Int
// [Typer] check: Var("k") against Array(Int)
// [Typer] inst: TypeScheme(([], Array(Int)))
// [Typer] inst result: Array(Int)
// [Typer] unify: Array(Int) and Array(Int)
// [Typer] unify: Int and Int
// [Typer] check: Int(0) against Int
// [Typer] unify: Var({val: None}) and Unit
// [Typer] union: Var({val: None}) and Unit
// [Typer] check: Let(("_", Var({val: None})), Put(Var("flips"), Int(0), Prim(Get(Var("flips"), Int(0)), Int(1), Add, kind=None)), App(Var("do_flip"), [Var("k")])) against Unit
// [Typer] infer: Put(Var("flips"), Int(0), Prim(Get(Var("flips"), Int(0)), Int(1), Add, kind=None))
// [Typer] infer: Prim(Get(Var("flips"), Int(0)), Int(1), Add, kind=None)
// [Typer] infer: Get(Var("flips"), Int(0))
// [Typer] infer: Var("flips")
// [Typer] inst: TypeScheme(([], Var({val: Some(Array(Int))})))
// [Typer] inst result: Array(Int)
// [Typer] check: Int(0) against Int
// [Typer] infer: Int(1)
// [Typer] unify: Int and Int
// [Typer] check: Var("flips") against Array(Int)
// [Typer] inst: TypeScheme(([], Var({val: Some(Array(Int))})))
// [Typer] inst result: Array(Int)
// [Typer] unify: Array(Int) and Array(Int)
// [Typer] unify: Int and Int
// [Typer] check: Int(0) against Int
// [Typer] unify: Var({val: None}) and Unit
// [Typer] union: Var({val: None}) and Unit
// [Typer] check: App(Var("do_flip"), [Var("k")]) against Unit
// [Typer] infer: Var("k")
// [Typer] inst: TypeScheme(([], Array(Int)))
// [Typer] inst result: Array(Int)
// [Typer] check: Var("do_flip") against Fun([Array(Int)], Unit)
// [Typer] inst: TypeScheme(([], Fun([Array(Int)], Unit)))
// [Typer] inst result: Fun([Array(Int)], Unit)
// [Typer] unify: Fun([Array(Int)], Unit) and Fun([Array(Int)], Unit)
// [Typer] unify: Array(Int) and Array(Int)
// [Typer] unify: Int and Int
// [Typer] unify: Unit and Unit
// [Typer] check: Unit against Unit
// [Typer] check: Let(("_", Var({val: None})), App(Var("do_flip"), [Var("k")]), Let(("_", Var({val: None})), If(LE(Get(Var("max_flips"), Int(0)), Get(Var("flips"), Int(0))), Put(Var("max_flips"), Int(0), Get(Var("flips"), Int(0))), Unit), Let(("_", Var({val: None})), Put(Var("check_sum"), Int(0), Prim(Get(Var("check_sum"), Int(0)), Prim(Get(Var("flips"), Int(0)), Prim(Int(1), Prim(Prim(Get(Var("nperm"), Int(0)), Prim(Prim(Get(Var("nperm"), Int(0)), Int(2), Div, kind=None), Int(2), Mul, kind=None), Sub, kind=None), Int(2), Mul, kind=None), Sub, kind=None), Mul, kind=None), Add, kind=None)), Let(("go", Var({val: None})), Array(Int(1), Bool(true)), Let(("t", Var({val: None})), Array(Int(1), Int(0)), LetRec({tyvars: [], name: ("go_loop", Unit), args: [], body: If(Get(Var("go"), Int(0)), Let(("_", Var({val: None})), If(Eq(Get(Var("r"), Int(0)), Var("n")), Let(("_", Var({val: None})), Put(Var("go"), Int(0), Bool(false)), Let(("_", Var({val: None})), Put(Var("r"), Int(0), Int(0)), Unit)), Let(("_", Var({val: None})), Put(Var("t"), Int(0), Get(Var("perm1"), Int(0))), LetRec({tyvars: [], name: ("move_perm1_forward", Unit), args: [("i", Int)], body: If(LE(Var("i"), Prim(Get(Var("r"), Int(0)), Int(1), Sub, kind=None)), Let(("_", Var({val: None})), Put(Var("perm1"), Var("i"), Get(Var("perm1"), Prim(Var("i"), Int(1), Add, kind=None))), Let(("_", Var({val: None})), App(Var("move_perm1_forward"), [Prim(Var("i"), Int(1), Add, kind=None)]), Unit)), Unit)}, Let(("_", Var({val: None})), App(Var("move_perm1_forward"), [Int(0)]), Let(("_", Var({val: None})), Put(Var("perm1"), Get(Var("r"), Int(0)), Get(Var("t"), Int(0))), Let(("_", Var({val: None})), Put(Var("count"), Get(Var("r"), Int(0)), Prim(Get(Var("count"), Get(Var("r"), Int(0))), Int(1), Sub, kind=None)), Let(("_", Var({val: None})), If(LE(Int(1), Get(Var("count"), Get(Var("r"), Int(0)))), Put(Var("go"), Int(0), Bool(false)), Put(Var("r"), Int(0), Prim(Get(Var("r"), Int(0)), Int(1), Add, kind=None))), Unit))))))), App(Var("go_loop"), [])), Unit)}, Let(("_", Var({val: None})), App(Var("go_loop"), []), Let(("_", Var({val: None})), Put(Var("nperm"), Int(0), Prim(Get(Var("nperm"), Int(0)), Int(1), Add, kind=None)), App(Var("compute"), [Var("r")]))))))))) against Unit
// [Typer] infer: App(Var("do_flip"), [Var("k")])
// [Typer] infer: Var("do_flip")
// [Typer] inst: TypeScheme(([], Fun([Array(Int)], Unit)))
// [Typer] inst result: Fun([Array(Int)], Unit)
// [Typer] check: Var("k") against Array(Int)
// [Typer] inst: TypeScheme(([], Var({val: Some(Array(Int))})))
// [Typer] inst result: Array(Int)
// [Typer] unify: Array(Int) and Array(Int)
// [Typer] unify: Int and Int
// [Typer] unify: Var({val: None}) and Unit
// [Typer] union: Var({val: None}) and Unit
// [Typer] check: Let(("_", Var({val: None})), If(LE(Get(Var("max_flips"), Int(0)), Get(Var("flips"), Int(0))), Put(Var("max_flips"), Int(0), Get(Var("flips"), Int(0))), Unit), Let(("_", Var({val: None})), Put(Var("check_sum"), Int(0), Prim(Get(Var("check_sum"), Int(0)), Prim(Get(Var("flips"), Int(0)), Prim(Int(1), Prim(Prim(Get(Var("nperm"), Int(0)), Prim(Prim(Get(Var("nperm"), Int(0)), Int(2), Div, kind=None), Int(2), Mul, kind=None), Sub, kind=None), Int(2), Mul, kind=None), Sub, kind=None), Mul, kind=None), Add, kind=None)), Let(("go", Var({val: None})), Array(Int(1), Bool(true)), Let(("t", Var({val: None})), Array(Int(1), Int(0)), LetRec({tyvars: [], name: ("go_loop", Unit), args: [], body: If(Get(Var("go"), Int(0)), Let(("_", Var({val: None})), If(Eq(Get(Var("r"), Int(0)), Var("n")), Let(("_", Var({val: None})), Put(Var("go"), Int(0), Bool(false)), Let(("_", Var({val: None})), Put(Var("r"), Int(0), Int(0)), Unit)), Let(("_", Var({val: None})), Put(Var("t"), Int(0), Get(Var("perm1"), Int(0))), LetRec({tyvars: [], name: ("move_perm1_forward", Unit), args: [("i", Int)], body: If(LE(Var("i"), Prim(Get(Var("r"), Int(0)), Int(1), Sub, kind=None)), Let(("_", Var({val: None})), Put(Var("perm1"), Var("i"), Get(Var("perm1"), Prim(Var("i"), Int(1), Add, kind=None))), Let(("_", Var({val: None})), App(Var("move_perm1_forward"), [Prim(Var("i"), Int(1), Add, kind=None)]), Unit)), Unit)}, Let(("_", Var({val: None})), App(Var("move_perm1_forward"), [Int(0)]), Let(("_", Var({val: None})), Put(Var("perm1"), Get(Var("r"), Int(0)), Get(Var("t"), Int(0))), Let(("_", Var({val: None})), Put(Var("count"), Get(Var("r"), Int(0)), Prim(Get(Var("count"), Get(Var("r"), Int(0))), Int(1), Sub, kind=None)), Let(("_", Var({val: None})), If(LE(Int(1), Get(Var("count"), Get(Var("r"), Int(0)))), Put(Var("go"), Int(0), Bool(false)), Put(Var("r"), Int(0), Prim(Get(Var("r"), Int(0)), Int(1), Add, kind=None))), Unit))))))), App(Var("go_loop"), [])), Unit)}, Let(("_", Var({val: None})), App(Var("go_loop"), []), Let(("_", Var({val: None})), Put(Var("nperm"), Int(0), Prim(Get(Var("nperm"), Int(0)), Int(1), Add, kind=None)), App(Var("compute"), [Var("r")])))))))) against Unit
// [Typer] infer: If(LE(Get(Var("max_flips"), Int(0)), Get(Var("flips"), Int(0))), Put(Var("max_flips"), Int(0), Get(Var("flips"), Int(0))), Unit)
// [Typer] check: LE(Get(Var("max_flips"), Int(0)), Get(Var("flips"), Int(0))) against Bool
// [Typer] infer: Get(Var("max_flips"), Int(0))
// [Typer] infer: Var("max_flips")
// [Typer] inst: TypeScheme(([], Var({val: Some(Array(Int))})))
// [Typer] inst result: Array(Int)
// [Typer] check: Int(0) against Int
// [Typer] infer: Get(Var("flips"), Int(0))
// [Typer] infer: Var("flips")
// [Typer] inst: TypeScheme(([], Var({val: Some(Array(Int))})))
// [Typer] inst result: Array(Int)
// [Typer] check: Int(0) against Int
// [Typer] unify: Int and Int
// [Typer] infer: Put(Var("max_flips"), Int(0), Get(Var("flips"), Int(0)))
// [Typer] infer: Get(Var("flips"), Int(0))
// [Typer] infer: Var("flips")
// [Typer] inst: TypeScheme(([], Var({val: Some(Array(Int))})))
// [Typer] inst result: Array(Int)
// [Typer] check: Int(0) against Int
// [Typer] check: Var("max_flips") against Array(Int)
// [Typer] inst: TypeScheme(([], Var({val: Some(Array(Int))})))
// [Typer] inst result: Array(Int)
// [Typer] unify: Array(Int) and Array(Int)
// [Typer] unify: Int and Int
// [Typer] check: Int(0) against Int
// [Typer] infer: Unit
// [Typer] unify: Unit and Unit
// [Typer] unify: Var({val: None}) and Unit
// [Typer] union: Var({val: None}) and Unit
// [Typer] check: Let(("_", Var({val: None})), Put(Var("check_sum"), Int(0), Prim(Get(Var("check_sum"), Int(0)), Prim(Get(Var("flips"), Int(0)), Prim(Int(1), Prim(Prim(Get(Var("nperm"), Int(0)), Prim(Prim(Get(Var("nperm"), Int(0)), Int(2), Div, kind=None), Int(2), Mul, kind=None), Sub, kind=None), Int(2), Mul, kind=None), Sub, kind=None), Mul, kind=None), Add, kind=None)), Let(("go", Var({val: None})), Array(Int(1), Bool(true)), Let(("t", Var({val: None})), Array(Int(1), Int(0)), LetRec({tyvars: [], name: ("go_loop", Unit), args: [], body: If(Get(Var("go"), Int(0)), Let(("_", Var({val: None})), If(Eq(Get(Var("r"), Int(0)), Var("n")), Let(("_", Var({val: None})), Put(Var("go"), Int(0), Bool(false)), Let(("_", Var({val: None})), Put(Var("r"), Int(0), Int(0)), Unit)), Let(("_", Var({val: None})), Put(Var("t"), Int(0), Get(Var("perm1"), Int(0))), LetRec({tyvars: [], name: ("move_perm1_forward", Unit), args: [("i", Int)], body: If(LE(Var("i"), Prim(Get(Var("r"), Int(0)), Int(1), Sub, kind=None)), Let(("_", Var({val: None})), Put(Var("perm1"), Var("i"), Get(Var("perm1"), Prim(Var("i"), Int(1), Add, kind=None))), Let(("_", Var({val: None})), App(Var("move_perm1_forward"), [Prim(Var("i"), Int(1), Add, kind=None)]), Unit)), Unit)}, Let(("_", Var({val: None})), App(Var("move_perm1_forward"), [Int(0)]), Let(("_", Var({val: None})), Put(Var("perm1"), Get(Var("r"), Int(0)), Get(Var("t"), Int(0))), Let(("_", Var({val: None})), Put(Var("count"), Get(Var("r"), Int(0)), Prim(Get(Var("count"), Get(Var("r"), Int(0))), Int(1), Sub, kind=None)), Let(("_", Var({val: None})), If(LE(Int(1), Get(Var("count"), Get(Var("r"), Int(0)))), Put(Var("go"), Int(0), Bool(false)), Put(Var("r"), Int(0), Prim(Get(Var("r"), Int(0)), Int(1), Add, kind=None))), Unit))))))), App(Var("go_loop"), [])), Unit)}, Let(("_", Var({val: None})), App(Var("go_loop"), []), Let(("_", Var({val: None})), Put(Var("nperm"), Int(0), Prim(Get(Var("nperm"), Int(0)), Int(1), Add, kind=None)), App(Var("compute"), [Var("r")]))))))) against Unit
// [Typer] infer: Put(Var("check_sum"), Int(0), Prim(Get(Var("check_sum"), Int(0)), Prim(Get(Var("flips"), Int(0)), Prim(Int(1), Prim(Prim(Get(Var("nperm"), Int(0)), Prim(Prim(Get(Var("nperm"), Int(0)), Int(2), Div, kind=None), Int(2), Mul, kind=None), Sub, kind=None), Int(2), Mul, kind=None), Sub, kind=None), Mul, kind=None), Add, kind=None))
// [Typer] infer: Prim(Get(Var("check_sum"), Int(0)), Prim(Get(Var("flips"), Int(0)), Prim(Int(1), Prim(Prim(Get(Var("nperm"), Int(0)), Prim(Prim(Get(Var("nperm"), Int(0)), Int(2), Div, kind=None), Int(2), Mul, kind=None), Sub, kind=None), Int(2), Mul, kind=None), Sub, kind=None), Mul, kind=None), Add, kind=None)
// [Typer] infer: Get(Var("check_sum"), Int(0))
// [Typer] infer: Var("check_sum")
// [Typer] inst: TypeScheme(([], Var({val: Some(Array(Int))})))
// [Typer] inst result: Array(Int)
// [Typer] check: Int(0) against Int
// [Typer] infer: Prim(Get(Var("flips"), Int(0)), Prim(Int(1), Prim(Prim(Get(Var("nperm"), Int(0)), Prim(Prim(Get(Var("nperm"), Int(0)), Int(2), Div, kind=None), Int(2), Mul, kind=None), Sub, kind=None), Int(2), Mul, kind=None), Sub, kind=None), Mul, kind=None)
// [Typer] infer: Get(Var("flips"), Int(0))
// [Typer] infer: Var("flips")
// [Typer] inst: TypeScheme(([], Var({val: Some(Array(Int))})))
// [Typer] inst result: Array(Int)
// [Typer] check: Int(0) against Int
// [Typer] infer: Prim(Int(1), Prim(Prim(Get(Var("nperm"), Int(0)), Prim(Prim(Get(Var("nperm"), Int(0)), Int(2), Div, kind=None), Int(2), Mul, kind=None), Sub, kind=None), Int(2), Mul, kind=None), Sub, kind=None)
// [Typer] infer: Int(1)
// [Typer] infer: Prim(Prim(Get(Var("nperm"), Int(0)), Prim(Prim(Get(Var("nperm"), Int(0)), Int(2), Div, kind=None), Int(2), Mul, kind=None), Sub, kind=None), Int(2), Mul, kind=None)
// [Typer] infer: Prim(Get(Var("nperm"), Int(0)), Prim(Prim(Get(Var("nperm"), Int(0)), Int(2), Div, kind=None), Int(2), Mul, kind=None), Sub, kind=None)
// [Typer] infer: Get(Var("nperm"), Int(0))
// [Typer] infer: Var("nperm")
// [Typer] inst: TypeScheme(([], Var({val: Some(Array(Int))})))
// [Typer] inst result: Array(Int)
// [Typer] check: Int(0) against Int
// [Typer] infer: Prim(Prim(Get(Var("nperm"), Int(0)), Int(2), Div, kind=None), Int(2), Mul, kind=None)
// [Typer] infer: Prim(Get(Var("nperm"), Int(0)), Int(2), Div, kind=None)
// [Typer] infer: Get(Var("nperm"), Int(0))
// [Typer] infer: Var("nperm")
// [Typer] inst: TypeScheme(([], Var({val: Some(Array(Int))})))
// [Typer] inst result: Array(Int)
// [Typer] check: Int(0) against Int
// [Typer] infer: Int(2)
// [Typer] unify: Int and Int
// [Typer] infer: Int(2)
// [Typer] unify: Int and Int
// [Typer] unify: Int and Int
// [Typer] infer: Int(2)
// [Typer] unify: Int and Int
// [Typer] unify: Int and Int
// [Typer] unify: Int and Int
// [Typer] unify: Int and Int
// [Typer] check: Var("check_sum") against Array(Int)
// [Typer] inst: TypeScheme(([], Var({val: Some(Array(Int))})))
// [Typer] inst result: Array(Int)
// [Typer] unify: Array(Int) and Array(Int)
// [Typer] unify: Int and Int
// [Typer] check: Int(0) against Int
// [Typer] unify: Var({val: None}) and Unit
// [Typer] union: Var({val: None}) and Unit
// [Typer] check: Let(("go", Var({val: None})), Array(Int(1), Bool(true)), Let(("t", Var({val: None})), Array(Int(1), Int(0)), LetRec({tyvars: [], name: ("go_loop", Unit), args: [], body: If(Get(Var("go"), Int(0)), Let(("_", Var({val: None})), If(Eq(Get(Var("r"), Int(0)), Var("n")), Let(("_", Var({val: None})), Put(Var("go"), Int(0), Bool(false)), Let(("_", Var({val: None})), Put(Var("r"), Int(0), Int(0)), Unit)), Let(("_", Var({val: None})), Put(Var("t"), Int(0), Get(Var("perm1"), Int(0))), LetRec({tyvars: [], name: ("move_perm1_forward", Unit), args: [("i", Int)], body: If(LE(Var("i"), Prim(Get(Var("r"), Int(0)), Int(1), Sub, kind=None)), Let(("_", Var({val: None})), Put(Var("perm1"), Var("i"), Get(Var("perm1"), Prim(Var("i"), Int(1), Add, kind=None))), Let(("_", Var({val: None})), App(Var("move_perm1_forward"), [Prim(Var("i"), Int(1), Add, kind=None)]), Unit)), Unit)}, Let(("_", Var({val: None})), App(Var("move_perm1_forward"), [Int(0)]), Let(("_", Var({val: None})), Put(Var("perm1"), Get(Var("r"), Int(0)), Get(Var("t"), Int(0))), Let(("_", Var({val: None})), Put(Var("count"), Get(Var("r"), Int(0)), Prim(Get(Var("count"), Get(Var("r"), Int(0))), Int(1), Sub, kind=None)), Let(("_", Var({val: None})), If(LE(Int(1), Get(Var("count"), Get(Var("r"), Int(0)))), Put(Var("go"), Int(0), Bool(false)), Put(Var("r"), Int(0), Prim(Get(Var("r"), Int(0)), Int(1), Add, kind=None))), Unit))))))), App(Var("go_loop"), [])), Unit)}, Let(("_", Var({val: None})), App(Var("go_loop"), []), Let(("_", Var({val: None})), Put(Var("nperm"), Int(0), Prim(Get(Var("nperm"), Int(0)), Int(1), Add, kind=None)), App(Var("compute"), [Var("r")])))))) against Unit
// [Typer] infer: Array(Int(1), Bool(true))
// [Typer] infer: Bool(true)
// [Typer] check: Int(1) against Int
// [Typer] unify: Var({val: None}) and Array(Bool)
// [Typer] union: Var({val: None}) and Array(Bool)
// [Typer] check: Let(("t", Var({val: None})), Array(Int(1), Int(0)), LetRec({tyvars: [], name: ("go_loop", Unit), args: [], body: If(Get(Var("go"), Int(0)), Let(("_", Var({val: None})), If(Eq(Get(Var("r"), Int(0)), Var("n")), Let(("_", Var({val: None})), Put(Var("go"), Int(0), Bool(false)), Let(("_", Var({val: None})), Put(Var("r"), Int(0), Int(0)), Unit)), Let(("_", Var({val: None})), Put(Var("t"), Int(0), Get(Var("perm1"), Int(0))), LetRec({tyvars: [], name: ("move_perm1_forward", Unit), args: [("i", Int)], body: If(LE(Var("i"), Prim(Get(Var("r"), Int(0)), Int(1), Sub, kind=None)), Let(("_", Var({val: None})), Put(Var("perm1"), Var("i"), Get(Var("perm1"), Prim(Var("i"), Int(1), Add, kind=None))), Let(("_", Var({val: None})), App(Var("move_perm1_forward"), [Prim(Var("i"), Int(1), Add, kind=None)]), Unit)), Unit)}, Let(("_", Var({val: None})), App(Var("move_perm1_forward"), [Int(0)]), Let(("_", Var({val: None})), Put(Var("perm1"), Get(Var("r"), Int(0)), Get(Var("t"), Int(0))), Let(("_", Var({val: None})), Put(Var("count"), Get(Var("r"), Int(0)), Prim(Get(Var("count"), Get(Var("r"), Int(0))), Int(1), Sub, kind=None)), Let(("_", Var({val: None})), If(LE(Int(1), Get(Var("count"), Get(Var("r"), Int(0)))), Put(Var("go"), Int(0), Bool(false)), Put(Var("r"), Int(0), Prim(Get(Var("r"), Int(0)), Int(1), Add, kind=None))), Unit))))))), App(Var("go_loop"), [])), Unit)}, Let(("_", Var({val: None})), App(Var("go_loop"), []), Let(("_", Var({val: None})), Put(Var("nperm"), Int(0), Prim(Get(Var("nperm"), Int(0)), Int(1), Add, kind=None)), App(Var("compute"), [Var("r")]))))) against Unit
// [Typer] infer: Array(Int(1), Int(0))
// [Typer] infer: Int(0)
// [Typer] check: Int(1) against Int
// [Typer] unify: Var({val: None}) and Array(Int)
// [Typer] union: Var({val: None}) and Array(Int)
// [Typer] check: LetRec({tyvars: [], name: ("go_loop", Unit), args: [], body: If(Get(Var("go"), Int(0)), Let(("_", Var({val: None})), If(Eq(Get(Var("r"), Int(0)), Var("n")), Let(("_", Var({val: None})), Put(Var("go"), Int(0), Bool(false)), Let(("_", Var({val: None})), Put(Var("r"), Int(0), Int(0)), Unit)), Let(("_", Var({val: None})), Put(Var("t"), Int(0), Get(Var("perm1"), Int(0))), LetRec({tyvars: [], name: ("move_perm1_forward", Unit), args: [("i", Int)], body: If(LE(Var("i"), Prim(Get(Var("r"), Int(0)), Int(1), Sub, kind=None)), Let(("_", Var({val: None})), Put(Var("perm1"), Var("i"), Get(Var("perm1"), Prim(Var("i"), Int(1), Add, kind=None))), Let(("_", Var({val: None})), App(Var("move_perm1_forward"), [Prim(Var("i"), Int(1), Add, kind=None)]), Unit)), Unit)}, Let(("_", Var({val: None})), App(Var("move_perm1_forward"), [Int(0)]), Let(("_", Var({val: None})), Put(Var("perm1"), Get(Var("r"), Int(0)), Get(Var("t"), Int(0))), Let(("_", Var({val: None})), Put(Var("count"), Get(Var("r"), Int(0)), Prim(Get(Var("count"), Get(Var("r"), Int(0))), Int(1), Sub, kind=None)), Let(("_", Var({val: None})), If(LE(Int(1), Get(Var("count"), Get(Var("r"), Int(0)))), Put(Var("go"), Int(0), Bool(false)), Put(Var("r"), Int(0), Prim(Get(Var("r"), Int(0)), Int(1), Add, kind=None))), Unit))))))), App(Var("go_loop"), [])), Unit)}, Let(("_", Var({val: None})), App(Var("go_loop"), []), Let(("_", Var({val: None})), Put(Var("nperm"), Int(0), Prim(Get(Var("nperm"), Int(0)), Int(1), Add, kind=None)), App(Var("compute"), [Var("r")])))) against Unit
// [Typer] typevars: []
// [Typer] check: If(Get(Var("go"), Int(0)), Let(("_", Var({val: None})), If(Eq(Get(Var("r"), Int(0)), Var("n")), Let(("_", Var({val: None})), Put(Var("go"), Int(0), Bool(false)), Let(("_", Var({val: None})), Put(Var("r"), Int(0), Int(0)), Unit)), Let(("_", Var({val: None})), Put(Var("t"), Int(0), Get(Var("perm1"), Int(0))), LetRec({tyvars: [], name: ("move_perm1_forward", Unit), args: [("i", Int)], body: If(LE(Var("i"), Prim(Get(Var("r"), Int(0)), Int(1), Sub, kind=None)), Let(("_", Var({val: None})), Put(Var("perm1"), Var("i"), Get(Var("perm1"), Prim(Var("i"), Int(1), Add, kind=None))), Let(("_", Var({val: None})), App(Var("move_perm1_forward"), [Prim(Var("i"), Int(1), Add, kind=None)]), Unit)), Unit)}, Let(("_", Var({val: None})), App(Var("move_perm1_forward"), [Int(0)]), Let(("_", Var({val: None})), Put(Var("perm1"), Get(Var("r"), Int(0)), Get(Var("t"), Int(0))), Let(("_", Var({val: None})), Put(Var("count"), Get(Var("r"), Int(0)), Prim(Get(Var("count"), Get(Var("r"), Int(0))), Int(1), Sub, kind=None)), Let(("_", Var({val: None})), If(LE(Int(1), Get(Var("count"), Get(Var("r"), Int(0)))), Put(Var("go"), Int(0), Bool(false)), Put(Var("r"), Int(0), Prim(Get(Var("r"), Int(0)), Int(1), Add, kind=None))), Unit))))))), App(Var("go_loop"), [])), Unit) against Unit
// [Typer] check: Get(Var("go"), Int(0)) against Bool
// [Typer] check: Var("go") against Array(Bool)
// [Typer] inst: TypeScheme(([], Var({val: Some(Array(Bool))})))
// [Typer] inst result: Array(Bool)
// [Typer] unify: Array(Bool) and Array(Bool)
// [Typer] unify: Bool and Bool
// [Typer] check: Int(0) against Int
// [Typer] check: Let(("_", Var({val: None})), If(Eq(Get(Var("r"), Int(0)), Var("n")), Let(("_", Var({val: None})), Put(Var("go"), Int(0), Bool(false)), Let(("_", Var({val: None})), Put(Var("r"), Int(0), Int(0)), Unit)), Let(("_", Var({val: None})), Put(Var("t"), Int(0), Get(Var("perm1"), Int(0))), LetRec({tyvars: [], name: ("move_perm1_forward", Unit), args: [("i", Int)], body: If(LE(Var("i"), Prim(Get(Var("r"), Int(0)), Int(1), Sub, kind=None)), Let(("_", Var({val: None})), Put(Var("perm1"), Var("i"), Get(Var("perm1"), Prim(Var("i"), Int(1), Add, kind=None))), Let(("_", Var({val: None})), App(Var("move_perm1_forward"), [Prim(Var("i"), Int(1), Add, kind=None)]), Unit)), Unit)}, Let(("_", Var({val: None})), App(Var("move_perm1_forward"), [Int(0)]), Let(("_", Var({val: None})), Put(Var("perm1"), Get(Var("r"), Int(0)), Get(Var("t"), Int(0))), Let(("_", Var({val: None})), Put(Var("count"), Get(Var("r"), Int(0)), Prim(Get(Var("count"), Get(Var("r"), Int(0))), Int(1), Sub, kind=None)), Let(("_", Var({val: None})), If(LE(Int(1), Get(Var("count"), Get(Var("r"), Int(0)))), Put(Var("go"), Int(0), Bool(false)), Put(Var("r"), Int(0), Prim(Get(Var("r"), Int(0)), Int(1), Add, kind=None))), Unit))))))), App(Var("go_loop"), [])) against Unit
// [Typer] infer: If(Eq(Get(Var("r"), Int(0)), Var("n")), Let(("_", Var({val: None})), Put(Var("go"), Int(0), Bool(false)), Let(("_", Var({val: None})), Put(Var("r"), Int(0), Int(0)), Unit)), Let(("_", Var({val: None})), Put(Var("t"), Int(0), Get(Var("perm1"), Int(0))), LetRec({tyvars: [], name: ("move_perm1_forward", Unit), args: [("i", Int)], body: If(LE(Var("i"), Prim(Get(Var("r"), Int(0)), Int(1), Sub, kind=None)), Let(("_", Var({val: None})), Put(Var("perm1"), Var("i"), Get(Var("perm1"), Prim(Var("i"), Int(1), Add, kind=None))), Let(("_", Var({val: None})), App(Var("move_perm1_forward"), [Prim(Var("i"), Int(1), Add, kind=None)]), Unit)), Unit)}, Let(("_", Var({val: None})), App(Var("move_perm1_forward"), [Int(0)]), Let(("_", Var({val: None})), Put(Var("perm1"), Get(Var("r"), Int(0)), Get(Var("t"), Int(0))), Let(("_", Var({val: None})), Put(Var("count"), Get(Var("r"), Int(0)), Prim(Get(Var("count"), Get(Var("r"), Int(0))), Int(1), Sub, kind=None)), Let(("_", Var({val: None})), If(LE(Int(1), Get(Var("count"), Get(Var("r"), Int(0)))), Put(Var("go"), Int(0), Bool(false)), Put(Var("r"), Int(0), Prim(Get(Var("r"), Int(0)), Int(1), Add, kind=None))), Unit)))))))
// [Typer] check: Eq(Get(Var("r"), Int(0)), Var("n")) against Bool
// [Typer] infer: Get(Var("r"), Int(0))
// [Typer] infer: Var("r")
// [Typer] inst: TypeScheme(([], Array(Int)))
// [Typer] inst result: Array(Int)
// [Typer] check: Int(0) against Int
// [Typer] infer: Var("n")
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] infer: Let(("_", Var({val: None})), Put(Var("go"), Int(0), Bool(false)), Let(("_", Var({val: None})), Put(Var("r"), Int(0), Int(0)), Unit))
// [Typer] infer: Put(Var("go"), Int(0), Bool(false))
// [Typer] infer: Bool(false)
// [Typer] check: Var("go") against Array(Bool)
// [Typer] inst: TypeScheme(([], Var({val: Some(Array(Bool))})))
// [Typer] inst result: Array(Bool)
// [Typer] unify: Array(Bool) and Array(Bool)
// [Typer] unify: Bool and Bool
// [Typer] check: Int(0) against Int
// [Typer] unify: Var({val: None}) and Unit
// [Typer] union: Var({val: None}) and Unit
// [Typer] infer: Let(("_", Var({val: None})), Put(Var("r"), Int(0), Int(0)), Unit)
// [Typer] infer: Put(Var("r"), Int(0), Int(0))
// [Typer] infer: Int(0)
// [Typer] check: Var("r") against Array(Int)
// [Typer] inst: TypeScheme(([], Array(Int)))
// [Typer] inst result: Array(Int)
// [Typer] unify: Array(Int) and Array(Int)
// [Typer] unify: Int and Int
// [Typer] check: Int(0) against Int
// [Typer] unify: Var({val: None}) and Unit
// [Typer] union: Var({val: None}) and Unit
// [Typer] infer: Unit
// [Typer] infer: Let(("_", Var({val: None})), Put(Var("t"), Int(0), Get(Var("perm1"), Int(0))), LetRec({tyvars: [], name: ("move_perm1_forward", Unit), args: [("i", Int)], body: If(LE(Var("i"), Prim(Get(Var("r"), Int(0)), Int(1), Sub, kind=None)), Let(("_", Var({val: None})), Put(Var("perm1"), Var("i"), Get(Var("perm1"), Prim(Var("i"), Int(1), Add, kind=None))), Let(("_", Var({val: None})), App(Var("move_perm1_forward"), [Prim(Var("i"), Int(1), Add, kind=None)]), Unit)), Unit)}, Let(("_", Var({val: None})), App(Var("move_perm1_forward"), [Int(0)]), Let(("_", Var({val: None})), Put(Var("perm1"), Get(Var("r"), Int(0)), Get(Var("t"), Int(0))), Let(("_", Var({val: None})), Put(Var("count"), Get(Var("r"), Int(0)), Prim(Get(Var("count"), Get(Var("r"), Int(0))), Int(1), Sub, kind=None)), Let(("_", Var({val: None})), If(LE(Int(1), Get(Var("count"), Get(Var("r"), Int(0)))), Put(Var("go"), Int(0), Bool(false)), Put(Var("r"), Int(0), Prim(Get(Var("r"), Int(0)), Int(1), Add, kind=None))), Unit))))))
// [Typer] infer: Put(Var("t"), Int(0), Get(Var("perm1"), Int(0)))
// [Typer] infer: Get(Var("perm1"), Int(0))
// [Typer] infer: Var("perm1")
// [Typer] inst: TypeScheme(([], Var({val: Some(Array(Int))})))
// [Typer] inst result: Array(Int)
// [Typer] check: Int(0) against Int
// [Typer] check: Var("t") against Array(Int)
// [Typer] inst: TypeScheme(([], Var({val: Some(Array(Int))})))
// [Typer] inst result: Array(Int)
// [Typer] unify: Array(Int) and Array(Int)
// [Typer] unify: Int and Int
// [Typer] check: Int(0) against Int
// [Typer] unify: Var({val: None}) and Unit
// [Typer] union: Var({val: None}) and Unit
// [Typer] infer: LetRec({tyvars: [], name: ("move_perm1_forward", Unit), args: [("i", Int)], body: If(LE(Var("i"), Prim(Get(Var("r"), Int(0)), Int(1), Sub, kind=None)), Let(("_", Var({val: None})), Put(Var("perm1"), Var("i"), Get(Var("perm1"), Prim(Var("i"), Int(1), Add, kind=None))), Let(("_", Var({val: None})), App(Var("move_perm1_forward"), [Prim(Var("i"), Int(1), Add, kind=None)]), Unit)), Unit)}, Let(("_", Var({val: None})), App(Var("move_perm1_forward"), [Int(0)]), Let(("_", Var({val: None})), Put(Var("perm1"), Get(Var("r"), Int(0)), Get(Var("t"), Int(0))), Let(("_", Var({val: None})), Put(Var("count"), Get(Var("r"), Int(0)), Prim(Get(Var("count"), Get(Var("r"), Int(0))), Int(1), Sub, kind=None)), Let(("_", Var({val: None})), If(LE(Int(1), Get(Var("count"), Get(Var("r"), Int(0)))), Put(Var("go"), Int(0), Bool(false)), Put(Var("r"), Int(0), Prim(Get(Var("r"), Int(0)), Int(1), Add, kind=None))), Unit)))))
// [Typer] typevars: []
// [Typer] check: If(LE(Var("i"), Prim(Get(Var("r"), Int(0)), Int(1), Sub, kind=None)), Let(("_", Var({val: None})), Put(Var("perm1"), Var("i"), Get(Var("perm1"), Prim(Var("i"), Int(1), Add, kind=None))), Let(("_", Var({val: None})), App(Var("move_perm1_forward"), [Prim(Var("i"), Int(1), Add, kind=None)]), Unit)), Unit) against Unit
// [Typer] check: LE(Var("i"), Prim(Get(Var("r"), Int(0)), Int(1), Sub, kind=None)) against Bool
// [Typer] infer: Var("i")
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] infer: Prim(Get(Var("r"), Int(0)), Int(1), Sub, kind=None)
// [Typer] infer: Get(Var("r"), Int(0))
// [Typer] infer: Var("r")
// [Typer] inst: TypeScheme(([], Array(Int)))
// [Typer] inst result: Array(Int)
// [Typer] check: Int(0) against Int
// [Typer] infer: Int(1)
// [Typer] unify: Int and Int
// [Typer] unify: Int and Int
// [Typer] check: Let(("_", Var({val: None})), Put(Var("perm1"), Var("i"), Get(Var("perm1"), Prim(Var("i"), Int(1), Add, kind=None))), Let(("_", Var({val: None})), App(Var("move_perm1_forward"), [Prim(Var("i"), Int(1), Add, kind=None)]), Unit)) against Unit
// [Typer] infer: Put(Var("perm1"), Var("i"), Get(Var("perm1"), Prim(Var("i"), Int(1), Add, kind=None)))
// [Typer] infer: Get(Var("perm1"), Prim(Var("i"), Int(1), Add, kind=None))
// [Typer] infer: Var("perm1")
// [Typer] inst: TypeScheme(([], Var({val: Some(Array(Int))})))
// [Typer] inst result: Array(Int)
// [Typer] check: Prim(Var("i"), Int(1), Add, kind=None) against Int
// [Typer] check: Var("i") against Int
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] check: Int(1) against Int
// [Typer] check: Var("perm1") against Array(Int)
// [Typer] inst: TypeScheme(([], Var({val: Some(Array(Int))})))
// [Typer] inst result: Array(Int)
// [Typer] unify: Array(Int) and Array(Int)
// [Typer] unify: Int and Int
// [Typer] check: Var("i") against Int
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] unify: Var({val: None}) and Unit
// [Typer] union: Var({val: None}) and Unit
// [Typer] check: Let(("_", Var({val: None})), App(Var("move_perm1_forward"), [Prim(Var("i"), Int(1), Add, kind=None)]), Unit) against Unit
// [Typer] infer: App(Var("move_perm1_forward"), [Prim(Var("i"), Int(1), Add, kind=None)])
// [Typer] infer: Var("move_perm1_forward")
// [Typer] inst: TypeScheme(([], Fun([Int], Unit)))
// [Typer] inst result: Fun([Int], Unit)
// [Typer] check: Prim(Var("i"), Int(1), Add, kind=None) against Int
// [Typer] check: Var("i") against Int
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] check: Int(1) against Int
// [Typer] unify: Var({val: None}) and Unit
// [Typer] union: Var({val: None}) and Unit
// [Typer] check: Unit against Unit
// [Typer] check: Unit against Unit
// [Typer] infer: Let(("_", Var({val: None})), App(Var("move_perm1_forward"), [Int(0)]), Let(("_", Var({val: None})), Put(Var("perm1"), Get(Var("r"), Int(0)), Get(Var("t"), Int(0))), Let(("_", Var({val: None})), Put(Var("count"), Get(Var("r"), Int(0)), Prim(Get(Var("count"), Get(Var("r"), Int(0))), Int(1), Sub, kind=None)), Let(("_", Var({val: None})), If(LE(Int(1), Get(Var("count"), Get(Var("r"), Int(0)))), Put(Var("go"), Int(0), Bool(false)), Put(Var("r"), Int(0), Prim(Get(Var("r"), Int(0)), Int(1), Add, kind=None))), Unit))))
// [Typer] infer: App(Var("move_perm1_forward"), [Int(0)])
// [Typer] infer: Var("move_perm1_forward")
// [Typer] inst: TypeScheme(([], Fun([Int], Unit)))
// [Typer] inst result: Fun([Int], Unit)
// [Typer] check: Int(0) against Int
// [Typer] unify: Var({val: None}) and Unit
// [Typer] union: Var({val: None}) and Unit
// [Typer] infer: Let(("_", Var({val: None})), Put(Var("perm1"), Get(Var("r"), Int(0)), Get(Var("t"), Int(0))), Let(("_", Var({val: None})), Put(Var("count"), Get(Var("r"), Int(0)), Prim(Get(Var("count"), Get(Var("r"), Int(0))), Int(1), Sub, kind=None)), Let(("_", Var({val: None})), If(LE(Int(1), Get(Var("count"), Get(Var("r"), Int(0)))), Put(Var("go"), Int(0), Bool(false)), Put(Var("r"), Int(0), Prim(Get(Var("r"), Int(0)), Int(1), Add, kind=None))), Unit)))
// [Typer] infer: Put(Var("perm1"), Get(Var("r"), Int(0)), Get(Var("t"), Int(0)))
// [Typer] infer: Get(Var("t"), Int(0))
// [Typer] infer: Var("t")
// [Typer] inst: TypeScheme(([], Var({val: Some(Array(Int))})))
// [Typer] inst result: Array(Int)
// [Typer] check: Int(0) against Int
// [Typer] check: Var("perm1") against Array(Int)
// [Typer] inst: TypeScheme(([], Var({val: Some(Array(Int))})))
// [Typer] inst result: Array(Int)
// [Typer] unify: Array(Int) and Array(Int)
// [Typer] unify: Int and Int
// [Typer] check: Get(Var("r"), Int(0)) against Int
// [Typer] check: Var("r") against Array(Int)
// [Typer] inst: TypeScheme(([], Array(Int)))
// [Typer] inst result: Array(Int)
// [Typer] unify: Array(Int) and Array(Int)
// [Typer] unify: Int and Int
// [Typer] check: Int(0) against Int
// [Typer] unify: Var({val: None}) and Unit
// [Typer] union: Var({val: None}) and Unit
// [Typer] infer: Let(("_", Var({val: None})), Put(Var("count"), Get(Var("r"), Int(0)), Prim(Get(Var("count"), Get(Var("r"), Int(0))), Int(1), Sub, kind=None)), Let(("_", Var({val: None})), If(LE(Int(1), Get(Var("count"), Get(Var("r"), Int(0)))), Put(Var("go"), Int(0), Bool(false)), Put(Var("r"), Int(0), Prim(Get(Var("r"), Int(0)), Int(1), Add, kind=None))), Unit))
// [Typer] infer: Put(Var("count"), Get(Var("r"), Int(0)), Prim(Get(Var("count"), Get(Var("r"), Int(0))), Int(1), Sub, kind=None))
// [Typer] infer: Prim(Get(Var("count"), Get(Var("r"), Int(0))), Int(1), Sub, kind=None)
// [Typer] infer: Get(Var("count"), Get(Var("r"), Int(0)))
// [Typer] infer: Var("count")
// [Typer] inst: TypeScheme(([], Var({val: Some(Array(Int))})))
// [Typer] inst result: Array(Int)
// [Typer] check: Get(Var("r"), Int(0)) against Int
// [Typer] check: Var("r") against Array(Int)
// [Typer] inst: TypeScheme(([], Array(Int)))
// [Typer] inst result: Array(Int)
// [Typer] unify: Array(Int) and Array(Int)
// [Typer] unify: Int and Int
// [Typer] check: Int(0) against Int
// [Typer] infer: Int(1)
// [Typer] unify: Int and Int
// [Typer] check: Var("count") against Array(Int)
// [Typer] inst: TypeScheme(([], Var({val: Some(Array(Int))})))
// [Typer] inst result: Array(Int)
// [Typer] unify: Array(Int) and Array(Int)
// [Typer] unify: Int and Int
// [Typer] check: Get(Var("r"), Int(0)) against Int
// [Typer] check: Var("r") against Array(Int)
// [Typer] inst: TypeScheme(([], Array(Int)))
// [Typer] inst result: Array(Int)
// [Typer] unify: Array(Int) and Array(Int)
// [Typer] unify: Int and Int
// [Typer] check: Int(0) against Int
// [Typer] unify: Var({val: None}) and Unit
// [Typer] union: Var({val: None}) and Unit
// [Typer] infer: Let(("_", Var({val: None})), If(LE(Int(1), Get(Var("count"), Get(Var("r"), Int(0)))), Put(Var("go"), Int(0), Bool(false)), Put(Var("r"), Int(0), Prim(Get(Var("r"), Int(0)), Int(1), Add, kind=None))), Unit)
// [Typer] infer: If(LE(Int(1), Get(Var("count"), Get(Var("r"), Int(0)))), Put(Var("go"), Int(0), Bool(false)), Put(Var("r"), Int(0), Prim(Get(Var("r"), Int(0)), Int(1), Add, kind=None)))
// [Typer] check: LE(Int(1), Get(Var("count"), Get(Var("r"), Int(0)))) against Bool
// [Typer] infer: Int(1)
// [Typer] infer: Get(Var("count"), Get(Var("r"), Int(0)))
// [Typer] infer: Var("count")
// [Typer] inst: TypeScheme(([], Var({val: Some(Array(Int))})))
// [Typer] inst result: Array(Int)
// [Typer] check: Get(Var("r"), Int(0)) against Int
// [Typer] check: Var("r") against Array(Int)
// [Typer] inst: TypeScheme(([], Array(Int)))
// [Typer] inst result: Array(Int)
// [Typer] unify: Array(Int) and Array(Int)
// [Typer] unify: Int and Int
// [Typer] check: Int(0) against Int
// [Typer] unify: Int and Int
// [Typer] infer: Put(Var("go"), Int(0), Bool(false))
// [Typer] infer: Bool(false)
// [Typer] check: Var("go") against Array(Bool)
// [Typer] inst: TypeScheme(([], Var({val: Some(Array(Bool))})))
// [Typer] inst result: Array(Bool)
// [Typer] unify: Array(Bool) and Array(Bool)
// [Typer] unify: Bool and Bool
// [Typer] check: Int(0) against Int
// [Typer] infer: Put(Var("r"), Int(0), Prim(Get(Var("r"), Int(0)), Int(1), Add, kind=None))
// [Typer] infer: Prim(Get(Var("r"), Int(0)), Int(1), Add, kind=None)
// [Typer] infer: Get(Var("r"), Int(0))
// [Typer] infer: Var("r")
// [Typer] inst: TypeScheme(([], Array(Int)))
// [Typer] inst result: Array(Int)
// [Typer] check: Int(0) against Int
// [Typer] infer: Int(1)
// [Typer] unify: Int and Int
// [Typer] check: Var("r") against Array(Int)
// [Typer] inst: TypeScheme(([], Array(Int)))
// [Typer] inst result: Array(Int)
// [Typer] unify: Array(Int) and Array(Int)
// [Typer] unify: Int and Int
// [Typer] check: Int(0) against Int
// [Typer] unify: Unit and Unit
// [Typer] unify: Var({val: None}) and Unit
// [Typer] union: Var({val: None}) and Unit
// [Typer] infer: Unit
// [Typer] unify: Unit and Unit
// [Typer] unify: Var({val: None}) and Unit
// [Typer] union: Var({val: None}) and Unit
// [Typer] check: App(Var("go_loop"), []) against Unit
// [Typer] check: Var("go_loop") against Fun([], Unit)
// [Typer] inst: TypeScheme(([], Fun([], Unit)))
// [Typer] inst result: Fun([], Unit)
// [Typer] unify: Fun([], Unit) and Fun([], Unit)
// [Typer] unify: Unit and Unit
// [Typer] check: Unit against Unit
// [Typer] check: Let(("_", Var({val: None})), App(Var("go_loop"), []), Let(("_", Var({val: None})), Put(Var("nperm"), Int(0), Prim(Get(Var("nperm"), Int(0)), Int(1), Add, kind=None)), App(Var("compute"), [Var("r")]))) against Unit
// [Typer] infer: App(Var("go_loop"), [])
// [Typer] infer: Var("go_loop")
// [Typer] inst: TypeScheme(([], Fun([], Unit)))
// [Typer] inst result: Fun([], Unit)
// [Typer] unify: Var({val: None}) and Unit
// [Typer] union: Var({val: None}) and Unit
// [Typer] check: Let(("_", Var({val: None})), Put(Var("nperm"), Int(0), Prim(Get(Var("nperm"), Int(0)), Int(1), Add, kind=None)), App(Var("compute"), [Var("r")])) against Unit
// [Typer] infer: Put(Var("nperm"), Int(0), Prim(Get(Var("nperm"), Int(0)), Int(1), Add, kind=None))
// [Typer] infer: Prim(Get(Var("nperm"), Int(0)), Int(1), Add, kind=None)
// [Typer] infer: Get(Var("nperm"), Int(0))
// [Typer] infer: Var("nperm")
// [Typer] inst: TypeScheme(([], Var({val: Some(Array(Int))})))
// [Typer] inst result: Array(Int)
// [Typer] check: Int(0) against Int
// [Typer] infer: Int(1)
// [Typer] unify: Int and Int
// [Typer] check: Var("nperm") against Array(Int)
// [Typer] inst: TypeScheme(([], Var({val: Some(Array(Int))})))
// [Typer] inst result: Array(Int)
// [Typer] unify: Array(Int) and Array(Int)
// [Typer] unify: Int and Int
// [Typer] check: Int(0) against Int
// [Typer] unify: Var({val: None}) and Unit
// [Typer] union: Var({val: None}) and Unit
// [Typer] check: App(Var("compute"), [Var("r")]) against Unit
// [Typer] infer: Var("r")
// [Typer] inst: TypeScheme(([], Array(Int)))
// [Typer] inst result: Array(Int)
// [Typer] check: Var("compute") against Fun([Array(Int)], Unit)
// [Typer] inst: TypeScheme(([], Fun([Array(Int)], Unit)))
// [Typer] inst result: Fun([Array(Int)], Unit)
// [Typer] unify: Fun([Array(Int)], Unit) and Fun([Array(Int)], Unit)
// [Typer] unify: Array(Int) and Array(Int)
// [Typer] unify: Int and Int
// [Typer] unify: Unit and Unit
// [Typer] check: Unit against Unit
// [Typer] check: Let(("_", Var({val: None})), App(Var("compute"), [Var("r")]), Tuple([Get(Var("max_flips"), Int(0)), Get(Var("check_sum"), Int(0))])) against Tuple([Int, Int])
// [Typer] infer: App(Var("compute"), [Var("r")])
// [Typer] infer: Var("compute")
// [Typer] inst: TypeScheme(([], Fun([Array(Int)], Unit)))
// [Typer] inst result: Fun([Array(Int)], Unit)
// [Typer] check: Var("r") against Array(Int)
// [Typer] inst: TypeScheme(([], Var({val: Some(Array(Int))})))
// [Typer] inst result: Array(Int)
// [Typer] unify: Array(Int) and Array(Int)
// [Typer] unify: Int and Int
// [Typer] unify: Var({val: None}) and Unit
// [Typer] union: Var({val: None}) and Unit
// [Typer] check: Tuple([Get(Var("max_flips"), Int(0)), Get(Var("check_sum"), Int(0))]) against Tuple([Int, Int])
// [Typer] check: Get(Var("max_flips"), Int(0)) against Int
// [Typer] check: Var("max_flips") against Array(Int)
// [Typer] inst: TypeScheme(([], Var({val: Some(Array(Int))})))
// [Typer] inst result: Array(Int)
// [Typer] unify: Array(Int) and Array(Int)
// [Typer] unify: Int and Int
// [Typer] check: Int(0) against Int
// [Typer] check: Get(Var("check_sum"), Int(0)) against Int
// [Typer] check: Var("check_sum") against Array(Int)
// [Typer] inst: TypeScheme(([], Var({val: Some(Array(Int))})))
// [Typer] inst result: Array(Int)
// [Typer] unify: Array(Int) and Array(Int)
// [Typer] unify: Int and Int
// [Typer] check: Int(0) against Int
// [Typer] check: LetRec({tyvars: [], name: ("main", Var({val: None})), args: [], body: LetTuple([("max_flips", Var({val: None})), ("check_sum", Var({val: None}))], App(Var("fannkuch"), [Int(9)]), Let(("_", Var({val: None})), App(Var("print_int"), [Var("check_sum")]), App(Var("print_int"), [Var("max_flips")])))}, Unit) against Unit
// [Typer] typevars: []
// [Typer] infer: LetTuple([("max_flips", Var({val: None})), ("check_sum", Var({val: None}))], App(Var("fannkuch"), [Int(9)]), Let(("_", Var({val: None})), App(Var("print_int"), [Var("check_sum")]), App(Var("print_int"), [Var("max_flips")])))
// [Typer] infer: App(Var("fannkuch"), [Int(9)])
// [Typer] infer: Var("fannkuch")
// [Typer] inst: TypeScheme(([], Fun([Int], Tuple([Int, Int]))))
// [Typer] inst result: Fun([Int], Tuple([Int, Int]))
// [Typer] check: Int(9) against Int
// [Typer] unify: Var({val: None}) and Int
// [Typer] union: Var({val: None}) and Int
// [Typer] unify: Var({val: None}) and Int
// [Typer] union: Var({val: None}) and Int
// [Typer] infer: Let(("_", Var({val: None})), App(Var("print_int"), [Var("check_sum")]), App(Var("print_int"), [Var("max_flips")]))
// [Typer] infer: App(Var("print_int"), [Var("check_sum")])
// [Typer] infer: Var("print_int")
// [Typer] inst: TypeScheme(([], Fun([Int], Unit)))
// [Typer] inst result: Fun([Int], Unit)
// [Typer] check: Var("check_sum") against Int
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] unify: Var({val: None}) and Unit
// [Typer] union: Var({val: None}) and Unit
// [Typer] infer: App(Var("print_int"), [Var("max_flips")])
// [Typer] infer: Var("print_int")
// [Typer] inst: TypeScheme(([], Fun([Int], Unit)))
// [Typer] inst result: Fun([Int], Unit)
// [Typer] check: Var("max_flips") against Int
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] unify: Unit and Var({val: None})
// [Typer] union: Unit and Var({val: None})
// [Typer] check: Unit against Unit
// [Parser] flags: []
