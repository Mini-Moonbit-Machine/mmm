// [Knf] build_knf: LetRec({tyvars: [], name: ("swap", Unit), args: [("arr", Array(Int)), ("i", Int), ("j", Int)], body: Let(("tmp", Int), Get(Var("arr"), Var("i")), Let(("_", Unit), Put(Var("arr"), Var("i"), Get(Var("arr"), Var("j"))), Let(("_", Unit), Put(Var("arr"), Var("j"), Var("tmp")), Unit)))}, LetRec({tyvars: [], name: ("partition", Int), args: [("arr", Array(Int)), ("low", Int), ("high", Int)], body: Let(("pivot", Int), Get(Var("arr"), Var("high")), Let(("i", Array(Int)), Array(Int(1), Prim(Var("low"), Int(1), Sub, kind=Some(Int))), LetRec({tyvars: [], name: ("l", Unit), args: [("j", Int)], body: If(LE(Var("j"), Prim(Var("high"), Int(1), Sub, kind=Some(Int))), Let(("_", Unit), If(LE(Get(Var("arr"), Var("j")), Var("pivot")), Let(("_", Unit), Put(Var("i"), Int(0), Prim(Get(Var("i"), Int(0)), Int(1), Add, kind=Some(Int))), App(Var("swap"), [Var("arr"), Get(Var("i"), Int(0)), Var("j")])), Unit), App(Var("l"), [Prim(Var("j"), Int(1), Add, kind=Some(Int))])), Unit)}, Let(("_", Unit), App(Var("l"), [Var("low")]), Let(("_", Unit), Put(Var("i"), Int(0), Prim(Get(Var("i"), Int(0)), Int(1), Add, kind=Some(Int))), Let(("_", Unit), App(Var("swap"), [Var("arr"), Get(Var("i"), Int(0)), Var("high")]), Get(Var("i"), Int(0))))))))}, LetRec({tyvars: [], name: ("quicksort", Unit), args: [("arr", Array(Int)), ("low", Int), ("high", Int)], body: If(LE(Var("low"), Prim(Var("high"), Int(1), Sub, kind=Some(Int))), Let(("pi", Int), App(Var("partition"), [Var("arr"), Var("low"), Var("high")]), Let(("_", Unit), App(Var("quicksort"), [Var("arr"), Var("low"), Prim(Var("pi"), Int(1), Sub, kind=Some(Int))]), App(Var("quicksort"), [Var("arr"), Prim(Var("pi"), Int(1), Add, kind=Some(Int)), Var("high")]))), Unit)}, LetRec({tyvars: [], name: ("main", Unit), args: [], body: Let(("len", Int), App(Var("read_int"), []), Let(("arr", Array(Int)), Array(Var("len"), Int(0)), LetRec({tyvars: [], name: ("input", Unit), args: [("i", Int)], body: If(LE(Var("i"), Prim(Var("len"), Int(1), Sub, kind=Some(Int))), Let(("_", Unit), Put(Var("arr"), Var("i"), App(Var("read_int"), [])), App(Var("input"), [Prim(Var("i"), Int(1), Add, kind=Some(Int))])), Unit)}, Let(("_", Unit), App(Var("input"), [Int(0)]), Let(("_", Unit), App(Var("quicksort"), [Var("arr"), Int(0), Prim(Var("len"), Int(1), Sub, kind=Some(Int))]), LetRec({tyvars: [], name: ("output", Unit), args: [("i", Int)], body: If(LE(Var("i"), Prim(Var("len"), Int(1), Sub, kind=Some(Int))), Let(("_", Unit), App(Var("print_int"), [Get(Var("arr"), Var("i"))]), Let(("_", Unit), App(Var("print_endline"), []), App(Var("output"), [Prim(Var("i"), Int(1), Add, kind=Some(Int))]))), Unit)}, App(Var("output"), [Int(0)])))))))}, App(Var("main"), [])))))
// [Knf] build_knf: Let(("tmp", Int), Get(Var("arr"), Var("i")), Let(("_", Unit), Put(Var("arr"), Var("i"), Get(Var("arr"), Var("j"))), Let(("_", Unit), Put(Var("arr"), Var("j"), Var("tmp")), Unit)))
// [Knf] build_knf: Get(Var("arr"), Var("i"))
// [Knf] build_knf: Var("arr")
// [Knf] build_knf: Var("i")
// [Knf] build_knf: Let(("_", Unit), Put(Var("arr"), Var("i"), Get(Var("arr"), Var("j"))), Let(("_", Unit), Put(Var("arr"), Var("j"), Var("tmp")), Unit))
// [Knf] build_knf: Put(Var("arr"), Var("i"), Get(Var("arr"), Var("j")))
// [Knf] build_knf: Var("arr")
// [Knf] build_knf: Var("i")
// [Knf] build_knf: Get(Var("arr"), Var("j"))
// [Knf] build_knf: Var("arr")
// [Knf] build_knf: Var("j")
// [Knf] build_knf: Let(("_", Unit), Put(Var("arr"), Var("j"), Var("tmp")), Unit)
// [Knf] build_knf: Put(Var("arr"), Var("j"), Var("tmp"))
// [Knf] build_knf: Var("arr")
// [Knf] build_knf: Var("j")
// [Knf] build_knf: Var("tmp")
// [Knf] build_knf: Unit
// [Knf] build_knf: LetRec({tyvars: [], name: ("partition", Int), args: [("arr", Array(Int)), ("low", Int), ("high", Int)], body: Let(("pivot", Int), Get(Var("arr"), Var("high")), Let(("i", Array(Int)), Array(Int(1), Prim(Var("low"), Int(1), Sub, kind=Some(Int))), LetRec({tyvars: [], name: ("l", Unit), args: [("j", Int)], body: If(LE(Var("j"), Prim(Var("high"), Int(1), Sub, kind=Some(Int))), Let(("_", Unit), If(LE(Get(Var("arr"), Var("j")), Var("pivot")), Let(("_", Unit), Put(Var("i"), Int(0), Prim(Get(Var("i"), Int(0)), Int(1), Add, kind=Some(Int))), App(Var("swap"), [Var("arr"), Get(Var("i"), Int(0)), Var("j")])), Unit), App(Var("l"), [Prim(Var("j"), Int(1), Add, kind=Some(Int))])), Unit)}, Let(("_", Unit), App(Var("l"), [Var("low")]), Let(("_", Unit), Put(Var("i"), Int(0), Prim(Get(Var("i"), Int(0)), Int(1), Add, kind=Some(Int))), Let(("_", Unit), App(Var("swap"), [Var("arr"), Get(Var("i"), Int(0)), Var("high")]), Get(Var("i"), Int(0))))))))}, LetRec({tyvars: [], name: ("quicksort", Unit), args: [("arr", Array(Int)), ("low", Int), ("high", Int)], body: If(LE(Var("low"), Prim(Var("high"), Int(1), Sub, kind=Some(Int))), Let(("pi", Int), App(Var("partition"), [Var("arr"), Var("low"), Var("high")]), Let(("_", Unit), App(Var("quicksort"), [Var("arr"), Var("low"), Prim(Var("pi"), Int(1), Sub, kind=Some(Int))]), App(Var("quicksort"), [Var("arr"), Prim(Var("pi"), Int(1), Add, kind=Some(Int)), Var("high")]))), Unit)}, LetRec({tyvars: [], name: ("main", Unit), args: [], body: Let(("len", Int), App(Var("read_int"), []), Let(("arr", Array(Int)), Array(Var("len"), Int(0)), LetRec({tyvars: [], name: ("input", Unit), args: [("i", Int)], body: If(LE(Var("i"), Prim(Var("len"), Int(1), Sub, kind=Some(Int))), Let(("_", Unit), Put(Var("arr"), Var("i"), App(Var("read_int"), [])), App(Var("input"), [Prim(Var("i"), Int(1), Add, kind=Some(Int))])), Unit)}, Let(("_", Unit), App(Var("input"), [Int(0)]), Let(("_", Unit), App(Var("quicksort"), [Var("arr"), Int(0), Prim(Var("len"), Int(1), Sub, kind=Some(Int))]), LetRec({tyvars: [], name: ("output", Unit), args: [("i", Int)], body: If(LE(Var("i"), Prim(Var("len"), Int(1), Sub, kind=Some(Int))), Let(("_", Unit), App(Var("print_int"), [Get(Var("arr"), Var("i"))]), Let(("_", Unit), App(Var("print_endline"), []), App(Var("output"), [Prim(Var("i"), Int(1), Add, kind=Some(Int))]))), Unit)}, App(Var("output"), [Int(0)])))))))}, App(Var("main"), []))))
// [Knf] build_knf: Let(("pivot", Int), Get(Var("arr"), Var("high")), Let(("i", Array(Int)), Array(Int(1), Prim(Var("low"), Int(1), Sub, kind=Some(Int))), LetRec({tyvars: [], name: ("l", Unit), args: [("j", Int)], body: If(LE(Var("j"), Prim(Var("high"), Int(1), Sub, kind=Some(Int))), Let(("_", Unit), If(LE(Get(Var("arr"), Var("j")), Var("pivot")), Let(("_", Unit), Put(Var("i"), Int(0), Prim(Get(Var("i"), Int(0)), Int(1), Add, kind=Some(Int))), App(Var("swap"), [Var("arr"), Get(Var("i"), Int(0)), Var("j")])), Unit), App(Var("l"), [Prim(Var("j"), Int(1), Add, kind=Some(Int))])), Unit)}, Let(("_", Unit), App(Var("l"), [Var("low")]), Let(("_", Unit), Put(Var("i"), Int(0), Prim(Get(Var("i"), Int(0)), Int(1), Add, kind=Some(Int))), Let(("_", Unit), App(Var("swap"), [Var("arr"), Get(Var("i"), Int(0)), Var("high")]), Get(Var("i"), Int(0))))))))
// [Knf] build_knf: Get(Var("arr"), Var("high"))
// [Knf] build_knf: Var("arr")
// [Knf] build_knf: Var("high")
// [Knf] build_knf: Let(("i", Array(Int)), Array(Int(1), Prim(Var("low"), Int(1), Sub, kind=Some(Int))), LetRec({tyvars: [], name: ("l", Unit), args: [("j", Int)], body: If(LE(Var("j"), Prim(Var("high"), Int(1), Sub, kind=Some(Int))), Let(("_", Unit), If(LE(Get(Var("arr"), Var("j")), Var("pivot")), Let(("_", Unit), Put(Var("i"), Int(0), Prim(Get(Var("i"), Int(0)), Int(1), Add, kind=Some(Int))), App(Var("swap"), [Var("arr"), Get(Var("i"), Int(0)), Var("j")])), Unit), App(Var("l"), [Prim(Var("j"), Int(1), Add, kind=Some(Int))])), Unit)}, Let(("_", Unit), App(Var("l"), [Var("low")]), Let(("_", Unit), Put(Var("i"), Int(0), Prim(Get(Var("i"), Int(0)), Int(1), Add, kind=Some(Int))), Let(("_", Unit), App(Var("swap"), [Var("arr"), Get(Var("i"), Int(0)), Var("high")]), Get(Var("i"), Int(0)))))))
// [Knf] build_knf: Array(Int(1), Prim(Var("low"), Int(1), Sub, kind=Some(Int)))
// [Knf] build_knf: Int(1)
// [Knf] build_knf: Prim(Var("low"), Int(1), Sub, kind=Some(Int))
// [Knf] build_knf: Var("low")
// [Knf] build_knf: Int(1)
// [Knf] build_knf: LetRec({tyvars: [], name: ("l", Unit), args: [("j", Int)], body: If(LE(Var("j"), Prim(Var("high"), Int(1), Sub, kind=Some(Int))), Let(("_", Unit), If(LE(Get(Var("arr"), Var("j")), Var("pivot")), Let(("_", Unit), Put(Var("i"), Int(0), Prim(Get(Var("i"), Int(0)), Int(1), Add, kind=Some(Int))), App(Var("swap"), [Var("arr"), Get(Var("i"), Int(0)), Var("j")])), Unit), App(Var("l"), [Prim(Var("j"), Int(1), Add, kind=Some(Int))])), Unit)}, Let(("_", Unit), App(Var("l"), [Var("low")]), Let(("_", Unit), Put(Var("i"), Int(0), Prim(Get(Var("i"), Int(0)), Int(1), Add, kind=Some(Int))), Let(("_", Unit), App(Var("swap"), [Var("arr"), Get(Var("i"), Int(0)), Var("high")]), Get(Var("i"), Int(0))))))
// [Knf] build_knf: If(LE(Var("j"), Prim(Var("high"), Int(1), Sub, kind=Some(Int))), Let(("_", Unit), If(LE(Get(Var("arr"), Var("j")), Var("pivot")), Let(("_", Unit), Put(Var("i"), Int(0), Prim(Get(Var("i"), Int(0)), Int(1), Add, kind=Some(Int))), App(Var("swap"), [Var("arr"), Get(Var("i"), Int(0)), Var("j")])), Unit), App(Var("l"), [Prim(Var("j"), Int(1), Add, kind=Some(Int))])), Unit)
// [Knf] build_knf: Var("j")
// [Knf] build_knf: Prim(Var("high"), Int(1), Sub, kind=Some(Int))
// [Knf] build_knf: Var("high")
// [Knf] build_knf: Int(1)
// [Knf] build_knf: Let(("_", Unit), If(LE(Get(Var("arr"), Var("j")), Var("pivot")), Let(("_", Unit), Put(Var("i"), Int(0), Prim(Get(Var("i"), Int(0)), Int(1), Add, kind=Some(Int))), App(Var("swap"), [Var("arr"), Get(Var("i"), Int(0)), Var("j")])), Unit), App(Var("l"), [Prim(Var("j"), Int(1), Add, kind=Some(Int))]))
// [Knf] build_knf: If(LE(Get(Var("arr"), Var("j")), Var("pivot")), Let(("_", Unit), Put(Var("i"), Int(0), Prim(Get(Var("i"), Int(0)), Int(1), Add, kind=Some(Int))), App(Var("swap"), [Var("arr"), Get(Var("i"), Int(0)), Var("j")])), Unit)
// [Knf] build_knf: Get(Var("arr"), Var("j"))
// [Knf] build_knf: Var("arr")
// [Knf] build_knf: Var("j")
// [Knf] build_knf: Var("pivot")
// [Knf] build_knf: Let(("_", Unit), Put(Var("i"), Int(0), Prim(Get(Var("i"), Int(0)), Int(1), Add, kind=Some(Int))), App(Var("swap"), [Var("arr"), Get(Var("i"), Int(0)), Var("j")]))
// [Knf] build_knf: Put(Var("i"), Int(0), Prim(Get(Var("i"), Int(0)), Int(1), Add, kind=Some(Int)))
// [Knf] build_knf: Var("i")
// [Knf] build_knf: Int(0)
// [Knf] build_knf: Prim(Get(Var("i"), Int(0)), Int(1), Add, kind=Some(Int))
// [Knf] build_knf: Get(Var("i"), Int(0))
// [Knf] build_knf: Var("i")
// [Knf] build_knf: Int(0)
// [Knf] build_knf: Int(1)
// [Knf] build_knf: App(Var("swap"), [Var("arr"), Get(Var("i"), Int(0)), Var("j")])
// [Knf] build_knf: Var("swap")
// [Knf] build_knf: Var("arr")
// [Knf] build_knf: Get(Var("i"), Int(0))
// [Knf] build_knf: Var("i")
// [Knf] build_knf: Int(0)
// [Knf] build_knf: Var("j")
// [Knf] build_knf: Unit
// [Knf] build_knf: App(Var("l"), [Prim(Var("j"), Int(1), Add, kind=Some(Int))])
// [Knf] build_knf: Var("l")
// [Knf] build_knf: Prim(Var("j"), Int(1), Add, kind=Some(Int))
// [Knf] build_knf: Var("j")
// [Knf] build_knf: Int(1)
// [Knf] build_knf: Unit
// [Knf] build_knf: Let(("_", Unit), App(Var("l"), [Var("low")]), Let(("_", Unit), Put(Var("i"), Int(0), Prim(Get(Var("i"), Int(0)), Int(1), Add, kind=Some(Int))), Let(("_", Unit), App(Var("swap"), [Var("arr"), Get(Var("i"), Int(0)), Var("high")]), Get(Var("i"), Int(0)))))
// [Knf] build_knf: App(Var("l"), [Var("low")])
// [Knf] build_knf: Var("l")
// [Knf] build_knf: Var("low")
// [Knf] build_knf: Let(("_", Unit), Put(Var("i"), Int(0), Prim(Get(Var("i"), Int(0)), Int(1), Add, kind=Some(Int))), Let(("_", Unit), App(Var("swap"), [Var("arr"), Get(Var("i"), Int(0)), Var("high")]), Get(Var("i"), Int(0))))
// [Knf] build_knf: Put(Var("i"), Int(0), Prim(Get(Var("i"), Int(0)), Int(1), Add, kind=Some(Int)))
// [Knf] build_knf: Var("i")
// [Knf] build_knf: Int(0)
// [Knf] build_knf: Prim(Get(Var("i"), Int(0)), Int(1), Add, kind=Some(Int))
// [Knf] build_knf: Get(Var("i"), Int(0))
// [Knf] build_knf: Var("i")
// [Knf] build_knf: Int(0)
// [Knf] build_knf: Int(1)
// [Knf] build_knf: Let(("_", Unit), App(Var("swap"), [Var("arr"), Get(Var("i"), Int(0)), Var("high")]), Get(Var("i"), Int(0)))
// [Knf] build_knf: App(Var("swap"), [Var("arr"), Get(Var("i"), Int(0)), Var("high")])
// [Knf] build_knf: Var("swap")
// [Knf] build_knf: Var("arr")
// [Knf] build_knf: Get(Var("i"), Int(0))
// [Knf] build_knf: Var("i")
// [Knf] build_knf: Int(0)
// [Knf] build_knf: Var("high")
// [Knf] build_knf: Get(Var("i"), Int(0))
// [Knf] build_knf: Var("i")
// [Knf] build_knf: Int(0)
// [Knf] build_knf: LetRec({tyvars: [], name: ("quicksort", Unit), args: [("arr", Array(Int)), ("low", Int), ("high", Int)], body: If(LE(Var("low"), Prim(Var("high"), Int(1), Sub, kind=Some(Int))), Let(("pi", Int), App(Var("partition"), [Var("arr"), Var("low"), Var("high")]), Let(("_", Unit), App(Var("quicksort"), [Var("arr"), Var("low"), Prim(Var("pi"), Int(1), Sub, kind=Some(Int))]), App(Var("quicksort"), [Var("arr"), Prim(Var("pi"), Int(1), Add, kind=Some(Int)), Var("high")]))), Unit)}, LetRec({tyvars: [], name: ("main", Unit), args: [], body: Let(("len", Int), App(Var("read_int"), []), Let(("arr", Array(Int)), Array(Var("len"), Int(0)), LetRec({tyvars: [], name: ("input", Unit), args: [("i", Int)], body: If(LE(Var("i"), Prim(Var("len"), Int(1), Sub, kind=Some(Int))), Let(("_", Unit), Put(Var("arr"), Var("i"), App(Var("read_int"), [])), App(Var("input"), [Prim(Var("i"), Int(1), Add, kind=Some(Int))])), Unit)}, Let(("_", Unit), App(Var("input"), [Int(0)]), Let(("_", Unit), App(Var("quicksort"), [Var("arr"), Int(0), Prim(Var("len"), Int(1), Sub, kind=Some(Int))]), LetRec({tyvars: [], name: ("output", Unit), args: [("i", Int)], body: If(LE(Var("i"), Prim(Var("len"), Int(1), Sub, kind=Some(Int))), Let(("_", Unit), App(Var("print_int"), [Get(Var("arr"), Var("i"))]), Let(("_", Unit), App(Var("print_endline"), []), App(Var("output"), [Prim(Var("i"), Int(1), Add, kind=Some(Int))]))), Unit)}, App(Var("output"), [Int(0)])))))))}, App(Var("main"), [])))
// [Knf] build_knf: If(LE(Var("low"), Prim(Var("high"), Int(1), Sub, kind=Some(Int))), Let(("pi", Int), App(Var("partition"), [Var("arr"), Var("low"), Var("high")]), Let(("_", Unit), App(Var("quicksort"), [Var("arr"), Var("low"), Prim(Var("pi"), Int(1), Sub, kind=Some(Int))]), App(Var("quicksort"), [Var("arr"), Prim(Var("pi"), Int(1), Add, kind=Some(Int)), Var("high")]))), Unit)
// [Knf] build_knf: Var("low")
// [Knf] build_knf: Prim(Var("high"), Int(1), Sub, kind=Some(Int))
// [Knf] build_knf: Var("high")
// [Knf] build_knf: Int(1)
// [Knf] build_knf: Let(("pi", Int), App(Var("partition"), [Var("arr"), Var("low"), Var("high")]), Let(("_", Unit), App(Var("quicksort"), [Var("arr"), Var("low"), Prim(Var("pi"), Int(1), Sub, kind=Some(Int))]), App(Var("quicksort"), [Var("arr"), Prim(Var("pi"), Int(1), Add, kind=Some(Int)), Var("high")])))
// [Knf] build_knf: App(Var("partition"), [Var("arr"), Var("low"), Var("high")])
// [Knf] build_knf: Var("partition")
// [Knf] build_knf: Var("arr")
// [Knf] build_knf: Var("low")
// [Knf] build_knf: Var("high")
// [Knf] build_knf: Let(("_", Unit), App(Var("quicksort"), [Var("arr"), Var("low"), Prim(Var("pi"), Int(1), Sub, kind=Some(Int))]), App(Var("quicksort"), [Var("arr"), Prim(Var("pi"), Int(1), Add, kind=Some(Int)), Var("high")]))
// [Knf] build_knf: App(Var("quicksort"), [Var("arr"), Var("low"), Prim(Var("pi"), Int(1), Sub, kind=Some(Int))])
// [Knf] build_knf: Var("quicksort")
// [Knf] build_knf: Var("arr")
// [Knf] build_knf: Var("low")
// [Knf] build_knf: Prim(Var("pi"), Int(1), Sub, kind=Some(Int))
// [Knf] build_knf: Var("pi")
// [Knf] build_knf: Int(1)
// [Knf] build_knf: App(Var("quicksort"), [Var("arr"), Prim(Var("pi"), Int(1), Add, kind=Some(Int)), Var("high")])
// [Knf] build_knf: Var("quicksort")
// [Knf] build_knf: Var("arr")
// [Knf] build_knf: Prim(Var("pi"), Int(1), Add, kind=Some(Int))
// [Knf] build_knf: Var("pi")
// [Knf] build_knf: Int(1)
// [Knf] build_knf: Var("high")
// [Knf] build_knf: Unit
// [Knf] build_knf: LetRec({tyvars: [], name: ("main", Unit), args: [], body: Let(("len", Int), App(Var("read_int"), []), Let(("arr", Array(Int)), Array(Var("len"), Int(0)), LetRec({tyvars: [], name: ("input", Unit), args: [("i", Int)], body: If(LE(Var("i"), Prim(Var("len"), Int(1), Sub, kind=Some(Int))), Let(("_", Unit), Put(Var("arr"), Var("i"), App(Var("read_int"), [])), App(Var("input"), [Prim(Var("i"), Int(1), Add, kind=Some(Int))])), Unit)}, Let(("_", Unit), App(Var("input"), [Int(0)]), Let(("_", Unit), App(Var("quicksort"), [Var("arr"), Int(0), Prim(Var("len"), Int(1), Sub, kind=Some(Int))]), LetRec({tyvars: [], name: ("output", Unit), args: [("i", Int)], body: If(LE(Var("i"), Prim(Var("len"), Int(1), Sub, kind=Some(Int))), Let(("_", Unit), App(Var("print_int"), [Get(Var("arr"), Var("i"))]), Let(("_", Unit), App(Var("print_endline"), []), App(Var("output"), [Prim(Var("i"), Int(1), Add, kind=Some(Int))]))), Unit)}, App(Var("output"), [Int(0)])))))))}, App(Var("main"), []))
// [Knf] build_knf: Let(("len", Int), App(Var("read_int"), []), Let(("arr", Array(Int)), Array(Var("len"), Int(0)), LetRec({tyvars: [], name: ("input", Unit), args: [("i", Int)], body: If(LE(Var("i"), Prim(Var("len"), Int(1), Sub, kind=Some(Int))), Let(("_", Unit), Put(Var("arr"), Var("i"), App(Var("read_int"), [])), App(Var("input"), [Prim(Var("i"), Int(1), Add, kind=Some(Int))])), Unit)}, Let(("_", Unit), App(Var("input"), [Int(0)]), Let(("_", Unit), App(Var("quicksort"), [Var("arr"), Int(0), Prim(Var("len"), Int(1), Sub, kind=Some(Int))]), LetRec({tyvars: [], name: ("output", Unit), args: [("i", Int)], body: If(LE(Var("i"), Prim(Var("len"), Int(1), Sub, kind=Some(Int))), Let(("_", Unit), App(Var("print_int"), [Get(Var("arr"), Var("i"))]), Let(("_", Unit), App(Var("print_endline"), []), App(Var("output"), [Prim(Var("i"), Int(1), Add, kind=Some(Int))]))), Unit)}, App(Var("output"), [Int(0)])))))))
// [Knf] build_knf: App(Var("read_int"), [])
// [Knf] build_knf: Let(("arr", Array(Int)), Array(Var("len"), Int(0)), LetRec({tyvars: [], name: ("input", Unit), args: [("i", Int)], body: If(LE(Var("i"), Prim(Var("len"), Int(1), Sub, kind=Some(Int))), Let(("_", Unit), Put(Var("arr"), Var("i"), App(Var("read_int"), [])), App(Var("input"), [Prim(Var("i"), Int(1), Add, kind=Some(Int))])), Unit)}, Let(("_", Unit), App(Var("input"), [Int(0)]), Let(("_", Unit), App(Var("quicksort"), [Var("arr"), Int(0), Prim(Var("len"), Int(1), Sub, kind=Some(Int))]), LetRec({tyvars: [], name: ("output", Unit), args: [("i", Int)], body: If(LE(Var("i"), Prim(Var("len"), Int(1), Sub, kind=Some(Int))), Let(("_", Unit), App(Var("print_int"), [Get(Var("arr"), Var("i"))]), Let(("_", Unit), App(Var("print_endline"), []), App(Var("output"), [Prim(Var("i"), Int(1), Add, kind=Some(Int))]))), Unit)}, App(Var("output"), [Int(0)]))))))
// [Knf] build_knf: Array(Var("len"), Int(0))
// [Knf] build_knf: Var("len")
// [Knf] build_knf: Int(0)
// [Knf] build_knf: LetRec({tyvars: [], name: ("input", Unit), args: [("i", Int)], body: If(LE(Var("i"), Prim(Var("len"), Int(1), Sub, kind=Some(Int))), Let(("_", Unit), Put(Var("arr"), Var("i"), App(Var("read_int"), [])), App(Var("input"), [Prim(Var("i"), Int(1), Add, kind=Some(Int))])), Unit)}, Let(("_", Unit), App(Var("input"), [Int(0)]), Let(("_", Unit), App(Var("quicksort"), [Var("arr"), Int(0), Prim(Var("len"), Int(1), Sub, kind=Some(Int))]), LetRec({tyvars: [], name: ("output", Unit), args: [("i", Int)], body: If(LE(Var("i"), Prim(Var("len"), Int(1), Sub, kind=Some(Int))), Let(("_", Unit), App(Var("print_int"), [Get(Var("arr"), Var("i"))]), Let(("_", Unit), App(Var("print_endline"), []), App(Var("output"), [Prim(Var("i"), Int(1), Add, kind=Some(Int))]))), Unit)}, App(Var("output"), [Int(0)])))))
// [Knf] build_knf: If(LE(Var("i"), Prim(Var("len"), Int(1), Sub, kind=Some(Int))), Let(("_", Unit), Put(Var("arr"), Var("i"), App(Var("read_int"), [])), App(Var("input"), [Prim(Var("i"), Int(1), Add, kind=Some(Int))])), Unit)
// [Knf] build_knf: Var("i")
// [Knf] build_knf: Prim(Var("len"), Int(1), Sub, kind=Some(Int))
// [Knf] build_knf: Var("len")
// [Knf] build_knf: Int(1)
// [Knf] build_knf: Let(("_", Unit), Put(Var("arr"), Var("i"), App(Var("read_int"), [])), App(Var("input"), [Prim(Var("i"), Int(1), Add, kind=Some(Int))]))
// [Knf] build_knf: Put(Var("arr"), Var("i"), App(Var("read_int"), []))
// [Knf] build_knf: Var("arr")
// [Knf] build_knf: Var("i")
// [Knf] build_knf: App(Var("read_int"), [])
// [Knf] build_knf: App(Var("input"), [Prim(Var("i"), Int(1), Add, kind=Some(Int))])
// [Knf] build_knf: Var("input")
// [Knf] build_knf: Prim(Var("i"), Int(1), Add, kind=Some(Int))
// [Knf] build_knf: Var("i")
// [Knf] build_knf: Int(1)
// [Knf] build_knf: Unit
// [Knf] build_knf: Let(("_", Unit), App(Var("input"), [Int(0)]), Let(("_", Unit), App(Var("quicksort"), [Var("arr"), Int(0), Prim(Var("len"), Int(1), Sub, kind=Some(Int))]), LetRec({tyvars: [], name: ("output", Unit), args: [("i", Int)], body: If(LE(Var("i"), Prim(Var("len"), Int(1), Sub, kind=Some(Int))), Let(("_", Unit), App(Var("print_int"), [Get(Var("arr"), Var("i"))]), Let(("_", Unit), App(Var("print_endline"), []), App(Var("output"), [Prim(Var("i"), Int(1), Add, kind=Some(Int))]))), Unit)}, App(Var("output"), [Int(0)]))))
// [Knf] build_knf: App(Var("input"), [Int(0)])
// [Knf] build_knf: Var("input")
// [Knf] build_knf: Int(0)
// [Knf] build_knf: Let(("_", Unit), App(Var("quicksort"), [Var("arr"), Int(0), Prim(Var("len"), Int(1), Sub, kind=Some(Int))]), LetRec({tyvars: [], name: ("output", Unit), args: [("i", Int)], body: If(LE(Var("i"), Prim(Var("len"), Int(1), Sub, kind=Some(Int))), Let(("_", Unit), App(Var("print_int"), [Get(Var("arr"), Var("i"))]), Let(("_", Unit), App(Var("print_endline"), []), App(Var("output"), [Prim(Var("i"), Int(1), Add, kind=Some(Int))]))), Unit)}, App(Var("output"), [Int(0)])))
// [Knf] build_knf: App(Var("quicksort"), [Var("arr"), Int(0), Prim(Var("len"), Int(1), Sub, kind=Some(Int))])
// [Knf] build_knf: Var("quicksort")
// [Knf] build_knf: Var("arr")
// [Knf] build_knf: Int(0)
// [Knf] build_knf: Prim(Var("len"), Int(1), Sub, kind=Some(Int))
// [Knf] build_knf: Var("len")
// [Knf] build_knf: Int(1)
// [Knf] build_knf: LetRec({tyvars: [], name: ("output", Unit), args: [("i", Int)], body: If(LE(Var("i"), Prim(Var("len"), Int(1), Sub, kind=Some(Int))), Let(("_", Unit), App(Var("print_int"), [Get(Var("arr"), Var("i"))]), Let(("_", Unit), App(Var("print_endline"), []), App(Var("output"), [Prim(Var("i"), Int(1), Add, kind=Some(Int))]))), Unit)}, App(Var("output"), [Int(0)]))
// [Knf] build_knf: If(LE(Var("i"), Prim(Var("len"), Int(1), Sub, kind=Some(Int))), Let(("_", Unit), App(Var("print_int"), [Get(Var("arr"), Var("i"))]), Let(("_", Unit), App(Var("print_endline"), []), App(Var("output"), [Prim(Var("i"), Int(1), Add, kind=Some(Int))]))), Unit)
// [Knf] build_knf: Var("i")
// [Knf] build_knf: Prim(Var("len"), Int(1), Sub, kind=Some(Int))
// [Knf] build_knf: Var("len")
// [Knf] build_knf: Int(1)
// [Knf] build_knf: Let(("_", Unit), App(Var("print_int"), [Get(Var("arr"), Var("i"))]), Let(("_", Unit), App(Var("print_endline"), []), App(Var("output"), [Prim(Var("i"), Int(1), Add, kind=Some(Int))])))
// [Knf] build_knf: App(Var("print_int"), [Get(Var("arr"), Var("i"))])
// [Knf] build_knf: Get(Var("arr"), Var("i"))
// [Knf] build_knf: Var("arr")
// [Knf] build_knf: Var("i")
// [Knf] build_knf: Let(("_", Unit), App(Var("print_endline"), []), App(Var("output"), [Prim(Var("i"), Int(1), Add, kind=Some(Int))]))
// [Knf] build_knf: App(Var("print_endline"), [])
// [Knf] build_knf: App(Var("output"), [Prim(Var("i"), Int(1), Add, kind=Some(Int))])
// [Knf] build_knf: Var("output")
// [Knf] build_knf: Prim(Var("i"), Int(1), Add, kind=Some(Int))
// [Knf] build_knf: Var("i")
// [Knf] build_knf: Int(1)
// [Knf] build_knf: Unit
// [Knf] build_knf: App(Var("output"), [Int(0)])
// [Knf] build_knf: Var("output")
// [Knf] build_knf: Int(0)
// [Knf] build_knf: App(Var("main"), [])
// [Knf] build_knf: Var("main")
// [Main] function thunk_main(k) {
// [Main]   function swap_1(arr_3, i_5, j_7, k) {
// [Main]     const tmp_8 = arr_3[i_5];
// [Main]     const _9 = arr_3[j_7];
// [Main]     const _11 = arr_3[i_5] = _9;
// [Main]     const _13 = arr_3[j_7] = tmp_8;
// [Main]     return k(null)
// [Main]   }
// [Main]   function partition_14(arr_16, low_18, high_20, k) {
// [Main]     const pivot_21 = arr_16[high_20];
// [Main]     const _22 = 1;
// [Main]     const _23 = 1;
// [Main]     const _24 = low_18 - _23;
// [Main]     const i_25 = minimbt_create_array($force(_22), $force(_24));
// [Main]     function l_26(j_28, k) {
// [Main]       const _29 = 1;
// [Main]       const _30 = high_20 - _29;
// [Main]       if (j_28 <= _30) {
// [Main]         const _31 = arr_16[j_28];
// [Main]         const _42 = $force((() => {
// [Main]           if (_31 <= pivot_21) {
// [Main]             const _32 = 0;
// [Main]             const _33 = 0;
// [Main]             const _34 = i_25[_33];
// [Main]             const _35 = 1;
// [Main]             const _36 = _34 + _35;
// [Main]             const _38 = i_25[_32] = _36;
// [Main]             const _39 = 0;
// [Main]             const _40 = i_25[_39];
// [Main]             return $thunk(() => swap_1(arr_16, _40, j_28, k))
// [Main]           } else {
// [Main]             return null
// [Main]           }
// [Main]         })());
// [Main]         const _43 = 1;
// [Main]         const _44 = j_28 + _43;
// [Main]         return $thunk(() => l_26(_44, k))
// [Main]       } else {
// [Main]         return k(null)
// [Main]       }
// [Main]     }
// [Main]     return $thunk(() => l_26(low_18, function (_46) {
// [Main]       const _47 = 0;
// [Main]       const _48 = 0;
// [Main]       const _49 = i_25[_48];
// [Main]       const _50 = 1;
// [Main]       const _51 = _49 + _50;
// [Main]       const _53 = i_25[_47] = _51;
// [Main]       const _54 = 0;
// [Main]       const _55 = i_25[_54];
// [Main]       return $thunk(() => swap_1(arr_16, _55, high_20, function (_57) {
// [Main]         const _58 = 0;
// [Main]         return $thunk(() => $thunk(() => k(i_25[_58])))
// [Main]       }
// [Main]       ))
// [Main]     }
// [Main]     ))
// [Main]   }
// [Main]   function quicksort_59(arr_61, low_63, high_65, k) {
// [Main]     const _66 = 1;
// [Main]     const _67 = high_65 - _66;
// [Main]     if (low_63 <= _67) {
// [Main]       return $thunk(() => partition_14(arr_61, low_63, high_65, function (pi_68) {
// [Main]         const _69 = 1;
// [Main]         const _70 = pi_68 - _69;
// [Main]         return $thunk(() => quicksort_59(arr_61, low_63, _70, function (_72) {
// [Main]           const _73 = 1;
// [Main]           const _74 = pi_68 + _73;
// [Main]           return $thunk(() => quicksort_59(arr_61, _74, high_65, k))
// [Main]         }
// [Main]         ))
// [Main]       }
// [Main]       ))
// [Main]     } else {
// [Main]       return k(null)
// [Main]     }
// [Main]   }
// [Main]   function main_75(k) {
// [Main]     const len_76 = minimbt_read_int();
// [Main]     const _77 = 0;
// [Main]     const arr_78 = minimbt_create_array($force(len_76), $force(_77));
// [Main]     function input_79(i_81, k) {
// [Main]       const _82 = 1;
// [Main]       const _83 = len_76 - _82;
// [Main]       if (i_81 <= _83) {
// [Main]         const _84 = minimbt_read_int();
// [Main]         const _86 = arr_78[i_81] = _84;
// [Main]         const _87 = 1;
// [Main]         const _88 = i_81 + _87;
// [Main]         return $thunk(() => input_79(_88, k))
// [Main]       } else {
// [Main]         return k(null)
// [Main]       }
// [Main]     }
// [Main]     const _89 = 0;
// [Main]     return $thunk(() => input_79(_89, function (_91) {
// [Main]       const _92 = 0;
// [Main]       const _93 = 1;
// [Main]       const _94 = len_76 - _93;
// [Main]       return $thunk(() => quicksort_59(arr_78, _92, _94, function (_96) {
// [Main]         function output_97(i_99, k) {
// [Main]           const _100 = 1;
// [Main]           const _101 = len_76 - _100;
// [Main]           if (i_99 <= _101) {
// [Main]             const _102 = arr_78[i_99];
// [Main]             const _104 = minimbt_print_int($force(_102));
// [Main]             const _106 = minimbt_print_endline();
// [Main]             const _107 = 1;
// [Main]             const _108 = i_99 + _107;
// [Main]             return $thunk(() => output_97(_108, k))
// [Main]           } else {
// [Main]             return k(null)
// [Main]           }
// [Main]         }
// [Main]         const _109 = 0;
// [Main]         return $thunk(() => output_97(_109, k))
// [Main]       }
// [Main]       ))
// [Main]     }
// [Main]     ))
// [Main]   }
// [Main]   return $thunk(() => main_75(k))
// [Main] }
// [Main] 
// [Main] function $thunk(lambda) {
// [Main]   return { thunk: lambda };
// [Main] }
// [Main] function $is_thunk(x) {
// [Main]   return x && x.hasOwnProperty('thunk') && x.thunk !== undefined;
// [Main] }
// [Main] function $force(x) {
// [Main]   while ($is_thunk(x)) {
// [Main]     x = x.thunk();
// [Main]   }
// [Main]   return x;
// [Main] }
// [Main] function $trampoline(f, ...args) {
// [Main]   let x = f(...args);
// [Main]   return $force(x);
// [Main] }
// [Main] export default () => $trampoline(thunk_main, x => x);
// [Typer] check: LetRec({tyvars: [], name: ("swap", Unit), args: [("arr", Array(Int)), ("i", Int), ("j", Int)], body: Let(("tmp", Var({val: None})), Get(Var("arr"), Var("i")), Let(("_", Var({val: None})), Put(Var("arr"), Var("i"), Get(Var("arr"), Var("j"))), Let(("_", Var({val: None})), Put(Var("arr"), Var("j"), Var("tmp")), Unit)))}, LetRec({tyvars: [], name: ("partition", Int), args: [("arr", Array(Int)), ("low", Int), ("high", Int)], body: Let(("pivot", Var({val: None})), Get(Var("arr"), Var("high")), Let(("i", Var({val: None})), Array(Int(1), Prim(Var("low"), Int(1), Sub, kind=None)), LetRec({tyvars: [], name: ("l", Var({val: None})), args: [("j", Var({val: None}))], body: If(LE(Var("j"), Prim(Var("high"), Int(1), Sub, kind=None)), Let(("_", Var({val: None})), If(LE(Get(Var("arr"), Var("j")), Var("pivot")), Let(("_", Var({val: None})), Put(Var("i"), Int(0), Prim(Get(Var("i"), Int(0)), Int(1), Add, kind=None)), App(Var("swap"), [Var("arr"), Get(Var("i"), Int(0)), Var("j")])), Unit), App(Var("l"), [Prim(Var("j"), Int(1), Add, kind=None)])), Unit)}, Let(("_", Var({val: None})), App(Var("l"), [Var("low")]), Let(("_", Var({val: None})), Put(Var("i"), Int(0), Prim(Get(Var("i"), Int(0)), Int(1), Add, kind=None)), Let(("_", Var({val: None})), App(Var("swap"), [Var("arr"), Get(Var("i"), Int(0)), Var("high")]), Get(Var("i"), Int(0))))))))}, LetRec({tyvars: [], name: ("quicksort", Unit), args: [("arr", Array(Int)), ("low", Int), ("high", Int)], body: If(LE(Var("low"), Prim(Var("high"), Int(1), Sub, kind=None)), Let(("pi", Var({val: None})), App(Var("partition"), [Var("arr"), Var("low"), Var("high")]), Let(("_", Var({val: None})), App(Var("quicksort"), [Var("arr"), Var("low"), Prim(Var("pi"), Int(1), Sub, kind=None)]), App(Var("quicksort"), [Var("arr"), Prim(Var("pi"), Int(1), Add, kind=None), Var("high")]))), Unit)}, LetRec({tyvars: [], name: ("main", Var({val: None})), args: [], body: Let(("len", Var({val: None})), App(Var("read_int"), []), Let(("arr", Var({val: None})), Array(Var("len"), Int(0)), LetRec({tyvars: [], name: ("input", Var({val: None})), args: [("i", Int)], body: If(LE(Var("i"), Prim(Var("len"), Int(1), Sub, kind=None)), Let(("_", Var({val: None})), Put(Var("arr"), Var("i"), App(Var("read_int"), [])), App(Var("input"), [Prim(Var("i"), Int(1), Add, kind=None)])), Unit)}, Let(("_", Var({val: None})), App(Var("input"), [Int(0)]), Let(("_", Var({val: None})), App(Var("quicksort"), [Var("arr"), Int(0), Prim(Var("len"), Int(1), Sub, kind=None)]), LetRec({tyvars: [], name: ("output", Var({val: None})), args: [("i", Int)], body: If(LE(Var("i"), Prim(Var("len"), Int(1), Sub, kind=None)), Let(("_", Var({val: None})), App(Var("print_int"), [Get(Var("arr"), Var("i"))]), Let(("_", Var({val: None})), App(Var("print_endline"), []), App(Var("output"), [Prim(Var("i"), Int(1), Add, kind=None)]))), Unit)}, App(Var("output"), [Int(0)])))))))}, Unit)))) against Unit
// [Typer] typevars: []
// [Typer] check: Let(("tmp", Var({val: None})), Get(Var("arr"), Var("i")), Let(("_", Var({val: None})), Put(Var("arr"), Var("i"), Get(Var("arr"), Var("j"))), Let(("_", Var({val: None})), Put(Var("arr"), Var("j"), Var("tmp")), Unit))) against Unit
// [Typer] infer: Get(Var("arr"), Var("i"))
// [Typer] infer: Var("arr")
// [Typer] inst: TypeScheme(([], Array(Int)))
// [Typer] inst result: Array(Int)
// [Typer] check: Var("i") against Int
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] unify: Var({val: None}) and Int
// [Typer] union: Var({val: None}) and Int
// [Typer] check: Let(("_", Var({val: None})), Put(Var("arr"), Var("i"), Get(Var("arr"), Var("j"))), Let(("_", Var({val: None})), Put(Var("arr"), Var("j"), Var("tmp")), Unit)) against Unit
// [Typer] infer: Put(Var("arr"), Var("i"), Get(Var("arr"), Var("j")))
// [Typer] infer: Get(Var("arr"), Var("j"))
// [Typer] infer: Var("arr")
// [Typer] inst: TypeScheme(([], Array(Int)))
// [Typer] inst result: Array(Int)
// [Typer] check: Var("j") against Int
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] check: Var("arr") against Array(Int)
// [Typer] inst: TypeScheme(([], Array(Int)))
// [Typer] inst result: Array(Int)
// [Typer] unify: Array(Int) and Array(Int)
// [Typer] unify: Int and Int
// [Typer] check: Var("i") against Int
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] unify: Var({val: None}) and Unit
// [Typer] union: Var({val: None}) and Unit
// [Typer] check: Let(("_", Var({val: None})), Put(Var("arr"), Var("j"), Var("tmp")), Unit) against Unit
// [Typer] infer: Put(Var("arr"), Var("j"), Var("tmp"))
// [Typer] infer: Var("tmp")
// [Typer] inst: TypeScheme(([], Var({val: Some(Int)})))
// [Typer] inst result: Int
// [Typer] check: Var("arr") against Array(Int)
// [Typer] inst: TypeScheme(([], Array(Int)))
// [Typer] inst result: Array(Int)
// [Typer] unify: Array(Int) and Array(Int)
// [Typer] unify: Int and Int
// [Typer] check: Var("j") against Int
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] unify: Var({val: None}) and Unit
// [Typer] union: Var({val: None}) and Unit
// [Typer] check: Unit against Unit
// [Typer] check: LetRec({tyvars: [], name: ("partition", Int), args: [("arr", Array(Int)), ("low", Int), ("high", Int)], body: Let(("pivot", Var({val: None})), Get(Var("arr"), Var("high")), Let(("i", Var({val: None})), Array(Int(1), Prim(Var("low"), Int(1), Sub, kind=None)), LetRec({tyvars: [], name: ("l", Var({val: None})), args: [("j", Var({val: None}))], body: If(LE(Var("j"), Prim(Var("high"), Int(1), Sub, kind=None)), Let(("_", Var({val: None})), If(LE(Get(Var("arr"), Var("j")), Var("pivot")), Let(("_", Var({val: None})), Put(Var("i"), Int(0), Prim(Get(Var("i"), Int(0)), Int(1), Add, kind=None)), App(Var("swap"), [Var("arr"), Get(Var("i"), Int(0)), Var("j")])), Unit), App(Var("l"), [Prim(Var("j"), Int(1), Add, kind=None)])), Unit)}, Let(("_", Var({val: None})), App(Var("l"), [Var("low")]), Let(("_", Var({val: None})), Put(Var("i"), Int(0), Prim(Get(Var("i"), Int(0)), Int(1), Add, kind=None)), Let(("_", Var({val: None})), App(Var("swap"), [Var("arr"), Get(Var("i"), Int(0)), Var("high")]), Get(Var("i"), Int(0))))))))}, LetRec({tyvars: [], name: ("quicksort", Unit), args: [("arr", Array(Int)), ("low", Int), ("high", Int)], body: If(LE(Var("low"), Prim(Var("high"), Int(1), Sub, kind=None)), Let(("pi", Var({val: None})), App(Var("partition"), [Var("arr"), Var("low"), Var("high")]), Let(("_", Var({val: None})), App(Var("quicksort"), [Var("arr"), Var("low"), Prim(Var("pi"), Int(1), Sub, kind=None)]), App(Var("quicksort"), [Var("arr"), Prim(Var("pi"), Int(1), Add, kind=None), Var("high")]))), Unit)}, LetRec({tyvars: [], name: ("main", Var({val: None})), args: [], body: Let(("len", Var({val: None})), App(Var("read_int"), []), Let(("arr", Var({val: None})), Array(Var("len"), Int(0)), LetRec({tyvars: [], name: ("input", Var({val: None})), args: [("i", Int)], body: If(LE(Var("i"), Prim(Var("len"), Int(1), Sub, kind=None)), Let(("_", Var({val: None})), Put(Var("arr"), Var("i"), App(Var("read_int"), [])), App(Var("input"), [Prim(Var("i"), Int(1), Add, kind=None)])), Unit)}, Let(("_", Var({val: None})), App(Var("input"), [Int(0)]), Let(("_", Var({val: None})), App(Var("quicksort"), [Var("arr"), Int(0), Prim(Var("len"), Int(1), Sub, kind=None)]), LetRec({tyvars: [], name: ("output", Var({val: None})), args: [("i", Int)], body: If(LE(Var("i"), Prim(Var("len"), Int(1), Sub, kind=None)), Let(("_", Var({val: None})), App(Var("print_int"), [Get(Var("arr"), Var("i"))]), Let(("_", Var({val: None})), App(Var("print_endline"), []), App(Var("output"), [Prim(Var("i"), Int(1), Add, kind=None)]))), Unit)}, App(Var("output"), [Int(0)])))))))}, Unit))) against Unit
// [Typer] typevars: []
// [Typer] check: Let(("pivot", Var({val: None})), Get(Var("arr"), Var("high")), Let(("i", Var({val: None})), Array(Int(1), Prim(Var("low"), Int(1), Sub, kind=None)), LetRec({tyvars: [], name: ("l", Var({val: None})), args: [("j", Var({val: None}))], body: If(LE(Var("j"), Prim(Var("high"), Int(1), Sub, kind=None)), Let(("_", Var({val: None})), If(LE(Get(Var("arr"), Var("j")), Var("pivot")), Let(("_", Var({val: None})), Put(Var("i"), Int(0), Prim(Get(Var("i"), Int(0)), Int(1), Add, kind=None)), App(Var("swap"), [Var("arr"), Get(Var("i"), Int(0)), Var("j")])), Unit), App(Var("l"), [Prim(Var("j"), Int(1), Add, kind=None)])), Unit)}, Let(("_", Var({val: None})), App(Var("l"), [Var("low")]), Let(("_", Var({val: None})), Put(Var("i"), Int(0), Prim(Get(Var("i"), Int(0)), Int(1), Add, kind=None)), Let(("_", Var({val: None})), App(Var("swap"), [Var("arr"), Get(Var("i"), Int(0)), Var("high")]), Get(Var("i"), Int(0)))))))) against Int
// [Typer] infer: Get(Var("arr"), Var("high"))
// [Typer] infer: Var("arr")
// [Typer] inst: TypeScheme(([], Array(Int)))
// [Typer] inst result: Array(Int)
// [Typer] check: Var("high") against Int
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] unify: Var({val: None}) and Int
// [Typer] union: Var({val: None}) and Int
// [Typer] check: Let(("i", Var({val: None})), Array(Int(1), Prim(Var("low"), Int(1), Sub, kind=None)), LetRec({tyvars: [], name: ("l", Var({val: None})), args: [("j", Var({val: None}))], body: If(LE(Var("j"), Prim(Var("high"), Int(1), Sub, kind=None)), Let(("_", Var({val: None})), If(LE(Get(Var("arr"), Var("j")), Var("pivot")), Let(("_", Var({val: None})), Put(Var("i"), Int(0), Prim(Get(Var("i"), Int(0)), Int(1), Add, kind=None)), App(Var("swap"), [Var("arr"), Get(Var("i"), Int(0)), Var("j")])), Unit), App(Var("l"), [Prim(Var("j"), Int(1), Add, kind=None)])), Unit)}, Let(("_", Var({val: None})), App(Var("l"), [Var("low")]), Let(("_", Var({val: None})), Put(Var("i"), Int(0), Prim(Get(Var("i"), Int(0)), Int(1), Add, kind=None)), Let(("_", Var({val: None})), App(Var("swap"), [Var("arr"), Get(Var("i"), Int(0)), Var("high")]), Get(Var("i"), Int(0))))))) against Int
// [Typer] infer: Array(Int(1), Prim(Var("low"), Int(1), Sub, kind=None))
// [Typer] infer: Prim(Var("low"), Int(1), Sub, kind=None)
// [Typer] infer: Var("low")
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] infer: Int(1)
// [Typer] unify: Int and Int
// [Typer] check: Int(1) against Int
// [Typer] unify: Var({val: None}) and Array(Int)
// [Typer] union: Var({val: None}) and Array(Int)
// [Typer] check: LetRec({tyvars: [], name: ("l", Var({val: None})), args: [("j", Var({val: None}))], body: If(LE(Var("j"), Prim(Var("high"), Int(1), Sub, kind=None)), Let(("_", Var({val: None})), If(LE(Get(Var("arr"), Var("j")), Var("pivot")), Let(("_", Var({val: None})), Put(Var("i"), Int(0), Prim(Get(Var("i"), Int(0)), Int(1), Add, kind=None)), App(Var("swap"), [Var("arr"), Get(Var("i"), Int(0)), Var("j")])), Unit), App(Var("l"), [Prim(Var("j"), Int(1), Add, kind=None)])), Unit)}, Let(("_", Var({val: None})), App(Var("l"), [Var("low")]), Let(("_", Var({val: None})), Put(Var("i"), Int(0), Prim(Get(Var("i"), Int(0)), Int(1), Add, kind=None)), Let(("_", Var({val: None})), App(Var("swap"), [Var("arr"), Get(Var("i"), Int(0)), Var("high")]), Get(Var("i"), Int(0)))))) against Int
// [Typer] typevars: []
// [Typer] infer: If(LE(Var("j"), Prim(Var("high"), Int(1), Sub, kind=None)), Let(("_", Var({val: None})), If(LE(Get(Var("arr"), Var("j")), Var("pivot")), Let(("_", Var({val: None})), Put(Var("i"), Int(0), Prim(Get(Var("i"), Int(0)), Int(1), Add, kind=None)), App(Var("swap"), [Var("arr"), Get(Var("i"), Int(0)), Var("j")])), Unit), App(Var("l"), [Prim(Var("j"), Int(1), Add, kind=None)])), Unit)
// [Typer] check: LE(Var("j"), Prim(Var("high"), Int(1), Sub, kind=None)) against Bool
// [Typer] infer: Var("j")
// [Typer] inst: TypeScheme(([], Var({val: None})))
// [Typer] inst result: Var({val: None})
// [Typer] infer: Prim(Var("high"), Int(1), Sub, kind=None)
// [Typer] infer: Var("high")
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] infer: Int(1)
// [Typer] unify: Int and Int
// [Typer] unify: Var({val: None}) and Int
// [Typer] union: Var({val: None}) and Int
// [Typer] infer: Let(("_", Var({val: None})), If(LE(Get(Var("arr"), Var("j")), Var("pivot")), Let(("_", Var({val: None})), Put(Var("i"), Int(0), Prim(Get(Var("i"), Int(0)), Int(1), Add, kind=None)), App(Var("swap"), [Var("arr"), Get(Var("i"), Int(0)), Var("j")])), Unit), App(Var("l"), [Prim(Var("j"), Int(1), Add, kind=None)]))
// [Typer] infer: If(LE(Get(Var("arr"), Var("j")), Var("pivot")), Let(("_", Var({val: None})), Put(Var("i"), Int(0), Prim(Get(Var("i"), Int(0)), Int(1), Add, kind=None)), App(Var("swap"), [Var("arr"), Get(Var("i"), Int(0)), Var("j")])), Unit)
// [Typer] check: LE(Get(Var("arr"), Var("j")), Var("pivot")) against Bool
// [Typer] infer: Get(Var("arr"), Var("j"))
// [Typer] infer: Var("arr")
// [Typer] inst: TypeScheme(([], Array(Int)))
// [Typer] inst result: Array(Int)
// [Typer] check: Var("j") against Int
// [Typer] inst: TypeScheme(([], Var({val: Some(Int)})))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] infer: Var("pivot")
// [Typer] inst: TypeScheme(([], Var({val: Some(Int)})))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] infer: Let(("_", Var({val: None})), Put(Var("i"), Int(0), Prim(Get(Var("i"), Int(0)), Int(1), Add, kind=None)), App(Var("swap"), [Var("arr"), Get(Var("i"), Int(0)), Var("j")]))
// [Typer] infer: Put(Var("i"), Int(0), Prim(Get(Var("i"), Int(0)), Int(1), Add, kind=None))
// [Typer] infer: Prim(Get(Var("i"), Int(0)), Int(1), Add, kind=None)
// [Typer] infer: Get(Var("i"), Int(0))
// [Typer] infer: Var("i")
// [Typer] inst: TypeScheme(([], Var({val: Some(Array(Int))})))
// [Typer] inst result: Array(Int)
// [Typer] check: Int(0) against Int
// [Typer] infer: Int(1)
// [Typer] unify: Int and Int
// [Typer] check: Var("i") against Array(Int)
// [Typer] inst: TypeScheme(([], Var({val: Some(Array(Int))})))
// [Typer] inst result: Array(Int)
// [Typer] unify: Array(Int) and Array(Int)
// [Typer] unify: Int and Int
// [Typer] check: Int(0) against Int
// [Typer] unify: Var({val: None}) and Unit
// [Typer] union: Var({val: None}) and Unit
// [Typer] infer: App(Var("swap"), [Var("arr"), Get(Var("i"), Int(0)), Var("j")])
// [Typer] infer: Var("swap")
// [Typer] inst: TypeScheme(([], Fun([Array(Int), Int, Int], Unit)))
// [Typer] inst result: Fun([Array(Int), Int, Int], Unit)
// [Typer] check: Var("arr") against Array(Int)
// [Typer] inst: TypeScheme(([], Array(Int)))
// [Typer] inst result: Array(Int)
// [Typer] unify: Array(Int) and Array(Int)
// [Typer] unify: Int and Int
// [Typer] check: Get(Var("i"), Int(0)) against Int
// [Typer] check: Var("i") against Array(Int)
// [Typer] inst: TypeScheme(([], Var({val: Some(Array(Int))})))
// [Typer] inst result: Array(Int)
// [Typer] unify: Array(Int) and Array(Int)
// [Typer] unify: Int and Int
// [Typer] check: Int(0) against Int
// [Typer] check: Var("j") against Int
// [Typer] inst: TypeScheme(([], Var({val: Some(Int)})))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] infer: Unit
// [Typer] unify: Unit and Unit
// [Typer] unify: Var({val: None}) and Unit
// [Typer] union: Var({val: None}) and Unit
// [Typer] infer: App(Var("l"), [Prim(Var("j"), Int(1), Add, kind=None)])
// [Typer] infer: Var("l")
// [Typer] inst: TypeScheme(([], Fun([Var({val: Some(Int)})], Var({val: None}))))
// [Typer] inst result: Fun([Int], Var({val: None}))
// [Typer] check: Prim(Var("j"), Int(1), Add, kind=None) against Int
// [Typer] check: Var("j") against Int
// [Typer] inst: TypeScheme(([], Var({val: Some(Int)})))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] check: Int(1) against Int
// [Typer] infer: Unit
// [Typer] unify: Var({val: None}) and Unit
// [Typer] union: Var({val: None}) and Unit
// [Typer] unify: Unit and Var({val: Some(Unit)})
// [Typer] check: Let(("_", Var({val: None})), App(Var("l"), [Var("low")]), Let(("_", Var({val: None})), Put(Var("i"), Int(0), Prim(Get(Var("i"), Int(0)), Int(1), Add, kind=None)), Let(("_", Var({val: None})), App(Var("swap"), [Var("arr"), Get(Var("i"), Int(0)), Var("high")]), Get(Var("i"), Int(0))))) against Int
// [Typer] infer: App(Var("l"), [Var("low")])
// [Typer] infer: Var("l")
// [Typer] inst: TypeScheme(([], Fun([Var({val: Some(Int)})], Var({val: Some(Unit)}))))
// [Typer] inst result: Fun([Int], Unit)
// [Typer] check: Var("low") against Int
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] unify: Var({val: None}) and Unit
// [Typer] union: Var({val: None}) and Unit
// [Typer] check: Let(("_", Var({val: None})), Put(Var("i"), Int(0), Prim(Get(Var("i"), Int(0)), Int(1), Add, kind=None)), Let(("_", Var({val: None})), App(Var("swap"), [Var("arr"), Get(Var("i"), Int(0)), Var("high")]), Get(Var("i"), Int(0)))) against Int
// [Typer] infer: Put(Var("i"), Int(0), Prim(Get(Var("i"), Int(0)), Int(1), Add, kind=None))
// [Typer] infer: Prim(Get(Var("i"), Int(0)), Int(1), Add, kind=None)
// [Typer] infer: Get(Var("i"), Int(0))
// [Typer] infer: Var("i")
// [Typer] inst: TypeScheme(([], Var({val: Some(Array(Int))})))
// [Typer] inst result: Array(Int)
// [Typer] check: Int(0) against Int
// [Typer] infer: Int(1)
// [Typer] unify: Int and Int
// [Typer] check: Var("i") against Array(Int)
// [Typer] inst: TypeScheme(([], Var({val: Some(Array(Int))})))
// [Typer] inst result: Array(Int)
// [Typer] unify: Array(Int) and Array(Int)
// [Typer] unify: Int and Int
// [Typer] check: Int(0) against Int
// [Typer] unify: Var({val: None}) and Unit
// [Typer] union: Var({val: None}) and Unit
// [Typer] check: Let(("_", Var({val: None})), App(Var("swap"), [Var("arr"), Get(Var("i"), Int(0)), Var("high")]), Get(Var("i"), Int(0))) against Int
// [Typer] infer: App(Var("swap"), [Var("arr"), Get(Var("i"), Int(0)), Var("high")])
// [Typer] infer: Var("swap")
// [Typer] inst: TypeScheme(([], Fun([Array(Int), Int, Int], Unit)))
// [Typer] inst result: Fun([Array(Int), Int, Int], Unit)
// [Typer] check: Var("arr") against Array(Int)
// [Typer] inst: TypeScheme(([], Array(Int)))
// [Typer] inst result: Array(Int)
// [Typer] unify: Array(Int) and Array(Int)
// [Typer] unify: Int and Int
// [Typer] check: Get(Var("i"), Int(0)) against Int
// [Typer] check: Var("i") against Array(Int)
// [Typer] inst: TypeScheme(([], Var({val: Some(Array(Int))})))
// [Typer] inst result: Array(Int)
// [Typer] unify: Array(Int) and Array(Int)
// [Typer] unify: Int and Int
// [Typer] check: Int(0) against Int
// [Typer] check: Var("high") against Int
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] unify: Var({val: None}) and Unit
// [Typer] union: Var({val: None}) and Unit
// [Typer] check: Get(Var("i"), Int(0)) against Int
// [Typer] check: Var("i") against Array(Int)
// [Typer] inst: TypeScheme(([], Var({val: Some(Array(Int))})))
// [Typer] inst result: Array(Int)
// [Typer] unify: Array(Int) and Array(Int)
// [Typer] unify: Int and Int
// [Typer] check: Int(0) against Int
// [Typer] check: LetRec({tyvars: [], name: ("quicksort", Unit), args: [("arr", Array(Int)), ("low", Int), ("high", Int)], body: If(LE(Var("low"), Prim(Var("high"), Int(1), Sub, kind=None)), Let(("pi", Var({val: None})), App(Var("partition"), [Var("arr"), Var("low"), Var("high")]), Let(("_", Var({val: None})), App(Var("quicksort"), [Var("arr"), Var("low"), Prim(Var("pi"), Int(1), Sub, kind=None)]), App(Var("quicksort"), [Var("arr"), Prim(Var("pi"), Int(1), Add, kind=None), Var("high")]))), Unit)}, LetRec({tyvars: [], name: ("main", Var({val: None})), args: [], body: Let(("len", Var({val: None})), App(Var("read_int"), []), Let(("arr", Var({val: None})), Array(Var("len"), Int(0)), LetRec({tyvars: [], name: ("input", Var({val: None})), args: [("i", Int)], body: If(LE(Var("i"), Prim(Var("len"), Int(1), Sub, kind=None)), Let(("_", Var({val: None})), Put(Var("arr"), Var("i"), App(Var("read_int"), [])), App(Var("input"), [Prim(Var("i"), Int(1), Add, kind=None)])), Unit)}, Let(("_", Var({val: None})), App(Var("input"), [Int(0)]), Let(("_", Var({val: None})), App(Var("quicksort"), [Var("arr"), Int(0), Prim(Var("len"), Int(1), Sub, kind=None)]), LetRec({tyvars: [], name: ("output", Var({val: None})), args: [("i", Int)], body: If(LE(Var("i"), Prim(Var("len"), Int(1), Sub, kind=None)), Let(("_", Var({val: None})), App(Var("print_int"), [Get(Var("arr"), Var("i"))]), Let(("_", Var({val: None})), App(Var("print_endline"), []), App(Var("output"), [Prim(Var("i"), Int(1), Add, kind=None)]))), Unit)}, App(Var("output"), [Int(0)])))))))}, Unit)) against Unit
// [Typer] typevars: []
// [Typer] check: If(LE(Var("low"), Prim(Var("high"), Int(1), Sub, kind=None)), Let(("pi", Var({val: None})), App(Var("partition"), [Var("arr"), Var("low"), Var("high")]), Let(("_", Var({val: None})), App(Var("quicksort"), [Var("arr"), Var("low"), Prim(Var("pi"), Int(1), Sub, kind=None)]), App(Var("quicksort"), [Var("arr"), Prim(Var("pi"), Int(1), Add, kind=None), Var("high")]))), Unit) against Unit
// [Typer] check: LE(Var("low"), Prim(Var("high"), Int(1), Sub, kind=None)) against Bool
// [Typer] infer: Var("low")
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] infer: Prim(Var("high"), Int(1), Sub, kind=None)
// [Typer] infer: Var("high")
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] infer: Int(1)
// [Typer] unify: Int and Int
// [Typer] unify: Int and Int
// [Typer] check: Let(("pi", Var({val: None})), App(Var("partition"), [Var("arr"), Var("low"), Var("high")]), Let(("_", Var({val: None})), App(Var("quicksort"), [Var("arr"), Var("low"), Prim(Var("pi"), Int(1), Sub, kind=None)]), App(Var("quicksort"), [Var("arr"), Prim(Var("pi"), Int(1), Add, kind=None), Var("high")]))) against Unit
// [Typer] infer: App(Var("partition"), [Var("arr"), Var("low"), Var("high")])
// [Typer] infer: Var("partition")
// [Typer] inst: TypeScheme(([], Fun([Array(Int), Int, Int], Int)))
// [Typer] inst result: Fun([Array(Int), Int, Int], Int)
// [Typer] check: Var("arr") against Array(Int)
// [Typer] inst: TypeScheme(([], Array(Int)))
// [Typer] inst result: Array(Int)
// [Typer] unify: Array(Int) and Array(Int)
// [Typer] unify: Int and Int
// [Typer] check: Var("low") against Int
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] check: Var("high") against Int
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] unify: Var({val: None}) and Int
// [Typer] union: Var({val: None}) and Int
// [Typer] check: Let(("_", Var({val: None})), App(Var("quicksort"), [Var("arr"), Var("low"), Prim(Var("pi"), Int(1), Sub, kind=None)]), App(Var("quicksort"), [Var("arr"), Prim(Var("pi"), Int(1), Add, kind=None), Var("high")])) against Unit
// [Typer] infer: App(Var("quicksort"), [Var("arr"), Var("low"), Prim(Var("pi"), Int(1), Sub, kind=None)])
// [Typer] infer: Var("quicksort")
// [Typer] inst: TypeScheme(([], Fun([Array(Int), Int, Int], Unit)))
// [Typer] inst result: Fun([Array(Int), Int, Int], Unit)
// [Typer] check: Var("arr") against Array(Int)
// [Typer] inst: TypeScheme(([], Array(Int)))
// [Typer] inst result: Array(Int)
// [Typer] unify: Array(Int) and Array(Int)
// [Typer] unify: Int and Int
// [Typer] check: Var("low") against Int
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] check: Prim(Var("pi"), Int(1), Sub, kind=None) against Int
// [Typer] check: Var("pi") against Int
// [Typer] inst: TypeScheme(([], Var({val: Some(Int)})))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] check: Int(1) against Int
// [Typer] unify: Var({val: None}) and Unit
// [Typer] union: Var({val: None}) and Unit
// [Typer] check: App(Var("quicksort"), [Var("arr"), Prim(Var("pi"), Int(1), Add, kind=None), Var("high")]) against Unit
// [Typer] infer: Var("arr")
// [Typer] inst: TypeScheme(([], Array(Int)))
// [Typer] inst result: Array(Int)
// [Typer] infer: Prim(Var("pi"), Int(1), Add, kind=None)
// [Typer] infer: Var("pi")
// [Typer] inst: TypeScheme(([], Var({val: Some(Int)})))
// [Typer] inst result: Int
// [Typer] infer: Int(1)
// [Typer] unify: Int and Int
// [Typer] infer: Var("high")
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] check: Var("quicksort") against Fun([Array(Int), Int, Int], Unit)
// [Typer] inst: TypeScheme(([], Fun([Array(Int), Int, Int], Unit)))
// [Typer] inst result: Fun([Array(Int), Int, Int], Unit)
// [Typer] unify: Fun([Array(Int), Int, Int], Unit) and Fun([Array(Int), Int, Int], Unit)
// [Typer] unify: Array(Int) and Array(Int)
// [Typer] unify: Int and Int
// [Typer] unify: Int and Int
// [Typer] unify: Int and Int
// [Typer] unify: Unit and Unit
// [Typer] check: Unit against Unit
// [Typer] check: LetRec({tyvars: [], name: ("main", Var({val: None})), args: [], body: Let(("len", Var({val: None})), App(Var("read_int"), []), Let(("arr", Var({val: None})), Array(Var("len"), Int(0)), LetRec({tyvars: [], name: ("input", Var({val: None})), args: [("i", Int)], body: If(LE(Var("i"), Prim(Var("len"), Int(1), Sub, kind=None)), Let(("_", Var({val: None})), Put(Var("arr"), Var("i"), App(Var("read_int"), [])), App(Var("input"), [Prim(Var("i"), Int(1), Add, kind=None)])), Unit)}, Let(("_", Var({val: None})), App(Var("input"), [Int(0)]), Let(("_", Var({val: None})), App(Var("quicksort"), [Var("arr"), Int(0), Prim(Var("len"), Int(1), Sub, kind=None)]), LetRec({tyvars: [], name: ("output", Var({val: None})), args: [("i", Int)], body: If(LE(Var("i"), Prim(Var("len"), Int(1), Sub, kind=None)), Let(("_", Var({val: None})), App(Var("print_int"), [Get(Var("arr"), Var("i"))]), Let(("_", Var({val: None})), App(Var("print_endline"), []), App(Var("output"), [Prim(Var("i"), Int(1), Add, kind=None)]))), Unit)}, App(Var("output"), [Int(0)])))))))}, Unit) against Unit
// [Typer] typevars: []
// [Typer] infer: Let(("len", Var({val: None})), App(Var("read_int"), []), Let(("arr", Var({val: None})), Array(Var("len"), Int(0)), LetRec({tyvars: [], name: ("input", Var({val: None})), args: [("i", Int)], body: If(LE(Var("i"), Prim(Var("len"), Int(1), Sub, kind=None)), Let(("_", Var({val: None})), Put(Var("arr"), Var("i"), App(Var("read_int"), [])), App(Var("input"), [Prim(Var("i"), Int(1), Add, kind=None)])), Unit)}, Let(("_", Var({val: None})), App(Var("input"), [Int(0)]), Let(("_", Var({val: None})), App(Var("quicksort"), [Var("arr"), Int(0), Prim(Var("len"), Int(1), Sub, kind=None)]), LetRec({tyvars: [], name: ("output", Var({val: None})), args: [("i", Int)], body: If(LE(Var("i"), Prim(Var("len"), Int(1), Sub, kind=None)), Let(("_", Var({val: None})), App(Var("print_int"), [Get(Var("arr"), Var("i"))]), Let(("_", Var({val: None})), App(Var("print_endline"), []), App(Var("output"), [Prim(Var("i"), Int(1), Add, kind=None)]))), Unit)}, App(Var("output"), [Int(0)])))))))
// [Typer] infer: App(Var("read_int"), [])
// [Typer] infer: Var("read_int")
// [Typer] inst: TypeScheme(([], Fun([], Int)))
// [Typer] inst result: Fun([], Int)
// [Typer] unify: Var({val: None}) and Int
// [Typer] union: Var({val: None}) and Int
// [Typer] infer: Let(("arr", Var({val: None})), Array(Var("len"), Int(0)), LetRec({tyvars: [], name: ("input", Var({val: None})), args: [("i", Int)], body: If(LE(Var("i"), Prim(Var("len"), Int(1), Sub, kind=None)), Let(("_", Var({val: None})), Put(Var("arr"), Var("i"), App(Var("read_int"), [])), App(Var("input"), [Prim(Var("i"), Int(1), Add, kind=None)])), Unit)}, Let(("_", Var({val: None})), App(Var("input"), [Int(0)]), Let(("_", Var({val: None})), App(Var("quicksort"), [Var("arr"), Int(0), Prim(Var("len"), Int(1), Sub, kind=None)]), LetRec({tyvars: [], name: ("output", Var({val: None})), args: [("i", Int)], body: If(LE(Var("i"), Prim(Var("len"), Int(1), Sub, kind=None)), Let(("_", Var({val: None})), App(Var("print_int"), [Get(Var("arr"), Var("i"))]), Let(("_", Var({val: None})), App(Var("print_endline"), []), App(Var("output"), [Prim(Var("i"), Int(1), Add, kind=None)]))), Unit)}, App(Var("output"), [Int(0)]))))))
// [Typer] infer: Array(Var("len"), Int(0))
// [Typer] infer: Int(0)
// [Typer] check: Var("len") against Int
// [Typer] inst: TypeScheme(([], Var({val: Some(Int)})))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] unify: Var({val: None}) and Array(Int)
// [Typer] union: Var({val: None}) and Array(Int)
// [Typer] infer: LetRec({tyvars: [], name: ("input", Var({val: None})), args: [("i", Int)], body: If(LE(Var("i"), Prim(Var("len"), Int(1), Sub, kind=None)), Let(("_", Var({val: None})), Put(Var("arr"), Var("i"), App(Var("read_int"), [])), App(Var("input"), [Prim(Var("i"), Int(1), Add, kind=None)])), Unit)}, Let(("_", Var({val: None})), App(Var("input"), [Int(0)]), Let(("_", Var({val: None})), App(Var("quicksort"), [Var("arr"), Int(0), Prim(Var("len"), Int(1), Sub, kind=None)]), LetRec({tyvars: [], name: ("output", Var({val: None})), args: [("i", Int)], body: If(LE(Var("i"), Prim(Var("len"), Int(1), Sub, kind=None)), Let(("_", Var({val: None})), App(Var("print_int"), [Get(Var("arr"), Var("i"))]), Let(("_", Var({val: None})), App(Var("print_endline"), []), App(Var("output"), [Prim(Var("i"), Int(1), Add, kind=None)]))), Unit)}, App(Var("output"), [Int(0)])))))
// [Typer] typevars: []
// [Typer] infer: If(LE(Var("i"), Prim(Var("len"), Int(1), Sub, kind=None)), Let(("_", Var({val: None})), Put(Var("arr"), Var("i"), App(Var("read_int"), [])), App(Var("input"), [Prim(Var("i"), Int(1), Add, kind=None)])), Unit)
// [Typer] check: LE(Var("i"), Prim(Var("len"), Int(1), Sub, kind=None)) against Bool
// [Typer] infer: Var("i")
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] infer: Prim(Var("len"), Int(1), Sub, kind=None)
// [Typer] infer: Var("len")
// [Typer] inst: TypeScheme(([], Var({val: Some(Int)})))
// [Typer] inst result: Int
// [Typer] infer: Int(1)
// [Typer] unify: Int and Int
// [Typer] unify: Int and Int
// [Typer] infer: Let(("_", Var({val: None})), Put(Var("arr"), Var("i"), App(Var("read_int"), [])), App(Var("input"), [Prim(Var("i"), Int(1), Add, kind=None)]))
// [Typer] infer: Put(Var("arr"), Var("i"), App(Var("read_int"), []))
// [Typer] infer: App(Var("read_int"), [])
// [Typer] infer: Var("read_int")
// [Typer] inst: TypeScheme(([], Fun([], Int)))
// [Typer] inst result: Fun([], Int)
// [Typer] check: Var("arr") against Array(Int)
// [Typer] inst: TypeScheme(([], Var({val: Some(Array(Int))})))
// [Typer] inst result: Array(Int)
// [Typer] unify: Array(Int) and Array(Int)
// [Typer] unify: Int and Int
// [Typer] check: Var("i") against Int
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] unify: Var({val: None}) and Unit
// [Typer] union: Var({val: None}) and Unit
// [Typer] infer: App(Var("input"), [Prim(Var("i"), Int(1), Add, kind=None)])
// [Typer] infer: Var("input")
// [Typer] inst: TypeScheme(([], Fun([Int], Var({val: None}))))
// [Typer] inst result: Fun([Int], Var({val: None}))
// [Typer] check: Prim(Var("i"), Int(1), Add, kind=None) against Int
// [Typer] check: Var("i") against Int
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] check: Int(1) against Int
// [Typer] infer: Unit
// [Typer] unify: Var({val: None}) and Unit
// [Typer] union: Var({val: None}) and Unit
// [Typer] unify: Unit and Var({val: Some(Unit)})
// [Typer] infer: Let(("_", Var({val: None})), App(Var("input"), [Int(0)]), Let(("_", Var({val: None})), App(Var("quicksort"), [Var("arr"), Int(0), Prim(Var("len"), Int(1), Sub, kind=None)]), LetRec({tyvars: [], name: ("output", Var({val: None})), args: [("i", Int)], body: If(LE(Var("i"), Prim(Var("len"), Int(1), Sub, kind=None)), Let(("_", Var({val: None})), App(Var("print_int"), [Get(Var("arr"), Var("i"))]), Let(("_", Var({val: None})), App(Var("print_endline"), []), App(Var("output"), [Prim(Var("i"), Int(1), Add, kind=None)]))), Unit)}, App(Var("output"), [Int(0)]))))
// [Typer] infer: App(Var("input"), [Int(0)])
// [Typer] infer: Var("input")
// [Typer] inst: TypeScheme(([], Fun([Int], Var({val: Some(Unit)}))))
// [Typer] inst result: Fun([Int], Unit)
// [Typer] check: Int(0) against Int
// [Typer] unify: Var({val: None}) and Unit
// [Typer] union: Var({val: None}) and Unit
// [Typer] infer: Let(("_", Var({val: None})), App(Var("quicksort"), [Var("arr"), Int(0), Prim(Var("len"), Int(1), Sub, kind=None)]), LetRec({tyvars: [], name: ("output", Var({val: None})), args: [("i", Int)], body: If(LE(Var("i"), Prim(Var("len"), Int(1), Sub, kind=None)), Let(("_", Var({val: None})), App(Var("print_int"), [Get(Var("arr"), Var("i"))]), Let(("_", Var({val: None})), App(Var("print_endline"), []), App(Var("output"), [Prim(Var("i"), Int(1), Add, kind=None)]))), Unit)}, App(Var("output"), [Int(0)])))
// [Typer] infer: App(Var("quicksort"), [Var("arr"), Int(0), Prim(Var("len"), Int(1), Sub, kind=None)])
// [Typer] infer: Var("quicksort")
// [Typer] inst: TypeScheme(([], Fun([Array(Int), Int, Int], Unit)))
// [Typer] inst result: Fun([Array(Int), Int, Int], Unit)
// [Typer] check: Var("arr") against Array(Int)
// [Typer] inst: TypeScheme(([], Var({val: Some(Array(Int))})))
// [Typer] inst result: Array(Int)
// [Typer] unify: Array(Int) and Array(Int)
// [Typer] unify: Int and Int
// [Typer] check: Int(0) against Int
// [Typer] check: Prim(Var("len"), Int(1), Sub, kind=None) against Int
// [Typer] check: Var("len") against Int
// [Typer] inst: TypeScheme(([], Var({val: Some(Int)})))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] check: Int(1) against Int
// [Typer] unify: Var({val: None}) and Unit
// [Typer] union: Var({val: None}) and Unit
// [Typer] infer: LetRec({tyvars: [], name: ("output", Var({val: None})), args: [("i", Int)], body: If(LE(Var("i"), Prim(Var("len"), Int(1), Sub, kind=None)), Let(("_", Var({val: None})), App(Var("print_int"), [Get(Var("arr"), Var("i"))]), Let(("_", Var({val: None})), App(Var("print_endline"), []), App(Var("output"), [Prim(Var("i"), Int(1), Add, kind=None)]))), Unit)}, App(Var("output"), [Int(0)]))
// [Typer] typevars: []
// [Typer] infer: If(LE(Var("i"), Prim(Var("len"), Int(1), Sub, kind=None)), Let(("_", Var({val: None})), App(Var("print_int"), [Get(Var("arr"), Var("i"))]), Let(("_", Var({val: None})), App(Var("print_endline"), []), App(Var("output"), [Prim(Var("i"), Int(1), Add, kind=None)]))), Unit)
// [Typer] check: LE(Var("i"), Prim(Var("len"), Int(1), Sub, kind=None)) against Bool
// [Typer] infer: Var("i")
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] infer: Prim(Var("len"), Int(1), Sub, kind=None)
// [Typer] infer: Var("len")
// [Typer] inst: TypeScheme(([], Var({val: Some(Int)})))
// [Typer] inst result: Int
// [Typer] infer: Int(1)
// [Typer] unify: Int and Int
// [Typer] unify: Int and Int
// [Typer] infer: Let(("_", Var({val: None})), App(Var("print_int"), [Get(Var("arr"), Var("i"))]), Let(("_", Var({val: None})), App(Var("print_endline"), []), App(Var("output"), [Prim(Var("i"), Int(1), Add, kind=None)])))
// [Typer] infer: App(Var("print_int"), [Get(Var("arr"), Var("i"))])
// [Typer] infer: Var("print_int")
// [Typer] inst: TypeScheme(([], Fun([Int], Unit)))
// [Typer] inst result: Fun([Int], Unit)
// [Typer] check: Get(Var("arr"), Var("i")) against Int
// [Typer] check: Var("arr") against Array(Int)
// [Typer] inst: TypeScheme(([], Var({val: Some(Array(Int))})))
// [Typer] inst result: Array(Int)
// [Typer] unify: Array(Int) and Array(Int)
// [Typer] unify: Int and Int
// [Typer] check: Var("i") against Int
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] unify: Var({val: None}) and Unit
// [Typer] union: Var({val: None}) and Unit
// [Typer] infer: Let(("_", Var({val: None})), App(Var("print_endline"), []), App(Var("output"), [Prim(Var("i"), Int(1), Add, kind=None)]))
// [Typer] infer: App(Var("print_endline"), [])
// [Typer] infer: Var("print_endline")
// [Typer] inst: TypeScheme(([], Fun([], Unit)))
// [Typer] inst result: Fun([], Unit)
// [Typer] unify: Var({val: None}) and Unit
// [Typer] union: Var({val: None}) and Unit
// [Typer] infer: App(Var("output"), [Prim(Var("i"), Int(1), Add, kind=None)])
// [Typer] infer: Var("output")
// [Typer] inst: TypeScheme(([], Fun([Int], Var({val: None}))))
// [Typer] inst result: Fun([Int], Var({val: None}))
// [Typer] check: Prim(Var("i"), Int(1), Add, kind=None) against Int
// [Typer] check: Var("i") against Int
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] check: Int(1) against Int
// [Typer] infer: Unit
// [Typer] unify: Var({val: None}) and Unit
// [Typer] union: Var({val: None}) and Unit
// [Typer] unify: Unit and Var({val: Some(Unit)})
// [Typer] infer: App(Var("output"), [Int(0)])
// [Typer] infer: Var("output")
// [Typer] inst: TypeScheme(([], Fun([Int], Var({val: Some(Unit)}))))
// [Typer] inst result: Fun([Int], Unit)
// [Typer] check: Int(0) against Int
// [Typer] unify: Unit and Var({val: None})
// [Typer] union: Unit and Var({val: None})
// [Typer] check: Unit against Unit
// [Parser] flags: []
