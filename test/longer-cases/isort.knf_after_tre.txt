let rec random.1: Int = (state.2: Int) {
  let _3: Int = Int(75)
  let _4: Int = Mul(state.2, _3)
  let _5: Int = Int(74)
  Add(_4, _5)
}
let rec modulo.6: Int = (x.7: Int, y.8: Int) {
  let q.9: Int = Div(x.7, y.8)
  let _10: Int = Mul(q.9, y.8)
  Sub(x.7, _10)
}
let rec fill_buffer.11: Unit = (arr.12: Array(Int), n.13: Int) {
  let rec aux.14: Unit = (i.15: Int, state.16: Int) {
    let join aux.70: Unit = (i.71: Int, state.72: Int) {
      if (i.71 == n.13) then {
        Unit
      } else {
        let new_state.73: Int = Apply(random.1, [state.72, ])
        let _74: Int = Int(65537)
        let res.75: Int = Apply(modulo.6, [new_state.73, _74, ])
        let _76: Unit = Put arr.12[i.71] = res.75
        let _77: Int = Int(1)
        let _78: Int = Add(i.71, _77)
        Jump(aux.70, [_78, res.75, ])
      }
    }
    Jump(aux.70, [i.15, state.16, ])
  }
  let _23: Int = Int(0)
  let _24: Int = Int(12345)
  Apply(aux.14, [_23, _24, ])
}
let rec isort.25: Unit = (arr.26: Array(Int), n.27: Int) {
  let rec insert.28: Unit = (arr.29: Array(Int), i.30: Int) {
    let join insert.79: Unit = (arr.80: Array(Int), i.81: Int) {
      let _82: Int = Int(0)
      if (i.81 == _82) then {
        Unit
      } else {
        let _83: Int = Int(1)
        let _84: Int = Sub(i.81, _83)
        let _85: Int = Get arr.80[_84]
        let _86: Int = Get arr.80[i.81]
        if (_85 <= _86) then {
          Unit
        } else {
          let tmp.87: Int = Get arr.80[i.81]
          let _88: Int = Int(1)
          let _89: Int = Sub(i.81, _88)
          let _90: Int = Get arr.80[_89]
          let _91: Unit = Put arr.80[i.81] = _90
          let _92: Int = Int(1)
          let _93: Int = Sub(i.81, _92)
          let _94: Unit = Put arr.80[_93] = tmp.87
          let _95: Int = Int(1)
          let _96: Int = Sub(i.81, _95)
          Jump(insert.79, [arr.80, _96, ])
        }
      }
    }
    Jump(insert.79, [arr.29, i.30, ])
  }
  let rec aux.46: Unit = (i.47: Int) {
    let join aux.97: Unit = (i.98: Int) {
      if (i.98 == n.27) then {
        Unit
      } else {
        let _99: Unit = Apply(insert.28, [arr.26, i.98, ])
        let _100: Int = Int(1)
        let _101: Int = Add(i.98, _100)
        Jump(aux.97, [_101, ])
      }
    }
    Jump(aux.97, [i.47, ])
  }
  let _51: Int = Int(1)
  Apply(aux.46, [_51, ])
}
let rec print_array.52: Unit = (arr.53: Array(Int), n.54: Int) {
  let rec aux.55: Unit = (i.56: Int) {
    let join aux.102: Unit = (i.103: Int) {
      if (i.103 == n.54) then {
        Unit
      } else {
        let _104: Int = Get arr.53[i.103]
        let _105: Unit = ExtApply(minimbt_print_int, [_104, ])
        let _106: Int = Int(32)
        let _107: Unit = ExtApply(minimbt_print_char, [_106, ])
        let _108: Int = Int(1)
        let _109: Int = Add(i.103, _108)
        Jump(aux.102, [_109, ])
      }
    }
    Jump(aux.102, [i.56, ])
  }
  let _63: Int = Int(0)
  Apply(aux.55, [_63, ])
}
let rec main.64: Var({val: Some(Unit)}) = () {
  let n.65: Int = Int(100)
  let _66: Int = Int(0)
  let arr.67: Array(Int) = ExtApply(minimbt_create_array, [n.65, _66, ])
  let _68: Unit = Apply(fill_buffer.11, [arr.67, n.65, ])
  let _69: Unit = Apply(isort.25, [arr.67, n.65, ])
  Apply(print_array.52, [arr.67, n.65, ])
}
Apply(main.64, [])