// [Main] function thunk_main(k) {
// [Main]   function read_ch_until_newline_or_eof_1(k) {
// [Main]     const c_2 = minimbt_read_char();
// [Main]     const _3 = 10;
// [Main]     if (c_2 === _3) {
// [Main]       return k(-1)
// [Main]     } else {
// [Main]       const _4 = 13;
// [Main]       if (c_2 === _4) {
// [Main]         return k(-1)
// [Main]       } else {
// [Main]         return k(c_2)
// [Main]       }
// [Main]     }
// [Main]   }
// [Main]   const move_left_5 = 60;
// [Main]   const move_right_6 = 62;
// [Main]   const increase_7 = 43;
// [Main]   const decrease_8 = 45;
// [Main]   const print_9 = 46;
// [Main]   const read_10 = 44;
// [Main]   const loop_start_11 = 91;
// [Main]   const loop_end_12 = 93;
// [Main]   function bf_13(len_15, prog_17, k) {
// [Main]     const _18 = 1;
// [Main]     const _19 = 0;
// [Main]     const ptr_20 = minimbt_create_array($force(_18), $force(_19));
// [Main]     const _21 = 1024;
// [Main]     const _22 = 1024;
// [Main]     const _23 = _21 * _22;
// [Main]     const _24 = 0;
// [Main]     const cells_25 = minimbt_create_array($force(_23), $force(_24));
// [Main]     const _26 = 1;
// [Main]     const _27 = 0;
// [Main]     const next_pc_28 = minimbt_create_array($force(_26), $force(_27));
// [Main]     function skip_29(pc_31, level_33, k) {
// [Main]       if (len_15 <= pc_31) {
// [Main]         return k(pc_31)
// [Main]       } else {
// [Main]         const i_34 = prog_17[pc_31];
// [Main]         if (i_34 === loop_start_11) {
// [Main]           const _35 = 1;
// [Main]           const _36 = pc_31 + _35;
// [Main]           const _37 = 1;
// [Main]           const _38 = level_33 + _37;
// [Main]           return $thunk(() => skip_29(_36, _38, k))
// [Main]         } else {
// [Main]           if (i_34 === loop_end_12) {
// [Main]             const _39 = 0;
// [Main]             if (level_33 === _39) {
// [Main]               return k(pc_31)
// [Main]             } else {
// [Main]               const _40 = 1;
// [Main]               const _41 = pc_31 + _40;
// [Main]               const _42 = 1;
// [Main]               const _43 = level_33 - _42;
// [Main]               return $thunk(() => skip_29(_41, _43, k))
// [Main]             }
// [Main]           } else {
// [Main]             const _44 = 1;
// [Main]             const _45 = pc_31 + _44;
// [Main]             return $thunk(() => skip_29(_45, level_33, k))
// [Main]           }
// [Main]         }
// [Main]       }
// [Main]     }
// [Main]     function aux_46(pc_48, k) {
// [Main]       if (len_15 <= pc_48) {
// [Main]         return k(pc_48)
// [Main]       } else {
// [Main]         const i_49 = prog_17[pc_48];
// [Main]         if (i_49 === move_right_6) {
// [Main]           const _50 = 0;
// [Main]           const _51 = 0;
// [Main]           const _52 = ptr_20[_51];
// [Main]           const _53 = 1;
// [Main]           const _54 = _52 + _53;
// [Main]           const _56 = ptr_20[_50] = _54;
// [Main]           const _57 = 1;
// [Main]           const _58 = pc_48 + _57;
// [Main]           return $thunk(() => aux_46(_58, k))
// [Main]         } else {
// [Main]           if (i_49 === move_left_5) {
// [Main]             const _59 = 0;
// [Main]             const _60 = 0;
// [Main]             const _61 = ptr_20[_60];
// [Main]             const _62 = 1;
// [Main]             const _63 = _61 - _62;
// [Main]             const _65 = ptr_20[_59] = _63;
// [Main]             const _66 = 1;
// [Main]             const _67 = pc_48 + _66;
// [Main]             return $thunk(() => aux_46(_67, k))
// [Main]           } else {
// [Main]             if (i_49 === increase_7) {
// [Main]               const _68 = 0;
// [Main]               const _69 = ptr_20[_68];
// [Main]               const _70 = 0;
// [Main]               const _71 = ptr_20[_70];
// [Main]               const _72 = cells_25[_71];
// [Main]               const _73 = 1;
// [Main]               const _74 = _72 + _73;
// [Main]               const _76 = cells_25[_69] = _74;
// [Main]               const _77 = 1;
// [Main]               const _78 = pc_48 + _77;
// [Main]               return $thunk(() => aux_46(_78, k))
// [Main]             } else {
// [Main]               if (i_49 === decrease_8) {
// [Main]                 const _79 = 0;
// [Main]                 const _80 = ptr_20[_79];
// [Main]                 const _81 = 0;
// [Main]                 const _82 = ptr_20[_81];
// [Main]                 const _83 = cells_25[_82];
// [Main]                 const _84 = 1;
// [Main]                 const _85 = _83 - _84;
// [Main]                 const _87 = cells_25[_80] = _85;
// [Main]                 const _88 = 1;
// [Main]                 const _89 = pc_48 + _88;
// [Main]                 return $thunk(() => aux_46(_89, k))
// [Main]               } else {
// [Main]                 if (i_49 === print_9) {
// [Main]                   const _90 = 0;
// [Main]                   const _91 = ptr_20[_90];
// [Main]                   const _92 = cells_25[_91];
// [Main]                   const _94 = minimbt_print_char($force(_92));
// [Main]                   const _95 = 1;
// [Main]                   const _96 = pc_48 + _95;
// [Main]                   return $thunk(() => aux_46(_96, k))
// [Main]                 } else {
// [Main]                   if (i_49 === read_10) {
// [Main]                     const _97 = 0;
// [Main]                     const _98 = ptr_20[_97];
// [Main]                     return $thunk(() => read_ch_until_newline_or_eof_1(function (_99) {
// [Main]                       const _101 = cells_25[_98] = _99;
// [Main]                       const _102 = 1;
// [Main]                       const _103 = pc_48 + _102;
// [Main]                       return $thunk(() => aux_46(_103, k))
// [Main]                     }
// [Main]                     ))
// [Main]                   } else {
// [Main]                     if (i_49 === loop_start_11) {
// [Main]                       const _104 = 0;
// [Main]                       const _106 = next_pc_28[_104] = pc_48;
// [Main]                       function lp_107(k) {
// [Main]                         const _108 = 0;
// [Main]                         const _109 = ptr_20[_108];
// [Main]                         const _110 = cells_25[_109];
// [Main]                         const _111 = 0;
// [Main]                         if (_110 === _111) {
// [Main]                           const _112 = 0;
// [Main]                           const _113 = 1;
// [Main]                           const _114 = pc_48 + _113;
// [Main]                           const _115 = 0;
// [Main]                           return $thunk(() => skip_29(_114, _115, function (_116) {
// [Main]                             const _118 = next_pc_28[_112] = _116;
// [Main]                             return $thunk(() => k(null))
// [Main]                           }
// [Main]                           ))
// [Main]                         } else {
// [Main]                           const _119 = 0;
// [Main]                           const _120 = 1;
// [Main]                           const _121 = pc_48 + _120;
// [Main]                           return $thunk(() => aux_46(_121, function (_122) {
// [Main]                             const _124 = next_pc_28[_119] = _122;
// [Main]                             return $thunk(() => lp_107(k))
// [Main]                           }
// [Main]                           ))
// [Main]                         }
// [Main]                       }
// [Main]                       return $thunk(() => lp_107(function (_126) {
// [Main]                         const _127 = 0;
// [Main]                         const _128 = next_pc_28[_127];
// [Main]                         const _129 = 1;
// [Main]                         const _130 = _128 + _129;
// [Main]                         return $thunk(() => aux_46(_130, k))
// [Main]                       }
// [Main]                       ))
// [Main]                     } else {
// [Main]                       if (i_49 === loop_end_12) {
// [Main]                         return k(pc_48)
// [Main]                       } else {
// [Main]                         return k(pc_48)
// [Main]                       }
// [Main]                     }
// [Main]                   }
// [Main]                 }
// [Main]               }
// [Main]             }
// [Main]           }
// [Main]         }
// [Main]       }
// [Main]     }
// [Main]     const _131 = 0;
// [Main]     return $thunk(() => aux_46(_131, function (_133) {
// [Main]       return $thunk(() => k(null))
// [Main]     }
// [Main]     ))
// [Main]   }
// [Main]   function main_134(k) {
// [Main]     const len_135 = 1024;
// [Main]     const _136 = 0;
// [Main]     const prog_137 = minimbt_create_array($force(len_135), $force(_136));
// [Main]     function read_prog_138(i_140, k) {
// [Main]       return $thunk(() => read_ch_until_newline_or_eof_1(function (x_141) {
// [Main]         const _142 = -1;
// [Main]         if (x_141 === _142) {
// [Main]           return $thunk(() => bf_13(i_140, prog_137, k))
// [Main]         } else {
// [Main]           const _144 = prog_137[i_140] = x_141;
// [Main]           const _145 = 1;
// [Main]           const _146 = i_140 + _145;
// [Main]           return $thunk(() => read_prog_138(_146, k))
// [Main]         }
// [Main]       }
// [Main]       ))
// [Main]     }
// [Main]     const _147 = 0;
// [Main]     return $thunk(() => read_prog_138(_147, function (_149) {
// [Main]       return $thunk(() => k(null))
// [Main]     }
// [Main]     ))
// [Main]   }
// [Main]   return $thunk(() => main_134(k))
// [Main] }
// [Main] 
// [Main] function $thunk(lambda) {
// [Main]   return { thunk: lambda };
// [Main] }
// [Main] function $is_thunk(x) {
// [Main]   return x && x.hasOwnProperty('thunk') && x.thunk !== undefined;
// [Main] }
// [Main] function $force(x) {
// [Main]   while ($is_thunk(x)) {
// [Main]     x = x.thunk();
// [Main]   }
// [Main]   return x;
// [Main] }
// [Main] function $trampoline(f, ...args) {
// [Main]   let x = f(...args);
// [Main]   return $force(x);
// [Main] }
// [Main] export default () => $trampoline(thunk_main, x => x);
// [Typer] check: LetRec({tyvars: [], name: ("read_ch_until_newline_or_eof", Int), args: [], body: Let(("c", Var({val: None})), App(Var("read_char"), []), If(Eq(Var("c"), Int(10)), Neg(Int(1), kind=None), If(Eq(Var("c"), Int(13)), Neg(Int(1), kind=None), Var("c"))))}, Let(("move_left", Int), Int(60), Let(("move_right", Int), Int(62), Let(("increase", Int), Int(43), Let(("decrease", Int), Int(45), Let(("print", Int), Int(46), Let(("read", Int), Int(44), Let(("loop_start", Int), Int(91), Let(("loop_end", Int), Int(93), LetRec({tyvars: [], name: ("bf", Unit), args: [("len", Int), ("prog", Array(Int))], body: Let(("ptr", Var({val: None})), Array(Int(1), Int(0)), Let(("cells", Var({val: None})), Array(Prim(Int(1024), Int(1024), Mul, kind=None), Int(0)), Let(("next_pc", Var({val: None})), Array(Int(1), Int(0)), LetRec({tyvars: [], name: ("skip", Var({val: None})), args: [("pc", Var({val: None})), ("level", Int)], body: If(LE(Var("len"), Var("pc")), Var("pc"), Let(("i", Var({val: None})), Get(Var("prog"), Var("pc")), If(Eq(Var("i"), Var("loop_start")), App(Var("skip"), [Prim(Var("pc"), Int(1), Add, kind=None), Prim(Var("level"), Int(1), Add, kind=None)]), If(Eq(Var("i"), Var("loop_end")), If(Eq(Var("level"), Int(0)), Var("pc"), App(Var("skip"), [Prim(Var("pc"), Int(1), Add, kind=None), Prim(Var("level"), Int(1), Sub, kind=None)])), App(Var("skip"), [Prim(Var("pc"), Int(1), Add, kind=None), Var("level")])))))}, LetRec({tyvars: [], name: ("aux", Var({val: None})), args: [("pc", Var({val: None}))], body: If(LE(Var("len"), Var("pc")), Var("pc"), Let(("i", Var({val: None})), Get(Var("prog"), Var("pc")), If(Eq(Var("i"), Var("move_right")), Let(("_", Var({val: None})), Put(Var("ptr"), Int(0), Prim(Get(Var("ptr"), Int(0)), Int(1), Add, kind=None)), App(Var("aux"), [Prim(Var("pc"), Int(1), Add, kind=None)])), If(Eq(Var("i"), Var("move_left")), Let(("_", Var({val: None})), Put(Var("ptr"), Int(0), Prim(Get(Var("ptr"), Int(0)), Int(1), Sub, kind=None)), App(Var("aux"), [Prim(Var("pc"), Int(1), Add, kind=None)])), If(Eq(Var("i"), Var("increase")), Let(("_", Var({val: None})), Put(Var("cells"), Get(Var("ptr"), Int(0)), Prim(Get(Var("cells"), Get(Var("ptr"), Int(0))), Int(1), Add, kind=None)), App(Var("aux"), [Prim(Var("pc"), Int(1), Add, kind=None)])), If(Eq(Var("i"), Var("decrease")), Let(("_", Var({val: None})), Put(Var("cells"), Get(Var("ptr"), Int(0)), Prim(Get(Var("cells"), Get(Var("ptr"), Int(0))), Int(1), Sub, kind=None)), App(Var("aux"), [Prim(Var("pc"), Int(1), Add, kind=None)])), If(Eq(Var("i"), Var("print")), Let(("_", Var({val: None})), App(Var("print_char"), [Get(Var("cells"), Get(Var("ptr"), Int(0)))]), App(Var("aux"), [Prim(Var("pc"), Int(1), Add, kind=None)])), If(Eq(Var("i"), Var("read")), Let(("_", Var({val: None})), Put(Var("cells"), Get(Var("ptr"), Int(0)), App(Var("read_ch_until_newline_or_eof"), [])), App(Var("aux"), [Prim(Var("pc"), Int(1), Add, kind=None)])), If(Eq(Var("i"), Var("loop_start")), Let(("_", Var({val: None})), Put(Var("next_pc"), Int(0), Var("pc")), LetRec({tyvars: [], name: ("lp", Var({val: None})), args: [], body: If(Eq(Get(Var("cells"), Get(Var("ptr"), Int(0))), Int(0)), Let(("_", Var({val: None})), Put(Var("next_pc"), Int(0), App(Var("skip"), [Prim(Var("pc"), Int(1), Add, kind=None), Int(0)])), Unit), Let(("_", Var({val: None})), Put(Var("next_pc"), Int(0), App(Var("aux"), [Prim(Var("pc"), Int(1), Add, kind=None)])), App(Var("lp"), [])))}, Let(("_", Var({val: None})), App(Var("lp"), []), App(Var("aux"), [Prim(Get(Var("next_pc"), Int(0)), Int(1), Add, kind=None)])))), If(Eq(Var("i"), Var("loop_end")), Var("pc"), Var("pc")))))))))))}, Let(("_", Var({val: None})), App(Var("aux"), [Int(0)]), Unit))))))}, LetRec({tyvars: [], name: ("main", Var({val: None})), args: [], body: Let(("len", Var({val: None})), Int(1024), Let(("prog", Var({val: None})), Array(Var("len"), Int(0)), LetRec({tyvars: [], name: ("read_prog", Var({val: None})), args: [("i", Var({val: None}))], body: Let(("x", Var({val: None})), App(Var("read_ch_until_newline_or_eof"), []), If(Eq(Var("x"), Neg(Int(1), kind=None)), App(Var("bf"), [Var("i"), Var("prog")]), Let(("_", Var({val: None})), Put(Var("prog"), Var("i"), Var("x")), App(Var("read_prog"), [Prim(Var("i"), Int(1), Add, kind=None)]))))}, Let(("_", Var({val: None})), App(Var("read_prog"), [Int(0)]), Unit))))}, Unit))))))))))) against Unit
// [Typer] typevars: []
// [Typer] check: Let(("c", Var({val: None})), App(Var("read_char"), []), If(Eq(Var("c"), Int(10)), Neg(Int(1), kind=None), If(Eq(Var("c"), Int(13)), Neg(Int(1), kind=None), Var("c")))) against Int
// [Typer] infer: App(Var("read_char"), [])
// [Typer] infer: Var("read_char")
// [Typer] inst: TypeScheme(([], Fun([], Int)))
// [Typer] inst result: Fun([], Int)
// [Typer] unify: Var({val: None}) and Int
// [Typer] union: Var({val: None}) and Int
// [Typer] check: If(Eq(Var("c"), Int(10)), Neg(Int(1), kind=None), If(Eq(Var("c"), Int(13)), Neg(Int(1), kind=None), Var("c"))) against Int
// [Typer] check: Eq(Var("c"), Int(10)) against Bool
// [Typer] infer: Var("c")
// [Typer] inst: TypeScheme(([], Var({val: Some(Int)})))
// [Typer] inst result: Int
// [Typer] infer: Int(10)
// [Typer] unify: Int and Int
// [Typer] check: Neg(Int(1), kind=None) against Int
// [Typer] check: Int(1) against Int
// [Typer] check: If(Eq(Var("c"), Int(13)), Neg(Int(1), kind=None), Var("c")) against Int
// [Typer] check: Eq(Var("c"), Int(13)) against Bool
// [Typer] infer: Var("c")
// [Typer] inst: TypeScheme(([], Var({val: Some(Int)})))
// [Typer] inst result: Int
// [Typer] infer: Int(13)
// [Typer] unify: Int and Int
// [Typer] check: Neg(Int(1), kind=None) against Int
// [Typer] check: Int(1) against Int
// [Typer] check: Var("c") against Int
// [Typer] inst: TypeScheme(([], Var({val: Some(Int)})))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] check: Let(("move_left", Int), Int(60), Let(("move_right", Int), Int(62), Let(("increase", Int), Int(43), Let(("decrease", Int), Int(45), Let(("print", Int), Int(46), Let(("read", Int), Int(44), Let(("loop_start", Int), Int(91), Let(("loop_end", Int), Int(93), LetRec({tyvars: [], name: ("bf", Unit), args: [("len", Int), ("prog", Array(Int))], body: Let(("ptr", Var({val: None})), Array(Int(1), Int(0)), Let(("cells", Var({val: None})), Array(Prim(Int(1024), Int(1024), Mul, kind=None), Int(0)), Let(("next_pc", Var({val: None})), Array(Int(1), Int(0)), LetRec({tyvars: [], name: ("skip", Var({val: None})), args: [("pc", Var({val: None})), ("level", Int)], body: If(LE(Var("len"), Var("pc")), Var("pc"), Let(("i", Var({val: None})), Get(Var("prog"), Var("pc")), If(Eq(Var("i"), Var("loop_start")), App(Var("skip"), [Prim(Var("pc"), Int(1), Add, kind=None), Prim(Var("level"), Int(1), Add, kind=None)]), If(Eq(Var("i"), Var("loop_end")), If(Eq(Var("level"), Int(0)), Var("pc"), App(Var("skip"), [Prim(Var("pc"), Int(1), Add, kind=None), Prim(Var("level"), Int(1), Sub, kind=None)])), App(Var("skip"), [Prim(Var("pc"), Int(1), Add, kind=None), Var("level")])))))}, LetRec({tyvars: [], name: ("aux", Var({val: None})), args: [("pc", Var({val: None}))], body: If(LE(Var("len"), Var("pc")), Var("pc"), Let(("i", Var({val: None})), Get(Var("prog"), Var("pc")), If(Eq(Var("i"), Var("move_right")), Let(("_", Var({val: None})), Put(Var("ptr"), Int(0), Prim(Get(Var("ptr"), Int(0)), Int(1), Add, kind=None)), App(Var("aux"), [Prim(Var("pc"), Int(1), Add, kind=None)])), If(Eq(Var("i"), Var("move_left")), Let(("_", Var({val: None})), Put(Var("ptr"), Int(0), Prim(Get(Var("ptr"), Int(0)), Int(1), Sub, kind=None)), App(Var("aux"), [Prim(Var("pc"), Int(1), Add, kind=None)])), If(Eq(Var("i"), Var("increase")), Let(("_", Var({val: None})), Put(Var("cells"), Get(Var("ptr"), Int(0)), Prim(Get(Var("cells"), Get(Var("ptr"), Int(0))), Int(1), Add, kind=None)), App(Var("aux"), [Prim(Var("pc"), Int(1), Add, kind=None)])), If(Eq(Var("i"), Var("decrease")), Let(("_", Var({val: None})), Put(Var("cells"), Get(Var("ptr"), Int(0)), Prim(Get(Var("cells"), Get(Var("ptr"), Int(0))), Int(1), Sub, kind=None)), App(Var("aux"), [Prim(Var("pc"), Int(1), Add, kind=None)])), If(Eq(Var("i"), Var("print")), Let(("_", Var({val: None})), App(Var("print_char"), [Get(Var("cells"), Get(Var("ptr"), Int(0)))]), App(Var("aux"), [Prim(Var("pc"), Int(1), Add, kind=None)])), If(Eq(Var("i"), Var("read")), Let(("_", Var({val: None})), Put(Var("cells"), Get(Var("ptr"), Int(0)), App(Var("read_ch_until_newline_or_eof"), [])), App(Var("aux"), [Prim(Var("pc"), Int(1), Add, kind=None)])), If(Eq(Var("i"), Var("loop_start")), Let(("_", Var({val: None})), Put(Var("next_pc"), Int(0), Var("pc")), LetRec({tyvars: [], name: ("lp", Var({val: None})), args: [], body: If(Eq(Get(Var("cells"), Get(Var("ptr"), Int(0))), Int(0)), Let(("_", Var({val: None})), Put(Var("next_pc"), Int(0), App(Var("skip"), [Prim(Var("pc"), Int(1), Add, kind=None), Int(0)])), Unit), Let(("_", Var({val: None})), Put(Var("next_pc"), Int(0), App(Var("aux"), [Prim(Var("pc"), Int(1), Add, kind=None)])), App(Var("lp"), [])))}, Let(("_", Var({val: None})), App(Var("lp"), []), App(Var("aux"), [Prim(Get(Var("next_pc"), Int(0)), Int(1), Add, kind=None)])))), If(Eq(Var("i"), Var("loop_end")), Var("pc"), Var("pc")))))))))))}, Let(("_", Var({val: None})), App(Var("aux"), [Int(0)]), Unit))))))}, LetRec({tyvars: [], name: ("main", Var({val: None})), args: [], body: Let(("len", Var({val: None})), Int(1024), Let(("prog", Var({val: None})), Array(Var("len"), Int(0)), LetRec({tyvars: [], name: ("read_prog", Var({val: None})), args: [("i", Var({val: None}))], body: Let(("x", Var({val: None})), App(Var("read_ch_until_newline_or_eof"), []), If(Eq(Var("x"), Neg(Int(1), kind=None)), App(Var("bf"), [Var("i"), Var("prog")]), Let(("_", Var({val: None})), Put(Var("prog"), Var("i"), Var("x")), App(Var("read_prog"), [Prim(Var("i"), Int(1), Add, kind=None)]))))}, Let(("_", Var({val: None})), App(Var("read_prog"), [Int(0)]), Unit))))}, Unit)))))))))) against Unit
// [Typer] check: Int(60) against Int
// [Typer] check: Let(("move_right", Int), Int(62), Let(("increase", Int), Int(43), Let(("decrease", Int), Int(45), Let(("print", Int), Int(46), Let(("read", Int), Int(44), Let(("loop_start", Int), Int(91), Let(("loop_end", Int), Int(93), LetRec({tyvars: [], name: ("bf", Unit), args: [("len", Int), ("prog", Array(Int))], body: Let(("ptr", Var({val: None})), Array(Int(1), Int(0)), Let(("cells", Var({val: None})), Array(Prim(Int(1024), Int(1024), Mul, kind=None), Int(0)), Let(("next_pc", Var({val: None})), Array(Int(1), Int(0)), LetRec({tyvars: [], name: ("skip", Var({val: None})), args: [("pc", Var({val: None})), ("level", Int)], body: If(LE(Var("len"), Var("pc")), Var("pc"), Let(("i", Var({val: None})), Get(Var("prog"), Var("pc")), If(Eq(Var("i"), Var("loop_start")), App(Var("skip"), [Prim(Var("pc"), Int(1), Add, kind=None), Prim(Var("level"), Int(1), Add, kind=None)]), If(Eq(Var("i"), Var("loop_end")), If(Eq(Var("level"), Int(0)), Var("pc"), App(Var("skip"), [Prim(Var("pc"), Int(1), Add, kind=None), Prim(Var("level"), Int(1), Sub, kind=None)])), App(Var("skip"), [Prim(Var("pc"), Int(1), Add, kind=None), Var("level")])))))}, LetRec({tyvars: [], name: ("aux", Var({val: None})), args: [("pc", Var({val: None}))], body: If(LE(Var("len"), Var("pc")), Var("pc"), Let(("i", Var({val: None})), Get(Var("prog"), Var("pc")), If(Eq(Var("i"), Var("move_right")), Let(("_", Var({val: None})), Put(Var("ptr"), Int(0), Prim(Get(Var("ptr"), Int(0)), Int(1), Add, kind=None)), App(Var("aux"), [Prim(Var("pc"), Int(1), Add, kind=None)])), If(Eq(Var("i"), Var("move_left")), Let(("_", Var({val: None})), Put(Var("ptr"), Int(0), Prim(Get(Var("ptr"), Int(0)), Int(1), Sub, kind=None)), App(Var("aux"), [Prim(Var("pc"), Int(1), Add, kind=None)])), If(Eq(Var("i"), Var("increase")), Let(("_", Var({val: None})), Put(Var("cells"), Get(Var("ptr"), Int(0)), Prim(Get(Var("cells"), Get(Var("ptr"), Int(0))), Int(1), Add, kind=None)), App(Var("aux"), [Prim(Var("pc"), Int(1), Add, kind=None)])), If(Eq(Var("i"), Var("decrease")), Let(("_", Var({val: None})), Put(Var("cells"), Get(Var("ptr"), Int(0)), Prim(Get(Var("cells"), Get(Var("ptr"), Int(0))), Int(1), Sub, kind=None)), App(Var("aux"), [Prim(Var("pc"), Int(1), Add, kind=None)])), If(Eq(Var("i"), Var("print")), Let(("_", Var({val: None})), App(Var("print_char"), [Get(Var("cells"), Get(Var("ptr"), Int(0)))]), App(Var("aux"), [Prim(Var("pc"), Int(1), Add, kind=None)])), If(Eq(Var("i"), Var("read")), Let(("_", Var({val: None})), Put(Var("cells"), Get(Var("ptr"), Int(0)), App(Var("read_ch_until_newline_or_eof"), [])), App(Var("aux"), [Prim(Var("pc"), Int(1), Add, kind=None)])), If(Eq(Var("i"), Var("loop_start")), Let(("_", Var({val: None})), Put(Var("next_pc"), Int(0), Var("pc")), LetRec({tyvars: [], name: ("lp", Var({val: None})), args: [], body: If(Eq(Get(Var("cells"), Get(Var("ptr"), Int(0))), Int(0)), Let(("_", Var({val: None})), Put(Var("next_pc"), Int(0), App(Var("skip"), [Prim(Var("pc"), Int(1), Add, kind=None), Int(0)])), Unit), Let(("_", Var({val: None})), Put(Var("next_pc"), Int(0), App(Var("aux"), [Prim(Var("pc"), Int(1), Add, kind=None)])), App(Var("lp"), [])))}, Let(("_", Var({val: None})), App(Var("lp"), []), App(Var("aux"), [Prim(Get(Var("next_pc"), Int(0)), Int(1), Add, kind=None)])))), If(Eq(Var("i"), Var("loop_end")), Var("pc"), Var("pc")))))))))))}, Let(("_", Var({val: None})), App(Var("aux"), [Int(0)]), Unit))))))}, LetRec({tyvars: [], name: ("main", Var({val: None})), args: [], body: Let(("len", Var({val: None})), Int(1024), Let(("prog", Var({val: None})), Array(Var("len"), Int(0)), LetRec({tyvars: [], name: ("read_prog", Var({val: None})), args: [("i", Var({val: None}))], body: Let(("x", Var({val: None})), App(Var("read_ch_until_newline_or_eof"), []), If(Eq(Var("x"), Neg(Int(1), kind=None)), App(Var("bf"), [Var("i"), Var("prog")]), Let(("_", Var({val: None})), Put(Var("prog"), Var("i"), Var("x")), App(Var("read_prog"), [Prim(Var("i"), Int(1), Add, kind=None)]))))}, Let(("_", Var({val: None})), App(Var("read_prog"), [Int(0)]), Unit))))}, Unit))))))))) against Unit
// [Typer] check: Int(62) against Int
// [Typer] check: Let(("increase", Int), Int(43), Let(("decrease", Int), Int(45), Let(("print", Int), Int(46), Let(("read", Int), Int(44), Let(("loop_start", Int), Int(91), Let(("loop_end", Int), Int(93), LetRec({tyvars: [], name: ("bf", Unit), args: [("len", Int), ("prog", Array(Int))], body: Let(("ptr", Var({val: None})), Array(Int(1), Int(0)), Let(("cells", Var({val: None})), Array(Prim(Int(1024), Int(1024), Mul, kind=None), Int(0)), Let(("next_pc", Var({val: None})), Array(Int(1), Int(0)), LetRec({tyvars: [], name: ("skip", Var({val: None})), args: [("pc", Var({val: None})), ("level", Int)], body: If(LE(Var("len"), Var("pc")), Var("pc"), Let(("i", Var({val: None})), Get(Var("prog"), Var("pc")), If(Eq(Var("i"), Var("loop_start")), App(Var("skip"), [Prim(Var("pc"), Int(1), Add, kind=None), Prim(Var("level"), Int(1), Add, kind=None)]), If(Eq(Var("i"), Var("loop_end")), If(Eq(Var("level"), Int(0)), Var("pc"), App(Var("skip"), [Prim(Var("pc"), Int(1), Add, kind=None), Prim(Var("level"), Int(1), Sub, kind=None)])), App(Var("skip"), [Prim(Var("pc"), Int(1), Add, kind=None), Var("level")])))))}, LetRec({tyvars: [], name: ("aux", Var({val: None})), args: [("pc", Var({val: None}))], body: If(LE(Var("len"), Var("pc")), Var("pc"), Let(("i", Var({val: None})), Get(Var("prog"), Var("pc")), If(Eq(Var("i"), Var("move_right")), Let(("_", Var({val: None})), Put(Var("ptr"), Int(0), Prim(Get(Var("ptr"), Int(0)), Int(1), Add, kind=None)), App(Var("aux"), [Prim(Var("pc"), Int(1), Add, kind=None)])), If(Eq(Var("i"), Var("move_left")), Let(("_", Var({val: None})), Put(Var("ptr"), Int(0), Prim(Get(Var("ptr"), Int(0)), Int(1), Sub, kind=None)), App(Var("aux"), [Prim(Var("pc"), Int(1), Add, kind=None)])), If(Eq(Var("i"), Var("increase")), Let(("_", Var({val: None})), Put(Var("cells"), Get(Var("ptr"), Int(0)), Prim(Get(Var("cells"), Get(Var("ptr"), Int(0))), Int(1), Add, kind=None)), App(Var("aux"), [Prim(Var("pc"), Int(1), Add, kind=None)])), If(Eq(Var("i"), Var("decrease")), Let(("_", Var({val: None})), Put(Var("cells"), Get(Var("ptr"), Int(0)), Prim(Get(Var("cells"), Get(Var("ptr"), Int(0))), Int(1), Sub, kind=None)), App(Var("aux"), [Prim(Var("pc"), Int(1), Add, kind=None)])), If(Eq(Var("i"), Var("print")), Let(("_", Var({val: None})), App(Var("print_char"), [Get(Var("cells"), Get(Var("ptr"), Int(0)))]), App(Var("aux"), [Prim(Var("pc"), Int(1), Add, kind=None)])), If(Eq(Var("i"), Var("read")), Let(("_", Var({val: None})), Put(Var("cells"), Get(Var("ptr"), Int(0)), App(Var("read_ch_until_newline_or_eof"), [])), App(Var("aux"), [Prim(Var("pc"), Int(1), Add, kind=None)])), If(Eq(Var("i"), Var("loop_start")), Let(("_", Var({val: None})), Put(Var("next_pc"), Int(0), Var("pc")), LetRec({tyvars: [], name: ("lp", Var({val: None})), args: [], body: If(Eq(Get(Var("cells"), Get(Var("ptr"), Int(0))), Int(0)), Let(("_", Var({val: None})), Put(Var("next_pc"), Int(0), App(Var("skip"), [Prim(Var("pc"), Int(1), Add, kind=None), Int(0)])), Unit), Let(("_", Var({val: None})), Put(Var("next_pc"), Int(0), App(Var("aux"), [Prim(Var("pc"), Int(1), Add, kind=None)])), App(Var("lp"), [])))}, Let(("_", Var({val: None})), App(Var("lp"), []), App(Var("aux"), [Prim(Get(Var("next_pc"), Int(0)), Int(1), Add, kind=None)])))), If(Eq(Var("i"), Var("loop_end")), Var("pc"), Var("pc")))))))))))}, Let(("_", Var({val: None})), App(Var("aux"), [Int(0)]), Unit))))))}, LetRec({tyvars: [], name: ("main", Var({val: None})), args: [], body: Let(("len", Var({val: None})), Int(1024), Let(("prog", Var({val: None})), Array(Var("len"), Int(0)), LetRec({tyvars: [], name: ("read_prog", Var({val: None})), args: [("i", Var({val: None}))], body: Let(("x", Var({val: None})), App(Var("read_ch_until_newline_or_eof"), []), If(Eq(Var("x"), Neg(Int(1), kind=None)), App(Var("bf"), [Var("i"), Var("prog")]), Let(("_", Var({val: None})), Put(Var("prog"), Var("i"), Var("x")), App(Var("read_prog"), [Prim(Var("i"), Int(1), Add, kind=None)]))))}, Let(("_", Var({val: None})), App(Var("read_prog"), [Int(0)]), Unit))))}, Unit)))))))) against Unit
// [Typer] check: Int(43) against Int
// [Typer] check: Let(("decrease", Int), Int(45), Let(("print", Int), Int(46), Let(("read", Int), Int(44), Let(("loop_start", Int), Int(91), Let(("loop_end", Int), Int(93), LetRec({tyvars: [], name: ("bf", Unit), args: [("len", Int), ("prog", Array(Int))], body: Let(("ptr", Var({val: None})), Array(Int(1), Int(0)), Let(("cells", Var({val: None})), Array(Prim(Int(1024), Int(1024), Mul, kind=None), Int(0)), Let(("next_pc", Var({val: None})), Array(Int(1), Int(0)), LetRec({tyvars: [], name: ("skip", Var({val: None})), args: [("pc", Var({val: None})), ("level", Int)], body: If(LE(Var("len"), Var("pc")), Var("pc"), Let(("i", Var({val: None})), Get(Var("prog"), Var("pc")), If(Eq(Var("i"), Var("loop_start")), App(Var("skip"), [Prim(Var("pc"), Int(1), Add, kind=None), Prim(Var("level"), Int(1), Add, kind=None)]), If(Eq(Var("i"), Var("loop_end")), If(Eq(Var("level"), Int(0)), Var("pc"), App(Var("skip"), [Prim(Var("pc"), Int(1), Add, kind=None), Prim(Var("level"), Int(1), Sub, kind=None)])), App(Var("skip"), [Prim(Var("pc"), Int(1), Add, kind=None), Var("level")])))))}, LetRec({tyvars: [], name: ("aux", Var({val: None})), args: [("pc", Var({val: None}))], body: If(LE(Var("len"), Var("pc")), Var("pc"), Let(("i", Var({val: None})), Get(Var("prog"), Var("pc")), If(Eq(Var("i"), Var("move_right")), Let(("_", Var({val: None})), Put(Var("ptr"), Int(0), Prim(Get(Var("ptr"), Int(0)), Int(1), Add, kind=None)), App(Var("aux"), [Prim(Var("pc"), Int(1), Add, kind=None)])), If(Eq(Var("i"), Var("move_left")), Let(("_", Var({val: None})), Put(Var("ptr"), Int(0), Prim(Get(Var("ptr"), Int(0)), Int(1), Sub, kind=None)), App(Var("aux"), [Prim(Var("pc"), Int(1), Add, kind=None)])), If(Eq(Var("i"), Var("increase")), Let(("_", Var({val: None})), Put(Var("cells"), Get(Var("ptr"), Int(0)), Prim(Get(Var("cells"), Get(Var("ptr"), Int(0))), Int(1), Add, kind=None)), App(Var("aux"), [Prim(Var("pc"), Int(1), Add, kind=None)])), If(Eq(Var("i"), Var("decrease")), Let(("_", Var({val: None})), Put(Var("cells"), Get(Var("ptr"), Int(0)), Prim(Get(Var("cells"), Get(Var("ptr"), Int(0))), Int(1), Sub, kind=None)), App(Var("aux"), [Prim(Var("pc"), Int(1), Add, kind=None)])), If(Eq(Var("i"), Var("print")), Let(("_", Var({val: None})), App(Var("print_char"), [Get(Var("cells"), Get(Var("ptr"), Int(0)))]), App(Var("aux"), [Prim(Var("pc"), Int(1), Add, kind=None)])), If(Eq(Var("i"), Var("read")), Let(("_", Var({val: None})), Put(Var("cells"), Get(Var("ptr"), Int(0)), App(Var("read_ch_until_newline_or_eof"), [])), App(Var("aux"), [Prim(Var("pc"), Int(1), Add, kind=None)])), If(Eq(Var("i"), Var("loop_start")), Let(("_", Var({val: None})), Put(Var("next_pc"), Int(0), Var("pc")), LetRec({tyvars: [], name: ("lp", Var({val: None})), args: [], body: If(Eq(Get(Var("cells"), Get(Var("ptr"), Int(0))), Int(0)), Let(("_", Var({val: None})), Put(Var("next_pc"), Int(0), App(Var("skip"), [Prim(Var("pc"), Int(1), Add, kind=None), Int(0)])), Unit), Let(("_", Var({val: None})), Put(Var("next_pc"), Int(0), App(Var("aux"), [Prim(Var("pc"), Int(1), Add, kind=None)])), App(Var("lp"), [])))}, Let(("_", Var({val: None})), App(Var("lp"), []), App(Var("aux"), [Prim(Get(Var("next_pc"), Int(0)), Int(1), Add, kind=None)])))), If(Eq(Var("i"), Var("loop_end")), Var("pc"), Var("pc")))))))))))}, Let(("_", Var({val: None})), App(Var("aux"), [Int(0)]), Unit))))))}, LetRec({tyvars: [], name: ("main", Var({val: None})), args: [], body: Let(("len", Var({val: None})), Int(1024), Let(("prog", Var({val: None})), Array(Var("len"), Int(0)), LetRec({tyvars: [], name: ("read_prog", Var({val: None})), args: [("i", Var({val: None}))], body: Let(("x", Var({val: None})), App(Var("read_ch_until_newline_or_eof"), []), If(Eq(Var("x"), Neg(Int(1), kind=None)), App(Var("bf"), [Var("i"), Var("prog")]), Let(("_", Var({val: None})), Put(Var("prog"), Var("i"), Var("x")), App(Var("read_prog"), [Prim(Var("i"), Int(1), Add, kind=None)]))))}, Let(("_", Var({val: None})), App(Var("read_prog"), [Int(0)]), Unit))))}, Unit))))))) against Unit
// [Typer] check: Int(45) against Int
// [Typer] check: Let(("print", Int), Int(46), Let(("read", Int), Int(44), Let(("loop_start", Int), Int(91), Let(("loop_end", Int), Int(93), LetRec({tyvars: [], name: ("bf", Unit), args: [("len", Int), ("prog", Array(Int))], body: Let(("ptr", Var({val: None})), Array(Int(1), Int(0)), Let(("cells", Var({val: None})), Array(Prim(Int(1024), Int(1024), Mul, kind=None), Int(0)), Let(("next_pc", Var({val: None})), Array(Int(1), Int(0)), LetRec({tyvars: [], name: ("skip", Var({val: None})), args: [("pc", Var({val: None})), ("level", Int)], body: If(LE(Var("len"), Var("pc")), Var("pc"), Let(("i", Var({val: None})), Get(Var("prog"), Var("pc")), If(Eq(Var("i"), Var("loop_start")), App(Var("skip"), [Prim(Var("pc"), Int(1), Add, kind=None), Prim(Var("level"), Int(1), Add, kind=None)]), If(Eq(Var("i"), Var("loop_end")), If(Eq(Var("level"), Int(0)), Var("pc"), App(Var("skip"), [Prim(Var("pc"), Int(1), Add, kind=None), Prim(Var("level"), Int(1), Sub, kind=None)])), App(Var("skip"), [Prim(Var("pc"), Int(1), Add, kind=None), Var("level")])))))}, LetRec({tyvars: [], name: ("aux", Var({val: None})), args: [("pc", Var({val: None}))], body: If(LE(Var("len"), Var("pc")), Var("pc"), Let(("i", Var({val: None})), Get(Var("prog"), Var("pc")), If(Eq(Var("i"), Var("move_right")), Let(("_", Var({val: None})), Put(Var("ptr"), Int(0), Prim(Get(Var("ptr"), Int(0)), Int(1), Add, kind=None)), App(Var("aux"), [Prim(Var("pc"), Int(1), Add, kind=None)])), If(Eq(Var("i"), Var("move_left")), Let(("_", Var({val: None})), Put(Var("ptr"), Int(0), Prim(Get(Var("ptr"), Int(0)), Int(1), Sub, kind=None)), App(Var("aux"), [Prim(Var("pc"), Int(1), Add, kind=None)])), If(Eq(Var("i"), Var("increase")), Let(("_", Var({val: None})), Put(Var("cells"), Get(Var("ptr"), Int(0)), Prim(Get(Var("cells"), Get(Var("ptr"), Int(0))), Int(1), Add, kind=None)), App(Var("aux"), [Prim(Var("pc"), Int(1), Add, kind=None)])), If(Eq(Var("i"), Var("decrease")), Let(("_", Var({val: None})), Put(Var("cells"), Get(Var("ptr"), Int(0)), Prim(Get(Var("cells"), Get(Var("ptr"), Int(0))), Int(1), Sub, kind=None)), App(Var("aux"), [Prim(Var("pc"), Int(1), Add, kind=None)])), If(Eq(Var("i"), Var("print")), Let(("_", Var({val: None})), App(Var("print_char"), [Get(Var("cells"), Get(Var("ptr"), Int(0)))]), App(Var("aux"), [Prim(Var("pc"), Int(1), Add, kind=None)])), If(Eq(Var("i"), Var("read")), Let(("_", Var({val: None})), Put(Var("cells"), Get(Var("ptr"), Int(0)), App(Var("read_ch_until_newline_or_eof"), [])), App(Var("aux"), [Prim(Var("pc"), Int(1), Add, kind=None)])), If(Eq(Var("i"), Var("loop_start")), Let(("_", Var({val: None})), Put(Var("next_pc"), Int(0), Var("pc")), LetRec({tyvars: [], name: ("lp", Var({val: None})), args: [], body: If(Eq(Get(Var("cells"), Get(Var("ptr"), Int(0))), Int(0)), Let(("_", Var({val: None})), Put(Var("next_pc"), Int(0), App(Var("skip"), [Prim(Var("pc"), Int(1), Add, kind=None), Int(0)])), Unit), Let(("_", Var({val: None})), Put(Var("next_pc"), Int(0), App(Var("aux"), [Prim(Var("pc"), Int(1), Add, kind=None)])), App(Var("lp"), [])))}, Let(("_", Var({val: None})), App(Var("lp"), []), App(Var("aux"), [Prim(Get(Var("next_pc"), Int(0)), Int(1), Add, kind=None)])))), If(Eq(Var("i"), Var("loop_end")), Var("pc"), Var("pc")))))))))))}, Let(("_", Var({val: None})), App(Var("aux"), [Int(0)]), Unit))))))}, LetRec({tyvars: [], name: ("main", Var({val: None})), args: [], body: Let(("len", Var({val: None})), Int(1024), Let(("prog", Var({val: None})), Array(Var("len"), Int(0)), LetRec({tyvars: [], name: ("read_prog", Var({val: None})), args: [("i", Var({val: None}))], body: Let(("x", Var({val: None})), App(Var("read_ch_until_newline_or_eof"), []), If(Eq(Var("x"), Neg(Int(1), kind=None)), App(Var("bf"), [Var("i"), Var("prog")]), Let(("_", Var({val: None})), Put(Var("prog"), Var("i"), Var("x")), App(Var("read_prog"), [Prim(Var("i"), Int(1), Add, kind=None)]))))}, Let(("_", Var({val: None})), App(Var("read_prog"), [Int(0)]), Unit))))}, Unit)))))) against Unit
// [Typer] check: Int(46) against Int
// [Typer] check: Let(("read", Int), Int(44), Let(("loop_start", Int), Int(91), Let(("loop_end", Int), Int(93), LetRec({tyvars: [], name: ("bf", Unit), args: [("len", Int), ("prog", Array(Int))], body: Let(("ptr", Var({val: None})), Array(Int(1), Int(0)), Let(("cells", Var({val: None})), Array(Prim(Int(1024), Int(1024), Mul, kind=None), Int(0)), Let(("next_pc", Var({val: None})), Array(Int(1), Int(0)), LetRec({tyvars: [], name: ("skip", Var({val: None})), args: [("pc", Var({val: None})), ("level", Int)], body: If(LE(Var("len"), Var("pc")), Var("pc"), Let(("i", Var({val: None})), Get(Var("prog"), Var("pc")), If(Eq(Var("i"), Var("loop_start")), App(Var("skip"), [Prim(Var("pc"), Int(1), Add, kind=None), Prim(Var("level"), Int(1), Add, kind=None)]), If(Eq(Var("i"), Var("loop_end")), If(Eq(Var("level"), Int(0)), Var("pc"), App(Var("skip"), [Prim(Var("pc"), Int(1), Add, kind=None), Prim(Var("level"), Int(1), Sub, kind=None)])), App(Var("skip"), [Prim(Var("pc"), Int(1), Add, kind=None), Var("level")])))))}, LetRec({tyvars: [], name: ("aux", Var({val: None})), args: [("pc", Var({val: None}))], body: If(LE(Var("len"), Var("pc")), Var("pc"), Let(("i", Var({val: None})), Get(Var("prog"), Var("pc")), If(Eq(Var("i"), Var("move_right")), Let(("_", Var({val: None})), Put(Var("ptr"), Int(0), Prim(Get(Var("ptr"), Int(0)), Int(1), Add, kind=None)), App(Var("aux"), [Prim(Var("pc"), Int(1), Add, kind=None)])), If(Eq(Var("i"), Var("move_left")), Let(("_", Var({val: None})), Put(Var("ptr"), Int(0), Prim(Get(Var("ptr"), Int(0)), Int(1), Sub, kind=None)), App(Var("aux"), [Prim(Var("pc"), Int(1), Add, kind=None)])), If(Eq(Var("i"), Var("increase")), Let(("_", Var({val: None})), Put(Var("cells"), Get(Var("ptr"), Int(0)), Prim(Get(Var("cells"), Get(Var("ptr"), Int(0))), Int(1), Add, kind=None)), App(Var("aux"), [Prim(Var("pc"), Int(1), Add, kind=None)])), If(Eq(Var("i"), Var("decrease")), Let(("_", Var({val: None})), Put(Var("cells"), Get(Var("ptr"), Int(0)), Prim(Get(Var("cells"), Get(Var("ptr"), Int(0))), Int(1), Sub, kind=None)), App(Var("aux"), [Prim(Var("pc"), Int(1), Add, kind=None)])), If(Eq(Var("i"), Var("print")), Let(("_", Var({val: None})), App(Var("print_char"), [Get(Var("cells"), Get(Var("ptr"), Int(0)))]), App(Var("aux"), [Prim(Var("pc"), Int(1), Add, kind=None)])), If(Eq(Var("i"), Var("read")), Let(("_", Var({val: None})), Put(Var("cells"), Get(Var("ptr"), Int(0)), App(Var("read_ch_until_newline_or_eof"), [])), App(Var("aux"), [Prim(Var("pc"), Int(1), Add, kind=None)])), If(Eq(Var("i"), Var("loop_start")), Let(("_", Var({val: None})), Put(Var("next_pc"), Int(0), Var("pc")), LetRec({tyvars: [], name: ("lp", Var({val: None})), args: [], body: If(Eq(Get(Var("cells"), Get(Var("ptr"), Int(0))), Int(0)), Let(("_", Var({val: None})), Put(Var("next_pc"), Int(0), App(Var("skip"), [Prim(Var("pc"), Int(1), Add, kind=None), Int(0)])), Unit), Let(("_", Var({val: None})), Put(Var("next_pc"), Int(0), App(Var("aux"), [Prim(Var("pc"), Int(1), Add, kind=None)])), App(Var("lp"), [])))}, Let(("_", Var({val: None})), App(Var("lp"), []), App(Var("aux"), [Prim(Get(Var("next_pc"), Int(0)), Int(1), Add, kind=None)])))), If(Eq(Var("i"), Var("loop_end")), Var("pc"), Var("pc")))))))))))}, Let(("_", Var({val: None})), App(Var("aux"), [Int(0)]), Unit))))))}, LetRec({tyvars: [], name: ("main", Var({val: None})), args: [], body: Let(("len", Var({val: None})), Int(1024), Let(("prog", Var({val: None})), Array(Var("len"), Int(0)), LetRec({tyvars: [], name: ("read_prog", Var({val: None})), args: [("i", Var({val: None}))], body: Let(("x", Var({val: None})), App(Var("read_ch_until_newline_or_eof"), []), If(Eq(Var("x"), Neg(Int(1), kind=None)), App(Var("bf"), [Var("i"), Var("prog")]), Let(("_", Var({val: None})), Put(Var("prog"), Var("i"), Var("x")), App(Var("read_prog"), [Prim(Var("i"), Int(1), Add, kind=None)]))))}, Let(("_", Var({val: None})), App(Var("read_prog"), [Int(0)]), Unit))))}, Unit))))) against Unit
// [Typer] check: Int(44) against Int
// [Typer] check: Let(("loop_start", Int), Int(91), Let(("loop_end", Int), Int(93), LetRec({tyvars: [], name: ("bf", Unit), args: [("len", Int), ("prog", Array(Int))], body: Let(("ptr", Var({val: None})), Array(Int(1), Int(0)), Let(("cells", Var({val: None})), Array(Prim(Int(1024), Int(1024), Mul, kind=None), Int(0)), Let(("next_pc", Var({val: None})), Array(Int(1), Int(0)), LetRec({tyvars: [], name: ("skip", Var({val: None})), args: [("pc", Var({val: None})), ("level", Int)], body: If(LE(Var("len"), Var("pc")), Var("pc"), Let(("i", Var({val: None})), Get(Var("prog"), Var("pc")), If(Eq(Var("i"), Var("loop_start")), App(Var("skip"), [Prim(Var("pc"), Int(1), Add, kind=None), Prim(Var("level"), Int(1), Add, kind=None)]), If(Eq(Var("i"), Var("loop_end")), If(Eq(Var("level"), Int(0)), Var("pc"), App(Var("skip"), [Prim(Var("pc"), Int(1), Add, kind=None), Prim(Var("level"), Int(1), Sub, kind=None)])), App(Var("skip"), [Prim(Var("pc"), Int(1), Add, kind=None), Var("level")])))))}, LetRec({tyvars: [], name: ("aux", Var({val: None})), args: [("pc", Var({val: None}))], body: If(LE(Var("len"), Var("pc")), Var("pc"), Let(("i", Var({val: None})), Get(Var("prog"), Var("pc")), If(Eq(Var("i"), Var("move_right")), Let(("_", Var({val: None})), Put(Var("ptr"), Int(0), Prim(Get(Var("ptr"), Int(0)), Int(1), Add, kind=None)), App(Var("aux"), [Prim(Var("pc"), Int(1), Add, kind=None)])), If(Eq(Var("i"), Var("move_left")), Let(("_", Var({val: None})), Put(Var("ptr"), Int(0), Prim(Get(Var("ptr"), Int(0)), Int(1), Sub, kind=None)), App(Var("aux"), [Prim(Var("pc"), Int(1), Add, kind=None)])), If(Eq(Var("i"), Var("increase")), Let(("_", Var({val: None})), Put(Var("cells"), Get(Var("ptr"), Int(0)), Prim(Get(Var("cells"), Get(Var("ptr"), Int(0))), Int(1), Add, kind=None)), App(Var("aux"), [Prim(Var("pc"), Int(1), Add, kind=None)])), If(Eq(Var("i"), Var("decrease")), Let(("_", Var({val: None})), Put(Var("cells"), Get(Var("ptr"), Int(0)), Prim(Get(Var("cells"), Get(Var("ptr"), Int(0))), Int(1), Sub, kind=None)), App(Var("aux"), [Prim(Var("pc"), Int(1), Add, kind=None)])), If(Eq(Var("i"), Var("print")), Let(("_", Var({val: None})), App(Var("print_char"), [Get(Var("cells"), Get(Var("ptr"), Int(0)))]), App(Var("aux"), [Prim(Var("pc"), Int(1), Add, kind=None)])), If(Eq(Var("i"), Var("read")), Let(("_", Var({val: None})), Put(Var("cells"), Get(Var("ptr"), Int(0)), App(Var("read_ch_until_newline_or_eof"), [])), App(Var("aux"), [Prim(Var("pc"), Int(1), Add, kind=None)])), If(Eq(Var("i"), Var("loop_start")), Let(("_", Var({val: None})), Put(Var("next_pc"), Int(0), Var("pc")), LetRec({tyvars: [], name: ("lp", Var({val: None})), args: [], body: If(Eq(Get(Var("cells"), Get(Var("ptr"), Int(0))), Int(0)), Let(("_", Var({val: None})), Put(Var("next_pc"), Int(0), App(Var("skip"), [Prim(Var("pc"), Int(1), Add, kind=None), Int(0)])), Unit), Let(("_", Var({val: None})), Put(Var("next_pc"), Int(0), App(Var("aux"), [Prim(Var("pc"), Int(1), Add, kind=None)])), App(Var("lp"), [])))}, Let(("_", Var({val: None})), App(Var("lp"), []), App(Var("aux"), [Prim(Get(Var("next_pc"), Int(0)), Int(1), Add, kind=None)])))), If(Eq(Var("i"), Var("loop_end")), Var("pc"), Var("pc")))))))))))}, Let(("_", Var({val: None})), App(Var("aux"), [Int(0)]), Unit))))))}, LetRec({tyvars: [], name: ("main", Var({val: None})), args: [], body: Let(("len", Var({val: None})), Int(1024), Let(("prog", Var({val: None})), Array(Var("len"), Int(0)), LetRec({tyvars: [], name: ("read_prog", Var({val: None})), args: [("i", Var({val: None}))], body: Let(("x", Var({val: None})), App(Var("read_ch_until_newline_or_eof"), []), If(Eq(Var("x"), Neg(Int(1), kind=None)), App(Var("bf"), [Var("i"), Var("prog")]), Let(("_", Var({val: None})), Put(Var("prog"), Var("i"), Var("x")), App(Var("read_prog"), [Prim(Var("i"), Int(1), Add, kind=None)]))))}, Let(("_", Var({val: None})), App(Var("read_prog"), [Int(0)]), Unit))))}, Unit)))) against Unit
// [Typer] check: Int(91) against Int
// [Typer] check: Let(("loop_end", Int), Int(93), LetRec({tyvars: [], name: ("bf", Unit), args: [("len", Int), ("prog", Array(Int))], body: Let(("ptr", Var({val: None})), Array(Int(1), Int(0)), Let(("cells", Var({val: None})), Array(Prim(Int(1024), Int(1024), Mul, kind=None), Int(0)), Let(("next_pc", Var({val: None})), Array(Int(1), Int(0)), LetRec({tyvars: [], name: ("skip", Var({val: None})), args: [("pc", Var({val: None})), ("level", Int)], body: If(LE(Var("len"), Var("pc")), Var("pc"), Let(("i", Var({val: None})), Get(Var("prog"), Var("pc")), If(Eq(Var("i"), Var("loop_start")), App(Var("skip"), [Prim(Var("pc"), Int(1), Add, kind=None), Prim(Var("level"), Int(1), Add, kind=None)]), If(Eq(Var("i"), Var("loop_end")), If(Eq(Var("level"), Int(0)), Var("pc"), App(Var("skip"), [Prim(Var("pc"), Int(1), Add, kind=None), Prim(Var("level"), Int(1), Sub, kind=None)])), App(Var("skip"), [Prim(Var("pc"), Int(1), Add, kind=None), Var("level")])))))}, LetRec({tyvars: [], name: ("aux", Var({val: None})), args: [("pc", Var({val: None}))], body: If(LE(Var("len"), Var("pc")), Var("pc"), Let(("i", Var({val: None})), Get(Var("prog"), Var("pc")), If(Eq(Var("i"), Var("move_right")), Let(("_", Var({val: None})), Put(Var("ptr"), Int(0), Prim(Get(Var("ptr"), Int(0)), Int(1), Add, kind=None)), App(Var("aux"), [Prim(Var("pc"), Int(1), Add, kind=None)])), If(Eq(Var("i"), Var("move_left")), Let(("_", Var({val: None})), Put(Var("ptr"), Int(0), Prim(Get(Var("ptr"), Int(0)), Int(1), Sub, kind=None)), App(Var("aux"), [Prim(Var("pc"), Int(1), Add, kind=None)])), If(Eq(Var("i"), Var("increase")), Let(("_", Var({val: None})), Put(Var("cells"), Get(Var("ptr"), Int(0)), Prim(Get(Var("cells"), Get(Var("ptr"), Int(0))), Int(1), Add, kind=None)), App(Var("aux"), [Prim(Var("pc"), Int(1), Add, kind=None)])), If(Eq(Var("i"), Var("decrease")), Let(("_", Var({val: None})), Put(Var("cells"), Get(Var("ptr"), Int(0)), Prim(Get(Var("cells"), Get(Var("ptr"), Int(0))), Int(1), Sub, kind=None)), App(Var("aux"), [Prim(Var("pc"), Int(1), Add, kind=None)])), If(Eq(Var("i"), Var("print")), Let(("_", Var({val: None})), App(Var("print_char"), [Get(Var("cells"), Get(Var("ptr"), Int(0)))]), App(Var("aux"), [Prim(Var("pc"), Int(1), Add, kind=None)])), If(Eq(Var("i"), Var("read")), Let(("_", Var({val: None})), Put(Var("cells"), Get(Var("ptr"), Int(0)), App(Var("read_ch_until_newline_or_eof"), [])), App(Var("aux"), [Prim(Var("pc"), Int(1), Add, kind=None)])), If(Eq(Var("i"), Var("loop_start")), Let(("_", Var({val: None})), Put(Var("next_pc"), Int(0), Var("pc")), LetRec({tyvars: [], name: ("lp", Var({val: None})), args: [], body: If(Eq(Get(Var("cells"), Get(Var("ptr"), Int(0))), Int(0)), Let(("_", Var({val: None})), Put(Var("next_pc"), Int(0), App(Var("skip"), [Prim(Var("pc"), Int(1), Add, kind=None), Int(0)])), Unit), Let(("_", Var({val: None})), Put(Var("next_pc"), Int(0), App(Var("aux"), [Prim(Var("pc"), Int(1), Add, kind=None)])), App(Var("lp"), [])))}, Let(("_", Var({val: None})), App(Var("lp"), []), App(Var("aux"), [Prim(Get(Var("next_pc"), Int(0)), Int(1), Add, kind=None)])))), If(Eq(Var("i"), Var("loop_end")), Var("pc"), Var("pc")))))))))))}, Let(("_", Var({val: None})), App(Var("aux"), [Int(0)]), Unit))))))}, LetRec({tyvars: [], name: ("main", Var({val: None})), args: [], body: Let(("len", Var({val: None})), Int(1024), Let(("prog", Var({val: None})), Array(Var("len"), Int(0)), LetRec({tyvars: [], name: ("read_prog", Var({val: None})), args: [("i", Var({val: None}))], body: Let(("x", Var({val: None})), App(Var("read_ch_until_newline_or_eof"), []), If(Eq(Var("x"), Neg(Int(1), kind=None)), App(Var("bf"), [Var("i"), Var("prog")]), Let(("_", Var({val: None})), Put(Var("prog"), Var("i"), Var("x")), App(Var("read_prog"), [Prim(Var("i"), Int(1), Add, kind=None)]))))}, Let(("_", Var({val: None})), App(Var("read_prog"), [Int(0)]), Unit))))}, Unit))) against Unit
// [Typer] check: Int(93) against Int
// [Typer] check: LetRec({tyvars: [], name: ("bf", Unit), args: [("len", Int), ("prog", Array(Int))], body: Let(("ptr", Var({val: None})), Array(Int(1), Int(0)), Let(("cells", Var({val: None})), Array(Prim(Int(1024), Int(1024), Mul, kind=None), Int(0)), Let(("next_pc", Var({val: None})), Array(Int(1), Int(0)), LetRec({tyvars: [], name: ("skip", Var({val: None})), args: [("pc", Var({val: None})), ("level", Int)], body: If(LE(Var("len"), Var("pc")), Var("pc"), Let(("i", Var({val: None})), Get(Var("prog"), Var("pc")), If(Eq(Var("i"), Var("loop_start")), App(Var("skip"), [Prim(Var("pc"), Int(1), Add, kind=None), Prim(Var("level"), Int(1), Add, kind=None)]), If(Eq(Var("i"), Var("loop_end")), If(Eq(Var("level"), Int(0)), Var("pc"), App(Var("skip"), [Prim(Var("pc"), Int(1), Add, kind=None), Prim(Var("level"), Int(1), Sub, kind=None)])), App(Var("skip"), [Prim(Var("pc"), Int(1), Add, kind=None), Var("level")])))))}, LetRec({tyvars: [], name: ("aux", Var({val: None})), args: [("pc", Var({val: None}))], body: If(LE(Var("len"), Var("pc")), Var("pc"), Let(("i", Var({val: None})), Get(Var("prog"), Var("pc")), If(Eq(Var("i"), Var("move_right")), Let(("_", Var({val: None})), Put(Var("ptr"), Int(0), Prim(Get(Var("ptr"), Int(0)), Int(1), Add, kind=None)), App(Var("aux"), [Prim(Var("pc"), Int(1), Add, kind=None)])), If(Eq(Var("i"), Var("move_left")), Let(("_", Var({val: None})), Put(Var("ptr"), Int(0), Prim(Get(Var("ptr"), Int(0)), Int(1), Sub, kind=None)), App(Var("aux"), [Prim(Var("pc"), Int(1), Add, kind=None)])), If(Eq(Var("i"), Var("increase")), Let(("_", Var({val: None})), Put(Var("cells"), Get(Var("ptr"), Int(0)), Prim(Get(Var("cells"), Get(Var("ptr"), Int(0))), Int(1), Add, kind=None)), App(Var("aux"), [Prim(Var("pc"), Int(1), Add, kind=None)])), If(Eq(Var("i"), Var("decrease")), Let(("_", Var({val: None})), Put(Var("cells"), Get(Var("ptr"), Int(0)), Prim(Get(Var("cells"), Get(Var("ptr"), Int(0))), Int(1), Sub, kind=None)), App(Var("aux"), [Prim(Var("pc"), Int(1), Add, kind=None)])), If(Eq(Var("i"), Var("print")), Let(("_", Var({val: None})), App(Var("print_char"), [Get(Var("cells"), Get(Var("ptr"), Int(0)))]), App(Var("aux"), [Prim(Var("pc"), Int(1), Add, kind=None)])), If(Eq(Var("i"), Var("read")), Let(("_", Var({val: None})), Put(Var("cells"), Get(Var("ptr"), Int(0)), App(Var("read_ch_until_newline_or_eof"), [])), App(Var("aux"), [Prim(Var("pc"), Int(1), Add, kind=None)])), If(Eq(Var("i"), Var("loop_start")), Let(("_", Var({val: None})), Put(Var("next_pc"), Int(0), Var("pc")), LetRec({tyvars: [], name: ("lp", Var({val: None})), args: [], body: If(Eq(Get(Var("cells"), Get(Var("ptr"), Int(0))), Int(0)), Let(("_", Var({val: None})), Put(Var("next_pc"), Int(0), App(Var("skip"), [Prim(Var("pc"), Int(1), Add, kind=None), Int(0)])), Unit), Let(("_", Var({val: None})), Put(Var("next_pc"), Int(0), App(Var("aux"), [Prim(Var("pc"), Int(1), Add, kind=None)])), App(Var("lp"), [])))}, Let(("_", Var({val: None})), App(Var("lp"), []), App(Var("aux"), [Prim(Get(Var("next_pc"), Int(0)), Int(1), Add, kind=None)])))), If(Eq(Var("i"), Var("loop_end")), Var("pc"), Var("pc")))))))))))}, Let(("_", Var({val: None})), App(Var("aux"), [Int(0)]), Unit))))))}, LetRec({tyvars: [], name: ("main", Var({val: None})), args: [], body: Let(("len", Var({val: None})), Int(1024), Let(("prog", Var({val: None})), Array(Var("len"), Int(0)), LetRec({tyvars: [], name: ("read_prog", Var({val: None})), args: [("i", Var({val: None}))], body: Let(("x", Var({val: None})), App(Var("read_ch_until_newline_or_eof"), []), If(Eq(Var("x"), Neg(Int(1), kind=None)), App(Var("bf"), [Var("i"), Var("prog")]), Let(("_", Var({val: None})), Put(Var("prog"), Var("i"), Var("x")), App(Var("read_prog"), [Prim(Var("i"), Int(1), Add, kind=None)]))))}, Let(("_", Var({val: None})), App(Var("read_prog"), [Int(0)]), Unit))))}, Unit)) against Unit
// [Typer] typevars: []
// [Typer] check: Let(("ptr", Var({val: None})), Array(Int(1), Int(0)), Let(("cells", Var({val: None})), Array(Prim(Int(1024), Int(1024), Mul, kind=None), Int(0)), Let(("next_pc", Var({val: None})), Array(Int(1), Int(0)), LetRec({tyvars: [], name: ("skip", Var({val: None})), args: [("pc", Var({val: None})), ("level", Int)], body: If(LE(Var("len"), Var("pc")), Var("pc"), Let(("i", Var({val: None})), Get(Var("prog"), Var("pc")), If(Eq(Var("i"), Var("loop_start")), App(Var("skip"), [Prim(Var("pc"), Int(1), Add, kind=None), Prim(Var("level"), Int(1), Add, kind=None)]), If(Eq(Var("i"), Var("loop_end")), If(Eq(Var("level"), Int(0)), Var("pc"), App(Var("skip"), [Prim(Var("pc"), Int(1), Add, kind=None), Prim(Var("level"), Int(1), Sub, kind=None)])), App(Var("skip"), [Prim(Var("pc"), Int(1), Add, kind=None), Var("level")])))))}, LetRec({tyvars: [], name: ("aux", Var({val: None})), args: [("pc", Var({val: None}))], body: If(LE(Var("len"), Var("pc")), Var("pc"), Let(("i", Var({val: None})), Get(Var("prog"), Var("pc")), If(Eq(Var("i"), Var("move_right")), Let(("_", Var({val: None})), Put(Var("ptr"), Int(0), Prim(Get(Var("ptr"), Int(0)), Int(1), Add, kind=None)), App(Var("aux"), [Prim(Var("pc"), Int(1), Add, kind=None)])), If(Eq(Var("i"), Var("move_left")), Let(("_", Var({val: None})), Put(Var("ptr"), Int(0), Prim(Get(Var("ptr"), Int(0)), Int(1), Sub, kind=None)), App(Var("aux"), [Prim(Var("pc"), Int(1), Add, kind=None)])), If(Eq(Var("i"), Var("increase")), Let(("_", Var({val: None})), Put(Var("cells"), Get(Var("ptr"), Int(0)), Prim(Get(Var("cells"), Get(Var("ptr"), Int(0))), Int(1), Add, kind=None)), App(Var("aux"), [Prim(Var("pc"), Int(1), Add, kind=None)])), If(Eq(Var("i"), Var("decrease")), Let(("_", Var({val: None})), Put(Var("cells"), Get(Var("ptr"), Int(0)), Prim(Get(Var("cells"), Get(Var("ptr"), Int(0))), Int(1), Sub, kind=None)), App(Var("aux"), [Prim(Var("pc"), Int(1), Add, kind=None)])), If(Eq(Var("i"), Var("print")), Let(("_", Var({val: None})), App(Var("print_char"), [Get(Var("cells"), Get(Var("ptr"), Int(0)))]), App(Var("aux"), [Prim(Var("pc"), Int(1), Add, kind=None)])), If(Eq(Var("i"), Var("read")), Let(("_", Var({val: None})), Put(Var("cells"), Get(Var("ptr"), Int(0)), App(Var("read_ch_until_newline_or_eof"), [])), App(Var("aux"), [Prim(Var("pc"), Int(1), Add, kind=None)])), If(Eq(Var("i"), Var("loop_start")), Let(("_", Var({val: None})), Put(Var("next_pc"), Int(0), Var("pc")), LetRec({tyvars: [], name: ("lp", Var({val: None})), args: [], body: If(Eq(Get(Var("cells"), Get(Var("ptr"), Int(0))), Int(0)), Let(("_", Var({val: None})), Put(Var("next_pc"), Int(0), App(Var("skip"), [Prim(Var("pc"), Int(1), Add, kind=None), Int(0)])), Unit), Let(("_", Var({val: None})), Put(Var("next_pc"), Int(0), App(Var("aux"), [Prim(Var("pc"), Int(1), Add, kind=None)])), App(Var("lp"), [])))}, Let(("_", Var({val: None})), App(Var("lp"), []), App(Var("aux"), [Prim(Get(Var("next_pc"), Int(0)), Int(1), Add, kind=None)])))), If(Eq(Var("i"), Var("loop_end")), Var("pc"), Var("pc")))))))))))}, Let(("_", Var({val: None})), App(Var("aux"), [Int(0)]), Unit)))))) against Unit
// [Typer] infer: Array(Int(1), Int(0))
// [Typer] infer: Int(0)
// [Typer] check: Int(1) against Int
// [Typer] unify: Var({val: None}) and Array(Int)
// [Typer] union: Var({val: None}) and Array(Int)
// [Typer] check: Let(("cells", Var({val: None})), Array(Prim(Int(1024), Int(1024), Mul, kind=None), Int(0)), Let(("next_pc", Var({val: None})), Array(Int(1), Int(0)), LetRec({tyvars: [], name: ("skip", Var({val: None})), args: [("pc", Var({val: None})), ("level", Int)], body: If(LE(Var("len"), Var("pc")), Var("pc"), Let(("i", Var({val: None})), Get(Var("prog"), Var("pc")), If(Eq(Var("i"), Var("loop_start")), App(Var("skip"), [Prim(Var("pc"), Int(1), Add, kind=None), Prim(Var("level"), Int(1), Add, kind=None)]), If(Eq(Var("i"), Var("loop_end")), If(Eq(Var("level"), Int(0)), Var("pc"), App(Var("skip"), [Prim(Var("pc"), Int(1), Add, kind=None), Prim(Var("level"), Int(1), Sub, kind=None)])), App(Var("skip"), [Prim(Var("pc"), Int(1), Add, kind=None), Var("level")])))))}, LetRec({tyvars: [], name: ("aux", Var({val: None})), args: [("pc", Var({val: None}))], body: If(LE(Var("len"), Var("pc")), Var("pc"), Let(("i", Var({val: None})), Get(Var("prog"), Var("pc")), If(Eq(Var("i"), Var("move_right")), Let(("_", Var({val: None})), Put(Var("ptr"), Int(0), Prim(Get(Var("ptr"), Int(0)), Int(1), Add, kind=None)), App(Var("aux"), [Prim(Var("pc"), Int(1), Add, kind=None)])), If(Eq(Var("i"), Var("move_left")), Let(("_", Var({val: None})), Put(Var("ptr"), Int(0), Prim(Get(Var("ptr"), Int(0)), Int(1), Sub, kind=None)), App(Var("aux"), [Prim(Var("pc"), Int(1), Add, kind=None)])), If(Eq(Var("i"), Var("increase")), Let(("_", Var({val: None})), Put(Var("cells"), Get(Var("ptr"), Int(0)), Prim(Get(Var("cells"), Get(Var("ptr"), Int(0))), Int(1), Add, kind=None)), App(Var("aux"), [Prim(Var("pc"), Int(1), Add, kind=None)])), If(Eq(Var("i"), Var("decrease")), Let(("_", Var({val: None})), Put(Var("cells"), Get(Var("ptr"), Int(0)), Prim(Get(Var("cells"), Get(Var("ptr"), Int(0))), Int(1), Sub, kind=None)), App(Var("aux"), [Prim(Var("pc"), Int(1), Add, kind=None)])), If(Eq(Var("i"), Var("print")), Let(("_", Var({val: None})), App(Var("print_char"), [Get(Var("cells"), Get(Var("ptr"), Int(0)))]), App(Var("aux"), [Prim(Var("pc"), Int(1), Add, kind=None)])), If(Eq(Var("i"), Var("read")), Let(("_", Var({val: None})), Put(Var("cells"), Get(Var("ptr"), Int(0)), App(Var("read_ch_until_newline_or_eof"), [])), App(Var("aux"), [Prim(Var("pc"), Int(1), Add, kind=None)])), If(Eq(Var("i"), Var("loop_start")), Let(("_", Var({val: None})), Put(Var("next_pc"), Int(0), Var("pc")), LetRec({tyvars: [], name: ("lp", Var({val: None})), args: [], body: If(Eq(Get(Var("cells"), Get(Var("ptr"), Int(0))), Int(0)), Let(("_", Var({val: None})), Put(Var("next_pc"), Int(0), App(Var("skip"), [Prim(Var("pc"), Int(1), Add, kind=None), Int(0)])), Unit), Let(("_", Var({val: None})), Put(Var("next_pc"), Int(0), App(Var("aux"), [Prim(Var("pc"), Int(1), Add, kind=None)])), App(Var("lp"), [])))}, Let(("_", Var({val: None})), App(Var("lp"), []), App(Var("aux"), [Prim(Get(Var("next_pc"), Int(0)), Int(1), Add, kind=None)])))), If(Eq(Var("i"), Var("loop_end")), Var("pc"), Var("pc")))))))))))}, Let(("_", Var({val: None})), App(Var("aux"), [Int(0)]), Unit))))) against Unit
// [Typer] infer: Array(Prim(Int(1024), Int(1024), Mul, kind=None), Int(0))
// [Typer] infer: Int(0)
// [Typer] check: Prim(Int(1024), Int(1024), Mul, kind=None) against Int
// [Typer] check: Int(1024) against Int
// [Typer] check: Int(1024) against Int
// [Typer] unify: Var({val: None}) and Array(Int)
// [Typer] union: Var({val: None}) and Array(Int)
// [Typer] check: Let(("next_pc", Var({val: None})), Array(Int(1), Int(0)), LetRec({tyvars: [], name: ("skip", Var({val: None})), args: [("pc", Var({val: None})), ("level", Int)], body: If(LE(Var("len"), Var("pc")), Var("pc"), Let(("i", Var({val: None})), Get(Var("prog"), Var("pc")), If(Eq(Var("i"), Var("loop_start")), App(Var("skip"), [Prim(Var("pc"), Int(1), Add, kind=None), Prim(Var("level"), Int(1), Add, kind=None)]), If(Eq(Var("i"), Var("loop_end")), If(Eq(Var("level"), Int(0)), Var("pc"), App(Var("skip"), [Prim(Var("pc"), Int(1), Add, kind=None), Prim(Var("level"), Int(1), Sub, kind=None)])), App(Var("skip"), [Prim(Var("pc"), Int(1), Add, kind=None), Var("level")])))))}, LetRec({tyvars: [], name: ("aux", Var({val: None})), args: [("pc", Var({val: None}))], body: If(LE(Var("len"), Var("pc")), Var("pc"), Let(("i", Var({val: None})), Get(Var("prog"), Var("pc")), If(Eq(Var("i"), Var("move_right")), Let(("_", Var({val: None})), Put(Var("ptr"), Int(0), Prim(Get(Var("ptr"), Int(0)), Int(1), Add, kind=None)), App(Var("aux"), [Prim(Var("pc"), Int(1), Add, kind=None)])), If(Eq(Var("i"), Var("move_left")), Let(("_", Var({val: None})), Put(Var("ptr"), Int(0), Prim(Get(Var("ptr"), Int(0)), Int(1), Sub, kind=None)), App(Var("aux"), [Prim(Var("pc"), Int(1), Add, kind=None)])), If(Eq(Var("i"), Var("increase")), Let(("_", Var({val: None})), Put(Var("cells"), Get(Var("ptr"), Int(0)), Prim(Get(Var("cells"), Get(Var("ptr"), Int(0))), Int(1), Add, kind=None)), App(Var("aux"), [Prim(Var("pc"), Int(1), Add, kind=None)])), If(Eq(Var("i"), Var("decrease")), Let(("_", Var({val: None})), Put(Var("cells"), Get(Var("ptr"), Int(0)), Prim(Get(Var("cells"), Get(Var("ptr"), Int(0))), Int(1), Sub, kind=None)), App(Var("aux"), [Prim(Var("pc"), Int(1), Add, kind=None)])), If(Eq(Var("i"), Var("print")), Let(("_", Var({val: None})), App(Var("print_char"), [Get(Var("cells"), Get(Var("ptr"), Int(0)))]), App(Var("aux"), [Prim(Var("pc"), Int(1), Add, kind=None)])), If(Eq(Var("i"), Var("read")), Let(("_", Var({val: None})), Put(Var("cells"), Get(Var("ptr"), Int(0)), App(Var("read_ch_until_newline_or_eof"), [])), App(Var("aux"), [Prim(Var("pc"), Int(1), Add, kind=None)])), If(Eq(Var("i"), Var("loop_start")), Let(("_", Var({val: None})), Put(Var("next_pc"), Int(0), Var("pc")), LetRec({tyvars: [], name: ("lp", Var({val: None})), args: [], body: If(Eq(Get(Var("cells"), Get(Var("ptr"), Int(0))), Int(0)), Let(("_", Var({val: None})), Put(Var("next_pc"), Int(0), App(Var("skip"), [Prim(Var("pc"), Int(1), Add, kind=None), Int(0)])), Unit), Let(("_", Var({val: None})), Put(Var("next_pc"), Int(0), App(Var("aux"), [Prim(Var("pc"), Int(1), Add, kind=None)])), App(Var("lp"), [])))}, Let(("_", Var({val: None})), App(Var("lp"), []), App(Var("aux"), [Prim(Get(Var("next_pc"), Int(0)), Int(1), Add, kind=None)])))), If(Eq(Var("i"), Var("loop_end")), Var("pc"), Var("pc")))))))))))}, Let(("_", Var({val: None})), App(Var("aux"), [Int(0)]), Unit)))) against Unit
// [Typer] infer: Array(Int(1), Int(0))
// [Typer] infer: Int(0)
// [Typer] check: Int(1) against Int
// [Typer] unify: Var({val: None}) and Array(Int)
// [Typer] union: Var({val: None}) and Array(Int)
// [Typer] check: LetRec({tyvars: [], name: ("skip", Var({val: None})), args: [("pc", Var({val: None})), ("level", Int)], body: If(LE(Var("len"), Var("pc")), Var("pc"), Let(("i", Var({val: None})), Get(Var("prog"), Var("pc")), If(Eq(Var("i"), Var("loop_start")), App(Var("skip"), [Prim(Var("pc"), Int(1), Add, kind=None), Prim(Var("level"), Int(1), Add, kind=None)]), If(Eq(Var("i"), Var("loop_end")), If(Eq(Var("level"), Int(0)), Var("pc"), App(Var("skip"), [Prim(Var("pc"), Int(1), Add, kind=None), Prim(Var("level"), Int(1), Sub, kind=None)])), App(Var("skip"), [Prim(Var("pc"), Int(1), Add, kind=None), Var("level")])))))}, LetRec({tyvars: [], name: ("aux", Var({val: None})), args: [("pc", Var({val: None}))], body: If(LE(Var("len"), Var("pc")), Var("pc"), Let(("i", Var({val: None})), Get(Var("prog"), Var("pc")), If(Eq(Var("i"), Var("move_right")), Let(("_", Var({val: None})), Put(Var("ptr"), Int(0), Prim(Get(Var("ptr"), Int(0)), Int(1), Add, kind=None)), App(Var("aux"), [Prim(Var("pc"), Int(1), Add, kind=None)])), If(Eq(Var("i"), Var("move_left")), Let(("_", Var({val: None})), Put(Var("ptr"), Int(0), Prim(Get(Var("ptr"), Int(0)), Int(1), Sub, kind=None)), App(Var("aux"), [Prim(Var("pc"), Int(1), Add, kind=None)])), If(Eq(Var("i"), Var("increase")), Let(("_", Var({val: None})), Put(Var("cells"), Get(Var("ptr"), Int(0)), Prim(Get(Var("cells"), Get(Var("ptr"), Int(0))), Int(1), Add, kind=None)), App(Var("aux"), [Prim(Var("pc"), Int(1), Add, kind=None)])), If(Eq(Var("i"), Var("decrease")), Let(("_", Var({val: None})), Put(Var("cells"), Get(Var("ptr"), Int(0)), Prim(Get(Var("cells"), Get(Var("ptr"), Int(0))), Int(1), Sub, kind=None)), App(Var("aux"), [Prim(Var("pc"), Int(1), Add, kind=None)])), If(Eq(Var("i"), Var("print")), Let(("_", Var({val: None})), App(Var("print_char"), [Get(Var("cells"), Get(Var("ptr"), Int(0)))]), App(Var("aux"), [Prim(Var("pc"), Int(1), Add, kind=None)])), If(Eq(Var("i"), Var("read")), Let(("_", Var({val: None})), Put(Var("cells"), Get(Var("ptr"), Int(0)), App(Var("read_ch_until_newline_or_eof"), [])), App(Var("aux"), [Prim(Var("pc"), Int(1), Add, kind=None)])), If(Eq(Var("i"), Var("loop_start")), Let(("_", Var({val: None})), Put(Var("next_pc"), Int(0), Var("pc")), LetRec({tyvars: [], name: ("lp", Var({val: None})), args: [], body: If(Eq(Get(Var("cells"), Get(Var("ptr"), Int(0))), Int(0)), Let(("_", Var({val: None})), Put(Var("next_pc"), Int(0), App(Var("skip"), [Prim(Var("pc"), Int(1), Add, kind=None), Int(0)])), Unit), Let(("_", Var({val: None})), Put(Var("next_pc"), Int(0), App(Var("aux"), [Prim(Var("pc"), Int(1), Add, kind=None)])), App(Var("lp"), [])))}, Let(("_", Var({val: None})), App(Var("lp"), []), App(Var("aux"), [Prim(Get(Var("next_pc"), Int(0)), Int(1), Add, kind=None)])))), If(Eq(Var("i"), Var("loop_end")), Var("pc"), Var("pc")))))))))))}, Let(("_", Var({val: None})), App(Var("aux"), [Int(0)]), Unit))) against Unit
// [Typer] typevars: []
// [Typer] infer: If(LE(Var("len"), Var("pc")), Var("pc"), Let(("i", Var({val: None})), Get(Var("prog"), Var("pc")), If(Eq(Var("i"), Var("loop_start")), App(Var("skip"), [Prim(Var("pc"), Int(1), Add, kind=None), Prim(Var("level"), Int(1), Add, kind=None)]), If(Eq(Var("i"), Var("loop_end")), If(Eq(Var("level"), Int(0)), Var("pc"), App(Var("skip"), [Prim(Var("pc"), Int(1), Add, kind=None), Prim(Var("level"), Int(1), Sub, kind=None)])), App(Var("skip"), [Prim(Var("pc"), Int(1), Add, kind=None), Var("level")])))))
// [Typer] check: LE(Var("len"), Var("pc")) against Bool
// [Typer] infer: Var("len")
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] infer: Var("pc")
// [Typer] inst: TypeScheme(([], Var({val: None})))
// [Typer] inst result: Var({val: None})
// [Typer] unify: Int and Var({val: None})
// [Typer] union: Int and Var({val: None})
// [Typer] infer: Var("pc")
// [Typer] inst: TypeScheme(([], Var({val: Some(Int)})))
// [Typer] inst result: Int
// [Typer] infer: Let(("i", Var({val: None})), Get(Var("prog"), Var("pc")), If(Eq(Var("i"), Var("loop_start")), App(Var("skip"), [Prim(Var("pc"), Int(1), Add, kind=None), Prim(Var("level"), Int(1), Add, kind=None)]), If(Eq(Var("i"), Var("loop_end")), If(Eq(Var("level"), Int(0)), Var("pc"), App(Var("skip"), [Prim(Var("pc"), Int(1), Add, kind=None), Prim(Var("level"), Int(1), Sub, kind=None)])), App(Var("skip"), [Prim(Var("pc"), Int(1), Add, kind=None), Var("level")]))))
// [Typer] infer: Get(Var("prog"), Var("pc"))
// [Typer] infer: Var("prog")
// [Typer] inst: TypeScheme(([], Array(Int)))
// [Typer] inst result: Array(Int)
// [Typer] check: Var("pc") against Int
// [Typer] inst: TypeScheme(([], Var({val: Some(Int)})))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] unify: Var({val: None}) and Int
// [Typer] union: Var({val: None}) and Int
// [Typer] infer: If(Eq(Var("i"), Var("loop_start")), App(Var("skip"), [Prim(Var("pc"), Int(1), Add, kind=None), Prim(Var("level"), Int(1), Add, kind=None)]), If(Eq(Var("i"), Var("loop_end")), If(Eq(Var("level"), Int(0)), Var("pc"), App(Var("skip"), [Prim(Var("pc"), Int(1), Add, kind=None), Prim(Var("level"), Int(1), Sub, kind=None)])), App(Var("skip"), [Prim(Var("pc"), Int(1), Add, kind=None), Var("level")])))
// [Typer] check: Eq(Var("i"), Var("loop_start")) against Bool
// [Typer] infer: Var("i")
// [Typer] inst: TypeScheme(([], Var({val: Some(Int)})))
// [Typer] inst result: Int
// [Typer] infer: Var("loop_start")
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] infer: App(Var("skip"), [Prim(Var("pc"), Int(1), Add, kind=None), Prim(Var("level"), Int(1), Add, kind=None)])
// [Typer] infer: Var("skip")
// [Typer] inst: TypeScheme(([], Fun([Var({val: Some(Int)}), Int], Var({val: None}))))
// [Typer] inst result: Fun([Int, Int], Var({val: None}))
// [Typer] check: Prim(Var("pc"), Int(1), Add, kind=None) against Int
// [Typer] check: Var("pc") against Int
// [Typer] inst: TypeScheme(([], Var({val: Some(Int)})))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] check: Int(1) against Int
// [Typer] check: Prim(Var("level"), Int(1), Add, kind=None) against Int
// [Typer] check: Var("level") against Int
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] check: Int(1) against Int
// [Typer] infer: If(Eq(Var("i"), Var("loop_end")), If(Eq(Var("level"), Int(0)), Var("pc"), App(Var("skip"), [Prim(Var("pc"), Int(1), Add, kind=None), Prim(Var("level"), Int(1), Sub, kind=None)])), App(Var("skip"), [Prim(Var("pc"), Int(1), Add, kind=None), Var("level")]))
// [Typer] check: Eq(Var("i"), Var("loop_end")) against Bool
// [Typer] infer: Var("i")
// [Typer] inst: TypeScheme(([], Var({val: Some(Int)})))
// [Typer] inst result: Int
// [Typer] infer: Var("loop_end")
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] infer: If(Eq(Var("level"), Int(0)), Var("pc"), App(Var("skip"), [Prim(Var("pc"), Int(1), Add, kind=None), Prim(Var("level"), Int(1), Sub, kind=None)]))
// [Typer] check: Eq(Var("level"), Int(0)) against Bool
// [Typer] infer: Var("level")
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] infer: Int(0)
// [Typer] unify: Int and Int
// [Typer] infer: Var("pc")
// [Typer] inst: TypeScheme(([], Var({val: Some(Int)})))
// [Typer] inst result: Int
// [Typer] infer: App(Var("skip"), [Prim(Var("pc"), Int(1), Add, kind=None), Prim(Var("level"), Int(1), Sub, kind=None)])
// [Typer] infer: Var("skip")
// [Typer] inst: TypeScheme(([], Fun([Var({val: Some(Int)}), Int], Var({val: None}))))
// [Typer] inst result: Fun([Int, Int], Var({val: None}))
// [Typer] check: Prim(Var("pc"), Int(1), Add, kind=None) against Int
// [Typer] check: Var("pc") against Int
// [Typer] inst: TypeScheme(([], Var({val: Some(Int)})))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] check: Int(1) against Int
// [Typer] check: Prim(Var("level"), Int(1), Sub, kind=None) against Int
// [Typer] check: Var("level") against Int
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] check: Int(1) against Int
// [Typer] unify: Int and Var({val: None})
// [Typer] union: Int and Var({val: None})
// [Typer] infer: App(Var("skip"), [Prim(Var("pc"), Int(1), Add, kind=None), Var("level")])
// [Typer] infer: Var("skip")
// [Typer] inst: TypeScheme(([], Fun([Var({val: Some(Int)}), Int], Var({val: Some(Int)}))))
// [Typer] inst result: Fun([Int, Int], Int)
// [Typer] check: Prim(Var("pc"), Int(1), Add, kind=None) against Int
// [Typer] check: Var("pc") against Int
// [Typer] inst: TypeScheme(([], Var({val: Some(Int)})))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] check: Int(1) against Int
// [Typer] check: Var("level") against Int
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] unify: Int and Int
// [Typer] unify: Var({val: Some(Int)}) and Int
// [Typer] unify: Int and Int
// [Typer] unify: Int and Var({val: Some(Int)})
// [Typer] check: LetRec({tyvars: [], name: ("aux", Var({val: None})), args: [("pc", Var({val: None}))], body: If(LE(Var("len"), Var("pc")), Var("pc"), Let(("i", Var({val: None})), Get(Var("prog"), Var("pc")), If(Eq(Var("i"), Var("move_right")), Let(("_", Var({val: None})), Put(Var("ptr"), Int(0), Prim(Get(Var("ptr"), Int(0)), Int(1), Add, kind=None)), App(Var("aux"), [Prim(Var("pc"), Int(1), Add, kind=None)])), If(Eq(Var("i"), Var("move_left")), Let(("_", Var({val: None})), Put(Var("ptr"), Int(0), Prim(Get(Var("ptr"), Int(0)), Int(1), Sub, kind=None)), App(Var("aux"), [Prim(Var("pc"), Int(1), Add, kind=None)])), If(Eq(Var("i"), Var("increase")), Let(("_", Var({val: None})), Put(Var("cells"), Get(Var("ptr"), Int(0)), Prim(Get(Var("cells"), Get(Var("ptr"), Int(0))), Int(1), Add, kind=None)), App(Var("aux"), [Prim(Var("pc"), Int(1), Add, kind=None)])), If(Eq(Var("i"), Var("decrease")), Let(("_", Var({val: None})), Put(Var("cells"), Get(Var("ptr"), Int(0)), Prim(Get(Var("cells"), Get(Var("ptr"), Int(0))), Int(1), Sub, kind=None)), App(Var("aux"), [Prim(Var("pc"), Int(1), Add, kind=None)])), If(Eq(Var("i"), Var("print")), Let(("_", Var({val: None})), App(Var("print_char"), [Get(Var("cells"), Get(Var("ptr"), Int(0)))]), App(Var("aux"), [Prim(Var("pc"), Int(1), Add, kind=None)])), If(Eq(Var("i"), Var("read")), Let(("_", Var({val: None})), Put(Var("cells"), Get(Var("ptr"), Int(0)), App(Var("read_ch_until_newline_or_eof"), [])), App(Var("aux"), [Prim(Var("pc"), Int(1), Add, kind=None)])), If(Eq(Var("i"), Var("loop_start")), Let(("_", Var({val: None})), Put(Var("next_pc"), Int(0), Var("pc")), LetRec({tyvars: [], name: ("lp", Var({val: None})), args: [], body: If(Eq(Get(Var("cells"), Get(Var("ptr"), Int(0))), Int(0)), Let(("_", Var({val: None})), Put(Var("next_pc"), Int(0), App(Var("skip"), [Prim(Var("pc"), Int(1), Add, kind=None), Int(0)])), Unit), Let(("_", Var({val: None})), Put(Var("next_pc"), Int(0), App(Var("aux"), [Prim(Var("pc"), Int(1), Add, kind=None)])), App(Var("lp"), [])))}, Let(("_", Var({val: None})), App(Var("lp"), []), App(Var("aux"), [Prim(Get(Var("next_pc"), Int(0)), Int(1), Add, kind=None)])))), If(Eq(Var("i"), Var("loop_end")), Var("pc"), Var("pc")))))))))))}, Let(("_", Var({val: None})), App(Var("aux"), [Int(0)]), Unit)) against Unit
// [Typer] typevars: []
// [Typer] infer: If(LE(Var("len"), Var("pc")), Var("pc"), Let(("i", Var({val: None})), Get(Var("prog"), Var("pc")), If(Eq(Var("i"), Var("move_right")), Let(("_", Var({val: None})), Put(Var("ptr"), Int(0), Prim(Get(Var("ptr"), Int(0)), Int(1), Add, kind=None)), App(Var("aux"), [Prim(Var("pc"), Int(1), Add, kind=None)])), If(Eq(Var("i"), Var("move_left")), Let(("_", Var({val: None})), Put(Var("ptr"), Int(0), Prim(Get(Var("ptr"), Int(0)), Int(1), Sub, kind=None)), App(Var("aux"), [Prim(Var("pc"), Int(1), Add, kind=None)])), If(Eq(Var("i"), Var("increase")), Let(("_", Var({val: None})), Put(Var("cells"), Get(Var("ptr"), Int(0)), Prim(Get(Var("cells"), Get(Var("ptr"), Int(0))), Int(1), Add, kind=None)), App(Var("aux"), [Prim(Var("pc"), Int(1), Add, kind=None)])), If(Eq(Var("i"), Var("decrease")), Let(("_", Var({val: None})), Put(Var("cells"), Get(Var("ptr"), Int(0)), Prim(Get(Var("cells"), Get(Var("ptr"), Int(0))), Int(1), Sub, kind=None)), App(Var("aux"), [Prim(Var("pc"), Int(1), Add, kind=None)])), If(Eq(Var("i"), Var("print")), Let(("_", Var({val: None})), App(Var("print_char"), [Get(Var("cells"), Get(Var("ptr"), Int(0)))]), App(Var("aux"), [Prim(Var("pc"), Int(1), Add, kind=None)])), If(Eq(Var("i"), Var("read")), Let(("_", Var({val: None})), Put(Var("cells"), Get(Var("ptr"), Int(0)), App(Var("read_ch_until_newline_or_eof"), [])), App(Var("aux"), [Prim(Var("pc"), Int(1), Add, kind=None)])), If(Eq(Var("i"), Var("loop_start")), Let(("_", Var({val: None})), Put(Var("next_pc"), Int(0), Var("pc")), LetRec({tyvars: [], name: ("lp", Var({val: None})), args: [], body: If(Eq(Get(Var("cells"), Get(Var("ptr"), Int(0))), Int(0)), Let(("_", Var({val: None})), Put(Var("next_pc"), Int(0), App(Var("skip"), [Prim(Var("pc"), Int(1), Add, kind=None), Int(0)])), Unit), Let(("_", Var({val: None})), Put(Var("next_pc"), Int(0), App(Var("aux"), [Prim(Var("pc"), Int(1), Add, kind=None)])), App(Var("lp"), [])))}, Let(("_", Var({val: None})), App(Var("lp"), []), App(Var("aux"), [Prim(Get(Var("next_pc"), Int(0)), Int(1), Add, kind=None)])))), If(Eq(Var("i"), Var("loop_end")), Var("pc"), Var("pc")))))))))))
// [Typer] check: LE(Var("len"), Var("pc")) against Bool
// [Typer] infer: Var("len")
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] infer: Var("pc")
// [Typer] inst: TypeScheme(([], Var({val: None})))
// [Typer] inst result: Var({val: None})
// [Typer] unify: Int and Var({val: None})
// [Typer] union: Int and Var({val: None})
// [Typer] infer: Var("pc")
// [Typer] inst: TypeScheme(([], Var({val: Some(Int)})))
// [Typer] inst result: Int
// [Typer] infer: Let(("i", Var({val: None})), Get(Var("prog"), Var("pc")), If(Eq(Var("i"), Var("move_right")), Let(("_", Var({val: None})), Put(Var("ptr"), Int(0), Prim(Get(Var("ptr"), Int(0)), Int(1), Add, kind=None)), App(Var("aux"), [Prim(Var("pc"), Int(1), Add, kind=None)])), If(Eq(Var("i"), Var("move_left")), Let(("_", Var({val: None})), Put(Var("ptr"), Int(0), Prim(Get(Var("ptr"), Int(0)), Int(1), Sub, kind=None)), App(Var("aux"), [Prim(Var("pc"), Int(1), Add, kind=None)])), If(Eq(Var("i"), Var("increase")), Let(("_", Var({val: None})), Put(Var("cells"), Get(Var("ptr"), Int(0)), Prim(Get(Var("cells"), Get(Var("ptr"), Int(0))), Int(1), Add, kind=None)), App(Var("aux"), [Prim(Var("pc"), Int(1), Add, kind=None)])), If(Eq(Var("i"), Var("decrease")), Let(("_", Var({val: None})), Put(Var("cells"), Get(Var("ptr"), Int(0)), Prim(Get(Var("cells"), Get(Var("ptr"), Int(0))), Int(1), Sub, kind=None)), App(Var("aux"), [Prim(Var("pc"), Int(1), Add, kind=None)])), If(Eq(Var("i"), Var("print")), Let(("_", Var({val: None})), App(Var("print_char"), [Get(Var("cells"), Get(Var("ptr"), Int(0)))]), App(Var("aux"), [Prim(Var("pc"), Int(1), Add, kind=None)])), If(Eq(Var("i"), Var("read")), Let(("_", Var({val: None})), Put(Var("cells"), Get(Var("ptr"), Int(0)), App(Var("read_ch_until_newline_or_eof"), [])), App(Var("aux"), [Prim(Var("pc"), Int(1), Add, kind=None)])), If(Eq(Var("i"), Var("loop_start")), Let(("_", Var({val: None})), Put(Var("next_pc"), Int(0), Var("pc")), LetRec({tyvars: [], name: ("lp", Var({val: None})), args: [], body: If(Eq(Get(Var("cells"), Get(Var("ptr"), Int(0))), Int(0)), Let(("_", Var({val: None})), Put(Var("next_pc"), Int(0), App(Var("skip"), [Prim(Var("pc"), Int(1), Add, kind=None), Int(0)])), Unit), Let(("_", Var({val: None})), Put(Var("next_pc"), Int(0), App(Var("aux"), [Prim(Var("pc"), Int(1), Add, kind=None)])), App(Var("lp"), [])))}, Let(("_", Var({val: None})), App(Var("lp"), []), App(Var("aux"), [Prim(Get(Var("next_pc"), Int(0)), Int(1), Add, kind=None)])))), If(Eq(Var("i"), Var("loop_end")), Var("pc"), Var("pc"))))))))))
// [Typer] infer: Get(Var("prog"), Var("pc"))
// [Typer] infer: Var("prog")
// [Typer] inst: TypeScheme(([], Array(Int)))
// [Typer] inst result: Array(Int)
// [Typer] check: Var("pc") against Int
// [Typer] inst: TypeScheme(([], Var({val: Some(Int)})))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] unify: Var({val: None}) and Int
// [Typer] union: Var({val: None}) and Int
// [Typer] infer: If(Eq(Var("i"), Var("move_right")), Let(("_", Var({val: None})), Put(Var("ptr"), Int(0), Prim(Get(Var("ptr"), Int(0)), Int(1), Add, kind=None)), App(Var("aux"), [Prim(Var("pc"), Int(1), Add, kind=None)])), If(Eq(Var("i"), Var("move_left")), Let(("_", Var({val: None})), Put(Var("ptr"), Int(0), Prim(Get(Var("ptr"), Int(0)), Int(1), Sub, kind=None)), App(Var("aux"), [Prim(Var("pc"), Int(1), Add, kind=None)])), If(Eq(Var("i"), Var("increase")), Let(("_", Var({val: None})), Put(Var("cells"), Get(Var("ptr"), Int(0)), Prim(Get(Var("cells"), Get(Var("ptr"), Int(0))), Int(1), Add, kind=None)), App(Var("aux"), [Prim(Var("pc"), Int(1), Add, kind=None)])), If(Eq(Var("i"), Var("decrease")), Let(("_", Var({val: None})), Put(Var("cells"), Get(Var("ptr"), Int(0)), Prim(Get(Var("cells"), Get(Var("ptr"), Int(0))), Int(1), Sub, kind=None)), App(Var("aux"), [Prim(Var("pc"), Int(1), Add, kind=None)])), If(Eq(Var("i"), Var("print")), Let(("_", Var({val: None})), App(Var("print_char"), [Get(Var("cells"), Get(Var("ptr"), Int(0)))]), App(Var("aux"), [Prim(Var("pc"), Int(1), Add, kind=None)])), If(Eq(Var("i"), Var("read")), Let(("_", Var({val: None})), Put(Var("cells"), Get(Var("ptr"), Int(0)), App(Var("read_ch_until_newline_or_eof"), [])), App(Var("aux"), [Prim(Var("pc"), Int(1), Add, kind=None)])), If(Eq(Var("i"), Var("loop_start")), Let(("_", Var({val: None})), Put(Var("next_pc"), Int(0), Var("pc")), LetRec({tyvars: [], name: ("lp", Var({val: None})), args: [], body: If(Eq(Get(Var("cells"), Get(Var("ptr"), Int(0))), Int(0)), Let(("_", Var({val: None})), Put(Var("next_pc"), Int(0), App(Var("skip"), [Prim(Var("pc"), Int(1), Add, kind=None), Int(0)])), Unit), Let(("_", Var({val: None})), Put(Var("next_pc"), Int(0), App(Var("aux"), [Prim(Var("pc"), Int(1), Add, kind=None)])), App(Var("lp"), [])))}, Let(("_", Var({val: None})), App(Var("lp"), []), App(Var("aux"), [Prim(Get(Var("next_pc"), Int(0)), Int(1), Add, kind=None)])))), If(Eq(Var("i"), Var("loop_end")), Var("pc"), Var("pc")))))))))
// [Typer] check: Eq(Var("i"), Var("move_right")) against Bool
// [Typer] infer: Var("i")
// [Typer] inst: TypeScheme(([], Var({val: Some(Int)})))
// [Typer] inst result: Int
// [Typer] infer: Var("move_right")
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] infer: Let(("_", Var({val: None})), Put(Var("ptr"), Int(0), Prim(Get(Var("ptr"), Int(0)), Int(1), Add, kind=None)), App(Var("aux"), [Prim(Var("pc"), Int(1), Add, kind=None)]))
// [Typer] infer: Put(Var("ptr"), Int(0), Prim(Get(Var("ptr"), Int(0)), Int(1), Add, kind=None))
// [Typer] infer: Prim(Get(Var("ptr"), Int(0)), Int(1), Add, kind=None)
// [Typer] infer: Get(Var("ptr"), Int(0))
// [Typer] infer: Var("ptr")
// [Typer] inst: TypeScheme(([], Var({val: Some(Array(Int))})))
// [Typer] inst result: Array(Int)
// [Typer] check: Int(0) against Int
// [Typer] infer: Int(1)
// [Typer] unify: Int and Int
// [Typer] check: Var("ptr") against Array(Int)
// [Typer] inst: TypeScheme(([], Var({val: Some(Array(Int))})))
// [Typer] inst result: Array(Int)
// [Typer] unify: Array(Int) and Array(Int)
// [Typer] unify: Int and Int
// [Typer] check: Int(0) against Int
// [Typer] unify: Var({val: None}) and Unit
// [Typer] union: Var({val: None}) and Unit
// [Typer] infer: App(Var("aux"), [Prim(Var("pc"), Int(1), Add, kind=None)])
// [Typer] infer: Var("aux")
// [Typer] inst: TypeScheme(([], Fun([Var({val: Some(Int)})], Var({val: None}))))
// [Typer] inst result: Fun([Int], Var({val: None}))
// [Typer] check: Prim(Var("pc"), Int(1), Add, kind=None) against Int
// [Typer] check: Var("pc") against Int
// [Typer] inst: TypeScheme(([], Var({val: Some(Int)})))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] check: Int(1) against Int
// [Typer] infer: If(Eq(Var("i"), Var("move_left")), Let(("_", Var({val: None})), Put(Var("ptr"), Int(0), Prim(Get(Var("ptr"), Int(0)), Int(1), Sub, kind=None)), App(Var("aux"), [Prim(Var("pc"), Int(1), Add, kind=None)])), If(Eq(Var("i"), Var("increase")), Let(("_", Var({val: None})), Put(Var("cells"), Get(Var("ptr"), Int(0)), Prim(Get(Var("cells"), Get(Var("ptr"), Int(0))), Int(1), Add, kind=None)), App(Var("aux"), [Prim(Var("pc"), Int(1), Add, kind=None)])), If(Eq(Var("i"), Var("decrease")), Let(("_", Var({val: None})), Put(Var("cells"), Get(Var("ptr"), Int(0)), Prim(Get(Var("cells"), Get(Var("ptr"), Int(0))), Int(1), Sub, kind=None)), App(Var("aux"), [Prim(Var("pc"), Int(1), Add, kind=None)])), If(Eq(Var("i"), Var("print")), Let(("_", Var({val: None})), App(Var("print_char"), [Get(Var("cells"), Get(Var("ptr"), Int(0)))]), App(Var("aux"), [Prim(Var("pc"), Int(1), Add, kind=None)])), If(Eq(Var("i"), Var("read")), Let(("_", Var({val: None})), Put(Var("cells"), Get(Var("ptr"), Int(0)), App(Var("read_ch_until_newline_or_eof"), [])), App(Var("aux"), [Prim(Var("pc"), Int(1), Add, kind=None)])), If(Eq(Var("i"), Var("loop_start")), Let(("_", Var({val: None})), Put(Var("next_pc"), Int(0), Var("pc")), LetRec({tyvars: [], name: ("lp", Var({val: None})), args: [], body: If(Eq(Get(Var("cells"), Get(Var("ptr"), Int(0))), Int(0)), Let(("_", Var({val: None})), Put(Var("next_pc"), Int(0), App(Var("skip"), [Prim(Var("pc"), Int(1), Add, kind=None), Int(0)])), Unit), Let(("_", Var({val: None})), Put(Var("next_pc"), Int(0), App(Var("aux"), [Prim(Var("pc"), Int(1), Add, kind=None)])), App(Var("lp"), [])))}, Let(("_", Var({val: None})), App(Var("lp"), []), App(Var("aux"), [Prim(Get(Var("next_pc"), Int(0)), Int(1), Add, kind=None)])))), If(Eq(Var("i"), Var("loop_end")), Var("pc"), Var("pc"))))))))
// [Typer] check: Eq(Var("i"), Var("move_left")) against Bool
// [Typer] infer: Var("i")
// [Typer] inst: TypeScheme(([], Var({val: Some(Int)})))
// [Typer] inst result: Int
// [Typer] infer: Var("move_left")
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] infer: Let(("_", Var({val: None})), Put(Var("ptr"), Int(0), Prim(Get(Var("ptr"), Int(0)), Int(1), Sub, kind=None)), App(Var("aux"), [Prim(Var("pc"), Int(1), Add, kind=None)]))
// [Typer] infer: Put(Var("ptr"), Int(0), Prim(Get(Var("ptr"), Int(0)), Int(1), Sub, kind=None))
// [Typer] infer: Prim(Get(Var("ptr"), Int(0)), Int(1), Sub, kind=None)
// [Typer] infer: Get(Var("ptr"), Int(0))
// [Typer] infer: Var("ptr")
// [Typer] inst: TypeScheme(([], Var({val: Some(Array(Int))})))
// [Typer] inst result: Array(Int)
// [Typer] check: Int(0) against Int
// [Typer] infer: Int(1)
// [Typer] unify: Int and Int
// [Typer] check: Var("ptr") against Array(Int)
// [Typer] inst: TypeScheme(([], Var({val: Some(Array(Int))})))
// [Typer] inst result: Array(Int)
// [Typer] unify: Array(Int) and Array(Int)
// [Typer] unify: Int and Int
// [Typer] check: Int(0) against Int
// [Typer] unify: Var({val: None}) and Unit
// [Typer] union: Var({val: None}) and Unit
// [Typer] infer: App(Var("aux"), [Prim(Var("pc"), Int(1), Add, kind=None)])
// [Typer] infer: Var("aux")
// [Typer] inst: TypeScheme(([], Fun([Var({val: Some(Int)})], Var({val: None}))))
// [Typer] inst result: Fun([Int], Var({val: None}))
// [Typer] check: Prim(Var("pc"), Int(1), Add, kind=None) against Int
// [Typer] check: Var("pc") against Int
// [Typer] inst: TypeScheme(([], Var({val: Some(Int)})))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] check: Int(1) against Int
// [Typer] infer: If(Eq(Var("i"), Var("increase")), Let(("_", Var({val: None})), Put(Var("cells"), Get(Var("ptr"), Int(0)), Prim(Get(Var("cells"), Get(Var("ptr"), Int(0))), Int(1), Add, kind=None)), App(Var("aux"), [Prim(Var("pc"), Int(1), Add, kind=None)])), If(Eq(Var("i"), Var("decrease")), Let(("_", Var({val: None})), Put(Var("cells"), Get(Var("ptr"), Int(0)), Prim(Get(Var("cells"), Get(Var("ptr"), Int(0))), Int(1), Sub, kind=None)), App(Var("aux"), [Prim(Var("pc"), Int(1), Add, kind=None)])), If(Eq(Var("i"), Var("print")), Let(("_", Var({val: None})), App(Var("print_char"), [Get(Var("cells"), Get(Var("ptr"), Int(0)))]), App(Var("aux"), [Prim(Var("pc"), Int(1), Add, kind=None)])), If(Eq(Var("i"), Var("read")), Let(("_", Var({val: None})), Put(Var("cells"), Get(Var("ptr"), Int(0)), App(Var("read_ch_until_newline_or_eof"), [])), App(Var("aux"), [Prim(Var("pc"), Int(1), Add, kind=None)])), If(Eq(Var("i"), Var("loop_start")), Let(("_", Var({val: None})), Put(Var("next_pc"), Int(0), Var("pc")), LetRec({tyvars: [], name: ("lp", Var({val: None})), args: [], body: If(Eq(Get(Var("cells"), Get(Var("ptr"), Int(0))), Int(0)), Let(("_", Var({val: None})), Put(Var("next_pc"), Int(0), App(Var("skip"), [Prim(Var("pc"), Int(1), Add, kind=None), Int(0)])), Unit), Let(("_", Var({val: None})), Put(Var("next_pc"), Int(0), App(Var("aux"), [Prim(Var("pc"), Int(1), Add, kind=None)])), App(Var("lp"), [])))}, Let(("_", Var({val: None})), App(Var("lp"), []), App(Var("aux"), [Prim(Get(Var("next_pc"), Int(0)), Int(1), Add, kind=None)])))), If(Eq(Var("i"), Var("loop_end")), Var("pc"), Var("pc")))))))
// [Typer] check: Eq(Var("i"), Var("increase")) against Bool
// [Typer] infer: Var("i")
// [Typer] inst: TypeScheme(([], Var({val: Some(Int)})))
// [Typer] inst result: Int
// [Typer] infer: Var("increase")
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] infer: Let(("_", Var({val: None})), Put(Var("cells"), Get(Var("ptr"), Int(0)), Prim(Get(Var("cells"), Get(Var("ptr"), Int(0))), Int(1), Add, kind=None)), App(Var("aux"), [Prim(Var("pc"), Int(1), Add, kind=None)]))
// [Typer] infer: Put(Var("cells"), Get(Var("ptr"), Int(0)), Prim(Get(Var("cells"), Get(Var("ptr"), Int(0))), Int(1), Add, kind=None))
// [Typer] infer: Prim(Get(Var("cells"), Get(Var("ptr"), Int(0))), Int(1), Add, kind=None)
// [Typer] infer: Get(Var("cells"), Get(Var("ptr"), Int(0)))
// [Typer] infer: Var("cells")
// [Typer] inst: TypeScheme(([], Var({val: Some(Array(Int))})))
// [Typer] inst result: Array(Int)
// [Typer] check: Get(Var("ptr"), Int(0)) against Int
// [Typer] check: Var("ptr") against Array(Int)
// [Typer] inst: TypeScheme(([], Var({val: Some(Array(Int))})))
// [Typer] inst result: Array(Int)
// [Typer] unify: Array(Int) and Array(Int)
// [Typer] unify: Int and Int
// [Typer] check: Int(0) against Int
// [Typer] infer: Int(1)
// [Typer] unify: Int and Int
// [Typer] check: Var("cells") against Array(Int)
// [Typer] inst: TypeScheme(([], Var({val: Some(Array(Int))})))
// [Typer] inst result: Array(Int)
// [Typer] unify: Array(Int) and Array(Int)
// [Typer] unify: Int and Int
// [Typer] check: Get(Var("ptr"), Int(0)) against Int
// [Typer] check: Var("ptr") against Array(Int)
// [Typer] inst: TypeScheme(([], Var({val: Some(Array(Int))})))
// [Typer] inst result: Array(Int)
// [Typer] unify: Array(Int) and Array(Int)
// [Typer] unify: Int and Int
// [Typer] check: Int(0) against Int
// [Typer] unify: Var({val: None}) and Unit
// [Typer] union: Var({val: None}) and Unit
// [Typer] infer: App(Var("aux"), [Prim(Var("pc"), Int(1), Add, kind=None)])
// [Typer] infer: Var("aux")
// [Typer] inst: TypeScheme(([], Fun([Var({val: Some(Int)})], Var({val: None}))))
// [Typer] inst result: Fun([Int], Var({val: None}))
// [Typer] check: Prim(Var("pc"), Int(1), Add, kind=None) against Int
// [Typer] check: Var("pc") against Int
// [Typer] inst: TypeScheme(([], Var({val: Some(Int)})))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] check: Int(1) against Int
// [Typer] infer: If(Eq(Var("i"), Var("decrease")), Let(("_", Var({val: None})), Put(Var("cells"), Get(Var("ptr"), Int(0)), Prim(Get(Var("cells"), Get(Var("ptr"), Int(0))), Int(1), Sub, kind=None)), App(Var("aux"), [Prim(Var("pc"), Int(1), Add, kind=None)])), If(Eq(Var("i"), Var("print")), Let(("_", Var({val: None})), App(Var("print_char"), [Get(Var("cells"), Get(Var("ptr"), Int(0)))]), App(Var("aux"), [Prim(Var("pc"), Int(1), Add, kind=None)])), If(Eq(Var("i"), Var("read")), Let(("_", Var({val: None})), Put(Var("cells"), Get(Var("ptr"), Int(0)), App(Var("read_ch_until_newline_or_eof"), [])), App(Var("aux"), [Prim(Var("pc"), Int(1), Add, kind=None)])), If(Eq(Var("i"), Var("loop_start")), Let(("_", Var({val: None})), Put(Var("next_pc"), Int(0), Var("pc")), LetRec({tyvars: [], name: ("lp", Var({val: None})), args: [], body: If(Eq(Get(Var("cells"), Get(Var("ptr"), Int(0))), Int(0)), Let(("_", Var({val: None})), Put(Var("next_pc"), Int(0), App(Var("skip"), [Prim(Var("pc"), Int(1), Add, kind=None), Int(0)])), Unit), Let(("_", Var({val: None})), Put(Var("next_pc"), Int(0), App(Var("aux"), [Prim(Var("pc"), Int(1), Add, kind=None)])), App(Var("lp"), [])))}, Let(("_", Var({val: None})), App(Var("lp"), []), App(Var("aux"), [Prim(Get(Var("next_pc"), Int(0)), Int(1), Add, kind=None)])))), If(Eq(Var("i"), Var("loop_end")), Var("pc"), Var("pc"))))))
// [Typer] check: Eq(Var("i"), Var("decrease")) against Bool
// [Typer] infer: Var("i")
// [Typer] inst: TypeScheme(([], Var({val: Some(Int)})))
// [Typer] inst result: Int
// [Typer] infer: Var("decrease")
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] infer: Let(("_", Var({val: None})), Put(Var("cells"), Get(Var("ptr"), Int(0)), Prim(Get(Var("cells"), Get(Var("ptr"), Int(0))), Int(1), Sub, kind=None)), App(Var("aux"), [Prim(Var("pc"), Int(1), Add, kind=None)]))
// [Typer] infer: Put(Var("cells"), Get(Var("ptr"), Int(0)), Prim(Get(Var("cells"), Get(Var("ptr"), Int(0))), Int(1), Sub, kind=None))
// [Typer] infer: Prim(Get(Var("cells"), Get(Var("ptr"), Int(0))), Int(1), Sub, kind=None)
// [Typer] infer: Get(Var("cells"), Get(Var("ptr"), Int(0)))
// [Typer] infer: Var("cells")
// [Typer] inst: TypeScheme(([], Var({val: Some(Array(Int))})))
// [Typer] inst result: Array(Int)
// [Typer] check: Get(Var("ptr"), Int(0)) against Int
// [Typer] check: Var("ptr") against Array(Int)
// [Typer] inst: TypeScheme(([], Var({val: Some(Array(Int))})))
// [Typer] inst result: Array(Int)
// [Typer] unify: Array(Int) and Array(Int)
// [Typer] unify: Int and Int
// [Typer] check: Int(0) against Int
// [Typer] infer: Int(1)
// [Typer] unify: Int and Int
// [Typer] check: Var("cells") against Array(Int)
// [Typer] inst: TypeScheme(([], Var({val: Some(Array(Int))})))
// [Typer] inst result: Array(Int)
// [Typer] unify: Array(Int) and Array(Int)
// [Typer] unify: Int and Int
// [Typer] check: Get(Var("ptr"), Int(0)) against Int
// [Typer] check: Var("ptr") against Array(Int)
// [Typer] inst: TypeScheme(([], Var({val: Some(Array(Int))})))
// [Typer] inst result: Array(Int)
// [Typer] unify: Array(Int) and Array(Int)
// [Typer] unify: Int and Int
// [Typer] check: Int(0) against Int
// [Typer] unify: Var({val: None}) and Unit
// [Typer] union: Var({val: None}) and Unit
// [Typer] infer: App(Var("aux"), [Prim(Var("pc"), Int(1), Add, kind=None)])
// [Typer] infer: Var("aux")
// [Typer] inst: TypeScheme(([], Fun([Var({val: Some(Int)})], Var({val: None}))))
// [Typer] inst result: Fun([Int], Var({val: None}))
// [Typer] check: Prim(Var("pc"), Int(1), Add, kind=None) against Int
// [Typer] check: Var("pc") against Int
// [Typer] inst: TypeScheme(([], Var({val: Some(Int)})))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] check: Int(1) against Int
// [Typer] infer: If(Eq(Var("i"), Var("print")), Let(("_", Var({val: None})), App(Var("print_char"), [Get(Var("cells"), Get(Var("ptr"), Int(0)))]), App(Var("aux"), [Prim(Var("pc"), Int(1), Add, kind=None)])), If(Eq(Var("i"), Var("read")), Let(("_", Var({val: None})), Put(Var("cells"), Get(Var("ptr"), Int(0)), App(Var("read_ch_until_newline_or_eof"), [])), App(Var("aux"), [Prim(Var("pc"), Int(1), Add, kind=None)])), If(Eq(Var("i"), Var("loop_start")), Let(("_", Var({val: None})), Put(Var("next_pc"), Int(0), Var("pc")), LetRec({tyvars: [], name: ("lp", Var({val: None})), args: [], body: If(Eq(Get(Var("cells"), Get(Var("ptr"), Int(0))), Int(0)), Let(("_", Var({val: None})), Put(Var("next_pc"), Int(0), App(Var("skip"), [Prim(Var("pc"), Int(1), Add, kind=None), Int(0)])), Unit), Let(("_", Var({val: None})), Put(Var("next_pc"), Int(0), App(Var("aux"), [Prim(Var("pc"), Int(1), Add, kind=None)])), App(Var("lp"), [])))}, Let(("_", Var({val: None})), App(Var("lp"), []), App(Var("aux"), [Prim(Get(Var("next_pc"), Int(0)), Int(1), Add, kind=None)])))), If(Eq(Var("i"), Var("loop_end")), Var("pc"), Var("pc")))))
// [Typer] check: Eq(Var("i"), Var("print")) against Bool
// [Typer] infer: Var("i")
// [Typer] inst: TypeScheme(([], Var({val: Some(Int)})))
// [Typer] inst result: Int
// [Typer] infer: Var("print")
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] infer: Let(("_", Var({val: None})), App(Var("print_char"), [Get(Var("cells"), Get(Var("ptr"), Int(0)))]), App(Var("aux"), [Prim(Var("pc"), Int(1), Add, kind=None)]))
// [Typer] infer: App(Var("print_char"), [Get(Var("cells"), Get(Var("ptr"), Int(0)))])
// [Typer] infer: Var("print_char")
// [Typer] inst: TypeScheme(([], Fun([Int], Unit)))
// [Typer] inst result: Fun([Int], Unit)
// [Typer] check: Get(Var("cells"), Get(Var("ptr"), Int(0))) against Int
// [Typer] check: Var("cells") against Array(Int)
// [Typer] inst: TypeScheme(([], Var({val: Some(Array(Int))})))
// [Typer] inst result: Array(Int)
// [Typer] unify: Array(Int) and Array(Int)
// [Typer] unify: Int and Int
// [Typer] check: Get(Var("ptr"), Int(0)) against Int
// [Typer] check: Var("ptr") against Array(Int)
// [Typer] inst: TypeScheme(([], Var({val: Some(Array(Int))})))
// [Typer] inst result: Array(Int)
// [Typer] unify: Array(Int) and Array(Int)
// [Typer] unify: Int and Int
// [Typer] check: Int(0) against Int
// [Typer] unify: Var({val: None}) and Unit
// [Typer] union: Var({val: None}) and Unit
// [Typer] infer: App(Var("aux"), [Prim(Var("pc"), Int(1), Add, kind=None)])
// [Typer] infer: Var("aux")
// [Typer] inst: TypeScheme(([], Fun([Var({val: Some(Int)})], Var({val: None}))))
// [Typer] inst result: Fun([Int], Var({val: None}))
// [Typer] check: Prim(Var("pc"), Int(1), Add, kind=None) against Int
// [Typer] check: Var("pc") against Int
// [Typer] inst: TypeScheme(([], Var({val: Some(Int)})))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] check: Int(1) against Int
// [Typer] infer: If(Eq(Var("i"), Var("read")), Let(("_", Var({val: None})), Put(Var("cells"), Get(Var("ptr"), Int(0)), App(Var("read_ch_until_newline_or_eof"), [])), App(Var("aux"), [Prim(Var("pc"), Int(1), Add, kind=None)])), If(Eq(Var("i"), Var("loop_start")), Let(("_", Var({val: None})), Put(Var("next_pc"), Int(0), Var("pc")), LetRec({tyvars: [], name: ("lp", Var({val: None})), args: [], body: If(Eq(Get(Var("cells"), Get(Var("ptr"), Int(0))), Int(0)), Let(("_", Var({val: None})), Put(Var("next_pc"), Int(0), App(Var("skip"), [Prim(Var("pc"), Int(1), Add, kind=None), Int(0)])), Unit), Let(("_", Var({val: None})), Put(Var("next_pc"), Int(0), App(Var("aux"), [Prim(Var("pc"), Int(1), Add, kind=None)])), App(Var("lp"), [])))}, Let(("_", Var({val: None})), App(Var("lp"), []), App(Var("aux"), [Prim(Get(Var("next_pc"), Int(0)), Int(1), Add, kind=None)])))), If(Eq(Var("i"), Var("loop_end")), Var("pc"), Var("pc"))))
// [Typer] check: Eq(Var("i"), Var("read")) against Bool
// [Typer] infer: Var("i")
// [Typer] inst: TypeScheme(([], Var({val: Some(Int)})))
// [Typer] inst result: Int
// [Typer] infer: Var("read")
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] infer: Let(("_", Var({val: None})), Put(Var("cells"), Get(Var("ptr"), Int(0)), App(Var("read_ch_until_newline_or_eof"), [])), App(Var("aux"), [Prim(Var("pc"), Int(1), Add, kind=None)]))
// [Typer] infer: Put(Var("cells"), Get(Var("ptr"), Int(0)), App(Var("read_ch_until_newline_or_eof"), []))
// [Typer] infer: App(Var("read_ch_until_newline_or_eof"), [])
// [Typer] infer: Var("read_ch_until_newline_or_eof")
// [Typer] inst: TypeScheme(([], Fun([], Int)))
// [Typer] inst result: Fun([], Int)
// [Typer] check: Var("cells") against Array(Int)
// [Typer] inst: TypeScheme(([], Var({val: Some(Array(Int))})))
// [Typer] inst result: Array(Int)
// [Typer] unify: Array(Int) and Array(Int)
// [Typer] unify: Int and Int
// [Typer] check: Get(Var("ptr"), Int(0)) against Int
// [Typer] check: Var("ptr") against Array(Int)
// [Typer] inst: TypeScheme(([], Var({val: Some(Array(Int))})))
// [Typer] inst result: Array(Int)
// [Typer] unify: Array(Int) and Array(Int)
// [Typer] unify: Int and Int
// [Typer] check: Int(0) against Int
// [Typer] unify: Var({val: None}) and Unit
// [Typer] union: Var({val: None}) and Unit
// [Typer] infer: App(Var("aux"), [Prim(Var("pc"), Int(1), Add, kind=None)])
// [Typer] infer: Var("aux")
// [Typer] inst: TypeScheme(([], Fun([Var({val: Some(Int)})], Var({val: None}))))
// [Typer] inst result: Fun([Int], Var({val: None}))
// [Typer] check: Prim(Var("pc"), Int(1), Add, kind=None) against Int
// [Typer] check: Var("pc") against Int
// [Typer] inst: TypeScheme(([], Var({val: Some(Int)})))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] check: Int(1) against Int
// [Typer] infer: If(Eq(Var("i"), Var("loop_start")), Let(("_", Var({val: None})), Put(Var("next_pc"), Int(0), Var("pc")), LetRec({tyvars: [], name: ("lp", Var({val: None})), args: [], body: If(Eq(Get(Var("cells"), Get(Var("ptr"), Int(0))), Int(0)), Let(("_", Var({val: None})), Put(Var("next_pc"), Int(0), App(Var("skip"), [Prim(Var("pc"), Int(1), Add, kind=None), Int(0)])), Unit), Let(("_", Var({val: None})), Put(Var("next_pc"), Int(0), App(Var("aux"), [Prim(Var("pc"), Int(1), Add, kind=None)])), App(Var("lp"), [])))}, Let(("_", Var({val: None})), App(Var("lp"), []), App(Var("aux"), [Prim(Get(Var("next_pc"), Int(0)), Int(1), Add, kind=None)])))), If(Eq(Var("i"), Var("loop_end")), Var("pc"), Var("pc")))
// [Typer] check: Eq(Var("i"), Var("loop_start")) against Bool
// [Typer] infer: Var("i")
// [Typer] inst: TypeScheme(([], Var({val: Some(Int)})))
// [Typer] inst result: Int
// [Typer] infer: Var("loop_start")
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] infer: Let(("_", Var({val: None})), Put(Var("next_pc"), Int(0), Var("pc")), LetRec({tyvars: [], name: ("lp", Var({val: None})), args: [], body: If(Eq(Get(Var("cells"), Get(Var("ptr"), Int(0))), Int(0)), Let(("_", Var({val: None})), Put(Var("next_pc"), Int(0), App(Var("skip"), [Prim(Var("pc"), Int(1), Add, kind=None), Int(0)])), Unit), Let(("_", Var({val: None})), Put(Var("next_pc"), Int(0), App(Var("aux"), [Prim(Var("pc"), Int(1), Add, kind=None)])), App(Var("lp"), [])))}, Let(("_", Var({val: None})), App(Var("lp"), []), App(Var("aux"), [Prim(Get(Var("next_pc"), Int(0)), Int(1), Add, kind=None)]))))
// [Typer] infer: Put(Var("next_pc"), Int(0), Var("pc"))
// [Typer] infer: Var("pc")
// [Typer] inst: TypeScheme(([], Var({val: Some(Int)})))
// [Typer] inst result: Int
// [Typer] check: Var("next_pc") against Array(Int)
// [Typer] inst: TypeScheme(([], Var({val: Some(Array(Int))})))
// [Typer] inst result: Array(Int)
// [Typer] unify: Array(Int) and Array(Int)
// [Typer] unify: Int and Int
// [Typer] check: Int(0) against Int
// [Typer] unify: Var({val: None}) and Unit
// [Typer] union: Var({val: None}) and Unit
// [Typer] infer: LetRec({tyvars: [], name: ("lp", Var({val: None})), args: [], body: If(Eq(Get(Var("cells"), Get(Var("ptr"), Int(0))), Int(0)), Let(("_", Var({val: None})), Put(Var("next_pc"), Int(0), App(Var("skip"), [Prim(Var("pc"), Int(1), Add, kind=None), Int(0)])), Unit), Let(("_", Var({val: None})), Put(Var("next_pc"), Int(0), App(Var("aux"), [Prim(Var("pc"), Int(1), Add, kind=None)])), App(Var("lp"), [])))}, Let(("_", Var({val: None})), App(Var("lp"), []), App(Var("aux"), [Prim(Get(Var("next_pc"), Int(0)), Int(1), Add, kind=None)])))
// [Typer] typevars: []
// [Typer] infer: If(Eq(Get(Var("cells"), Get(Var("ptr"), Int(0))), Int(0)), Let(("_", Var({val: None})), Put(Var("next_pc"), Int(0), App(Var("skip"), [Prim(Var("pc"), Int(1), Add, kind=None), Int(0)])), Unit), Let(("_", Var({val: None})), Put(Var("next_pc"), Int(0), App(Var("aux"), [Prim(Var("pc"), Int(1), Add, kind=None)])), App(Var("lp"), [])))
// [Typer] check: Eq(Get(Var("cells"), Get(Var("ptr"), Int(0))), Int(0)) against Bool
// [Typer] infer: Get(Var("cells"), Get(Var("ptr"), Int(0)))
// [Typer] infer: Var("cells")
// [Typer] inst: TypeScheme(([], Var({val: Some(Array(Int))})))
// [Typer] inst result: Array(Int)
// [Typer] check: Get(Var("ptr"), Int(0)) against Int
// [Typer] check: Var("ptr") against Array(Int)
// [Typer] inst: TypeScheme(([], Var({val: Some(Array(Int))})))
// [Typer] inst result: Array(Int)
// [Typer] unify: Array(Int) and Array(Int)
// [Typer] unify: Int and Int
// [Typer] check: Int(0) against Int
// [Typer] infer: Int(0)
// [Typer] unify: Int and Int
// [Typer] infer: Let(("_", Var({val: None})), Put(Var("next_pc"), Int(0), App(Var("skip"), [Prim(Var("pc"), Int(1), Add, kind=None), Int(0)])), Unit)
// [Typer] infer: Put(Var("next_pc"), Int(0), App(Var("skip"), [Prim(Var("pc"), Int(1), Add, kind=None), Int(0)]))
// [Typer] infer: App(Var("skip"), [Prim(Var("pc"), Int(1), Add, kind=None), Int(0)])
// [Typer] infer: Var("skip")
// [Typer] inst: TypeScheme(([], Fun([Var({val: Some(Int)}), Int], Var({val: Some(Int)}))))
// [Typer] inst result: Fun([Int, Int], Int)
// [Typer] check: Prim(Var("pc"), Int(1), Add, kind=None) against Int
// [Typer] check: Var("pc") against Int
// [Typer] inst: TypeScheme(([], Var({val: Some(Int)})))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] check: Int(1) against Int
// [Typer] check: Int(0) against Int
// [Typer] check: Var("next_pc") against Array(Int)
// [Typer] inst: TypeScheme(([], Var({val: Some(Array(Int))})))
// [Typer] inst result: Array(Int)
// [Typer] unify: Array(Int) and Array(Int)
// [Typer] unify: Int and Int
// [Typer] check: Int(0) against Int
// [Typer] unify: Var({val: None}) and Unit
// [Typer] union: Var({val: None}) and Unit
// [Typer] infer: Unit
// [Typer] infer: Let(("_", Var({val: None})), Put(Var("next_pc"), Int(0), App(Var("aux"), [Prim(Var("pc"), Int(1), Add, kind=None)])), App(Var("lp"), []))
// [Typer] infer: Put(Var("next_pc"), Int(0), App(Var("aux"), [Prim(Var("pc"), Int(1), Add, kind=None)]))
// [Typer] infer: App(Var("aux"), [Prim(Var("pc"), Int(1), Add, kind=None)])
// [Typer] infer: Var("aux")
// [Typer] inst: TypeScheme(([], Fun([Var({val: Some(Int)})], Var({val: None}))))
// [Typer] inst result: Fun([Int], Var({val: None}))
// [Typer] check: Prim(Var("pc"), Int(1), Add, kind=None) against Int
// [Typer] check: Var("pc") against Int
// [Typer] inst: TypeScheme(([], Var({val: Some(Int)})))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] check: Int(1) against Int
// [Typer] check: Var("next_pc") against Array(Var({val: None}))
// [Typer] inst: TypeScheme(([], Var({val: Some(Array(Int))})))
// [Typer] inst result: Array(Int)
// [Typer] unify: Array(Int) and Array(Var({val: None}))
// [Typer] unify: Int and Var({val: None})
// [Typer] union: Int and Var({val: None})
// [Typer] check: Int(0) against Int
// [Typer] unify: Var({val: None}) and Unit
// [Typer] union: Var({val: None}) and Unit
// [Typer] infer: App(Var("lp"), [])
// [Typer] infer: Var("lp")
// [Typer] inst: TypeScheme(([], Fun([], Var({val: None}))))
// [Typer] inst result: Fun([], Var({val: None}))
// [Typer] unify: Unit and Var({val: None})
// [Typer] union: Unit and Var({val: None})
// [Typer] unify: Unit and Var({val: Some(Unit)})
// [Typer] infer: Let(("_", Var({val: None})), App(Var("lp"), []), App(Var("aux"), [Prim(Get(Var("next_pc"), Int(0)), Int(1), Add, kind=None)]))
// [Typer] infer: App(Var("lp"), [])
// [Typer] infer: Var("lp")
// [Typer] inst: TypeScheme(([], Fun([], Var({val: Some(Unit)}))))
// [Typer] inst result: Fun([], Unit)
// [Typer] unify: Var({val: None}) and Unit
// [Typer] union: Var({val: None}) and Unit
// [Typer] infer: App(Var("aux"), [Prim(Get(Var("next_pc"), Int(0)), Int(1), Add, kind=None)])
// [Typer] infer: Var("aux")
// [Typer] inst: TypeScheme(([], Fun([Var({val: Some(Int)})], Var({val: Some(Int)}))))
// [Typer] inst result: Fun([Int], Int)
// [Typer] check: Prim(Get(Var("next_pc"), Int(0)), Int(1), Add, kind=None) against Int
// [Typer] check: Get(Var("next_pc"), Int(0)) against Int
// [Typer] check: Var("next_pc") against Array(Int)
// [Typer] inst: TypeScheme(([], Var({val: Some(Array(Int))})))
// [Typer] inst result: Array(Int)
// [Typer] unify: Array(Int) and Array(Int)
// [Typer] unify: Int and Int
// [Typer] check: Int(0) against Int
// [Typer] check: Int(1) against Int
// [Typer] infer: If(Eq(Var("i"), Var("loop_end")), Var("pc"), Var("pc"))
// [Typer] check: Eq(Var("i"), Var("loop_end")) against Bool
// [Typer] infer: Var("i")
// [Typer] inst: TypeScheme(([], Var({val: Some(Int)})))
// [Typer] inst result: Int
// [Typer] infer: Var("loop_end")
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] infer: Var("pc")
// [Typer] inst: TypeScheme(([], Var({val: Some(Int)})))
// [Typer] inst result: Int
// [Typer] infer: Var("pc")
// [Typer] inst: TypeScheme(([], Var({val: Some(Int)})))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] unify: Int and Int
// [Typer] unify: Var({val: Some(Int)}) and Int
// [Typer] unify: Var({val: Some(Int)}) and Int
// [Typer] unify: Var({val: Some(Int)}) and Int
// [Typer] unify: Var({val: Some(Int)}) and Int
// [Typer] unify: Var({val: Some(Int)}) and Int
// [Typer] unify: Var({val: Some(Int)}) and Int
// [Typer] unify: Int and Int
// [Typer] unify: Int and Var({val: Some(Int)})
// [Typer] check: Let(("_", Var({val: None})), App(Var("aux"), [Int(0)]), Unit) against Unit
// [Typer] infer: App(Var("aux"), [Int(0)])
// [Typer] infer: Var("aux")
// [Typer] inst: TypeScheme(([], Fun([Var({val: Some(Int)})], Var({val: Some(Int)}))))
// [Typer] inst result: Fun([Int], Int)
// [Typer] check: Int(0) against Int
// [Typer] unify: Var({val: None}) and Int
// [Typer] union: Var({val: None}) and Int
// [Typer] check: Unit against Unit
// [Typer] check: LetRec({tyvars: [], name: ("main", Var({val: None})), args: [], body: Let(("len", Var({val: None})), Int(1024), Let(("prog", Var({val: None})), Array(Var("len"), Int(0)), LetRec({tyvars: [], name: ("read_prog", Var({val: None})), args: [("i", Var({val: None}))], body: Let(("x", Var({val: None})), App(Var("read_ch_until_newline_or_eof"), []), If(Eq(Var("x"), Neg(Int(1), kind=None)), App(Var("bf"), [Var("i"), Var("prog")]), Let(("_", Var({val: None})), Put(Var("prog"), Var("i"), Var("x")), App(Var("read_prog"), [Prim(Var("i"), Int(1), Add, kind=None)]))))}, Let(("_", Var({val: None})), App(Var("read_prog"), [Int(0)]), Unit))))}, Unit) against Unit
// [Typer] typevars: []
// [Typer] infer: Let(("len", Var({val: None})), Int(1024), Let(("prog", Var({val: None})), Array(Var("len"), Int(0)), LetRec({tyvars: [], name: ("read_prog", Var({val: None})), args: [("i", Var({val: None}))], body: Let(("x", Var({val: None})), App(Var("read_ch_until_newline_or_eof"), []), If(Eq(Var("x"), Neg(Int(1), kind=None)), App(Var("bf"), [Var("i"), Var("prog")]), Let(("_", Var({val: None})), Put(Var("prog"), Var("i"), Var("x")), App(Var("read_prog"), [Prim(Var("i"), Int(1), Add, kind=None)]))))}, Let(("_", Var({val: None})), App(Var("read_prog"), [Int(0)]), Unit))))
// [Typer] infer: Int(1024)
// [Typer] unify: Var({val: None}) and Int
// [Typer] union: Var({val: None}) and Int
// [Typer] infer: Let(("prog", Var({val: None})), Array(Var("len"), Int(0)), LetRec({tyvars: [], name: ("read_prog", Var({val: None})), args: [("i", Var({val: None}))], body: Let(("x", Var({val: None})), App(Var("read_ch_until_newline_or_eof"), []), If(Eq(Var("x"), Neg(Int(1), kind=None)), App(Var("bf"), [Var("i"), Var("prog")]), Let(("_", Var({val: None})), Put(Var("prog"), Var("i"), Var("x")), App(Var("read_prog"), [Prim(Var("i"), Int(1), Add, kind=None)]))))}, Let(("_", Var({val: None})), App(Var("read_prog"), [Int(0)]), Unit)))
// [Typer] infer: Array(Var("len"), Int(0))
// [Typer] infer: Int(0)
// [Typer] check: Var("len") against Int
// [Typer] inst: TypeScheme(([], Var({val: Some(Int)})))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] unify: Var({val: None}) and Array(Int)
// [Typer] union: Var({val: None}) and Array(Int)
// [Typer] infer: LetRec({tyvars: [], name: ("read_prog", Var({val: None})), args: [("i", Var({val: None}))], body: Let(("x", Var({val: None})), App(Var("read_ch_until_newline_or_eof"), []), If(Eq(Var("x"), Neg(Int(1), kind=None)), App(Var("bf"), [Var("i"), Var("prog")]), Let(("_", Var({val: None})), Put(Var("prog"), Var("i"), Var("x")), App(Var("read_prog"), [Prim(Var("i"), Int(1), Add, kind=None)]))))}, Let(("_", Var({val: None})), App(Var("read_prog"), [Int(0)]), Unit))
// [Typer] typevars: []
// [Typer] infer: Let(("x", Var({val: None})), App(Var("read_ch_until_newline_or_eof"), []), If(Eq(Var("x"), Neg(Int(1), kind=None)), App(Var("bf"), [Var("i"), Var("prog")]), Let(("_", Var({val: None})), Put(Var("prog"), Var("i"), Var("x")), App(Var("read_prog"), [Prim(Var("i"), Int(1), Add, kind=None)]))))
// [Typer] infer: App(Var("read_ch_until_newline_or_eof"), [])
// [Typer] infer: Var("read_ch_until_newline_or_eof")
// [Typer] inst: TypeScheme(([], Fun([], Int)))
// [Typer] inst result: Fun([], Int)
// [Typer] unify: Var({val: None}) and Int
// [Typer] union: Var({val: None}) and Int
// [Typer] infer: If(Eq(Var("x"), Neg(Int(1), kind=None)), App(Var("bf"), [Var("i"), Var("prog")]), Let(("_", Var({val: None})), Put(Var("prog"), Var("i"), Var("x")), App(Var("read_prog"), [Prim(Var("i"), Int(1), Add, kind=None)])))
// [Typer] check: Eq(Var("x"), Neg(Int(1), kind=None)) against Bool
// [Typer] infer: Var("x")
// [Typer] inst: TypeScheme(([], Var({val: Some(Int)})))
// [Typer] inst result: Int
// [Typer] infer: Neg(Int(1), kind=None)
// [Typer] infer: Int(1)
// [Typer] unify: Int and Int
// [Typer] infer: App(Var("bf"), [Var("i"), Var("prog")])
// [Typer] infer: Var("bf")
// [Typer] inst: TypeScheme(([], Fun([Int, Array(Int)], Unit)))
// [Typer] inst result: Fun([Int, Array(Int)], Unit)
// [Typer] check: Var("i") against Int
// [Typer] inst: TypeScheme(([], Var({val: None})))
// [Typer] inst result: Var({val: None})
// [Typer] unify: Var({val: None}) and Int
// [Typer] union: Var({val: None}) and Int
// [Typer] check: Var("prog") against Array(Int)
// [Typer] inst: TypeScheme(([], Var({val: Some(Array(Int))})))
// [Typer] inst result: Array(Int)
// [Typer] unify: Array(Int) and Array(Int)
// [Typer] unify: Int and Int
// [Typer] infer: Let(("_", Var({val: None})), Put(Var("prog"), Var("i"), Var("x")), App(Var("read_prog"), [Prim(Var("i"), Int(1), Add, kind=None)]))
// [Typer] infer: Put(Var("prog"), Var("i"), Var("x"))
// [Typer] infer: Var("x")
// [Typer] inst: TypeScheme(([], Var({val: Some(Int)})))
// [Typer] inst result: Int
// [Typer] check: Var("prog") against Array(Int)
// [Typer] inst: TypeScheme(([], Var({val: Some(Array(Int))})))
// [Typer] inst result: Array(Int)
// [Typer] unify: Array(Int) and Array(Int)
// [Typer] unify: Int and Int
// [Typer] check: Var("i") against Int
// [Typer] inst: TypeScheme(([], Var({val: Some(Int)})))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] unify: Var({val: None}) and Unit
// [Typer] union: Var({val: None}) and Unit
// [Typer] infer: App(Var("read_prog"), [Prim(Var("i"), Int(1), Add, kind=None)])
// [Typer] infer: Var("read_prog")
// [Typer] inst: TypeScheme(([], Fun([Var({val: Some(Int)})], Var({val: None}))))
// [Typer] inst result: Fun([Int], Var({val: None}))
// [Typer] check: Prim(Var("i"), Int(1), Add, kind=None) against Int
// [Typer] check: Var("i") against Int
// [Typer] inst: TypeScheme(([], Var({val: Some(Int)})))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] check: Int(1) against Int
// [Typer] unify: Unit and Var({val: None})
// [Typer] union: Unit and Var({val: None})
// [Typer] unify: Unit and Var({val: Some(Unit)})
// [Typer] infer: Let(("_", Var({val: None})), App(Var("read_prog"), [Int(0)]), Unit)
// [Typer] infer: App(Var("read_prog"), [Int(0)])
// [Typer] infer: Var("read_prog")
// [Typer] inst: TypeScheme(([], Fun([Var({val: Some(Int)})], Var({val: Some(Unit)}))))
// [Typer] inst result: Fun([Int], Unit)
// [Typer] check: Int(0) against Int
// [Typer] unify: Var({val: None}) and Unit
// [Typer] union: Var({val: None}) and Unit
// [Typer] infer: Unit
// [Typer] unify: Unit and Var({val: None})
// [Typer] union: Unit and Var({val: None})
// [Typer] check: Unit against Unit
// [Parser] flags: []
