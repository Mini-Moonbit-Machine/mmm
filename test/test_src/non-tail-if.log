// [Main] function thunk_main(k) {
// [Main]   function main_1(k) {
// [Main]     const _2 = 1.23;
// [Main]     const x_3 = minimbt_truncate($force(_2));
// [Main]     const _4 = 4.56;
// [Main]     const y_5 = minimbt_truncate($force(_4));
// [Main]     const _6 = 7.89;
// [Main]     const _7 = -_6;
// [Main]     const z_8 = minimbt_truncate($force(_7));
// [Main]     const _9 = 0;
// [Main]     const _10 = $force((() => {
// [Main]       if (_9 <= z_8) {
// [Main]         return x_3
// [Main]       } else {
// [Main]         return y_5
// [Main]       }
// [Main]     })());
// [Main]     const _11 = 0;
// [Main]     const _12 = $force((() => {
// [Main]       if (x_3 <= _11) {
// [Main]         return y_5
// [Main]       } else {
// [Main]         return z_8
// [Main]       }
// [Main]     })());
// [Main]     const _13 = _10 + _12;
// [Main]     const _14 = 0;
// [Main]     const _15 = $force((() => {
// [Main]       if (_14 <= y_5) {
// [Main]         return z_8
// [Main]       } else {
// [Main]         return x_3
// [Main]       }
// [Main]     })());
// [Main]     const _16 = _13 + _15;
// [Main]     return k(minimbt_print_int($force(_16)))
// [Main]   }
// [Main]   return $thunk(() => main_1(k))
// [Main] }
// [Main] 
// [Main] function $thunk(lambda) {
// [Main]   return { thunk: lambda };
// [Main] }
// [Main] function $is_thunk(x) {
// [Main]   return x && x.hasOwnProperty('thunk') && x.thunk !== undefined;
// [Main] }
// [Main] function $force(x) {
// [Main]   while ($is_thunk(x)) {
// [Main]     x = x.thunk();
// [Main]   }
// [Main]   return x;
// [Main] }
// [Main] function $trampoline(f, ...args) {
// [Main]   let x = f(...args);
// [Main]   return $force(x);
// [Main] }
// [Main] export default () => $trampoline(thunk_main, x => x);
// [Typer] check: LetRec({tyvars: [], name: ("main", Var({val: None})), args: [], body: Let(("x", Var({val: None})), App(Var("truncate"), [Double(1.23)]), Let(("y", Var({val: None})), App(Var("truncate"), [Double(4.56)]), Let(("z", Var({val: None})), App(Var("truncate"), [Neg(Double(7.89), kind=None)]), App(Var("print_int"), [Prim(Prim(If(LE(Int(0), Var("z")), Var("x"), Var("y")), If(LE(Var("x"), Int(0)), Var("y"), Var("z")), Add, kind=None), If(LE(Int(0), Var("y")), Var("z"), Var("x")), Add, kind=None)]))))}, Unit) against Unit
// [Typer] typevars: []
// [Typer] infer: Let(("x", Var({val: None})), App(Var("truncate"), [Double(1.23)]), Let(("y", Var({val: None})), App(Var("truncate"), [Double(4.56)]), Let(("z", Var({val: None})), App(Var("truncate"), [Neg(Double(7.89), kind=None)]), App(Var("print_int"), [Prim(Prim(If(LE(Int(0), Var("z")), Var("x"), Var("y")), If(LE(Var("x"), Int(0)), Var("y"), Var("z")), Add, kind=None), If(LE(Int(0), Var("y")), Var("z"), Var("x")), Add, kind=None)]))))
// [Typer] infer: App(Var("truncate"), [Double(1.23)])
// [Typer] infer: Var("truncate")
// [Typer] inst: TypeScheme(([], Fun([Double], Int)))
// [Typer] inst result: Fun([Double], Int)
// [Typer] check: Double(1.23) against Double
// [Typer] unify: Var({val: None}) and Int
// [Typer] union: Var({val: None}) and Int
// [Typer] infer: Let(("y", Var({val: None})), App(Var("truncate"), [Double(4.56)]), Let(("z", Var({val: None})), App(Var("truncate"), [Neg(Double(7.89), kind=None)]), App(Var("print_int"), [Prim(Prim(If(LE(Int(0), Var("z")), Var("x"), Var("y")), If(LE(Var("x"), Int(0)), Var("y"), Var("z")), Add, kind=None), If(LE(Int(0), Var("y")), Var("z"), Var("x")), Add, kind=None)])))
// [Typer] infer: App(Var("truncate"), [Double(4.56)])
// [Typer] infer: Var("truncate")
// [Typer] inst: TypeScheme(([], Fun([Double], Int)))
// [Typer] inst result: Fun([Double], Int)
// [Typer] check: Double(4.56) against Double
// [Typer] unify: Var({val: None}) and Int
// [Typer] union: Var({val: None}) and Int
// [Typer] infer: Let(("z", Var({val: None})), App(Var("truncate"), [Neg(Double(7.89), kind=None)]), App(Var("print_int"), [Prim(Prim(If(LE(Int(0), Var("z")), Var("x"), Var("y")), If(LE(Var("x"), Int(0)), Var("y"), Var("z")), Add, kind=None), If(LE(Int(0), Var("y")), Var("z"), Var("x")), Add, kind=None)]))
// [Typer] infer: App(Var("truncate"), [Neg(Double(7.89), kind=None)])
// [Typer] infer: Var("truncate")
// [Typer] inst: TypeScheme(([], Fun([Double], Int)))
// [Typer] inst result: Fun([Double], Int)
// [Typer] check: Neg(Double(7.89), kind=None) against Double
// [Typer] check: Double(7.89) against Double
// [Typer] unify: Var({val: None}) and Int
// [Typer] union: Var({val: None}) and Int
// [Typer] infer: App(Var("print_int"), [Prim(Prim(If(LE(Int(0), Var("z")), Var("x"), Var("y")), If(LE(Var("x"), Int(0)), Var("y"), Var("z")), Add, kind=None), If(LE(Int(0), Var("y")), Var("z"), Var("x")), Add, kind=None)])
// [Typer] infer: Var("print_int")
// [Typer] inst: TypeScheme(([], Fun([Int], Unit)))
// [Typer] inst result: Fun([Int], Unit)
// [Typer] check: Prim(Prim(If(LE(Int(0), Var("z")), Var("x"), Var("y")), If(LE(Var("x"), Int(0)), Var("y"), Var("z")), Add, kind=None), If(LE(Int(0), Var("y")), Var("z"), Var("x")), Add, kind=None) against Int
// [Typer] check: Prim(If(LE(Int(0), Var("z")), Var("x"), Var("y")), If(LE(Var("x"), Int(0)), Var("y"), Var("z")), Add, kind=None) against Int
// [Typer] check: If(LE(Int(0), Var("z")), Var("x"), Var("y")) against Int
// [Typer] check: LE(Int(0), Var("z")) against Bool
// [Typer] infer: Int(0)
// [Typer] infer: Var("z")
// [Typer] inst: TypeScheme(([], Var({val: Some(Int)})))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] check: Var("x") against Int
// [Typer] inst: TypeScheme(([], Var({val: Some(Int)})))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] check: Var("y") against Int
// [Typer] inst: TypeScheme(([], Var({val: Some(Int)})))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] check: If(LE(Var("x"), Int(0)), Var("y"), Var("z")) against Int
// [Typer] check: LE(Var("x"), Int(0)) against Bool
// [Typer] infer: Var("x")
// [Typer] inst: TypeScheme(([], Var({val: Some(Int)})))
// [Typer] inst result: Int
// [Typer] infer: Int(0)
// [Typer] unify: Int and Int
// [Typer] check: Var("y") against Int
// [Typer] inst: TypeScheme(([], Var({val: Some(Int)})))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] check: Var("z") against Int
// [Typer] inst: TypeScheme(([], Var({val: Some(Int)})))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] check: If(LE(Int(0), Var("y")), Var("z"), Var("x")) against Int
// [Typer] check: LE(Int(0), Var("y")) against Bool
// [Typer] infer: Int(0)
// [Typer] infer: Var("y")
// [Typer] inst: TypeScheme(([], Var({val: Some(Int)})))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] check: Var("z") against Int
// [Typer] inst: TypeScheme(([], Var({val: Some(Int)})))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] check: Var("x") against Int
// [Typer] inst: TypeScheme(([], Var({val: Some(Int)})))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] unify: Unit and Var({val: None})
// [Typer] union: Unit and Var({val: None})
// [Typer] check: Unit against Unit
// [Parser] flags: []
