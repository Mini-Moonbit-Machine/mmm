// [Knf] matcher_run: init mat
// [Knf] {arity: 1, occurs: {occurs: [/\]}, rows: [{binds: @immut/hashmap.of([]), patterns: [Int(1)], action: CtorApp("Nil", [])}, {binds: @immut/hashmap.of([]), patterns: [Int(2)], action: Var("q")}]}
// [Knf] specialize_matrix: by subpat int(1), at col 0:
// [Knf] {arity: 0, occurs: {occurs: []}, rows: [{binds: @immut/hashmap.of([]), patterns: [], action: CtorApp("Nil", [])}]}
// [Knf] specialize_matrix: by subpat int(2), at col 0:
// [Knf] {arity: 0, occurs: {occurs: []}, rows: [{binds: @immut/hashmap.of([]), patterns: [], action: Var("q")}]}
// [Knf] default_matrix:
// [Knf] {arity: 0, occurs: {occurs: []}, rows: []}
// [Knf] matcher_run: final tree
// [Knf] Switch(/\, 
// [Knf]   [(int(1), Succeed({}, CtorApp("Nil", []))),
// [Knf]   (int(2), Succeed({}, Var("q"))),
// [Knf]   
// [Knf] ])
// [Knf] decision_tree_to_knf: Switch(/\, 
// [Knf]   [(int(1), Succeed({}, CtorApp("Nil", []))),
// [Knf]   (int(2), Succeed({}, Var("q"))),
// [Knf]   
// [Knf] ])
// [Knf] decision_tree_to_knf: Succeed({}, CtorApp("Nil", []))
// [Knf] decision_tree_to_knf: Succeed({}, Var("q"))
// [Knf] matcher_run: init mat
// [Knf] {arity: 1, occurs: {occurs: [/\]}, rows: [{binds: @immut/hashmap.of([]), patterns: [CtorApp("Nil", [])], action: Int(0)}, {binds: @immut/hashmap.of([]), patterns: [CtorApp("Cons", [CtorApp("None", []), CtorApp("Nil", [])])], action: Int(1)}, {binds: @immut/hashmap.of([]), patterns: [CtorApp("Cons", [CtorApp("Some", [Int(2)]), CtorApp("Nil", [])])], action: Int(2)}, {binds: @immut/hashmap.of([]), patterns: [Wildcard], action: Int(3)}]}
// [Knf] specialize_matrix: by subpat ctor(Nil, 0), at col 0:
// [Knf] {arity: 0, occurs: {occurs: []}, rows: [{binds: @immut/hashmap.of([]), patterns: [], action: Int(0)}, {binds: @immut/hashmap.of([]), patterns: [], action: Int(3)}]}
// [Knf] specialize_matrix: by subpat ctor(Cons, 2), at col 0:
// [Knf] {arity: 2, occurs: {occurs: [/\.0, /\.1]}, rows: [{binds: @immut/hashmap.of([]), patterns: [CtorApp("None", []), CtorApp("Nil", [])], action: Int(1)}, {binds: @immut/hashmap.of([]), patterns: [CtorApp("Some", [Int(2)]), CtorApp("Nil", [])], action: Int(2)}, {binds: @immut/hashmap.of([]), patterns: [Wildcard, Wildcard], action: Int(3)}]}
// [Knf] specialize_matrix: by subpat ctor(Nil, 0), at col 1:
// [Knf] {arity: 1, occurs: {occurs: [/\.0]}, rows: [{binds: @immut/hashmap.of([]), patterns: [CtorApp("None", [])], action: Int(1)}, {binds: @immut/hashmap.of([]), patterns: [CtorApp("Some", [Int(2)])], action: Int(2)}, {binds: @immut/hashmap.of([]), patterns: [Wildcard], action: Int(3)}]}
// [Knf] specialize_matrix: by subpat ctor(None, 0), at col 0:
// [Knf] {arity: 0, occurs: {occurs: []}, rows: [{binds: @immut/hashmap.of([]), patterns: [], action: Int(1)}, {binds: @immut/hashmap.of([]), patterns: [], action: Int(3)}]}
// [Knf] specialize_matrix: by subpat ctor(Some, 1), at col 0:
// [Knf] {arity: 1, occurs: {occurs: [/\.0.0]}, rows: [{binds: @immut/hashmap.of([]), patterns: [Int(2)], action: Int(2)}, {binds: @immut/hashmap.of([]), patterns: [Wildcard], action: Int(3)}]}
// [Knf] specialize_matrix: by subpat int(2), at col 0:
// [Knf] {arity: 0, occurs: {occurs: []}, rows: [{binds: @immut/hashmap.of([]), patterns: [], action: Int(2)}, {binds: @immut/hashmap.of([]), patterns: [], action: Int(3)}]}
// [Knf] default_matrix:
// [Knf] {arity: 0, occurs: {occurs: []}, rows: [{binds: @immut/hashmap.of([]), patterns: [], action: Int(3)}]}
// [Knf] default_matrix:
// [Knf] {arity: 0, occurs: {occurs: []}, rows: [{binds: @immut/hashmap.of([]), patterns: [], action: Int(3)}]}
// [Knf] default_matrix:
// [Knf] {arity: 1, occurs: {occurs: [/\.0]}, rows: [{binds: @immut/hashmap.of([]), patterns: [Wildcard], action: Int(3)}]}
// [Knf] default_matrix:
// [Knf] {arity: 0, occurs: {occurs: []}, rows: [{binds: @immut/hashmap.of([]), patterns: [], action: Int(3)}]}
// [Knf] matcher_run: final tree
// [Knf] Switch(/\, 
// [Knf]   [(ctor(Nil, 0), Succeed({}, Int(0))),
// [Knf]   (ctor(Cons, 2), Switch(/\.1, 
// [Knf]     [(ctor(Nil, 0), Switch(/\.0, 
// [Knf]       [(ctor(None, 0), Succeed({}, Int(1))),
// [Knf]       (ctor(Some, 1), Switch(/\.0.0, 
// [Knf]         [(int(2), Succeed({}, Int(2))),
// [Knf]         (fallback, Succeed({}, Int(3)))
// [Knf]       ])),
// [Knf]       (fallback, Succeed({}, Int(3)))
// [Knf]     ])),
// [Knf]     (fallback, Succeed({}, Int(3)))
// [Knf]   ])),
// [Knf]   (fallback, Succeed({}, Int(3)))
// [Knf] ])
// [Knf] decision_tree_to_knf: Switch(/\, 
// [Knf]   [(ctor(Nil, 0), Succeed({}, Int(0))),
// [Knf]   (ctor(Cons, 2), Switch(/\.1, 
// [Knf]     [(ctor(Nil, 0), Switch(/\.0, 
// [Knf]       [(ctor(None, 0), Succeed({}, Int(1))),
// [Knf]       (ctor(Some, 1), Switch(/\.0.0, 
// [Knf]         [(int(2), Succeed({}, Int(2))),
// [Knf]         (fallback, Succeed({}, Int(3)))
// [Knf]       ])),
// [Knf]       (fallback, Succeed({}, Int(3)))
// [Knf]     ])),
// [Knf]     (fallback, Succeed({}, Int(3)))
// [Knf]   ])),
// [Knf]   (fallback, Succeed({}, Int(3)))
// [Knf] ])
// [Knf] decision_tree_to_knf: Succeed({}, Int(0))
// [Knf] decision_tree_to_knf: Switch(/\.1, 
// [Knf]   [(ctor(Nil, 0), Switch(/\.0, 
// [Knf]     [(ctor(None, 0), Succeed({}, Int(1))),
// [Knf]     (ctor(Some, 1), Switch(/\.0.0, 
// [Knf]       [(int(2), Succeed({}, Int(2))),
// [Knf]       (fallback, Succeed({}, Int(3)))
// [Knf]     ])),
// [Knf]     (fallback, Succeed({}, Int(3)))
// [Knf]   ])),
// [Knf]   (fallback, Succeed({}, Int(3)))
// [Knf] ])
// [Knf] decision_tree_to_knf: Switch(/\.0, 
// [Knf]   [(ctor(None, 0), Succeed({}, Int(1))),
// [Knf]   (ctor(Some, 1), Switch(/\.0.0, 
// [Knf]     [(int(2), Succeed({}, Int(2))),
// [Knf]     (fallback, Succeed({}, Int(3)))
// [Knf]   ])),
// [Knf]   (fallback, Succeed({}, Int(3)))
// [Knf] ])
// [Knf] decision_tree_to_knf: Succeed({}, Int(1))
// [Knf] decision_tree_to_knf: Switch(/\.0.0, 
// [Knf]   [(int(2), Succeed({}, Int(2))),
// [Knf]   (fallback, Succeed({}, Int(3)))
// [Knf] ])
// [Knf] decision_tree_to_knf: Succeed({}, Int(2))
// [Knf] decision_tree_to_knf: Succeed({}, Int(3))
// [Knf] decision_tree_to_knf: Succeed({}, Int(3))
// [Knf] decision_tree_to_knf: Succeed({}, Int(3))
// [Knf] decision_tree_to_knf: Succeed({}, Int(3))
// [Knf] matcher_run: init mat
// [Knf] {arity: 1, occurs: {occurs: [/\]}, rows: [{binds: @immut/hashmap.of([]), patterns: [CtorApp("Nil", [])], action: Int(0)}, {binds: @immut/hashmap.of([]), patterns: [CtorApp("Cons", [CtorApp("Some", [Var("v")]), Wildcard])], action: Var("v")}, {binds: @immut/hashmap.of([]), patterns: [Wildcard], action: Int(3)}]}
// [Knf] specialize_matrix: by subpat ctor(Nil, 0), at col 0:
// [Knf] {arity: 0, occurs: {occurs: []}, rows: [{binds: @immut/hashmap.of([]), patterns: [], action: Int(0)}, {binds: @immut/hashmap.of([]), patterns: [], action: Int(3)}]}
// [Knf] specialize_matrix: by subpat ctor(Cons, 2), at col 0:
// [Knf] {arity: 2, occurs: {occurs: [/\.0, /\.1]}, rows: [{binds: @immut/hashmap.of([]), patterns: [CtorApp("Some", [Var("v")]), Wildcard], action: Var("v")}, {binds: @immut/hashmap.of([]), patterns: [Wildcard, Wildcard], action: Int(3)}]}
// [Knf] specialize_matrix: by subpat ctor(Some, 1), at col 0:
// [Knf] {arity: 2, occurs: {occurs: [/\.0.0, /\.1]}, rows: [{binds: @immut/hashmap.of([]), patterns: [Var("v"), Wildcard], action: Var("v")}, {binds: @immut/hashmap.of([]), patterns: [Wildcard, Wildcard], action: Int(3)}]}
// [Knf] default_matrix:
// [Knf] {arity: 1, occurs: {occurs: [/\.1]}, rows: [{binds: @immut/hashmap.of([]), patterns: [Wildcard], action: Int(3)}]}
// [Knf] default_matrix:
// [Knf] {arity: 0, occurs: {occurs: []}, rows: [{binds: @immut/hashmap.of([]), patterns: [], action: Int(3)}]}
// [Knf] matcher_run: final tree
// [Knf] Switch(/\, 
// [Knf]   [(ctor(Nil, 0), Succeed({}, Int(0))),
// [Knf]   (ctor(Cons, 2), Switch(/\.0, 
// [Knf]     [(ctor(Some, 1), Succeed({/\.0.0 -> v, }, Var("v"))),
// [Knf]     (fallback, Succeed({}, Int(3)))
// [Knf]   ])),
// [Knf]   (fallback, Succeed({}, Int(3)))
// [Knf] ])
// [Knf] decision_tree_to_knf: Switch(/\, 
// [Knf]   [(ctor(Nil, 0), Succeed({}, Int(0))),
// [Knf]   (ctor(Cons, 2), Switch(/\.0, 
// [Knf]     [(ctor(Some, 1), Succeed({/\.0.0 -> v, }, Var("v"))),
// [Knf]     (fallback, Succeed({}, Int(3)))
// [Knf]   ])),
// [Knf]   (fallback, Succeed({}, Int(3)))
// [Knf] ])
// [Knf] decision_tree_to_knf: Succeed({}, Int(0))
// [Knf] decision_tree_to_knf: Switch(/\.0, 
// [Knf]   [(ctor(Some, 1), Succeed({/\.0.0 -> v, }, Var("v"))),
// [Knf]   (fallback, Succeed({}, Int(3)))
// [Knf] ])
// [Knf] decision_tree_to_knf: Succeed({/\.0.0 -> v, }, Var("v"))
// [Knf] decision_tree_to_knf: Succeed({}, Int(3))
// [Knf] decision_tree_to_knf: Succeed({}, Int(3))
// [Main] function thunk_main(k) {
// [Main]   function main_1(k) {
// [Main]     const _2 = 0;
// [Main]     const _3 = [];
// [Main]     const p_4 = [_2, _3];
// [Main]     const _5 = 1;
// [Main]     const _6 = 0;
// [Main]     const _7 = [];
// [Main]     const _8 = [_6, _7];
// [Main]     const _9 = 0;
// [Main]     const _10 = [];
// [Main]     const _11 = [_9, _10];
// [Main]     const _12 = [_8, _11];
// [Main]     const q_13 = [_5, _12];
// [Main]     const _14 = 1;
// [Main]     const _15 = 1;
// [Main]     const _16 = 1;
// [Main]     const _17 = [_16];
// [Main]     const _18 = [_15, _17];
// [Main]     const _19 = 0;
// [Main]     const _20 = [];
// [Main]     const _21 = [_19, _20];
// [Main]     const _22 = [_18, _21];
// [Main]     const r_23 = [_14, _22];
// [Main]     const _24 = 2;
// [Main]     const _25 = 1;
// [Main]     function j2(_30) {
// [Main]       const _31 = 0;
// [Main]       const [_32, _33] = r_23;
// [Main]       function j1(t_50) {
// [Main]         const _51 = 0;
// [Main]         const [_52, _53] = r_23;
// [Main]         function j0(w_63) {
// [Main]           const _64 = t_50 + w_63;
// [Main]           return $thunk(() => $external(minimbt_print_int, function (_66) {
// [Main]             return $thunk(() => k(null))
// [Main]           }
// [Main]           , _64))
// [Main]         }
// [Main]         if (_52 === _51) {
// [Main]           const [] = _53;
// [Main]           return $thunk(() => j0(0))
// [Main]         } else {
// [Main]           const _54 = 1;
// [Main]           const [_55, _56] = r_23;
// [Main]           if (_55 === _54) {
// [Main]             const [_57, _58] = _56;
// [Main]             const _59 = 1;
// [Main]             const [_60, _61] = _57;
// [Main]             if (_60 === _59) {
// [Main]               const [_62] = _61;
// [Main]               return $thunk(() => j0(_62))
// [Main]             } else {
// [Main]               return $thunk(() => j0(3))
// [Main]             }
// [Main]           } else {
// [Main]             return $thunk(() => j0(3))
// [Main]           }
// [Main]         }
// [Main]       }
// [Main]       if (_32 === _31) {
// [Main]         const [] = _33;
// [Main]         return $thunk(() => j1(0))
// [Main]       } else {
// [Main]         const _34 = 1;
// [Main]         const [_35, _36] = r_23;
// [Main]         if (_35 === _34) {
// [Main]           const [_37, _38] = _36;
// [Main]           const _39 = 0;
// [Main]           const [_40, _41] = _38;
// [Main]           if (_40 === _39) {
// [Main]             const [] = _41;
// [Main]             const _42 = 0;
// [Main]             const [_43, _44] = _37;
// [Main]             if (_43 === _42) {
// [Main]               const [] = _44;
// [Main]               return $thunk(() => j1(1))
// [Main]             } else {
// [Main]               const _45 = 1;
// [Main]               const [_46, _47] = _37;
// [Main]               if (_46 === _45) {
// [Main]                 const [_48] = _47;
// [Main]                 const _49 = 2;
// [Main]                 if (_48 === _49) {
// [Main]                   return $thunk(() => j1(2))
// [Main]                 } else {
// [Main]                   return $thunk(() => j1(3))
// [Main]                 }
// [Main]               } else {
// [Main]                 return $thunk(() => j1(3))
// [Main]               }
// [Main]             }
// [Main]           } else {
// [Main]             return $thunk(() => j1(3))
// [Main]           }
// [Main]         } else {
// [Main]           return $thunk(() => j1(3))
// [Main]         }
// [Main]       }
// [Main]     }
// [Main]     if (_24 === _25) {
// [Main]       const _26 = 0;
// [Main]       const _27 = [];
// [Main]       return $thunk(() => j2([_26, _27]))
// [Main]     } else {
// [Main]       const _28 = 2;
// [Main]       if (_24 === _28) {
// [Main]         return $thunk(() => j2(q_13))
// [Main]       } else {
// [Main]         return $thunk(() => j2(null))
// [Main]       }
// [Main]     }
// [Main]   }
// [Main]   return $thunk(() => main_1(function (x) {
// [Main]     return $thunk(() => k(x))
// [Main]   }
// [Main]   ))
// [Main] }
// [Main] 
// [Main] function $thunk(lambda) {
// [Main]   return { thunk: lambda };
// [Main] }
// [Main] function $is_thunk(x) {
// [Main]   return x && x.hasOwnProperty('thunk') && x.thunk !== undefined;
// [Main] }
// [Main] function $force(x) {
// [Main]   while ($is_thunk(x)) {
// [Main]     x = x.thunk();
// [Main]   }
// [Main]   return x;
// [Main] }
// [Main] function $external(f, k, ...args) {
// [Main]   let x = f(...args);
// [Main]   return $thunk(() => k(x));
// [Main] }
// [Main] function $trampoline(f, ...args) {
// [Main]   let x = f(...args);
// [Main]   return $force(x);
// [Main] }
// [Main] export default () => $trampoline(thunk_main, x => x);
// [Typer] check: LetEnum("IntOpt", Var(Enum IntOpt { None(), Some(Int) }), LetEnum("IntOptList", Var(Enum IntOptList { Nil(), Cons(IntOpt, IntOptList) }), LetRec({tyvars: [], name: ("main", Var(None)), args: [], body: Let(("p", Var(None)), CtorApp("Nil", []), Let(("q", Var(None)), CtorApp("Cons", [CtorApp("None", []), CtorApp("Nil", [])]), Let(("r", Var(None)), CtorApp("Cons", [CtorApp("Some", [Int(1)]), CtorApp("Nil", [])]), Let(("_", Var(None)), Match(Int(2), [{pat: Int(1), action: CtorApp("Nil", [])}, {pat: Int(2), action: Var("q")}]), Let(("t", Var(None)), Match(Var("r"), [{pat: CtorApp("Nil", []), action: Int(0)}, {pat: CtorApp("Cons", [CtorApp("None", []), CtorApp("Nil", [])]), action: Int(1)}, {pat: CtorApp("Cons", [CtorApp("Some", [Int(2)]), CtorApp("Nil", [])]), action: Int(2)}, {pat: Wildcard, action: Int(3)}]), Let(("w", Var(None)), Match(Var("r"), [{pat: CtorApp("Nil", []), action: Int(0)}, {pat: CtorApp("Cons", [CtorApp("Some", [Var("v")]), Wildcard]), action: Var("v")}, {pat: Wildcard, action: Int(3)}]), Let(("_", Var(None)), App(Var("print_int"), [Prim(Var("t"), Var("w"), Add, kind=None)]), Unit)))))))}, Unit))) against Unit
// [Typer] let enum before resolved: Var(Enum IntOpt { None(), Some(Int) })
// [Typer] let enum after resolved: Var(Var(Enum IntOpt { None(), Some(Int) }))
// [Typer] check: LetEnum("IntOptList", Var(Enum IntOptList { Nil(), Cons(IntOpt, IntOptList) }), LetRec({tyvars: [], name: ("main", Var(None)), args: [], body: Let(("p", Var(None)), CtorApp("Nil", []), Let(("q", Var(None)), CtorApp("Cons", [CtorApp("None", []), CtorApp("Nil", [])]), Let(("r", Var(None)), CtorApp("Cons", [CtorApp("Some", [Int(1)]), CtorApp("Nil", [])]), Let(("_", Var(None)), Match(Int(2), [{pat: Int(1), action: CtorApp("Nil", [])}, {pat: Int(2), action: Var("q")}]), Let(("t", Var(None)), Match(Var("r"), [{pat: CtorApp("Nil", []), action: Int(0)}, {pat: CtorApp("Cons", [CtorApp("None", []), CtorApp("Nil", [])]), action: Int(1)}, {pat: CtorApp("Cons", [CtorApp("Some", [Int(2)]), CtorApp("Nil", [])]), action: Int(2)}, {pat: Wildcard, action: Int(3)}]), Let(("w", Var(None)), Match(Var("r"), [{pat: CtorApp("Nil", []), action: Int(0)}, {pat: CtorApp("Cons", [CtorApp("Some", [Var("v")]), Wildcard]), action: Var("v")}, {pat: Wildcard, action: Int(3)}]), Let(("_", Var(None)), App(Var("print_int"), [Prim(Var("t"), Var("w"), Add, kind=None)]), Unit)))))))}, Unit)) against Unit
// [Typer] let enum before resolved: Var(Enum IntOptList { Nil(), Cons(IntOpt, IntOptList) })
// [Typer] let enum after resolved: Var(Var(Enum IntOptList { Nil(), Cons(Var(Enum IntOpt { None(), Some(Int) }), Var(~0)) }))
// [Typer] check: LetRec({tyvars: [], name: ("main", Var(None)), args: [], body: Let(("p", Var(None)), CtorApp("Nil", []), Let(("q", Var(None)), CtorApp("Cons", [CtorApp("None", []), CtorApp("Nil", [])]), Let(("r", Var(None)), CtorApp("Cons", [CtorApp("Some", [Int(1)]), CtorApp("Nil", [])]), Let(("_", Var(None)), Match(Int(2), [{pat: Int(1), action: CtorApp("Nil", [])}, {pat: Int(2), action: Var("q")}]), Let(("t", Var(None)), Match(Var("r"), [{pat: CtorApp("Nil", []), action: Int(0)}, {pat: CtorApp("Cons", [CtorApp("None", []), CtorApp("Nil", [])]), action: Int(1)}, {pat: CtorApp("Cons", [CtorApp("Some", [Int(2)]), CtorApp("Nil", [])]), action: Int(2)}, {pat: Wildcard, action: Int(3)}]), Let(("w", Var(None)), Match(Var("r"), [{pat: CtorApp("Nil", []), action: Int(0)}, {pat: CtorApp("Cons", [CtorApp("Some", [Var("v")]), Wildcard]), action: Var("v")}, {pat: Wildcard, action: Int(3)}]), Let(("_", Var(None)), App(Var("print_int"), [Prim(Var("t"), Var("w"), Add, kind=None)]), Unit)))))))}, Unit) against Unit
// [Typer] typevars: []
// [Typer] infer: Let(("p", Var(None)), CtorApp("Nil", []), Let(("q", Var(None)), CtorApp("Cons", [CtorApp("None", []), CtorApp("Nil", [])]), Let(("r", Var(None)), CtorApp("Cons", [CtorApp("Some", [Int(1)]), CtorApp("Nil", [])]), Let(("_", Var(None)), Match(Int(2), [{pat: Int(1), action: CtorApp("Nil", [])}, {pat: Int(2), action: Var("q")}]), Let(("t", Var(None)), Match(Var("r"), [{pat: CtorApp("Nil", []), action: Int(0)}, {pat: CtorApp("Cons", [CtorApp("None", []), CtorApp("Nil", [])]), action: Int(1)}, {pat: CtorApp("Cons", [CtorApp("Some", [Int(2)]), CtorApp("Nil", [])]), action: Int(2)}, {pat: Wildcard, action: Int(3)}]), Let(("w", Var(None)), Match(Var("r"), [{pat: CtorApp("Nil", []), action: Int(0)}, {pat: CtorApp("Cons", [CtorApp("Some", [Var("v")]), Wildcard]), action: Var("v")}, {pat: Wildcard, action: Int(3)}]), Let(("_", Var(None)), App(Var("print_int"), [Prim(Var("t"), Var("w"), Add, kind=None)]), Unit)))))))
// [Typer] infer: CtorApp("Nil", [])
// [Typer] inst: TypeScheme(([], () -> Var(Enum IntOptList { Nil(), Cons(Var(Enum IntOpt { None(), Some(Int) }), Var(~0)) })))
// [Typer] inst result: () -> Var(Enum IntOptList { Nil(), Cons(Var(Enum IntOpt { None(), Some(Int) }), Var(~0)) })
// [Typer] unify: Var(None) and Var(Enum IntOptList { Nil(), Cons(Var(Enum IntOpt { None(), Some(Int) }), Var(~0)) })
// [Typer] union: Var(None) and Enum IntOptList { Nil(), Cons(Var(Enum IntOpt { None(), Some(Int) }), Var(Enum IntOptList { Nil(), Cons(Var(~0), Var(~1)) })) }
// [Typer] infer: Let(("q", Var(None)), CtorApp("Cons", [CtorApp("None", []), CtorApp("Nil", [])]), Let(("r", Var(None)), CtorApp("Cons", [CtorApp("Some", [Int(1)]), CtorApp("Nil", [])]), Let(("_", Var(None)), Match(Int(2), [{pat: Int(1), action: CtorApp("Nil", [])}, {pat: Int(2), action: Var("q")}]), Let(("t", Var(None)), Match(Var("r"), [{pat: CtorApp("Nil", []), action: Int(0)}, {pat: CtorApp("Cons", [CtorApp("None", []), CtorApp("Nil", [])]), action: Int(1)}, {pat: CtorApp("Cons", [CtorApp("Some", [Int(2)]), CtorApp("Nil", [])]), action: Int(2)}, {pat: Wildcard, action: Int(3)}]), Let(("w", Var(None)), Match(Var("r"), [{pat: CtorApp("Nil", []), action: Int(0)}, {pat: CtorApp("Cons", [CtorApp("Some", [Var("v")]), Wildcard]), action: Var("v")}, {pat: Wildcard, action: Int(3)}]), Let(("_", Var(None)), App(Var("print_int"), [Prim(Var("t"), Var("w"), Add, kind=None)]), Unit))))))
// [Typer] infer: CtorApp("Cons", [CtorApp("None", []), CtorApp("Nil", [])])
// [Typer] inst: TypeScheme(([], (Var(Enum IntOpt { None(), Some(Int) }), Var(Enum IntOptList { Nil(), Cons(Var(~0), Var(~1)) })) -> Var(~1)))
// [Typer] inst result: (Var(Enum IntOpt { None(), Some(Int) }), Var(Enum IntOptList { Nil(), Cons(Var(~0), Var(~1)) })) -> Enum IntOptList { Nil(), Cons(Var(~0), Var(~1)) }
// [Typer] check: CtorApp("None", []) against Var(Enum IntOpt { None(), Some(Int) })
// [Typer] inst: TypeScheme(([], () -> Var(Enum IntOpt { None(), Some(Int) })))
// [Typer] inst result: () -> Var(Enum IntOpt { None(), Some(Int) })
// [Typer] unify: () -> Var(Enum IntOpt { None(), Some(Int) }) and () -> Enum IntOpt { None(), Some(Int) }
// [Typer] unify: Var(Enum IntOpt { None(), Some(Int) }) and Enum IntOpt { None(), Some(Int) }
// [Typer] check: CtorApp("Nil", []) against Var(Enum IntOptList { Nil(), Cons(Var(Enum IntOpt { None(), Some(Int) }), Var(~0)) })
// [Typer] inst: TypeScheme(([], () -> Var(Enum IntOptList { Nil(), Cons(Var(Enum IntOpt { None(), Some(Int) }), Var(~0)) })))
// [Typer] inst result: () -> Var(Enum IntOptList { Nil(), Cons(Var(Enum IntOpt { None(), Some(Int) }), Var(~0)) })
// [Typer] unify: () -> Var(Enum IntOptList { Nil(), Cons(Var(Enum IntOpt { None(), Some(Int) }), Var(~0)) }) and () -> Enum IntOptList { Nil(), Cons(Var(Enum IntOpt { None(), Some(Int) }), Var(Enum IntOptList { Nil(), Cons(Var(~0), Var(~1)) })) }
// [Typer] unify: Var(Enum IntOptList { Nil(), Cons(Var(Enum IntOpt { None(), Some(Int) }), Var(~0)) }) and Enum IntOptList { Nil(), Cons(Var(Enum IntOpt { None(), Some(Int) }), Var(Enum IntOptList { Nil(), Cons(Var(~0), Var(~1)) })) }
// [Typer] unify: Var(None) and Enum IntOptList { Nil(), Cons(Var(Enum IntOpt { None(), Some(Int) }), Var(Enum IntOptList { Nil(), Cons(Var(~0), Var(~1)) })) }
// [Typer] union: Var(None) and Enum IntOptList { Nil(), Cons(Var(Enum IntOpt { None(), Some(Int) }), Var(Enum IntOptList { Nil(), Cons(Var(~0), Var(~1)) })) }
// [Typer] infer: Let(("r", Var(None)), CtorApp("Cons", [CtorApp("Some", [Int(1)]), CtorApp("Nil", [])]), Let(("_", Var(None)), Match(Int(2), [{pat: Int(1), action: CtorApp("Nil", [])}, {pat: Int(2), action: Var("q")}]), Let(("t", Var(None)), Match(Var("r"), [{pat: CtorApp("Nil", []), action: Int(0)}, {pat: CtorApp("Cons", [CtorApp("None", []), CtorApp("Nil", [])]), action: Int(1)}, {pat: CtorApp("Cons", [CtorApp("Some", [Int(2)]), CtorApp("Nil", [])]), action: Int(2)}, {pat: Wildcard, action: Int(3)}]), Let(("w", Var(None)), Match(Var("r"), [{pat: CtorApp("Nil", []), action: Int(0)}, {pat: CtorApp("Cons", [CtorApp("Some", [Var("v")]), Wildcard]), action: Var("v")}, {pat: Wildcard, action: Int(3)}]), Let(("_", Var(None)), App(Var("print_int"), [Prim(Var("t"), Var("w"), Add, kind=None)]), Unit)))))
// [Typer] infer: CtorApp("Cons", [CtorApp("Some", [Int(1)]), CtorApp("Nil", [])])
// [Typer] inst: TypeScheme(([], (Var(Enum IntOpt { None(), Some(Int) }), Var(Enum IntOptList { Nil(), Cons(Var(~0), Var(~1)) })) -> Var(~1)))
// [Typer] inst result: (Var(Enum IntOpt { None(), Some(Int) }), Var(Enum IntOptList { Nil(), Cons(Var(~0), Var(~1)) })) -> Enum IntOptList { Nil(), Cons(Var(~0), Var(~1)) }
// [Typer] check: CtorApp("Some", [Int(1)]) against Var(Enum IntOpt { None(), Some(Int) })
// [Typer] infer: Int(1)
// [Typer] inst: TypeScheme(([], (Int) -> Var(Enum IntOpt { None(), Some(Int) })))
// [Typer] inst result: (Int) -> Var(Enum IntOpt { None(), Some(Int) })
// [Typer] unify: (Int) -> Var(Enum IntOpt { None(), Some(Int) }) and (Int) -> Enum IntOpt { None(), Some(Int) }
// [Typer] unify: Int and Int
// [Typer] unify: Var(Enum IntOpt { None(), Some(Int) }) and Enum IntOpt { None(), Some(Int) }
// [Typer] check: CtorApp("Nil", []) against Var(Enum IntOptList { Nil(), Cons(Var(Enum IntOpt { None(), Some(Int) }), Var(~0)) })
// [Typer] inst: TypeScheme(([], () -> Var(Enum IntOptList { Nil(), Cons(Var(Enum IntOpt { None(), Some(Int) }), Var(~0)) })))
// [Typer] inst result: () -> Var(Enum IntOptList { Nil(), Cons(Var(Enum IntOpt { None(), Some(Int) }), Var(~0)) })
// [Typer] unify: () -> Var(Enum IntOptList { Nil(), Cons(Var(Enum IntOpt { None(), Some(Int) }), Var(~0)) }) and () -> Enum IntOptList { Nil(), Cons(Var(Enum IntOpt { None(), Some(Int) }), Var(Enum IntOptList { Nil(), Cons(Var(~0), Var(~1)) })) }
// [Typer] unify: Var(Enum IntOptList { Nil(), Cons(Var(Enum IntOpt { None(), Some(Int) }), Var(~0)) }) and Enum IntOptList { Nil(), Cons(Var(Enum IntOpt { None(), Some(Int) }), Var(Enum IntOptList { Nil(), Cons(Var(~0), Var(~1)) })) }
// [Typer] unify: Var(None) and Enum IntOptList { Nil(), Cons(Var(Enum IntOpt { None(), Some(Int) }), Var(Enum IntOptList { Nil(), Cons(Var(~0), Var(~1)) })) }
// [Typer] union: Var(None) and Enum IntOptList { Nil(), Cons(Var(Enum IntOpt { None(), Some(Int) }), Var(Enum IntOptList { Nil(), Cons(Var(~0), Var(~1)) })) }
// [Typer] infer: Let(("_", Var(None)), Match(Int(2), [{pat: Int(1), action: CtorApp("Nil", [])}, {pat: Int(2), action: Var("q")}]), Let(("t", Var(None)), Match(Var("r"), [{pat: CtorApp("Nil", []), action: Int(0)}, {pat: CtorApp("Cons", [CtorApp("None", []), CtorApp("Nil", [])]), action: Int(1)}, {pat: CtorApp("Cons", [CtorApp("Some", [Int(2)]), CtorApp("Nil", [])]), action: Int(2)}, {pat: Wildcard, action: Int(3)}]), Let(("w", Var(None)), Match(Var("r"), [{pat: CtorApp("Nil", []), action: Int(0)}, {pat: CtorApp("Cons", [CtorApp("Some", [Var("v")]), Wildcard]), action: Var("v")}, {pat: Wildcard, action: Int(3)}]), Let(("_", Var(None)), App(Var("print_int"), [Prim(Var("t"), Var("w"), Add, kind=None)]), Unit))))
// [Typer] infer: Match(Int(2), [{pat: Int(1), action: CtorApp("Nil", [])}, {pat: Int(2), action: Var("q")}])
// [Typer] infer: Int(2)
// [Typer] unify: Int and Int
// [Typer] infer: CtorApp("Nil", [])
// [Typer] inst: TypeScheme(([], () -> Var(Enum IntOptList { Nil(), Cons(Var(Enum IntOpt { None(), Some(Int) }), Var(~0)) })))
// [Typer] inst result: () -> Var(Enum IntOptList { Nil(), Cons(Var(Enum IntOpt { None(), Some(Int) }), Var(~0)) })
// [Typer] unify: Int and Int
// [Typer] infer: Var("q")
// [Typer] inst: TypeScheme(([], Var(Enum IntOptList { Nil(), Cons(Var(Enum IntOpt { None(), Some(Int) }), Var(~0)) })))
// [Typer] inst result: Enum IntOptList { Nil(), Cons(Var(Enum IntOpt { None(), Some(Int) }), Var(Enum IntOptList { Nil(), Cons(Var(~0), Var(~1)) })) }
// [Typer] unify: Var(Enum IntOptList { Nil(), Cons(Var(Enum IntOpt { None(), Some(Int) }), Var(~0)) }) and Enum IntOptList { Nil(), Cons(Var(Enum IntOpt { None(), Some(Int) }), Var(Enum IntOptList { Nil(), Cons(Var(~0), Var(~1)) })) }
// [Typer] unify: Enum IntOptList { Nil(), Cons(Var(Enum IntOpt { None(), Some(Int) }), Var(Enum IntOptList { Nil(), Cons(Var(~0), Var(~1)) })) } and Var(Enum IntOptList { Nil(), Cons(Var(Enum IntOpt { None(), Some(Int) }), Var(~0)) })
// [Typer] unify: Var(None) and Var(Enum IntOptList { Nil(), Cons(Var(Enum IntOpt { None(), Some(Int) }), Var(~0)) })
// [Typer] union: Var(None) and Enum IntOptList { Nil(), Cons(Var(Enum IntOpt { None(), Some(Int) }), Var(Enum IntOptList { Nil(), Cons(Var(~0), Var(~1)) })) }
// [Typer] infer: Let(("t", Var(None)), Match(Var("r"), [{pat: CtorApp("Nil", []), action: Int(0)}, {pat: CtorApp("Cons", [CtorApp("None", []), CtorApp("Nil", [])]), action: Int(1)}, {pat: CtorApp("Cons", [CtorApp("Some", [Int(2)]), CtorApp("Nil", [])]), action: Int(2)}, {pat: Wildcard, action: Int(3)}]), Let(("w", Var(None)), Match(Var("r"), [{pat: CtorApp("Nil", []), action: Int(0)}, {pat: CtorApp("Cons", [CtorApp("Some", [Var("v")]), Wildcard]), action: Var("v")}, {pat: Wildcard, action: Int(3)}]), Let(("_", Var(None)), App(Var("print_int"), [Prim(Var("t"), Var("w"), Add, kind=None)]), Unit)))
// [Typer] infer: Match(Var("r"), [{pat: CtorApp("Nil", []), action: Int(0)}, {pat: CtorApp("Cons", [CtorApp("None", []), CtorApp("Nil", [])]), action: Int(1)}, {pat: CtorApp("Cons", [CtorApp("Some", [Int(2)]), CtorApp("Nil", [])]), action: Int(2)}, {pat: Wildcard, action: Int(3)}])
// [Typer] infer: Var("r")
// [Typer] inst: TypeScheme(([], Var(Enum IntOptList { Nil(), Cons(Var(Enum IntOpt { None(), Some(Int) }), Var(~0)) })))
// [Typer] inst result: Enum IntOptList { Nil(), Cons(Var(Enum IntOpt { None(), Some(Int) }), Var(Enum IntOptList { Nil(), Cons(Var(~0), Var(~1)) })) }
// [Typer] inst: TypeScheme(([], () -> Var(Enum IntOptList { Nil(), Cons(Var(Enum IntOpt { None(), Some(Int) }), Var(~0)) })))
// [Typer] inst result: () -> Var(Enum IntOptList { Nil(), Cons(Var(Enum IntOpt { None(), Some(Int) }), Var(~0)) })
// [Typer] unify: Enum IntOptList { Nil(), Cons(Var(Enum IntOpt { None(), Some(Int) }), Var(Enum IntOptList { Nil(), Cons(Var(~0), Var(~1)) })) } and Var(Enum IntOptList { Nil(), Cons(Var(Enum IntOpt { None(), Some(Int) }), Var(~0)) })
// [Typer] infer: Int(0)
// [Typer] inst: TypeScheme(([], (Var(Enum IntOpt { None(), Some(Int) }), Var(Enum IntOptList { Nil(), Cons(Var(~0), Var(~1)) })) -> Var(~1)))
// [Typer] inst result: (Var(Enum IntOpt { None(), Some(Int) }), Var(Enum IntOptList { Nil(), Cons(Var(~0), Var(~1)) })) -> Enum IntOptList { Nil(), Cons(Var(~0), Var(~1)) }
// [Typer] unify: Enum IntOptList { Nil(), Cons(Var(Enum IntOpt { None(), Some(Int) }), Var(Enum IntOptList { Nil(), Cons(Var(~0), Var(~1)) })) } and Enum IntOptList { Nil(), Cons(Var(Enum IntOpt { None(), Some(Int) }), Var(Enum IntOptList { Nil(), Cons(Var(~0), Var(~1)) })) }
// [Typer] inst: TypeScheme(([], () -> Var(Enum IntOpt { None(), Some(Int) })))
// [Typer] inst result: () -> Var(Enum IntOpt { None(), Some(Int) })
// [Typer] unify: Var(Enum IntOpt { None(), Some(Int) }) and Var(Enum IntOpt { None(), Some(Int) })
// [Typer] inst: TypeScheme(([], () -> Var(Enum IntOptList { Nil(), Cons(Var(Enum IntOpt { None(), Some(Int) }), Var(~0)) })))
// [Typer] inst result: () -> Var(Enum IntOptList { Nil(), Cons(Var(Enum IntOpt { None(), Some(Int) }), Var(~0)) })
// [Typer] unify: Var(Enum IntOptList { Nil(), Cons(Var(Enum IntOpt { None(), Some(Int) }), Var(~0)) }) and Var(Enum IntOptList { Nil(), Cons(Var(Enum IntOpt { None(), Some(Int) }), Var(~0)) })
// [Typer] infer: Int(1)
// [Typer] inst: TypeScheme(([], (Var(Enum IntOpt { None(), Some(Int) }), Var(Enum IntOptList { Nil(), Cons(Var(~0), Var(~1)) })) -> Var(~1)))
// [Typer] inst result: (Var(Enum IntOpt { None(), Some(Int) }), Var(Enum IntOptList { Nil(), Cons(Var(~0), Var(~1)) })) -> Enum IntOptList { Nil(), Cons(Var(~0), Var(~1)) }
// [Typer] unify: Enum IntOptList { Nil(), Cons(Var(Enum IntOpt { None(), Some(Int) }), Var(Enum IntOptList { Nil(), Cons(Var(~0), Var(~1)) })) } and Enum IntOptList { Nil(), Cons(Var(Enum IntOpt { None(), Some(Int) }), Var(Enum IntOptList { Nil(), Cons(Var(~0), Var(~1)) })) }
// [Typer] inst: TypeScheme(([], (Int) -> Var(Enum IntOpt { None(), Some(Int) })))
// [Typer] inst result: (Int) -> Var(Enum IntOpt { None(), Some(Int) })
// [Typer] unify: Var(Enum IntOpt { None(), Some(Int) }) and Var(Enum IntOpt { None(), Some(Int) })
// [Typer] unify: Int and Int
// [Typer] inst: TypeScheme(([], () -> Var(Enum IntOptList { Nil(), Cons(Var(Enum IntOpt { None(), Some(Int) }), Var(~0)) })))
// [Typer] inst result: () -> Var(Enum IntOptList { Nil(), Cons(Var(Enum IntOpt { None(), Some(Int) }), Var(~0)) })
// [Typer] unify: Var(Enum IntOptList { Nil(), Cons(Var(Enum IntOpt { None(), Some(Int) }), Var(~0)) }) and Var(Enum IntOptList { Nil(), Cons(Var(Enum IntOpt { None(), Some(Int) }), Var(~0)) })
// [Typer] infer: Int(2)
// [Typer] infer: Int(3)
// [Typer] unify: Int and Int
// [Typer] unify: Int and Int
// [Typer] unify: Int and Int
// [Typer] unify: Int and Int
// [Typer] unify: Var(None) and Int
// [Typer] union: Var(None) and Int
// [Typer] infer: Let(("w", Var(None)), Match(Var("r"), [{pat: CtorApp("Nil", []), action: Int(0)}, {pat: CtorApp("Cons", [CtorApp("Some", [Var("v")]), Wildcard]), action: Var("v")}, {pat: Wildcard, action: Int(3)}]), Let(("_", Var(None)), App(Var("print_int"), [Prim(Var("t"), Var("w"), Add, kind=None)]), Unit))
// [Typer] infer: Match(Var("r"), [{pat: CtorApp("Nil", []), action: Int(0)}, {pat: CtorApp("Cons", [CtorApp("Some", [Var("v")]), Wildcard]), action: Var("v")}, {pat: Wildcard, action: Int(3)}])
// [Typer] infer: Var("r")
// [Typer] inst: TypeScheme(([], Var(Enum IntOptList { Nil(), Cons(Var(Enum IntOpt { None(), Some(Int) }), Var(~0)) })))
// [Typer] inst result: Enum IntOptList { Nil(), Cons(Var(Enum IntOpt { None(), Some(Int) }), Var(Enum IntOptList { Nil(), Cons(Var(~0), Var(~1)) })) }
// [Typer] inst: TypeScheme(([], () -> Var(Enum IntOptList { Nil(), Cons(Var(Enum IntOpt { None(), Some(Int) }), Var(~0)) })))
// [Typer] inst result: () -> Var(Enum IntOptList { Nil(), Cons(Var(Enum IntOpt { None(), Some(Int) }), Var(~0)) })
// [Typer] unify: Enum IntOptList { Nil(), Cons(Var(Enum IntOpt { None(), Some(Int) }), Var(Enum IntOptList { Nil(), Cons(Var(~0), Var(~1)) })) } and Var(Enum IntOptList { Nil(), Cons(Var(Enum IntOpt { None(), Some(Int) }), Var(~0)) })
// [Typer] infer: Int(0)
// [Typer] inst: TypeScheme(([], (Var(Enum IntOpt { None(), Some(Int) }), Var(Enum IntOptList { Nil(), Cons(Var(~0), Var(~1)) })) -> Var(~1)))
// [Typer] inst result: (Var(Enum IntOpt { None(), Some(Int) }), Var(Enum IntOptList { Nil(), Cons(Var(~0), Var(~1)) })) -> Enum IntOptList { Nil(), Cons(Var(~0), Var(~1)) }
// [Typer] unify: Enum IntOptList { Nil(), Cons(Var(Enum IntOpt { None(), Some(Int) }), Var(Enum IntOptList { Nil(), Cons(Var(~0), Var(~1)) })) } and Enum IntOptList { Nil(), Cons(Var(Enum IntOpt { None(), Some(Int) }), Var(Enum IntOptList { Nil(), Cons(Var(~0), Var(~1)) })) }
// [Typer] inst: TypeScheme(([], (Int) -> Var(Enum IntOpt { None(), Some(Int) })))
// [Typer] inst result: (Int) -> Var(Enum IntOpt { None(), Some(Int) })
// [Typer] unify: Var(Enum IntOpt { None(), Some(Int) }) and Var(Enum IntOpt { None(), Some(Int) })
// [Typer] infer: Var("v")
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] infer: Int(3)
// [Typer] unify: Int and Int
// [Typer] unify: Int and Int
// [Typer] unify: Int and Int
// [Typer] unify: Var(None) and Int
// [Typer] union: Var(None) and Int
// [Typer] infer: Let(("_", Var(None)), App(Var("print_int"), [Prim(Var("t"), Var("w"), Add, kind=None)]), Unit)
// [Typer] infer: App(Var("print_int"), [Prim(Var("t"), Var("w"), Add, kind=None)])
// [Typer] infer: Var("print_int")
// [Typer] inst: TypeScheme(([], (Int) -> Unit))
// [Typer] inst result: (Int) -> Unit
// [Typer] check: Prim(Var("t"), Var("w"), Add, kind=None) against Int
// [Typer] check: Var("t") against Int
// [Typer] inst: TypeScheme(([], Var(Int)))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] check: Var("w") against Int
// [Typer] inst: TypeScheme(([], Var(Int)))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] unify: Var(None) and Unit
// [Typer] union: Var(None) and Unit
// [Typer] infer: Unit
// [Typer] unify: Unit and Var(None)
// [Typer] union: Unit and Var(None)
// [Typer] check: Unit against Unit
// [Parser] flags: []
