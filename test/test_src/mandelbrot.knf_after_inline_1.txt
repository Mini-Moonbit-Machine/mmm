let rec main.60: Var({val: Some(Unit)}) = () {
  let _61: Int = Int(40)
  let rec dbl.424: Double = (f.425: Double) {
    FAdd(f.425, f.425)
  }
  let _493: Int = Int(0)
  let join yloop.646: Unit = (y.647: Int) {
    if (_61 <= y.647) then {
      Unit
    } else {
      let rec xloop.648: Unit = (x.649: Int, y.650: Int) {
        let join xloop.651: Unit = (x.652: Int, y.653: Int) {
          if (_61 <= x.652) then {
            let _654: Unit = ExtApply(minimbt_print_endline, [])
            Unit
          } else {
            let _655: Double = ExtApply(minimbt_float_of_int, [x.652, ])
            let _656: Double = Apply(dbl.424, [_655, ])
            let _657: Double = ExtApply(minimbt_float_of_int, [_61, ])
            let _658: Double = FDiv(_656, _657)
            let _659: Double = Double(1.5)
            let cr.660: Double = FSub(_658, _659)
            let _661: Double = ExtApply(minimbt_float_of_int, [y.653, ])
            let _662: Double = Apply(dbl.424, [_661, ])
            let _663: Double = ExtApply(minimbt_float_of_int, [_61, ])
            let _664: Double = FDiv(_662, _663)
            let _665: Double = Double(1)
            let ci.666: Double = FSub(_664, _665)
            let rec iloop.667: Unit = (i.668: Int, zr.669: Double, zi.670: Double, zr2.671: Double, zi2.672: Double, cr.673: Double, ci.674: Double) {
              let join iloop.675: Unit = (i.676: Int, zr.677: Double, zi.678: Double, zr2.679: Double, zi2.680: Double, cr.681: Double, ci.682: Double) {
                let _683: Int = Int(0)
                if (i.676 == _683) then {
                  let _684: Int = Int(1)
                  ExtApply(minimbt_print_int, [_684, ])
                } else {
                  let _685: Double = FSub(zr2.679, zi2.680)
                  let tr.686: Double = FAdd(_685, cr.681)
                  let _687: Double = Apply(dbl.424, [zr.677, ])
                  let _688: Double = FMul(_687, zi.678)
                  let ti.689: Double = FAdd(_688, ci.682)
                  let zr2.690: Double = FMul(tr.686, tr.686)
                  let zi2.691: Double = FMul(ti.689, ti.689)
                  let _692: Double = Double(2)
                  let _693: Double = Double(2)
                  let _694: Double = FMul(_692, _693)
                  let _695: Double = FAdd(zr2.690, zi2.691)
                  if (_694 <= _695) then {
                    let _696: Int = Int(0)
                    ExtApply(minimbt_print_int, [_696, ])
                  } else {
                    let _697: Int = Int(1)
                    let _698: Int = Sub(i.676, _697)
                    Jump(iloop.675, [_698, tr.686, ti.689, zr2.690, zi2.691, cr.681, ci.682, ])
                  }
                }
              }
              Jump(iloop.675, [i.668, zr.669, zi.670, zr2.671, zi2.672, cr.673, ci.674, ])
            }
            let _699: Int = Int(1000)
            let _700: Double = Double(0)
            let _701: Double = Double(0)
            let _702: Double = Double(0)
            let _703: Double = Double(0)
            let _704: Unit = Apply(iloop.667, [_699, _700, _701, _702, _703, cr.660, ci.666, ])
            let _705: Int = Int(1)
            let _706: Int = Add(x.652, _705)
            Jump(xloop.651, [_706, y.653, ])
          }
        }
        Jump(xloop.651, [x.649, y.650, ])
      }
      let _707: Int = Int(0)
      let _708: Unit = Apply(xloop.648, [_707, y.647, ])
      let _709: Int = Int(1)
      let _710: Int = Add(y.647, _709)
      Jump(yloop.646, [_710, ])
    }
  }
  Jump(yloop.646, [_493, ])
}
Apply(main.60, [])