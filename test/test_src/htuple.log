// [Main] function thunk_main(k) {
// [Main]   function return_i_d_1(k) {
// [Main]     const _2 = 1;
// [Main]     const _3 = 2;
// [Main]     return k([_2, _3])
// [Main]   }
// [Main]   function return_i_d_i_4(k) {
// [Main]     const _5 = 1;
// [Main]     const _6 = 2;
// [Main]     const _7 = 3;
// [Main]     return k([_5, _6, _7])
// [Main]   }
// [Main]   function return_d_i_i_8(k) {
// [Main]     const _9 = 2;
// [Main]     const _10 = 3;
// [Main]     const _11 = 4;
// [Main]     return k([_9, _10, _11])
// [Main]   }
// [Main]   function return_i_i_i_12(k) {
// [Main]     const _13 = 1;
// [Main]     const _14 = 2;
// [Main]     const _15 = 3;
// [Main]     return k([_13, _14, _15])
// [Main]   }
// [Main]   function main_16(k) {
// [Main]     return $thunk(() => return_i_d_1(function (_17) {
// [Main]       const [i_19, d_21] = _17;const _23 = minimbt_print_int($force(i_19));
// [Main]       const _24 = minimbt_int_of_float($force(d_21));
// [Main]       const _26 = minimbt_print_int($force(_24));
// [Main]       return $thunk(() => return_i_d_i_4(function (_27) {
// [Main]         const [i_29, d_31, i2_33] = _27;const _35 = minimbt_print_int($force(i_29));
// [Main]         const _36 = minimbt_int_of_float($force(d_31));
// [Main]         const _38 = minimbt_print_int($force(_36));
// [Main]         const _40 = minimbt_print_int($force(i2_33));
// [Main]         return $thunk(() => return_d_i_i_8(function (_41) {
// [Main]           const [d_43, i_45, i2_47] = _41;const _48 = minimbt_int_of_float($force(d_43));
// [Main]           const _50 = minimbt_print_int($force(_48));
// [Main]           const _52 = minimbt_print_int($force(i_45));
// [Main]           const _54 = minimbt_print_int($force(i2_47));
// [Main]           return $thunk(() => return_i_i_i_12(function (_55) {
// [Main]             const [i_57, i2_59, i3_61] = _55;const _63 = minimbt_print_int($force(i_57));
// [Main]             const _65 = minimbt_print_int($force(i2_59));
// [Main]             const _67 = minimbt_print_int($force(i3_61));
// [Main]             return $thunk(() => $thunk(() => $thunk(() => $thunk(() => k(null)))))
// [Main]           }
// [Main]           ))
// [Main]         }
// [Main]         ))
// [Main]       }
// [Main]       ))
// [Main]     }
// [Main]     ))
// [Main]   }
// [Main]   return $thunk(() => main_16(k))
// [Main] }
// [Main] 
// [Main] function $thunk(lambda) {
// [Main]   return { thunk: lambda };
// [Main] }
// [Main] function $is_thunk(x) {
// [Main]   return x && x.hasOwnProperty('thunk') && x.thunk !== undefined;
// [Main] }
// [Main] function $force(x) {
// [Main]   while ($is_thunk(x)) {
// [Main]     x = x.thunk();
// [Main]   }
// [Main]   return x;
// [Main] }
// [Main] function $trampoline(f, ...args) {
// [Main]   let x = f(...args);
// [Main]   return $force(x);
// [Main] }
// [Main] export default () => $trampoline(thunk_main, x => x);
// [Typer] check: LetRec({tyvars: [], name: ("return_i_d", Tuple([Int, Double])), args: [], body: Tuple([Int(1), Double(2)])}, LetRec({tyvars: [], name: ("return_i_d_i", Tuple([Int, Double, Int])), args: [], body: Tuple([Int(1), Double(2), Int(3)])}, LetRec({tyvars: [], name: ("return_d_i_i", Tuple([Double, Int, Int])), args: [], body: Tuple([Double(2), Int(3), Int(4)])}, LetRec({tyvars: [], name: ("return_i_i_i", Tuple([Int, Int, Int])), args: [], body: Tuple([Int(1), Int(2), Int(3)])}, LetRec({tyvars: [], name: ("main", Var({val: None})), args: [], body: LetTuple([("i", Var({val: None})), ("d", Var({val: None}))], App(Var("return_i_d"), []), Let(("_", Var({val: None})), App(Var("print_int"), [Var("i")]), Let(("_", Var({val: None})), App(Var("print_int"), [App(Var("int_of_float"), [Var("d")])]), LetTuple([("i", Var({val: None})), ("d", Var({val: None})), ("i2", Var({val: None}))], App(Var("return_i_d_i"), []), Let(("_", Var({val: None})), App(Var("print_int"), [Var("i")]), Let(("_", Var({val: None})), App(Var("print_int"), [App(Var("int_of_float"), [Var("d")])]), Let(("_", Var({val: None})), App(Var("print_int"), [Var("i2")]), LetTuple([("d", Var({val: None})), ("i", Var({val: None})), ("i2", Var({val: None}))], App(Var("return_d_i_i"), []), Let(("_", Var({val: None})), App(Var("print_int"), [App(Var("int_of_float"), [Var("d")])]), Let(("_", Var({val: None})), App(Var("print_int"), [Var("i")]), Let(("_", Var({val: None})), App(Var("print_int"), [Var("i2")]), LetTuple([("i", Var({val: None})), ("i2", Var({val: None})), ("i3", Var({val: None}))], App(Var("return_i_i_i"), []), Let(("_", Var({val: None})), App(Var("print_int"), [Var("i")]), Let(("_", Var({val: None})), App(Var("print_int"), [Var("i2")]), Let(("_", Var({val: None})), App(Var("print_int"), [Var("i3")]), Unit)))))))))))))))}, Unit))))) against Unit
// [Typer] typevars: []
// [Typer] check: Tuple([Int(1), Double(2)]) against Tuple([Int, Double])
// [Typer] check: Int(1) against Int
// [Typer] check: Double(2) against Double
// [Typer] check: LetRec({tyvars: [], name: ("return_i_d_i", Tuple([Int, Double, Int])), args: [], body: Tuple([Int(1), Double(2), Int(3)])}, LetRec({tyvars: [], name: ("return_d_i_i", Tuple([Double, Int, Int])), args: [], body: Tuple([Double(2), Int(3), Int(4)])}, LetRec({tyvars: [], name: ("return_i_i_i", Tuple([Int, Int, Int])), args: [], body: Tuple([Int(1), Int(2), Int(3)])}, LetRec({tyvars: [], name: ("main", Var({val: None})), args: [], body: LetTuple([("i", Var({val: None})), ("d", Var({val: None}))], App(Var("return_i_d"), []), Let(("_", Var({val: None})), App(Var("print_int"), [Var("i")]), Let(("_", Var({val: None})), App(Var("print_int"), [App(Var("int_of_float"), [Var("d")])]), LetTuple([("i", Var({val: None})), ("d", Var({val: None})), ("i2", Var({val: None}))], App(Var("return_i_d_i"), []), Let(("_", Var({val: None})), App(Var("print_int"), [Var("i")]), Let(("_", Var({val: None})), App(Var("print_int"), [App(Var("int_of_float"), [Var("d")])]), Let(("_", Var({val: None})), App(Var("print_int"), [Var("i2")]), LetTuple([("d", Var({val: None})), ("i", Var({val: None})), ("i2", Var({val: None}))], App(Var("return_d_i_i"), []), Let(("_", Var({val: None})), App(Var("print_int"), [App(Var("int_of_float"), [Var("d")])]), Let(("_", Var({val: None})), App(Var("print_int"), [Var("i")]), Let(("_", Var({val: None})), App(Var("print_int"), [Var("i2")]), LetTuple([("i", Var({val: None})), ("i2", Var({val: None})), ("i3", Var({val: None}))], App(Var("return_i_i_i"), []), Let(("_", Var({val: None})), App(Var("print_int"), [Var("i")]), Let(("_", Var({val: None})), App(Var("print_int"), [Var("i2")]), Let(("_", Var({val: None})), App(Var("print_int"), [Var("i3")]), Unit)))))))))))))))}, Unit)))) against Unit
// [Typer] typevars: []
// [Typer] check: Tuple([Int(1), Double(2), Int(3)]) against Tuple([Int, Double, Int])
// [Typer] check: Int(1) against Int
// [Typer] check: Double(2) against Double
// [Typer] check: Int(3) against Int
// [Typer] check: LetRec({tyvars: [], name: ("return_d_i_i", Tuple([Double, Int, Int])), args: [], body: Tuple([Double(2), Int(3), Int(4)])}, LetRec({tyvars: [], name: ("return_i_i_i", Tuple([Int, Int, Int])), args: [], body: Tuple([Int(1), Int(2), Int(3)])}, LetRec({tyvars: [], name: ("main", Var({val: None})), args: [], body: LetTuple([("i", Var({val: None})), ("d", Var({val: None}))], App(Var("return_i_d"), []), Let(("_", Var({val: None})), App(Var("print_int"), [Var("i")]), Let(("_", Var({val: None})), App(Var("print_int"), [App(Var("int_of_float"), [Var("d")])]), LetTuple([("i", Var({val: None})), ("d", Var({val: None})), ("i2", Var({val: None}))], App(Var("return_i_d_i"), []), Let(("_", Var({val: None})), App(Var("print_int"), [Var("i")]), Let(("_", Var({val: None})), App(Var("print_int"), [App(Var("int_of_float"), [Var("d")])]), Let(("_", Var({val: None})), App(Var("print_int"), [Var("i2")]), LetTuple([("d", Var({val: None})), ("i", Var({val: None})), ("i2", Var({val: None}))], App(Var("return_d_i_i"), []), Let(("_", Var({val: None})), App(Var("print_int"), [App(Var("int_of_float"), [Var("d")])]), Let(("_", Var({val: None})), App(Var("print_int"), [Var("i")]), Let(("_", Var({val: None})), App(Var("print_int"), [Var("i2")]), LetTuple([("i", Var({val: None})), ("i2", Var({val: None})), ("i3", Var({val: None}))], App(Var("return_i_i_i"), []), Let(("_", Var({val: None})), App(Var("print_int"), [Var("i")]), Let(("_", Var({val: None})), App(Var("print_int"), [Var("i2")]), Let(("_", Var({val: None})), App(Var("print_int"), [Var("i3")]), Unit)))))))))))))))}, Unit))) against Unit
// [Typer] typevars: []
// [Typer] check: Tuple([Double(2), Int(3), Int(4)]) against Tuple([Double, Int, Int])
// [Typer] check: Double(2) against Double
// [Typer] check: Int(3) against Int
// [Typer] check: Int(4) against Int
// [Typer] check: LetRec({tyvars: [], name: ("return_i_i_i", Tuple([Int, Int, Int])), args: [], body: Tuple([Int(1), Int(2), Int(3)])}, LetRec({tyvars: [], name: ("main", Var({val: None})), args: [], body: LetTuple([("i", Var({val: None})), ("d", Var({val: None}))], App(Var("return_i_d"), []), Let(("_", Var({val: None})), App(Var("print_int"), [Var("i")]), Let(("_", Var({val: None})), App(Var("print_int"), [App(Var("int_of_float"), [Var("d")])]), LetTuple([("i", Var({val: None})), ("d", Var({val: None})), ("i2", Var({val: None}))], App(Var("return_i_d_i"), []), Let(("_", Var({val: None})), App(Var("print_int"), [Var("i")]), Let(("_", Var({val: None})), App(Var("print_int"), [App(Var("int_of_float"), [Var("d")])]), Let(("_", Var({val: None})), App(Var("print_int"), [Var("i2")]), LetTuple([("d", Var({val: None})), ("i", Var({val: None})), ("i2", Var({val: None}))], App(Var("return_d_i_i"), []), Let(("_", Var({val: None})), App(Var("print_int"), [App(Var("int_of_float"), [Var("d")])]), Let(("_", Var({val: None})), App(Var("print_int"), [Var("i")]), Let(("_", Var({val: None})), App(Var("print_int"), [Var("i2")]), LetTuple([("i", Var({val: None})), ("i2", Var({val: None})), ("i3", Var({val: None}))], App(Var("return_i_i_i"), []), Let(("_", Var({val: None})), App(Var("print_int"), [Var("i")]), Let(("_", Var({val: None})), App(Var("print_int"), [Var("i2")]), Let(("_", Var({val: None})), App(Var("print_int"), [Var("i3")]), Unit)))))))))))))))}, Unit)) against Unit
// [Typer] typevars: []
// [Typer] check: Tuple([Int(1), Int(2), Int(3)]) against Tuple([Int, Int, Int])
// [Typer] check: Int(1) against Int
// [Typer] check: Int(2) against Int
// [Typer] check: Int(3) against Int
// [Typer] check: LetRec({tyvars: [], name: ("main", Var({val: None})), args: [], body: LetTuple([("i", Var({val: None})), ("d", Var({val: None}))], App(Var("return_i_d"), []), Let(("_", Var({val: None})), App(Var("print_int"), [Var("i")]), Let(("_", Var({val: None})), App(Var("print_int"), [App(Var("int_of_float"), [Var("d")])]), LetTuple([("i", Var({val: None})), ("d", Var({val: None})), ("i2", Var({val: None}))], App(Var("return_i_d_i"), []), Let(("_", Var({val: None})), App(Var("print_int"), [Var("i")]), Let(("_", Var({val: None})), App(Var("print_int"), [App(Var("int_of_float"), [Var("d")])]), Let(("_", Var({val: None})), App(Var("print_int"), [Var("i2")]), LetTuple([("d", Var({val: None})), ("i", Var({val: None})), ("i2", Var({val: None}))], App(Var("return_d_i_i"), []), Let(("_", Var({val: None})), App(Var("print_int"), [App(Var("int_of_float"), [Var("d")])]), Let(("_", Var({val: None})), App(Var("print_int"), [Var("i")]), Let(("_", Var({val: None})), App(Var("print_int"), [Var("i2")]), LetTuple([("i", Var({val: None})), ("i2", Var({val: None})), ("i3", Var({val: None}))], App(Var("return_i_i_i"), []), Let(("_", Var({val: None})), App(Var("print_int"), [Var("i")]), Let(("_", Var({val: None})), App(Var("print_int"), [Var("i2")]), Let(("_", Var({val: None})), App(Var("print_int"), [Var("i3")]), Unit)))))))))))))))}, Unit) against Unit
// [Typer] typevars: []
// [Typer] infer: LetTuple([("i", Var({val: None})), ("d", Var({val: None}))], App(Var("return_i_d"), []), Let(("_", Var({val: None})), App(Var("print_int"), [Var("i")]), Let(("_", Var({val: None})), App(Var("print_int"), [App(Var("int_of_float"), [Var("d")])]), LetTuple([("i", Var({val: None})), ("d", Var({val: None})), ("i2", Var({val: None}))], App(Var("return_i_d_i"), []), Let(("_", Var({val: None})), App(Var("print_int"), [Var("i")]), Let(("_", Var({val: None})), App(Var("print_int"), [App(Var("int_of_float"), [Var("d")])]), Let(("_", Var({val: None})), App(Var("print_int"), [Var("i2")]), LetTuple([("d", Var({val: None})), ("i", Var({val: None})), ("i2", Var({val: None}))], App(Var("return_d_i_i"), []), Let(("_", Var({val: None})), App(Var("print_int"), [App(Var("int_of_float"), [Var("d")])]), Let(("_", Var({val: None})), App(Var("print_int"), [Var("i")]), Let(("_", Var({val: None})), App(Var("print_int"), [Var("i2")]), LetTuple([("i", Var({val: None})), ("i2", Var({val: None})), ("i3", Var({val: None}))], App(Var("return_i_i_i"), []), Let(("_", Var({val: None})), App(Var("print_int"), [Var("i")]), Let(("_", Var({val: None})), App(Var("print_int"), [Var("i2")]), Let(("_", Var({val: None})), App(Var("print_int"), [Var("i3")]), Unit)))))))))))))))
// [Typer] infer: App(Var("return_i_d"), [])
// [Typer] infer: Var("return_i_d")
// [Typer] inst: TypeScheme(([], Fun([], Tuple([Int, Double]))))
// [Typer] inst result: Fun([], Tuple([Int, Double]))
// [Typer] unify: Var({val: None}) and Int
// [Typer] union: Var({val: None}) and Int
// [Typer] unify: Var({val: None}) and Double
// [Typer] union: Var({val: None}) and Double
// [Typer] infer: Let(("_", Var({val: None})), App(Var("print_int"), [Var("i")]), Let(("_", Var({val: None})), App(Var("print_int"), [App(Var("int_of_float"), [Var("d")])]), LetTuple([("i", Var({val: None})), ("d", Var({val: None})), ("i2", Var({val: None}))], App(Var("return_i_d_i"), []), Let(("_", Var({val: None})), App(Var("print_int"), [Var("i")]), Let(("_", Var({val: None})), App(Var("print_int"), [App(Var("int_of_float"), [Var("d")])]), Let(("_", Var({val: None})), App(Var("print_int"), [Var("i2")]), LetTuple([("d", Var({val: None})), ("i", Var({val: None})), ("i2", Var({val: None}))], App(Var("return_d_i_i"), []), Let(("_", Var({val: None})), App(Var("print_int"), [App(Var("int_of_float"), [Var("d")])]), Let(("_", Var({val: None})), App(Var("print_int"), [Var("i")]), Let(("_", Var({val: None})), App(Var("print_int"), [Var("i2")]), LetTuple([("i", Var({val: None})), ("i2", Var({val: None})), ("i3", Var({val: None}))], App(Var("return_i_i_i"), []), Let(("_", Var({val: None})), App(Var("print_int"), [Var("i")]), Let(("_", Var({val: None})), App(Var("print_int"), [Var("i2")]), Let(("_", Var({val: None})), App(Var("print_int"), [Var("i3")]), Unit))))))))))))))
// [Typer] infer: App(Var("print_int"), [Var("i")])
// [Typer] infer: Var("print_int")
// [Typer] inst: TypeScheme(([], Fun([Int], Unit)))
// [Typer] inst result: Fun([Int], Unit)
// [Typer] check: Var("i") against Int
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] unify: Var({val: None}) and Unit
// [Typer] union: Var({val: None}) and Unit
// [Typer] infer: Let(("_", Var({val: None})), App(Var("print_int"), [App(Var("int_of_float"), [Var("d")])]), LetTuple([("i", Var({val: None})), ("d", Var({val: None})), ("i2", Var({val: None}))], App(Var("return_i_d_i"), []), Let(("_", Var({val: None})), App(Var("print_int"), [Var("i")]), Let(("_", Var({val: None})), App(Var("print_int"), [App(Var("int_of_float"), [Var("d")])]), Let(("_", Var({val: None})), App(Var("print_int"), [Var("i2")]), LetTuple([("d", Var({val: None})), ("i", Var({val: None})), ("i2", Var({val: None}))], App(Var("return_d_i_i"), []), Let(("_", Var({val: None})), App(Var("print_int"), [App(Var("int_of_float"), [Var("d")])]), Let(("_", Var({val: None})), App(Var("print_int"), [Var("i")]), Let(("_", Var({val: None})), App(Var("print_int"), [Var("i2")]), LetTuple([("i", Var({val: None})), ("i2", Var({val: None})), ("i3", Var({val: None}))], App(Var("return_i_i_i"), []), Let(("_", Var({val: None})), App(Var("print_int"), [Var("i")]), Let(("_", Var({val: None})), App(Var("print_int"), [Var("i2")]), Let(("_", Var({val: None})), App(Var("print_int"), [Var("i3")]), Unit)))))))))))))
// [Typer] infer: App(Var("print_int"), [App(Var("int_of_float"), [Var("d")])])
// [Typer] infer: Var("print_int")
// [Typer] inst: TypeScheme(([], Fun([Int], Unit)))
// [Typer] inst result: Fun([Int], Unit)
// [Typer] check: App(Var("int_of_float"), [Var("d")]) against Int
// [Typer] infer: Var("d")
// [Typer] inst: TypeScheme(([], Double))
// [Typer] inst result: Double
// [Typer] check: Var("int_of_float") against Fun([Double], Int)
// [Typer] inst: TypeScheme(([], Fun([Double], Int)))
// [Typer] inst result: Fun([Double], Int)
// [Typer] unify: Fun([Double], Int) and Fun([Double], Int)
// [Typer] unify: Double and Double
// [Typer] unify: Int and Int
// [Typer] unify: Var({val: None}) and Unit
// [Typer] union: Var({val: None}) and Unit
// [Typer] infer: LetTuple([("i", Var({val: None})), ("d", Var({val: None})), ("i2", Var({val: None}))], App(Var("return_i_d_i"), []), Let(("_", Var({val: None})), App(Var("print_int"), [Var("i")]), Let(("_", Var({val: None})), App(Var("print_int"), [App(Var("int_of_float"), [Var("d")])]), Let(("_", Var({val: None})), App(Var("print_int"), [Var("i2")]), LetTuple([("d", Var({val: None})), ("i", Var({val: None})), ("i2", Var({val: None}))], App(Var("return_d_i_i"), []), Let(("_", Var({val: None})), App(Var("print_int"), [App(Var("int_of_float"), [Var("d")])]), Let(("_", Var({val: None})), App(Var("print_int"), [Var("i")]), Let(("_", Var({val: None})), App(Var("print_int"), [Var("i2")]), LetTuple([("i", Var({val: None})), ("i2", Var({val: None})), ("i3", Var({val: None}))], App(Var("return_i_i_i"), []), Let(("_", Var({val: None})), App(Var("print_int"), [Var("i")]), Let(("_", Var({val: None})), App(Var("print_int"), [Var("i2")]), Let(("_", Var({val: None})), App(Var("print_int"), [Var("i3")]), Unit))))))))))))
// [Typer] infer: App(Var("return_i_d_i"), [])
// [Typer] infer: Var("return_i_d_i")
// [Typer] inst: TypeScheme(([], Fun([], Tuple([Int, Double, Int]))))
// [Typer] inst result: Fun([], Tuple([Int, Double, Int]))
// [Typer] unify: Var({val: None}) and Int
// [Typer] union: Var({val: None}) and Int
// [Typer] unify: Var({val: None}) and Double
// [Typer] union: Var({val: None}) and Double
// [Typer] unify: Var({val: None}) and Int
// [Typer] union: Var({val: None}) and Int
// [Typer] infer: Let(("_", Var({val: None})), App(Var("print_int"), [Var("i")]), Let(("_", Var({val: None})), App(Var("print_int"), [App(Var("int_of_float"), [Var("d")])]), Let(("_", Var({val: None})), App(Var("print_int"), [Var("i2")]), LetTuple([("d", Var({val: None})), ("i", Var({val: None})), ("i2", Var({val: None}))], App(Var("return_d_i_i"), []), Let(("_", Var({val: None})), App(Var("print_int"), [App(Var("int_of_float"), [Var("d")])]), Let(("_", Var({val: None})), App(Var("print_int"), [Var("i")]), Let(("_", Var({val: None})), App(Var("print_int"), [Var("i2")]), LetTuple([("i", Var({val: None})), ("i2", Var({val: None})), ("i3", Var({val: None}))], App(Var("return_i_i_i"), []), Let(("_", Var({val: None})), App(Var("print_int"), [Var("i")]), Let(("_", Var({val: None})), App(Var("print_int"), [Var("i2")]), Let(("_", Var({val: None})), App(Var("print_int"), [Var("i3")]), Unit)))))))))))
// [Typer] infer: App(Var("print_int"), [Var("i")])
// [Typer] infer: Var("print_int")
// [Typer] inst: TypeScheme(([], Fun([Int], Unit)))
// [Typer] inst result: Fun([Int], Unit)
// [Typer] check: Var("i") against Int
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] unify: Var({val: None}) and Unit
// [Typer] union: Var({val: None}) and Unit
// [Typer] infer: Let(("_", Var({val: None})), App(Var("print_int"), [App(Var("int_of_float"), [Var("d")])]), Let(("_", Var({val: None})), App(Var("print_int"), [Var("i2")]), LetTuple([("d", Var({val: None})), ("i", Var({val: None})), ("i2", Var({val: None}))], App(Var("return_d_i_i"), []), Let(("_", Var({val: None})), App(Var("print_int"), [App(Var("int_of_float"), [Var("d")])]), Let(("_", Var({val: None})), App(Var("print_int"), [Var("i")]), Let(("_", Var({val: None})), App(Var("print_int"), [Var("i2")]), LetTuple([("i", Var({val: None})), ("i2", Var({val: None})), ("i3", Var({val: None}))], App(Var("return_i_i_i"), []), Let(("_", Var({val: None})), App(Var("print_int"), [Var("i")]), Let(("_", Var({val: None})), App(Var("print_int"), [Var("i2")]), Let(("_", Var({val: None})), App(Var("print_int"), [Var("i3")]), Unit))))))))))
// [Typer] infer: App(Var("print_int"), [App(Var("int_of_float"), [Var("d")])])
// [Typer] infer: Var("print_int")
// [Typer] inst: TypeScheme(([], Fun([Int], Unit)))
// [Typer] inst result: Fun([Int], Unit)
// [Typer] check: App(Var("int_of_float"), [Var("d")]) against Int
// [Typer] infer: Var("d")
// [Typer] inst: TypeScheme(([], Double))
// [Typer] inst result: Double
// [Typer] check: Var("int_of_float") against Fun([Double], Int)
// [Typer] inst: TypeScheme(([], Fun([Double], Int)))
// [Typer] inst result: Fun([Double], Int)
// [Typer] unify: Fun([Double], Int) and Fun([Double], Int)
// [Typer] unify: Double and Double
// [Typer] unify: Int and Int
// [Typer] unify: Var({val: None}) and Unit
// [Typer] union: Var({val: None}) and Unit
// [Typer] infer: Let(("_", Var({val: None})), App(Var("print_int"), [Var("i2")]), LetTuple([("d", Var({val: None})), ("i", Var({val: None})), ("i2", Var({val: None}))], App(Var("return_d_i_i"), []), Let(("_", Var({val: None})), App(Var("print_int"), [App(Var("int_of_float"), [Var("d")])]), Let(("_", Var({val: None})), App(Var("print_int"), [Var("i")]), Let(("_", Var({val: None})), App(Var("print_int"), [Var("i2")]), LetTuple([("i", Var({val: None})), ("i2", Var({val: None})), ("i3", Var({val: None}))], App(Var("return_i_i_i"), []), Let(("_", Var({val: None})), App(Var("print_int"), [Var("i")]), Let(("_", Var({val: None})), App(Var("print_int"), [Var("i2")]), Let(("_", Var({val: None})), App(Var("print_int"), [Var("i3")]), Unit)))))))))
// [Typer] infer: App(Var("print_int"), [Var("i2")])
// [Typer] infer: Var("print_int")
// [Typer] inst: TypeScheme(([], Fun([Int], Unit)))
// [Typer] inst result: Fun([Int], Unit)
// [Typer] check: Var("i2") against Int
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] unify: Var({val: None}) and Unit
// [Typer] union: Var({val: None}) and Unit
// [Typer] infer: LetTuple([("d", Var({val: None})), ("i", Var({val: None})), ("i2", Var({val: None}))], App(Var("return_d_i_i"), []), Let(("_", Var({val: None})), App(Var("print_int"), [App(Var("int_of_float"), [Var("d")])]), Let(("_", Var({val: None})), App(Var("print_int"), [Var("i")]), Let(("_", Var({val: None})), App(Var("print_int"), [Var("i2")]), LetTuple([("i", Var({val: None})), ("i2", Var({val: None})), ("i3", Var({val: None}))], App(Var("return_i_i_i"), []), Let(("_", Var({val: None})), App(Var("print_int"), [Var("i")]), Let(("_", Var({val: None})), App(Var("print_int"), [Var("i2")]), Let(("_", Var({val: None})), App(Var("print_int"), [Var("i3")]), Unit))))))))
// [Typer] infer: App(Var("return_d_i_i"), [])
// [Typer] infer: Var("return_d_i_i")
// [Typer] inst: TypeScheme(([], Fun([], Tuple([Double, Int, Int]))))
// [Typer] inst result: Fun([], Tuple([Double, Int, Int]))
// [Typer] unify: Var({val: None}) and Double
// [Typer] union: Var({val: None}) and Double
// [Typer] unify: Var({val: None}) and Int
// [Typer] union: Var({val: None}) and Int
// [Typer] unify: Var({val: None}) and Int
// [Typer] union: Var({val: None}) and Int
// [Typer] infer: Let(("_", Var({val: None})), App(Var("print_int"), [App(Var("int_of_float"), [Var("d")])]), Let(("_", Var({val: None})), App(Var("print_int"), [Var("i")]), Let(("_", Var({val: None})), App(Var("print_int"), [Var("i2")]), LetTuple([("i", Var({val: None})), ("i2", Var({val: None})), ("i3", Var({val: None}))], App(Var("return_i_i_i"), []), Let(("_", Var({val: None})), App(Var("print_int"), [Var("i")]), Let(("_", Var({val: None})), App(Var("print_int"), [Var("i2")]), Let(("_", Var({val: None})), App(Var("print_int"), [Var("i3")]), Unit)))))))
// [Typer] infer: App(Var("print_int"), [App(Var("int_of_float"), [Var("d")])])
// [Typer] infer: Var("print_int")
// [Typer] inst: TypeScheme(([], Fun([Int], Unit)))
// [Typer] inst result: Fun([Int], Unit)
// [Typer] check: App(Var("int_of_float"), [Var("d")]) against Int
// [Typer] infer: Var("d")
// [Typer] inst: TypeScheme(([], Double))
// [Typer] inst result: Double
// [Typer] check: Var("int_of_float") against Fun([Double], Int)
// [Typer] inst: TypeScheme(([], Fun([Double], Int)))
// [Typer] inst result: Fun([Double], Int)
// [Typer] unify: Fun([Double], Int) and Fun([Double], Int)
// [Typer] unify: Double and Double
// [Typer] unify: Int and Int
// [Typer] unify: Var({val: None}) and Unit
// [Typer] union: Var({val: None}) and Unit
// [Typer] infer: Let(("_", Var({val: None})), App(Var("print_int"), [Var("i")]), Let(("_", Var({val: None})), App(Var("print_int"), [Var("i2")]), LetTuple([("i", Var({val: None})), ("i2", Var({val: None})), ("i3", Var({val: None}))], App(Var("return_i_i_i"), []), Let(("_", Var({val: None})), App(Var("print_int"), [Var("i")]), Let(("_", Var({val: None})), App(Var("print_int"), [Var("i2")]), Let(("_", Var({val: None})), App(Var("print_int"), [Var("i3")]), Unit))))))
// [Typer] infer: App(Var("print_int"), [Var("i")])
// [Typer] infer: Var("print_int")
// [Typer] inst: TypeScheme(([], Fun([Int], Unit)))
// [Typer] inst result: Fun([Int], Unit)
// [Typer] check: Var("i") against Int
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] unify: Var({val: None}) and Unit
// [Typer] union: Var({val: None}) and Unit
// [Typer] infer: Let(("_", Var({val: None})), App(Var("print_int"), [Var("i2")]), LetTuple([("i", Var({val: None})), ("i2", Var({val: None})), ("i3", Var({val: None}))], App(Var("return_i_i_i"), []), Let(("_", Var({val: None})), App(Var("print_int"), [Var("i")]), Let(("_", Var({val: None})), App(Var("print_int"), [Var("i2")]), Let(("_", Var({val: None})), App(Var("print_int"), [Var("i3")]), Unit)))))
// [Typer] infer: App(Var("print_int"), [Var("i2")])
// [Typer] infer: Var("print_int")
// [Typer] inst: TypeScheme(([], Fun([Int], Unit)))
// [Typer] inst result: Fun([Int], Unit)
// [Typer] check: Var("i2") against Int
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] unify: Var({val: None}) and Unit
// [Typer] union: Var({val: None}) and Unit
// [Typer] infer: LetTuple([("i", Var({val: None})), ("i2", Var({val: None})), ("i3", Var({val: None}))], App(Var("return_i_i_i"), []), Let(("_", Var({val: None})), App(Var("print_int"), [Var("i")]), Let(("_", Var({val: None})), App(Var("print_int"), [Var("i2")]), Let(("_", Var({val: None})), App(Var("print_int"), [Var("i3")]), Unit))))
// [Typer] infer: App(Var("return_i_i_i"), [])
// [Typer] infer: Var("return_i_i_i")
// [Typer] inst: TypeScheme(([], Fun([], Tuple([Int, Int, Int]))))
// [Typer] inst result: Fun([], Tuple([Int, Int, Int]))
// [Typer] unify: Var({val: None}) and Int
// [Typer] union: Var({val: None}) and Int
// [Typer] unify: Var({val: None}) and Int
// [Typer] union: Var({val: None}) and Int
// [Typer] unify: Var({val: None}) and Int
// [Typer] union: Var({val: None}) and Int
// [Typer] infer: Let(("_", Var({val: None})), App(Var("print_int"), [Var("i")]), Let(("_", Var({val: None})), App(Var("print_int"), [Var("i2")]), Let(("_", Var({val: None})), App(Var("print_int"), [Var("i3")]), Unit)))
// [Typer] infer: App(Var("print_int"), [Var("i")])
// [Typer] infer: Var("print_int")
// [Typer] inst: TypeScheme(([], Fun([Int], Unit)))
// [Typer] inst result: Fun([Int], Unit)
// [Typer] check: Var("i") against Int
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] unify: Var({val: None}) and Unit
// [Typer] union: Var({val: None}) and Unit
// [Typer] infer: Let(("_", Var({val: None})), App(Var("print_int"), [Var("i2")]), Let(("_", Var({val: None})), App(Var("print_int"), [Var("i3")]), Unit))
// [Typer] infer: App(Var("print_int"), [Var("i2")])
// [Typer] infer: Var("print_int")
// [Typer] inst: TypeScheme(([], Fun([Int], Unit)))
// [Typer] inst result: Fun([Int], Unit)
// [Typer] check: Var("i2") against Int
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] unify: Var({val: None}) and Unit
// [Typer] union: Var({val: None}) and Unit
// [Typer] infer: Let(("_", Var({val: None})), App(Var("print_int"), [Var("i3")]), Unit)
// [Typer] infer: App(Var("print_int"), [Var("i3")])
// [Typer] infer: Var("print_int")
// [Typer] inst: TypeScheme(([], Fun([Int], Unit)))
// [Typer] inst result: Fun([Int], Unit)
// [Typer] check: Var("i3") against Int
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] unify: Var({val: None}) and Unit
// [Typer] union: Var({val: None}) and Unit
// [Typer] infer: Unit
// [Typer] unify: Unit and Var({val: None})
// [Typer] union: Unit and Var({val: None})
// [Typer] check: Unit against Unit
// [Parser] flags: []
