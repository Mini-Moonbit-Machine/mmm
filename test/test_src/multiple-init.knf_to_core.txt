# name conventions used in the core ir:
# - functions: f<id>
# - blocks: b<id>
# - instructions: %<id>
# - memory: m<id>
# - free variables: ^<id>
# - function parameters: $f<pid>
# - block parameters: $b<bid>.<pid>
.core
.fn T$_11_10 #f10 : fn() -> int32
.freevars ()
.entry b0 {
  .bb #b0 () {
    return 1
  }
}
.fn T$_1_0 #f0 : fn() -> int32
.freevars ()
.entry b0 {
  .bb #b0 () {
    return 1
  }
}
.fn T$_2_2 #f2 : fn() -> int32
.freevars ()
.entry b0 {
  .bb #b0 () {
    return 0
  }
}
.fn init14l1_16 #f16 : fn(array[int32]) -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: array[int32] = load_symbol ::6
    let _ = store int32 offset(%0, 0) <- 2
    return ()
  }
}
.fn init21l2_20 #f20 : fn(array[int32], array[int32]) -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: array[int32] = load_symbol ::2
    let _ = store int32 offset(%0, 0) <- 3
    let %2: array[int32] = load_symbol ::6
    let _ = store int32 offset(%2, 0) <- 4
    return ()
  }
}
.fn T$len.34 #f4 : fn() -> array[int32]
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: int32 = load_symbol ::0
    let %1: int32 = load_symbol ::1
    let _ = alloc <m0: array[int32] heap(%0)> <- [..] = %1
    return f4.m0
  }
}
.fn T$len2.1314 #f14 : fn() -> array[int32]
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: int32 = load_symbol ::4
    let %1: int32 = load_symbol ::5
    let _ = alloc <m0: array[int32] heap(%0)> <- [..] = %1
    return f14.m0
  }
}
.fn T$_20_18 #f18 : fn() -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: array[int32] = load_symbol ::6
    let %1: unit = call f16(%0)
    return %1
  }
}
.fn T$start_26 #f26 : fn() -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: array[int32] = load_symbol ::2
    let %1: array[int32] = load_symbol ::6
    let %2: unit = call f24(%0, %1)
    return %2
  }
}
.fn T$_31_22 #f22 : fn() -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: array[int32] = load_symbol ::2
    let %1: array[int32] = load_symbol ::6
    let %2: unit = call f20(%0, %1)
    return %2
  }
}
.fn T$_10_8 #f8 : fn() -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: array[int32] = load_symbol ::2
    let %1: unit = call f6(%0)
    return %1
  }
}
.fn init4l0_6 #f6 : fn(array[int32]) -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: array[int32] = load_symbol ::2
    let _ = store int32 offset(%0, 0) <- 1
    return ()
  }
}
.fn T$_12_12 #f12 : fn() -> int32
.freevars ()
.entry b0 {
  .bb #b0 () {
    return 0
  }
}
.fn main32l3_24 #f24 : fn(array[int32], array[int32]) -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: array[int32] = load_symbol ::2
    let %1: int32 = load int32 offset(%0, 0)
    let %2: unit = ext_call minimbt_print_int(%1)
    let %3: unit = ext_call minimbt_print_endline()
    let %4: array[int32] = load_symbol ::6
    let %5: int32 = load int32 offset(%4, 0)
    let %6: unit = ext_call minimbt_print_int(%5)
    return ()
  }
}
.thunk ::0 _1
.thunk ::1 _2
.thunk ::2 len.3
.thunk ::3 _10
.thunk ::4 _11
.thunk ::5 _12
.thunk ::6 len2.13
.thunk ::7 _20
.thunk ::8 _31
.thunk ::9 start
