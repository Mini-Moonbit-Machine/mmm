# name conventions used in the core ir:
# - functions: f<id>
# - blocks: b<id>
# - instructions: %<id>
# - memory: m<id>
# - free variables: ^<id>
# - function parameters: $f<pid>
# - block parameters: $b<bid>.<pid>
.core
.fn T$_52 #f34 : fn() -> int32
.freevars ()
.entry b0 {
  .bb #b0 () {
    return 0
  }
}
.fn T$_20 #f26 : fn() -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    return ()
  }
}
.fn T$_50 #f30 : fn() -> int32
.freevars ()
.entry b0 {
  .bb #b0 () {
    return 3
  }
}
.fn T$_47 #f22 : fn() -> int32
.freevars ()
.entry b0 {
  .bb #b0 () {
    return 2
  }
}
.fn T$_10 #f12 : fn() -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    return ()
  }
}
.fn T$_44 #f8 : fn() -> int32
.freevars ()
.entry b0 {
  .bb #b0 () {
    return 1
  }
}
.fn T$_1 #f0 : fn() -> int32
.freevars ()
.entry b0 {
  .bb #b0 () {
    return 1
  }
}
.fn T$len.3 #f4 : fn() -> array[int32]
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: int32 = load_symbol ::0
    let %1: int32 = load_symbol ::1
    let _ = alloc <m0: array[int32] heap(%0)> <- [..] = %1
    return f4.m0
  }
}
.fn T$_43 #f6 : fn() -> int32
.freevars ()
.entry b0 {
  .bb #b0 () {
    return 0
  }
}
.fn T$_46 #f20 : fn() -> int32
.freevars ()
.entry b0 {
  .bb #b0 () {
    return 0
  }
}
.fn T$_48 #f24 : fn() -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: array[int32] = load_symbol ::9
    let %1: int32 = load_symbol ::10
    let %2: int32 = load_symbol ::11
    let _ = store int32 offset(%0, %1 * @32) <- %2
    return ()
  }
}
.fn T$len2.13 #f18 : fn() -> array[int32]
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: int32 = load_symbol ::7
    let %1: int32 = load_symbol ::8
    let _ = alloc <m0: array[int32] heap(%0)> <- [..] = %1
    return f18.m0
  }
}
.fn main32.55 #f42 : fn(array[int32], array[int32]) -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: array[int32] = load_symbol ::2
    let %1: int32 = load int32 field(%0, 0 * @32)
    let %2: unit = ext_call minimbt_print_int(%1)
    let %3: unit = ext_call minimbt_print_endline()
    let %4: array[int32] = load_symbol ::9
    let %5: int32 = load int32 field(%4, 0 * @32)
    let %6: unit = ext_call minimbt_print_int(%5)
    return ()
  }
}
.fn T$_45 #f10 : fn() -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: array[int32] = load_symbol ::2
    let %1: int32 = load_symbol ::3
    let %2: int32 = load_symbol ::4
    let _ = store int32 offset(%0, %1 * @32) <- %2
    return ()
  }
}
.fn T$_11 #f14 : fn() -> int32
.freevars ()
.entry b0 {
  .bb #b0 () {
    return 1
  }
}
.fn T$_49 #f28 : fn() -> int32
.freevars ()
.entry b0 {
  .bb #b0 () {
    return 0
  }
}
.fn T$_2 #f2 : fn() -> int32
.freevars ()
.entry b0 {
  .bb #b0 () {
    return 0
  }
}
.fn T$_12 #f16 : fn() -> int32
.freevars ()
.entry b0 {
  .bb #b0 () {
    return 0
  }
}
.fn T$_31 #f40 : fn() -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    return ()
  }
}
.fn T$_51 #f32 : fn() -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: array[int32] = load_symbol ::2
    let %1: int32 = load_symbol ::14
    let %2: int32 = load_symbol ::15
    let _ = store int32 offset(%0, %1 * @32) <- %2
    return ()
  }
}
.fn T$_54 #f38 : fn() -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: array[int32] = load_symbol ::9
    let %1: int32 = load_symbol ::17
    let %2: int32 = load_symbol ::18
    let _ = store int32 offset(%0, %1 * @32) <- %2
    return ()
  }
}
.fn T$_53 #f36 : fn() -> int32
.freevars ()
.entry b0 {
  .bb #b0 () {
    return 4
  }
}
.fn T$start #f44 : fn() -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: array[int32] = load_symbol ::2
    let %1: array[int32] = load_symbol ::9
    let %2: unit = call f42(%0, %1)
    return %2
  }
}
.thunk ::0 _1
.thunk ::1 _2
.thunk ::2 len.3
.thunk ::3 _43
.thunk ::4 _44
.thunk ::5 _45
.thunk ::6 _10
.thunk ::7 _11
.thunk ::8 _12
.thunk ::9 len2.13
.thunk ::10 _46
.thunk ::11 _47
.thunk ::12 _48
.thunk ::13 _20
.thunk ::14 _49
.thunk ::15 _50
.thunk ::16 _51
.thunk ::17 _52
.thunk ::18 _53
.thunk ::19 _54
.thunk ::20 _31
.thunk ::21 start

