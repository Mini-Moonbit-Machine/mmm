# name conventions used in the core ir:
# - functions: f<id>
# - blocks: b<id>
# - instructions: %<id>
# - memory: m<id>
# - free variables: ^<id>
# - function parameters: $f<pid>
# - block parameters: $b<bid>.<pid>
.core
.fn T$_40 #f22 : fn() -> int32
.freevars ()
.entry b0 {
  .bb #b0 () {
    return 2
  }
}
.fn T$_38 #f10 : fn() -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: array[int32] = load_symbol ::2
    let %1: int32 = load_symbol ::3
    let %2: int32 = load_symbol ::4
    let _ = store int32 offset(%0, %1 * @32) <- %2
    return ()
  }
}
.fn T$_24 #f30 : fn() -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: array[int32] = load_symbol ::2
    let %1: array[int32] = load_symbol ::9
    let %2: unit = call f28(%0, %1)
    return %2
  }
}
.fn T$_16 #f26 : fn() -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    return ()
  }
}
.fn T$_36 #f6 : fn() -> int32
.freevars ()
.entry b0 {
  .bb #b0 () {
    return 0
  }
}
.fn T$_10 #f16 : fn() -> int32
.freevars ()
.entry b0 {
  .bb #b0 () {
    return 0
  }
}
.fn T$_41 #f24 : fn() -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: array[int32] = load_symbol ::9
    let %1: int32 = load_symbol ::10
    let %2: int32 = load_symbol ::11
    let _ = store int32 offset(%0, %1 * @32) <- %2
    return ()
  }
}
.fn init.42 #f28 : fn(array[int32], array[int32]) -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: array[int32] = load_symbol ::2
    let _ = store int32 field(%0, 0 * @32) <- 3
    let %2: array[int32] = load_symbol ::9
    let _ = store int32 field(%2, 0 * @32) <- 4
    return ()
  }
}
.fn T$_1 #f0 : fn() -> int32
.freevars ()
.entry b0 {
  .bb #b0 () {
    return 1
  }
}
.fn T$len.3 #f4 : fn() -> array[int32]
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: int32 = load_symbol ::0
    let %1: int32 = load_symbol ::1
    let _ = alloc <m0: array[int32] heap(%0)> <- [..] = %1
    return f4.m0
  }
}
.fn T$_37 #f8 : fn() -> int32
.freevars ()
.entry b0 {
  .bb #b0 () {
    return 1
  }
}
.fn T$len2.11 #f18 : fn() -> array[int32]
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: int32 = load_symbol ::7
    let %1: int32 = load_symbol ::8
    let _ = alloc <m0: array[int32] heap(%0)> <- [..] = %1
    return f18.m0
  }
}
.fn T$_8 #f12 : fn() -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    return ()
  }
}
.fn T$_9 #f14 : fn() -> int32
.freevars ()
.entry b0 {
  .bb #b0 () {
    return 1
  }
}
.fn T$_2 #f2 : fn() -> int32
.freevars ()
.entry b0 {
  .bb #b0 () {
    return 0
  }
}
.fn T$_39 #f20 : fn() -> int32
.freevars ()
.entry b0 {
  .bb #b0 () {
    return 0
  }
}
.fn main.43 #f32 : fn(array[int32], array[int32]) -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: array[int32] = load_symbol ::2
    let %1: int32 = load int32 field(%0, 0 * @32)
    let %2: unit = ext_call minimbt_print_int(%1)
    let %3: unit = ext_call minimbt_print_endline()
    let %4: array[int32] = load_symbol ::9
    let %5: int32 = load int32 field(%4, 0 * @32)
    let %6: unit = ext_call minimbt_print_int(%5)
    return ()
  }
}
.fn T$start #f34 : fn() -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: array[int32] = load_symbol ::2
    let %1: array[int32] = load_symbol ::9
    let %2: unit = call f32(%0, %1)
    return %2
  }
}
.thunk ::0 _1
.thunk ::1 _2
.thunk ::2 len.3
.thunk ::3 _36
.thunk ::4 _37
.thunk ::5 _38
.thunk ::6 _8
.thunk ::7 _9
.thunk ::8 _10
.thunk ::9 len2.11
.thunk ::10 _39
.thunk ::11 _40
.thunk ::12 _41
.thunk ::13 _16
.thunk ::14 _24
.thunk ::15 start
