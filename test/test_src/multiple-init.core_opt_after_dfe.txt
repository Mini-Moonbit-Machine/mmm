# name conventions used in the core ir:
# - functions: f<id>
# - blocks: b<id>
# - instructions: %<id>
# - memory: m<id>
# - free variables: ^<id>
# - function parameters: $f<pid>
# - block parameters: $b<bid>.<pid>
.core
.fn T$_20 #f26 : fn() -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    return ()
  }
}
.fn T$_10 #f12 : fn() -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    return ()
  }
}
.fn T$len.3 #f4 : fn() -> array[int32]
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: int32 = load_symbol ::0
    let %1: int32 = load_symbol ::1
    let _ = alloc <m0: array[int32] heap(%0)> <- [..] = %1
    return f4.m0
  }
}
.fn T$_58 #f8 : fn() -> int32
.freevars ()
.entry b0 {
  .bb #b0 () {
    return 1
  }
}
.fn T$_62 #f22 : fn() -> int32
.freevars ()
.entry b0 {
  .bb #b0 () {
    return 2
  }
}
.fn T$_57 #f6 : fn() -> int32
.freevars ()
.entry b0 {
  .bb #b0 () {
    return 0
  }
}
.fn T$_48 #f24 : fn() -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: array[int32] = load_symbol ::9
    let %1: int32 = load_symbol ::10
    let %2: int32 = load_symbol ::11
    let _ = store int32 offset(%0, %1 * @32) <- %2
    return ()
  }
}
.fn T$len2.13 #f18 : fn() -> array[int32]
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: int32 = load_symbol ::7
    let %1: int32 = load_symbol ::8
    let _ = alloc <m0: array[int32] heap(%0)> <- [..] = %1
    return f18.m0
  }
}
.fn T$_61 #f20 : fn() -> int32
.freevars ()
.entry b0 {
  .bb #b0 () {
    return 0
  }
}
.fn T$_66 #f36 : fn() -> int32
.freevars ()
.entry b0 {
  .bb #b0 () {
    return 4
  }
}
.fn T$_65 #f34 : fn() -> int32
.freevars ()
.entry b0 {
  .bb #b0 () {
    return 0
  }
}
.fn T$_45 #f10 : fn() -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: array[int32] = load_symbol ::2
    let %1: int32 = load_symbol ::3
    let %2: int32 = load_symbol ::4
    let _ = store int32 offset(%0, %1 * @32) <- %2
    return ()
  }
}
.fn T$_59 #f14 : fn() -> int32
.freevars ()
.entry b0 {
  .bb #b0 () {
    return 1
  }
}
.fn T$_64 #f30 : fn() -> int32
.freevars ()
.entry b0 {
  .bb #b0 () {
    return 3
  }
}
.fn T$_63 #f28 : fn() -> int32
.freevars ()
.entry b0 {
  .bb #b0 () {
    return 0
  }
}
.fn main32.67 #f42 : fn() -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: array[int32] = load_symbol ::2
    let %1: int32 = load int32 field(%0, 0 * @32)
    let %2: unit = ext_call minimbt_print_int(%1)
    let %3: unit = ext_call minimbt_print_endline()
    let %4: array[int32] = load_symbol ::9
    let %5: int32 = load int32 field(%4, 0 * @32)
    let %6: unit = ext_call minimbt_print_int(%5)
    return ()
  }
}
.fn T$_60 #f16 : fn() -> int32
.freevars ()
.entry b0 {
  .bb #b0 () {
    return 0
  }
}
.fn T$_31 #f40 : fn() -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    return ()
  }
}
.fn T$_56 #f2 : fn() -> int32
.freevars ()
.entry b0 {
  .bb #b0 () {
    return 0
  }
}
.fn T$_51 #f32 : fn() -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: array[int32] = load_symbol ::2
    let %1: int32 = load_symbol ::14
    let %2: int32 = load_symbol ::15
    let _ = store int32 offset(%0, %1 * @32) <- %2
    return ()
  }
}
.fn T$_54 #f38 : fn() -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: array[int32] = load_symbol ::9
    let %1: int32 = load_symbol ::17
    let %2: int32 = load_symbol ::18
    let _ = store int32 offset(%0, %1 * @32) <- %2
    return ()
  }
}
.fn T$start #f44 : fn() -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: unit = call f42()
    return %0
  }
}
.fn T$_55 #f0 : fn() -> int32
.freevars ()
.entry b0 {
  .bb #b0 () {
    return 1
  }
}
.thunk ::0 _55
.thunk ::1 _56
.thunk ::2 len.3
.thunk ::3 _57
.thunk ::4 _58
.thunk ::5 _45
.thunk ::6 _10
.thunk ::7 _59
.thunk ::8 _60
.thunk ::9 len2.13
.thunk ::10 _61
.thunk ::11 _62
.thunk ::12 _48
.thunk ::13 _20
.thunk ::14 _63
.thunk ::15 _64
.thunk ::16 _51
.thunk ::17 _65
.thunk ::18 _66
.thunk ::19 _54
.thunk ::20 _31
.thunk ::21 start

