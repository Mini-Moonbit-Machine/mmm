// [Main] function thunk_main(k) {
// [Main]   function dummy_1(i_3, k) {
// [Main]     return $thunk(() => k(i_3))
// [Main]   }
// [Main]   function landins_knot_4(f_6, k) {
// [Main]     const _7 = 1;
// [Main]     return $thunk(() => $external(minimbt_create_ptr_array, function (arr_8) {
// [Main]       function aux_9(x_11, k) {
// [Main]         const _12 = 0;
// [Main]         const _13 = arr_8[_12];
// [Main]         return $thunk(() => _13(x_11, function (x) {
// [Main]           return $thunk(() => k(x))
// [Main]         }
// [Main]         ))
// [Main]       }
// [Main]       return $thunk(() => f_6(aux_9, function (fixedpoint_14) {
// [Main]         const _15 = 0;
// [Main]         const _17 = arr_8[_15] = fixedpoint_14;
// [Main]         return $thunk(() => k(fixedpoint_14))
// [Main]       }
// [Main]       ))
// [Main]     }
// [Main]     , _7, dummy_1))
// [Main]   }
// [Main]   function g_18(f_20, k) {
// [Main]     function h_21(x_23, k) {
// [Main]       const _24 = 0;
// [Main]       if (x_23 === _24) {
// [Main]         return $thunk(() => k(1))
// [Main]       } else {
// [Main]         const _25 = 1;
// [Main]         const _26 = x_23 - _25;
// [Main]         return $thunk(() => f_20(_26, function (_27) {
// [Main]           return $thunk(() => k(x_23 * _27))
// [Main]         }
// [Main]         ))
// [Main]       }
// [Main]     }
// [Main]     return $thunk(() => k(h_21))
// [Main]   }
// [Main]   return $thunk(() => landins_knot_4(g_18, function (factorial_28) {
// [Main]     function f1_29(k) {
// [Main]       const _30 = 5;
// [Main]       return $thunk(() => factorial_28(_30, function (_31) {
// [Main]         return $thunk(() => $external(minimbt_print_int, function (x) {
// [Main]           return $thunk(() => k(x))
// [Main]         }
// [Main]         , _31))
// [Main]       }
// [Main]       ))
// [Main]     }
// [Main]     const _32 = 5;
// [Main]     return $thunk(() => factorial_28(_32, function (a_33) {
// [Main]       function g_34(x_36, k) {
// [Main]         return $thunk(() => k(x_36 + a_33))
// [Main]       }
// [Main]       function main_37(k) {
// [Main]         return $thunk(() => f1_29(function (_39) {
// [Main]           const _40 = 10;
// [Main]           return $thunk(() => g_34(_40, function (_41) {
// [Main]             return $thunk(() => $external(minimbt_print_int, function (_43) {
// [Main]               const _44 = 31;
// [Main]               return $thunk(() => g_34(_44, function (_45) {
// [Main]                 return $thunk(() => $external(minimbt_print_int, function (x) {
// [Main]                   return $thunk(() => k(x))
// [Main]                 }
// [Main]                 , _45))
// [Main]               }
// [Main]               ))
// [Main]             }
// [Main]             , _41))
// [Main]           }
// [Main]           ))
// [Main]         }
// [Main]         ))
// [Main]       }
// [Main]       return $thunk(() => main_37(function (x) {
// [Main]         return $thunk(() => k(x))
// [Main]       }
// [Main]       ))
// [Main]     }
// [Main]     ))
// [Main]   }
// [Main]   ))
// [Main] }
// [Main] 
// [Main] function $thunk(lambda) {
// [Main]   return { thunk: lambda };
// [Main] }
// [Main] function $is_thunk(x) {
// [Main]   return x && x.hasOwnProperty('thunk') && x.thunk !== undefined;
// [Main] }
// [Main] function $force(x) {
// [Main]   while ($is_thunk(x)) {
// [Main]     x = x.thunk();
// [Main]   }
// [Main]   return x;
// [Main] }
// [Main] function $external(f, k, ...args) {
// [Main]   let x = f(...args);
// [Main]   return $thunk(() => k(x));
// [Main] }
// [Main] function $trampoline(f, ...args) {
// [Main]   let x = f(...args);
// [Main]   return $force(x);
// [Main] }
// [Main] export default () => $trampoline(thunk_main, x => x);
// [Typer] check: LetRec({tyvars: [], name: ("dummy", Int), args: [("i", Int)], body: Var("i")}, LetRec({tyvars: [], name: ("landins_knot", (Int) -> Int), args: [("f", ((Int) -> Int) -> (Int) -> Int)], body: Let(("arr", Var(None)), Array(Int(1), Var("dummy")), LetRec({tyvars: [], name: ("aux", Var(None)), args: [("x", Var(None))], body: App(Get(Var("arr"), Int(0)), [Var("x")])}, Let(("fixedpoint", Var(None)), App(Var("f"), [Var("aux")]), Let(("_", Var(None)), Put(Var("arr"), Int(0), Var("fixedpoint")), Var("fixedpoint")))))}, Let(("factorial", (Int) -> Int), LetRec({tyvars: [], name: ("g", Var(None)), args: [("f", Var(None))], body: LetRec({tyvars: [], name: ("h", Var(None)), args: [("x", Var(None))], body: If(Eq(Var("x"), Int(0)), Int(1), Prim(Var("x"), App(Var("f"), [Prim(Var("x"), Int(1), Sub, kind=None)]), Mul, kind=None))}, Var("h"))}, App(Var("landins_knot"), [Var("g")])), LetRec({tyvars: [], name: ("f1", Unit), args: [], body: App(Var("print_int"), [App(Var("factorial"), [Int(5)])])}, Let(("with_effect", (Int) -> Int), Let(("a", Var(None)), App(Var("factorial"), [Int(5)]), LetRec({tyvars: [], name: ("g", Var(None)), args: [("x", Var(None))], body: Prim(Var("x"), Var("a"), Add, kind=None)}, Var("g"))), LetRec({tyvars: [], name: ("main", Var(None)), args: [], body: Let(("_", Var(None)), App(Var("f1"), []), Let(("_", Var(None)), App(Var("print_int"), [App(Var("with_effect"), [Int(10)])]), App(Var("print_int"), [App(Var("with_effect"), [Int(31)])])))}, Unit)))))) against Unit
// [Typer] typevars: []
// [Typer] check: Var("i") against Int
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] check: LetRec({tyvars: [], name: ("landins_knot", (Int) -> Int), args: [("f", ((Int) -> Int) -> (Int) -> Int)], body: Let(("arr", Var(None)), Array(Int(1), Var("dummy")), LetRec({tyvars: [], name: ("aux", Var(None)), args: [("x", Var(None))], body: App(Get(Var("arr"), Int(0)), [Var("x")])}, Let(("fixedpoint", Var(None)), App(Var("f"), [Var("aux")]), Let(("_", Var(None)), Put(Var("arr"), Int(0), Var("fixedpoint")), Var("fixedpoint")))))}, Let(("factorial", (Int) -> Int), LetRec({tyvars: [], name: ("g", Var(None)), args: [("f", Var(None))], body: LetRec({tyvars: [], name: ("h", Var(None)), args: [("x", Var(None))], body: If(Eq(Var("x"), Int(0)), Int(1), Prim(Var("x"), App(Var("f"), [Prim(Var("x"), Int(1), Sub, kind=None)]), Mul, kind=None))}, Var("h"))}, App(Var("landins_knot"), [Var("g")])), LetRec({tyvars: [], name: ("f1", Unit), args: [], body: App(Var("print_int"), [App(Var("factorial"), [Int(5)])])}, Let(("with_effect", (Int) -> Int), Let(("a", Var(None)), App(Var("factorial"), [Int(5)]), LetRec({tyvars: [], name: ("g", Var(None)), args: [("x", Var(None))], body: Prim(Var("x"), Var("a"), Add, kind=None)}, Var("g"))), LetRec({tyvars: [], name: ("main", Var(None)), args: [], body: Let(("_", Var(None)), App(Var("f1"), []), Let(("_", Var(None)), App(Var("print_int"), [App(Var("with_effect"), [Int(10)])]), App(Var("print_int"), [App(Var("with_effect"), [Int(31)])])))}, Unit))))) against Unit
// [Typer] typevars: []
// [Typer] check: Let(("arr", Var(None)), Array(Int(1), Var("dummy")), LetRec({tyvars: [], name: ("aux", Var(None)), args: [("x", Var(None))], body: App(Get(Var("arr"), Int(0)), [Var("x")])}, Let(("fixedpoint", Var(None)), App(Var("f"), [Var("aux")]), Let(("_", Var(None)), Put(Var("arr"), Int(0), Var("fixedpoint")), Var("fixedpoint"))))) against (Int) -> Int
// [Typer] infer: Array(Int(1), Var("dummy"))
// [Typer] infer: Var("dummy")
// [Typer] inst: TypeScheme(([], (Int) -> Int))
// [Typer] inst result: (Int) -> Int
// [Typer] check: Int(1) against Int
// [Typer] unify: Var(None) and Array[(Int) -> Int]
// [Typer] union: Var(None) and Array[(Int) -> Int]
// [Typer] check: LetRec({tyvars: [], name: ("aux", Var(None)), args: [("x", Var(None))], body: App(Get(Var("arr"), Int(0)), [Var("x")])}, Let(("fixedpoint", Var(None)), App(Var("f"), [Var("aux")]), Let(("_", Var(None)), Put(Var("arr"), Int(0), Var("fixedpoint")), Var("fixedpoint")))) against (Int) -> Int
// [Typer] typevars: []
// [Typer] infer: App(Get(Var("arr"), Int(0)), [Var("x")])
// [Typer] infer: Get(Var("arr"), Int(0))
// [Typer] infer: Var("arr")
// [Typer] inst: TypeScheme(([], Var(Array[(Int) -> Int])))
// [Typer] inst result: Array[(Int) -> Int]
// [Typer] check: Int(0) against Int
// [Typer] check: Var("x") against Int
// [Typer] inst: TypeScheme(([], Var(None)))
// [Typer] inst result: Var(None)
// [Typer] unify: Var(None) and Int
// [Typer] union: Var(None) and Int
// [Typer] unify: Int and Var(None)
// [Typer] union: Int and Var(None)
// [Typer] check: Let(("fixedpoint", Var(None)), App(Var("f"), [Var("aux")]), Let(("_", Var(None)), Put(Var("arr"), Int(0), Var("fixedpoint")), Var("fixedpoint"))) against (Int) -> Int
// [Typer] infer: App(Var("f"), [Var("aux")])
// [Typer] infer: Var("f")
// [Typer] inst: TypeScheme(([], ((Int) -> Int) -> (Int) -> Int))
// [Typer] inst result: ((Int) -> Int) -> (Int) -> Int
// [Typer] check: Var("aux") against (Int) -> Int
// [Typer] inst: TypeScheme(([], (Var(Int)) -> Var(~0)))
// [Typer] inst result: (Var(Int)) -> Int
// [Typer] unify: (Var(Int)) -> Int and (Int) -> Int
// [Typer] unify: Var(Int) and Int
// [Typer] unify: Int and Int
// [Typer] unify: Var(None) and (Int) -> Int
// [Typer] union: Var(None) and (Int) -> Int
// [Typer] check: Let(("_", Var(None)), Put(Var("arr"), Int(0), Var("fixedpoint")), Var("fixedpoint")) against (Int) -> Int
// [Typer] infer: Put(Var("arr"), Int(0), Var("fixedpoint"))
// [Typer] infer: Var("fixedpoint")
// [Typer] inst: TypeScheme(([], Var((Int) -> Int)))
// [Typer] inst result: (Int) -> Int
// [Typer] check: Var("arr") against Array[(Int) -> Int]
// [Typer] inst: TypeScheme(([], Var(Array[(Int) -> Int])))
// [Typer] inst result: Array[(Int) -> Int]
// [Typer] unify: Array[(Int) -> Int] and Array[(Int) -> Int]
// [Typer] unify: (Int) -> Int and (Int) -> Int
// [Typer] unify: Int and Int
// [Typer] unify: Int and Int
// [Typer] check: Int(0) against Int
// [Typer] unify: Var(None) and Unit
// [Typer] union: Var(None) and Unit
// [Typer] check: Var("fixedpoint") against (Int) -> Int
// [Typer] inst: TypeScheme(([], Var((Int) -> Int)))
// [Typer] inst result: (Int) -> Int
// [Typer] unify: (Int) -> Int and (Int) -> Int
// [Typer] unify: Int and Int
// [Typer] unify: Int and Int
// [Typer] check: Let(("factorial", (Int) -> Int), LetRec({tyvars: [], name: ("g", Var(None)), args: [("f", Var(None))], body: LetRec({tyvars: [], name: ("h", Var(None)), args: [("x", Var(None))], body: If(Eq(Var("x"), Int(0)), Int(1), Prim(Var("x"), App(Var("f"), [Prim(Var("x"), Int(1), Sub, kind=None)]), Mul, kind=None))}, Var("h"))}, App(Var("landins_knot"), [Var("g")])), LetRec({tyvars: [], name: ("f1", Unit), args: [], body: App(Var("print_int"), [App(Var("factorial"), [Int(5)])])}, Let(("with_effect", (Int) -> Int), Let(("a", Var(None)), App(Var("factorial"), [Int(5)]), LetRec({tyvars: [], name: ("g", Var(None)), args: [("x", Var(None))], body: Prim(Var("x"), Var("a"), Add, kind=None)}, Var("g"))), LetRec({tyvars: [], name: ("main", Var(None)), args: [], body: Let(("_", Var(None)), App(Var("f1"), []), Let(("_", Var(None)), App(Var("print_int"), [App(Var("with_effect"), [Int(10)])]), App(Var("print_int"), [App(Var("with_effect"), [Int(31)])])))}, Unit)))) against Unit
// [Typer] check: LetRec({tyvars: [], name: ("g", Var(None)), args: [("f", Var(None))], body: LetRec({tyvars: [], name: ("h", Var(None)), args: [("x", Var(None))], body: If(Eq(Var("x"), Int(0)), Int(1), Prim(Var("x"), App(Var("f"), [Prim(Var("x"), Int(1), Sub, kind=None)]), Mul, kind=None))}, Var("h"))}, App(Var("landins_knot"), [Var("g")])) against (Int) -> Int
// [Typer] typevars: []
// [Typer] infer: LetRec({tyvars: [], name: ("h", Var(None)), args: [("x", Var(None))], body: If(Eq(Var("x"), Int(0)), Int(1), Prim(Var("x"), App(Var("f"), [Prim(Var("x"), Int(1), Sub, kind=None)]), Mul, kind=None))}, Var("h"))
// [Typer] typevars: []
// [Typer] infer: If(Eq(Var("x"), Int(0)), Int(1), Prim(Var("x"), App(Var("f"), [Prim(Var("x"), Int(1), Sub, kind=None)]), Mul, kind=None))
// [Typer] check: Eq(Var("x"), Int(0)) against Bool
// [Typer] infer: Var("x")
// [Typer] inst: TypeScheme(([], Var(None)))
// [Typer] inst result: Var(None)
// [Typer] infer: Int(0)
// [Typer] unify: Var(None) and Int
// [Typer] union: Var(None) and Int
// [Typer] infer: Int(1)
// [Typer] infer: Prim(Var("x"), App(Var("f"), [Prim(Var("x"), Int(1), Sub, kind=None)]), Mul, kind=None)
// [Typer] infer: Var("x")
// [Typer] inst: TypeScheme(([], Var(Int)))
// [Typer] inst result: Int
// [Typer] infer: App(Var("f"), [Prim(Var("x"), Int(1), Sub, kind=None)])
// [Typer] infer: Var("f")
// [Typer] inst: TypeScheme(([], Var(None)))
// [Typer] inst result: Var(None)
// [Typer] infer: Prim(Var("x"), Int(1), Sub, kind=None)
// [Typer] infer: Var("x")
// [Typer] inst: TypeScheme(([], Var(Int)))
// [Typer] inst result: Int
// [Typer] infer: Int(1)
// [Typer] unify: Int and Int
// [Typer] unify: Var(None) and (Int) -> Var(None)
// [Typer] union: Var(None) and (Int) -> Var(None)
// [Typer] unify: Int and Var(None)
// [Typer] union: Int and Var(None)
// [Typer] unify: Int and Int
// [Typer] unify: Int and Var(None)
// [Typer] union: Int and Var(None)
// [Typer] infer: Var("h")
// [Typer] inst: TypeScheme(([], (Var(Int)) -> Var(~0)))
// [Typer] inst result: (Var(Int)) -> Int
// [Typer] unify: (Var(Int)) -> Int and Var(None)
// [Typer] union: (Var(Int)) -> Int and Var(None)
// [Typer] check: App(Var("landins_knot"), [Var("g")]) against (Int) -> Int
// [Typer] infer: Var("g")
// [Typer] inst: TypeScheme(([], (Var((Int) -> Var(Int))) -> Var((Var(~1)) -> Int)))
// [Typer] inst result: (Var((Int) -> Var(Int))) -> Var((Int) -> Int)
// [Typer] check: Var("landins_knot") against ((Var((Int) -> Var(Int))) -> Var((Int) -> Int)) -> (Int) -> Int
// [Typer] inst: TypeScheme(([], (((Int) -> Int) -> (Int) -> Int) -> (Int) -> Int))
// [Typer] inst result: (((Int) -> Int) -> (Int) -> Int) -> (Int) -> Int
// [Typer] unify: (((Int) -> Int) -> (Int) -> Int) -> (Int) -> Int and ((Var((Int) -> Var(Int))) -> Var((Int) -> Int)) -> (Int) -> Int
// [Typer] unify: ((Int) -> Int) -> (Int) -> Int and (Var((Int) -> Var(Int))) -> Var((Int) -> Int)
// [Typer] unify: (Int) -> Int and Var((Int) -> Var(Int))
// [Typer] unify: Int and Int
// [Typer] unify: Int and Var(Int)
// [Typer] unify: (Int) -> Int and Var((Int) -> Int)
// [Typer] unify: Int and Int
// [Typer] unify: Int and Int
// [Typer] unify: (Int) -> Int and (Int) -> Int
// [Typer] unify: Int and Int
// [Typer] unify: Int and Int
// [Typer] check: LetRec({tyvars: [], name: ("f1", Unit), args: [], body: App(Var("print_int"), [App(Var("factorial"), [Int(5)])])}, Let(("with_effect", (Int) -> Int), Let(("a", Var(None)), App(Var("factorial"), [Int(5)]), LetRec({tyvars: [], name: ("g", Var(None)), args: [("x", Var(None))], body: Prim(Var("x"), Var("a"), Add, kind=None)}, Var("g"))), LetRec({tyvars: [], name: ("main", Var(None)), args: [], body: Let(("_", Var(None)), App(Var("f1"), []), Let(("_", Var(None)), App(Var("print_int"), [App(Var("with_effect"), [Int(10)])]), App(Var("print_int"), [App(Var("with_effect"), [Int(31)])])))}, Unit))) against Unit
// [Typer] typevars: []
// [Typer] check: App(Var("print_int"), [App(Var("factorial"), [Int(5)])]) against Unit
// [Typer] infer: App(Var("factorial"), [Int(5)])
// [Typer] infer: Var("factorial")
// [Typer] inst: TypeScheme(([], (Int) -> Int))
// [Typer] inst result: (Int) -> Int
// [Typer] check: Int(5) against Int
// [Typer] check: Var("print_int") against (Int) -> Unit
// [Typer] inst: TypeScheme(([], (Int) -> Unit))
// [Typer] inst result: (Int) -> Unit
// [Typer] unify: (Int) -> Unit and (Int) -> Unit
// [Typer] unify: Int and Int
// [Typer] unify: Unit and Unit
// [Typer] check: Let(("with_effect", (Int) -> Int), Let(("a", Var(None)), App(Var("factorial"), [Int(5)]), LetRec({tyvars: [], name: ("g", Var(None)), args: [("x", Var(None))], body: Prim(Var("x"), Var("a"), Add, kind=None)}, Var("g"))), LetRec({tyvars: [], name: ("main", Var(None)), args: [], body: Let(("_", Var(None)), App(Var("f1"), []), Let(("_", Var(None)), App(Var("print_int"), [App(Var("with_effect"), [Int(10)])]), App(Var("print_int"), [App(Var("with_effect"), [Int(31)])])))}, Unit)) against Unit
// [Typer] check: Let(("a", Var(None)), App(Var("factorial"), [Int(5)]), LetRec({tyvars: [], name: ("g", Var(None)), args: [("x", Var(None))], body: Prim(Var("x"), Var("a"), Add, kind=None)}, Var("g"))) against (Int) -> Int
// [Typer] infer: App(Var("factorial"), [Int(5)])
// [Typer] infer: Var("factorial")
// [Typer] inst: TypeScheme(([], (Int) -> Int))
// [Typer] inst result: (Int) -> Int
// [Typer] check: Int(5) against Int
// [Typer] unify: Var(None) and Int
// [Typer] union: Var(None) and Int
// [Typer] check: LetRec({tyvars: [], name: ("g", Var(None)), args: [("x", Var(None))], body: Prim(Var("x"), Var("a"), Add, kind=None)}, Var("g")) against (Int) -> Int
// [Typer] typevars: []
// [Typer] infer: Prim(Var("x"), Var("a"), Add, kind=None)
// [Typer] infer: Var("x")
// [Typer] inst: TypeScheme(([], Var(None)))
// [Typer] inst result: Var(None)
// [Typer] infer: Var("a")
// [Typer] inst: TypeScheme(([], Var(Int)))
// [Typer] inst result: Int
// [Typer] unify: Var(None) and Int
// [Typer] union: Var(None) and Int
// [Typer] unify: Int and Var(None)
// [Typer] union: Int and Var(None)
// [Typer] check: Var("g") against (Int) -> Int
// [Typer] inst: TypeScheme(([], (Var(Int)) -> Var(~0)))
// [Typer] inst result: (Var(Int)) -> Int
// [Typer] unify: (Var(Int)) -> Int and (Int) -> Int
// [Typer] unify: Var(Int) and Int
// [Typer] unify: Int and Int
// [Typer] check: LetRec({tyvars: [], name: ("main", Var(None)), args: [], body: Let(("_", Var(None)), App(Var("f1"), []), Let(("_", Var(None)), App(Var("print_int"), [App(Var("with_effect"), [Int(10)])]), App(Var("print_int"), [App(Var("with_effect"), [Int(31)])])))}, Unit) against Unit
// [Typer] typevars: []
// [Typer] infer: Let(("_", Var(None)), App(Var("f1"), []), Let(("_", Var(None)), App(Var("print_int"), [App(Var("with_effect"), [Int(10)])]), App(Var("print_int"), [App(Var("with_effect"), [Int(31)])])))
// [Typer] infer: App(Var("f1"), [])
// [Typer] infer: Var("f1")
// [Typer] inst: TypeScheme(([], () -> Unit))
// [Typer] inst result: () -> Unit
// [Typer] unify: Var(None) and Unit
// [Typer] union: Var(None) and Unit
// [Typer] infer: Let(("_", Var(None)), App(Var("print_int"), [App(Var("with_effect"), [Int(10)])]), App(Var("print_int"), [App(Var("with_effect"), [Int(31)])]))
// [Typer] infer: App(Var("print_int"), [App(Var("with_effect"), [Int(10)])])
// [Typer] infer: Var("print_int")
// [Typer] inst: TypeScheme(([], (Int) -> Unit))
// [Typer] inst result: (Int) -> Unit
// [Typer] check: App(Var("with_effect"), [Int(10)]) against Int
// [Typer] infer: Int(10)
// [Typer] check: Var("with_effect") against (Int) -> Int
// [Typer] inst: TypeScheme(([], (Int) -> Int))
// [Typer] inst result: (Int) -> Int
// [Typer] unify: (Int) -> Int and (Int) -> Int
// [Typer] unify: Int and Int
// [Typer] unify: Int and Int
// [Typer] unify: Var(None) and Unit
// [Typer] union: Var(None) and Unit
// [Typer] infer: App(Var("print_int"), [App(Var("with_effect"), [Int(31)])])
// [Typer] infer: Var("print_int")
// [Typer] inst: TypeScheme(([], (Int) -> Unit))
// [Typer] inst result: (Int) -> Unit
// [Typer] check: App(Var("with_effect"), [Int(31)]) against Int
// [Typer] infer: Int(31)
// [Typer] check: Var("with_effect") against (Int) -> Int
// [Typer] inst: TypeScheme(([], (Int) -> Int))
// [Typer] inst result: (Int) -> Int
// [Typer] unify: (Int) -> Int and (Int) -> Int
// [Typer] unify: Int and Int
// [Typer] unify: Int and Int
// [Typer] unify: Unit and Var(None)
// [Typer] union: Unit and Var(None)
// [Typer] check: Unit against Unit
// [Parser] flags: []
