// [Main] function thunk_main(k) {
// [Main]   function dummy_1(i_3, k) {
// [Main]     return k(i_3)
// [Main]   }
// [Main]   function landins_knot_4(f_6, k) {
// [Main]     const _7 = 1;
// [Main]     const arr_8 = minimbt_create_ptr_array($force(_7), $force(dummy_1));
// [Main]     function aux_9(x_11, k) {
// [Main]       const _12 = 0;
// [Main]       const _13 = arr_8[_12];
// [Main]       return $thunk(() => _13(x_11, k))
// [Main]     }
// [Main]     return $thunk(() => f_6(aux_9, function (fixedpoint_14) {
// [Main]       const _15 = 0;
// [Main]       const _17 = arr_8[_15] = fixedpoint_14;
// [Main]       return $thunk(() => k(fixedpoint_14))
// [Main]     }
// [Main]     ))
// [Main]   }
// [Main]   function g_18(f_20, k) {
// [Main]     function h_21(x_23, k) {
// [Main]       const _24 = 0;
// [Main]       if (x_23 === _24) {
// [Main]         return k(1)
// [Main]       } else {
// [Main]         const _25 = 1;
// [Main]         const _26 = x_23 - _25;
// [Main]         return $thunk(() => f_20(_26, function (_27) {
// [Main]           return $thunk(() => k(x_23 * _27))
// [Main]         }
// [Main]         ))
// [Main]       }
// [Main]     }
// [Main]     return k(h_21)
// [Main]   }
// [Main]   return $thunk(() => landins_knot_4(g_18, function (factorial_28) {
// [Main]     function f1_29(k) {
// [Main]       const _30 = 5;
// [Main]       return $thunk(() => factorial_28(_30, function (_31) {
// [Main]         return $thunk(() => k(minimbt_print_int($force(_31))))
// [Main]       }
// [Main]       ))
// [Main]     }
// [Main]     const _32 = 5;
// [Main]     return $thunk(() => factorial_28(_32, function (a_33) {
// [Main]       function g_34(x_36, k) {
// [Main]         return k(x_36 + a_33)
// [Main]       }
// [Main]       function main_37(k) {
// [Main]         return $thunk(() => f1_29(function (_39) {
// [Main]           const _40 = 10;
// [Main]           return $thunk(() => g_34(_40, function (_41) {
// [Main]             const _43 = minimbt_print_int($force(_41));
// [Main]             const _44 = 31;
// [Main]             return $thunk(() => g_34(_44, function (_45) {
// [Main]               return $thunk(() => $thunk(() => $thunk(() => k(minimbt_print_int($force(_45))))))
// [Main]             }
// [Main]             ))
// [Main]           }
// [Main]           ))
// [Main]         }
// [Main]         ))
// [Main]       }
// [Main]       return $thunk(() => main_37(k))
// [Main]     }
// [Main]     ))
// [Main]   }
// [Main]   ))
// [Main] }
// [Main] 
// [Main] function $thunk(lambda) {
// [Main]   return { thunk: lambda };
// [Main] }
// [Main] function $is_thunk(x) {
// [Main]   return x && x.hasOwnProperty('thunk') && x.thunk !== undefined;
// [Main] }
// [Main] function $force(x) {
// [Main]   while ($is_thunk(x)) {
// [Main]     x = x.thunk();
// [Main]   }
// [Main]   return x;
// [Main] }
// [Main] function $trampoline(f, ...args) {
// [Main]   let x = f(...args);
// [Main]   return $force(x);
// [Main] }
// [Main] export default () => $trampoline(thunk_main, x => x);
// [Typer] check: LetRec({tyvars: [], name: ("dummy", Int), args: [("i", Int)], body: Var("i")}, LetRec({tyvars: [], name: ("landins_knot", Fun([Int], Int)), args: [("f", Fun([Fun([Int], Int)], Fun([Int], Int)))], body: Let(("arr", Var({val: None})), Array(Int(1), Var("dummy")), LetRec({tyvars: [], name: ("aux", Var({val: None})), args: [("x", Var({val: None}))], body: App(Get(Var("arr"), Int(0)), [Var("x")])}, Let(("fixedpoint", Var({val: None})), App(Var("f"), [Var("aux")]), Let(("_", Var({val: None})), Put(Var("arr"), Int(0), Var("fixedpoint")), Var("fixedpoint")))))}, Let(("factorial", Fun([Int], Int)), LetRec({tyvars: [], name: ("g", Var({val: None})), args: [("f", Var({val: None}))], body: LetRec({tyvars: [], name: ("h", Var({val: None})), args: [("x", Var({val: None}))], body: If(Eq(Var("x"), Int(0)), Int(1), Prim(Var("x"), App(Var("f"), [Prim(Var("x"), Int(1), Sub, kind=None)]), Mul, kind=None))}, Var("h"))}, App(Var("landins_knot"), [Var("g")])), LetRec({tyvars: [], name: ("f1", Unit), args: [], body: App(Var("print_int"), [App(Var("factorial"), [Int(5)])])}, Let(("with_effect", Fun([Int], Int)), Let(("a", Var({val: None})), App(Var("factorial"), [Int(5)]), LetRec({tyvars: [], name: ("g", Var({val: None})), args: [("x", Var({val: None}))], body: Prim(Var("x"), Var("a"), Add, kind=None)}, Var("g"))), LetRec({tyvars: [], name: ("main", Var({val: None})), args: [], body: Let(("_", Var({val: None})), App(Var("f1"), []), Let(("_", Var({val: None})), App(Var("print_int"), [App(Var("with_effect"), [Int(10)])]), App(Var("print_int"), [App(Var("with_effect"), [Int(31)])])))}, Unit)))))) against Unit
// [Typer] typevars: []
// [Typer] check: Var("i") against Int
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] check: LetRec({tyvars: [], name: ("landins_knot", Fun([Int], Int)), args: [("f", Fun([Fun([Int], Int)], Fun([Int], Int)))], body: Let(("arr", Var({val: None})), Array(Int(1), Var("dummy")), LetRec({tyvars: [], name: ("aux", Var({val: None})), args: [("x", Var({val: None}))], body: App(Get(Var("arr"), Int(0)), [Var("x")])}, Let(("fixedpoint", Var({val: None})), App(Var("f"), [Var("aux")]), Let(("_", Var({val: None})), Put(Var("arr"), Int(0), Var("fixedpoint")), Var("fixedpoint")))))}, Let(("factorial", Fun([Int], Int)), LetRec({tyvars: [], name: ("g", Var({val: None})), args: [("f", Var({val: None}))], body: LetRec({tyvars: [], name: ("h", Var({val: None})), args: [("x", Var({val: None}))], body: If(Eq(Var("x"), Int(0)), Int(1), Prim(Var("x"), App(Var("f"), [Prim(Var("x"), Int(1), Sub, kind=None)]), Mul, kind=None))}, Var("h"))}, App(Var("landins_knot"), [Var("g")])), LetRec({tyvars: [], name: ("f1", Unit), args: [], body: App(Var("print_int"), [App(Var("factorial"), [Int(5)])])}, Let(("with_effect", Fun([Int], Int)), Let(("a", Var({val: None})), App(Var("factorial"), [Int(5)]), LetRec({tyvars: [], name: ("g", Var({val: None})), args: [("x", Var({val: None}))], body: Prim(Var("x"), Var("a"), Add, kind=None)}, Var("g"))), LetRec({tyvars: [], name: ("main", Var({val: None})), args: [], body: Let(("_", Var({val: None})), App(Var("f1"), []), Let(("_", Var({val: None})), App(Var("print_int"), [App(Var("with_effect"), [Int(10)])]), App(Var("print_int"), [App(Var("with_effect"), [Int(31)])])))}, Unit))))) against Unit
// [Typer] typevars: []
// [Typer] check: Let(("arr", Var({val: None})), Array(Int(1), Var("dummy")), LetRec({tyvars: [], name: ("aux", Var({val: None})), args: [("x", Var({val: None}))], body: App(Get(Var("arr"), Int(0)), [Var("x")])}, Let(("fixedpoint", Var({val: None})), App(Var("f"), [Var("aux")]), Let(("_", Var({val: None})), Put(Var("arr"), Int(0), Var("fixedpoint")), Var("fixedpoint"))))) against Fun([Int], Int)
// [Typer] infer: Array(Int(1), Var("dummy"))
// [Typer] infer: Var("dummy")
// [Typer] inst: TypeScheme(([], Fun([Int], Int)))
// [Typer] inst result: Fun([Int], Int)
// [Typer] check: Int(1) against Int
// [Typer] unify: Var({val: None}) and Array(Fun([Int], Int))
// [Typer] union: Var({val: None}) and Array(Fun([Int], Int))
// [Typer] check: LetRec({tyvars: [], name: ("aux", Var({val: None})), args: [("x", Var({val: None}))], body: App(Get(Var("arr"), Int(0)), [Var("x")])}, Let(("fixedpoint", Var({val: None})), App(Var("f"), [Var("aux")]), Let(("_", Var({val: None})), Put(Var("arr"), Int(0), Var("fixedpoint")), Var("fixedpoint")))) against Fun([Int], Int)
// [Typer] typevars: []
// [Typer] infer: App(Get(Var("arr"), Int(0)), [Var("x")])
// [Typer] infer: Get(Var("arr"), Int(0))
// [Typer] infer: Var("arr")
// [Typer] inst: TypeScheme(([], Var({val: Some(Array(Fun([Int], Int)))})))
// [Typer] inst result: Array(Fun([Int], Int))
// [Typer] check: Int(0) against Int
// [Typer] check: Var("x") against Int
// [Typer] inst: TypeScheme(([], Var({val: None})))
// [Typer] inst result: Var({val: None})
// [Typer] unify: Var({val: None}) and Int
// [Typer] union: Var({val: None}) and Int
// [Typer] unify: Int and Var({val: None})
// [Typer] union: Int and Var({val: None})
// [Typer] check: Let(("fixedpoint", Var({val: None})), App(Var("f"), [Var("aux")]), Let(("_", Var({val: None})), Put(Var("arr"), Int(0), Var("fixedpoint")), Var("fixedpoint"))) against Fun([Int], Int)
// [Typer] infer: App(Var("f"), [Var("aux")])
// [Typer] infer: Var("f")
// [Typer] inst: TypeScheme(([], Fun([Fun([Int], Int)], Fun([Int], Int))))
// [Typer] inst result: Fun([Fun([Int], Int)], Fun([Int], Int))
// [Typer] check: Var("aux") against Fun([Int], Int)
// [Typer] inst: TypeScheme(([], Fun([Var({val: Some(Int)})], Var({val: Some(Int)}))))
// [Typer] inst result: Fun([Int], Int)
// [Typer] unify: Fun([Int], Int) and Fun([Int], Int)
// [Typer] unify: Int and Int
// [Typer] unify: Int and Int
// [Typer] unify: Var({val: None}) and Fun([Int], Int)
// [Typer] union: Var({val: None}) and Fun([Int], Int)
// [Typer] check: Let(("_", Var({val: None})), Put(Var("arr"), Int(0), Var("fixedpoint")), Var("fixedpoint")) against Fun([Int], Int)
// [Typer] infer: Put(Var("arr"), Int(0), Var("fixedpoint"))
// [Typer] infer: Var("fixedpoint")
// [Typer] inst: TypeScheme(([], Var({val: Some(Fun([Int], Int))})))
// [Typer] inst result: Fun([Int], Int)
// [Typer] check: Var("arr") against Array(Fun([Int], Int))
// [Typer] inst: TypeScheme(([], Var({val: Some(Array(Fun([Int], Int)))})))
// [Typer] inst result: Array(Fun([Int], Int))
// [Typer] unify: Array(Fun([Int], Int)) and Array(Fun([Int], Int))
// [Typer] unify: Fun([Int], Int) and Fun([Int], Int)
// [Typer] unify: Int and Int
// [Typer] unify: Int and Int
// [Typer] check: Int(0) against Int
// [Typer] unify: Var({val: None}) and Unit
// [Typer] union: Var({val: None}) and Unit
// [Typer] check: Var("fixedpoint") against Fun([Int], Int)
// [Typer] inst: TypeScheme(([], Var({val: Some(Fun([Int], Int))})))
// [Typer] inst result: Fun([Int], Int)
// [Typer] unify: Fun([Int], Int) and Fun([Int], Int)
// [Typer] unify: Int and Int
// [Typer] unify: Int and Int
// [Typer] check: Let(("factorial", Fun([Int], Int)), LetRec({tyvars: [], name: ("g", Var({val: None})), args: [("f", Var({val: None}))], body: LetRec({tyvars: [], name: ("h", Var({val: None})), args: [("x", Var({val: None}))], body: If(Eq(Var("x"), Int(0)), Int(1), Prim(Var("x"), App(Var("f"), [Prim(Var("x"), Int(1), Sub, kind=None)]), Mul, kind=None))}, Var("h"))}, App(Var("landins_knot"), [Var("g")])), LetRec({tyvars: [], name: ("f1", Unit), args: [], body: App(Var("print_int"), [App(Var("factorial"), [Int(5)])])}, Let(("with_effect", Fun([Int], Int)), Let(("a", Var({val: None})), App(Var("factorial"), [Int(5)]), LetRec({tyvars: [], name: ("g", Var({val: None})), args: [("x", Var({val: None}))], body: Prim(Var("x"), Var("a"), Add, kind=None)}, Var("g"))), LetRec({tyvars: [], name: ("main", Var({val: None})), args: [], body: Let(("_", Var({val: None})), App(Var("f1"), []), Let(("_", Var({val: None})), App(Var("print_int"), [App(Var("with_effect"), [Int(10)])]), App(Var("print_int"), [App(Var("with_effect"), [Int(31)])])))}, Unit)))) against Unit
// [Typer] check: LetRec({tyvars: [], name: ("g", Var({val: None})), args: [("f", Var({val: None}))], body: LetRec({tyvars: [], name: ("h", Var({val: None})), args: [("x", Var({val: None}))], body: If(Eq(Var("x"), Int(0)), Int(1), Prim(Var("x"), App(Var("f"), [Prim(Var("x"), Int(1), Sub, kind=None)]), Mul, kind=None))}, Var("h"))}, App(Var("landins_knot"), [Var("g")])) against Fun([Int], Int)
// [Typer] typevars: []
// [Typer] infer: LetRec({tyvars: [], name: ("h", Var({val: None})), args: [("x", Var({val: None}))], body: If(Eq(Var("x"), Int(0)), Int(1), Prim(Var("x"), App(Var("f"), [Prim(Var("x"), Int(1), Sub, kind=None)]), Mul, kind=None))}, Var("h"))
// [Typer] typevars: []
// [Typer] infer: If(Eq(Var("x"), Int(0)), Int(1), Prim(Var("x"), App(Var("f"), [Prim(Var("x"), Int(1), Sub, kind=None)]), Mul, kind=None))
// [Typer] check: Eq(Var("x"), Int(0)) against Bool
// [Typer] infer: Var("x")
// [Typer] inst: TypeScheme(([], Var({val: None})))
// [Typer] inst result: Var({val: None})
// [Typer] infer: Int(0)
// [Typer] unify: Var({val: None}) and Int
// [Typer] union: Var({val: None}) and Int
// [Typer] infer: Int(1)
// [Typer] infer: Prim(Var("x"), App(Var("f"), [Prim(Var("x"), Int(1), Sub, kind=None)]), Mul, kind=None)
// [Typer] infer: Var("x")
// [Typer] inst: TypeScheme(([], Var({val: Some(Int)})))
// [Typer] inst result: Int
// [Typer] infer: App(Var("f"), [Prim(Var("x"), Int(1), Sub, kind=None)])
// [Typer] infer: Var("f")
// [Typer] inst: TypeScheme(([], Var({val: None})))
// [Typer] inst result: Var({val: None})
// [Typer] infer: Prim(Var("x"), Int(1), Sub, kind=None)
// [Typer] infer: Var("x")
// [Typer] inst: TypeScheme(([], Var({val: Some(Int)})))
// [Typer] inst result: Int
// [Typer] infer: Int(1)
// [Typer] unify: Int and Int
// [Typer] unify: Var({val: None}) and Fun([Int], Var({val: None}))
// [Typer] union: Var({val: None}) and Fun([Int], Var({val: None}))
// [Typer] unify: Int and Var({val: None})
// [Typer] union: Int and Var({val: None})
// [Typer] unify: Int and Int
// [Typer] unify: Int and Var({val: None})
// [Typer] union: Int and Var({val: None})
// [Typer] infer: Var("h")
// [Typer] inst: TypeScheme(([], Fun([Var({val: Some(Int)})], Var({val: Some(Int)}))))
// [Typer] inst result: Fun([Int], Int)
// [Typer] unify: Fun([Int], Int) and Var({val: None})
// [Typer] union: Fun([Int], Int) and Var({val: None})
// [Typer] check: App(Var("landins_knot"), [Var("g")]) against Fun([Int], Int)
// [Typer] infer: Var("g")
// [Typer] inst: TypeScheme(([], Fun([Var({val: Some(Fun([Int], Var({val: Some(Int)})))})], Var({val: Some(Fun([Int], Int))}))))
// [Typer] inst result: Fun([Fun([Int], Int)], Fun([Int], Int))
// [Typer] check: Var("landins_knot") against Fun([Fun([Fun([Int], Int)], Fun([Int], Int))], Fun([Int], Int))
// [Typer] inst: TypeScheme(([], Fun([Fun([Fun([Int], Int)], Fun([Int], Int))], Fun([Int], Int))))
// [Typer] inst result: Fun([Fun([Fun([Int], Int)], Fun([Int], Int))], Fun([Int], Int))
// [Typer] unify: Fun([Fun([Fun([Int], Int)], Fun([Int], Int))], Fun([Int], Int)) and Fun([Fun([Fun([Int], Int)], Fun([Int], Int))], Fun([Int], Int))
// [Typer] unify: Fun([Fun([Int], Int)], Fun([Int], Int)) and Fun([Fun([Int], Int)], Fun([Int], Int))
// [Typer] unify: Fun([Int], Int) and Fun([Int], Int)
// [Typer] unify: Int and Int
// [Typer] unify: Int and Int
// [Typer] unify: Fun([Int], Int) and Fun([Int], Int)
// [Typer] unify: Int and Int
// [Typer] unify: Int and Int
// [Typer] unify: Fun([Int], Int) and Fun([Int], Int)
// [Typer] unify: Int and Int
// [Typer] unify: Int and Int
// [Typer] check: LetRec({tyvars: [], name: ("f1", Unit), args: [], body: App(Var("print_int"), [App(Var("factorial"), [Int(5)])])}, Let(("with_effect", Fun([Int], Int)), Let(("a", Var({val: None})), App(Var("factorial"), [Int(5)]), LetRec({tyvars: [], name: ("g", Var({val: None})), args: [("x", Var({val: None}))], body: Prim(Var("x"), Var("a"), Add, kind=None)}, Var("g"))), LetRec({tyvars: [], name: ("main", Var({val: None})), args: [], body: Let(("_", Var({val: None})), App(Var("f1"), []), Let(("_", Var({val: None})), App(Var("print_int"), [App(Var("with_effect"), [Int(10)])]), App(Var("print_int"), [App(Var("with_effect"), [Int(31)])])))}, Unit))) against Unit
// [Typer] typevars: []
// [Typer] check: App(Var("print_int"), [App(Var("factorial"), [Int(5)])]) against Unit
// [Typer] infer: App(Var("factorial"), [Int(5)])
// [Typer] infer: Var("factorial")
// [Typer] inst: TypeScheme(([], Fun([Int], Int)))
// [Typer] inst result: Fun([Int], Int)
// [Typer] check: Int(5) against Int
// [Typer] check: Var("print_int") against Fun([Int], Unit)
// [Typer] inst: TypeScheme(([], Fun([Int], Unit)))
// [Typer] inst result: Fun([Int], Unit)
// [Typer] unify: Fun([Int], Unit) and Fun([Int], Unit)
// [Typer] unify: Int and Int
// [Typer] unify: Unit and Unit
// [Typer] check: Let(("with_effect", Fun([Int], Int)), Let(("a", Var({val: None})), App(Var("factorial"), [Int(5)]), LetRec({tyvars: [], name: ("g", Var({val: None})), args: [("x", Var({val: None}))], body: Prim(Var("x"), Var("a"), Add, kind=None)}, Var("g"))), LetRec({tyvars: [], name: ("main", Var({val: None})), args: [], body: Let(("_", Var({val: None})), App(Var("f1"), []), Let(("_", Var({val: None})), App(Var("print_int"), [App(Var("with_effect"), [Int(10)])]), App(Var("print_int"), [App(Var("with_effect"), [Int(31)])])))}, Unit)) against Unit
// [Typer] check: Let(("a", Var({val: None})), App(Var("factorial"), [Int(5)]), LetRec({tyvars: [], name: ("g", Var({val: None})), args: [("x", Var({val: None}))], body: Prim(Var("x"), Var("a"), Add, kind=None)}, Var("g"))) against Fun([Int], Int)
// [Typer] infer: App(Var("factorial"), [Int(5)])
// [Typer] infer: Var("factorial")
// [Typer] inst: TypeScheme(([], Fun([Int], Int)))
// [Typer] inst result: Fun([Int], Int)
// [Typer] check: Int(5) against Int
// [Typer] unify: Var({val: None}) and Int
// [Typer] union: Var({val: None}) and Int
// [Typer] check: LetRec({tyvars: [], name: ("g", Var({val: None})), args: [("x", Var({val: None}))], body: Prim(Var("x"), Var("a"), Add, kind=None)}, Var("g")) against Fun([Int], Int)
// [Typer] typevars: []
// [Typer] infer: Prim(Var("x"), Var("a"), Add, kind=None)
// [Typer] infer: Var("x")
// [Typer] inst: TypeScheme(([], Var({val: None})))
// [Typer] inst result: Var({val: None})
// [Typer] infer: Var("a")
// [Typer] inst: TypeScheme(([], Var({val: Some(Int)})))
// [Typer] inst result: Int
// [Typer] unify: Var({val: None}) and Int
// [Typer] union: Var({val: None}) and Int
// [Typer] unify: Int and Var({val: None})
// [Typer] union: Int and Var({val: None})
// [Typer] check: Var("g") against Fun([Int], Int)
// [Typer] inst: TypeScheme(([], Fun([Var({val: Some(Int)})], Var({val: Some(Int)}))))
// [Typer] inst result: Fun([Int], Int)
// [Typer] unify: Fun([Int], Int) and Fun([Int], Int)
// [Typer] unify: Int and Int
// [Typer] unify: Int and Int
// [Typer] check: LetRec({tyvars: [], name: ("main", Var({val: None})), args: [], body: Let(("_", Var({val: None})), App(Var("f1"), []), Let(("_", Var({val: None})), App(Var("print_int"), [App(Var("with_effect"), [Int(10)])]), App(Var("print_int"), [App(Var("with_effect"), [Int(31)])])))}, Unit) against Unit
// [Typer] typevars: []
// [Typer] infer: Let(("_", Var({val: None})), App(Var("f1"), []), Let(("_", Var({val: None})), App(Var("print_int"), [App(Var("with_effect"), [Int(10)])]), App(Var("print_int"), [App(Var("with_effect"), [Int(31)])])))
// [Typer] infer: App(Var("f1"), [])
// [Typer] infer: Var("f1")
// [Typer] inst: TypeScheme(([], Fun([], Unit)))
// [Typer] inst result: Fun([], Unit)
// [Typer] unify: Var({val: None}) and Unit
// [Typer] union: Var({val: None}) and Unit
// [Typer] infer: Let(("_", Var({val: None})), App(Var("print_int"), [App(Var("with_effect"), [Int(10)])]), App(Var("print_int"), [App(Var("with_effect"), [Int(31)])]))
// [Typer] infer: App(Var("print_int"), [App(Var("with_effect"), [Int(10)])])
// [Typer] infer: Var("print_int")
// [Typer] inst: TypeScheme(([], Fun([Int], Unit)))
// [Typer] inst result: Fun([Int], Unit)
// [Typer] check: App(Var("with_effect"), [Int(10)]) against Int
// [Typer] infer: Int(10)
// [Typer] check: Var("with_effect") against Fun([Int], Int)
// [Typer] inst: TypeScheme(([], Fun([Int], Int)))
// [Typer] inst result: Fun([Int], Int)
// [Typer] unify: Fun([Int], Int) and Fun([Int], Int)
// [Typer] unify: Int and Int
// [Typer] unify: Int and Int
// [Typer] unify: Var({val: None}) and Unit
// [Typer] union: Var({val: None}) and Unit
// [Typer] infer: App(Var("print_int"), [App(Var("with_effect"), [Int(31)])])
// [Typer] infer: Var("print_int")
// [Typer] inst: TypeScheme(([], Fun([Int], Unit)))
// [Typer] inst result: Fun([Int], Unit)
// [Typer] check: App(Var("with_effect"), [Int(31)]) against Int
// [Typer] infer: Int(31)
// [Typer] check: Var("with_effect") against Fun([Int], Int)
// [Typer] inst: TypeScheme(([], Fun([Int], Int)))
// [Typer] inst result: Fun([Int], Int)
// [Typer] unify: Fun([Int], Int) and Fun([Int], Int)
// [Typer] unify: Int and Int
// [Typer] unify: Int and Int
// [Typer] unify: Unit and Var({val: None})
// [Typer] union: Unit and Var({val: None})
// [Typer] check: Unit against Unit
// [Parser] flags: []
