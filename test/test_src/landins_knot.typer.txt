let rec dummy: (i: Int) -> Int {
  Var(i)
}
let rec landins_knot: (f: ((Int) -> Int) -> (Int) -> Int) -> (Int) -> Int {
  let arr: Var(Array[(Int) -> Int]) = Array::make(Int(1), Var("dummy"))
  let rec aux: (x: Var(Int)) -> Var(Int) {
    Apply(Get(Var("arr"), Int(0)), [Var("x"), ])
  }
  let fixedpoint: Var((Int) -> Int) = Apply(Var("f"), [Var("aux"), ])
  let _: Var(Unit) = Put Var("arr")[Int(0)] = Var("fixedpoint")
  Var(fixedpoint)
}
let factorial: (Int) -> Int = 
  let rec g: (f: Var((Int) -> Var(Int))) -> Var((Var(Int)) -> Int) {
    let rec h: (x: Var(Int)) -> Var(Int) {
      if (Eq(Var("x"), Int(0))) then {
        Int(1)
      } else {
        Var("x") * App(Var("f"), [Prim(Var("x"), Int(1), Sub, kind=Some(Int))])
      }
    }
    Var(h)
  }
  Apply(Var("landins_knot"), [Var("g"), ])
let rec f1: () -> Unit {
  Apply(Var("print_int"), [App(Var("factorial"), [Int(5)]), ])
}
let with_effect: (Int) -> Int = 
  let a: Var(Int) = Apply(Var("factorial"), [Int(5), ])
  let rec g: (x: Var(Int)) -> Var(Int) {
    Var("x") + Var("a")
  }
  Var(g)
let rec main: () -> Var(Unit) {
  let _: Var(Unit) = Apply(Var("f1"), [])
  let _: Var(Unit) = Apply(Var("print_int"), [App(Var("with_effect"), [Int(10)]), ])
  Apply(Var("print_int"), [App(Var("with_effect"), [Int(31)]), ])
}
Unit
