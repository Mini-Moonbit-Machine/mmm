// [Knf] matcher_run: init mat
// [Knf] {arity: 1, occurs: {occurs: [/\]}, rows: [{binds: @immut/hashmap.of([]), patterns: [Tuple([Bool(true), Wildcard])], action: Int(1)}, {binds: @immut/hashmap.of([]), patterns: [Tuple([Wildcard, Bool(true)])], action: Int(2)}, {binds: @immut/hashmap.of([]), patterns: [Wildcard], action: Int(3)}]}
// [Knf] specialize_matrix: by subpat tuple(2), at col 0:
// [Knf] {arity: 2, occurs: {occurs: [/\.0, /\.1]}, rows: [{binds: @immut/hashmap.of([]), patterns: [Bool(true), Wildcard], action: Int(1)}, {binds: @immut/hashmap.of([]), patterns: [Wildcard, Bool(true)], action: Int(2)}, {binds: @immut/hashmap.of([]), patterns: [Wildcard, Wildcard], action: Int(3)}]}
// [Knf] specialize_matrix: by subpat bool(true), at col 0:
// [Knf] {arity: 1, occurs: {occurs: [/\.1]}, rows: [{binds: @immut/hashmap.of([]), patterns: [Wildcard], action: Int(1)}, {binds: @immut/hashmap.of([]), patterns: [Bool(true)], action: Int(2)}, {binds: @immut/hashmap.of([]), patterns: [Wildcard], action: Int(3)}]}
// [Knf] default_matrix:
// [Knf] {arity: 1, occurs: {occurs: [/\.1]}, rows: [{binds: @immut/hashmap.of([]), patterns: [Bool(true)], action: Int(2)}, {binds: @immut/hashmap.of([]), patterns: [Wildcard], action: Int(3)}]}
// [Knf] specialize_matrix: by subpat bool(true), at col 0:
// [Knf] {arity: 0, occurs: {occurs: []}, rows: [{binds: @immut/hashmap.of([]), patterns: [], action: Int(2)}, {binds: @immut/hashmap.of([]), patterns: [], action: Int(3)}]}
// [Knf] default_matrix:
// [Knf] {arity: 0, occurs: {occurs: []}, rows: [{binds: @immut/hashmap.of([]), patterns: [], action: Int(3)}]}
// [Knf] default_matrix:
// [Knf] {arity: 0, occurs: {occurs: []}, rows: [{binds: @immut/hashmap.of([]), patterns: [], action: Int(3)}]}
// [Knf] matcher_run: final tree
// [Knf] Switch(/\, 
// [Knf]   [(tuple(2), Switch(/\.0, 
// [Knf]     [(bool(true), Succeed({}, Int(1))),
// [Knf]     (fallback, Switch(/\.1, 
// [Knf]       [(bool(true), Succeed({}, Int(2))),
// [Knf]       (fallback, Succeed({}, Int(3)))
// [Knf]     ]))
// [Knf]   ])),
// [Knf]   (fallback, Succeed({}, Int(3)))
// [Knf] ])
// [Knf] decision_tree_to_knf: Switch(/\, 
// [Knf]   [(tuple(2), Switch(/\.0, 
// [Knf]     [(bool(true), Succeed({}, Int(1))),
// [Knf]     (fallback, Switch(/\.1, 
// [Knf]       [(bool(true), Succeed({}, Int(2))),
// [Knf]       (fallback, Succeed({}, Int(3)))
// [Knf]     ]))
// [Knf]   ])),
// [Knf]   (fallback, Succeed({}, Int(3)))
// [Knf] ])
// [Knf] decision_tree_to_knf: Switch(/\.0, 
// [Knf]   [(bool(true), Succeed({}, Int(1))),
// [Knf]   (fallback, Switch(/\.1, 
// [Knf]     [(bool(true), Succeed({}, Int(2))),
// [Knf]     (fallback, Succeed({}, Int(3)))
// [Knf]   ]))
// [Knf] ])
// [Knf] decision_tree_to_knf: Succeed({}, Int(1))
// [Knf] decision_tree_to_knf: Switch(/\.1, 
// [Knf]   [(bool(true), Succeed({}, Int(2))),
// [Knf]   (fallback, Succeed({}, Int(3)))
// [Knf] ])
// [Knf] decision_tree_to_knf: Succeed({}, Int(2))
// [Knf] decision_tree_to_knf: Succeed({}, Int(3))
// [Knf] matcher_run: init mat
// [Knf] {arity: 1, occurs: {occurs: [/\]}, rows: [{binds: @immut/hashmap.of([]), patterns: [Tuple([Bool(true), Wildcard, Wildcard])], action: Int(1)}, {binds: @immut/hashmap.of([]), patterns: [Tuple([Wildcard, Bool(true), Wildcard])], action: Int(2)}, {binds: @immut/hashmap.of([]), patterns: [Tuple([Wildcard, Wildcard, Bool(true)])], action: Int(3)}, {binds: @immut/hashmap.of([]), patterns: [Wildcard], action: Int(4)}]}
// [Knf] specialize_matrix: by subpat tuple(3), at col 0:
// [Knf] {arity: 3, occurs: {occurs: [/\.0, /\.1, /\.2]}, rows: [{binds: @immut/hashmap.of([]), patterns: [Bool(true), Wildcard, Wildcard], action: Int(1)}, {binds: @immut/hashmap.of([]), patterns: [Wildcard, Bool(true), Wildcard], action: Int(2)}, {binds: @immut/hashmap.of([]), patterns: [Wildcard, Wildcard, Bool(true)], action: Int(3)}, {binds: @immut/hashmap.of([]), patterns: [Wildcard, Wildcard, Wildcard], action: Int(4)}]}
// [Knf] specialize_matrix: by subpat bool(true), at col 0:
// [Knf] {arity: 2, occurs: {occurs: [/\.1, /\.2]}, rows: [{binds: @immut/hashmap.of([]), patterns: [Wildcard, Wildcard], action: Int(1)}, {binds: @immut/hashmap.of([]), patterns: [Bool(true), Wildcard], action: Int(2)}, {binds: @immut/hashmap.of([]), patterns: [Wildcard, Bool(true)], action: Int(3)}, {binds: @immut/hashmap.of([]), patterns: [Wildcard, Wildcard], action: Int(4)}]}
// [Knf] default_matrix:
// [Knf] {arity: 2, occurs: {occurs: [/\.1, /\.2]}, rows: [{binds: @immut/hashmap.of([]), patterns: [Bool(true), Wildcard], action: Int(2)}, {binds: @immut/hashmap.of([]), patterns: [Wildcard, Bool(true)], action: Int(3)}, {binds: @immut/hashmap.of([]), patterns: [Wildcard, Wildcard], action: Int(4)}]}
// [Knf] specialize_matrix: by subpat bool(true), at col 0:
// [Knf] {arity: 1, occurs: {occurs: [/\.2]}, rows: [{binds: @immut/hashmap.of([]), patterns: [Wildcard], action: Int(2)}, {binds: @immut/hashmap.of([]), patterns: [Bool(true)], action: Int(3)}, {binds: @immut/hashmap.of([]), patterns: [Wildcard], action: Int(4)}]}
// [Knf] default_matrix:
// [Knf] {arity: 1, occurs: {occurs: [/\.2]}, rows: [{binds: @immut/hashmap.of([]), patterns: [Bool(true)], action: Int(3)}, {binds: @immut/hashmap.of([]), patterns: [Wildcard], action: Int(4)}]}
// [Knf] specialize_matrix: by subpat bool(true), at col 0:
// [Knf] {arity: 0, occurs: {occurs: []}, rows: [{binds: @immut/hashmap.of([]), patterns: [], action: Int(3)}, {binds: @immut/hashmap.of([]), patterns: [], action: Int(4)}]}
// [Knf] default_matrix:
// [Knf] {arity: 0, occurs: {occurs: []}, rows: [{binds: @immut/hashmap.of([]), patterns: [], action: Int(4)}]}
// [Knf] default_matrix:
// [Knf] {arity: 0, occurs: {occurs: []}, rows: [{binds: @immut/hashmap.of([]), patterns: [], action: Int(4)}]}
// [Knf] matcher_run: final tree
// [Knf] Switch(/\, 
// [Knf]   [(tuple(3), Switch(/\.0, 
// [Knf]     [(bool(true), Succeed({}, Int(1))),
// [Knf]     (fallback, Switch(/\.1, 
// [Knf]       [(bool(true), Succeed({}, Int(2))),
// [Knf]       (fallback, Switch(/\.2, 
// [Knf]         [(bool(true), Succeed({}, Int(3))),
// [Knf]         (fallback, Succeed({}, Int(4)))
// [Knf]       ]))
// [Knf]     ]))
// [Knf]   ])),
// [Knf]   (fallback, Succeed({}, Int(4)))
// [Knf] ])
// [Knf] decision_tree_to_knf: Switch(/\, 
// [Knf]   [(tuple(3), Switch(/\.0, 
// [Knf]     [(bool(true), Succeed({}, Int(1))),
// [Knf]     (fallback, Switch(/\.1, 
// [Knf]       [(bool(true), Succeed({}, Int(2))),
// [Knf]       (fallback, Switch(/\.2, 
// [Knf]         [(bool(true), Succeed({}, Int(3))),
// [Knf]         (fallback, Succeed({}, Int(4)))
// [Knf]       ]))
// [Knf]     ]))
// [Knf]   ])),
// [Knf]   (fallback, Succeed({}, Int(4)))
// [Knf] ])
// [Knf] decision_tree_to_knf: Switch(/\.0, 
// [Knf]   [(bool(true), Succeed({}, Int(1))),
// [Knf]   (fallback, Switch(/\.1, 
// [Knf]     [(bool(true), Succeed({}, Int(2))),
// [Knf]     (fallback, Switch(/\.2, 
// [Knf]       [(bool(true), Succeed({}, Int(3))),
// [Knf]       (fallback, Succeed({}, Int(4)))
// [Knf]     ]))
// [Knf]   ]))
// [Knf] ])
// [Knf] decision_tree_to_knf: Succeed({}, Int(1))
// [Knf] decision_tree_to_knf: Switch(/\.1, 
// [Knf]   [(bool(true), Succeed({}, Int(2))),
// [Knf]   (fallback, Switch(/\.2, 
// [Knf]     [(bool(true), Succeed({}, Int(3))),
// [Knf]     (fallback, Succeed({}, Int(4)))
// [Knf]   ]))
// [Knf] ])
// [Knf] decision_tree_to_knf: Succeed({}, Int(2))
// [Knf] decision_tree_to_knf: Switch(/\.2, 
// [Knf]   [(bool(true), Succeed({}, Int(3))),
// [Knf]   (fallback, Succeed({}, Int(4)))
// [Knf] ])
// [Knf] decision_tree_to_knf: Succeed({}, Int(3))
// [Knf] decision_tree_to_knf: Succeed({}, Int(4))
// [Knf] matcher_run: init mat
// [Knf] {arity: 1, occurs: {occurs: [/\]}, rows: [{binds: @immut/hashmap.of([]), patterns: [Tuple([Int(1), Int(2), Int(3), Int(5)])], action: Int(1)}, {binds: @immut/hashmap.of([]), patterns: [Tuple([Int(1), Int(2), Int(3), Int(6)])], action: Int(2)}, {binds: @immut/hashmap.of([]), patterns: [Tuple([Int(1), Int(2), Int(3), Int(7)])], action: Int(3)}, {binds: @immut/hashmap.of([]), patterns: [Wildcard], action: Int(4)}]}
// [Knf] specialize_matrix: by subpat tuple(4), at col 0:
// [Knf] {arity: 4, occurs: {occurs: [/\.0, /\.1, /\.2, /\.3]}, rows: [{binds: @immut/hashmap.of([]), patterns: [Int(1), Int(2), Int(3), Int(5)], action: Int(1)}, {binds: @immut/hashmap.of([]), patterns: [Int(1), Int(2), Int(3), Int(6)], action: Int(2)}, {binds: @immut/hashmap.of([]), patterns: [Int(1), Int(2), Int(3), Int(7)], action: Int(3)}, {binds: @immut/hashmap.of([]), patterns: [Wildcard, Wildcard, Wildcard, Wildcard], action: Int(4)}]}
// [Knf] specialize_matrix: by subpat int(1), at col 0:
// [Knf] {arity: 3, occurs: {occurs: [/\.1, /\.2, /\.3]}, rows: [{binds: @immut/hashmap.of([]), patterns: [Int(2), Int(3), Int(5)], action: Int(1)}, {binds: @immut/hashmap.of([]), patterns: [Int(2), Int(3), Int(6)], action: Int(2)}, {binds: @immut/hashmap.of([]), patterns: [Int(2), Int(3), Int(7)], action: Int(3)}, {binds: @immut/hashmap.of([]), patterns: [Wildcard, Wildcard, Wildcard], action: Int(4)}]}
// [Knf] specialize_matrix: by subpat int(2), at col 0:
// [Knf] {arity: 2, occurs: {occurs: [/\.2, /\.3]}, rows: [{binds: @immut/hashmap.of([]), patterns: [Int(3), Int(5)], action: Int(1)}, {binds: @immut/hashmap.of([]), patterns: [Int(3), Int(6)], action: Int(2)}, {binds: @immut/hashmap.of([]), patterns: [Int(3), Int(7)], action: Int(3)}, {binds: @immut/hashmap.of([]), patterns: [Wildcard, Wildcard], action: Int(4)}]}
// [Knf] specialize_matrix: by subpat int(3), at col 0:
// [Knf] {arity: 1, occurs: {occurs: [/\.3]}, rows: [{binds: @immut/hashmap.of([]), patterns: [Int(5)], action: Int(1)}, {binds: @immut/hashmap.of([]), patterns: [Int(6)], action: Int(2)}, {binds: @immut/hashmap.of([]), patterns: [Int(7)], action: Int(3)}, {binds: @immut/hashmap.of([]), patterns: [Wildcard], action: Int(4)}]}
// [Knf] specialize_matrix: by subpat int(5), at col 0:
// [Knf] {arity: 0, occurs: {occurs: []}, rows: [{binds: @immut/hashmap.of([]), patterns: [], action: Int(1)}, {binds: @immut/hashmap.of([]), patterns: [], action: Int(4)}]}
// [Knf] specialize_matrix: by subpat int(6), at col 0:
// [Knf] {arity: 0, occurs: {occurs: []}, rows: [{binds: @immut/hashmap.of([]), patterns: [], action: Int(2)}, {binds: @immut/hashmap.of([]), patterns: [], action: Int(4)}]}
// [Knf] specialize_matrix: by subpat int(7), at col 0:
// [Knf] {arity: 0, occurs: {occurs: []}, rows: [{binds: @immut/hashmap.of([]), patterns: [], action: Int(3)}, {binds: @immut/hashmap.of([]), patterns: [], action: Int(4)}]}
// [Knf] default_matrix:
// [Knf] {arity: 0, occurs: {occurs: []}, rows: [{binds: @immut/hashmap.of([]), patterns: [], action: Int(4)}]}
// [Knf] default_matrix:
// [Knf] {arity: 1, occurs: {occurs: [/\.3]}, rows: [{binds: @immut/hashmap.of([]), patterns: [Wildcard], action: Int(4)}]}
// [Knf] default_matrix:
// [Knf] {arity: 2, occurs: {occurs: [/\.2, /\.3]}, rows: [{binds: @immut/hashmap.of([]), patterns: [Wildcard, Wildcard], action: Int(4)}]}
// [Knf] default_matrix:
// [Knf] {arity: 3, occurs: {occurs: [/\.1, /\.2, /\.3]}, rows: [{binds: @immut/hashmap.of([]), patterns: [Wildcard, Wildcard, Wildcard], action: Int(4)}]}
// [Knf] default_matrix:
// [Knf] {arity: 0, occurs: {occurs: []}, rows: [{binds: @immut/hashmap.of([]), patterns: [], action: Int(4)}]}
// [Knf] matcher_run: final tree
// [Knf] Switch(/\, 
// [Knf]   [(tuple(4), Switch(/\.0, 
// [Knf]     [(int(1), Switch(/\.1, 
// [Knf]       [(int(2), Switch(/\.2, 
// [Knf]         [(int(3), Switch(/\.3, 
// [Knf]           [(int(5), Succeed({}, Int(1))),
// [Knf]           (int(6), Succeed({}, Int(2))),
// [Knf]           (int(7), Succeed({}, Int(3))),
// [Knf]           (fallback, Succeed({}, Int(4)))
// [Knf]         ])),
// [Knf]         (fallback, Succeed({}, Int(4)))
// [Knf]       ])),
// [Knf]       (fallback, Succeed({}, Int(4)))
// [Knf]     ])),
// [Knf]     (fallback, Succeed({}, Int(4)))
// [Knf]   ])),
// [Knf]   (fallback, Succeed({}, Int(4)))
// [Knf] ])
// [Knf] decision_tree_to_knf: Switch(/\, 
// [Knf]   [(tuple(4), Switch(/\.0, 
// [Knf]     [(int(1), Switch(/\.1, 
// [Knf]       [(int(2), Switch(/\.2, 
// [Knf]         [(int(3), Switch(/\.3, 
// [Knf]           [(int(5), Succeed({}, Int(1))),
// [Knf]           (int(6), Succeed({}, Int(2))),
// [Knf]           (int(7), Succeed({}, Int(3))),
// [Knf]           (fallback, Succeed({}, Int(4)))
// [Knf]         ])),
// [Knf]         (fallback, Succeed({}, Int(4)))
// [Knf]       ])),
// [Knf]       (fallback, Succeed({}, Int(4)))
// [Knf]     ])),
// [Knf]     (fallback, Succeed({}, Int(4)))
// [Knf]   ])),
// [Knf]   (fallback, Succeed({}, Int(4)))
// [Knf] ])
// [Knf] decision_tree_to_knf: Switch(/\.0, 
// [Knf]   [(int(1), Switch(/\.1, 
// [Knf]     [(int(2), Switch(/\.2, 
// [Knf]       [(int(3), Switch(/\.3, 
// [Knf]         [(int(5), Succeed({}, Int(1))),
// [Knf]         (int(6), Succeed({}, Int(2))),
// [Knf]         (int(7), Succeed({}, Int(3))),
// [Knf]         (fallback, Succeed({}, Int(4)))
// [Knf]       ])),
// [Knf]       (fallback, Succeed({}, Int(4)))
// [Knf]     ])),
// [Knf]     (fallback, Succeed({}, Int(4)))
// [Knf]   ])),
// [Knf]   (fallback, Succeed({}, Int(4)))
// [Knf] ])
// [Knf] decision_tree_to_knf: Switch(/\.1, 
// [Knf]   [(int(2), Switch(/\.2, 
// [Knf]     [(int(3), Switch(/\.3, 
// [Knf]       [(int(5), Succeed({}, Int(1))),
// [Knf]       (int(6), Succeed({}, Int(2))),
// [Knf]       (int(7), Succeed({}, Int(3))),
// [Knf]       (fallback, Succeed({}, Int(4)))
// [Knf]     ])),
// [Knf]     (fallback, Succeed({}, Int(4)))
// [Knf]   ])),
// [Knf]   (fallback, Succeed({}, Int(4)))
// [Knf] ])
// [Knf] decision_tree_to_knf: Switch(/\.2, 
// [Knf]   [(int(3), Switch(/\.3, 
// [Knf]     [(int(5), Succeed({}, Int(1))),
// [Knf]     (int(6), Succeed({}, Int(2))),
// [Knf]     (int(7), Succeed({}, Int(3))),
// [Knf]     (fallback, Succeed({}, Int(4)))
// [Knf]   ])),
// [Knf]   (fallback, Succeed({}, Int(4)))
// [Knf] ])
// [Knf] decision_tree_to_knf: Switch(/\.3, 
// [Knf]   [(int(5), Succeed({}, Int(1))),
// [Knf]   (int(6), Succeed({}, Int(2))),
// [Knf]   (int(7), Succeed({}, Int(3))),
// [Knf]   (fallback, Succeed({}, Int(4)))
// [Knf] ])
// [Knf] decision_tree_to_knf: Succeed({}, Int(1))
// [Knf] decision_tree_to_knf: Succeed({}, Int(2))
// [Knf] decision_tree_to_knf: Succeed({}, Int(3))
// [Knf] decision_tree_to_knf: Succeed({}, Int(4))
// [Knf] decision_tree_to_knf: Succeed({}, Int(4))
// [Knf] decision_tree_to_knf: Succeed({}, Int(4))
// [Knf] decision_tree_to_knf: Succeed({}, Int(4))
// [Knf] matcher_run: init mat
// [Knf] {arity: 1, occurs: {occurs: [/\]}, rows: [{binds: @immut/hashmap.of([]), patterns: [CtorApp("A", [CtorApp("B", [Var("a"), Var("b")]), CtorApp("B", [Var("c"), Var("d")])])], action: Int(1)}, {binds: @immut/hashmap.of([]), patterns: [CtorApp("A", [CtorApp("C", []), CtorApp("B", [Var("a"), Var("b")])])], action: Int(2)}, {binds: @immut/hashmap.of([]), patterns: [CtorApp("A", [CtorApp("B", [Int(1), Int(3)]), CtorApp("C", [])])], action: Int(3)}, {binds: @immut/hashmap.of([]), patterns: [CtorApp("A", [CtorApp("B", [Int(1), Int(2)]), CtorApp("C", [])])], action: Int(4)}, {binds: @immut/hashmap.of([]), patterns: [CtorApp("B", [Wildcard, Wildcard])], action: Int(5)}, {binds: @immut/hashmap.of([]), patterns: [CtorApp("C", [])], action: Int(6)}]}
// [Knf] specialize_matrix: by subpat ctor(A, 2), at col 0:
// [Knf] {arity: 2, occurs: {occurs: [/\.0, /\.1]}, rows: [{binds: @immut/hashmap.of([]), patterns: [CtorApp("B", [Var("a"), Var("b")]), CtorApp("B", [Var("c"), Var("d")])], action: Int(1)}, {binds: @immut/hashmap.of([]), patterns: [CtorApp("C", []), CtorApp("B", [Var("a"), Var("b")])], action: Int(2)}, {binds: @immut/hashmap.of([]), patterns: [CtorApp("B", [Int(1), Int(3)]), CtorApp("C", [])], action: Int(3)}, {binds: @immut/hashmap.of([]), patterns: [CtorApp("B", [Int(1), Int(2)]), CtorApp("C", [])], action: Int(4)}]}
// [Knf] specialize_matrix: by subpat ctor(B, 2), at col 1:
// [Knf] {arity: 3, occurs: {occurs: [/\.0, /\.1.0, /\.1.1]}, rows: [{binds: @immut/hashmap.of([]), patterns: [CtorApp("B", [Var("a"), Var("b")]), Var("c"), Var("d")], action: Int(1)}, {binds: @immut/hashmap.of([]), patterns: [CtorApp("C", []), Var("a"), Var("b")], action: Int(2)}]}
// [Knf] specialize_matrix: by subpat ctor(B, 2), at col 0:
// [Knf] {arity: 4, occurs: {occurs: [/\.0.0, /\.0.1, /\.1.0, /\.1.1]}, rows: [{binds: @immut/hashmap.of([]), patterns: [Var("a"), Var("b"), Var("c"), Var("d")], action: Int(1)}]}
// [Knf] specialize_matrix: by subpat ctor(C, 0), at col 0:
// [Knf] {arity: 2, occurs: {occurs: [/\.1.0, /\.1.1]}, rows: [{binds: @immut/hashmap.of([]), patterns: [Var("a"), Var("b")], action: Int(2)}]}
// [Knf] default_matrix:
// [Knf] {arity: 2, occurs: {occurs: [/\.1.0, /\.1.1]}, rows: []}
// [Knf] specialize_matrix: by subpat ctor(C, 0), at col 1:
// [Knf] {arity: 1, occurs: {occurs: [/\.0]}, rows: [{binds: @immut/hashmap.of([]), patterns: [CtorApp("B", [Int(1), Int(3)])], action: Int(3)}, {binds: @immut/hashmap.of([]), patterns: [CtorApp("B", [Int(1), Int(2)])], action: Int(4)}]}
// [Knf] specialize_matrix: by subpat ctor(B, 2), at col 0:
// [Knf] {arity: 2, occurs: {occurs: [/\.0.0, /\.0.1]}, rows: [{binds: @immut/hashmap.of([]), patterns: [Int(1), Int(3)], action: Int(3)}, {binds: @immut/hashmap.of([]), patterns: [Int(1), Int(2)], action: Int(4)}]}
// [Knf] specialize_matrix: by subpat int(1), at col 0:
// [Knf] {arity: 1, occurs: {occurs: [/\.0.1]}, rows: [{binds: @immut/hashmap.of([]), patterns: [Int(3)], action: Int(3)}, {binds: @immut/hashmap.of([]), patterns: [Int(2)], action: Int(4)}]}
// [Knf] specialize_matrix: by subpat int(3), at col 0:
// [Knf] {arity: 0, occurs: {occurs: []}, rows: [{binds: @immut/hashmap.of([]), patterns: [], action: Int(3)}]}
// [Knf] specialize_matrix: by subpat int(2), at col 0:
// [Knf] {arity: 0, occurs: {occurs: []}, rows: [{binds: @immut/hashmap.of([]), patterns: [], action: Int(4)}]}
// [Knf] default_matrix:
// [Knf] {arity: 0, occurs: {occurs: []}, rows: []}
// [Knf] default_matrix:
// [Knf] {arity: 1, occurs: {occurs: [/\.0.1]}, rows: []}
// [Knf] default_matrix:
// [Knf] {arity: 0, occurs: {occurs: []}, rows: []}
// [Knf] default_matrix:
// [Knf] {arity: 1, occurs: {occurs: [/\.0]}, rows: []}
// [Knf] specialize_matrix: by subpat ctor(B, 2), at col 0:
// [Knf] {arity: 2, occurs: {occurs: [/\.0, /\.1]}, rows: [{binds: @immut/hashmap.of([]), patterns: [Wildcard, Wildcard], action: Int(5)}]}
// [Knf] specialize_matrix: by subpat ctor(C, 0), at col 0:
// [Knf] {arity: 0, occurs: {occurs: []}, rows: [{binds: @immut/hashmap.of([]), patterns: [], action: Int(6)}]}
// [Knf] default_matrix:
// [Knf] {arity: 0, occurs: {occurs: []}, rows: []}
// [Knf] matcher_run: final tree
// [Knf] Switch(/\, 
// [Knf]   [(ctor(A, 2), Switch(/\.1, 
// [Knf]     [(ctor(B, 2), Switch(/\.0, 
// [Knf]       [(ctor(B, 2), Succeed({/\.0.1 -> b, /\.0.0 -> a, /\.1.1 -> d, /\.1.0 -> c, }, Int(1))),
// [Knf]       (ctor(C, 0), Succeed({/\.1.1 -> b, /\.1.0 -> a, }, Int(2))),
// [Knf]       
// [Knf]     ])),
// [Knf]     (ctor(C, 0), Switch(/\.0, 
// [Knf]       [(ctor(B, 2), Switch(/\.0.0, 
// [Knf]         [(int(1), Switch(/\.0.1, 
// [Knf]           [(int(3), Succeed({}, Int(3))),
// [Knf]           (int(2), Succeed({}, Int(4))),
// [Knf]           
// [Knf]         ])),
// [Knf]         
// [Knf]       ])),
// [Knf]       
// [Knf]     ])),
// [Knf]     
// [Knf]   ])),
// [Knf]   (ctor(B, 2), Succeed({}, Int(5))),
// [Knf]   (ctor(C, 0), Succeed({}, Int(6))),
// [Knf]   
// [Knf] ])
// [Knf] decision_tree_to_knf: Switch(/\, 
// [Knf]   [(ctor(A, 2), Switch(/\.1, 
// [Knf]     [(ctor(B, 2), Switch(/\.0, 
// [Knf]       [(ctor(B, 2), Succeed({/\.0.1 -> b, /\.0.0 -> a, /\.1.1 -> d, /\.1.0 -> c, }, Int(1))),
// [Knf]       (ctor(C, 0), Succeed({/\.1.1 -> b, /\.1.0 -> a, }, Int(2))),
// [Knf]       
// [Knf]     ])),
// [Knf]     (ctor(C, 0), Switch(/\.0, 
// [Knf]       [(ctor(B, 2), Switch(/\.0.0, 
// [Knf]         [(int(1), Switch(/\.0.1, 
// [Knf]           [(int(3), Succeed({}, Int(3))),
// [Knf]           (int(2), Succeed({}, Int(4))),
// [Knf]           
// [Knf]         ])),
// [Knf]         
// [Knf]       ])),
// [Knf]       
// [Knf]     ])),
// [Knf]     
// [Knf]   ])),
// [Knf]   (ctor(B, 2), Succeed({}, Int(5))),
// [Knf]   (ctor(C, 0), Succeed({}, Int(6))),
// [Knf]   
// [Knf] ])
// [Knf] decision_tree_to_knf: Switch(/\.1, 
// [Knf]   [(ctor(B, 2), Switch(/\.0, 
// [Knf]     [(ctor(B, 2), Succeed({/\.0.1 -> b, /\.0.0 -> a, /\.1.1 -> d, /\.1.0 -> c, }, Int(1))),
// [Knf]     (ctor(C, 0), Succeed({/\.1.1 -> b, /\.1.0 -> a, }, Int(2))),
// [Knf]     
// [Knf]   ])),
// [Knf]   (ctor(C, 0), Switch(/\.0, 
// [Knf]     [(ctor(B, 2), Switch(/\.0.0, 
// [Knf]       [(int(1), Switch(/\.0.1, 
// [Knf]         [(int(3), Succeed({}, Int(3))),
// [Knf]         (int(2), Succeed({}, Int(4))),
// [Knf]         
// [Knf]       ])),
// [Knf]       
// [Knf]     ])),
// [Knf]     
// [Knf]   ])),
// [Knf]   
// [Knf] ])
// [Knf] decision_tree_to_knf: Switch(/\.0, 
// [Knf]   [(ctor(B, 2), Succeed({/\.0.1 -> b, /\.0.0 -> a, /\.1.1 -> d, /\.1.0 -> c, }, Int(1))),
// [Knf]   (ctor(C, 0), Succeed({/\.1.1 -> b, /\.1.0 -> a, }, Int(2))),
// [Knf]   
// [Knf] ])
// [Knf] decision_tree_to_knf: Succeed({/\.0.1 -> b, /\.0.0 -> a, /\.1.1 -> d, /\.1.0 -> c, }, Int(1))
// [Knf] decision_tree_to_knf: Succeed({/\.1.1 -> b, /\.1.0 -> a, }, Int(2))
// [Knf] decision_tree_to_knf: Switch(/\.0, 
// [Knf]   [(ctor(B, 2), Switch(/\.0.0, 
// [Knf]     [(int(1), Switch(/\.0.1, 
// [Knf]       [(int(3), Succeed({}, Int(3))),
// [Knf]       (int(2), Succeed({}, Int(4))),
// [Knf]       
// [Knf]     ])),
// [Knf]     
// [Knf]   ])),
// [Knf]   
// [Knf] ])
// [Knf] decision_tree_to_knf: Switch(/\.0.0, 
// [Knf]   [(int(1), Switch(/\.0.1, 
// [Knf]     [(int(3), Succeed({}, Int(3))),
// [Knf]     (int(2), Succeed({}, Int(4))),
// [Knf]     
// [Knf]   ])),
// [Knf]   
// [Knf] ])
// [Knf] decision_tree_to_knf: Switch(/\.0.1, 
// [Knf]   [(int(3), Succeed({}, Int(3))),
// [Knf]   (int(2), Succeed({}, Int(4))),
// [Knf]   
// [Knf] ])
// [Knf] decision_tree_to_knf: Succeed({}, Int(3))
// [Knf] decision_tree_to_knf: Succeed({}, Int(4))
// [Knf] decision_tree_to_knf: Succeed({}, Int(5))
// [Knf] decision_tree_to_knf: Succeed({}, Int(6))
// [Main] function thunk_main(k) {
// [Main]   function main_1(k) {
// [Main]     const _2 = true;
// [Main]     const _3 = false;
// [Main]     const _4 = [_2, _3];
// [Main]     const [_5, _6] = _4;
// [Main]     const _7 = true;
// [Main]     function j6(i_9) {
// [Main]       const _10 = 1;
// [Main]       function j5(_11) {
// [Main]         const _12 = 2;
// [Main]         function j4(_13) {
// [Main]           const _14 = 3;
// [Main]           function j3(_15) {
// [Main]             const _16 = [_11, _13, _15];
// [Main]             const [_17, _18, _19] = _16;
// [Main]             const _20 = true;
// [Main]             function j2(j_23) {
// [Main]               const _24 = 1;
// [Main]               const _25 = j_23 + _24;
// [Main]               const _26 = 2;
// [Main]               const _27 = j_23 + _26;
// [Main]               const _28 = 3;
// [Main]               const _29 = j_23 + _28;
// [Main]               const _30 = [j_23, _25, _27, _29];
// [Main]               const [_31, _32, _33, _34] = _30;
// [Main]               const _35 = 1;
// [Main]               function j1(k_41) {
// [Main]                 const _42 = 0;
// [Main]                 const _43 = 1;
// [Main]                 const _44 = 1;
// [Main]                 const _45 = 2;
// [Main]                 const _46 = [_44, _45];
// [Main]                 const _47 = [_43, _46];
// [Main]                 const _48 = 2;
// [Main]                 const _49 = [];
// [Main]                 const _50 = [_48, _49];
// [Main]                 const _51 = [_47, _50];
// [Main]                 const _52 = [_42, _51];
// [Main]                 const _53 = 0;
// [Main]                 const [_54, _55] = _52;
// [Main]                 function j0(m_90) {
// [Main]                   return $thunk(() => $external(minimbt_print_int, function (_92) {
// [Main]                     return $thunk(() => $external(minimbt_print_int, function (_94) {
// [Main]                       return $thunk(() => $external(minimbt_print_int, function (_96) {
// [Main]                         return $thunk(() => $external(minimbt_print_int, function (_98) {
// [Main]                           return $thunk(() => k(null))
// [Main]                         }
// [Main]                         , m_90))
// [Main]                       }
// [Main]                       , k_41))
// [Main]                     }
// [Main]                     , j_23))
// [Main]                   }
// [Main]                   , i_9))
// [Main]                 }
// [Main]                 if (_54 === _53) {
// [Main]                   const [_56, _57] = _55;
// [Main]                   const _58 = 1;
// [Main]                   const [_59, _60] = _57;
// [Main]                   if (_59 === _58) {
// [Main]                     const [_61, _62] = _60;
// [Main]                     const _63 = 1;
// [Main]                     const [_64, _65] = _56;
// [Main]                     if (_64 === _63) {
// [Main]                       const [_66, _67] = _65;
// [Main]                       return $thunk(() => j0(1))
// [Main]                     } else {
// [Main]                       const _68 = 2;
// [Main]                       const [_69, _70] = _56;
// [Main]                       if (_69 === _68) {
// [Main]                         const [] = _70;
// [Main]                         return $thunk(() => j0(2))
// [Main]                       } else {
// [Main]                         return $thunk(() => $external(minimbt_panic, function (x) {
// [Main]                           return $thunk(() => j0(x))
// [Main]                         }
// [Main]                         ))
// [Main]                       }
// [Main]                     }
// [Main]                   } else {
// [Main]                     const _71 = 2;
// [Main]                     const [_72, _73] = _57;
// [Main]                     if (_72 === _71) {
// [Main]                       const [] = _73;
// [Main]                       const _74 = 1;
// [Main]                       const [_75, _76] = _56;
// [Main]                       if (_75 === _74) {
// [Main]                         const [_77, _78] = _76;
// [Main]                         const _79 = 1;
// [Main]                         if (_77 === _79) {
// [Main]                           const _80 = 3;
// [Main]                           if (_78 === _80) {
// [Main]                             return $thunk(() => j0(3))
// [Main]                           } else {
// [Main]                             const _81 = 2;
// [Main]                             if (_78 === _81) {
// [Main]                               return $thunk(() => j0(4))
// [Main]                             } else {
// [Main]                               return $thunk(() => $external(minimbt_panic, function (x) {
// [Main]                                 return $thunk(() => j0(x))
// [Main]                               }
// [Main]                               ))
// [Main]                             }
// [Main]                           }
// [Main]                         } else {
// [Main]                           return $thunk(() => $external(minimbt_panic, function (x) {
// [Main]                             return $thunk(() => j0(x))
// [Main]                           }
// [Main]                           ))
// [Main]                         }
// [Main]                       } else {
// [Main]                         return $thunk(() => $external(minimbt_panic, function (x) {
// [Main]                           return $thunk(() => j0(x))
// [Main]                         }
// [Main]                         ))
// [Main]                       }
// [Main]                     } else {
// [Main]                       return $thunk(() => $external(minimbt_panic, function (x) {
// [Main]                         return $thunk(() => j0(x))
// [Main]                       }
// [Main]                       ))
// [Main]                     }
// [Main]                   }
// [Main]                 } else {
// [Main]                   const _82 = 1;
// [Main]                   const [_83, _84] = _52;
// [Main]                   if (_83 === _82) {
// [Main]                     const [_85, _86] = _84;
// [Main]                     return $thunk(() => j0(5))
// [Main]                   } else {
// [Main]                     const _87 = 2;
// [Main]                     const [_88, _89] = _52;
// [Main]                     if (_88 === _87) {
// [Main]                       const [] = _89;
// [Main]                       return $thunk(() => j0(6))
// [Main]                     } else {
// [Main]                       return $thunk(() => $external(minimbt_panic, function (x) {
// [Main]                         return $thunk(() => j0(x))
// [Main]                       }
// [Main]                       ))
// [Main]                     }
// [Main]                   }
// [Main]                 }
// [Main]               }
// [Main]               if (_31 === _35) {
// [Main]                 const _36 = 2;
// [Main]                 if (_32 === _36) {
// [Main]                   const _37 = 3;
// [Main]                   if (_33 === _37) {
// [Main]                     const _38 = 5;
// [Main]                     if (_34 === _38) {
// [Main]                       return $thunk(() => j1(1))
// [Main]                     } else {
// [Main]                       const _39 = 6;
// [Main]                       if (_34 === _39) {
// [Main]                         return $thunk(() => j1(2))
// [Main]                       } else {
// [Main]                         const _40 = 7;
// [Main]                         if (_34 === _40) {
// [Main]                           return $thunk(() => j1(3))
// [Main]                         } else {
// [Main]                           return $thunk(() => j1(4))
// [Main]                         }
// [Main]                       }
// [Main]                     }
// [Main]                   } else {
// [Main]                     return $thunk(() => j1(4))
// [Main]                   }
// [Main]                 } else {
// [Main]                   return $thunk(() => j1(4))
// [Main]                 }
// [Main]               } else {
// [Main]                 return $thunk(() => j1(4))
// [Main]               }
// [Main]             }
// [Main]             if (_17 === _20) {
// [Main]               return $thunk(() => j2(1))
// [Main]             } else {
// [Main]               const _21 = true;
// [Main]               if (_18 === _21) {
// [Main]                 return $thunk(() => j2(2))
// [Main]               } else {
// [Main]                 const _22 = true;
// [Main]                 if (_19 === _22) {
// [Main]                   return $thunk(() => j2(3))
// [Main]                 } else {
// [Main]                   return $thunk(() => j2(4))
// [Main]                 }
// [Main]               }
// [Main]             }
// [Main]           }
// [Main]           if (i_9 <= _14) {
// [Main]             return $thunk(() => j3(true))
// [Main]           } else {
// [Main]             return $thunk(() => j3(false))
// [Main]           }
// [Main]         }
// [Main]         if (i_9 <= _12) {
// [Main]           return $thunk(() => j4(true))
// [Main]         } else {
// [Main]           return $thunk(() => j4(false))
// [Main]         }
// [Main]       }
// [Main]       if (i_9 <= _10) {
// [Main]         return $thunk(() => j5(true))
// [Main]       } else {
// [Main]         return $thunk(() => j5(false))
// [Main]       }
// [Main]     }
// [Main]     if (_5 === _7) {
// [Main]       return $thunk(() => j6(1))
// [Main]     } else {
// [Main]       const _8 = true;
// [Main]       if (_6 === _8) {
// [Main]         return $thunk(() => j6(2))
// [Main]       } else {
// [Main]         return $thunk(() => j6(3))
// [Main]       }
// [Main]     }
// [Main]   }
// [Main]   return $thunk(() => main_1(function (x) {
// [Main]     return $thunk(() => k(x))
// [Main]   }
// [Main]   ))
// [Main] }
// [Main] 
// [Main] function $thunk(lambda) {
// [Main]   return { thunk: lambda };
// [Main] }
// [Main] function $is_thunk(x) {
// [Main]   return x && x.hasOwnProperty('thunk') && x.thunk !== undefined;
// [Main] }
// [Main] function $force(x) {
// [Main]   while ($is_thunk(x)) {
// [Main]     x = x.thunk();
// [Main]   }
// [Main]   return x;
// [Main] }
// [Main] function $external(f, k, ...args) {
// [Main]   let x = f(...args);
// [Main]   return $thunk(() => k(x));
// [Main] }
// [Main] function $trampoline(f, ...args) {
// [Main]   let x = f(...args);
// [Main]   return $force(x);
// [Main] }
// [Main] export default () => $trampoline(thunk_main, x => x);
// [Typer] resolve: LetEnum("X", Enum X { A(X, X), B(Int, Int), C() }, LetRec({tyvars: [], name: ("main", Var(None)), args: [], body: Let(("i", Var(None)), Match(Tuple([Bool(true), Bool(false)]), [{pat: Tuple([Bool(true), Wildcard]), action: Int(1)}, {pat: Tuple([Wildcard, Bool(true)]), action: Int(2)}, {pat: Wildcard, action: Int(3)}]), Let(("j", Var(None)), Match(Tuple([LE(Var("i"), Int(1)), LE(Var("i"), Int(2)), LE(Var("i"), Int(3))]), [{pat: Tuple([Bool(true), Wildcard, Wildcard]), action: Int(1)}, {pat: Tuple([Wildcard, Bool(true), Wildcard]), action: Int(2)}, {pat: Tuple([Wildcard, Wildcard, Bool(true)]), action: Int(3)}, {pat: Wildcard, action: Int(4)}]), Let(("k", Var(None)), Match(Tuple([Var("j"), Prim(Var("j"), Int(1), Add, kind=None), Prim(Var("j"), Int(2), Add, kind=None), Prim(Var("j"), Int(3), Add, kind=None)]), [{pat: Tuple([Int(1), Int(2), Int(3), Int(5)]), action: Int(1)}, {pat: Tuple([Int(1), Int(2), Int(3), Int(6)]), action: Int(2)}, {pat: Tuple([Int(1), Int(2), Int(3), Int(7)]), action: Int(3)}, {pat: Wildcard, action: Int(4)}]), Let(("m", Var(None)), Match(CtorApp("A", [CtorApp("B", [Int(1), Int(2)]), CtorApp("C", [])]), [{pat: CtorApp("A", [CtorApp("B", [Var("a"), Var("b")]), CtorApp("B", [Var("c"), Var("d")])]), action: Int(1)}, {pat: CtorApp("A", [CtorApp("C", []), CtorApp("B", [Var("a"), Var("b")])]), action: Int(2)}, {pat: CtorApp("A", [CtorApp("B", [Int(1), Int(3)]), CtorApp("C", [])]), action: Int(3)}, {pat: CtorApp("A", [CtorApp("B", [Int(1), Int(2)]), CtorApp("C", [])]), action: Int(4)}, {pat: CtorApp("B", [Wildcard, Wildcard]), action: Int(5)}, {pat: CtorApp("C", []), action: Int(6)}]), Let(("_", Var(None)), App(Var("print_int"), [Var("i")]), Let(("_", Var(None)), App(Var("print_int"), [Var("j")]), Let(("_", Var(None)), App(Var("print_int"), [Var("k")]), Let(("_", Var(None)), App(Var("print_int"), [Var("m")]), Unit))))))))}, Unit))
// [Typer] resolve: LetRec({tyvars: [], name: ("main", Var(None)), args: [], body: Let(("i", Var(None)), Match(Tuple([Bool(true), Bool(false)]), [{pat: Tuple([Bool(true), Wildcard]), action: Int(1)}, {pat: Tuple([Wildcard, Bool(true)]), action: Int(2)}, {pat: Wildcard, action: Int(3)}]), Let(("j", Var(None)), Match(Tuple([LE(Var("i"), Int(1)), LE(Var("i"), Int(2)), LE(Var("i"), Int(3))]), [{pat: Tuple([Bool(true), Wildcard, Wildcard]), action: Int(1)}, {pat: Tuple([Wildcard, Bool(true), Wildcard]), action: Int(2)}, {pat: Tuple([Wildcard, Wildcard, Bool(true)]), action: Int(3)}, {pat: Wildcard, action: Int(4)}]), Let(("k", Var(None)), Match(Tuple([Var("j"), Prim(Var("j"), Int(1), Add, kind=None), Prim(Var("j"), Int(2), Add, kind=None), Prim(Var("j"), Int(3), Add, kind=None)]), [{pat: Tuple([Int(1), Int(2), Int(3), Int(5)]), action: Int(1)}, {pat: Tuple([Int(1), Int(2), Int(3), Int(6)]), action: Int(2)}, {pat: Tuple([Int(1), Int(2), Int(3), Int(7)]), action: Int(3)}, {pat: Wildcard, action: Int(4)}]), Let(("m", Var(None)), Match(CtorApp("A", [CtorApp("B", [Int(1), Int(2)]), CtorApp("C", [])]), [{pat: CtorApp("A", [CtorApp("B", [Var("a"), Var("b")]), CtorApp("B", [Var("c"), Var("d")])]), action: Int(1)}, {pat: CtorApp("A", [CtorApp("C", []), CtorApp("B", [Var("a"), Var("b")])]), action: Int(2)}, {pat: CtorApp("A", [CtorApp("B", [Int(1), Int(3)]), CtorApp("C", [])]), action: Int(3)}, {pat: CtorApp("A", [CtorApp("B", [Int(1), Int(2)]), CtorApp("C", [])]), action: Int(4)}, {pat: CtorApp("B", [Wildcard, Wildcard]), action: Int(5)}, {pat: CtorApp("C", []), action: Int(6)}]), Let(("_", Var(None)), App(Var("print_int"), [Var("i")]), Let(("_", Var(None)), App(Var("print_int"), [Var("j")]), Let(("_", Var(None)), App(Var("print_int"), [Var("k")]), Let(("_", Var(None)), App(Var("print_int"), [Var("m")]), Unit))))))))}, Unit)
// [Typer] resolve: Let(("i", Var(None)), Match(Tuple([Bool(true), Bool(false)]), [{pat: Tuple([Bool(true), Wildcard]), action: Int(1)}, {pat: Tuple([Wildcard, Bool(true)]), action: Int(2)}, {pat: Wildcard, action: Int(3)}]), Let(("j", Var(None)), Match(Tuple([LE(Var("i"), Int(1)), LE(Var("i"), Int(2)), LE(Var("i"), Int(3))]), [{pat: Tuple([Bool(true), Wildcard, Wildcard]), action: Int(1)}, {pat: Tuple([Wildcard, Bool(true), Wildcard]), action: Int(2)}, {pat: Tuple([Wildcard, Wildcard, Bool(true)]), action: Int(3)}, {pat: Wildcard, action: Int(4)}]), Let(("k", Var(None)), Match(Tuple([Var("j"), Prim(Var("j"), Int(1), Add, kind=None), Prim(Var("j"), Int(2), Add, kind=None), Prim(Var("j"), Int(3), Add, kind=None)]), [{pat: Tuple([Int(1), Int(2), Int(3), Int(5)]), action: Int(1)}, {pat: Tuple([Int(1), Int(2), Int(3), Int(6)]), action: Int(2)}, {pat: Tuple([Int(1), Int(2), Int(3), Int(7)]), action: Int(3)}, {pat: Wildcard, action: Int(4)}]), Let(("m", Var(None)), Match(CtorApp("A", [CtorApp("B", [Int(1), Int(2)]), CtorApp("C", [])]), [{pat: CtorApp("A", [CtorApp("B", [Var("a"), Var("b")]), CtorApp("B", [Var("c"), Var("d")])]), action: Int(1)}, {pat: CtorApp("A", [CtorApp("C", []), CtorApp("B", [Var("a"), Var("b")])]), action: Int(2)}, {pat: CtorApp("A", [CtorApp("B", [Int(1), Int(3)]), CtorApp("C", [])]), action: Int(3)}, {pat: CtorApp("A", [CtorApp("B", [Int(1), Int(2)]), CtorApp("C", [])]), action: Int(4)}, {pat: CtorApp("B", [Wildcard, Wildcard]), action: Int(5)}, {pat: CtorApp("C", []), action: Int(6)}]), Let(("_", Var(None)), App(Var("print_int"), [Var("i")]), Let(("_", Var(None)), App(Var("print_int"), [Var("j")]), Let(("_", Var(None)), App(Var("print_int"), [Var("k")]), Let(("_", Var(None)), App(Var("print_int"), [Var("m")]), Unit))))))))
// [Typer] resolve: Match(Tuple([Bool(true), Bool(false)]), [{pat: Tuple([Bool(true), Wildcard]), action: Int(1)}, {pat: Tuple([Wildcard, Bool(true)]), action: Int(2)}, {pat: Wildcard, action: Int(3)}])
// [Typer] resolve: Tuple([Bool(true), Bool(false)])
// [Typer] resolve: Int(1)
// [Typer] resolve: Int(2)
// [Typer] resolve: Int(3)
// [Typer] resolve: Let(("j", Var(None)), Match(Tuple([LE(Var("i"), Int(1)), LE(Var("i"), Int(2)), LE(Var("i"), Int(3))]), [{pat: Tuple([Bool(true), Wildcard, Wildcard]), action: Int(1)}, {pat: Tuple([Wildcard, Bool(true), Wildcard]), action: Int(2)}, {pat: Tuple([Wildcard, Wildcard, Bool(true)]), action: Int(3)}, {pat: Wildcard, action: Int(4)}]), Let(("k", Var(None)), Match(Tuple([Var("j"), Prim(Var("j"), Int(1), Add, kind=None), Prim(Var("j"), Int(2), Add, kind=None), Prim(Var("j"), Int(3), Add, kind=None)]), [{pat: Tuple([Int(1), Int(2), Int(3), Int(5)]), action: Int(1)}, {pat: Tuple([Int(1), Int(2), Int(3), Int(6)]), action: Int(2)}, {pat: Tuple([Int(1), Int(2), Int(3), Int(7)]), action: Int(3)}, {pat: Wildcard, action: Int(4)}]), Let(("m", Var(None)), Match(CtorApp("A", [CtorApp("B", [Int(1), Int(2)]), CtorApp("C", [])]), [{pat: CtorApp("A", [CtorApp("B", [Var("a"), Var("b")]), CtorApp("B", [Var("c"), Var("d")])]), action: Int(1)}, {pat: CtorApp("A", [CtorApp("C", []), CtorApp("B", [Var("a"), Var("b")])]), action: Int(2)}, {pat: CtorApp("A", [CtorApp("B", [Int(1), Int(3)]), CtorApp("C", [])]), action: Int(3)}, {pat: CtorApp("A", [CtorApp("B", [Int(1), Int(2)]), CtorApp("C", [])]), action: Int(4)}, {pat: CtorApp("B", [Wildcard, Wildcard]), action: Int(5)}, {pat: CtorApp("C", []), action: Int(6)}]), Let(("_", Var(None)), App(Var("print_int"), [Var("i")]), Let(("_", Var(None)), App(Var("print_int"), [Var("j")]), Let(("_", Var(None)), App(Var("print_int"), [Var("k")]), Let(("_", Var(None)), App(Var("print_int"), [Var("m")]), Unit)))))))
// [Typer] resolve: Match(Tuple([LE(Var("i"), Int(1)), LE(Var("i"), Int(2)), LE(Var("i"), Int(3))]), [{pat: Tuple([Bool(true), Wildcard, Wildcard]), action: Int(1)}, {pat: Tuple([Wildcard, Bool(true), Wildcard]), action: Int(2)}, {pat: Tuple([Wildcard, Wildcard, Bool(true)]), action: Int(3)}, {pat: Wildcard, action: Int(4)}])
// [Typer] resolve: Tuple([LE(Var("i"), Int(1)), LE(Var("i"), Int(2)), LE(Var("i"), Int(3))])
// [Typer] resolve: Int(1)
// [Typer] resolve: Int(2)
// [Typer] resolve: Int(3)
// [Typer] resolve: Int(4)
// [Typer] resolve: Let(("k", Var(None)), Match(Tuple([Var("j"), Prim(Var("j"), Int(1), Add, kind=None), Prim(Var("j"), Int(2), Add, kind=None), Prim(Var("j"), Int(3), Add, kind=None)]), [{pat: Tuple([Int(1), Int(2), Int(3), Int(5)]), action: Int(1)}, {pat: Tuple([Int(1), Int(2), Int(3), Int(6)]), action: Int(2)}, {pat: Tuple([Int(1), Int(2), Int(3), Int(7)]), action: Int(3)}, {pat: Wildcard, action: Int(4)}]), Let(("m", Var(None)), Match(CtorApp("A", [CtorApp("B", [Int(1), Int(2)]), CtorApp("C", [])]), [{pat: CtorApp("A", [CtorApp("B", [Var("a"), Var("b")]), CtorApp("B", [Var("c"), Var("d")])]), action: Int(1)}, {pat: CtorApp("A", [CtorApp("C", []), CtorApp("B", [Var("a"), Var("b")])]), action: Int(2)}, {pat: CtorApp("A", [CtorApp("B", [Int(1), Int(3)]), CtorApp("C", [])]), action: Int(3)}, {pat: CtorApp("A", [CtorApp("B", [Int(1), Int(2)]), CtorApp("C", [])]), action: Int(4)}, {pat: CtorApp("B", [Wildcard, Wildcard]), action: Int(5)}, {pat: CtorApp("C", []), action: Int(6)}]), Let(("_", Var(None)), App(Var("print_int"), [Var("i")]), Let(("_", Var(None)), App(Var("print_int"), [Var("j")]), Let(("_", Var(None)), App(Var("print_int"), [Var("k")]), Let(("_", Var(None)), App(Var("print_int"), [Var("m")]), Unit))))))
// [Typer] resolve: Match(Tuple([Var("j"), Prim(Var("j"), Int(1), Add, kind=None), Prim(Var("j"), Int(2), Add, kind=None), Prim(Var("j"), Int(3), Add, kind=None)]), [{pat: Tuple([Int(1), Int(2), Int(3), Int(5)]), action: Int(1)}, {pat: Tuple([Int(1), Int(2), Int(3), Int(6)]), action: Int(2)}, {pat: Tuple([Int(1), Int(2), Int(3), Int(7)]), action: Int(3)}, {pat: Wildcard, action: Int(4)}])
// [Typer] resolve: Tuple([Var("j"), Prim(Var("j"), Int(1), Add, kind=None), Prim(Var("j"), Int(2), Add, kind=None), Prim(Var("j"), Int(3), Add, kind=None)])
// [Typer] resolve: Int(1)
// [Typer] resolve: Int(2)
// [Typer] resolve: Int(3)
// [Typer] resolve: Int(4)
// [Typer] resolve: Let(("m", Var(None)), Match(CtorApp("A", [CtorApp("B", [Int(1), Int(2)]), CtorApp("C", [])]), [{pat: CtorApp("A", [CtorApp("B", [Var("a"), Var("b")]), CtorApp("B", [Var("c"), Var("d")])]), action: Int(1)}, {pat: CtorApp("A", [CtorApp("C", []), CtorApp("B", [Var("a"), Var("b")])]), action: Int(2)}, {pat: CtorApp("A", [CtorApp("B", [Int(1), Int(3)]), CtorApp("C", [])]), action: Int(3)}, {pat: CtorApp("A", [CtorApp("B", [Int(1), Int(2)]), CtorApp("C", [])]), action: Int(4)}, {pat: CtorApp("B", [Wildcard, Wildcard]), action: Int(5)}, {pat: CtorApp("C", []), action: Int(6)}]), Let(("_", Var(None)), App(Var("print_int"), [Var("i")]), Let(("_", Var(None)), App(Var("print_int"), [Var("j")]), Let(("_", Var(None)), App(Var("print_int"), [Var("k")]), Let(("_", Var(None)), App(Var("print_int"), [Var("m")]), Unit)))))
// [Typer] resolve: Match(CtorApp("A", [CtorApp("B", [Int(1), Int(2)]), CtorApp("C", [])]), [{pat: CtorApp("A", [CtorApp("B", [Var("a"), Var("b")]), CtorApp("B", [Var("c"), Var("d")])]), action: Int(1)}, {pat: CtorApp("A", [CtorApp("C", []), CtorApp("B", [Var("a"), Var("b")])]), action: Int(2)}, {pat: CtorApp("A", [CtorApp("B", [Int(1), Int(3)]), CtorApp("C", [])]), action: Int(3)}, {pat: CtorApp("A", [CtorApp("B", [Int(1), Int(2)]), CtorApp("C", [])]), action: Int(4)}, {pat: CtorApp("B", [Wildcard, Wildcard]), action: Int(5)}, {pat: CtorApp("C", []), action: Int(6)}])
// [Typer] resolve: CtorApp("A", [CtorApp("B", [Int(1), Int(2)]), CtorApp("C", [])])
// [Typer] resolve: CtorApp("B", [Int(1), Int(2)])
// [Typer] resolve: Int(1)
// [Typer] resolve: Int(2)
// [Typer] resolve: CtorApp("C", [])
// [Typer] resolve: Int(1)
// [Typer] resolve: Int(2)
// [Typer] resolve: Int(3)
// [Typer] resolve: Int(4)
// [Typer] resolve: Int(5)
// [Typer] resolve: Int(6)
// [Typer] resolve: Let(("_", Var(None)), App(Var("print_int"), [Var("i")]), Let(("_", Var(None)), App(Var("print_int"), [Var("j")]), Let(("_", Var(None)), App(Var("print_int"), [Var("k")]), Let(("_", Var(None)), App(Var("print_int"), [Var("m")]), Unit))))
// [Typer] resolve: App(Var("print_int"), [Var("i")])
// [Typer] resolve: Var("i")
// [Typer] resolve: Var("print_int")
// [Typer] resolve: Let(("_", Var(None)), App(Var("print_int"), [Var("j")]), Let(("_", Var(None)), App(Var("print_int"), [Var("k")]), Let(("_", Var(None)), App(Var("print_int"), [Var("m")]), Unit)))
// [Typer] resolve: App(Var("print_int"), [Var("j")])
// [Typer] resolve: Var("j")
// [Typer] resolve: Var("print_int")
// [Typer] resolve: Let(("_", Var(None)), App(Var("print_int"), [Var("k")]), Let(("_", Var(None)), App(Var("print_int"), [Var("m")]), Unit))
// [Typer] resolve: App(Var("print_int"), [Var("k")])
// [Typer] resolve: Var("k")
// [Typer] resolve: Var("print_int")
// [Typer] resolve: Let(("_", Var(None)), App(Var("print_int"), [Var("m")]), Unit)
// [Typer] resolve: App(Var("print_int"), [Var("m")])
// [Typer] resolve: Var("m")
// [Typer] resolve: Var("print_int")
// [Typer] resolve: Unit
// [Typer] resolve: Unit
// [Typer] check: LetEnum("X", Enum X { A(~0, ~0), B(Int, Int), C() }, LetRec({tyvars: [], name: ("main", Var(None)), args: [], body: Let(("i", Var(None)), Match(Tuple([Bool(true), Bool(false)]), [{pat: Tuple([Bool(true), Wildcard]), action: Int(1)}, {pat: Tuple([Wildcard, Bool(true)]), action: Int(2)}, {pat: Wildcard, action: Int(3)}]), Let(("j", Var(None)), Match(Tuple([LE(Var("i"), Int(1)), LE(Var("i"), Int(2)), LE(Var("i"), Int(3))]), [{pat: Tuple([Bool(true), Wildcard, Wildcard]), action: Int(1)}, {pat: Tuple([Wildcard, Bool(true), Wildcard]), action: Int(2)}, {pat: Tuple([Wildcard, Wildcard, Bool(true)]), action: Int(3)}, {pat: Wildcard, action: Int(4)}]), Let(("k", Var(None)), Match(Tuple([Var("j"), Prim(Var("j"), Int(1), Add, kind=None), Prim(Var("j"), Int(2), Add, kind=None), Prim(Var("j"), Int(3), Add, kind=None)]), [{pat: Tuple([Int(1), Int(2), Int(3), Int(5)]), action: Int(1)}, {pat: Tuple([Int(1), Int(2), Int(3), Int(6)]), action: Int(2)}, {pat: Tuple([Int(1), Int(2), Int(3), Int(7)]), action: Int(3)}, {pat: Wildcard, action: Int(4)}]), Let(("m", Var(None)), Match(CtorApp("A", [CtorApp("B", [Int(1), Int(2)]), CtorApp("C", [])]), [{pat: CtorApp("A", [CtorApp("B", [Var("a"), Var("b")]), CtorApp("B", [Var("c"), Var("d")])]), action: Int(1)}, {pat: CtorApp("A", [CtorApp("C", []), CtorApp("B", [Var("a"), Var("b")])]), action: Int(2)}, {pat: CtorApp("A", [CtorApp("B", [Int(1), Int(3)]), CtorApp("C", [])]), action: Int(3)}, {pat: CtorApp("A", [CtorApp("B", [Int(1), Int(2)]), CtorApp("C", [])]), action: Int(4)}, {pat: CtorApp("B", [Wildcard, Wildcard]), action: Int(5)}, {pat: CtorApp("C", []), action: Int(6)}]), Let(("_", Var(None)), App(Var("print_int"), [Var("i")]), Let(("_", Var(None)), App(Var("print_int"), [Var("j")]), Let(("_", Var(None)), App(Var("print_int"), [Var("k")]), Let(("_", Var(None)), App(Var("print_int"), [Var("m")]), Unit))))))))}, Unit)) against Unit
// [Typer] check: LetRec({tyvars: [], name: ("main", Var(None)), args: [], body: Let(("i", Var(None)), Match(Tuple([Bool(true), Bool(false)]), [{pat: Tuple([Bool(true), Wildcard]), action: Int(1)}, {pat: Tuple([Wildcard, Bool(true)]), action: Int(2)}, {pat: Wildcard, action: Int(3)}]), Let(("j", Var(None)), Match(Tuple([LE(Var("i"), Int(1)), LE(Var("i"), Int(2)), LE(Var("i"), Int(3))]), [{pat: Tuple([Bool(true), Wildcard, Wildcard]), action: Int(1)}, {pat: Tuple([Wildcard, Bool(true), Wildcard]), action: Int(2)}, {pat: Tuple([Wildcard, Wildcard, Bool(true)]), action: Int(3)}, {pat: Wildcard, action: Int(4)}]), Let(("k", Var(None)), Match(Tuple([Var("j"), Prim(Var("j"), Int(1), Add, kind=None), Prim(Var("j"), Int(2), Add, kind=None), Prim(Var("j"), Int(3), Add, kind=None)]), [{pat: Tuple([Int(1), Int(2), Int(3), Int(5)]), action: Int(1)}, {pat: Tuple([Int(1), Int(2), Int(3), Int(6)]), action: Int(2)}, {pat: Tuple([Int(1), Int(2), Int(3), Int(7)]), action: Int(3)}, {pat: Wildcard, action: Int(4)}]), Let(("m", Var(None)), Match(CtorApp("A", [CtorApp("B", [Int(1), Int(2)]), CtorApp("C", [])]), [{pat: CtorApp("A", [CtorApp("B", [Var("a"), Var("b")]), CtorApp("B", [Var("c"), Var("d")])]), action: Int(1)}, {pat: CtorApp("A", [CtorApp("C", []), CtorApp("B", [Var("a"), Var("b")])]), action: Int(2)}, {pat: CtorApp("A", [CtorApp("B", [Int(1), Int(3)]), CtorApp("C", [])]), action: Int(3)}, {pat: CtorApp("A", [CtorApp("B", [Int(1), Int(2)]), CtorApp("C", [])]), action: Int(4)}, {pat: CtorApp("B", [Wildcard, Wildcard]), action: Int(5)}, {pat: CtorApp("C", []), action: Int(6)}]), Let(("_", Var(None)), App(Var("print_int"), [Var("i")]), Let(("_", Var(None)), App(Var("print_int"), [Var("j")]), Let(("_", Var(None)), App(Var("print_int"), [Var("k")]), Let(("_", Var(None)), App(Var("print_int"), [Var("m")]), Unit))))))))}, Unit) against Unit
// [Typer] typevars: []
// [Typer] infer: Let(("i", Var(None)), Match(Tuple([Bool(true), Bool(false)]), [{pat: Tuple([Bool(true), Wildcard]), action: Int(1)}, {pat: Tuple([Wildcard, Bool(true)]), action: Int(2)}, {pat: Wildcard, action: Int(3)}]), Let(("j", Var(None)), Match(Tuple([LE(Var("i"), Int(1)), LE(Var("i"), Int(2)), LE(Var("i"), Int(3))]), [{pat: Tuple([Bool(true), Wildcard, Wildcard]), action: Int(1)}, {pat: Tuple([Wildcard, Bool(true), Wildcard]), action: Int(2)}, {pat: Tuple([Wildcard, Wildcard, Bool(true)]), action: Int(3)}, {pat: Wildcard, action: Int(4)}]), Let(("k", Var(None)), Match(Tuple([Var("j"), Prim(Var("j"), Int(1), Add, kind=None), Prim(Var("j"), Int(2), Add, kind=None), Prim(Var("j"), Int(3), Add, kind=None)]), [{pat: Tuple([Int(1), Int(2), Int(3), Int(5)]), action: Int(1)}, {pat: Tuple([Int(1), Int(2), Int(3), Int(6)]), action: Int(2)}, {pat: Tuple([Int(1), Int(2), Int(3), Int(7)]), action: Int(3)}, {pat: Wildcard, action: Int(4)}]), Let(("m", Var(None)), Match(CtorApp("A", [CtorApp("B", [Int(1), Int(2)]), CtorApp("C", [])]), [{pat: CtorApp("A", [CtorApp("B", [Var("a"), Var("b")]), CtorApp("B", [Var("c"), Var("d")])]), action: Int(1)}, {pat: CtorApp("A", [CtorApp("C", []), CtorApp("B", [Var("a"), Var("b")])]), action: Int(2)}, {pat: CtorApp("A", [CtorApp("B", [Int(1), Int(3)]), CtorApp("C", [])]), action: Int(3)}, {pat: CtorApp("A", [CtorApp("B", [Int(1), Int(2)]), CtorApp("C", [])]), action: Int(4)}, {pat: CtorApp("B", [Wildcard, Wildcard]), action: Int(5)}, {pat: CtorApp("C", []), action: Int(6)}]), Let(("_", Var(None)), App(Var("print_int"), [Var("i")]), Let(("_", Var(None)), App(Var("print_int"), [Var("j")]), Let(("_", Var(None)), App(Var("print_int"), [Var("k")]), Let(("_", Var(None)), App(Var("print_int"), [Var("m")]), Unit))))))))
// [Typer] infer: Match(Tuple([Bool(true), Bool(false)]), [{pat: Tuple([Bool(true), Wildcard]), action: Int(1)}, {pat: Tuple([Wildcard, Bool(true)]), action: Int(2)}, {pat: Wildcard, action: Int(3)}])
// [Typer] infer: Tuple([Bool(true), Bool(false)])
// [Typer] infer: Bool(true)
// [Typer] infer: Bool(false)
// [Typer] unify: Bool and Bool
// [Typer] infer: Int(1)
// [Typer] unify: Bool and Bool
// [Typer] infer: Int(2)
// [Typer] infer: Int(3)
// [Typer] unify: Int and Int
// [Typer] unify: Int and Int
// [Typer] unify: Int and Int
// [Typer] unify: Var(None) and Int
// [Typer] union: Var(None) and Int
// [Typer] infer: Let(("j", Var(None)), Match(Tuple([LE(Var("i"), Int(1)), LE(Var("i"), Int(2)), LE(Var("i"), Int(3))]), [{pat: Tuple([Bool(true), Wildcard, Wildcard]), action: Int(1)}, {pat: Tuple([Wildcard, Bool(true), Wildcard]), action: Int(2)}, {pat: Tuple([Wildcard, Wildcard, Bool(true)]), action: Int(3)}, {pat: Wildcard, action: Int(4)}]), Let(("k", Var(None)), Match(Tuple([Var("j"), Prim(Var("j"), Int(1), Add, kind=None), Prim(Var("j"), Int(2), Add, kind=None), Prim(Var("j"), Int(3), Add, kind=None)]), [{pat: Tuple([Int(1), Int(2), Int(3), Int(5)]), action: Int(1)}, {pat: Tuple([Int(1), Int(2), Int(3), Int(6)]), action: Int(2)}, {pat: Tuple([Int(1), Int(2), Int(3), Int(7)]), action: Int(3)}, {pat: Wildcard, action: Int(4)}]), Let(("m", Var(None)), Match(CtorApp("A", [CtorApp("B", [Int(1), Int(2)]), CtorApp("C", [])]), [{pat: CtorApp("A", [CtorApp("B", [Var("a"), Var("b")]), CtorApp("B", [Var("c"), Var("d")])]), action: Int(1)}, {pat: CtorApp("A", [CtorApp("C", []), CtorApp("B", [Var("a"), Var("b")])]), action: Int(2)}, {pat: CtorApp("A", [CtorApp("B", [Int(1), Int(3)]), CtorApp("C", [])]), action: Int(3)}, {pat: CtorApp("A", [CtorApp("B", [Int(1), Int(2)]), CtorApp("C", [])]), action: Int(4)}, {pat: CtorApp("B", [Wildcard, Wildcard]), action: Int(5)}, {pat: CtorApp("C", []), action: Int(6)}]), Let(("_", Var(None)), App(Var("print_int"), [Var("i")]), Let(("_", Var(None)), App(Var("print_int"), [Var("j")]), Let(("_", Var(None)), App(Var("print_int"), [Var("k")]), Let(("_", Var(None)), App(Var("print_int"), [Var("m")]), Unit)))))))
// [Typer] infer: Match(Tuple([LE(Var("i"), Int(1)), LE(Var("i"), Int(2)), LE(Var("i"), Int(3))]), [{pat: Tuple([Bool(true), Wildcard, Wildcard]), action: Int(1)}, {pat: Tuple([Wildcard, Bool(true), Wildcard]), action: Int(2)}, {pat: Tuple([Wildcard, Wildcard, Bool(true)]), action: Int(3)}, {pat: Wildcard, action: Int(4)}])
// [Typer] infer: Tuple([LE(Var("i"), Int(1)), LE(Var("i"), Int(2)), LE(Var("i"), Int(3))])
// [Typer] infer: LE(Var("i"), Int(1))
// [Typer] infer: Var("i")
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] check: Int(1) against Int
// [Typer] infer: LE(Var("i"), Int(2))
// [Typer] infer: Var("i")
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] check: Int(2) against Int
// [Typer] infer: LE(Var("i"), Int(3))
// [Typer] infer: Var("i")
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] check: Int(3) against Int
// [Typer] unify: Bool and Bool
// [Typer] infer: Int(1)
// [Typer] unify: Bool and Bool
// [Typer] infer: Int(2)
// [Typer] unify: Bool and Bool
// [Typer] infer: Int(3)
// [Typer] infer: Int(4)
// [Typer] unify: Int and Int
// [Typer] unify: Int and Int
// [Typer] unify: Int and Int
// [Typer] unify: Int and Int
// [Typer] unify: Var(None) and Int
// [Typer] union: Var(None) and Int
// [Typer] infer: Let(("k", Var(None)), Match(Tuple([Var("j"), Prim(Var("j"), Int(1), Add, kind=None), Prim(Var("j"), Int(2), Add, kind=None), Prim(Var("j"), Int(3), Add, kind=None)]), [{pat: Tuple([Int(1), Int(2), Int(3), Int(5)]), action: Int(1)}, {pat: Tuple([Int(1), Int(2), Int(3), Int(6)]), action: Int(2)}, {pat: Tuple([Int(1), Int(2), Int(3), Int(7)]), action: Int(3)}, {pat: Wildcard, action: Int(4)}]), Let(("m", Var(None)), Match(CtorApp("A", [CtorApp("B", [Int(1), Int(2)]), CtorApp("C", [])]), [{pat: CtorApp("A", [CtorApp("B", [Var("a"), Var("b")]), CtorApp("B", [Var("c"), Var("d")])]), action: Int(1)}, {pat: CtorApp("A", [CtorApp("C", []), CtorApp("B", [Var("a"), Var("b")])]), action: Int(2)}, {pat: CtorApp("A", [CtorApp("B", [Int(1), Int(3)]), CtorApp("C", [])]), action: Int(3)}, {pat: CtorApp("A", [CtorApp("B", [Int(1), Int(2)]), CtorApp("C", [])]), action: Int(4)}, {pat: CtorApp("B", [Wildcard, Wildcard]), action: Int(5)}, {pat: CtorApp("C", []), action: Int(6)}]), Let(("_", Var(None)), App(Var("print_int"), [Var("i")]), Let(("_", Var(None)), App(Var("print_int"), [Var("j")]), Let(("_", Var(None)), App(Var("print_int"), [Var("k")]), Let(("_", Var(None)), App(Var("print_int"), [Var("m")]), Unit))))))
// [Typer] infer: Match(Tuple([Var("j"), Prim(Var("j"), Int(1), Add, kind=None), Prim(Var("j"), Int(2), Add, kind=None), Prim(Var("j"), Int(3), Add, kind=None)]), [{pat: Tuple([Int(1), Int(2), Int(3), Int(5)]), action: Int(1)}, {pat: Tuple([Int(1), Int(2), Int(3), Int(6)]), action: Int(2)}, {pat: Tuple([Int(1), Int(2), Int(3), Int(7)]), action: Int(3)}, {pat: Wildcard, action: Int(4)}])
// [Typer] infer: Tuple([Var("j"), Prim(Var("j"), Int(1), Add, kind=None), Prim(Var("j"), Int(2), Add, kind=None), Prim(Var("j"), Int(3), Add, kind=None)])
// [Typer] infer: Var("j")
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] infer: Prim(Var("j"), Int(1), Add, kind=None)
// [Typer] infer: Var("j")
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] infer: Int(1)
// [Typer] unify: Int and Int
// [Typer] infer: Prim(Var("j"), Int(2), Add, kind=None)
// [Typer] infer: Var("j")
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] infer: Int(2)
// [Typer] unify: Int and Int
// [Typer] infer: Prim(Var("j"), Int(3), Add, kind=None)
// [Typer] infer: Var("j")
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] infer: Int(3)
// [Typer] unify: Int and Int
// [Typer] unify: Int and Int
// [Typer] unify: Int and Int
// [Typer] unify: Int and Int
// [Typer] unify: Int and Int
// [Typer] infer: Int(1)
// [Typer] unify: Int and Int
// [Typer] unify: Int and Int
// [Typer] unify: Int and Int
// [Typer] unify: Int and Int
// [Typer] infer: Int(2)
// [Typer] unify: Int and Int
// [Typer] unify: Int and Int
// [Typer] unify: Int and Int
// [Typer] unify: Int and Int
// [Typer] infer: Int(3)
// [Typer] infer: Int(4)
// [Typer] unify: Int and Int
// [Typer] unify: Int and Int
// [Typer] unify: Int and Int
// [Typer] unify: Int and Int
// [Typer] unify: Var(None) and Int
// [Typer] union: Var(None) and Int
// [Typer] infer: Let(("m", Var(None)), Match(CtorApp("A", [CtorApp("B", [Int(1), Int(2)]), CtorApp("C", [])]), [{pat: CtorApp("A", [CtorApp("B", [Var("a"), Var("b")]), CtorApp("B", [Var("c"), Var("d")])]), action: Int(1)}, {pat: CtorApp("A", [CtorApp("C", []), CtorApp("B", [Var("a"), Var("b")])]), action: Int(2)}, {pat: CtorApp("A", [CtorApp("B", [Int(1), Int(3)]), CtorApp("C", [])]), action: Int(3)}, {pat: CtorApp("A", [CtorApp("B", [Int(1), Int(2)]), CtorApp("C", [])]), action: Int(4)}, {pat: CtorApp("B", [Wildcard, Wildcard]), action: Int(5)}, {pat: CtorApp("C", []), action: Int(6)}]), Let(("_", Var(None)), App(Var("print_int"), [Var("i")]), Let(("_", Var(None)), App(Var("print_int"), [Var("j")]), Let(("_", Var(None)), App(Var("print_int"), [Var("k")]), Let(("_", Var(None)), App(Var("print_int"), [Var("m")]), Unit)))))
// [Typer] infer: Match(CtorApp("A", [CtorApp("B", [Int(1), Int(2)]), CtorApp("C", [])]), [{pat: CtorApp("A", [CtorApp("B", [Var("a"), Var("b")]), CtorApp("B", [Var("c"), Var("d")])]), action: Int(1)}, {pat: CtorApp("A", [CtorApp("C", []), CtorApp("B", [Var("a"), Var("b")])]), action: Int(2)}, {pat: CtorApp("A", [CtorApp("B", [Int(1), Int(3)]), CtorApp("C", [])]), action: Int(3)}, {pat: CtorApp("A", [CtorApp("B", [Int(1), Int(2)]), CtorApp("C", [])]), action: Int(4)}, {pat: CtorApp("B", [Wildcard, Wildcard]), action: Int(5)}, {pat: CtorApp("C", []), action: Int(6)}])
// [Typer] infer: CtorApp("A", [CtorApp("B", [Int(1), Int(2)]), CtorApp("C", [])])
// [Typer] inst: TypeScheme(([], (Enum X { A(Enum X { A(~0, ~0), B(Int, Int), C() }, ~0), B(Int, Int), C() }, Enum X { A(~0, ~0), B(Int, Int), C() }) -> Enum X { A(~0, ~0), B(Int, Int), C() }))
// [Typer] inst result: (Enum X { A(Enum X { A(~0, ~0), B(Int, Int), C() }, ~0), B(Int, Int), C() }, Enum X { A(~0, ~0), B(Int, Int), C() }) -> Enum X { A(~0, ~0), B(Int, Int), C() }
// [Typer] check: CtorApp("B", [Int(1), Int(2)]) against Enum X { A(~0, ~0), B(Int, Int), C() }
// [Typer] infer: Int(1)
// [Typer] infer: Int(2)
// [Typer] inst: TypeScheme(([], (Int, Int) -> Enum X { A(Enum X { A(~0, ~0), B(Int, Int), C() }, ~0), B(Int, Int), C() }))
// [Typer] inst result: (Int, Int) -> Enum X { A(Enum X { A(~0, ~0), B(Int, Int), C() }, ~0), B(Int, Int), C() }
// [Typer] unify: (Int, Int) -> Enum X { A(Enum X { A(~0, ~0), B(Int, Int), C() }, ~0), B(Int, Int), C() } and (Int, Int) -> Enum X { A(Enum X { A(~0, ~0), B(Int, Int), C() }, ~0), B(Int, Int), C() }
// [Typer] unify: Int and Int
// [Typer] unify: Int and Int
// [Typer] unify: Enum X { A(~0, ~0), B(Int, Int), C() } and Enum X { A(~0, ~0), B(Int, Int), C() }
// [Typer] check: CtorApp("C", []) against Enum X { A(~0, ~0), B(Int, Int), C() }
// [Typer] inst: TypeScheme(([], () -> Enum X { A(Enum X { A(~0, ~0), B(Int, Int), C() }, ~0), B(Int, Int), C() }))
// [Typer] inst result: () -> Enum X { A(Enum X { A(~0, ~0), B(Int, Int), C() }, ~0), B(Int, Int), C() }
// [Typer] unify: () -> Enum X { A(Enum X { A(~0, ~0), B(Int, Int), C() }, ~0), B(Int, Int), C() } and () -> Enum X { A(Enum X { A(~0, ~0), B(Int, Int), C() }, ~0), B(Int, Int), C() }
// [Typer] unify: Enum X { A(~0, ~0), B(Int, Int), C() } and Enum X { A(~0, ~0), B(Int, Int), C() }
// [Typer] inst: TypeScheme(([], (Enum X { A(Enum X { A(~0, ~0), B(Int, Int), C() }, ~0), B(Int, Int), C() }, Enum X { A(~0, ~0), B(Int, Int), C() }) -> Enum X { A(~0, ~0), B(Int, Int), C() }))
// [Typer] inst result: (Enum X { A(Enum X { A(~0, ~0), B(Int, Int), C() }, ~0), B(Int, Int), C() }, Enum X { A(~0, ~0), B(Int, Int), C() }) -> Enum X { A(~0, ~0), B(Int, Int), C() }
// [Typer] unify: Enum X { A(~0, ~0), B(Int, Int), C() } and Enum X { A(~0, ~0), B(Int, Int), C() }
// [Typer] inst: TypeScheme(([], (Int, Int) -> Enum X { A(Enum X { A(~0, ~0), B(Int, Int), C() }, ~0), B(Int, Int), C() }))
// [Typer] inst result: (Int, Int) -> Enum X { A(Enum X { A(~0, ~0), B(Int, Int), C() }, ~0), B(Int, Int), C() }
// [Typer] unify: Enum X { A(~0, ~0), B(Int, Int), C() } and Enum X { A(~0, ~0), B(Int, Int), C() }
// [Typer] inst: TypeScheme(([], (Int, Int) -> Enum X { A(Enum X { A(~0, ~0), B(Int, Int), C() }, ~0), B(Int, Int), C() }))
// [Typer] inst result: (Int, Int) -> Enum X { A(Enum X { A(~0, ~0), B(Int, Int), C() }, ~0), B(Int, Int), C() }
// [Typer] unify: Enum X { A(~0, ~0), B(Int, Int), C() } and Enum X { A(~0, ~0), B(Int, Int), C() }
// [Typer] infer: Int(1)
// [Typer] inst: TypeScheme(([], (Enum X { A(Enum X { A(~0, ~0), B(Int, Int), C() }, ~0), B(Int, Int), C() }, Enum X { A(~0, ~0), B(Int, Int), C() }) -> Enum X { A(~0, ~0), B(Int, Int), C() }))
// [Typer] inst result: (Enum X { A(Enum X { A(~0, ~0), B(Int, Int), C() }, ~0), B(Int, Int), C() }, Enum X { A(~0, ~0), B(Int, Int), C() }) -> Enum X { A(~0, ~0), B(Int, Int), C() }
// [Typer] unify: Enum X { A(~0, ~0), B(Int, Int), C() } and Enum X { A(~0, ~0), B(Int, Int), C() }
// [Typer] inst: TypeScheme(([], () -> Enum X { A(Enum X { A(~0, ~0), B(Int, Int), C() }, ~0), B(Int, Int), C() }))
// [Typer] inst result: () -> Enum X { A(Enum X { A(~0, ~0), B(Int, Int), C() }, ~0), B(Int, Int), C() }
// [Typer] unify: Enum X { A(~0, ~0), B(Int, Int), C() } and Enum X { A(~0, ~0), B(Int, Int), C() }
// [Typer] inst: TypeScheme(([], (Int, Int) -> Enum X { A(Enum X { A(~0, ~0), B(Int, Int), C() }, ~0), B(Int, Int), C() }))
// [Typer] inst result: (Int, Int) -> Enum X { A(Enum X { A(~0, ~0), B(Int, Int), C() }, ~0), B(Int, Int), C() }
// [Typer] unify: Enum X { A(~0, ~0), B(Int, Int), C() } and Enum X { A(~0, ~0), B(Int, Int), C() }
// [Typer] infer: Int(2)
// [Typer] inst: TypeScheme(([], (Enum X { A(Enum X { A(~0, ~0), B(Int, Int), C() }, ~0), B(Int, Int), C() }, Enum X { A(~0, ~0), B(Int, Int), C() }) -> Enum X { A(~0, ~0), B(Int, Int), C() }))
// [Typer] inst result: (Enum X { A(Enum X { A(~0, ~0), B(Int, Int), C() }, ~0), B(Int, Int), C() }, Enum X { A(~0, ~0), B(Int, Int), C() }) -> Enum X { A(~0, ~0), B(Int, Int), C() }
// [Typer] unify: Enum X { A(~0, ~0), B(Int, Int), C() } and Enum X { A(~0, ~0), B(Int, Int), C() }
// [Typer] inst: TypeScheme(([], (Int, Int) -> Enum X { A(Enum X { A(~0, ~0), B(Int, Int), C() }, ~0), B(Int, Int), C() }))
// [Typer] inst result: (Int, Int) -> Enum X { A(Enum X { A(~0, ~0), B(Int, Int), C() }, ~0), B(Int, Int), C() }
// [Typer] unify: Enum X { A(~0, ~0), B(Int, Int), C() } and Enum X { A(~0, ~0), B(Int, Int), C() }
// [Typer] unify: Int and Int
// [Typer] unify: Int and Int
// [Typer] inst: TypeScheme(([], () -> Enum X { A(Enum X { A(~0, ~0), B(Int, Int), C() }, ~0), B(Int, Int), C() }))
// [Typer] inst result: () -> Enum X { A(Enum X { A(~0, ~0), B(Int, Int), C() }, ~0), B(Int, Int), C() }
// [Typer] unify: Enum X { A(~0, ~0), B(Int, Int), C() } and Enum X { A(~0, ~0), B(Int, Int), C() }
// [Typer] infer: Int(3)
// [Typer] inst: TypeScheme(([], (Enum X { A(Enum X { A(~0, ~0), B(Int, Int), C() }, ~0), B(Int, Int), C() }, Enum X { A(~0, ~0), B(Int, Int), C() }) -> Enum X { A(~0, ~0), B(Int, Int), C() }))
// [Typer] inst result: (Enum X { A(Enum X { A(~0, ~0), B(Int, Int), C() }, ~0), B(Int, Int), C() }, Enum X { A(~0, ~0), B(Int, Int), C() }) -> Enum X { A(~0, ~0), B(Int, Int), C() }
// [Typer] unify: Enum X { A(~0, ~0), B(Int, Int), C() } and Enum X { A(~0, ~0), B(Int, Int), C() }
// [Typer] inst: TypeScheme(([], (Int, Int) -> Enum X { A(Enum X { A(~0, ~0), B(Int, Int), C() }, ~0), B(Int, Int), C() }))
// [Typer] inst result: (Int, Int) -> Enum X { A(Enum X { A(~0, ~0), B(Int, Int), C() }, ~0), B(Int, Int), C() }
// [Typer] unify: Enum X { A(~0, ~0), B(Int, Int), C() } and Enum X { A(~0, ~0), B(Int, Int), C() }
// [Typer] unify: Int and Int
// [Typer] unify: Int and Int
// [Typer] inst: TypeScheme(([], () -> Enum X { A(Enum X { A(~0, ~0), B(Int, Int), C() }, ~0), B(Int, Int), C() }))
// [Typer] inst result: () -> Enum X { A(Enum X { A(~0, ~0), B(Int, Int), C() }, ~0), B(Int, Int), C() }
// [Typer] unify: Enum X { A(~0, ~0), B(Int, Int), C() } and Enum X { A(~0, ~0), B(Int, Int), C() }
// [Typer] infer: Int(4)
// [Typer] inst: TypeScheme(([], (Int, Int) -> Enum X { A(Enum X { A(~0, ~0), B(Int, Int), C() }, ~0), B(Int, Int), C() }))
// [Typer] inst result: (Int, Int) -> Enum X { A(Enum X { A(~0, ~0), B(Int, Int), C() }, ~0), B(Int, Int), C() }
// [Typer] unify: Enum X { A(~0, ~0), B(Int, Int), C() } and Enum X { A(~0, ~0), B(Int, Int), C() }
// [Typer] infer: Int(5)
// [Typer] inst: TypeScheme(([], () -> Enum X { A(Enum X { A(~0, ~0), B(Int, Int), C() }, ~0), B(Int, Int), C() }))
// [Typer] inst result: () -> Enum X { A(Enum X { A(~0, ~0), B(Int, Int), C() }, ~0), B(Int, Int), C() }
// [Typer] unify: Enum X { A(~0, ~0), B(Int, Int), C() } and Enum X { A(~0, ~0), B(Int, Int), C() }
// [Typer] infer: Int(6)
// [Typer] unify: Int and Int
// [Typer] unify: Int and Int
// [Typer] unify: Int and Int
// [Typer] unify: Int and Int
// [Typer] unify: Int and Int
// [Typer] unify: Int and Int
// [Typer] unify: Var(None) and Int
// [Typer] union: Var(None) and Int
// [Typer] infer: Let(("_", Var(None)), App(Var("print_int"), [Var("i")]), Let(("_", Var(None)), App(Var("print_int"), [Var("j")]), Let(("_", Var(None)), App(Var("print_int"), [Var("k")]), Let(("_", Var(None)), App(Var("print_int"), [Var("m")]), Unit))))
// [Typer] infer: App(Var("print_int"), [Var("i")])
// [Typer] infer: Var("print_int")
// [Typer] inst: TypeScheme(([], (Int) -> Unit))
// [Typer] inst result: (Int) -> Unit
// [Typer] check: Var("i") against Int
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] unify: Var(None) and Unit
// [Typer] union: Var(None) and Unit
// [Typer] infer: Let(("_", Var(None)), App(Var("print_int"), [Var("j")]), Let(("_", Var(None)), App(Var("print_int"), [Var("k")]), Let(("_", Var(None)), App(Var("print_int"), [Var("m")]), Unit)))
// [Typer] infer: App(Var("print_int"), [Var("j")])
// [Typer] infer: Var("print_int")
// [Typer] inst: TypeScheme(([], (Int) -> Unit))
// [Typer] inst result: (Int) -> Unit
// [Typer] check: Var("j") against Int
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] unify: Var(None) and Unit
// [Typer] union: Var(None) and Unit
// [Typer] infer: Let(("_", Var(None)), App(Var("print_int"), [Var("k")]), Let(("_", Var(None)), App(Var("print_int"), [Var("m")]), Unit))
// [Typer] infer: App(Var("print_int"), [Var("k")])
// [Typer] infer: Var("print_int")
// [Typer] inst: TypeScheme(([], (Int) -> Unit))
// [Typer] inst result: (Int) -> Unit
// [Typer] check: Var("k") against Int
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] unify: Var(None) and Unit
// [Typer] union: Var(None) and Unit
// [Typer] infer: Let(("_", Var(None)), App(Var("print_int"), [Var("m")]), Unit)
// [Typer] infer: App(Var("print_int"), [Var("m")])
// [Typer] infer: Var("print_int")
// [Typer] inst: TypeScheme(([], (Int) -> Unit))
// [Typer] inst result: (Int) -> Unit
// [Typer] check: Var("m") against Int
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] unify: Var(None) and Unit
// [Typer] union: Var(None) and Unit
// [Typer] infer: Unit
// [Typer] unify: Unit and Var(None)
// [Typer] union: Unit and Var(None)
// [Typer] check: Unit against Unit
// [Parser] flags: ["extension"]
