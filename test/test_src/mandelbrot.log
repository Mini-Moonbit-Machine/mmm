// [Main] function thunk_main(k) {
// [Main]   function mandelbrot_1(w_3, k) {
// [Main]     function dbl_4(f_6, k) {
// [Main]       return $thunk(() => k(f_6 + f_6))
// [Main]     }
// [Main]     function yloop_7(y_9, k) {
// [Main]       if (w_3 <= y_9) {
// [Main]         return $thunk(() => k(null))
// [Main]       } else {
// [Main]         function xloop_10(x_12, y_14, k) {
// [Main]           if (w_3 <= x_12) {
// [Main]             return $thunk(() => $external(minimbt_print_endline, function (_16) {
// [Main]               return $thunk(() => k(null))
// [Main]             }
// [Main]             ))
// [Main]           } else {
// [Main]             return $thunk(() => $external(minimbt_float_of_int, function (_17) {
// [Main]               return $thunk(() => dbl_4(_17, function (_18) {
// [Main]                 return $thunk(() => $external(minimbt_float_of_int, function (_19) {
// [Main]                   const _20 = _18 / _19;
// [Main]                   const _21 = 1.5;
// [Main]                   const cr_22 = _20 - _21;
// [Main]                   return $thunk(() => $external(minimbt_float_of_int, function (_23) {
// [Main]                     return $thunk(() => dbl_4(_23, function (_24) {
// [Main]                       return $thunk(() => $external(minimbt_float_of_int, function (_25) {
// [Main]                         const _26 = _24 / _25;
// [Main]                         const _27 = 1;
// [Main]                         const ci_28 = _26 - _27;
// [Main]                         function iloop_29(i_31, zr_33, zi_35, zr2_37, zi2_39, cr_41, ci_43, k) {
// [Main]                           const _44 = 0;
// [Main]                           if (i_31 === _44) {
// [Main]                             const _45 = 1;
// [Main]                             return $thunk(() => $external(minimbt_print_int, function (x) {
// [Main]                               return $thunk(() => k(x))
// [Main]                             }
// [Main]                             , _45))
// [Main]                           } else {
// [Main]                             const _46 = zr2_37 - zi2_39;
// [Main]                             const tr_47 = _46 + cr_41;
// [Main]                             return $thunk(() => dbl_4(zr_33, function (_48) {
// [Main]                               const _49 = _48 * zi_35;
// [Main]                               const ti_50 = _49 + ci_43;
// [Main]                               const zr2_51 = tr_47 * tr_47;
// [Main]                               const zi2_52 = ti_50 * ti_50;
// [Main]                               const _53 = 2;
// [Main]                               const _54 = 2;
// [Main]                               const _55 = _53 * _54;
// [Main]                               const _56 = zr2_51 + zi2_52;
// [Main]                               if (_55 <= _56) {
// [Main]                                 const _57 = 0;
// [Main]                                 return $thunk(() => $external(minimbt_print_int, function (x) {
// [Main]                                   return $thunk(() => k(x))
// [Main]                                 }
// [Main]                                 , _57))
// [Main]                               } else {
// [Main]                                 const _58 = 1;
// [Main]                                 const _59 = i_31 - _58;
// [Main]                                 return $thunk(() => iloop_29(_59, tr_47, ti_50, zr2_51, zi2_52, cr_41, ci_43, function (x) {
// [Main]                                   return $thunk(() => k(x))
// [Main]                                 }
// [Main]                                 ))
// [Main]                               }
// [Main]                             }
// [Main]                             ))
// [Main]                           }
// [Main]                         }
// [Main]                         const _60 = 1000;
// [Main]                         const _61 = 0;
// [Main]                         const _62 = 0;
// [Main]                         const _63 = 0;
// [Main]                         const _64 = 0;
// [Main]                         return $thunk(() => iloop_29(_60, _61, _62, _63, _64, cr_22, ci_28, function (_66) {
// [Main]                           const _67 = 1;
// [Main]                           const _68 = x_12 + _67;
// [Main]                           return $thunk(() => xloop_10(_68, y_14, function (x) {
// [Main]                             return $thunk(() => k(x))
// [Main]                           }
// [Main]                           ))
// [Main]                         }
// [Main]                         ))
// [Main]                       }
// [Main]                       , w_3))
// [Main]                     }
// [Main]                     ))
// [Main]                   }
// [Main]                   , y_14))
// [Main]                 }
// [Main]                 , w_3))
// [Main]               }
// [Main]               ))
// [Main]             }
// [Main]             , x_12))
// [Main]           }
// [Main]         }
// [Main]         const _69 = 0;
// [Main]         return $thunk(() => xloop_10(_69, y_9, function (_71) {
// [Main]           const _72 = 1;
// [Main]           const _73 = y_9 + _72;
// [Main]           return $thunk(() => yloop_7(_73, function (x) {
// [Main]             return $thunk(() => k(x))
// [Main]           }
// [Main]           ))
// [Main]         }
// [Main]         ))
// [Main]       }
// [Main]     }
// [Main]     const _74 = 0;
// [Main]     return $thunk(() => yloop_7(_74, function (x) {
// [Main]       return $thunk(() => k(x))
// [Main]     }
// [Main]     ))
// [Main]   }
// [Main]   function main_75(k) {
// [Main]     const _76 = 40;
// [Main]     return $thunk(() => mandelbrot_1(_76, function (x) {
// [Main]       return $thunk(() => k(x))
// [Main]     }
// [Main]     ))
// [Main]   }
// [Main]   return $thunk(() => main_75(function (x) {
// [Main]     return $thunk(() => k(x))
// [Main]   }
// [Main]   ))
// [Main] }
// [Main] 
// [Main] function $thunk(lambda) {
// [Main]   return { thunk: lambda };
// [Main] }
// [Main] function $is_thunk(x) {
// [Main]   return x && x.hasOwnProperty('thunk') && x.thunk !== undefined;
// [Main] }
// [Main] function $force(x) {
// [Main]   while ($is_thunk(x)) {
// [Main]     x = x.thunk();
// [Main]   }
// [Main]   return x;
// [Main] }
// [Main] function $external(f, k, ...args) {
// [Main]   let x = f(...args);
// [Main]   return $thunk(() => k(x));
// [Main] }
// [Main] function $trampoline(f, ...args) {
// [Main]   let x = f(...args);
// [Main]   return $force(x);
// [Main] }
// [Main] export default () => $trampoline(thunk_main, x => x);
// [Typer] check: LetRec({tyvars: [], name: ("mandelbrot", Unit), args: [("w", Int)], body: LetRec({tyvars: [], name: ("dbl", Double), args: [("f", Double)], body: Prim(Var("f"), Var("f"), Add, kind=None)}, LetRec({tyvars: [], name: ("yloop", Unit), args: [("y", Int)], body: If(LE(Var("w"), Var("y")), Unit, LetRec({tyvars: [], name: ("xloop", Unit), args: [("x", Int), ("y", Int)], body: If(LE(Var("w"), Var("x")), Let(("_", Var(None)), App(Var("print_endline"), []), Unit), Let(("cr", Var(None)), Prim(Prim(App(Var("dbl"), [App(Var("float_of_int"), [Var("x")])]), App(Var("float_of_int"), [Var("w")]), Div, kind=None), Double(1.5), Sub, kind=None), Let(("ci", Var(None)), Prim(Prim(App(Var("dbl"), [App(Var("float_of_int"), [Var("y")])]), App(Var("float_of_int"), [Var("w")]), Div, kind=None), Double(1), Sub, kind=None), LetRec({tyvars: [], name: ("iloop", Unit), args: [("i", Int), ("zr", Double), ("zi", Double), ("zr2", Double), ("zi2", Double), ("cr", Double), ("ci", Double)], body: If(Eq(Var("i"), Int(0)), App(Var("print_int"), [Int(1)]), Let(("tr", Var(None)), Prim(Prim(Var("zr2"), Var("zi2"), Sub, kind=None), Var("cr"), Add, kind=None), Let(("ti", Var(None)), Prim(Prim(App(Var("dbl"), [Var("zr")]), Var("zi"), Mul, kind=None), Var("ci"), Add, kind=None), Let(("zr", Var(None)), Var("tr"), Let(("zi", Var(None)), Var("ti"), Let(("zr2", Var(None)), Prim(Var("zr"), Var("zr"), Mul, kind=None), Let(("zi2", Var(None)), Prim(Var("zi"), Var("zi"), Mul, kind=None), If(LE(Prim(Double(2), Double(2), Mul, kind=None), Prim(Var("zr2"), Var("zi2"), Add, kind=None)), App(Var("print_int"), [Int(0)]), App(Var("iloop"), [Prim(Var("i"), Int(1), Sub, kind=None), Var("zr"), Var("zi"), Var("zr2"), Var("zi2"), Var("cr"), Var("ci")])))))))))}, Let(("_", Var(None)), App(Var("iloop"), [Int(1000), Double(0), Double(0), Double(0), Double(0), Var("cr"), Var("ci")]), App(Var("xloop"), [Prim(Var("x"), Int(1), Add, kind=None), Var("y")]))))))}, Let(("_", Var(None)), App(Var("xloop"), [Int(0), Var("y")]), App(Var("yloop"), [Prim(Var("y"), Int(1), Add, kind=None)]))))}, App(Var("yloop"), [Int(0)])))}, LetRec({tyvars: [], name: ("main", Var(None)), args: [], body: App(Var("mandelbrot"), [Int(40)])}, Unit)) against Unit
// [Typer] typevars: []
// [Typer] check: LetRec({tyvars: [], name: ("dbl", Double), args: [("f", Double)], body: Prim(Var("f"), Var("f"), Add, kind=None)}, LetRec({tyvars: [], name: ("yloop", Unit), args: [("y", Int)], body: If(LE(Var("w"), Var("y")), Unit, LetRec({tyvars: [], name: ("xloop", Unit), args: [("x", Int), ("y", Int)], body: If(LE(Var("w"), Var("x")), Let(("_", Var(None)), App(Var("print_endline"), []), Unit), Let(("cr", Var(None)), Prim(Prim(App(Var("dbl"), [App(Var("float_of_int"), [Var("x")])]), App(Var("float_of_int"), [Var("w")]), Div, kind=None), Double(1.5), Sub, kind=None), Let(("ci", Var(None)), Prim(Prim(App(Var("dbl"), [App(Var("float_of_int"), [Var("y")])]), App(Var("float_of_int"), [Var("w")]), Div, kind=None), Double(1), Sub, kind=None), LetRec({tyvars: [], name: ("iloop", Unit), args: [("i", Int), ("zr", Double), ("zi", Double), ("zr2", Double), ("zi2", Double), ("cr", Double), ("ci", Double)], body: If(Eq(Var("i"), Int(0)), App(Var("print_int"), [Int(1)]), Let(("tr", Var(None)), Prim(Prim(Var("zr2"), Var("zi2"), Sub, kind=None), Var("cr"), Add, kind=None), Let(("ti", Var(None)), Prim(Prim(App(Var("dbl"), [Var("zr")]), Var("zi"), Mul, kind=None), Var("ci"), Add, kind=None), Let(("zr", Var(None)), Var("tr"), Let(("zi", Var(None)), Var("ti"), Let(("zr2", Var(None)), Prim(Var("zr"), Var("zr"), Mul, kind=None), Let(("zi2", Var(None)), Prim(Var("zi"), Var("zi"), Mul, kind=None), If(LE(Prim(Double(2), Double(2), Mul, kind=None), Prim(Var("zr2"), Var("zi2"), Add, kind=None)), App(Var("print_int"), [Int(0)]), App(Var("iloop"), [Prim(Var("i"), Int(1), Sub, kind=None), Var("zr"), Var("zi"), Var("zr2"), Var("zi2"), Var("cr"), Var("ci")])))))))))}, Let(("_", Var(None)), App(Var("iloop"), [Int(1000), Double(0), Double(0), Double(0), Double(0), Var("cr"), Var("ci")]), App(Var("xloop"), [Prim(Var("x"), Int(1), Add, kind=None), Var("y")]))))))}, Let(("_", Var(None)), App(Var("xloop"), [Int(0), Var("y")]), App(Var("yloop"), [Prim(Var("y"), Int(1), Add, kind=None)]))))}, App(Var("yloop"), [Int(0)]))) against Unit
// [Typer] typevars: []
// [Typer] check: Prim(Var("f"), Var("f"), Add, kind=None) against Double
// [Typer] check: Var("f") against Double
// [Typer] inst: TypeScheme(([], Double))
// [Typer] inst result: Double
// [Typer] unify: Double and Double
// [Typer] check: Var("f") against Double
// [Typer] inst: TypeScheme(([], Double))
// [Typer] inst result: Double
// [Typer] unify: Double and Double
// [Typer] check: LetRec({tyvars: [], name: ("yloop", Unit), args: [("y", Int)], body: If(LE(Var("w"), Var("y")), Unit, LetRec({tyvars: [], name: ("xloop", Unit), args: [("x", Int), ("y", Int)], body: If(LE(Var("w"), Var("x")), Let(("_", Var(None)), App(Var("print_endline"), []), Unit), Let(("cr", Var(None)), Prim(Prim(App(Var("dbl"), [App(Var("float_of_int"), [Var("x")])]), App(Var("float_of_int"), [Var("w")]), Div, kind=None), Double(1.5), Sub, kind=None), Let(("ci", Var(None)), Prim(Prim(App(Var("dbl"), [App(Var("float_of_int"), [Var("y")])]), App(Var("float_of_int"), [Var("w")]), Div, kind=None), Double(1), Sub, kind=None), LetRec({tyvars: [], name: ("iloop", Unit), args: [("i", Int), ("zr", Double), ("zi", Double), ("zr2", Double), ("zi2", Double), ("cr", Double), ("ci", Double)], body: If(Eq(Var("i"), Int(0)), App(Var("print_int"), [Int(1)]), Let(("tr", Var(None)), Prim(Prim(Var("zr2"), Var("zi2"), Sub, kind=None), Var("cr"), Add, kind=None), Let(("ti", Var(None)), Prim(Prim(App(Var("dbl"), [Var("zr")]), Var("zi"), Mul, kind=None), Var("ci"), Add, kind=None), Let(("zr", Var(None)), Var("tr"), Let(("zi", Var(None)), Var("ti"), Let(("zr2", Var(None)), Prim(Var("zr"), Var("zr"), Mul, kind=None), Let(("zi2", Var(None)), Prim(Var("zi"), Var("zi"), Mul, kind=None), If(LE(Prim(Double(2), Double(2), Mul, kind=None), Prim(Var("zr2"), Var("zi2"), Add, kind=None)), App(Var("print_int"), [Int(0)]), App(Var("iloop"), [Prim(Var("i"), Int(1), Sub, kind=None), Var("zr"), Var("zi"), Var("zr2"), Var("zi2"), Var("cr"), Var("ci")])))))))))}, Let(("_", Var(None)), App(Var("iloop"), [Int(1000), Double(0), Double(0), Double(0), Double(0), Var("cr"), Var("ci")]), App(Var("xloop"), [Prim(Var("x"), Int(1), Add, kind=None), Var("y")]))))))}, Let(("_", Var(None)), App(Var("xloop"), [Int(0), Var("y")]), App(Var("yloop"), [Prim(Var("y"), Int(1), Add, kind=None)]))))}, App(Var("yloop"), [Int(0)])) against Unit
// [Typer] typevars: []
// [Typer] check: If(LE(Var("w"), Var("y")), Unit, LetRec({tyvars: [], name: ("xloop", Unit), args: [("x", Int), ("y", Int)], body: If(LE(Var("w"), Var("x")), Let(("_", Var(None)), App(Var("print_endline"), []), Unit), Let(("cr", Var(None)), Prim(Prim(App(Var("dbl"), [App(Var("float_of_int"), [Var("x")])]), App(Var("float_of_int"), [Var("w")]), Div, kind=None), Double(1.5), Sub, kind=None), Let(("ci", Var(None)), Prim(Prim(App(Var("dbl"), [App(Var("float_of_int"), [Var("y")])]), App(Var("float_of_int"), [Var("w")]), Div, kind=None), Double(1), Sub, kind=None), LetRec({tyvars: [], name: ("iloop", Unit), args: [("i", Int), ("zr", Double), ("zi", Double), ("zr2", Double), ("zi2", Double), ("cr", Double), ("ci", Double)], body: If(Eq(Var("i"), Int(0)), App(Var("print_int"), [Int(1)]), Let(("tr", Var(None)), Prim(Prim(Var("zr2"), Var("zi2"), Sub, kind=None), Var("cr"), Add, kind=None), Let(("ti", Var(None)), Prim(Prim(App(Var("dbl"), [Var("zr")]), Var("zi"), Mul, kind=None), Var("ci"), Add, kind=None), Let(("zr", Var(None)), Var("tr"), Let(("zi", Var(None)), Var("ti"), Let(("zr2", Var(None)), Prim(Var("zr"), Var("zr"), Mul, kind=None), Let(("zi2", Var(None)), Prim(Var("zi"), Var("zi"), Mul, kind=None), If(LE(Prim(Double(2), Double(2), Mul, kind=None), Prim(Var("zr2"), Var("zi2"), Add, kind=None)), App(Var("print_int"), [Int(0)]), App(Var("iloop"), [Prim(Var("i"), Int(1), Sub, kind=None), Var("zr"), Var("zi"), Var("zr2"), Var("zi2"), Var("cr"), Var("ci")])))))))))}, Let(("_", Var(None)), App(Var("iloop"), [Int(1000), Double(0), Double(0), Double(0), Double(0), Var("cr"), Var("ci")]), App(Var("xloop"), [Prim(Var("x"), Int(1), Add, kind=None), Var("y")]))))))}, Let(("_", Var(None)), App(Var("xloop"), [Int(0), Var("y")]), App(Var("yloop"), [Prim(Var("y"), Int(1), Add, kind=None)])))) against Unit
// [Typer] check: LE(Var("w"), Var("y")) against Bool
// [Typer] infer: Var("w")
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] infer: Var("y")
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] check: Unit against Unit
// [Typer] check: LetRec({tyvars: [], name: ("xloop", Unit), args: [("x", Int), ("y", Int)], body: If(LE(Var("w"), Var("x")), Let(("_", Var(None)), App(Var("print_endline"), []), Unit), Let(("cr", Var(None)), Prim(Prim(App(Var("dbl"), [App(Var("float_of_int"), [Var("x")])]), App(Var("float_of_int"), [Var("w")]), Div, kind=None), Double(1.5), Sub, kind=None), Let(("ci", Var(None)), Prim(Prim(App(Var("dbl"), [App(Var("float_of_int"), [Var("y")])]), App(Var("float_of_int"), [Var("w")]), Div, kind=None), Double(1), Sub, kind=None), LetRec({tyvars: [], name: ("iloop", Unit), args: [("i", Int), ("zr", Double), ("zi", Double), ("zr2", Double), ("zi2", Double), ("cr", Double), ("ci", Double)], body: If(Eq(Var("i"), Int(0)), App(Var("print_int"), [Int(1)]), Let(("tr", Var(None)), Prim(Prim(Var("zr2"), Var("zi2"), Sub, kind=None), Var("cr"), Add, kind=None), Let(("ti", Var(None)), Prim(Prim(App(Var("dbl"), [Var("zr")]), Var("zi"), Mul, kind=None), Var("ci"), Add, kind=None), Let(("zr", Var(None)), Var("tr"), Let(("zi", Var(None)), Var("ti"), Let(("zr2", Var(None)), Prim(Var("zr"), Var("zr"), Mul, kind=None), Let(("zi2", Var(None)), Prim(Var("zi"), Var("zi"), Mul, kind=None), If(LE(Prim(Double(2), Double(2), Mul, kind=None), Prim(Var("zr2"), Var("zi2"), Add, kind=None)), App(Var("print_int"), [Int(0)]), App(Var("iloop"), [Prim(Var("i"), Int(1), Sub, kind=None), Var("zr"), Var("zi"), Var("zr2"), Var("zi2"), Var("cr"), Var("ci")])))))))))}, Let(("_", Var(None)), App(Var("iloop"), [Int(1000), Double(0), Double(0), Double(0), Double(0), Var("cr"), Var("ci")]), App(Var("xloop"), [Prim(Var("x"), Int(1), Add, kind=None), Var("y")]))))))}, Let(("_", Var(None)), App(Var("xloop"), [Int(0), Var("y")]), App(Var("yloop"), [Prim(Var("y"), Int(1), Add, kind=None)]))) against Unit
// [Typer] typevars: []
// [Typer] check: If(LE(Var("w"), Var("x")), Let(("_", Var(None)), App(Var("print_endline"), []), Unit), Let(("cr", Var(None)), Prim(Prim(App(Var("dbl"), [App(Var("float_of_int"), [Var("x")])]), App(Var("float_of_int"), [Var("w")]), Div, kind=None), Double(1.5), Sub, kind=None), Let(("ci", Var(None)), Prim(Prim(App(Var("dbl"), [App(Var("float_of_int"), [Var("y")])]), App(Var("float_of_int"), [Var("w")]), Div, kind=None), Double(1), Sub, kind=None), LetRec({tyvars: [], name: ("iloop", Unit), args: [("i", Int), ("zr", Double), ("zi", Double), ("zr2", Double), ("zi2", Double), ("cr", Double), ("ci", Double)], body: If(Eq(Var("i"), Int(0)), App(Var("print_int"), [Int(1)]), Let(("tr", Var(None)), Prim(Prim(Var("zr2"), Var("zi2"), Sub, kind=None), Var("cr"), Add, kind=None), Let(("ti", Var(None)), Prim(Prim(App(Var("dbl"), [Var("zr")]), Var("zi"), Mul, kind=None), Var("ci"), Add, kind=None), Let(("zr", Var(None)), Var("tr"), Let(("zi", Var(None)), Var("ti"), Let(("zr2", Var(None)), Prim(Var("zr"), Var("zr"), Mul, kind=None), Let(("zi2", Var(None)), Prim(Var("zi"), Var("zi"), Mul, kind=None), If(LE(Prim(Double(2), Double(2), Mul, kind=None), Prim(Var("zr2"), Var("zi2"), Add, kind=None)), App(Var("print_int"), [Int(0)]), App(Var("iloop"), [Prim(Var("i"), Int(1), Sub, kind=None), Var("zr"), Var("zi"), Var("zr2"), Var("zi2"), Var("cr"), Var("ci")])))))))))}, Let(("_", Var(None)), App(Var("iloop"), [Int(1000), Double(0), Double(0), Double(0), Double(0), Var("cr"), Var("ci")]), App(Var("xloop"), [Prim(Var("x"), Int(1), Add, kind=None), Var("y")])))))) against Unit
// [Typer] check: LE(Var("w"), Var("x")) against Bool
// [Typer] infer: Var("w")
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] infer: Var("x")
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] check: Let(("_", Var(None)), App(Var("print_endline"), []), Unit) against Unit
// [Typer] infer: App(Var("print_endline"), [])
// [Typer] infer: Var("print_endline")
// [Typer] inst: TypeScheme(([], () -> Unit))
// [Typer] inst result: () -> Unit
// [Typer] unify: Var(None) and Unit
// [Typer] union: Var(None) and Unit
// [Typer] check: Unit against Unit
// [Typer] check: Let(("cr", Var(None)), Prim(Prim(App(Var("dbl"), [App(Var("float_of_int"), [Var("x")])]), App(Var("float_of_int"), [Var("w")]), Div, kind=None), Double(1.5), Sub, kind=None), Let(("ci", Var(None)), Prim(Prim(App(Var("dbl"), [App(Var("float_of_int"), [Var("y")])]), App(Var("float_of_int"), [Var("w")]), Div, kind=None), Double(1), Sub, kind=None), LetRec({tyvars: [], name: ("iloop", Unit), args: [("i", Int), ("zr", Double), ("zi", Double), ("zr2", Double), ("zi2", Double), ("cr", Double), ("ci", Double)], body: If(Eq(Var("i"), Int(0)), App(Var("print_int"), [Int(1)]), Let(("tr", Var(None)), Prim(Prim(Var("zr2"), Var("zi2"), Sub, kind=None), Var("cr"), Add, kind=None), Let(("ti", Var(None)), Prim(Prim(App(Var("dbl"), [Var("zr")]), Var("zi"), Mul, kind=None), Var("ci"), Add, kind=None), Let(("zr", Var(None)), Var("tr"), Let(("zi", Var(None)), Var("ti"), Let(("zr2", Var(None)), Prim(Var("zr"), Var("zr"), Mul, kind=None), Let(("zi2", Var(None)), Prim(Var("zi"), Var("zi"), Mul, kind=None), If(LE(Prim(Double(2), Double(2), Mul, kind=None), Prim(Var("zr2"), Var("zi2"), Add, kind=None)), App(Var("print_int"), [Int(0)]), App(Var("iloop"), [Prim(Var("i"), Int(1), Sub, kind=None), Var("zr"), Var("zi"), Var("zr2"), Var("zi2"), Var("cr"), Var("ci")])))))))))}, Let(("_", Var(None)), App(Var("iloop"), [Int(1000), Double(0), Double(0), Double(0), Double(0), Var("cr"), Var("ci")]), App(Var("xloop"), [Prim(Var("x"), Int(1), Add, kind=None), Var("y")]))))) against Unit
// [Typer] infer: Prim(Prim(App(Var("dbl"), [App(Var("float_of_int"), [Var("x")])]), App(Var("float_of_int"), [Var("w")]), Div, kind=None), Double(1.5), Sub, kind=None)
// [Typer] infer: Prim(App(Var("dbl"), [App(Var("float_of_int"), [Var("x")])]), App(Var("float_of_int"), [Var("w")]), Div, kind=None)
// [Typer] infer: App(Var("dbl"), [App(Var("float_of_int"), [Var("x")])])
// [Typer] infer: Var("dbl")
// [Typer] inst: TypeScheme(([], (Double) -> Double))
// [Typer] inst result: (Double) -> Double
// [Typer] check: App(Var("float_of_int"), [Var("x")]) against Double
// [Typer] infer: Var("x")
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] check: Var("float_of_int") against (Int) -> Double
// [Typer] inst: TypeScheme(([], (Int) -> Double))
// [Typer] inst result: (Int) -> Double
// [Typer] unify: (Int) -> Double and (Int) -> Double
// [Typer] unify: Int and Int
// [Typer] unify: Double and Double
// [Typer] infer: App(Var("float_of_int"), [Var("w")])
// [Typer] infer: Var("float_of_int")
// [Typer] inst: TypeScheme(([], (Int) -> Double))
// [Typer] inst result: (Int) -> Double
// [Typer] check: Var("w") against Int
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] unify: Double and Double
// [Typer] infer: Double(1.5)
// [Typer] unify: Double and Double
// [Typer] unify: Var(None) and Double
// [Typer] union: Var(None) and Double
// [Typer] check: Let(("ci", Var(None)), Prim(Prim(App(Var("dbl"), [App(Var("float_of_int"), [Var("y")])]), App(Var("float_of_int"), [Var("w")]), Div, kind=None), Double(1), Sub, kind=None), LetRec({tyvars: [], name: ("iloop", Unit), args: [("i", Int), ("zr", Double), ("zi", Double), ("zr2", Double), ("zi2", Double), ("cr", Double), ("ci", Double)], body: If(Eq(Var("i"), Int(0)), App(Var("print_int"), [Int(1)]), Let(("tr", Var(None)), Prim(Prim(Var("zr2"), Var("zi2"), Sub, kind=None), Var("cr"), Add, kind=None), Let(("ti", Var(None)), Prim(Prim(App(Var("dbl"), [Var("zr")]), Var("zi"), Mul, kind=None), Var("ci"), Add, kind=None), Let(("zr", Var(None)), Var("tr"), Let(("zi", Var(None)), Var("ti"), Let(("zr2", Var(None)), Prim(Var("zr"), Var("zr"), Mul, kind=None), Let(("zi2", Var(None)), Prim(Var("zi"), Var("zi"), Mul, kind=None), If(LE(Prim(Double(2), Double(2), Mul, kind=None), Prim(Var("zr2"), Var("zi2"), Add, kind=None)), App(Var("print_int"), [Int(0)]), App(Var("iloop"), [Prim(Var("i"), Int(1), Sub, kind=None), Var("zr"), Var("zi"), Var("zr2"), Var("zi2"), Var("cr"), Var("ci")])))))))))}, Let(("_", Var(None)), App(Var("iloop"), [Int(1000), Double(0), Double(0), Double(0), Double(0), Var("cr"), Var("ci")]), App(Var("xloop"), [Prim(Var("x"), Int(1), Add, kind=None), Var("y")])))) against Unit
// [Typer] infer: Prim(Prim(App(Var("dbl"), [App(Var("float_of_int"), [Var("y")])]), App(Var("float_of_int"), [Var("w")]), Div, kind=None), Double(1), Sub, kind=None)
// [Typer] infer: Prim(App(Var("dbl"), [App(Var("float_of_int"), [Var("y")])]), App(Var("float_of_int"), [Var("w")]), Div, kind=None)
// [Typer] infer: App(Var("dbl"), [App(Var("float_of_int"), [Var("y")])])
// [Typer] infer: Var("dbl")
// [Typer] inst: TypeScheme(([], (Double) -> Double))
// [Typer] inst result: (Double) -> Double
// [Typer] check: App(Var("float_of_int"), [Var("y")]) against Double
// [Typer] infer: Var("y")
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] check: Var("float_of_int") against (Int) -> Double
// [Typer] inst: TypeScheme(([], (Int) -> Double))
// [Typer] inst result: (Int) -> Double
// [Typer] unify: (Int) -> Double and (Int) -> Double
// [Typer] unify: Int and Int
// [Typer] unify: Double and Double
// [Typer] infer: App(Var("float_of_int"), [Var("w")])
// [Typer] infer: Var("float_of_int")
// [Typer] inst: TypeScheme(([], (Int) -> Double))
// [Typer] inst result: (Int) -> Double
// [Typer] check: Var("w") against Int
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] unify: Double and Double
// [Typer] infer: Double(1)
// [Typer] unify: Double and Double
// [Typer] unify: Var(None) and Double
// [Typer] union: Var(None) and Double
// [Typer] check: LetRec({tyvars: [], name: ("iloop", Unit), args: [("i", Int), ("zr", Double), ("zi", Double), ("zr2", Double), ("zi2", Double), ("cr", Double), ("ci", Double)], body: If(Eq(Var("i"), Int(0)), App(Var("print_int"), [Int(1)]), Let(("tr", Var(None)), Prim(Prim(Var("zr2"), Var("zi2"), Sub, kind=None), Var("cr"), Add, kind=None), Let(("ti", Var(None)), Prim(Prim(App(Var("dbl"), [Var("zr")]), Var("zi"), Mul, kind=None), Var("ci"), Add, kind=None), Let(("zr", Var(None)), Var("tr"), Let(("zi", Var(None)), Var("ti"), Let(("zr2", Var(None)), Prim(Var("zr"), Var("zr"), Mul, kind=None), Let(("zi2", Var(None)), Prim(Var("zi"), Var("zi"), Mul, kind=None), If(LE(Prim(Double(2), Double(2), Mul, kind=None), Prim(Var("zr2"), Var("zi2"), Add, kind=None)), App(Var("print_int"), [Int(0)]), App(Var("iloop"), [Prim(Var("i"), Int(1), Sub, kind=None), Var("zr"), Var("zi"), Var("zr2"), Var("zi2"), Var("cr"), Var("ci")])))))))))}, Let(("_", Var(None)), App(Var("iloop"), [Int(1000), Double(0), Double(0), Double(0), Double(0), Var("cr"), Var("ci")]), App(Var("xloop"), [Prim(Var("x"), Int(1), Add, kind=None), Var("y")]))) against Unit
// [Typer] typevars: []
// [Typer] check: If(Eq(Var("i"), Int(0)), App(Var("print_int"), [Int(1)]), Let(("tr", Var(None)), Prim(Prim(Var("zr2"), Var("zi2"), Sub, kind=None), Var("cr"), Add, kind=None), Let(("ti", Var(None)), Prim(Prim(App(Var("dbl"), [Var("zr")]), Var("zi"), Mul, kind=None), Var("ci"), Add, kind=None), Let(("zr", Var(None)), Var("tr"), Let(("zi", Var(None)), Var("ti"), Let(("zr2", Var(None)), Prim(Var("zr"), Var("zr"), Mul, kind=None), Let(("zi2", Var(None)), Prim(Var("zi"), Var("zi"), Mul, kind=None), If(LE(Prim(Double(2), Double(2), Mul, kind=None), Prim(Var("zr2"), Var("zi2"), Add, kind=None)), App(Var("print_int"), [Int(0)]), App(Var("iloop"), [Prim(Var("i"), Int(1), Sub, kind=None), Var("zr"), Var("zi"), Var("zr2"), Var("zi2"), Var("cr"), Var("ci")]))))))))) against Unit
// [Typer] check: Eq(Var("i"), Int(0)) against Bool
// [Typer] infer: Var("i")
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] infer: Int(0)
// [Typer] unify: Int and Int
// [Typer] check: App(Var("print_int"), [Int(1)]) against Unit
// [Typer] infer: Int(1)
// [Typer] check: Var("print_int") against (Int) -> Unit
// [Typer] inst: TypeScheme(([], (Int) -> Unit))
// [Typer] inst result: (Int) -> Unit
// [Typer] unify: (Int) -> Unit and (Int) -> Unit
// [Typer] unify: Int and Int
// [Typer] unify: Unit and Unit
// [Typer] check: Let(("tr", Var(None)), Prim(Prim(Var("zr2"), Var("zi2"), Sub, kind=None), Var("cr"), Add, kind=None), Let(("ti", Var(None)), Prim(Prim(App(Var("dbl"), [Var("zr")]), Var("zi"), Mul, kind=None), Var("ci"), Add, kind=None), Let(("zr", Var(None)), Var("tr"), Let(("zi", Var(None)), Var("ti"), Let(("zr2", Var(None)), Prim(Var("zr"), Var("zr"), Mul, kind=None), Let(("zi2", Var(None)), Prim(Var("zi"), Var("zi"), Mul, kind=None), If(LE(Prim(Double(2), Double(2), Mul, kind=None), Prim(Var("zr2"), Var("zi2"), Add, kind=None)), App(Var("print_int"), [Int(0)]), App(Var("iloop"), [Prim(Var("i"), Int(1), Sub, kind=None), Var("zr"), Var("zi"), Var("zr2"), Var("zi2"), Var("cr"), Var("ci")])))))))) against Unit
// [Typer] infer: Prim(Prim(Var("zr2"), Var("zi2"), Sub, kind=None), Var("cr"), Add, kind=None)
// [Typer] infer: Prim(Var("zr2"), Var("zi2"), Sub, kind=None)
// [Typer] infer: Var("zr2")
// [Typer] inst: TypeScheme(([], Double))
// [Typer] inst result: Double
// [Typer] infer: Var("zi2")
// [Typer] inst: TypeScheme(([], Double))
// [Typer] inst result: Double
// [Typer] unify: Double and Double
// [Typer] infer: Var("cr")
// [Typer] inst: TypeScheme(([], Double))
// [Typer] inst result: Double
// [Typer] unify: Double and Double
// [Typer] unify: Var(None) and Double
// [Typer] union: Var(None) and Double
// [Typer] check: Let(("ti", Var(None)), Prim(Prim(App(Var("dbl"), [Var("zr")]), Var("zi"), Mul, kind=None), Var("ci"), Add, kind=None), Let(("zr", Var(None)), Var("tr"), Let(("zi", Var(None)), Var("ti"), Let(("zr2", Var(None)), Prim(Var("zr"), Var("zr"), Mul, kind=None), Let(("zi2", Var(None)), Prim(Var("zi"), Var("zi"), Mul, kind=None), If(LE(Prim(Double(2), Double(2), Mul, kind=None), Prim(Var("zr2"), Var("zi2"), Add, kind=None)), App(Var("print_int"), [Int(0)]), App(Var("iloop"), [Prim(Var("i"), Int(1), Sub, kind=None), Var("zr"), Var("zi"), Var("zr2"), Var("zi2"), Var("cr"), Var("ci")]))))))) against Unit
// [Typer] infer: Prim(Prim(App(Var("dbl"), [Var("zr")]), Var("zi"), Mul, kind=None), Var("ci"), Add, kind=None)
// [Typer] infer: Prim(App(Var("dbl"), [Var("zr")]), Var("zi"), Mul, kind=None)
// [Typer] infer: App(Var("dbl"), [Var("zr")])
// [Typer] infer: Var("dbl")
// [Typer] inst: TypeScheme(([], (Double) -> Double))
// [Typer] inst result: (Double) -> Double
// [Typer] check: Var("zr") against Double
// [Typer] inst: TypeScheme(([], Double))
// [Typer] inst result: Double
// [Typer] unify: Double and Double
// [Typer] infer: Var("zi")
// [Typer] inst: TypeScheme(([], Double))
// [Typer] inst result: Double
// [Typer] unify: Double and Double
// [Typer] infer: Var("ci")
// [Typer] inst: TypeScheme(([], Double))
// [Typer] inst result: Double
// [Typer] unify: Double and Double
// [Typer] unify: Var(None) and Double
// [Typer] union: Var(None) and Double
// [Typer] check: Let(("zr", Var(None)), Var("tr"), Let(("zi", Var(None)), Var("ti"), Let(("zr2", Var(None)), Prim(Var("zr"), Var("zr"), Mul, kind=None), Let(("zi2", Var(None)), Prim(Var("zi"), Var("zi"), Mul, kind=None), If(LE(Prim(Double(2), Double(2), Mul, kind=None), Prim(Var("zr2"), Var("zi2"), Add, kind=None)), App(Var("print_int"), [Int(0)]), App(Var("iloop"), [Prim(Var("i"), Int(1), Sub, kind=None), Var("zr"), Var("zi"), Var("zr2"), Var("zi2"), Var("cr"), Var("ci")])))))) against Unit
// [Typer] infer: Var("tr")
// [Typer] inst: TypeScheme(([], Var(Double)))
// [Typer] inst result: Double
// [Typer] unify: Var(None) and Double
// [Typer] union: Var(None) and Double
// [Typer] check: Let(("zi", Var(None)), Var("ti"), Let(("zr2", Var(None)), Prim(Var("zr"), Var("zr"), Mul, kind=None), Let(("zi2", Var(None)), Prim(Var("zi"), Var("zi"), Mul, kind=None), If(LE(Prim(Double(2), Double(2), Mul, kind=None), Prim(Var("zr2"), Var("zi2"), Add, kind=None)), App(Var("print_int"), [Int(0)]), App(Var("iloop"), [Prim(Var("i"), Int(1), Sub, kind=None), Var("zr"), Var("zi"), Var("zr2"), Var("zi2"), Var("cr"), Var("ci")]))))) against Unit
// [Typer] infer: Var("ti")
// [Typer] inst: TypeScheme(([], Var(Double)))
// [Typer] inst result: Double
// [Typer] unify: Var(None) and Double
// [Typer] union: Var(None) and Double
// [Typer] check: Let(("zr2", Var(None)), Prim(Var("zr"), Var("zr"), Mul, kind=None), Let(("zi2", Var(None)), Prim(Var("zi"), Var("zi"), Mul, kind=None), If(LE(Prim(Double(2), Double(2), Mul, kind=None), Prim(Var("zr2"), Var("zi2"), Add, kind=None)), App(Var("print_int"), [Int(0)]), App(Var("iloop"), [Prim(Var("i"), Int(1), Sub, kind=None), Var("zr"), Var("zi"), Var("zr2"), Var("zi2"), Var("cr"), Var("ci")])))) against Unit
// [Typer] infer: Prim(Var("zr"), Var("zr"), Mul, kind=None)
// [Typer] infer: Var("zr")
// [Typer] inst: TypeScheme(([], Var(Double)))
// [Typer] inst result: Double
// [Typer] infer: Var("zr")
// [Typer] inst: TypeScheme(([], Var(Double)))
// [Typer] inst result: Double
// [Typer] unify: Double and Double
// [Typer] unify: Var(None) and Double
// [Typer] union: Var(None) and Double
// [Typer] check: Let(("zi2", Var(None)), Prim(Var("zi"), Var("zi"), Mul, kind=None), If(LE(Prim(Double(2), Double(2), Mul, kind=None), Prim(Var("zr2"), Var("zi2"), Add, kind=None)), App(Var("print_int"), [Int(0)]), App(Var("iloop"), [Prim(Var("i"), Int(1), Sub, kind=None), Var("zr"), Var("zi"), Var("zr2"), Var("zi2"), Var("cr"), Var("ci")]))) against Unit
// [Typer] infer: Prim(Var("zi"), Var("zi"), Mul, kind=None)
// [Typer] infer: Var("zi")
// [Typer] inst: TypeScheme(([], Var(Double)))
// [Typer] inst result: Double
// [Typer] infer: Var("zi")
// [Typer] inst: TypeScheme(([], Var(Double)))
// [Typer] inst result: Double
// [Typer] unify: Double and Double
// [Typer] unify: Var(None) and Double
// [Typer] union: Var(None) and Double
// [Typer] check: If(LE(Prim(Double(2), Double(2), Mul, kind=None), Prim(Var("zr2"), Var("zi2"), Add, kind=None)), App(Var("print_int"), [Int(0)]), App(Var("iloop"), [Prim(Var("i"), Int(1), Sub, kind=None), Var("zr"), Var("zi"), Var("zr2"), Var("zi2"), Var("cr"), Var("ci")])) against Unit
// [Typer] check: LE(Prim(Double(2), Double(2), Mul, kind=None), Prim(Var("zr2"), Var("zi2"), Add, kind=None)) against Bool
// [Typer] infer: Prim(Double(2), Double(2), Mul, kind=None)
// [Typer] infer: Double(2)
// [Typer] infer: Double(2)
// [Typer] unify: Double and Double
// [Typer] infer: Prim(Var("zr2"), Var("zi2"), Add, kind=None)
// [Typer] infer: Var("zr2")
// [Typer] inst: TypeScheme(([], Var(Double)))
// [Typer] inst result: Double
// [Typer] infer: Var("zi2")
// [Typer] inst: TypeScheme(([], Var(Double)))
// [Typer] inst result: Double
// [Typer] unify: Double and Double
// [Typer] unify: Double and Double
// [Typer] check: App(Var("print_int"), [Int(0)]) against Unit
// [Typer] infer: Int(0)
// [Typer] check: Var("print_int") against (Int) -> Unit
// [Typer] inst: TypeScheme(([], (Int) -> Unit))
// [Typer] inst result: (Int) -> Unit
// [Typer] unify: (Int) -> Unit and (Int) -> Unit
// [Typer] unify: Int and Int
// [Typer] unify: Unit and Unit
// [Typer] check: App(Var("iloop"), [Prim(Var("i"), Int(1), Sub, kind=None), Var("zr"), Var("zi"), Var("zr2"), Var("zi2"), Var("cr"), Var("ci")]) against Unit
// [Typer] infer: Prim(Var("i"), Int(1), Sub, kind=None)
// [Typer] infer: Var("i")
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] infer: Int(1)
// [Typer] unify: Int and Int
// [Typer] infer: Var("zr")
// [Typer] inst: TypeScheme(([], Var(Double)))
// [Typer] inst result: Double
// [Typer] infer: Var("zi")
// [Typer] inst: TypeScheme(([], Var(Double)))
// [Typer] inst result: Double
// [Typer] infer: Var("zr2")
// [Typer] inst: TypeScheme(([], Var(Double)))
// [Typer] inst result: Double
// [Typer] infer: Var("zi2")
// [Typer] inst: TypeScheme(([], Var(Double)))
// [Typer] inst result: Double
// [Typer] infer: Var("cr")
// [Typer] inst: TypeScheme(([], Double))
// [Typer] inst result: Double
// [Typer] infer: Var("ci")
// [Typer] inst: TypeScheme(([], Double))
// [Typer] inst result: Double
// [Typer] check: Var("iloop") against (Int, Double, Double, Double, Double, Double, Double) -> Unit
// [Typer] inst: TypeScheme(([], (Int, Double, Double, Double, Double, Double, Double) -> Unit))
// [Typer] inst result: (Int, Double, Double, Double, Double, Double, Double) -> Unit
// [Typer] unify: (Int, Double, Double, Double, Double, Double, Double) -> Unit and (Int, Double, Double, Double, Double, Double, Double) -> Unit
// [Typer] unify: Int and Int
// [Typer] unify: Double and Double
// [Typer] unify: Double and Double
// [Typer] unify: Double and Double
// [Typer] unify: Double and Double
// [Typer] unify: Double and Double
// [Typer] unify: Double and Double
// [Typer] unify: Unit and Unit
// [Typer] check: Let(("_", Var(None)), App(Var("iloop"), [Int(1000), Double(0), Double(0), Double(0), Double(0), Var("cr"), Var("ci")]), App(Var("xloop"), [Prim(Var("x"), Int(1), Add, kind=None), Var("y")])) against Unit
// [Typer] infer: App(Var("iloop"), [Int(1000), Double(0), Double(0), Double(0), Double(0), Var("cr"), Var("ci")])
// [Typer] infer: Var("iloop")
// [Typer] inst: TypeScheme(([], (Int, Double, Double, Double, Double, Double, Double) -> Unit))
// [Typer] inst result: (Int, Double, Double, Double, Double, Double, Double) -> Unit
// [Typer] check: Int(1000) against Int
// [Typer] check: Double(0) against Double
// [Typer] check: Double(0) against Double
// [Typer] check: Double(0) against Double
// [Typer] check: Double(0) against Double
// [Typer] check: Var("cr") against Double
// [Typer] inst: TypeScheme(([], Var(Double)))
// [Typer] inst result: Double
// [Typer] unify: Double and Double
// [Typer] check: Var("ci") against Double
// [Typer] inst: TypeScheme(([], Var(Double)))
// [Typer] inst result: Double
// [Typer] unify: Double and Double
// [Typer] unify: Var(None) and Unit
// [Typer] union: Var(None) and Unit
// [Typer] check: App(Var("xloop"), [Prim(Var("x"), Int(1), Add, kind=None), Var("y")]) against Unit
// [Typer] infer: Prim(Var("x"), Int(1), Add, kind=None)
// [Typer] infer: Var("x")
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] infer: Int(1)
// [Typer] unify: Int and Int
// [Typer] infer: Var("y")
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] check: Var("xloop") against (Int, Int) -> Unit
// [Typer] inst: TypeScheme(([], (Int, Int) -> Unit))
// [Typer] inst result: (Int, Int) -> Unit
// [Typer] unify: (Int, Int) -> Unit and (Int, Int) -> Unit
// [Typer] unify: Int and Int
// [Typer] unify: Int and Int
// [Typer] unify: Unit and Unit
// [Typer] check: Let(("_", Var(None)), App(Var("xloop"), [Int(0), Var("y")]), App(Var("yloop"), [Prim(Var("y"), Int(1), Add, kind=None)])) against Unit
// [Typer] infer: App(Var("xloop"), [Int(0), Var("y")])
// [Typer] infer: Var("xloop")
// [Typer] inst: TypeScheme(([], (Int, Int) -> Unit))
// [Typer] inst result: (Int, Int) -> Unit
// [Typer] check: Int(0) against Int
// [Typer] check: Var("y") against Int
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] unify: Var(None) and Unit
// [Typer] union: Var(None) and Unit
// [Typer] check: App(Var("yloop"), [Prim(Var("y"), Int(1), Add, kind=None)]) against Unit
// [Typer] infer: Prim(Var("y"), Int(1), Add, kind=None)
// [Typer] infer: Var("y")
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] infer: Int(1)
// [Typer] unify: Int and Int
// [Typer] check: Var("yloop") against (Int) -> Unit
// [Typer] inst: TypeScheme(([], (Int) -> Unit))
// [Typer] inst result: (Int) -> Unit
// [Typer] unify: (Int) -> Unit and (Int) -> Unit
// [Typer] unify: Int and Int
// [Typer] unify: Unit and Unit
// [Typer] check: App(Var("yloop"), [Int(0)]) against Unit
// [Typer] infer: Int(0)
// [Typer] check: Var("yloop") against (Int) -> Unit
// [Typer] inst: TypeScheme(([], (Int) -> Unit))
// [Typer] inst result: (Int) -> Unit
// [Typer] unify: (Int) -> Unit and (Int) -> Unit
// [Typer] unify: Int and Int
// [Typer] unify: Unit and Unit
// [Typer] check: LetRec({tyvars: [], name: ("main", Var(None)), args: [], body: App(Var("mandelbrot"), [Int(40)])}, Unit) against Unit
// [Typer] typevars: []
// [Typer] infer: App(Var("mandelbrot"), [Int(40)])
// [Typer] infer: Var("mandelbrot")
// [Typer] inst: TypeScheme(([], (Int) -> Unit))
// [Typer] inst result: (Int) -> Unit
// [Typer] check: Int(40) against Int
// [Typer] unify: Unit and Var(None)
// [Typer] union: Unit and Var(None)
// [Typer] check: Unit against Unit
// [Parser] flags: []
