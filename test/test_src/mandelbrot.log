// [Main] function thunk_main(k) {
// [Main]   function mandelbrot_1(w_3, k) {
// [Main]     function dbl_4(f_6, k) {
// [Main]       return k(f_6 + f_6)
// [Main]     }
// [Main]     function yloop_7(y_9, k) {
// [Main]       if (w_3 <= y_9) {
// [Main]         return k(null)
// [Main]       } else {
// [Main]         function xloop_10(x_12, y_14, k) {
// [Main]           if (w_3 <= x_12) {
// [Main]             const _16 = minimbt_print_endline();
// [Main]             return k(null)
// [Main]           } else {
// [Main]             const _17 = minimbt_float_of_int($force(x_12));
// [Main]             return $thunk(() => dbl_4(_17, function (_18) {
// [Main]               const _19 = minimbt_float_of_int($force(w_3));
// [Main]               const _20 = _18 / _19;
// [Main]               const _21 = 1.5;
// [Main]               const cr_22 = _20 - _21;
// [Main]               const _23 = minimbt_float_of_int($force(y_14));
// [Main]               return $thunk(() => dbl_4(_23, function (_24) {
// [Main]                 const _25 = minimbt_float_of_int($force(w_3));
// [Main]                 const _26 = _24 / _25;
// [Main]                 const _27 = 1;
// [Main]                 const ci_28 = _26 - _27;
// [Main]                 function iloop_29(i_31, zr_33, zi_35, zr2_37, zi2_39, cr_41, ci_43, k) {
// [Main]                   const _44 = 0;
// [Main]                   if (i_31 === _44) {
// [Main]                     const _45 = 1;
// [Main]                     return k(minimbt_print_int($force(_45)))
// [Main]                   } else {
// [Main]                     const _46 = zr2_37 - zi2_39;
// [Main]                     const tr_47 = _46 + cr_41;
// [Main]                     return $thunk(() => dbl_4(zr_33, function (_48) {
// [Main]                       const _49 = _48 * zi_35;
// [Main]                       const ti_50 = _49 + ci_43;
// [Main]                       const zr2_51 = tr_47 * tr_47;
// [Main]                       const zi2_52 = ti_50 * ti_50;
// [Main]                       const _53 = 2;
// [Main]                       const _54 = 2;
// [Main]                       const _55 = _53 * _54;
// [Main]                       const _56 = zr2_51 + zi2_52;
// [Main]                       if (_55 <= _56) {
// [Main]                         const _57 = 0;
// [Main]                         return $thunk(() => k(minimbt_print_int($force(_57))))
// [Main]                       } else {
// [Main]                         const _58 = 1;
// [Main]                         const _59 = i_31 - _58;
// [Main]                         return $thunk(() => iloop_29(_59, tr_47, ti_50, zr2_51, zi2_52, cr_41, ci_43, k))
// [Main]                       }
// [Main]                     }
// [Main]                     ))
// [Main]                   }
// [Main]                 }
// [Main]                 const _60 = 1000;
// [Main]                 const _61 = 0;
// [Main]                 const _62 = 0;
// [Main]                 const _63 = 0;
// [Main]                 const _64 = 0;
// [Main]                 return $thunk(() => iloop_29(_60, _61, _62, _63, _64, cr_22, ci_28, function (_66) {
// [Main]                   const _67 = 1;
// [Main]                   const _68 = x_12 + _67;
// [Main]                   return $thunk(() => xloop_10(_68, y_14, k))
// [Main]                 }
// [Main]                 ))
// [Main]               }
// [Main]               ))
// [Main]             }
// [Main]             ))
// [Main]           }
// [Main]         }
// [Main]         const _69 = 0;
// [Main]         return $thunk(() => xloop_10(_69, y_9, function (_71) {
// [Main]           const _72 = 1;
// [Main]           const _73 = y_9 + _72;
// [Main]           return $thunk(() => yloop_7(_73, k))
// [Main]         }
// [Main]         ))
// [Main]       }
// [Main]     }
// [Main]     const _74 = 0;
// [Main]     return $thunk(() => yloop_7(_74, k))
// [Main]   }
// [Main]   function main_75(k) {
// [Main]     const _76 = 40;
// [Main]     return $thunk(() => mandelbrot_1(_76, k))
// [Main]   }
// [Main]   return $thunk(() => main_75(k))
// [Main] }
// [Main] 
// [Main] function $thunk(lambda) {
// [Main]   return { thunk: lambda };
// [Main] }
// [Main] function $is_thunk(x) {
// [Main]   return x && x.hasOwnProperty('thunk') && x.thunk !== undefined;
// [Main] }
// [Main] function $force(x) {
// [Main]   while ($is_thunk(x)) {
// [Main]     x = x.thunk();
// [Main]   }
// [Main]   return x;
// [Main] }
// [Main] function $trampoline(f, ...args) {
// [Main]   let x = f(...args);
// [Main]   return $force(x);
// [Main] }
// [Main] export default () => $trampoline(thunk_main, x => x);
// [Typer] check: LetRec({tyvars: [], name: ("mandelbrot", Unit), args: [("w", Int)], body: LetRec({tyvars: [], name: ("dbl", Double), args: [("f", Double)], body: Prim(Var("f"), Var("f"), Add, kind=None)}, LetRec({tyvars: [], name: ("yloop", Unit), args: [("y", Int)], body: If(LE(Var("w"), Var("y")), Unit, LetRec({tyvars: [], name: ("xloop", Unit), args: [("x", Int), ("y", Int)], body: If(LE(Var("w"), Var("x")), Let(("_", Var({val: None})), App(Var("print_endline"), []), Unit), Let(("cr", Var({val: None})), Prim(Prim(App(Var("dbl"), [App(Var("float_of_int"), [Var("x")])]), App(Var("float_of_int"), [Var("w")]), Div, kind=None), Double(1.5), Sub, kind=None), Let(("ci", Var({val: None})), Prim(Prim(App(Var("dbl"), [App(Var("float_of_int"), [Var("y")])]), App(Var("float_of_int"), [Var("w")]), Div, kind=None), Double(1), Sub, kind=None), LetRec({tyvars: [], name: ("iloop", Unit), args: [("i", Int), ("zr", Double), ("zi", Double), ("zr2", Double), ("zi2", Double), ("cr", Double), ("ci", Double)], body: If(Eq(Var("i"), Int(0)), App(Var("print_int"), [Int(1)]), Let(("tr", Var({val: None})), Prim(Prim(Var("zr2"), Var("zi2"), Sub, kind=None), Var("cr"), Add, kind=None), Let(("ti", Var({val: None})), Prim(Prim(App(Var("dbl"), [Var("zr")]), Var("zi"), Mul, kind=None), Var("ci"), Add, kind=None), Let(("zr", Var({val: None})), Var("tr"), Let(("zi", Var({val: None})), Var("ti"), Let(("zr2", Var({val: None})), Prim(Var("zr"), Var("zr"), Mul, kind=None), Let(("zi2", Var({val: None})), Prim(Var("zi"), Var("zi"), Mul, kind=None), If(LE(Prim(Double(2), Double(2), Mul, kind=None), Prim(Var("zr2"), Var("zi2"), Add, kind=None)), App(Var("print_int"), [Int(0)]), App(Var("iloop"), [Prim(Var("i"), Int(1), Sub, kind=None), Var("zr"), Var("zi"), Var("zr2"), Var("zi2"), Var("cr"), Var("ci")])))))))))}, Let(("_", Var({val: None})), App(Var("iloop"), [Int(1000), Double(0), Double(0), Double(0), Double(0), Var("cr"), Var("ci")]), App(Var("xloop"), [Prim(Var("x"), Int(1), Add, kind=None), Var("y")]))))))}, Let(("_", Var({val: None})), App(Var("xloop"), [Int(0), Var("y")]), App(Var("yloop"), [Prim(Var("y"), Int(1), Add, kind=None)]))))}, App(Var("yloop"), [Int(0)])))}, LetRec({tyvars: [], name: ("main", Var({val: None})), args: [], body: App(Var("mandelbrot"), [Int(40)])}, Unit)) against Unit
// [Typer] typevars: []
// [Typer] check: LetRec({tyvars: [], name: ("dbl", Double), args: [("f", Double)], body: Prim(Var("f"), Var("f"), Add, kind=None)}, LetRec({tyvars: [], name: ("yloop", Unit), args: [("y", Int)], body: If(LE(Var("w"), Var("y")), Unit, LetRec({tyvars: [], name: ("xloop", Unit), args: [("x", Int), ("y", Int)], body: If(LE(Var("w"), Var("x")), Let(("_", Var({val: None})), App(Var("print_endline"), []), Unit), Let(("cr", Var({val: None})), Prim(Prim(App(Var("dbl"), [App(Var("float_of_int"), [Var("x")])]), App(Var("float_of_int"), [Var("w")]), Div, kind=None), Double(1.5), Sub, kind=None), Let(("ci", Var({val: None})), Prim(Prim(App(Var("dbl"), [App(Var("float_of_int"), [Var("y")])]), App(Var("float_of_int"), [Var("w")]), Div, kind=None), Double(1), Sub, kind=None), LetRec({tyvars: [], name: ("iloop", Unit), args: [("i", Int), ("zr", Double), ("zi", Double), ("zr2", Double), ("zi2", Double), ("cr", Double), ("ci", Double)], body: If(Eq(Var("i"), Int(0)), App(Var("print_int"), [Int(1)]), Let(("tr", Var({val: None})), Prim(Prim(Var("zr2"), Var("zi2"), Sub, kind=None), Var("cr"), Add, kind=None), Let(("ti", Var({val: None})), Prim(Prim(App(Var("dbl"), [Var("zr")]), Var("zi"), Mul, kind=None), Var("ci"), Add, kind=None), Let(("zr", Var({val: None})), Var("tr"), Let(("zi", Var({val: None})), Var("ti"), Let(("zr2", Var({val: None})), Prim(Var("zr"), Var("zr"), Mul, kind=None), Let(("zi2", Var({val: None})), Prim(Var("zi"), Var("zi"), Mul, kind=None), If(LE(Prim(Double(2), Double(2), Mul, kind=None), Prim(Var("zr2"), Var("zi2"), Add, kind=None)), App(Var("print_int"), [Int(0)]), App(Var("iloop"), [Prim(Var("i"), Int(1), Sub, kind=None), Var("zr"), Var("zi"), Var("zr2"), Var("zi2"), Var("cr"), Var("ci")])))))))))}, Let(("_", Var({val: None})), App(Var("iloop"), [Int(1000), Double(0), Double(0), Double(0), Double(0), Var("cr"), Var("ci")]), App(Var("xloop"), [Prim(Var("x"), Int(1), Add, kind=None), Var("y")]))))))}, Let(("_", Var({val: None})), App(Var("xloop"), [Int(0), Var("y")]), App(Var("yloop"), [Prim(Var("y"), Int(1), Add, kind=None)]))))}, App(Var("yloop"), [Int(0)]))) against Unit
// [Typer] typevars: []
// [Typer] check: Prim(Var("f"), Var("f"), Add, kind=None) against Double
// [Typer] check: Var("f") against Double
// [Typer] inst: TypeScheme(([], Double))
// [Typer] inst result: Double
// [Typer] unify: Double and Double
// [Typer] check: Var("f") against Double
// [Typer] inst: TypeScheme(([], Double))
// [Typer] inst result: Double
// [Typer] unify: Double and Double
// [Typer] check: LetRec({tyvars: [], name: ("yloop", Unit), args: [("y", Int)], body: If(LE(Var("w"), Var("y")), Unit, LetRec({tyvars: [], name: ("xloop", Unit), args: [("x", Int), ("y", Int)], body: If(LE(Var("w"), Var("x")), Let(("_", Var({val: None})), App(Var("print_endline"), []), Unit), Let(("cr", Var({val: None})), Prim(Prim(App(Var("dbl"), [App(Var("float_of_int"), [Var("x")])]), App(Var("float_of_int"), [Var("w")]), Div, kind=None), Double(1.5), Sub, kind=None), Let(("ci", Var({val: None})), Prim(Prim(App(Var("dbl"), [App(Var("float_of_int"), [Var("y")])]), App(Var("float_of_int"), [Var("w")]), Div, kind=None), Double(1), Sub, kind=None), LetRec({tyvars: [], name: ("iloop", Unit), args: [("i", Int), ("zr", Double), ("zi", Double), ("zr2", Double), ("zi2", Double), ("cr", Double), ("ci", Double)], body: If(Eq(Var("i"), Int(0)), App(Var("print_int"), [Int(1)]), Let(("tr", Var({val: None})), Prim(Prim(Var("zr2"), Var("zi2"), Sub, kind=None), Var("cr"), Add, kind=None), Let(("ti", Var({val: None})), Prim(Prim(App(Var("dbl"), [Var("zr")]), Var("zi"), Mul, kind=None), Var("ci"), Add, kind=None), Let(("zr", Var({val: None})), Var("tr"), Let(("zi", Var({val: None})), Var("ti"), Let(("zr2", Var({val: None})), Prim(Var("zr"), Var("zr"), Mul, kind=None), Let(("zi2", Var({val: None})), Prim(Var("zi"), Var("zi"), Mul, kind=None), If(LE(Prim(Double(2), Double(2), Mul, kind=None), Prim(Var("zr2"), Var("zi2"), Add, kind=None)), App(Var("print_int"), [Int(0)]), App(Var("iloop"), [Prim(Var("i"), Int(1), Sub, kind=None), Var("zr"), Var("zi"), Var("zr2"), Var("zi2"), Var("cr"), Var("ci")])))))))))}, Let(("_", Var({val: None})), App(Var("iloop"), [Int(1000), Double(0), Double(0), Double(0), Double(0), Var("cr"), Var("ci")]), App(Var("xloop"), [Prim(Var("x"), Int(1), Add, kind=None), Var("y")]))))))}, Let(("_", Var({val: None})), App(Var("xloop"), [Int(0), Var("y")]), App(Var("yloop"), [Prim(Var("y"), Int(1), Add, kind=None)]))))}, App(Var("yloop"), [Int(0)])) against Unit
// [Typer] typevars: []
// [Typer] check: If(LE(Var("w"), Var("y")), Unit, LetRec({tyvars: [], name: ("xloop", Unit), args: [("x", Int), ("y", Int)], body: If(LE(Var("w"), Var("x")), Let(("_", Var({val: None})), App(Var("print_endline"), []), Unit), Let(("cr", Var({val: None})), Prim(Prim(App(Var("dbl"), [App(Var("float_of_int"), [Var("x")])]), App(Var("float_of_int"), [Var("w")]), Div, kind=None), Double(1.5), Sub, kind=None), Let(("ci", Var({val: None})), Prim(Prim(App(Var("dbl"), [App(Var("float_of_int"), [Var("y")])]), App(Var("float_of_int"), [Var("w")]), Div, kind=None), Double(1), Sub, kind=None), LetRec({tyvars: [], name: ("iloop", Unit), args: [("i", Int), ("zr", Double), ("zi", Double), ("zr2", Double), ("zi2", Double), ("cr", Double), ("ci", Double)], body: If(Eq(Var("i"), Int(0)), App(Var("print_int"), [Int(1)]), Let(("tr", Var({val: None})), Prim(Prim(Var("zr2"), Var("zi2"), Sub, kind=None), Var("cr"), Add, kind=None), Let(("ti", Var({val: None})), Prim(Prim(App(Var("dbl"), [Var("zr")]), Var("zi"), Mul, kind=None), Var("ci"), Add, kind=None), Let(("zr", Var({val: None})), Var("tr"), Let(("zi", Var({val: None})), Var("ti"), Let(("zr2", Var({val: None})), Prim(Var("zr"), Var("zr"), Mul, kind=None), Let(("zi2", Var({val: None})), Prim(Var("zi"), Var("zi"), Mul, kind=None), If(LE(Prim(Double(2), Double(2), Mul, kind=None), Prim(Var("zr2"), Var("zi2"), Add, kind=None)), App(Var("print_int"), [Int(0)]), App(Var("iloop"), [Prim(Var("i"), Int(1), Sub, kind=None), Var("zr"), Var("zi"), Var("zr2"), Var("zi2"), Var("cr"), Var("ci")])))))))))}, Let(("_", Var({val: None})), App(Var("iloop"), [Int(1000), Double(0), Double(0), Double(0), Double(0), Var("cr"), Var("ci")]), App(Var("xloop"), [Prim(Var("x"), Int(1), Add, kind=None), Var("y")]))))))}, Let(("_", Var({val: None})), App(Var("xloop"), [Int(0), Var("y")]), App(Var("yloop"), [Prim(Var("y"), Int(1), Add, kind=None)])))) against Unit
// [Typer] check: LE(Var("w"), Var("y")) against Bool
// [Typer] infer: Var("w")
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] infer: Var("y")
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] check: Unit against Unit
// [Typer] check: LetRec({tyvars: [], name: ("xloop", Unit), args: [("x", Int), ("y", Int)], body: If(LE(Var("w"), Var("x")), Let(("_", Var({val: None})), App(Var("print_endline"), []), Unit), Let(("cr", Var({val: None})), Prim(Prim(App(Var("dbl"), [App(Var("float_of_int"), [Var("x")])]), App(Var("float_of_int"), [Var("w")]), Div, kind=None), Double(1.5), Sub, kind=None), Let(("ci", Var({val: None})), Prim(Prim(App(Var("dbl"), [App(Var("float_of_int"), [Var("y")])]), App(Var("float_of_int"), [Var("w")]), Div, kind=None), Double(1), Sub, kind=None), LetRec({tyvars: [], name: ("iloop", Unit), args: [("i", Int), ("zr", Double), ("zi", Double), ("zr2", Double), ("zi2", Double), ("cr", Double), ("ci", Double)], body: If(Eq(Var("i"), Int(0)), App(Var("print_int"), [Int(1)]), Let(("tr", Var({val: None})), Prim(Prim(Var("zr2"), Var("zi2"), Sub, kind=None), Var("cr"), Add, kind=None), Let(("ti", Var({val: None})), Prim(Prim(App(Var("dbl"), [Var("zr")]), Var("zi"), Mul, kind=None), Var("ci"), Add, kind=None), Let(("zr", Var({val: None})), Var("tr"), Let(("zi", Var({val: None})), Var("ti"), Let(("zr2", Var({val: None})), Prim(Var("zr"), Var("zr"), Mul, kind=None), Let(("zi2", Var({val: None})), Prim(Var("zi"), Var("zi"), Mul, kind=None), If(LE(Prim(Double(2), Double(2), Mul, kind=None), Prim(Var("zr2"), Var("zi2"), Add, kind=None)), App(Var("print_int"), [Int(0)]), App(Var("iloop"), [Prim(Var("i"), Int(1), Sub, kind=None), Var("zr"), Var("zi"), Var("zr2"), Var("zi2"), Var("cr"), Var("ci")])))))))))}, Let(("_", Var({val: None})), App(Var("iloop"), [Int(1000), Double(0), Double(0), Double(0), Double(0), Var("cr"), Var("ci")]), App(Var("xloop"), [Prim(Var("x"), Int(1), Add, kind=None), Var("y")]))))))}, Let(("_", Var({val: None})), App(Var("xloop"), [Int(0), Var("y")]), App(Var("yloop"), [Prim(Var("y"), Int(1), Add, kind=None)]))) against Unit
// [Typer] typevars: []
// [Typer] check: If(LE(Var("w"), Var("x")), Let(("_", Var({val: None})), App(Var("print_endline"), []), Unit), Let(("cr", Var({val: None})), Prim(Prim(App(Var("dbl"), [App(Var("float_of_int"), [Var("x")])]), App(Var("float_of_int"), [Var("w")]), Div, kind=None), Double(1.5), Sub, kind=None), Let(("ci", Var({val: None})), Prim(Prim(App(Var("dbl"), [App(Var("float_of_int"), [Var("y")])]), App(Var("float_of_int"), [Var("w")]), Div, kind=None), Double(1), Sub, kind=None), LetRec({tyvars: [], name: ("iloop", Unit), args: [("i", Int), ("zr", Double), ("zi", Double), ("zr2", Double), ("zi2", Double), ("cr", Double), ("ci", Double)], body: If(Eq(Var("i"), Int(0)), App(Var("print_int"), [Int(1)]), Let(("tr", Var({val: None})), Prim(Prim(Var("zr2"), Var("zi2"), Sub, kind=None), Var("cr"), Add, kind=None), Let(("ti", Var({val: None})), Prim(Prim(App(Var("dbl"), [Var("zr")]), Var("zi"), Mul, kind=None), Var("ci"), Add, kind=None), Let(("zr", Var({val: None})), Var("tr"), Let(("zi", Var({val: None})), Var("ti"), Let(("zr2", Var({val: None})), Prim(Var("zr"), Var("zr"), Mul, kind=None), Let(("zi2", Var({val: None})), Prim(Var("zi"), Var("zi"), Mul, kind=None), If(LE(Prim(Double(2), Double(2), Mul, kind=None), Prim(Var("zr2"), Var("zi2"), Add, kind=None)), App(Var("print_int"), [Int(0)]), App(Var("iloop"), [Prim(Var("i"), Int(1), Sub, kind=None), Var("zr"), Var("zi"), Var("zr2"), Var("zi2"), Var("cr"), Var("ci")])))))))))}, Let(("_", Var({val: None})), App(Var("iloop"), [Int(1000), Double(0), Double(0), Double(0), Double(0), Var("cr"), Var("ci")]), App(Var("xloop"), [Prim(Var("x"), Int(1), Add, kind=None), Var("y")])))))) against Unit
// [Typer] check: LE(Var("w"), Var("x")) against Bool
// [Typer] infer: Var("w")
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] infer: Var("x")
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] check: Let(("_", Var({val: None})), App(Var("print_endline"), []), Unit) against Unit
// [Typer] infer: App(Var("print_endline"), [])
// [Typer] infer: Var("print_endline")
// [Typer] inst: TypeScheme(([], Fun([], Unit)))
// [Typer] inst result: Fun([], Unit)
// [Typer] unify: Var({val: None}) and Unit
// [Typer] union: Var({val: None}) and Unit
// [Typer] check: Unit against Unit
// [Typer] check: Let(("cr", Var({val: None})), Prim(Prim(App(Var("dbl"), [App(Var("float_of_int"), [Var("x")])]), App(Var("float_of_int"), [Var("w")]), Div, kind=None), Double(1.5), Sub, kind=None), Let(("ci", Var({val: None})), Prim(Prim(App(Var("dbl"), [App(Var("float_of_int"), [Var("y")])]), App(Var("float_of_int"), [Var("w")]), Div, kind=None), Double(1), Sub, kind=None), LetRec({tyvars: [], name: ("iloop", Unit), args: [("i", Int), ("zr", Double), ("zi", Double), ("zr2", Double), ("zi2", Double), ("cr", Double), ("ci", Double)], body: If(Eq(Var("i"), Int(0)), App(Var("print_int"), [Int(1)]), Let(("tr", Var({val: None})), Prim(Prim(Var("zr2"), Var("zi2"), Sub, kind=None), Var("cr"), Add, kind=None), Let(("ti", Var({val: None})), Prim(Prim(App(Var("dbl"), [Var("zr")]), Var("zi"), Mul, kind=None), Var("ci"), Add, kind=None), Let(("zr", Var({val: None})), Var("tr"), Let(("zi", Var({val: None})), Var("ti"), Let(("zr2", Var({val: None})), Prim(Var("zr"), Var("zr"), Mul, kind=None), Let(("zi2", Var({val: None})), Prim(Var("zi"), Var("zi"), Mul, kind=None), If(LE(Prim(Double(2), Double(2), Mul, kind=None), Prim(Var("zr2"), Var("zi2"), Add, kind=None)), App(Var("print_int"), [Int(0)]), App(Var("iloop"), [Prim(Var("i"), Int(1), Sub, kind=None), Var("zr"), Var("zi"), Var("zr2"), Var("zi2"), Var("cr"), Var("ci")])))))))))}, Let(("_", Var({val: None})), App(Var("iloop"), [Int(1000), Double(0), Double(0), Double(0), Double(0), Var("cr"), Var("ci")]), App(Var("xloop"), [Prim(Var("x"), Int(1), Add, kind=None), Var("y")]))))) against Unit
// [Typer] infer: Prim(Prim(App(Var("dbl"), [App(Var("float_of_int"), [Var("x")])]), App(Var("float_of_int"), [Var("w")]), Div, kind=None), Double(1.5), Sub, kind=None)
// [Typer] infer: Prim(App(Var("dbl"), [App(Var("float_of_int"), [Var("x")])]), App(Var("float_of_int"), [Var("w")]), Div, kind=None)
// [Typer] infer: App(Var("dbl"), [App(Var("float_of_int"), [Var("x")])])
// [Typer] infer: Var("dbl")
// [Typer] inst: TypeScheme(([], Fun([Double], Double)))
// [Typer] inst result: Fun([Double], Double)
// [Typer] check: App(Var("float_of_int"), [Var("x")]) against Double
// [Typer] infer: Var("x")
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] check: Var("float_of_int") against Fun([Int], Double)
// [Typer] inst: TypeScheme(([], Fun([Int], Double)))
// [Typer] inst result: Fun([Int], Double)
// [Typer] unify: Fun([Int], Double) and Fun([Int], Double)
// [Typer] unify: Int and Int
// [Typer] unify: Double and Double
// [Typer] infer: App(Var("float_of_int"), [Var("w")])
// [Typer] infer: Var("float_of_int")
// [Typer] inst: TypeScheme(([], Fun([Int], Double)))
// [Typer] inst result: Fun([Int], Double)
// [Typer] check: Var("w") against Int
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] unify: Double and Double
// [Typer] infer: Double(1.5)
// [Typer] unify: Double and Double
// [Typer] unify: Var({val: None}) and Double
// [Typer] union: Var({val: None}) and Double
// [Typer] check: Let(("ci", Var({val: None})), Prim(Prim(App(Var("dbl"), [App(Var("float_of_int"), [Var("y")])]), App(Var("float_of_int"), [Var("w")]), Div, kind=None), Double(1), Sub, kind=None), LetRec({tyvars: [], name: ("iloop", Unit), args: [("i", Int), ("zr", Double), ("zi", Double), ("zr2", Double), ("zi2", Double), ("cr", Double), ("ci", Double)], body: If(Eq(Var("i"), Int(0)), App(Var("print_int"), [Int(1)]), Let(("tr", Var({val: None})), Prim(Prim(Var("zr2"), Var("zi2"), Sub, kind=None), Var("cr"), Add, kind=None), Let(("ti", Var({val: None})), Prim(Prim(App(Var("dbl"), [Var("zr")]), Var("zi"), Mul, kind=None), Var("ci"), Add, kind=None), Let(("zr", Var({val: None})), Var("tr"), Let(("zi", Var({val: None})), Var("ti"), Let(("zr2", Var({val: None})), Prim(Var("zr"), Var("zr"), Mul, kind=None), Let(("zi2", Var({val: None})), Prim(Var("zi"), Var("zi"), Mul, kind=None), If(LE(Prim(Double(2), Double(2), Mul, kind=None), Prim(Var("zr2"), Var("zi2"), Add, kind=None)), App(Var("print_int"), [Int(0)]), App(Var("iloop"), [Prim(Var("i"), Int(1), Sub, kind=None), Var("zr"), Var("zi"), Var("zr2"), Var("zi2"), Var("cr"), Var("ci")])))))))))}, Let(("_", Var({val: None})), App(Var("iloop"), [Int(1000), Double(0), Double(0), Double(0), Double(0), Var("cr"), Var("ci")]), App(Var("xloop"), [Prim(Var("x"), Int(1), Add, kind=None), Var("y")])))) against Unit
// [Typer] infer: Prim(Prim(App(Var("dbl"), [App(Var("float_of_int"), [Var("y")])]), App(Var("float_of_int"), [Var("w")]), Div, kind=None), Double(1), Sub, kind=None)
// [Typer] infer: Prim(App(Var("dbl"), [App(Var("float_of_int"), [Var("y")])]), App(Var("float_of_int"), [Var("w")]), Div, kind=None)
// [Typer] infer: App(Var("dbl"), [App(Var("float_of_int"), [Var("y")])])
// [Typer] infer: Var("dbl")
// [Typer] inst: TypeScheme(([], Fun([Double], Double)))
// [Typer] inst result: Fun([Double], Double)
// [Typer] check: App(Var("float_of_int"), [Var("y")]) against Double
// [Typer] infer: Var("y")
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] check: Var("float_of_int") against Fun([Int], Double)
// [Typer] inst: TypeScheme(([], Fun([Int], Double)))
// [Typer] inst result: Fun([Int], Double)
// [Typer] unify: Fun([Int], Double) and Fun([Int], Double)
// [Typer] unify: Int and Int
// [Typer] unify: Double and Double
// [Typer] infer: App(Var("float_of_int"), [Var("w")])
// [Typer] infer: Var("float_of_int")
// [Typer] inst: TypeScheme(([], Fun([Int], Double)))
// [Typer] inst result: Fun([Int], Double)
// [Typer] check: Var("w") against Int
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] unify: Double and Double
// [Typer] infer: Double(1)
// [Typer] unify: Double and Double
// [Typer] unify: Var({val: None}) and Double
// [Typer] union: Var({val: None}) and Double
// [Typer] check: LetRec({tyvars: [], name: ("iloop", Unit), args: [("i", Int), ("zr", Double), ("zi", Double), ("zr2", Double), ("zi2", Double), ("cr", Double), ("ci", Double)], body: If(Eq(Var("i"), Int(0)), App(Var("print_int"), [Int(1)]), Let(("tr", Var({val: None})), Prim(Prim(Var("zr2"), Var("zi2"), Sub, kind=None), Var("cr"), Add, kind=None), Let(("ti", Var({val: None})), Prim(Prim(App(Var("dbl"), [Var("zr")]), Var("zi"), Mul, kind=None), Var("ci"), Add, kind=None), Let(("zr", Var({val: None})), Var("tr"), Let(("zi", Var({val: None})), Var("ti"), Let(("zr2", Var({val: None})), Prim(Var("zr"), Var("zr"), Mul, kind=None), Let(("zi2", Var({val: None})), Prim(Var("zi"), Var("zi"), Mul, kind=None), If(LE(Prim(Double(2), Double(2), Mul, kind=None), Prim(Var("zr2"), Var("zi2"), Add, kind=None)), App(Var("print_int"), [Int(0)]), App(Var("iloop"), [Prim(Var("i"), Int(1), Sub, kind=None), Var("zr"), Var("zi"), Var("zr2"), Var("zi2"), Var("cr"), Var("ci")])))))))))}, Let(("_", Var({val: None})), App(Var("iloop"), [Int(1000), Double(0), Double(0), Double(0), Double(0), Var("cr"), Var("ci")]), App(Var("xloop"), [Prim(Var("x"), Int(1), Add, kind=None), Var("y")]))) against Unit
// [Typer] typevars: []
// [Typer] check: If(Eq(Var("i"), Int(0)), App(Var("print_int"), [Int(1)]), Let(("tr", Var({val: None})), Prim(Prim(Var("zr2"), Var("zi2"), Sub, kind=None), Var("cr"), Add, kind=None), Let(("ti", Var({val: None})), Prim(Prim(App(Var("dbl"), [Var("zr")]), Var("zi"), Mul, kind=None), Var("ci"), Add, kind=None), Let(("zr", Var({val: None})), Var("tr"), Let(("zi", Var({val: None})), Var("ti"), Let(("zr2", Var({val: None})), Prim(Var("zr"), Var("zr"), Mul, kind=None), Let(("zi2", Var({val: None})), Prim(Var("zi"), Var("zi"), Mul, kind=None), If(LE(Prim(Double(2), Double(2), Mul, kind=None), Prim(Var("zr2"), Var("zi2"), Add, kind=None)), App(Var("print_int"), [Int(0)]), App(Var("iloop"), [Prim(Var("i"), Int(1), Sub, kind=None), Var("zr"), Var("zi"), Var("zr2"), Var("zi2"), Var("cr"), Var("ci")]))))))))) against Unit
// [Typer] check: Eq(Var("i"), Int(0)) against Bool
// [Typer] infer: Var("i")
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] infer: Int(0)
// [Typer] unify: Int and Int
// [Typer] check: App(Var("print_int"), [Int(1)]) against Unit
// [Typer] infer: Int(1)
// [Typer] check: Var("print_int") against Fun([Int], Unit)
// [Typer] inst: TypeScheme(([], Fun([Int], Unit)))
// [Typer] inst result: Fun([Int], Unit)
// [Typer] unify: Fun([Int], Unit) and Fun([Int], Unit)
// [Typer] unify: Int and Int
// [Typer] unify: Unit and Unit
// [Typer] check: Let(("tr", Var({val: None})), Prim(Prim(Var("zr2"), Var("zi2"), Sub, kind=None), Var("cr"), Add, kind=None), Let(("ti", Var({val: None})), Prim(Prim(App(Var("dbl"), [Var("zr")]), Var("zi"), Mul, kind=None), Var("ci"), Add, kind=None), Let(("zr", Var({val: None})), Var("tr"), Let(("zi", Var({val: None})), Var("ti"), Let(("zr2", Var({val: None})), Prim(Var("zr"), Var("zr"), Mul, kind=None), Let(("zi2", Var({val: None})), Prim(Var("zi"), Var("zi"), Mul, kind=None), If(LE(Prim(Double(2), Double(2), Mul, kind=None), Prim(Var("zr2"), Var("zi2"), Add, kind=None)), App(Var("print_int"), [Int(0)]), App(Var("iloop"), [Prim(Var("i"), Int(1), Sub, kind=None), Var("zr"), Var("zi"), Var("zr2"), Var("zi2"), Var("cr"), Var("ci")])))))))) against Unit
// [Typer] infer: Prim(Prim(Var("zr2"), Var("zi2"), Sub, kind=None), Var("cr"), Add, kind=None)
// [Typer] infer: Prim(Var("zr2"), Var("zi2"), Sub, kind=None)
// [Typer] infer: Var("zr2")
// [Typer] inst: TypeScheme(([], Double))
// [Typer] inst result: Double
// [Typer] infer: Var("zi2")
// [Typer] inst: TypeScheme(([], Double))
// [Typer] inst result: Double
// [Typer] unify: Double and Double
// [Typer] infer: Var("cr")
// [Typer] inst: TypeScheme(([], Double))
// [Typer] inst result: Double
// [Typer] unify: Double and Double
// [Typer] unify: Var({val: None}) and Double
// [Typer] union: Var({val: None}) and Double
// [Typer] check: Let(("ti", Var({val: None})), Prim(Prim(App(Var("dbl"), [Var("zr")]), Var("zi"), Mul, kind=None), Var("ci"), Add, kind=None), Let(("zr", Var({val: None})), Var("tr"), Let(("zi", Var({val: None})), Var("ti"), Let(("zr2", Var({val: None})), Prim(Var("zr"), Var("zr"), Mul, kind=None), Let(("zi2", Var({val: None})), Prim(Var("zi"), Var("zi"), Mul, kind=None), If(LE(Prim(Double(2), Double(2), Mul, kind=None), Prim(Var("zr2"), Var("zi2"), Add, kind=None)), App(Var("print_int"), [Int(0)]), App(Var("iloop"), [Prim(Var("i"), Int(1), Sub, kind=None), Var("zr"), Var("zi"), Var("zr2"), Var("zi2"), Var("cr"), Var("ci")]))))))) against Unit
// [Typer] infer: Prim(Prim(App(Var("dbl"), [Var("zr")]), Var("zi"), Mul, kind=None), Var("ci"), Add, kind=None)
// [Typer] infer: Prim(App(Var("dbl"), [Var("zr")]), Var("zi"), Mul, kind=None)
// [Typer] infer: App(Var("dbl"), [Var("zr")])
// [Typer] infer: Var("dbl")
// [Typer] inst: TypeScheme(([], Fun([Double], Double)))
// [Typer] inst result: Fun([Double], Double)
// [Typer] check: Var("zr") against Double
// [Typer] inst: TypeScheme(([], Double))
// [Typer] inst result: Double
// [Typer] unify: Double and Double
// [Typer] infer: Var("zi")
// [Typer] inst: TypeScheme(([], Double))
// [Typer] inst result: Double
// [Typer] unify: Double and Double
// [Typer] infer: Var("ci")
// [Typer] inst: TypeScheme(([], Double))
// [Typer] inst result: Double
// [Typer] unify: Double and Double
// [Typer] unify: Var({val: None}) and Double
// [Typer] union: Var({val: None}) and Double
// [Typer] check: Let(("zr", Var({val: None})), Var("tr"), Let(("zi", Var({val: None})), Var("ti"), Let(("zr2", Var({val: None})), Prim(Var("zr"), Var("zr"), Mul, kind=None), Let(("zi2", Var({val: None})), Prim(Var("zi"), Var("zi"), Mul, kind=None), If(LE(Prim(Double(2), Double(2), Mul, kind=None), Prim(Var("zr2"), Var("zi2"), Add, kind=None)), App(Var("print_int"), [Int(0)]), App(Var("iloop"), [Prim(Var("i"), Int(1), Sub, kind=None), Var("zr"), Var("zi"), Var("zr2"), Var("zi2"), Var("cr"), Var("ci")])))))) against Unit
// [Typer] infer: Var("tr")
// [Typer] inst: TypeScheme(([], Var({val: Some(Double)})))
// [Typer] inst result: Double
// [Typer] unify: Var({val: None}) and Double
// [Typer] union: Var({val: None}) and Double
// [Typer] check: Let(("zi", Var({val: None})), Var("ti"), Let(("zr2", Var({val: None})), Prim(Var("zr"), Var("zr"), Mul, kind=None), Let(("zi2", Var({val: None})), Prim(Var("zi"), Var("zi"), Mul, kind=None), If(LE(Prim(Double(2), Double(2), Mul, kind=None), Prim(Var("zr2"), Var("zi2"), Add, kind=None)), App(Var("print_int"), [Int(0)]), App(Var("iloop"), [Prim(Var("i"), Int(1), Sub, kind=None), Var("zr"), Var("zi"), Var("zr2"), Var("zi2"), Var("cr"), Var("ci")]))))) against Unit
// [Typer] infer: Var("ti")
// [Typer] inst: TypeScheme(([], Var({val: Some(Double)})))
// [Typer] inst result: Double
// [Typer] unify: Var({val: None}) and Double
// [Typer] union: Var({val: None}) and Double
// [Typer] check: Let(("zr2", Var({val: None})), Prim(Var("zr"), Var("zr"), Mul, kind=None), Let(("zi2", Var({val: None})), Prim(Var("zi"), Var("zi"), Mul, kind=None), If(LE(Prim(Double(2), Double(2), Mul, kind=None), Prim(Var("zr2"), Var("zi2"), Add, kind=None)), App(Var("print_int"), [Int(0)]), App(Var("iloop"), [Prim(Var("i"), Int(1), Sub, kind=None), Var("zr"), Var("zi"), Var("zr2"), Var("zi2"), Var("cr"), Var("ci")])))) against Unit
// [Typer] infer: Prim(Var("zr"), Var("zr"), Mul, kind=None)
// [Typer] infer: Var("zr")
// [Typer] inst: TypeScheme(([], Var({val: Some(Double)})))
// [Typer] inst result: Double
// [Typer] infer: Var("zr")
// [Typer] inst: TypeScheme(([], Var({val: Some(Double)})))
// [Typer] inst result: Double
// [Typer] unify: Double and Double
// [Typer] unify: Var({val: None}) and Double
// [Typer] union: Var({val: None}) and Double
// [Typer] check: Let(("zi2", Var({val: None})), Prim(Var("zi"), Var("zi"), Mul, kind=None), If(LE(Prim(Double(2), Double(2), Mul, kind=None), Prim(Var("zr2"), Var("zi2"), Add, kind=None)), App(Var("print_int"), [Int(0)]), App(Var("iloop"), [Prim(Var("i"), Int(1), Sub, kind=None), Var("zr"), Var("zi"), Var("zr2"), Var("zi2"), Var("cr"), Var("ci")]))) against Unit
// [Typer] infer: Prim(Var("zi"), Var("zi"), Mul, kind=None)
// [Typer] infer: Var("zi")
// [Typer] inst: TypeScheme(([], Var({val: Some(Double)})))
// [Typer] inst result: Double
// [Typer] infer: Var("zi")
// [Typer] inst: TypeScheme(([], Var({val: Some(Double)})))
// [Typer] inst result: Double
// [Typer] unify: Double and Double
// [Typer] unify: Var({val: None}) and Double
// [Typer] union: Var({val: None}) and Double
// [Typer] check: If(LE(Prim(Double(2), Double(2), Mul, kind=None), Prim(Var("zr2"), Var("zi2"), Add, kind=None)), App(Var("print_int"), [Int(0)]), App(Var("iloop"), [Prim(Var("i"), Int(1), Sub, kind=None), Var("zr"), Var("zi"), Var("zr2"), Var("zi2"), Var("cr"), Var("ci")])) against Unit
// [Typer] check: LE(Prim(Double(2), Double(2), Mul, kind=None), Prim(Var("zr2"), Var("zi2"), Add, kind=None)) against Bool
// [Typer] infer: Prim(Double(2), Double(2), Mul, kind=None)
// [Typer] infer: Double(2)
// [Typer] infer: Double(2)
// [Typer] unify: Double and Double
// [Typer] infer: Prim(Var("zr2"), Var("zi2"), Add, kind=None)
// [Typer] infer: Var("zr2")
// [Typer] inst: TypeScheme(([], Var({val: Some(Double)})))
// [Typer] inst result: Double
// [Typer] infer: Var("zi2")
// [Typer] inst: TypeScheme(([], Var({val: Some(Double)})))
// [Typer] inst result: Double
// [Typer] unify: Double and Double
// [Typer] unify: Double and Double
// [Typer] check: App(Var("print_int"), [Int(0)]) against Unit
// [Typer] infer: Int(0)
// [Typer] check: Var("print_int") against Fun([Int], Unit)
// [Typer] inst: TypeScheme(([], Fun([Int], Unit)))
// [Typer] inst result: Fun([Int], Unit)
// [Typer] unify: Fun([Int], Unit) and Fun([Int], Unit)
// [Typer] unify: Int and Int
// [Typer] unify: Unit and Unit
// [Typer] check: App(Var("iloop"), [Prim(Var("i"), Int(1), Sub, kind=None), Var("zr"), Var("zi"), Var("zr2"), Var("zi2"), Var("cr"), Var("ci")]) against Unit
// [Typer] infer: Prim(Var("i"), Int(1), Sub, kind=None)
// [Typer] infer: Var("i")
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] infer: Int(1)
// [Typer] unify: Int and Int
// [Typer] infer: Var("zr")
// [Typer] inst: TypeScheme(([], Var({val: Some(Double)})))
// [Typer] inst result: Double
// [Typer] infer: Var("zi")
// [Typer] inst: TypeScheme(([], Var({val: Some(Double)})))
// [Typer] inst result: Double
// [Typer] infer: Var("zr2")
// [Typer] inst: TypeScheme(([], Var({val: Some(Double)})))
// [Typer] inst result: Double
// [Typer] infer: Var("zi2")
// [Typer] inst: TypeScheme(([], Var({val: Some(Double)})))
// [Typer] inst result: Double
// [Typer] infer: Var("cr")
// [Typer] inst: TypeScheme(([], Double))
// [Typer] inst result: Double
// [Typer] infer: Var("ci")
// [Typer] inst: TypeScheme(([], Double))
// [Typer] inst result: Double
// [Typer] check: Var("iloop") against Fun([Int, Double, Double, Double, Double, Double, Double], Unit)
// [Typer] inst: TypeScheme(([], Fun([Int, Double, Double, Double, Double, Double, Double], Unit)))
// [Typer] inst result: Fun([Int, Double, Double, Double, Double, Double, Double], Unit)
// [Typer] unify: Fun([Int, Double, Double, Double, Double, Double, Double], Unit) and Fun([Int, Double, Double, Double, Double, Double, Double], Unit)
// [Typer] unify: Int and Int
// [Typer] unify: Double and Double
// [Typer] unify: Double and Double
// [Typer] unify: Double and Double
// [Typer] unify: Double and Double
// [Typer] unify: Double and Double
// [Typer] unify: Double and Double
// [Typer] unify: Unit and Unit
// [Typer] check: Let(("_", Var({val: None})), App(Var("iloop"), [Int(1000), Double(0), Double(0), Double(0), Double(0), Var("cr"), Var("ci")]), App(Var("xloop"), [Prim(Var("x"), Int(1), Add, kind=None), Var("y")])) against Unit
// [Typer] infer: App(Var("iloop"), [Int(1000), Double(0), Double(0), Double(0), Double(0), Var("cr"), Var("ci")])
// [Typer] infer: Var("iloop")
// [Typer] inst: TypeScheme(([], Fun([Int, Double, Double, Double, Double, Double, Double], Unit)))
// [Typer] inst result: Fun([Int, Double, Double, Double, Double, Double, Double], Unit)
// [Typer] check: Int(1000) against Int
// [Typer] check: Double(0) against Double
// [Typer] check: Double(0) against Double
// [Typer] check: Double(0) against Double
// [Typer] check: Double(0) against Double
// [Typer] check: Var("cr") against Double
// [Typer] inst: TypeScheme(([], Var({val: Some(Double)})))
// [Typer] inst result: Double
// [Typer] unify: Double and Double
// [Typer] check: Var("ci") against Double
// [Typer] inst: TypeScheme(([], Var({val: Some(Double)})))
// [Typer] inst result: Double
// [Typer] unify: Double and Double
// [Typer] unify: Var({val: None}) and Unit
// [Typer] union: Var({val: None}) and Unit
// [Typer] check: App(Var("xloop"), [Prim(Var("x"), Int(1), Add, kind=None), Var("y")]) against Unit
// [Typer] infer: Prim(Var("x"), Int(1), Add, kind=None)
// [Typer] infer: Var("x")
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] infer: Int(1)
// [Typer] unify: Int and Int
// [Typer] infer: Var("y")
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] check: Var("xloop") against Fun([Int, Int], Unit)
// [Typer] inst: TypeScheme(([], Fun([Int, Int], Unit)))
// [Typer] inst result: Fun([Int, Int], Unit)
// [Typer] unify: Fun([Int, Int], Unit) and Fun([Int, Int], Unit)
// [Typer] unify: Int and Int
// [Typer] unify: Int and Int
// [Typer] unify: Unit and Unit
// [Typer] check: Let(("_", Var({val: None})), App(Var("xloop"), [Int(0), Var("y")]), App(Var("yloop"), [Prim(Var("y"), Int(1), Add, kind=None)])) against Unit
// [Typer] infer: App(Var("xloop"), [Int(0), Var("y")])
// [Typer] infer: Var("xloop")
// [Typer] inst: TypeScheme(([], Fun([Int, Int], Unit)))
// [Typer] inst result: Fun([Int, Int], Unit)
// [Typer] check: Int(0) against Int
// [Typer] check: Var("y") against Int
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] unify: Var({val: None}) and Unit
// [Typer] union: Var({val: None}) and Unit
// [Typer] check: App(Var("yloop"), [Prim(Var("y"), Int(1), Add, kind=None)]) against Unit
// [Typer] infer: Prim(Var("y"), Int(1), Add, kind=None)
// [Typer] infer: Var("y")
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] infer: Int(1)
// [Typer] unify: Int and Int
// [Typer] check: Var("yloop") against Fun([Int], Unit)
// [Typer] inst: TypeScheme(([], Fun([Int], Unit)))
// [Typer] inst result: Fun([Int], Unit)
// [Typer] unify: Fun([Int], Unit) and Fun([Int], Unit)
// [Typer] unify: Int and Int
// [Typer] unify: Unit and Unit
// [Typer] check: App(Var("yloop"), [Int(0)]) against Unit
// [Typer] infer: Int(0)
// [Typer] check: Var("yloop") against Fun([Int], Unit)
// [Typer] inst: TypeScheme(([], Fun([Int], Unit)))
// [Typer] inst result: Fun([Int], Unit)
// [Typer] unify: Fun([Int], Unit) and Fun([Int], Unit)
// [Typer] unify: Int and Int
// [Typer] unify: Unit and Unit
// [Typer] check: LetRec({tyvars: [], name: ("main", Var({val: None})), args: [], body: App(Var("mandelbrot"), [Int(40)])}, Unit) against Unit
// [Typer] typevars: []
// [Typer] infer: App(Var("mandelbrot"), [Int(40)])
// [Typer] infer: Var("mandelbrot")
// [Typer] inst: TypeScheme(([], Fun([Int], Unit)))
// [Typer] inst result: Fun([Int], Unit)
// [Typer] check: Int(40) against Int
// [Typer] unify: Unit and Var({val: None})
// [Typer] union: Unit and Var({val: None})
// [Typer] check: Unit against Unit
// [Parser] flags: []
