// [Main] function thunk_main(k) {
// [Main]   function h_1(p_3, k) {
// [Main]     const [v1_5, v2_7, v3_9, v4_11, v5_13, v6_15, v7_17, v8_19, v9_21, v10_23] = p_3;function g_24(z_26, k) {
// [Main]       const _27 = v1_5 + v2_7;
// [Main]       const _28 = _27 + v3_9;
// [Main]       const _29 = _28 + v4_11;
// [Main]       const _30 = _29 + v5_13;
// [Main]       const _31 = _30 + v6_15;
// [Main]       const _32 = _31 + v7_17;
// [Main]       const _33 = _32 + v8_19;
// [Main]       const _34 = _33 + v9_21;
// [Main]       const r_35 = _34 + v10_23;
// [Main]       const _36 = 0;
// [Main]       if (z_26 <= _36) {
// [Main]         const _37 = -z_26;
// [Main]         return $thunk(() => g_24(_37, k))
// [Main]       } else {
// [Main]         return k(r_35)
// [Main]       }
// [Main]     }
// [Main]     const _38 = 1;
// [Main]     return $thunk(() => g_24(_38, k))
// [Main]   }
// [Main]   function main_39(k) {
// [Main]     const _40 = 1;
// [Main]     const _41 = 2;
// [Main]     const _42 = 3;
// [Main]     const _43 = 4;
// [Main]     const _44 = 5;
// [Main]     const _45 = 6;
// [Main]     const _46 = 7;
// [Main]     const _47 = 8;
// [Main]     const _48 = 9;
// [Main]     const _49 = 10;
// [Main]     const _50 = [_40, _41, _42, _43, _44, _45, _46, _47, _48, _49];
// [Main]     return $thunk(() => h_1(_50, function (_51) {
// [Main]       const t1_52 = minimbt_print_int($force(_51));
// [Main]       return $thunk(() => k(null))
// [Main]     }
// [Main]     ))
// [Main]   }
// [Main]   return $thunk(() => main_39(k))
// [Main] }
// [Main] 
// [Main] function $thunk(lambda) {
// [Main]   return { thunk: lambda };
// [Main] }
// [Main] function $is_thunk(x) {
// [Main]   return x && x.hasOwnProperty('thunk') && x.thunk !== undefined;
// [Main] }
// [Main] function $force(x) {
// [Main]   while ($is_thunk(x)) {
// [Main]     x = x.thunk();
// [Main]   }
// [Main]   return x;
// [Main] }
// [Main] function $trampoline(f, ...args) {
// [Main]   let x = f(...args);
// [Main]   return $force(x);
// [Main] }
// [Main] export default () => $trampoline(thunk_main, x => x);
// [Typer] check: LetRec({tyvars: [], name: ("h", Int), args: [("p", Tuple([Int, Int, Int, Int, Int, Int, Int, Int, Int, Int]))], body: LetTuple([("v1", Var({val: None})), ("v2", Var({val: None})), ("v3", Var({val: None})), ("v4", Var({val: None})), ("v5", Var({val: None})), ("v6", Var({val: None})), ("v7", Var({val: None})), ("v8", Var({val: None})), ("v9", Var({val: None})), ("v10", Var({val: None}))], Var("p"), LetRec({tyvars: [], name: ("g", Int), args: [("z", Int)], body: Let(("r", Var({val: None})), Prim(Prim(Prim(Prim(Prim(Prim(Prim(Prim(Prim(Var("v1"), Var("v2"), Add, kind=None), Var("v3"), Add, kind=None), Var("v4"), Add, kind=None), Var("v5"), Add, kind=None), Var("v6"), Add, kind=None), Var("v7"), Add, kind=None), Var("v8"), Add, kind=None), Var("v9"), Add, kind=None), Var("v10"), Add, kind=None), If(Not(LE(Var("z"), Int(0))), Var("r"), App(Var("g"), [Neg(Var("z"), kind=None)])))}, App(Var("g"), [Int(1)])))}, LetRec({tyvars: [], name: ("main", Var({val: None})), args: [], body: Let(("t1", Var({val: None})), App(Var("print_int"), [App(Var("h"), [Tuple([Int(1), Int(2), Int(3), Int(4), Int(5), Int(6), Int(7), Int(8), Int(9), Int(10)])])]), Unit)}, Unit)) against Unit
// [Typer] typevars: []
// [Typer] check: LetTuple([("v1", Var({val: None})), ("v2", Var({val: None})), ("v3", Var({val: None})), ("v4", Var({val: None})), ("v5", Var({val: None})), ("v6", Var({val: None})), ("v7", Var({val: None})), ("v8", Var({val: None})), ("v9", Var({val: None})), ("v10", Var({val: None}))], Var("p"), LetRec({tyvars: [], name: ("g", Int), args: [("z", Int)], body: Let(("r", Var({val: None})), Prim(Prim(Prim(Prim(Prim(Prim(Prim(Prim(Prim(Var("v1"), Var("v2"), Add, kind=None), Var("v3"), Add, kind=None), Var("v4"), Add, kind=None), Var("v5"), Add, kind=None), Var("v6"), Add, kind=None), Var("v7"), Add, kind=None), Var("v8"), Add, kind=None), Var("v9"), Add, kind=None), Var("v10"), Add, kind=None), If(Not(LE(Var("z"), Int(0))), Var("r"), App(Var("g"), [Neg(Var("z"), kind=None)])))}, App(Var("g"), [Int(1)]))) against Int
// [Typer] infer: Var("p")
// [Typer] inst: TypeScheme(([], Tuple([Int, Int, Int, Int, Int, Int, Int, Int, Int, Int])))
// [Typer] inst result: Tuple([Int, Int, Int, Int, Int, Int, Int, Int, Int, Int])
// [Typer] unify: Var({val: None}) and Int
// [Typer] union: Var({val: None}) and Int
// [Typer] unify: Var({val: None}) and Int
// [Typer] union: Var({val: None}) and Int
// [Typer] unify: Var({val: None}) and Int
// [Typer] union: Var({val: None}) and Int
// [Typer] unify: Var({val: None}) and Int
// [Typer] union: Var({val: None}) and Int
// [Typer] unify: Var({val: None}) and Int
// [Typer] union: Var({val: None}) and Int
// [Typer] unify: Var({val: None}) and Int
// [Typer] union: Var({val: None}) and Int
// [Typer] unify: Var({val: None}) and Int
// [Typer] union: Var({val: None}) and Int
// [Typer] unify: Var({val: None}) and Int
// [Typer] union: Var({val: None}) and Int
// [Typer] unify: Var({val: None}) and Int
// [Typer] union: Var({val: None}) and Int
// [Typer] unify: Var({val: None}) and Int
// [Typer] union: Var({val: None}) and Int
// [Typer] check: LetRec({tyvars: [], name: ("g", Int), args: [("z", Int)], body: Let(("r", Var({val: None})), Prim(Prim(Prim(Prim(Prim(Prim(Prim(Prim(Prim(Var("v1"), Var("v2"), Add, kind=None), Var("v3"), Add, kind=None), Var("v4"), Add, kind=None), Var("v5"), Add, kind=None), Var("v6"), Add, kind=None), Var("v7"), Add, kind=None), Var("v8"), Add, kind=None), Var("v9"), Add, kind=None), Var("v10"), Add, kind=None), If(Not(LE(Var("z"), Int(0))), Var("r"), App(Var("g"), [Neg(Var("z"), kind=None)])))}, App(Var("g"), [Int(1)])) against Int
// [Typer] typevars: []
// [Typer] check: Let(("r", Var({val: None})), Prim(Prim(Prim(Prim(Prim(Prim(Prim(Prim(Prim(Var("v1"), Var("v2"), Add, kind=None), Var("v3"), Add, kind=None), Var("v4"), Add, kind=None), Var("v5"), Add, kind=None), Var("v6"), Add, kind=None), Var("v7"), Add, kind=None), Var("v8"), Add, kind=None), Var("v9"), Add, kind=None), Var("v10"), Add, kind=None), If(Not(LE(Var("z"), Int(0))), Var("r"), App(Var("g"), [Neg(Var("z"), kind=None)]))) against Int
// [Typer] infer: Prim(Prim(Prim(Prim(Prim(Prim(Prim(Prim(Prim(Var("v1"), Var("v2"), Add, kind=None), Var("v3"), Add, kind=None), Var("v4"), Add, kind=None), Var("v5"), Add, kind=None), Var("v6"), Add, kind=None), Var("v7"), Add, kind=None), Var("v8"), Add, kind=None), Var("v9"), Add, kind=None), Var("v10"), Add, kind=None)
// [Typer] infer: Prim(Prim(Prim(Prim(Prim(Prim(Prim(Prim(Var("v1"), Var("v2"), Add, kind=None), Var("v3"), Add, kind=None), Var("v4"), Add, kind=None), Var("v5"), Add, kind=None), Var("v6"), Add, kind=None), Var("v7"), Add, kind=None), Var("v8"), Add, kind=None), Var("v9"), Add, kind=None)
// [Typer] infer: Prim(Prim(Prim(Prim(Prim(Prim(Prim(Var("v1"), Var("v2"), Add, kind=None), Var("v3"), Add, kind=None), Var("v4"), Add, kind=None), Var("v5"), Add, kind=None), Var("v6"), Add, kind=None), Var("v7"), Add, kind=None), Var("v8"), Add, kind=None)
// [Typer] infer: Prim(Prim(Prim(Prim(Prim(Prim(Var("v1"), Var("v2"), Add, kind=None), Var("v3"), Add, kind=None), Var("v4"), Add, kind=None), Var("v5"), Add, kind=None), Var("v6"), Add, kind=None), Var("v7"), Add, kind=None)
// [Typer] infer: Prim(Prim(Prim(Prim(Prim(Var("v1"), Var("v2"), Add, kind=None), Var("v3"), Add, kind=None), Var("v4"), Add, kind=None), Var("v5"), Add, kind=None), Var("v6"), Add, kind=None)
// [Typer] infer: Prim(Prim(Prim(Prim(Var("v1"), Var("v2"), Add, kind=None), Var("v3"), Add, kind=None), Var("v4"), Add, kind=None), Var("v5"), Add, kind=None)
// [Typer] infer: Prim(Prim(Prim(Var("v1"), Var("v2"), Add, kind=None), Var("v3"), Add, kind=None), Var("v4"), Add, kind=None)
// [Typer] infer: Prim(Prim(Var("v1"), Var("v2"), Add, kind=None), Var("v3"), Add, kind=None)
// [Typer] infer: Prim(Var("v1"), Var("v2"), Add, kind=None)
// [Typer] infer: Var("v1")
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] infer: Var("v2")
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] infer: Var("v3")
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] infer: Var("v4")
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] infer: Var("v5")
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] infer: Var("v6")
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] infer: Var("v7")
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] infer: Var("v8")
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] infer: Var("v9")
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] infer: Var("v10")
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] unify: Var({val: None}) and Int
// [Typer] union: Var({val: None}) and Int
// [Typer] check: If(Not(LE(Var("z"), Int(0))), Var("r"), App(Var("g"), [Neg(Var("z"), kind=None)])) against Int
// [Typer] check: Not(LE(Var("z"), Int(0))) against Bool
// [Typer] check: LE(Var("z"), Int(0)) against Bool
// [Typer] infer: Var("z")
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] infer: Int(0)
// [Typer] unify: Int and Int
// [Typer] check: Var("r") against Int
// [Typer] inst: TypeScheme(([], Var({val: Some(Int)})))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] check: App(Var("g"), [Neg(Var("z"), kind=None)]) against Int
// [Typer] infer: Neg(Var("z"), kind=None)
// [Typer] infer: Var("z")
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] check: Var("g") against Fun([Int], Int)
// [Typer] inst: TypeScheme(([], Fun([Int], Int)))
// [Typer] inst result: Fun([Int], Int)
// [Typer] unify: Fun([Int], Int) and Fun([Int], Int)
// [Typer] unify: Int and Int
// [Typer] unify: Int and Int
// [Typer] check: App(Var("g"), [Int(1)]) against Int
// [Typer] infer: Int(1)
// [Typer] check: Var("g") against Fun([Int], Int)
// [Typer] inst: TypeScheme(([], Fun([Int], Int)))
// [Typer] inst result: Fun([Int], Int)
// [Typer] unify: Fun([Int], Int) and Fun([Int], Int)
// [Typer] unify: Int and Int
// [Typer] unify: Int and Int
// [Typer] check: LetRec({tyvars: [], name: ("main", Var({val: None})), args: [], body: Let(("t1", Var({val: None})), App(Var("print_int"), [App(Var("h"), [Tuple([Int(1), Int(2), Int(3), Int(4), Int(5), Int(6), Int(7), Int(8), Int(9), Int(10)])])]), Unit)}, Unit) against Unit
// [Typer] typevars: []
// [Typer] infer: Let(("t1", Var({val: None})), App(Var("print_int"), [App(Var("h"), [Tuple([Int(1), Int(2), Int(3), Int(4), Int(5), Int(6), Int(7), Int(8), Int(9), Int(10)])])]), Unit)
// [Typer] infer: App(Var("print_int"), [App(Var("h"), [Tuple([Int(1), Int(2), Int(3), Int(4), Int(5), Int(6), Int(7), Int(8), Int(9), Int(10)])])])
// [Typer] infer: Var("print_int")
// [Typer] inst: TypeScheme(([], Fun([Int], Unit)))
// [Typer] inst result: Fun([Int], Unit)
// [Typer] check: App(Var("h"), [Tuple([Int(1), Int(2), Int(3), Int(4), Int(5), Int(6), Int(7), Int(8), Int(9), Int(10)])]) against Int
// [Typer] infer: Tuple([Int(1), Int(2), Int(3), Int(4), Int(5), Int(6), Int(7), Int(8), Int(9), Int(10)])
// [Typer] infer: Int(1)
// [Typer] infer: Int(2)
// [Typer] infer: Int(3)
// [Typer] infer: Int(4)
// [Typer] infer: Int(5)
// [Typer] infer: Int(6)
// [Typer] infer: Int(7)
// [Typer] infer: Int(8)
// [Typer] infer: Int(9)
// [Typer] infer: Int(10)
// [Typer] check: Var("h") against Fun([Tuple([Int, Int, Int, Int, Int, Int, Int, Int, Int, Int])], Int)
// [Typer] inst: TypeScheme(([], Fun([Tuple([Int, Int, Int, Int, Int, Int, Int, Int, Int, Int])], Int)))
// [Typer] inst result: Fun([Tuple([Int, Int, Int, Int, Int, Int, Int, Int, Int, Int])], Int)
// [Typer] unify: Fun([Tuple([Int, Int, Int, Int, Int, Int, Int, Int, Int, Int])], Int) and Fun([Tuple([Int, Int, Int, Int, Int, Int, Int, Int, Int, Int])], Int)
// [Typer] unify: Tuple([Int, Int, Int, Int, Int, Int, Int, Int, Int, Int]) and Tuple([Int, Int, Int, Int, Int, Int, Int, Int, Int, Int])
// [Typer] unify: Int and Int
// [Typer] unify: Int and Int
// [Typer] unify: Int and Int
// [Typer] unify: Int and Int
// [Typer] unify: Int and Int
// [Typer] unify: Int and Int
// [Typer] unify: Int and Int
// [Typer] unify: Int and Int
// [Typer] unify: Int and Int
// [Typer] unify: Int and Int
// [Typer] unify: Int and Int
// [Typer] unify: Var({val: None}) and Unit
// [Typer] union: Var({val: None}) and Unit
// [Typer] infer: Unit
// [Typer] unify: Unit and Var({val: None})
// [Typer] union: Unit and Var({val: None})
// [Typer] check: Unit against Unit
// [Parser] flags: []
