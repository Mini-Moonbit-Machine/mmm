# name conventions used in the core ir:
# - functions: f<id>
# - blocks: b<id>
# - instructions: %<id>
# - memory: m<id>
# - free variables: ^<id>
# - function parameters: $f<pid>
# - block parameters: $b<bid>.<pid>
.core
.fn T$_50 #f10 : fn() -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: array[int32] = load_symbol ::2
    let %1: int32 = load_symbol ::3
    let %2: int32 = load_symbol ::4
    let %4: ptr = compute_address unit offset(0, %1 * @32)
    let _ = store int32 raw(%0, %4) <- %2
    return ()
  }
}
.fn main.66 #f42 : fn(array[int32], array[int32]) -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: array[int32] = load_symbol ::2
    let %1: int32 = load int32 field(%0, 0 * @32)
    let %2: unit = ext_call minimbt_print_int(%1)
    let %3: unit = ext_call minimbt_print_endline()
    let %4: array[int32] = load_symbol ::9
    let %5: int32 = load int32 field(%4, 0 * @32)
    let %6: unit = ext_call minimbt_print_int(%5)
    return ()
  }
}
.fn T$_24 #f40 : fn() -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    return ()
  }
}
.fn T$_16 #f26 : fn() -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    return ()
  }
}
.fn T$_10 #f16 : fn() -> int32
.freevars ()
.entry b0 {
  .bb #b0 () {
    return 0
  }
}
.fn T$_1 #f0 : fn() -> int32
.freevars ()
.entry b0 {
  .bb #b0 () {
    return 1
  }
}
.fn T$len.3 #f4 : fn() -> array[int32]
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: int32 = load_symbol ::0
    let %1: int32 = load_symbol ::1
    let _ = alloc <m0: array[int32] heap(%0)> <- [..] = %1
    return f4.m0
  }
}
.fn T$_58 #f22 : fn() -> int32
.freevars ()
.entry b0 {
  .bb #b0 () {
    return 2
  }
}
.fn T$_62 #f32 : fn() -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: array[int32] = load_symbol ::2
    let %1: int32 = load_symbol ::14
    let %2: int32 = load_symbol ::15
    let %4: ptr = compute_address unit offset(0, %1 * @32)
    let _ = store int32 raw(%0, %4) <- %2
    return ()
  }
}
.fn T$_57 #f20 : fn() -> int32
.freevars ()
.entry b0 {
  .bb #b0 () {
    return 0
  }
}
.fn T$_48 #f6 : fn() -> int32
.freevars ()
.entry b0 {
  .bb #b0 () {
    return 0
  }
}
.fn T$len2.11 #f18 : fn() -> array[int32]
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: int32 = load_symbol ::7
    let %1: int32 = load_symbol ::8
    let _ = alloc <m0: array[int32] heap(%0)> <- [..] = %1
    return f18.m0
  }
}
.fn T$_61 #f30 : fn() -> int32
.freevars ()
.entry b0 {
  .bb #b0 () {
    return 3
  }
}
.fn T$_8 #f12 : fn() -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    return ()
  }
}
.fn T$_9 #f14 : fn() -> int32
.freevars ()
.entry b0 {
  .bb #b0 () {
    return 1
  }
}
.fn T$_65 #f38 : fn() -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: array[int32] = load_symbol ::9
    let %1: int32 = load_symbol ::17
    let %2: int32 = load_symbol ::18
    let %4: ptr = compute_address unit offset(0, %1 * @32)
    let _ = store int32 raw(%0, %4) <- %2
    return ()
  }
}
.fn T$_59 #f24 : fn() -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: array[int32] = load_symbol ::9
    let %1: int32 = load_symbol ::10
    let %2: int32 = load_symbol ::11
    let %4: ptr = compute_address unit offset(0, %1 * @32)
    let _ = store int32 raw(%0, %4) <- %2
    return ()
  }
}
.fn T$_49 #f8 : fn() -> int32
.freevars ()
.entry b0 {
  .bb #b0 () {
    return 1
  }
}
.fn T$_64 #f36 : fn() -> int32
.freevars ()
.entry b0 {
  .bb #b0 () {
    return 4
  }
}
.fn T$_63 #f34 : fn() -> int32
.freevars ()
.entry b0 {
  .bb #b0 () {
    return 0
  }
}
.fn T$_2 #f2 : fn() -> int32
.freevars ()
.entry b0 {
  .bb #b0 () {
    return 0
  }
}
.fn T$_60 #f28 : fn() -> int32
.freevars ()
.entry b0 {
  .bb #b0 () {
    return 0
  }
}
.fn T$start #f44 : fn() -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: array[int32] = load_symbol ::2
    let %1: array[int32] = load_symbol ::9
    let %2: unit = call f42(%0, %1)
    return %2
  }
}
.thunk ::0 _1
.thunk ::1 _2
.thunk ::2 len.3
.thunk ::3 _48
.thunk ::4 _49
.thunk ::5 _50
.thunk ::6 _8
.thunk ::7 _9
.thunk ::8 _10
.thunk ::9 len2.11
.thunk ::10 _57
.thunk ::11 _58
.thunk ::12 _59
.thunk ::13 _16
.thunk ::14 _60
.thunk ::15 _61
.thunk ::16 _62
.thunk ::17 _63
.thunk ::18 _64
.thunk ::19 _65
.thunk ::20 _24
.thunk ::21 start
