let rec main.60: Var({val: Some(Unit)}) = () {
  let _61: Int = Int(40)
  let rec dbl.424: Double = (f.425: Double) {
    FAdd(f.425, f.425)
  }
  let rec yloop.426: Unit = (y.427: Int) {
    let join yloop.428: Unit = (y.429: Int) {
      if (_61 <= y.429) then {
        Unit
      } else {
        let rec xloop.430: Unit = (x.431: Int, y.432: Int) {
          let join xloop.433: Unit = (x.434: Int, y.435: Int) {
            if (_61 <= x.434) then {
              let _436: Unit = ExtApply(minimbt_print_endline, [])
              Unit
            } else {
              let _437: Double = ExtApply(minimbt_float_of_int, [x.434, ])
              let _438: Double = Apply(dbl.424, [_437, ])
              let _439: Double = ExtApply(minimbt_float_of_int, [_61, ])
              let _440: Double = FDiv(_438, _439)
              let _441: Double = Double(1.5)
              let cr.442: Double = FSub(_440, _441)
              let _443: Double = ExtApply(minimbt_float_of_int, [y.435, ])
              let _444: Double = Apply(dbl.424, [_443, ])
              let _445: Double = ExtApply(minimbt_float_of_int, [_61, ])
              let _446: Double = FDiv(_444, _445)
              let _447: Double = Double(1)
              let ci.448: Double = FSub(_446, _447)
              let rec iloop.449: Unit = (i.450: Int, zr.451: Double, zi.452: Double, zr2.453: Double, zi2.454: Double, cr.455: Double, ci.456: Double) {
                let join iloop.457: Unit = (i.458: Int, zr.459: Double, zi.460: Double, zr2.461: Double, zi2.462: Double, cr.463: Double, ci.464: Double) {
                  let _465: Int = Int(0)
                  if (i.458 == _465) then {
                    let _466: Int = Int(1)
                    ExtApply(minimbt_print_int, [_466, ])
                  } else {
                    let _467: Double = FSub(zr2.461, zi2.462)
                    let tr.468: Double = FAdd(_467, cr.463)
                    let _469: Double = Apply(dbl.424, [zr.459, ])
                    let _470: Double = FMul(_469, zi.460)
                    let ti.471: Double = FAdd(_470, ci.464)
                    let zr2.472: Double = FMul(tr.468, tr.468)
                    let zi2.473: Double = FMul(ti.471, ti.471)
                    let _474: Double = Double(2)
                    let _475: Double = Double(2)
                    let _476: Double = FMul(_474, _475)
                    let _477: Double = FAdd(zr2.472, zi2.473)
                    if (_476 <= _477) then {
                      let _478: Int = Int(0)
                      ExtApply(minimbt_print_int, [_478, ])
                    } else {
                      let _479: Int = Int(1)
                      let _480: Int = Sub(i.458, _479)
                      Jump(iloop.457, [_480, tr.468, ti.471, zr2.472, zi2.473, cr.463, ci.464, ])
                    }
                  }
                }
                Jump(iloop.457, [i.450, zr.451, zi.452, zr2.453, zi2.454, cr.455, ci.456, ])
              }
              let _481: Int = Int(1000)
              let _482: Double = Double(0)
              let _483: Double = Double(0)
              let _484: Double = Double(0)
              let _485: Double = Double(0)
              let _486: Unit = Apply(iloop.449, [_481, _482, _483, _484, _485, cr.442, ci.448, ])
              let _487: Int = Int(1)
              let _488: Int = Add(x.434, _487)
              Jump(xloop.433, [_488, y.435, ])
            }
          }
          Jump(xloop.433, [x.431, y.432, ])
        }
        let _489: Int = Int(0)
        let _490: Unit = Apply(xloop.430, [_489, y.429, ])
        let _491: Int = Int(1)
        let _492: Int = Add(y.429, _491)
        Jump(yloop.428, [_492, ])
      }
    }
    Jump(yloop.428, [y.427, ])
  }
  let _493: Int = Int(0)
  Apply(yloop.426, [_493, ])
}
Apply(main.60, [])let rec main.60: Var({val: Some(Unit)}) = () {
  let _61: Int = Int(40)
  let rec dbl.424: Double = (f.425: Double) {
    FAdd(f.425, f.425)
  }
  let _493: Int = Int(0)
  let join yloop.646: Unit = (y.647: Int) {
    if (_61 <= y.647) then {
      Unit
    } else {
      let rec xloop.648: Unit = (x.649: Int, y.650: Int) {
        let join xloop.651: Unit = (x.652: Int, y.653: Int) {
          if (_61 <= x.652) then {
            let _654: Unit = ExtApply(minimbt_print_endline, [])
            Unit
          } else {
            let _655: Double = ExtApply(minimbt_float_of_int, [x.652, ])
            let _656: Double = Apply(dbl.424, [_655, ])
            let _657: Double = ExtApply(minimbt_float_of_int, [_61, ])
            let _658: Double = FDiv(_656, _657)
            let _659: Double = Double(1.5)
            let cr.660: Double = FSub(_658, _659)
            let _661: Double = ExtApply(minimbt_float_of_int, [y.653, ])
            let _662: Double = Apply(dbl.424, [_661, ])
            let _663: Double = ExtApply(minimbt_float_of_int, [_61, ])
            let _664: Double = FDiv(_662, _663)
            let _665: Double = Double(1)
            let ci.666: Double = FSub(_664, _665)
            let rec iloop.667: Unit = (i.668: Int, zr.669: Double, zi.670: Double, zr2.671: Double, zi2.672: Double, cr.673: Double, ci.674: Double) {
              let join iloop.675: Unit = (i.676: Int, zr.677: Double, zi.678: Double, zr2.679: Double, zi2.680: Double, cr.681: Double, ci.682: Double) {
                let _683: Int = Int(0)
                if (i.676 == _683) then {
                  let _684: Int = Int(1)
                  ExtApply(minimbt_print_int, [_684, ])
                } else {
                  let _685: Double = FSub(zr2.679, zi2.680)
                  let tr.686: Double = FAdd(_685, cr.681)
                  let _687: Double = Apply(dbl.424, [zr.677, ])
                  let _688: Double = FMul(_687, zi.678)
                  let ti.689: Double = FAdd(_688, ci.682)
                  let zr2.690: Double = FMul(tr.686, tr.686)
                  let zi2.691: Double = FMul(ti.689, ti.689)
                  let _692: Double = Double(2)
                  let _693: Double = Double(2)
                  let _694: Double = FMul(_692, _693)
                  let _695: Double = FAdd(zr2.690, zi2.691)
                  if (_694 <= _695) then {
                    let _696: Int = Int(0)
                    ExtApply(minimbt_print_int, [_696, ])
                  } else {
                    let _697: Int = Int(1)
                    let _698: Int = Sub(i.676, _697)
                    Jump(iloop.675, [_698, tr.686, ti.689, zr2.690, zi2.691, cr.681, ci.682, ])
                  }
                }
              }
              Jump(iloop.675, [i.668, zr.669, zi.670, zr2.671, zi2.672, cr.673, ci.674, ])
            }
            let _699: Int = Int(1000)
            let _700: Double = Double(0)
            let _701: Double = Double(0)
            let _702: Double = Double(0)
            let _703: Double = Double(0)
            let _704: Unit = Apply(iloop.667, [_699, _700, _701, _702, _703, cr.660, ci.666, ])
            let _705: Int = Int(1)
            let _706: Int = Add(x.652, _705)
            Jump(xloop.651, [_706, y.653, ])
          }
        }
        Jump(xloop.651, [x.649, y.650, ])
      }
      let _707: Int = Int(0)
      let _708: Unit = Apply(xloop.648, [_707, y.647, ])
      let _709: Int = Int(1)
      let _710: Int = Add(y.647, _709)
      Jump(yloop.646, [_710, ])
    }
  }
  Jump(yloop.646, [_493, ])
}
Apply(main.60, [])