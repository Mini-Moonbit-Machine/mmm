// [Main] function thunk_main(k) {
// [Main]   function pow_1(x_3, n_5, k) {
// [Main]     const _6 = 0;
// [Main]     if (n_5 === _6) {
// [Main]       return $thunk(() => k(1))
// [Main]     } else {
// [Main]       const _7 = 1;
// [Main]       const _8 = n_5 - _7;
// [Main]       return $thunk(() => pow_1(x_3, _8, function (_9) {
// [Main]         return $thunk(() => k(x_3 * _9))
// [Main]       }
// [Main]       ))
// [Main]     }
// [Main]   }
// [Main]   function mod_10(x_12, n_14, k) {
// [Main]     const _15 = ~~(x_12 / n_14);
// [Main]     const _16 = _15 * n_14;
// [Main]     return $thunk(() => k(x_12 - _16))
// [Main]   }
// [Main]   function main_17(k) {
// [Main]     const _18 = 2;
// [Main]     const _19 = 2;
// [Main]     const _20 = 3;
// [Main]     return $thunk(() => pow_1(_19, _20, function (_21) {
// [Main]       return $thunk(() => pow_1(_18, _21, function (_22) {
// [Main]         return $thunk(() => $external(minimbt_print_int, function (_24) {
// [Main]           const _25 = 10;
// [Main]           return $thunk(() => $external(minimbt_print_char, function (_27) {
// [Main]             const _28 = 2;
// [Main]             const _29 = 2;
// [Main]             return $thunk(() => pow_1(_28, _29, function (_30) {
// [Main]               const _31 = 3;
// [Main]               return $thunk(() => pow_1(_30, _31, function (_32) {
// [Main]                 return $thunk(() => $external(minimbt_print_int, function (_34) {
// [Main]                   const _35 = 10;
// [Main]                   return $thunk(() => $external(minimbt_print_char, function (_37) {
// [Main]                     const _38 = 66434;
// [Main]                     const _39 = 100;
// [Main]                     return $thunk(() => mod_10(_38, _39, function (_40) {
// [Main]                       return $thunk(() => $external(minimbt_print_int, function (_42) {
// [Main]                         const _43 = 10;
// [Main]                         return $thunk(() => $external(minimbt_print_char, function (_45) {
// [Main]                           return $thunk(() => k(null))
// [Main]                         }
// [Main]                         , _43))
// [Main]                       }
// [Main]                       , _40))
// [Main]                     }
// [Main]                     ))
// [Main]                   }
// [Main]                   , _35))
// [Main]                 }
// [Main]                 , _32))
// [Main]               }
// [Main]               ))
// [Main]             }
// [Main]             ))
// [Main]           }
// [Main]           , _25))
// [Main]         }
// [Main]         , _22))
// [Main]       }
// [Main]       ))
// [Main]     }
// [Main]     ))
// [Main]   }
// [Main]   return $thunk(() => main_17(function (x) {
// [Main]     return $thunk(() => k(x))
// [Main]   }
// [Main]   ))
// [Main] }
// [Main] 
// [Main] function $thunk(lambda) {
// [Main]   return { thunk: lambda };
// [Main] }
// [Main] function $is_thunk(x) {
// [Main]   return x && x.hasOwnProperty('thunk') && x.thunk !== undefined;
// [Main] }
// [Main] function $force(x) {
// [Main]   while ($is_thunk(x)) {
// [Main]     x = x.thunk();
// [Main]   }
// [Main]   return x;
// [Main] }
// [Main] function $external(f, k, ...args) {
// [Main]   let x = f(...args);
// [Main]   return $thunk(() => k(x));
// [Main] }
// [Main] function $trampoline(f, ...args) {
// [Main]   let x = f(...args);
// [Main]   return $force(x);
// [Main] }
// [Main] export default () => $trampoline(thunk_main, x => x);
// [Typer] check: LetRec({tyvars: [], name: ("pow", Int), args: [("x", Int), ("n", Int)], body: If(Eq(Var("n"), Int(0)), Int(1), Prim(Var("x"), App(Var("pow"), [Var("x"), Prim(Var("n"), Int(1), Sub, kind=None)]), Mul, kind=None))}, LetRec({tyvars: [], name: ("mod", Int), args: [("x", Int), ("n", Int)], body: Prim(Var("x"), Prim(Prim(Var("x"), Var("n"), Div, kind=None), Var("n"), Mul, kind=None), Sub, kind=None)}, LetRec({tyvars: [], name: ("main", Var(None)), args: [], body: Let(("_", Var(None)), App(Var("print_int"), [App(Var("pow"), [Int(2), App(Var("pow"), [Int(2), Int(3)])])]), Let(("_", Var(None)), App(Var("print_char"), [Int(10)]), Let(("_", Var(None)), App(Var("print_int"), [App(Var("pow"), [App(Var("pow"), [Int(2), Int(2)]), Int(3)])]), Let(("_", Var(None)), App(Var("print_char"), [Int(10)]), Let(("_", Var(None)), App(Var("print_int"), [App(Var("mod"), [Int(66434), Int(100)])]), Let(("_", Var(None)), App(Var("print_char"), [Int(10)]), Unit))))))}, Unit))) against Unit
// [Typer] typevars: []
// [Typer] check: If(Eq(Var("n"), Int(0)), Int(1), Prim(Var("x"), App(Var("pow"), [Var("x"), Prim(Var("n"), Int(1), Sub, kind=None)]), Mul, kind=None)) against Int
// [Typer] check: Eq(Var("n"), Int(0)) against Bool
// [Typer] infer: Var("n")
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] infer: Int(0)
// [Typer] unify: Int and Int
// [Typer] check: Int(1) against Int
// [Typer] check: Prim(Var("x"), App(Var("pow"), [Var("x"), Prim(Var("n"), Int(1), Sub, kind=None)]), Mul, kind=None) against Int
// [Typer] check: Var("x") against Int
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] check: App(Var("pow"), [Var("x"), Prim(Var("n"), Int(1), Sub, kind=None)]) against Int
// [Typer] infer: Var("x")
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] infer: Prim(Var("n"), Int(1), Sub, kind=None)
// [Typer] infer: Var("n")
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] infer: Int(1)
// [Typer] unify: Int and Int
// [Typer] check: Var("pow") against (Int, Int) -> Int
// [Typer] inst: TypeScheme(([], (Int, Int) -> Int))
// [Typer] inst result: (Int, Int) -> Int
// [Typer] unify: (Int, Int) -> Int and (Int, Int) -> Int
// [Typer] unify: Int and Int
// [Typer] unify: Int and Int
// [Typer] unify: Int and Int
// [Typer] check: LetRec({tyvars: [], name: ("mod", Int), args: [("x", Int), ("n", Int)], body: Prim(Var("x"), Prim(Prim(Var("x"), Var("n"), Div, kind=None), Var("n"), Mul, kind=None), Sub, kind=None)}, LetRec({tyvars: [], name: ("main", Var(None)), args: [], body: Let(("_", Var(None)), App(Var("print_int"), [App(Var("pow"), [Int(2), App(Var("pow"), [Int(2), Int(3)])])]), Let(("_", Var(None)), App(Var("print_char"), [Int(10)]), Let(("_", Var(None)), App(Var("print_int"), [App(Var("pow"), [App(Var("pow"), [Int(2), Int(2)]), Int(3)])]), Let(("_", Var(None)), App(Var("print_char"), [Int(10)]), Let(("_", Var(None)), App(Var("print_int"), [App(Var("mod"), [Int(66434), Int(100)])]), Let(("_", Var(None)), App(Var("print_char"), [Int(10)]), Unit))))))}, Unit)) against Unit
// [Typer] typevars: []
// [Typer] check: Prim(Var("x"), Prim(Prim(Var("x"), Var("n"), Div, kind=None), Var("n"), Mul, kind=None), Sub, kind=None) against Int
// [Typer] check: Var("x") against Int
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] check: Prim(Prim(Var("x"), Var("n"), Div, kind=None), Var("n"), Mul, kind=None) against Int
// [Typer] check: Prim(Var("x"), Var("n"), Div, kind=None) against Int
// [Typer] check: Var("x") against Int
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] check: Var("n") against Int
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] check: Var("n") against Int
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] check: LetRec({tyvars: [], name: ("main", Var(None)), args: [], body: Let(("_", Var(None)), App(Var("print_int"), [App(Var("pow"), [Int(2), App(Var("pow"), [Int(2), Int(3)])])]), Let(("_", Var(None)), App(Var("print_char"), [Int(10)]), Let(("_", Var(None)), App(Var("print_int"), [App(Var("pow"), [App(Var("pow"), [Int(2), Int(2)]), Int(3)])]), Let(("_", Var(None)), App(Var("print_char"), [Int(10)]), Let(("_", Var(None)), App(Var("print_int"), [App(Var("mod"), [Int(66434), Int(100)])]), Let(("_", Var(None)), App(Var("print_char"), [Int(10)]), Unit))))))}, Unit) against Unit
// [Typer] typevars: []
// [Typer] infer: Let(("_", Var(None)), App(Var("print_int"), [App(Var("pow"), [Int(2), App(Var("pow"), [Int(2), Int(3)])])]), Let(("_", Var(None)), App(Var("print_char"), [Int(10)]), Let(("_", Var(None)), App(Var("print_int"), [App(Var("pow"), [App(Var("pow"), [Int(2), Int(2)]), Int(3)])]), Let(("_", Var(None)), App(Var("print_char"), [Int(10)]), Let(("_", Var(None)), App(Var("print_int"), [App(Var("mod"), [Int(66434), Int(100)])]), Let(("_", Var(None)), App(Var("print_char"), [Int(10)]), Unit))))))
// [Typer] infer: App(Var("print_int"), [App(Var("pow"), [Int(2), App(Var("pow"), [Int(2), Int(3)])])])
// [Typer] infer: Var("print_int")
// [Typer] inst: TypeScheme(([], (Int) -> Unit))
// [Typer] inst result: (Int) -> Unit
// [Typer] check: App(Var("pow"), [Int(2), App(Var("pow"), [Int(2), Int(3)])]) against Int
// [Typer] infer: Int(2)
// [Typer] infer: App(Var("pow"), [Int(2), Int(3)])
// [Typer] infer: Var("pow")
// [Typer] inst: TypeScheme(([], (Int, Int) -> Int))
// [Typer] inst result: (Int, Int) -> Int
// [Typer] check: Int(2) against Int
// [Typer] check: Int(3) against Int
// [Typer] check: Var("pow") against (Int, Int) -> Int
// [Typer] inst: TypeScheme(([], (Int, Int) -> Int))
// [Typer] inst result: (Int, Int) -> Int
// [Typer] unify: (Int, Int) -> Int and (Int, Int) -> Int
// [Typer] unify: Int and Int
// [Typer] unify: Int and Int
// [Typer] unify: Int and Int
// [Typer] unify: Var(None) and Unit
// [Typer] union: Var(None) and Unit
// [Typer] infer: Let(("_", Var(None)), App(Var("print_char"), [Int(10)]), Let(("_", Var(None)), App(Var("print_int"), [App(Var("pow"), [App(Var("pow"), [Int(2), Int(2)]), Int(3)])]), Let(("_", Var(None)), App(Var("print_char"), [Int(10)]), Let(("_", Var(None)), App(Var("print_int"), [App(Var("mod"), [Int(66434), Int(100)])]), Let(("_", Var(None)), App(Var("print_char"), [Int(10)]), Unit)))))
// [Typer] infer: App(Var("print_char"), [Int(10)])
// [Typer] infer: Var("print_char")
// [Typer] inst: TypeScheme(([], (Int) -> Unit))
// [Typer] inst result: (Int) -> Unit
// [Typer] check: Int(10) against Int
// [Typer] unify: Var(None) and Unit
// [Typer] union: Var(None) and Unit
// [Typer] infer: Let(("_", Var(None)), App(Var("print_int"), [App(Var("pow"), [App(Var("pow"), [Int(2), Int(2)]), Int(3)])]), Let(("_", Var(None)), App(Var("print_char"), [Int(10)]), Let(("_", Var(None)), App(Var("print_int"), [App(Var("mod"), [Int(66434), Int(100)])]), Let(("_", Var(None)), App(Var("print_char"), [Int(10)]), Unit))))
// [Typer] infer: App(Var("print_int"), [App(Var("pow"), [App(Var("pow"), [Int(2), Int(2)]), Int(3)])])
// [Typer] infer: Var("print_int")
// [Typer] inst: TypeScheme(([], (Int) -> Unit))
// [Typer] inst result: (Int) -> Unit
// [Typer] check: App(Var("pow"), [App(Var("pow"), [Int(2), Int(2)]), Int(3)]) against Int
// [Typer] infer: App(Var("pow"), [Int(2), Int(2)])
// [Typer] infer: Var("pow")
// [Typer] inst: TypeScheme(([], (Int, Int) -> Int))
// [Typer] inst result: (Int, Int) -> Int
// [Typer] check: Int(2) against Int
// [Typer] check: Int(2) against Int
// [Typer] infer: Int(3)
// [Typer] check: Var("pow") against (Int, Int) -> Int
// [Typer] inst: TypeScheme(([], (Int, Int) -> Int))
// [Typer] inst result: (Int, Int) -> Int
// [Typer] unify: (Int, Int) -> Int and (Int, Int) -> Int
// [Typer] unify: Int and Int
// [Typer] unify: Int and Int
// [Typer] unify: Int and Int
// [Typer] unify: Var(None) and Unit
// [Typer] union: Var(None) and Unit
// [Typer] infer: Let(("_", Var(None)), App(Var("print_char"), [Int(10)]), Let(("_", Var(None)), App(Var("print_int"), [App(Var("mod"), [Int(66434), Int(100)])]), Let(("_", Var(None)), App(Var("print_char"), [Int(10)]), Unit)))
// [Typer] infer: App(Var("print_char"), [Int(10)])
// [Typer] infer: Var("print_char")
// [Typer] inst: TypeScheme(([], (Int) -> Unit))
// [Typer] inst result: (Int) -> Unit
// [Typer] check: Int(10) against Int
// [Typer] unify: Var(None) and Unit
// [Typer] union: Var(None) and Unit
// [Typer] infer: Let(("_", Var(None)), App(Var("print_int"), [App(Var("mod"), [Int(66434), Int(100)])]), Let(("_", Var(None)), App(Var("print_char"), [Int(10)]), Unit))
// [Typer] infer: App(Var("print_int"), [App(Var("mod"), [Int(66434), Int(100)])])
// [Typer] infer: Var("print_int")
// [Typer] inst: TypeScheme(([], (Int) -> Unit))
// [Typer] inst result: (Int) -> Unit
// [Typer] check: App(Var("mod"), [Int(66434), Int(100)]) against Int
// [Typer] infer: Int(66434)
// [Typer] infer: Int(100)
// [Typer] check: Var("mod") against (Int, Int) -> Int
// [Typer] inst: TypeScheme(([], (Int, Int) -> Int))
// [Typer] inst result: (Int, Int) -> Int
// [Typer] unify: (Int, Int) -> Int and (Int, Int) -> Int
// [Typer] unify: Int and Int
// [Typer] unify: Int and Int
// [Typer] unify: Int and Int
// [Typer] unify: Var(None) and Unit
// [Typer] union: Var(None) and Unit
// [Typer] infer: Let(("_", Var(None)), App(Var("print_char"), [Int(10)]), Unit)
// [Typer] infer: App(Var("print_char"), [Int(10)])
// [Typer] infer: Var("print_char")
// [Typer] inst: TypeScheme(([], (Int) -> Unit))
// [Typer] inst result: (Int) -> Unit
// [Typer] check: Int(10) against Int
// [Typer] unify: Var(None) and Unit
// [Typer] union: Var(None) and Unit
// [Typer] infer: Unit
// [Typer] unify: Unit and Var(None)
// [Typer] union: Unit and Var(None)
// [Typer] check: Unit against Unit
// [Parser] flags: []
