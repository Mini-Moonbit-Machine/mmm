// [Main] function thunk_main(k) {
// [Main]   function main_1(k) {
// [Main]     const _2 = 12.3;
// [Main]     const _3 = -_2;
// [Main]     const _4 = minimbt_abs_float($force(_3));
// [Main]     const _5 = minimbt_sqrt($force(_4));
// [Main]     const _6 = minimbt_cos($force(_5));
// [Main]     const _7 = minimbt_sin($force(_6));
// [Main]     const _8 = 4.5;
// [Main]     const _9 = _7 + _8;
// [Main]     const _10 = 6.7;
// [Main]     const _11 = 8.9;
// [Main]     const _12 = _10 * _11;
// [Main]     const _13 = 1.23456789;
// [Main]     const _14 = _12 / _13;
// [Main]     const _15 = _9 - _14;
// [Main]     const _16 = 1000000;
// [Main]     const _17 = minimbt_float_of_int($force(_16));
// [Main]     const _18 = _15 * _17;
// [Main]     const _19 = minimbt_int_of_float($force(_18));
// [Main]     return k(minimbt_print_int($force(_19)))
// [Main]   }
// [Main]   return $thunk(() => main_1(k))
// [Main] }
// [Main] 
// [Main] function $thunk(lambda) {
// [Main]   return { thunk: lambda };
// [Main] }
// [Main] function $is_thunk(x) {
// [Main]   return x && x.hasOwnProperty('thunk') && x.thunk !== undefined;
// [Main] }
// [Main] function $force(x) {
// [Main]   while ($is_thunk(x)) {
// [Main]     x = x.thunk();
// [Main]   }
// [Main]   return x;
// [Main] }
// [Main] function $trampoline(f, ...args) {
// [Main]   let x = f(...args);
// [Main]   return $force(x);
// [Main] }
// [Main] export default () => $trampoline(thunk_main, x => x);
// [Typer] check: LetRec({tyvars: [], name: ("main", Var({val: None})), args: [], body: App(Var("print_int"), [App(Var("int_of_float"), [Prim(Prim(Prim(App(Var("sin"), [App(Var("cos"), [App(Var("sqrt"), [App(Var("abs_float"), [Neg(Double(12.3), kind=None)])])])]), Double(4.5), Add, kind=None), Prim(Prim(Double(6.7), Double(8.9), Mul, kind=None), Double(1.23456789), Div, kind=None), Sub, kind=None), App(Var("float_of_int"), [Int(1000000)]), Mul, kind=None)])])}, Unit) against Unit
// [Typer] typevars: []
// [Typer] infer: App(Var("print_int"), [App(Var("int_of_float"), [Prim(Prim(Prim(App(Var("sin"), [App(Var("cos"), [App(Var("sqrt"), [App(Var("abs_float"), [Neg(Double(12.3), kind=None)])])])]), Double(4.5), Add, kind=None), Prim(Prim(Double(6.7), Double(8.9), Mul, kind=None), Double(1.23456789), Div, kind=None), Sub, kind=None), App(Var("float_of_int"), [Int(1000000)]), Mul, kind=None)])])
// [Typer] infer: Var("print_int")
// [Typer] inst: TypeScheme(([], Fun([Int], Unit)))
// [Typer] inst result: Fun([Int], Unit)
// [Typer] check: App(Var("int_of_float"), [Prim(Prim(Prim(App(Var("sin"), [App(Var("cos"), [App(Var("sqrt"), [App(Var("abs_float"), [Neg(Double(12.3), kind=None)])])])]), Double(4.5), Add, kind=None), Prim(Prim(Double(6.7), Double(8.9), Mul, kind=None), Double(1.23456789), Div, kind=None), Sub, kind=None), App(Var("float_of_int"), [Int(1000000)]), Mul, kind=None)]) against Int
// [Typer] infer: Prim(Prim(Prim(App(Var("sin"), [App(Var("cos"), [App(Var("sqrt"), [App(Var("abs_float"), [Neg(Double(12.3), kind=None)])])])]), Double(4.5), Add, kind=None), Prim(Prim(Double(6.7), Double(8.9), Mul, kind=None), Double(1.23456789), Div, kind=None), Sub, kind=None), App(Var("float_of_int"), [Int(1000000)]), Mul, kind=None)
// [Typer] infer: Prim(Prim(App(Var("sin"), [App(Var("cos"), [App(Var("sqrt"), [App(Var("abs_float"), [Neg(Double(12.3), kind=None)])])])]), Double(4.5), Add, kind=None), Prim(Prim(Double(6.7), Double(8.9), Mul, kind=None), Double(1.23456789), Div, kind=None), Sub, kind=None)
// [Typer] infer: Prim(App(Var("sin"), [App(Var("cos"), [App(Var("sqrt"), [App(Var("abs_float"), [Neg(Double(12.3), kind=None)])])])]), Double(4.5), Add, kind=None)
// [Typer] infer: App(Var("sin"), [App(Var("cos"), [App(Var("sqrt"), [App(Var("abs_float"), [Neg(Double(12.3), kind=None)])])])])
// [Typer] infer: Var("sin")
// [Typer] inst: TypeScheme(([], Fun([Double], Double)))
// [Typer] inst result: Fun([Double], Double)
// [Typer] check: App(Var("cos"), [App(Var("sqrt"), [App(Var("abs_float"), [Neg(Double(12.3), kind=None)])])]) against Double
// [Typer] infer: App(Var("sqrt"), [App(Var("abs_float"), [Neg(Double(12.3), kind=None)])])
// [Typer] infer: Var("sqrt")
// [Typer] inst: TypeScheme(([], Fun([Double], Double)))
// [Typer] inst result: Fun([Double], Double)
// [Typer] check: App(Var("abs_float"), [Neg(Double(12.3), kind=None)]) against Double
// [Typer] infer: Neg(Double(12.3), kind=None)
// [Typer] infer: Double(12.3)
// [Typer] check: Var("abs_float") against Fun([Double], Double)
// [Typer] inst: TypeScheme(([], Fun([Double], Double)))
// [Typer] inst result: Fun([Double], Double)
// [Typer] unify: Fun([Double], Double) and Fun([Double], Double)
// [Typer] unify: Double and Double
// [Typer] unify: Double and Double
// [Typer] check: Var("cos") against Fun([Double], Double)
// [Typer] inst: TypeScheme(([], Fun([Double], Double)))
// [Typer] inst result: Fun([Double], Double)
// [Typer] unify: Fun([Double], Double) and Fun([Double], Double)
// [Typer] unify: Double and Double
// [Typer] unify: Double and Double
// [Typer] infer: Double(4.5)
// [Typer] unify: Double and Double
// [Typer] infer: Prim(Prim(Double(6.7), Double(8.9), Mul, kind=None), Double(1.23456789), Div, kind=None)
// [Typer] infer: Prim(Double(6.7), Double(8.9), Mul, kind=None)
// [Typer] infer: Double(6.7)
// [Typer] infer: Double(8.9)
// [Typer] unify: Double and Double
// [Typer] infer: Double(1.23456789)
// [Typer] unify: Double and Double
// [Typer] unify: Double and Double
// [Typer] infer: App(Var("float_of_int"), [Int(1000000)])
// [Typer] infer: Var("float_of_int")
// [Typer] inst: TypeScheme(([], Fun([Int], Double)))
// [Typer] inst result: Fun([Int], Double)
// [Typer] check: Int(1000000) against Int
// [Typer] unify: Double and Double
// [Typer] check: Var("int_of_float") against Fun([Double], Int)
// [Typer] inst: TypeScheme(([], Fun([Double], Int)))
// [Typer] inst result: Fun([Double], Int)
// [Typer] unify: Fun([Double], Int) and Fun([Double], Int)
// [Typer] unify: Double and Double
// [Typer] unify: Int and Int
// [Typer] unify: Unit and Var({val: None})
// [Typer] union: Unit and Var({val: None})
// [Typer] check: Unit against Unit
// [Parser] flags: []
