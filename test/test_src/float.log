// [Main] function thunk_main(k) {
// [Main]   function main_1(k) {
// [Main]     const _2 = 12.3;
// [Main]     const _3 = -_2;
// [Main]     return $thunk(() => $external(minimbt_abs_float, function (_4) {
// [Main]       return $thunk(() => $external(minimbt_sqrt, function (_5) {
// [Main]         return $thunk(() => $external(minimbt_cos, function (_6) {
// [Main]           return $thunk(() => $external(minimbt_sin, function (_7) {
// [Main]             const _8 = 4.5;
// [Main]             const _9 = _7 + _8;
// [Main]             const _10 = 6.7;
// [Main]             const _11 = 8.9;
// [Main]             const _12 = _10 * _11;
// [Main]             const _13 = 1.23456789;
// [Main]             const _14 = _12 / _13;
// [Main]             const _15 = _9 - _14;
// [Main]             const _16 = 1000000;
// [Main]             return $thunk(() => $external(minimbt_float_of_int, function (_17) {
// [Main]               const _18 = _15 * _17;
// [Main]               return $thunk(() => $external(minimbt_int_of_float, function (_19) {
// [Main]                 return $thunk(() => $external(minimbt_print_int, function (x) {
// [Main]                   return $thunk(() => k(x))
// [Main]                 }
// [Main]                 , _19))
// [Main]               }
// [Main]               , _18))
// [Main]             }
// [Main]             , _16))
// [Main]           }
// [Main]           , _6))
// [Main]         }
// [Main]         , _5))
// [Main]       }
// [Main]       , _4))
// [Main]     }
// [Main]     , _3))
// [Main]   }
// [Main]   return $thunk(() => main_1(function (x) {
// [Main]     return $thunk(() => k(x))
// [Main]   }
// [Main]   ))
// [Main] }
// [Main] 
// [Main] function $thunk(lambda) {
// [Main]   return { thunk: lambda };
// [Main] }
// [Main] function $is_thunk(x) {
// [Main]   return x && x.hasOwnProperty('thunk') && x.thunk !== undefined;
// [Main] }
// [Main] function $force(x) {
// [Main]   while ($is_thunk(x)) {
// [Main]     x = x.thunk();
// [Main]   }
// [Main]   return x;
// [Main] }
// [Main] function $external(f, k, ...args) {
// [Main]   let x = f(...args);
// [Main]   return $thunk(() => k(x));
// [Main] }
// [Main] function $trampoline(f, ...args) {
// [Main]   let x = f(...args);
// [Main]   return $force(x);
// [Main] }
// [Main] export default () => $trampoline(thunk_main, x => x);
// [Typer] check: LetRec({tyvars: [], name: ("main", Var(None)), args: [], body: App(Var("print_int"), [App(Var("int_of_float"), [Prim(Prim(Prim(App(Var("sin"), [App(Var("cos"), [App(Var("sqrt"), [App(Var("abs_float"), [Neg(Double(12.3), kind=None)])])])]), Double(4.5), Add, kind=None), Prim(Prim(Double(6.7), Double(8.9), Mul, kind=None), Double(1.23456789), Div, kind=None), Sub, kind=None), App(Var("float_of_int"), [Int(1000000)]), Mul, kind=None)])])}, Unit) against Unit
// [Typer] typevars: []
// [Typer] infer: App(Var("print_int"), [App(Var("int_of_float"), [Prim(Prim(Prim(App(Var("sin"), [App(Var("cos"), [App(Var("sqrt"), [App(Var("abs_float"), [Neg(Double(12.3), kind=None)])])])]), Double(4.5), Add, kind=None), Prim(Prim(Double(6.7), Double(8.9), Mul, kind=None), Double(1.23456789), Div, kind=None), Sub, kind=None), App(Var("float_of_int"), [Int(1000000)]), Mul, kind=None)])])
// [Typer] infer: Var("print_int")
// [Typer] inst: TypeScheme(([], (Int) -> Unit))
// [Typer] inst result: (Int) -> Unit
// [Typer] check: App(Var("int_of_float"), [Prim(Prim(Prim(App(Var("sin"), [App(Var("cos"), [App(Var("sqrt"), [App(Var("abs_float"), [Neg(Double(12.3), kind=None)])])])]), Double(4.5), Add, kind=None), Prim(Prim(Double(6.7), Double(8.9), Mul, kind=None), Double(1.23456789), Div, kind=None), Sub, kind=None), App(Var("float_of_int"), [Int(1000000)]), Mul, kind=None)]) against Int
// [Typer] infer: Prim(Prim(Prim(App(Var("sin"), [App(Var("cos"), [App(Var("sqrt"), [App(Var("abs_float"), [Neg(Double(12.3), kind=None)])])])]), Double(4.5), Add, kind=None), Prim(Prim(Double(6.7), Double(8.9), Mul, kind=None), Double(1.23456789), Div, kind=None), Sub, kind=None), App(Var("float_of_int"), [Int(1000000)]), Mul, kind=None)
// [Typer] infer: Prim(Prim(App(Var("sin"), [App(Var("cos"), [App(Var("sqrt"), [App(Var("abs_float"), [Neg(Double(12.3), kind=None)])])])]), Double(4.5), Add, kind=None), Prim(Prim(Double(6.7), Double(8.9), Mul, kind=None), Double(1.23456789), Div, kind=None), Sub, kind=None)
// [Typer] infer: Prim(App(Var("sin"), [App(Var("cos"), [App(Var("sqrt"), [App(Var("abs_float"), [Neg(Double(12.3), kind=None)])])])]), Double(4.5), Add, kind=None)
// [Typer] infer: App(Var("sin"), [App(Var("cos"), [App(Var("sqrt"), [App(Var("abs_float"), [Neg(Double(12.3), kind=None)])])])])
// [Typer] infer: Var("sin")
// [Typer] inst: TypeScheme(([], (Double) -> Double))
// [Typer] inst result: (Double) -> Double
// [Typer] check: App(Var("cos"), [App(Var("sqrt"), [App(Var("abs_float"), [Neg(Double(12.3), kind=None)])])]) against Double
// [Typer] infer: App(Var("sqrt"), [App(Var("abs_float"), [Neg(Double(12.3), kind=None)])])
// [Typer] infer: Var("sqrt")
// [Typer] inst: TypeScheme(([], (Double) -> Double))
// [Typer] inst result: (Double) -> Double
// [Typer] check: App(Var("abs_float"), [Neg(Double(12.3), kind=None)]) against Double
// [Typer] infer: Neg(Double(12.3), kind=None)
// [Typer] infer: Double(12.3)
// [Typer] check: Var("abs_float") against (Double) -> Double
// [Typer] inst: TypeScheme(([], (Double) -> Double))
// [Typer] inst result: (Double) -> Double
// [Typer] unify: (Double) -> Double and (Double) -> Double
// [Typer] unify: Double and Double
// [Typer] unify: Double and Double
// [Typer] check: Var("cos") against (Double) -> Double
// [Typer] inst: TypeScheme(([], (Double) -> Double))
// [Typer] inst result: (Double) -> Double
// [Typer] unify: (Double) -> Double and (Double) -> Double
// [Typer] unify: Double and Double
// [Typer] unify: Double and Double
// [Typer] infer: Double(4.5)
// [Typer] unify: Double and Double
// [Typer] infer: Prim(Prim(Double(6.7), Double(8.9), Mul, kind=None), Double(1.23456789), Div, kind=None)
// [Typer] infer: Prim(Double(6.7), Double(8.9), Mul, kind=None)
// [Typer] infer: Double(6.7)
// [Typer] infer: Double(8.9)
// [Typer] unify: Double and Double
// [Typer] infer: Double(1.23456789)
// [Typer] unify: Double and Double
// [Typer] unify: Double and Double
// [Typer] infer: App(Var("float_of_int"), [Int(1000000)])
// [Typer] infer: Var("float_of_int")
// [Typer] inst: TypeScheme(([], (Int) -> Double))
// [Typer] inst result: (Int) -> Double
// [Typer] check: Int(1000000) against Int
// [Typer] unify: Double and Double
// [Typer] check: Var("int_of_float") against (Double) -> Int
// [Typer] inst: TypeScheme(([], (Double) -> Int))
// [Typer] inst result: (Double) -> Int
// [Typer] unify: (Double) -> Int and (Double) -> Int
// [Typer] unify: Double and Double
// [Typer] unify: Int and Int
// [Typer] unify: Unit and Var(None)
// [Typer] union: Unit and Var(None)
// [Typer] check: Unit against Unit
// [Parser] flags: []
