let rec h: (p: (Int, Int, Int, Int, Int, Int, Int, Int, Int, Int)) -> Int {
  let (v1: Var(Int), v2: Var(Int), v3: Var(Int), v4: Var(Int), v5: Var(Int), v6: Var(Int), v7: Var(Int), v8: Var(Int), v9: Var(Int), v10: Var(Int)) = Var("p")
  let rec g: (z: Int) -> Int {
    let r: Var(Int) = Prim(Prim(Prim(Prim(Prim(Prim(Prim(Prim(Var("v1"), Var("v2"), Add, kind=Some(Int)), Var("v3"), Add, kind=Some(Int)), Var("v4"), Add, kind=Some(Int)), Var("v5"), Add, kind=Some(Int)), Var("v6"), Add, kind=Some(Int)), Var("v7"), Add, kind=Some(Int)), Var("v8"), Add, kind=Some(Int)), Var("v9"), Add, kind=Some(Int)) + Var("v10")
    if (Not(LE(Var("z"), Int(0)))) then {
      Var(r)
    } else {
      Apply(Var("g"), [Neg(Var("z"), kind=Some(Int)), ])
    }
  }
  Apply(Var("g"), [Int(1), ])
}
let rec main: () -> Var(Unit) {
  let t1: Var(Unit) = Apply(Var("print_int"), [App(Var("h"), [Tuple([Int(1), Int(2), Int(3), Int(4), Int(5), Int(6), Int(7), Int(8), Int(9), Int(10)])]), ])
  Unit
}
Unit
