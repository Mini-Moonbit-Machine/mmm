Testing test/test_src/ack.mbt
2045

Testing test/test_src/adder-double.mbt
3

Testing test/test_src/adder.mbt
10

Testing test/test_src/adder2.mbt
35

Testing test/test_src/adt.mbt
12345

Testing test/test_src/cls-bug.mbt
912

Testing test/test_src/cls-bug2.mbt
9876543210

Testing test/test_src/cls-rec-bug.mbt
1-1

Testing test/test_src/cls-rec.mbt
120

Testing test/test_src/cls-reg-bug.mbt
55

Testing test/test_src/critical_edge.mbt
2

Testing test/test_src/debug.mbt


Testing test/test_src/even-odd.mbt
456

Testing test/test_src/feature_test.mbt
3-12011

Testing test/test_src/fib.mbt
832040

Testing test/test_src/float.mbt
-44604263

Testing test/test_src/funcomp.mbt
247

Testing test/test_src/gcd.mbt
2700

Testing test/test_src/global_spill.mbt
120120120120120120120120120120

Testing test/test_src/htuple.mbt
12123234123

Testing test/test_src/id.mbt
10001000

Testing test/test_src/inprod-loop.mbt
16826400

Testing test/test_src/inprod-rec.mbt
16826400

Testing test/test_src/inprod.mbt
32000000

Testing test/test_src/int_min.mbt
-2147483648

Testing test/test_src/join-reg.mbt
912

Testing test/test_src/join-reg2.mbt
789

Testing test/test_src/join-stack.mbt
1037

Testing test/test_src/join-stack2.mbt
246

Testing test/test_src/join-stack3.mbt
912

Testing test/test_src/landins_knot.mbt
120130151

Testing test/test_src/mandelbrot.mbt
0000000000000000000000000000001000000000
0000000000000000000000000000000000000000
0000000000000000000000000000000000000000
0000000000000000000000000000100000000000
0000000000000000000000000011110000000000
0000000000000000000000000011110000000000
0000000000000000000000000011110000000000
0000000000000000000000000000000000000000
0000000000000000000010011111111110000000
0000000000000000000011111111111111011000
0000000000000000000011111111111111111000
0000000000000000000111111111111111110000
0000000000000000001111111111111111111000
0000000000000000011111111111111111111100
0000000000000000011111111111111111111100
0000000100100000111111111111111111111100
0000000111111100111111111111111111111100
0000001111111110111111111111111111111100
0000001111111110111111111111111111111100
0000101111111110111111111111111111111000
1111111111111111111111111111111111110000
0000101111111110111111111111111111111000
0000001111111110111111111111111111111100
0000001111111110111111111111111111111100
0000000111111100111111111111111111111100
0000000100100000111111111111111111111100
0000000000000000011111111111111111111100
0000000000000000011111111111111111111100
0000000000000000001111111111111111111000
0000000000000000000111111111111111110000
0000000000000000000011111111111111111000
0000000000000000000011111111111111011000
0000000000000000000010011111111110000000
0000000000000000000000000000000000000000
0000000000000000000000000011110000000000
0000000000000000000000000011110000000000
0000000000000000000000000011110000000000
0000000000000000000000000000100000000000
0000000000000000000000000000000000000000
0000000000000000000000000000000000000000


Testing test/test_src/match.mbt
4

Testing test/test_src/match2.mbt
// [log::Knf]
// [Knf] matcher_run: init mat
// [Knf] {arity: 1, occurs: {occurs: [/\]}, rows: [{binds: @immut/hashmap.of([]), patterns: [Tuple([Bool(true), Wildcard])], action: Int(1)}, {binds: @immut/hashmap.of([]), patterns: [Tuple([Wildcard, Bool(true)])], action: Int(2)}, {binds: @immut/hashmap.of([]), patterns: [Wildcard], action: Int(3)}]}
// [Knf] specialize_matrix: by subpat tuple(2), at col 0:
// [Knf] {arity: 2, occurs: {occurs: [/\.0, /\.1]}, rows: [{binds: @immut/hashmap.of([]), patterns: [Bool(true), Wildcard], action: Int(1)}, {binds: @immut/hashmap.of([]), patterns: [Wildcard, Bool(true)], action: Int(2)}, {binds: @immut/hashmap.of([]), patterns: [Wildcard, Wildcard], action: Int(3)}]}
// [Knf] specialize_matrix: by subpat bool(true), at col 0:
// [Knf] {arity: 1, occurs: {occurs: [/\.1]}, rows: [{binds: @immut/hashmap.of([]), patterns: [Wildcard], action: Int(1)}, {binds: @immut/hashmap.of([]), patterns: [Bool(true)], action: Int(2)}, {binds: @immut/hashmap.of([]), patterns: [Wildcard], action: Int(3)}]}
// [Knf] default_matrix:
// [Knf] {arity: 1, occurs: {occurs: [/\.1]}, rows: [{binds: @immut/hashmap.of([]), patterns: [Bool(true)], action: Int(2)}, {binds: @immut/hashmap.of([]), patterns: [Wildcard], action: Int(3)}]}
// [Knf] specialize_matrix: by subpat bool(true), at col 0:
// [Knf] {arity: 0, occurs: {occurs: []}, rows: [{binds: @immut/hashmap.of([]), patterns: [], action: Int(2)}, {binds: @immut/hashmap.of([]), patterns: [], action: Int(3)}]}
// [Knf] default_matrix:
// [Knf] {arity: 0, occurs: {occurs: []}, rows: [{binds: @immut/hashmap.of([]), patterns: [], action: Int(3)}]}
// [Knf] default_matrix:
// [Knf] {arity: 0, occurs: {occurs: []}, rows: [{binds: @immut/hashmap.of([]), patterns: [], action: Int(3)}]}
// [Knf] matcher_run: final tree
// [Knf] Switch(/\, 
// [Knf]   [(tuple(2), Switch(/\.0, 
// [Knf]     [(bool(true), Succeed({}, Int(1))),
// [Knf]     (fallback, Switch(/\.1, 
// [Knf]       [(bool(true), Succeed({}, Int(2))),
// [Knf]       (fallback, Succeed({}, Int(3)))
// [Knf]     ]))
// [Knf]   ])),
// [Knf]   (fallback, Succeed({}, Int(3)))
// [Knf] ])
// [Knf] decision_tree_to_knf: Switch(/\, 
// [Knf]   [(tuple(2), Switch(/\.0, 
// [Knf]     [(bool(true), Succeed({}, Int(1))),
// [Knf]     (fallback, Switch(/\.1, 
// [Knf]       [(bool(true), Succeed({}, Int(2))),
// [Knf]       (fallback, Succeed({}, Int(3)))
// [Knf]     ]))
// [Knf]   ])),
// [Knf]   (fallback, Succeed({}, Int(3)))
// [Knf] ])
// [Knf] decision_tree_to_knf: Switch(/\.0, 
// [Knf]   [(bool(true), Succeed({}, Int(1))),
// [Knf]   (fallback, Switch(/\.1, 
// [Knf]     [(bool(true), Succeed({}, Int(2))),
// [Knf]     (fallback, Succeed({}, Int(3)))
// [Knf]   ]))
// [Knf] ])
// [Knf] decision_tree_to_knf: Succeed({}, Int(1))
// [Knf] decision_tree_to_knf: Switch(/\.1, 
// [Knf]   [(bool(true), Succeed({}, Int(2))),
// [Knf]   (fallback, Succeed({}, Int(3)))
// [Knf] ])
// [Knf] decision_tree_to_knf: Succeed({}, Int(2))
// [Knf] decision_tree_to_knf: Succeed({}, Int(3))
// [Knf] matcher_run: init mat
// [Knf] {arity: 1, occurs: {occurs: [/\]}, rows: [{binds: @immut/hashmap.of([]), patterns: [Tuple([Bool(true), Wildcard, Wildcard])], action: Int(1)}, {binds: @immut/hashmap.of([]), patterns: [Tuple([Wildcard, Bool(true), Wildcard])], action: Int(2)}, {binds: @immut/hashmap.of([]), patterns: [Tuple([Wildcard, Wildcard, Bool(true)])], action: Int(3)}, {binds: @immut/hashmap.of([]), patterns: [Wildcard], action: Int(4)}]}
// [Knf] specialize_matrix: by subpat tuple(3), at col 0:
// [Knf] {arity: 3, occurs: {occurs: [/\.0, /\.1, /\.2]}, rows: [{binds: @immut/hashmap.of([]), patterns: [Bool(true), Wildcard, Wildcard], action: Int(1)}, {binds: @immut/hashmap.of([]), patterns: [Wildcard, Bool(true), Wildcard], action: Int(2)}, {binds: @immut/hashmap.of([]), patterns: [Wildcard, Wildcard, Bool(true)], action: Int(3)}, {binds: @immut/hashmap.of([]), patterns: [Wildcard, Wildcard, Wildcard], action: Int(4)}]}
// [Knf] specialize_matrix: by subpat bool(true), at col 0:
// [Knf] {arity: 2, occurs: {occurs: [/\.1, /\.2]}, rows: [{binds: @immut/hashmap.of([]), patterns: [Wildcard, Wildcard], action: Int(1)}, {binds: @immut/hashmap.of([]), patterns: [Bool(true), Wildcard], action: Int(2)}, {binds: @immut/hashmap.of([]), patterns: [Wildcard, Bool(true)], action: Int(3)}, {binds: @immut/hashmap.of([]), patterns: [Wildcard, Wildcard], action: Int(4)}]}
// [Knf] default_matrix:
// [Knf] {arity: 2, occurs: {occurs: [/\.1, /\.2]}, rows: [{binds: @immut/hashmap.of([]), patterns: [Bool(true), Wildcard], action: Int(2)}, {binds: @immut/hashmap.of([]), patterns: [Wildcard, Bool(true)], action: Int(3)}, {binds: @immut/hashmap.of([]), patterns: [Wildcard, Wildcard], action: Int(4)}]}
// [Knf] specialize_matrix: by subpat bool(true), at col 0:
// [Knf] {arity: 1, occurs: {occurs: [/\.2]}, rows: [{binds: @immut/hashmap.of([]), patterns: [Wildcard], action: Int(2)}, {binds: @immut/hashmap.of([]), patterns: [Bool(true)], action: Int(3)}, {binds: @immut/hashmap.of([]), patterns: [Wildcard], action: Int(4)}]}
// [Knf] default_matrix:
// [Knf] {arity: 1, occurs: {occurs: [/\.2]}, rows: [{binds: @immut/hashmap.of([]), patterns: [Bool(true)], action: Int(3)}, {binds: @immut/hashmap.of([]), patterns: [Wildcard], action: Int(4)}]}
// [Knf] specialize_matrix: by subpat bool(true), at col 0:
// [Knf] {arity: 0, occurs: {occurs: []}, rows: [{binds: @immut/hashmap.of([]), patterns: [], action: Int(3)}, {binds: @immut/hashmap.of([]), patterns: [], action: Int(4)}]}
// [Knf] default_matrix:
// [Knf] {arity: 0, occurs: {occurs: []}, rows: [{binds: @immut/hashmap.of([]), patterns: [], action: Int(4)}]}
// [Knf] default_matrix:
// [Knf] {arity: 0, occurs: {occurs: []}, rows: [{binds: @immut/hashmap.of([]), patterns: [], action: Int(4)}]}
// [Knf] matcher_run: final tree
// [Knf] Switch(/\, 
// [Knf]   [(tuple(3), Switch(/\.0, 
// [Knf]     [(bool(true), Succeed({}, Int(1))),
// [Knf]     (fallback, Switch(/\.1, 
// [Knf]       [(bool(true), Succeed({}, Int(2))),
// [Knf]       (fallback, Switch(/\.2, 
// [Knf]         [(bool(true), Succeed({}, Int(3))),
// [Knf]         (fallback, Succeed({}, Int(4)))
// [Knf]       ]))
// [Knf]     ]))
// [Knf]   ])),
// [Knf]   (fallback, Succeed({}, Int(4)))
// [Knf] ])
// [Knf] decision_tree_to_knf: Switch(/\, 
// [Knf]   [(tuple(3), Switch(/\.0, 
// [Knf]     [(bool(true), Succeed({}, Int(1))),
// [Knf]     (fallback, Switch(/\.1, 
// [Knf]       [(bool(true), Succeed({}, Int(2))),
// [Knf]       (fallback, Switch(/\.2, 
// [Knf]         [(bool(true), Succeed({}, Int(3))),
// [Knf]         (fallback, Succeed({}, Int(4)))
// [Knf]       ]))
// [Knf]     ]))
// [Knf]   ])),
// [Knf]   (fallback, Succeed({}, Int(4)))
// [Knf] ])
// [Knf] decision_tree_to_knf: Switch(/\.0, 
// [Knf]   [(bool(true), Succeed({}, Int(1))),
// [Knf]   (fallback, Switch(/\.1, 
// [Knf]     [(bool(true), Succeed({}, Int(2))),
// [Knf]     (fallback, Switch(/\.2, 
// [Knf]       [(bool(true), Succeed({}, Int(3))),
// [Knf]       (fallback, Succeed({}, Int(4)))
// [Knf]     ]))
// [Knf]   ]))
// [Knf] ])
// [Knf] decision_tree_to_knf: Succeed({}, Int(1))
// [Knf] decision_tree_to_knf: Switch(/\.1, 
// [Knf]   [(bool(true), Succeed({}, Int(2))),
// [Knf]   (fallback, Switch(/\.2, 
// [Knf]     [(bool(true), Succeed({}, Int(3))),
// [Knf]     (fallback, Succeed({}, Int(4)))
// [Knf]   ]))
// [Knf] ])
// [Knf] decision_tree_to_knf: Succeed({}, Int(2))
// [Knf] decision_tree_to_knf: Switch(/\.2, 
// [Knf]   [(bool(true), Succeed({}, Int(3))),
// [Knf]   (fallback, Succeed({}, Int(4)))
// [Knf] ])
// [Knf] decision_tree_to_knf: Succeed({}, Int(3))
// [Knf] decision_tree_to_knf: Succeed({}, Int(4))
// [Knf] matcher_run: init mat
// [Knf] {arity: 1, occurs: {occurs: [/\]}, rows: [{binds: @immut/hashmap.of([]), patterns: [Tuple([Int(1), Int(2), Int(3), Int(5)])], action: Int(1)}, {binds: @immut/hashmap.of([]), patterns: [Tuple([Int(1), Int(2), Int(3), Int(6)])], action: Int(2)}, {binds: @immut/hashmap.of([]), patterns: [Tuple([Int(1), Int(2), Int(3), Int(7)])], action: Int(3)}, {binds: @immut/hashmap.of([]), patterns: [Wildcard], action: Int(4)}]}
// [Knf] specialize_matrix: by subpat tuple(4), at col 0:
// [Knf] {arity: 4, occurs: {occurs: [/\.0, /\.1, /\.2, /\.3]}, rows: [{binds: @immut/hashmap.of([]), patterns: [Int(1), Int(2), Int(3), Int(5)], action: Int(1)}, {binds: @immut/hashmap.of([]), patterns: [Int(1), Int(2), Int(3), Int(6)], action: Int(2)}, {binds: @immut/hashmap.of([]), patterns: [Int(1), Int(2), Int(3), Int(7)], action: Int(3)}, {binds: @immut/hashmap.of([]), patterns: [Wildcard, Wildcard, Wildcard, Wildcard], action: Int(4)}]}
// [Knf] specialize_matrix: by subpat int(1), at col 0:
// [Knf] {arity: 3, occurs: {occurs: [/\.1, /\.2, /\.3]}, rows: [{binds: @immut/hashmap.of([]), patterns: [Int(2), Int(3), Int(5)], action: Int(1)}, {binds: @immut/hashmap.of([]), patterns: [Int(2), Int(3), Int(6)], action: Int(2)}, {binds: @immut/hashmap.of([]), patterns: [Int(2), Int(3), Int(7)], action: Int(3)}, {binds: @immut/hashmap.of([]), patterns: [Wildcard, Wildcard, Wildcard], action: Int(4)}]}
// [Knf] specialize_matrix: by subpat int(2), at col 0:
// [Knf] {arity: 2, occurs: {occurs: [/\.2, /\.3]}, rows: [{binds: @immut/hashmap.of([]), patterns: [Int(3), Int(5)], action: Int(1)}, {binds: @immut/hashmap.of([]), patterns: [Int(3), Int(6)], action: Int(2)}, {binds: @immut/hashmap.of([]), patterns: [Int(3), Int(7)], action: Int(3)}, {binds: @immut/hashmap.of([]), patterns: [Wildcard, Wildcard], action: Int(4)}]}
// [Knf] specialize_matrix: by subpat int(3), at col 0:
// [Knf] {arity: 1, occurs: {occurs: [/\.3]}, rows: [{binds: @immut/hashmap.of([]), patterns: [Int(5)], action: Int(1)}, {binds: @immut/hashmap.of([]), patterns: [Int(6)], action: Int(2)}, {binds: @immut/hashmap.of([]), patterns: [Int(7)], action: Int(3)}, {binds: @immut/hashmap.of([]), patterns: [Wildcard], action: Int(4)}]}
// [Knf] specialize_matrix: by subpat int(5), at col 0:
// [Knf] {arity: 0, occurs: {occurs: []}, rows: [{binds: @immut/hashmap.of([]), patterns: [], action: Int(1)}, {binds: @immut/hashmap.of([]), patterns: [], action: Int(4)}]}
// [Knf] specialize_matrix: by subpat int(6), at col 0:
// [Knf] {arity: 0, occurs: {occurs: []}, rows: [{binds: @immut/hashmap.of([]), patterns: [], action: Int(2)}, {binds: @immut/hashmap.of([]), patterns: [], action: Int(4)}]}
// [Knf] specialize_matrix: by subpat int(7), at col 0:
// [Knf] {arity: 0, occurs: {occurs: []}, rows: [{binds: @immut/hashmap.of([]), patterns: [], action: Int(3)}, {binds: @immut/hashmap.of([]), patterns: [], action: Int(4)}]}
// [Knf] default_matrix:
// [Knf] {arity: 0, occurs: {occurs: []}, rows: [{binds: @immut/hashmap.of([]), patterns: [], action: Int(4)}]}
// [Knf] default_matrix:
// [Knf] {arity: 1, occurs: {occurs: [/\.3]}, rows: [{binds: @immut/hashmap.of([]), patterns: [Wildcard], action: Int(4)}]}
// [Knf] default_matrix:
// [Knf] {arity: 2, occurs: {occurs: [/\.2, /\.3]}, rows: [{binds: @immut/hashmap.of([]), patterns: [Wildcard, Wildcard], action: Int(4)}]}
// [Knf] default_matrix:
// [Knf] {arity: 3, occurs: {occurs: [/\.1, /\.2, /\.3]}, rows: [{binds: @immut/hashmap.of([]), patterns: [Wildcard, Wildcard, Wildcard], action: Int(4)}]}
// [Knf] default_matrix:
// [Knf] {arity: 0, occurs: {occurs: []}, rows: [{binds: @immut/hashmap.of([]), patterns: [], action: Int(4)}]}
// [Knf] matcher_run: final tree
// [Knf] Switch(/\, 
// [Knf]   [(tuple(4), Switch(/\.0, 
// [Knf]     [(int(1), Switch(/\.1, 
// [Knf]       [(int(2), Switch(/\.2, 
// [Knf]         [(int(3), Switch(/\.3, 
// [Knf]           [(int(5), Succeed({}, Int(1))),
// [Knf]           (int(6), Succeed({}, Int(2))),
// [Knf]           (int(7), Succeed({}, Int(3))),
// [Knf]           (fallback, Succeed({}, Int(4)))
// [Knf]         ])),
// [Knf]         (fallback, Succeed({}, Int(4)))
// [Knf]       ])),
// [Knf]       (fallback, Succeed({}, Int(4)))
// [Knf]     ])),
// [Knf]     (fallback, Succeed({}, Int(4)))
// [Knf]   ])),
// [Knf]   (fallback, Succeed({}, Int(4)))
// [Knf] ])
// [Knf] decision_tree_to_knf: Switch(/\, 
// [Knf]   [(tuple(4), Switch(/\.0, 
// [Knf]     [(int(1), Switch(/\.1, 
// [Knf]       [(int(2), Switch(/\.2, 
// [Knf]         [(int(3), Switch(/\.3, 
// [Knf]           [(int(5), Succeed({}, Int(1))),
// [Knf]           (int(6), Succeed({}, Int(2))),
// [Knf]           (int(7), Succeed({}, Int(3))),
// [Knf]           (fallback, Succeed({}, Int(4)))
// [Knf]         ])),
// [Knf]         (fallback, Succeed({}, Int(4)))
// [Knf]       ])),
// [Knf]       (fallback, Succeed({}, Int(4)))
// [Knf]     ])),
// [Knf]     (fallback, Succeed({}, Int(4)))
// [Knf]   ])),
// [Knf]   (fallback, Succeed({}, Int(4)))
// [Knf] ])
// [Knf] decision_tree_to_knf: Switch(/\.0, 
// [Knf]   [(int(1), Switch(/\.1, 
// [Knf]     [(int(2), Switch(/\.2, 
// [Knf]       [(int(3), Switch(/\.3, 
// [Knf]         [(int(5), Succeed({}, Int(1))),
// [Knf]         (int(6), Succeed({}, Int(2))),
// [Knf]         (int(7), Succeed({}, Int(3))),
// [Knf]         (fallback, Succeed({}, Int(4)))
// [Knf]       ])),
// [Knf]       (fallback, Succeed({}, Int(4)))
// [Knf]     ])),
// [Knf]     (fallback, Succeed({}, Int(4)))
// [Knf]   ])),
// [Knf]   (fallback, Succeed({}, Int(4)))
// [Knf] ])
// [Knf] decision_tree_to_knf: Switch(/\.1, 
// [Knf]   [(int(2), Switch(/\.2, 
// [Knf]     [(int(3), Switch(/\.3, 
// [Knf]       [(int(5), Succeed({}, Int(1))),
// [Knf]       (int(6), Succeed({}, Int(2))),
// [Knf]       (int(7), Succeed({}, Int(3))),
// [Knf]       (fallback, Succeed({}, Int(4)))
// [Knf]     ])),
// [Knf]     (fallback, Succeed({}, Int(4)))
// [Knf]   ])),
// [Knf]   (fallback, Succeed({}, Int(4)))
// [Knf] ])
// [Knf] decision_tree_to_knf: Switch(/\.2, 
// [Knf]   [(int(3), Switch(/\.3, 
// [Knf]     [(int(5), Succeed({}, Int(1))),
// [Knf]     (int(6), Succeed({}, Int(2))),
// [Knf]     (int(7), Succeed({}, Int(3))),
// [Knf]     (fallback, Succeed({}, Int(4)))
// [Knf]   ])),
// [Knf]   (fallback, Succeed({}, Int(4)))
// [Knf] ])
// [Knf] decision_tree_to_knf: Switch(/\.3, 
// [Knf]   [(int(5), Succeed({}, Int(1))),
// [Knf]   (int(6), Succeed({}, Int(2))),
// [Knf]   (int(7), Succeed({}, Int(3))),
// [Knf]   (fallback, Succeed({}, Int(4)))
// [Knf] ])
// [Knf] decision_tree_to_knf: Succeed({}, Int(1))
// [Knf] decision_tree_to_knf: Succeed({}, Int(2))
// [Knf] decision_tree_to_knf: Succeed({}, Int(3))
// [Knf] decision_tree_to_knf: Succeed({}, Int(4))
// [Knf] decision_tree_to_knf: Succeed({}, Int(4))
// [Knf] decision_tree_to_knf: Succeed({}, Int(4))
// [Knf] decision_tree_to_knf: Succeed({}, Int(4))
// [Knf] matcher_run: init mat
// [Knf] {arity: 1, occurs: {occurs: [/\]}, rows: [{binds: @immut/hashmap.of([]), patterns: [CtorApp("A", [CtorApp("B", [Var("a"), Var("b")]), CtorApp("B", [Var("c"), Var("d")])])], action: Int(1)}, {binds: @immut/hashmap.of([]), patterns: [CtorApp("A", [CtorApp("C", []), CtorApp("B", [Var("a"), Var("b")])])], action: Int(2)}, {binds: @immut/hashmap.of([]), patterns: [CtorApp("A", [CtorApp("B", [Int(1), Int(3)]), CtorApp("C", [])])], action: Int(3)}, {binds: @immut/hashmap.of([]), patterns: [CtorApp("A", [CtorApp("B", [Var("a"), Var("b")]), CtorApp("C", [])])], action: Prim(Var("a"), Var("b"), Add, kind=Some(Int))}, {binds: @immut/hashmap.of([]), patterns: [CtorApp("B", [Wildcard, Wildcard])], action: Int(5)}, {binds: @immut/hashmap.of([]), patterns: [CtorApp("C", [])], action: Int(6)}]}
// [Knf] specialize_matrix: by subpat ctor(A, 2), at col 0:
// [Knf] {arity: 2, occurs: {occurs: [/\.0, /\.1]}, rows: [{binds: @immut/hashmap.of([]), patterns: [CtorApp("B", [Var("a"), Var("b")]), CtorApp("B", [Var("c"), Var("d")])], action: Int(1)}, {binds: @immut/hashmap.of([]), patterns: [CtorApp("C", []), CtorApp("B", [Var("a"), Var("b")])], action: Int(2)}, {binds: @immut/hashmap.of([]), patterns: [CtorApp("B", [Int(1), Int(3)]), CtorApp("C", [])], action: Int(3)}, {binds: @immut/hashmap.of([]), patterns: [CtorApp("B", [Var("a"), Var("b")]), CtorApp("C", [])], action: Prim(Var("a"), Var("b"), Add, kind=Some(Int))}]}
// [Knf] specialize_matrix: by subpat ctor(B, 2), at col 1:
// [Knf] {arity: 3, occurs: {occurs: [/\.0, /\.1.0, /\.1.1]}, rows: [{binds: @immut/hashmap.of([]), patterns: [CtorApp("B", [Var("a"), Var("b")]), Var("c"), Var("d")], action: Int(1)}, {binds: @immut/hashmap.of([]), patterns: [CtorApp("C", []), Var("a"), Var("b")], action: Int(2)}]}
// [Knf] specialize_matrix: by subpat ctor(B, 2), at col 0:
// [Knf] {arity: 4, occurs: {occurs: [/\.0.0, /\.0.1, /\.1.0, /\.1.1]}, rows: [{binds: @immut/hashmap.of([]), patterns: [Var("a"), Var("b"), Var("c"), Var("d")], action: Int(1)}]}
// [Knf] specialize_matrix: by subpat ctor(C, 0), at col 0:
// [Knf] {arity: 2, occurs: {occurs: [/\.1.0, /\.1.1]}, rows: [{binds: @immut/hashmap.of([]), patterns: [Var("a"), Var("b")], action: Int(2)}]}
// [Knf] default_matrix:
// [Knf] {arity: 2, occurs: {occurs: [/\.1.0, /\.1.1]}, rows: []}
// [Knf] specialize_matrix: by subpat ctor(C, 0), at col 1:
// [Knf] {arity: 1, occurs: {occurs: [/\.0]}, rows: [{binds: @immut/hashmap.of([]), patterns: [CtorApp("B", [Int(1), Int(3)])], action: Int(3)}, {binds: @immut/hashmap.of([]), patterns: [CtorApp("B", [Var("a"), Var("b")])], action: Prim(Var("a"), Var("b"), Add, kind=Some(Int))}]}
// [Knf] specialize_matrix: by subpat ctor(B, 2), at col 0:
// [Knf] {arity: 2, occurs: {occurs: [/\.0.0, /\.0.1]}, rows: [{binds: @immut/hashmap.of([]), patterns: [Int(1), Int(3)], action: Int(3)}, {binds: @immut/hashmap.of([]), patterns: [Var("a"), Var("b")], action: Prim(Var("a"), Var("b"), Add, kind=Some(Int))}]}
// [Knf] specialize_matrix: by subpat int(1), at col 0:
// [Knf] {arity: 1, occurs: {occurs: [/\.0.1]}, rows: [{binds: @immut/hashmap.of([]), patterns: [Int(3)], action: Int(3)}, {binds: @immut/hashmap.of([(/\.0.0, "a")]), patterns: [Var("b")], action: Prim(Var("a"), Var("b"), Add, kind=Some(Int))}]}
// [Knf] specialize_matrix: by subpat int(3), at col 0:
// [Knf] {arity: 0, occurs: {occurs: []}, rows: [{binds: @immut/hashmap.of([]), patterns: [], action: Int(3)}, {binds: @immut/hashmap.of([(/\.0.1, "b"), (/\.0.0, "a")]), patterns: [], action: Prim(Var("a"), Var("b"), Add, kind=Some(Int))}]}
// [Knf] default_matrix:
// [Knf] {arity: 0, occurs: {occurs: []}, rows: [{binds: @immut/hashmap.of([(/\.0.0, "a")]), patterns: [], action: Prim(Var("a"), Var("b"), Add, kind=Some(Int))}]}
// [Knf] default_matrix:
// [Knf] {arity: 1, occurs: {occurs: [/\.0.1]}, rows: [{binds: @immut/hashmap.of([]), patterns: [Var("b")], action: Prim(Var("a"), Var("b"), Add, kind=Some(Int))}]}
// [Knf] default_matrix:
// [Knf] {arity: 0, occurs: {occurs: []}, rows: []}
// [Knf] default_matrix:
// [Knf] {arity: 1, occurs: {occurs: [/\.0]}, rows: []}
// [Knf] specialize_matrix: by subpat ctor(B, 2), at col 0:
// [Knf] {arity: 2, occurs: {occurs: [/\.0, /\.1]}, rows: [{binds: @immut/hashmap.of([]), patterns: [Wildcard, Wildcard], action: Int(5)}]}
// [Knf] specialize_matrix: by subpat ctor(C, 0), at col 0:
// [Knf] {arity: 0, occurs: {occurs: []}, rows: [{binds: @immut/hashmap.of([]), patterns: [], action: Int(6)}]}
// [Knf] default_matrix:
// [Knf] {arity: 0, occurs: {occurs: []}, rows: []}
// [Knf] matcher_run: final tree
// [Knf] Switch(/\, 
// [Knf]   [(ctor(A, 2), Switch(/\.1, 
// [Knf]     [(ctor(B, 2), Switch(/\.0, 
// [Knf]       [(ctor(B, 2), Succeed({/\.0.1 -> b, /\.0.0 -> a, /\.1.1 -> d, /\.1.0 -> c, }, Int(1))),
// [Knf]       (ctor(C, 0), Succeed({/\.1.1 -> b, /\.1.0 -> a, }, Int(2))),
// [Knf]       
// [Knf]     ])),
// [Knf]     (ctor(C, 0), Switch(/\.0, 
// [Knf]       [(ctor(B, 2), Switch(/\.0.0, 
// [Knf]         [(int(1), Switch(/\.0.1, 
// [Knf]           [(int(3), Succeed({}, Int(3))),
// [Knf]           (fallback, Succeed({/\.0.0 -> a, }, Prim(Var("a"), Var("b"), Add, kind=Some(Int))))
// [Knf]         ])),
// [Knf]         (fallback, Succeed({/\.0.1 -> b, }, Prim(Var("a"), Var("b"), Add, kind=Some(Int))))
// [Knf]       ])),
// [Knf]       
// [Knf]     ])),
// [Knf]     
// [Knf]   ])),
// [Knf]   (ctor(B, 2), Succeed({}, Int(5))),
// [Knf]   (ctor(C, 0), Succeed({}, Int(6))),
// [Knf]   
// [Knf] ])
// [Knf] decision_tree_to_knf: Switch(/\, 
// [Knf]   [(ctor(A, 2), Switch(/\.1, 
// [Knf]     [(ctor(B, 2), Switch(/\.0, 
// [Knf]       [(ctor(B, 2), Succeed({/\.0.1 -> b, /\.0.0 -> a, /\.1.1 -> d, /\.1.0 -> c, }, Int(1))),
// [Knf]       (ctor(C, 0), Succeed({/\.1.1 -> b, /\.1.0 -> a, }, Int(2))),
// [Knf]       
// [Knf]     ])),
// [Knf]     (ctor(C, 0), Switch(/\.0, 
// [Knf]       [(ctor(B, 2), Switch(/\.0.0, 
// [Knf]         [(int(1), Switch(/\.0.1, 
// [Knf]           [(int(3), Succeed({}, Int(3))),
// [Knf]           (fallback, Succeed({/\.0.0 -> a, }, Prim(Var("a"), Var("b"), Add, kind=Some(Int))))
// [Knf]         ])),
// [Knf]         (fallback, Succeed({/\.0.1 -> b, }, Prim(Var("a"), Var("b"), Add, kind=Some(Int))))
// [Knf]       ])),
// [Knf]       
// [Knf]     ])),
// [Knf]     
// [Knf]   ])),
// [Knf]   (ctor(B, 2), Succeed({}, Int(5))),
// [Knf]   (ctor(C, 0), Succeed({}, Int(6))),
// [Knf]   
// [Knf] ])
// [Knf] decision_tree_to_knf: Switch(/\.1, 
// [Knf]   [(ctor(B, 2), Switch(/\.0, 
// [Knf]     [(ctor(B, 2), Succeed({/\.0.1 -> b, /\.0.0 -> a, /\.1.1 -> d, /\.1.0 -> c, }, Int(1))),
// [Knf]     (ctor(C, 0), Succeed({/\.1.1 -> b, /\.1.0 -> a, }, Int(2))),
// [Knf]     
// [Knf]   ])),
// [Knf]   (ctor(C, 0), Switch(/\.0, 
// [Knf]     [(ctor(B, 2), Switch(/\.0.0, 
// [Knf]       [(int(1), Switch(/\.0.1, 
// [Knf]         [(int(3), Succeed({}, Int(3))),
// [Knf]         (fallback, Succeed({/\.0.0 -> a, }, Prim(Var("a"), Var("b"), Add, kind=Some(Int))))
// [Knf]       ])),
// [Knf]       (fallback, Succeed({/\.0.1 -> b, }, Prim(Var("a"), Var("b"), Add, kind=Some(Int))))
// [Knf]     ])),
// [Knf]     
// [Knf]   ])),
// [Knf]   
// [Knf] ])
// [Knf] decision_tree_to_knf: Switch(/\.0, 
// [Knf]   [(ctor(B, 2), Succeed({/\.0.1 -> b, /\.0.0 -> a, /\.1.1 -> d, /\.1.0 -> c, }, Int(1))),
// [Knf]   (ctor(C, 0), Succeed({/\.1.1 -> b, /\.1.0 -> a, }, Int(2))),
// [Knf]   
// [Knf] ])
// [Knf] decision_tree_to_knf: Succeed({/\.0.1 -> b, /\.0.0 -> a, /\.1.1 -> d, /\.1.0 -> c, }, Int(1))
// [Knf] decision_tree_to_knf: Succeed({/\.1.1 -> b, /\.1.0 -> a, }, Int(2))
// [Knf] decision_tree_to_knf: Switch(/\.0, 
// [Knf]   [(ctor(B, 2), Switch(/\.0.0, 
// [Knf]     [(int(1), Switch(/\.0.1, 
// [Knf]       [(int(3), Succeed({}, Int(3))),
// [Knf]       (fallback, Succeed({/\.0.0 -> a, }, Prim(Var("a"), Var("b"), Add, kind=Some(Int))))
// [Knf]     ])),
// [Knf]     (fallback, Succeed({/\.0.1 -> b, }, Prim(Var("a"), Var("b"), Add, kind=Some(Int))))
// [Knf]   ])),
// [Knf]   
// [Knf] ])
// [Knf] decision_tree_to_knf: Switch(/\.0.0, 
// [Knf]   [(int(1), Switch(/\.0.1, 
// [Knf]     [(int(3), Succeed({}, Int(3))),
// [Knf]     (fallback, Succeed({/\.0.0 -> a, }, Prim(Var("a"), Var("b"), Add, kind=Some(Int))))
// [Knf]   ])),
// [Knf]   (fallback, Succeed({/\.0.1 -> b, }, Prim(Var("a"), Var("b"), Add, kind=Some(Int))))
// [Knf] ])
// [Knf] decision_tree_to_knf: Switch(/\.0.1, 
// [Knf]   [(int(3), Succeed({}, Int(3))),
// [Knf]   (fallback, Succeed({/\.0.0 -> a, }, Prim(Var("a"), Var("b"), Add, kind=Some(Int))))
// [Knf] ])
// [Knf] decision_tree_to_knf: Succeed({}, Int(3))
// [Knf] decision_tree_to_knf: Succeed({/\.0.0 -> a, }, Prim(Var("a"), Var("b"), Add, kind=Some(Int)))
// [log::Typer]
// [Typer] resolve: LetEnum("X", Enum X { A(X, X), B(Int, Int), C() }, LetRec({tyvars: [], name: ("main", Var(None)), args: [], body: Let(("i", Var(None)), Match(Tuple([Bool(true), Bool(false)]), [{pat: Tuple([Bool(true), Wildcard]), action: Int(1)}, {pat: Tuple([Wildcard, Bool(true)]), action: Int(2)}, {pat: Wildcard, action: Int(3)}]), Let(("j", Var(None)), Match(Tuple([LE(Var("i"), Int(1)), LE(Var("i"), Int(2)), LE(Var("i"), Int(3))]), [{pat: Tuple([Bool(true), Wildcard, Wildcard]), action: Int(1)}, {pat: Tuple([Wildcard, Bool(true), Wildcard]), action: Int(2)}, {pat: Tuple([Wildcard, Wildcard, Bool(true)]), action: Int(3)}, {pat: Wildcard, action: Int(4)}]), Let(("k", Var(None)), Match(Tuple([Var("j"), Prim(Var("j"), Int(1), Add, kind=None), Prim(Var("j"), Int(2), Add, kind=None), Prim(Var("j"), Int(3), Add, kind=None)]), [{pat: Tuple([Int(1), Int(2), Int(3), Int(5)]), action: Int(1)}, {pat: Tuple([Int(1), Int(2), Int(3), Int(6)]), action: Int(2)}, {pat: Tuple([Int(1), Int(2), Int(3), Int(7)]), action: Int(3)}, {pat: Wildcard, action: Int(4)}]), Let(("m", Var(None)), Match(CtorApp("A", [CtorApp("B", [Int(1), Int(2)]), CtorApp("C", [])]), [{pat: CtorApp("A", [CtorApp("B", [Var("a"), Var("b")]), CtorApp("B", [Var("c"), Var("d")])]), action: Int(1)}, {pat: CtorApp("A", [CtorApp("C", []), CtorApp("B", [Var("a"), Var("b")])]), action: Int(2)}, {pat: CtorApp("A", [CtorApp("B", [Int(1), Int(3)]), CtorApp("C", [])]), action: Int(3)}, {pat: CtorApp("A", [CtorApp("B", [Var("a"), Var("b")]), CtorApp("C", [])]), action: Prim(Var("a"), Var("b"), Add, kind=None)}, {pat: CtorApp("B", [Wildcard, Wildcard]), action: Int(5)}, {pat: CtorApp("C", []), action: Int(6)}]), Let(("_", Var(None)), App(Var("print_int"), targs=None, [Var("i")]), Let(("_", Var(None)), App(Var("print_int"), targs=None, [Var("j")]), Let(("_", Var(None)), App(Var("print_int"), targs=None, [Var("k")]), Let(("_", Var(None)), App(Var("print_int"), targs=None, [Var("m")]), Unit))))))))}, Unit))
// [Typer] resolve: LetRec({tyvars: [], name: ("main", Var(None)), args: [], body: Let(("i", Var(None)), Match(Tuple([Bool(true), Bool(false)]), [{pat: Tuple([Bool(true), Wildcard]), action: Int(1)}, {pat: Tuple([Wildcard, Bool(true)]), action: Int(2)}, {pat: Wildcard, action: Int(3)}]), Let(("j", Var(None)), Match(Tuple([LE(Var("i"), Int(1)), LE(Var("i"), Int(2)), LE(Var("i"), Int(3))]), [{pat: Tuple([Bool(true), Wildcard, Wildcard]), action: Int(1)}, {pat: Tuple([Wildcard, Bool(true), Wildcard]), action: Int(2)}, {pat: Tuple([Wildcard, Wildcard, Bool(true)]), action: Int(3)}, {pat: Wildcard, action: Int(4)}]), Let(("k", Var(None)), Match(Tuple([Var("j"), Prim(Var("j"), Int(1), Add, kind=None), Prim(Var("j"), Int(2), Add, kind=None), Prim(Var("j"), Int(3), Add, kind=None)]), [{pat: Tuple([Int(1), Int(2), Int(3), Int(5)]), action: Int(1)}, {pat: Tuple([Int(1), Int(2), Int(3), Int(6)]), action: Int(2)}, {pat: Tuple([Int(1), Int(2), Int(3), Int(7)]), action: Int(3)}, {pat: Wildcard, action: Int(4)}]), Let(("m", Var(None)), Match(CtorApp("A", [CtorApp("B", [Int(1), Int(2)]), CtorApp("C", [])]), [{pat: CtorApp("A", [CtorApp("B", [Var("a"), Var("b")]), CtorApp("B", [Var("c"), Var("d")])]), action: Int(1)}, {pat: CtorApp("A", [CtorApp("C", []), CtorApp("B", [Var("a"), Var("b")])]), action: Int(2)}, {pat: CtorApp("A", [CtorApp("B", [Int(1), Int(3)]), CtorApp("C", [])]), action: Int(3)}, {pat: CtorApp("A", [CtorApp("B", [Var("a"), Var("b")]), CtorApp("C", [])]), action: Prim(Var("a"), Var("b"), Add, kind=None)}, {pat: CtorApp("B", [Wildcard, Wildcard]), action: Int(5)}, {pat: CtorApp("C", []), action: Int(6)}]), Let(("_", Var(None)), App(Var("print_int"), targs=None, [Var("i")]), Let(("_", Var(None)), App(Var("print_int"), targs=None, [Var("j")]), Let(("_", Var(None)), App(Var("print_int"), targs=None, [Var("k")]), Let(("_", Var(None)), App(Var("print_int"), targs=None, [Var("m")]), Unit))))))))}, Unit)
// [Typer] resolve: Let(("i", Var(None)), Match(Tuple([Bool(true), Bool(false)]), [{pat: Tuple([Bool(true), Wildcard]), action: Int(1)}, {pat: Tuple([Wildcard, Bool(true)]), action: Int(2)}, {pat: Wildcard, action: Int(3)}]), Let(("j", Var(None)), Match(Tuple([LE(Var("i"), Int(1)), LE(Var("i"), Int(2)), LE(Var("i"), Int(3))]), [{pat: Tuple([Bool(true), Wildcard, Wildcard]), action: Int(1)}, {pat: Tuple([Wildcard, Bool(true), Wildcard]), action: Int(2)}, {pat: Tuple([Wildcard, Wildcard, Bool(true)]), action: Int(3)}, {pat: Wildcard, action: Int(4)}]), Let(("k", Var(None)), Match(Tuple([Var("j"), Prim(Var("j"), Int(1), Add, kind=None), Prim(Var("j"), Int(2), Add, kind=None), Prim(Var("j"), Int(3), Add, kind=None)]), [{pat: Tuple([Int(1), Int(2), Int(3), Int(5)]), action: Int(1)}, {pat: Tuple([Int(1), Int(2), Int(3), Int(6)]), action: Int(2)}, {pat: Tuple([Int(1), Int(2), Int(3), Int(7)]), action: Int(3)}, {pat: Wildcard, action: Int(4)}]), Let(("m", Var(None)), Match(CtorApp("A", [CtorApp("B", [Int(1), Int(2)]), CtorApp("C", [])]), [{pat: CtorApp("A", [CtorApp("B", [Var("a"), Var("b")]), CtorApp("B", [Var("c"), Var("d")])]), action: Int(1)}, {pat: CtorApp("A", [CtorApp("C", []), CtorApp("B", [Var("a"), Var("b")])]), action: Int(2)}, {pat: CtorApp("A", [CtorApp("B", [Int(1), Int(3)]), CtorApp("C", [])]), action: Int(3)}, {pat: CtorApp("A", [CtorApp("B", [Var("a"), Var("b")]), CtorApp("C", [])]), action: Prim(Var("a"), Var("b"), Add, kind=None)}, {pat: CtorApp("B", [Wildcard, Wildcard]), action: Int(5)}, {pat: CtorApp("C", []), action: Int(6)}]), Let(("_", Var(None)), App(Var("print_int"), targs=None, [Var("i")]), Let(("_", Var(None)), App(Var("print_int"), targs=None, [Var("j")]), Let(("_", Var(None)), App(Var("print_int"), targs=None, [Var("k")]), Let(("_", Var(None)), App(Var("print_int"), targs=None, [Var("m")]), Unit))))))))
// [Typer] resolve: Match(Tuple([Bool(true), Bool(false)]), [{pat: Tuple([Bool(true), Wildcard]), action: Int(1)}, {pat: Tuple([Wildcard, Bool(true)]), action: Int(2)}, {pat: Wildcard, action: Int(3)}])
// [Typer] resolve: Tuple([Bool(true), Bool(false)])
// [Typer] resolve: Int(1)
// [Typer] resolve: Int(2)
// [Typer] resolve: Int(3)
// [Typer] resolve: Let(("j", Var(None)), Match(Tuple([LE(Var("i"), Int(1)), LE(Var("i"), Int(2)), LE(Var("i"), Int(3))]), [{pat: Tuple([Bool(true), Wildcard, Wildcard]), action: Int(1)}, {pat: Tuple([Wildcard, Bool(true), Wildcard]), action: Int(2)}, {pat: Tuple([Wildcard, Wildcard, Bool(true)]), action: Int(3)}, {pat: Wildcard, action: Int(4)}]), Let(("k", Var(None)), Match(Tuple([Var("j"), Prim(Var("j"), Int(1), Add, kind=None), Prim(Var("j"), Int(2), Add, kind=None), Prim(Var("j"), Int(3), Add, kind=None)]), [{pat: Tuple([Int(1), Int(2), Int(3), Int(5)]), action: Int(1)}, {pat: Tuple([Int(1), Int(2), Int(3), Int(6)]), action: Int(2)}, {pat: Tuple([Int(1), Int(2), Int(3), Int(7)]), action: Int(3)}, {pat: Wildcard, action: Int(4)}]), Let(("m", Var(None)), Match(CtorApp("A", [CtorApp("B", [Int(1), Int(2)]), CtorApp("C", [])]), [{pat: CtorApp("A", [CtorApp("B", [Var("a"), Var("b")]), CtorApp("B", [Var("c"), Var("d")])]), action: Int(1)}, {pat: CtorApp("A", [CtorApp("C", []), CtorApp("B", [Var("a"), Var("b")])]), action: Int(2)}, {pat: CtorApp("A", [CtorApp("B", [Int(1), Int(3)]), CtorApp("C", [])]), action: Int(3)}, {pat: CtorApp("A", [CtorApp("B", [Var("a"), Var("b")]), CtorApp("C", [])]), action: Prim(Var("a"), Var("b"), Add, kind=None)}, {pat: CtorApp("B", [Wildcard, Wildcard]), action: Int(5)}, {pat: CtorApp("C", []), action: Int(6)}]), Let(("_", Var(None)), App(Var("print_int"), targs=None, [Var("i")]), Let(("_", Var(None)), App(Var("print_int"), targs=None, [Var("j")]), Let(("_", Var(None)), App(Var("print_int"), targs=None, [Var("k")]), Let(("_", Var(None)), App(Var("print_int"), targs=None, [Var("m")]), Unit)))))))
// [Typer] resolve: Match(Tuple([LE(Var("i"), Int(1)), LE(Var("i"), Int(2)), LE(Var("i"), Int(3))]), [{pat: Tuple([Bool(true), Wildcard, Wildcard]), action: Int(1)}, {pat: Tuple([Wildcard, Bool(true), Wildcard]), action: Int(2)}, {pat: Tuple([Wildcard, Wildcard, Bool(true)]), action: Int(3)}, {pat: Wildcard, action: Int(4)}])
// [Typer] resolve: Tuple([LE(Var("i"), Int(1)), LE(Var("i"), Int(2)), LE(Var("i"), Int(3))])
// [Typer] resolve: Int(1)
// [Typer] resolve: Int(2)
// [Typer] resolve: Int(3)
// [Typer] resolve: Int(4)
// [Typer] resolve: Let(("k", Var(None)), Match(Tuple([Var("j"), Prim(Var("j"), Int(1), Add, kind=None), Prim(Var("j"), Int(2), Add, kind=None), Prim(Var("j"), Int(3), Add, kind=None)]), [{pat: Tuple([Int(1), Int(2), Int(3), Int(5)]), action: Int(1)}, {pat: Tuple([Int(1), Int(2), Int(3), Int(6)]), action: Int(2)}, {pat: Tuple([Int(1), Int(2), Int(3), Int(7)]), action: Int(3)}, {pat: Wildcard, action: Int(4)}]), Let(("m", Var(None)), Match(CtorApp("A", [CtorApp("B", [Int(1), Int(2)]), CtorApp("C", [])]), [{pat: CtorApp("A", [CtorApp("B", [Var("a"), Var("b")]), CtorApp("B", [Var("c"), Var("d")])]), action: Int(1)}, {pat: CtorApp("A", [CtorApp("C", []), CtorApp("B", [Var("a"), Var("b")])]), action: Int(2)}, {pat: CtorApp("A", [CtorApp("B", [Int(1), Int(3)]), CtorApp("C", [])]), action: Int(3)}, {pat: CtorApp("A", [CtorApp("B", [Var("a"), Var("b")]), CtorApp("C", [])]), action: Prim(Var("a"), Var("b"), Add, kind=None)}, {pat: CtorApp("B", [Wildcard, Wildcard]), action: Int(5)}, {pat: CtorApp("C", []), action: Int(6)}]), Let(("_", Var(None)), App(Var("print_int"), targs=None, [Var("i")]), Let(("_", Var(None)), App(Var("print_int"), targs=None, [Var("j")]), Let(("_", Var(None)), App(Var("print_int"), targs=None, [Var("k")]), Let(("_", Var(None)), App(Var("print_int"), targs=None, [Var("m")]), Unit))))))
// [Typer] resolve: Match(Tuple([Var("j"), Prim(Var("j"), Int(1), Add, kind=None), Prim(Var("j"), Int(2), Add, kind=None), Prim(Var("j"), Int(3), Add, kind=None)]), [{pat: Tuple([Int(1), Int(2), Int(3), Int(5)]), action: Int(1)}, {pat: Tuple([Int(1), Int(2), Int(3), Int(6)]), action: Int(2)}, {pat: Tuple([Int(1), Int(2), Int(3), Int(7)]), action: Int(3)}, {pat: Wildcard, action: Int(4)}])
// [Typer] resolve: Tuple([Var("j"), Prim(Var("j"), Int(1), Add, kind=None), Prim(Var("j"), Int(2), Add, kind=None), Prim(Var("j"), Int(3), Add, kind=None)])
// [Typer] resolve: Int(1)
// [Typer] resolve: Int(2)
// [Typer] resolve: Int(3)
// [Typer] resolve: Int(4)
// [Typer] resolve: Let(("m", Var(None)), Match(CtorApp("A", [CtorApp("B", [Int(1), Int(2)]), CtorApp("C", [])]), [{pat: CtorApp("A", [CtorApp("B", [Var("a"), Var("b")]), CtorApp("B", [Var("c"), Var("d")])]), action: Int(1)}, {pat: CtorApp("A", [CtorApp("C", []), CtorApp("B", [Var("a"), Var("b")])]), action: Int(2)}, {pat: CtorApp("A", [CtorApp("B", [Int(1), Int(3)]), CtorApp("C", [])]), action: Int(3)}, {pat: CtorApp("A", [CtorApp("B", [Var("a"), Var("b")]), CtorApp("C", [])]), action: Prim(Var("a"), Var("b"), Add, kind=None)}, {pat: CtorApp("B", [Wildcard, Wildcard]), action: Int(5)}, {pat: CtorApp("C", []), action: Int(6)}]), Let(("_", Var(None)), App(Var("print_int"), targs=None, [Var("i")]), Let(("_", Var(None)), App(Var("print_int"), targs=None, [Var("j")]), Let(("_", Var(None)), App(Var("print_int"), targs=None, [Var("k")]), Let(("_", Var(None)), App(Var("print_int"), targs=None, [Var("m")]), Unit)))))
// [Typer] resolve: Match(CtorApp("A", [CtorApp("B", [Int(1), Int(2)]), CtorApp("C", [])]), [{pat: CtorApp("A", [CtorApp("B", [Var("a"), Var("b")]), CtorApp("B", [Var("c"), Var("d")])]), action: Int(1)}, {pat: CtorApp("A", [CtorApp("C", []), CtorApp("B", [Var("a"), Var("b")])]), action: Int(2)}, {pat: CtorApp("A", [CtorApp("B", [Int(1), Int(3)]), CtorApp("C", [])]), action: Int(3)}, {pat: CtorApp("A", [CtorApp("B", [Var("a"), Var("b")]), CtorApp("C", [])]), action: Prim(Var("a"), Var("b"), Add, kind=None)}, {pat: CtorApp("B", [Wildcard, Wildcard]), action: Int(5)}, {pat: CtorApp("C", []), action: Int(6)}])
// [Typer] resolve: CtorApp("A", [CtorApp("B", [Int(1), Int(2)]), CtorApp("C", [])])
// [Typer] resolve: CtorApp("B", [Int(1), Int(2)])
// [Typer] resolve: Int(1)
// [Typer] resolve: Int(2)
// [Typer] resolve: CtorApp("C", [])
// [Typer] resolve: Int(1)
// [Typer] resolve: Int(2)
// [Typer] resolve: Int(3)
// [Typer] resolve: Prim(Var("a"), Var("b"), Add, kind=None)
// [Typer] resolve: Var("a")
// [Typer] resolve: Var("b")
// [Typer] resolve: Int(5)
// [Typer] resolve: Int(6)
// [Typer] resolve: Let(("_", Var(None)), App(Var("print_int"), targs=None, [Var("i")]), Let(("_", Var(None)), App(Var("print_int"), targs=None, [Var("j")]), Let(("_", Var(None)), App(Var("print_int"), targs=None, [Var("k")]), Let(("_", Var(None)), App(Var("print_int"), targs=None, [Var("m")]), Unit))))
// [Typer] resolve: App(Var("print_int"), targs=None, [Var("i")])
// [Typer] resolve: Var("i")
// [Typer] resolve: Var("print_int")
// [Typer] resolve: Let(("_", Var(None)), App(Var("print_int"), targs=None, [Var("j")]), Let(("_", Var(None)), App(Var("print_int"), targs=None, [Var("k")]), Let(("_", Var(None)), App(Var("print_int"), targs=None, [Var("m")]), Unit)))
// [Typer] resolve: App(Var("print_int"), targs=None, [Var("j")])
// [Typer] resolve: Var("j")
// [Typer] resolve: Var("print_int")
// [Typer] resolve: Let(("_", Var(None)), App(Var("print_int"), targs=None, [Var("k")]), Let(("_", Var(None)), App(Var("print_int"), targs=None, [Var("m")]), Unit))
// [Typer] resolve: App(Var("print_int"), targs=None, [Var("k")])
// [Typer] resolve: Var("k")
// [Typer] resolve: Var("print_int")
// [Typer] resolve: Let(("_", Var(None)), App(Var("print_int"), targs=None, [Var("m")]), Unit)
// [Typer] resolve: App(Var("print_int"), targs=None, [Var("m")])
// [Typer] resolve: Var("m")
// [Typer] resolve: Var("print_int")
// [Typer] resolve: Unit
// [Typer] resolve: Unit
// [Typer] check: LetEnum("X", Enum X { A(~0, ~0), B(Int, Int), C() }, LetRec({tyvars: [], name: ("main", Var(None)), args: [], body: Let(("i", Var(None)), Match(Tuple([Bool(true), Bool(false)]), [{pat: Tuple([Bool(true), Wildcard]), action: Int(1)}, {pat: Tuple([Wildcard, Bool(true)]), action: Int(2)}, {pat: Wildcard, action: Int(3)}]), Let(("j", Var(None)), Match(Tuple([LE(Var("i"), Int(1)), LE(Var("i"), Int(2)), LE(Var("i"), Int(3))]), [{pat: Tuple([Bool(true), Wildcard, Wildcard]), action: Int(1)}, {pat: Tuple([Wildcard, Bool(true), Wildcard]), action: Int(2)}, {pat: Tuple([Wildcard, Wildcard, Bool(true)]), action: Int(3)}, {pat: Wildcard, action: Int(4)}]), Let(("k", Var(None)), Match(Tuple([Var("j"), Prim(Var("j"), Int(1), Add, kind=None), Prim(Var("j"), Int(2), Add, kind=None), Prim(Var("j"), Int(3), Add, kind=None)]), [{pat: Tuple([Int(1), Int(2), Int(3), Int(5)]), action: Int(1)}, {pat: Tuple([Int(1), Int(2), Int(3), Int(6)]), action: Int(2)}, {pat: Tuple([Int(1), Int(2), Int(3), Int(7)]), action: Int(3)}, {pat: Wildcard, action: Int(4)}]), Let(("m", Var(None)), Match(CtorApp("A", [CtorApp("B", [Int(1), Int(2)]), CtorApp("C", [])]), [{pat: CtorApp("A", [CtorApp("B", [Var("a"), Var("b")]), CtorApp("B", [Var("c"), Var("d")])]), action: Int(1)}, {pat: CtorApp("A", [CtorApp("C", []), CtorApp("B", [Var("a"), Var("b")])]), action: Int(2)}, {pat: CtorApp("A", [CtorApp("B", [Int(1), Int(3)]), CtorApp("C", [])]), action: Int(3)}, {pat: CtorApp("A", [CtorApp("B", [Var("a"), Var("b")]), CtorApp("C", [])]), action: Prim(Var("a"), Var("b"), Add, kind=None)}, {pat: CtorApp("B", [Wildcard, Wildcard]), action: Int(5)}, {pat: CtorApp("C", []), action: Int(6)}]), Let(("_", Var(None)), App(Var("print_int"), targs=None, [Var("i")]), Let(("_", Var(None)), App(Var("print_int"), targs=None, [Var("j")]), Let(("_", Var(None)), App(Var("print_int"), targs=None, [Var("k")]), Let(("_", Var(None)), App(Var("print_int"), targs=None, [Var("m")]), Unit))))))))}, Unit)) against Unit
// [Typer] check: LetRec({tyvars: [], name: ("main", Var(None)), args: [], body: Let(("i", Var(None)), Match(Tuple([Bool(true), Bool(false)]), [{pat: Tuple([Bool(true), Wildcard]), action: Int(1)}, {pat: Tuple([Wildcard, Bool(true)]), action: Int(2)}, {pat: Wildcard, action: Int(3)}]), Let(("j", Var(None)), Match(Tuple([LE(Var("i"), Int(1)), LE(Var("i"), Int(2)), LE(Var("i"), Int(3))]), [{pat: Tuple([Bool(true), Wildcard, Wildcard]), action: Int(1)}, {pat: Tuple([Wildcard, Bool(true), Wildcard]), action: Int(2)}, {pat: Tuple([Wildcard, Wildcard, Bool(true)]), action: Int(3)}, {pat: Wildcard, action: Int(4)}]), Let(("k", Var(None)), Match(Tuple([Var("j"), Prim(Var("j"), Int(1), Add, kind=None), Prim(Var("j"), Int(2), Add, kind=None), Prim(Var("j"), Int(3), Add, kind=None)]), [{pat: Tuple([Int(1), Int(2), Int(3), Int(5)]), action: Int(1)}, {pat: Tuple([Int(1), Int(2), Int(3), Int(6)]), action: Int(2)}, {pat: Tuple([Int(1), Int(2), Int(3), Int(7)]), action: Int(3)}, {pat: Wildcard, action: Int(4)}]), Let(("m", Var(None)), Match(CtorApp("A", [CtorApp("B", [Int(1), Int(2)]), CtorApp("C", [])]), [{pat: CtorApp("A", [CtorApp("B", [Var("a"), Var("b")]), CtorApp("B", [Var("c"), Var("d")])]), action: Int(1)}, {pat: CtorApp("A", [CtorApp("C", []), CtorApp("B", [Var("a"), Var("b")])]), action: Int(2)}, {pat: CtorApp("A", [CtorApp("B", [Int(1), Int(3)]), CtorApp("C", [])]), action: Int(3)}, {pat: CtorApp("A", [CtorApp("B", [Var("a"), Var("b")]), CtorApp("C", [])]), action: Prim(Var("a"), Var("b"), Add, kind=None)}, {pat: CtorApp("B", [Wildcard, Wildcard]), action: Int(5)}, {pat: CtorApp("C", []), action: Int(6)}]), Let(("_", Var(None)), App(Var("print_int"), targs=None, [Var("i")]), Let(("_", Var(None)), App(Var("print_int"), targs=None, [Var("j")]), Let(("_", Var(None)), App(Var("print_int"), targs=None, [Var("k")]), Let(("_", Var(None)), App(Var("print_int"), targs=None, [Var("m")]), Unit))))))))}, Unit) against Unit
// [Typer] typevars: []
// [Typer] infer: Let(("i", Var(None)), Match(Tuple([Bool(true), Bool(false)]), [{pat: Tuple([Bool(true), Wildcard]), action: Int(1)}, {pat: Tuple([Wildcard, Bool(true)]), action: Int(2)}, {pat: Wildcard, action: Int(3)}]), Let(("j", Var(None)), Match(Tuple([LE(Var("i"), Int(1)), LE(Var("i"), Int(2)), LE(Var("i"), Int(3))]), [{pat: Tuple([Bool(true), Wildcard, Wildcard]), action: Int(1)}, {pat: Tuple([Wildcard, Bool(true), Wildcard]), action: Int(2)}, {pat: Tuple([Wildcard, Wildcard, Bool(true)]), action: Int(3)}, {pat: Wildcard, action: Int(4)}]), Let(("k", Var(None)), Match(Tuple([Var("j"), Prim(Var("j"), Int(1), Add, kind=None), Prim(Var("j"), Int(2), Add, kind=None), Prim(Var("j"), Int(3), Add, kind=None)]), [{pat: Tuple([Int(1), Int(2), Int(3), Int(5)]), action: Int(1)}, {pat: Tuple([Int(1), Int(2), Int(3), Int(6)]), action: Int(2)}, {pat: Tuple([Int(1), Int(2), Int(3), Int(7)]), action: Int(3)}, {pat: Wildcard, action: Int(4)}]), Let(("m", Var(None)), Match(CtorApp("A", [CtorApp("B", [Int(1), Int(2)]), CtorApp("C", [])]), [{pat: CtorApp("A", [CtorApp("B", [Var("a"), Var("b")]), CtorApp("B", [Var("c"), Var("d")])]), action: Int(1)}, {pat: CtorApp("A", [CtorApp("C", []), CtorApp("B", [Var("a"), Var("b")])]), action: Int(2)}, {pat: CtorApp("A", [CtorApp("B", [Int(1), Int(3)]), CtorApp("C", [])]), action: Int(3)}, {pat: CtorApp("A", [CtorApp("B", [Var("a"), Var("b")]), CtorApp("C", [])]), action: Prim(Var("a"), Var("b"), Add, kind=None)}, {pat: CtorApp("B", [Wildcard, Wildcard]), action: Int(5)}, {pat: CtorApp("C", []), action: Int(6)}]), Let(("_", Var(None)), App(Var("print_int"), targs=None, [Var("i")]), Let(("_", Var(None)), App(Var("print_int"), targs=None, [Var("j")]), Let(("_", Var(None)), App(Var("print_int"), targs=None, [Var("k")]), Let(("_", Var(None)), App(Var("print_int"), targs=None, [Var("m")]), Unit))))))))
// [Typer] infer: Match(Tuple([Bool(true), Bool(false)]), [{pat: Tuple([Bool(true), Wildcard]), action: Int(1)}, {pat: Tuple([Wildcard, Bool(true)]), action: Int(2)}, {pat: Wildcard, action: Int(3)}])
// [Typer] infer: Tuple([Bool(true), Bool(false)])
// [Typer] infer: Bool(true)
// [Typer] infer: Bool(false)
// [Typer] unify: Bool and Bool
// [Typer] infer: Int(1)
// [Typer] unify: Bool and Bool
// [Typer] infer: Int(2)
// [Typer] infer: Int(3)
// [Typer] unify: Int and Int
// [Typer] unify: Int and Int
// [Typer] unify: Int and Int
// [Typer] unify: Var(None) and Int
// [Typer] union: Var(None) and Int
// [Typer] infer: Let(("j", Var(None)), Match(Tuple([LE(Var("i"), Int(1)), LE(Var("i"), Int(2)), LE(Var("i"), Int(3))]), [{pat: Tuple([Bool(true), Wildcard, Wildcard]), action: Int(1)}, {pat: Tuple([Wildcard, Bool(true), Wildcard]), action: Int(2)}, {pat: Tuple([Wildcard, Wildcard, Bool(true)]), action: Int(3)}, {pat: Wildcard, action: Int(4)}]), Let(("k", Var(None)), Match(Tuple([Var("j"), Prim(Var("j"), Int(1), Add, kind=None), Prim(Var("j"), Int(2), Add, kind=None), Prim(Var("j"), Int(3), Add, kind=None)]), [{pat: Tuple([Int(1), Int(2), Int(3), Int(5)]), action: Int(1)}, {pat: Tuple([Int(1), Int(2), Int(3), Int(6)]), action: Int(2)}, {pat: Tuple([Int(1), Int(2), Int(3), Int(7)]), action: Int(3)}, {pat: Wildcard, action: Int(4)}]), Let(("m", Var(None)), Match(CtorApp("A", [CtorApp("B", [Int(1), Int(2)]), CtorApp("C", [])]), [{pat: CtorApp("A", [CtorApp("B", [Var("a"), Var("b")]), CtorApp("B", [Var("c"), Var("d")])]), action: Int(1)}, {pat: CtorApp("A", [CtorApp("C", []), CtorApp("B", [Var("a"), Var("b")])]), action: Int(2)}, {pat: CtorApp("A", [CtorApp("B", [Int(1), Int(3)]), CtorApp("C", [])]), action: Int(3)}, {pat: CtorApp("A", [CtorApp("B", [Var("a"), Var("b")]), CtorApp("C", [])]), action: Prim(Var("a"), Var("b"), Add, kind=None)}, {pat: CtorApp("B", [Wildcard, Wildcard]), action: Int(5)}, {pat: CtorApp("C", []), action: Int(6)}]), Let(("_", Var(None)), App(Var("print_int"), targs=None, [Var("i")]), Let(("_", Var(None)), App(Var("print_int"), targs=None, [Var("j")]), Let(("_", Var(None)), App(Var("print_int"), targs=None, [Var("k")]), Let(("_", Var(None)), App(Var("print_int"), targs=None, [Var("m")]), Unit)))))))
// [Typer] infer: Match(Tuple([LE(Var("i"), Int(1)), LE(Var("i"), Int(2)), LE(Var("i"), Int(3))]), [{pat: Tuple([Bool(true), Wildcard, Wildcard]), action: Int(1)}, {pat: Tuple([Wildcard, Bool(true), Wildcard]), action: Int(2)}, {pat: Tuple([Wildcard, Wildcard, Bool(true)]), action: Int(3)}, {pat: Wildcard, action: Int(4)}])
// [Typer] infer: Tuple([LE(Var("i"), Int(1)), LE(Var("i"), Int(2)), LE(Var("i"), Int(3))])
// [Typer] infer: LE(Var("i"), Int(1))
// [Typer] infer: Var("i")
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] check: Int(1) against Int
// [Typer] infer: LE(Var("i"), Int(2))
// [Typer] infer: Var("i")
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] check: Int(2) against Int
// [Typer] infer: LE(Var("i"), Int(3))
// [Typer] infer: Var("i")
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] check: Int(3) against Int
// [Typer] unify: Bool and Bool
// [Typer] infer: Int(1)
// [Typer] unify: Bool and Bool
// [Typer] infer: Int(2)
// [Typer] unify: Bool and Bool
// [Typer] infer: Int(3)
// [Typer] infer: Int(4)
// [Typer] unify: Int and Int
// [Typer] unify: Int and Int
// [Typer] unify: Int and Int
// [Typer] unify: Int and Int
// [Typer] unify: Var(None) and Int
// [Typer] union: Var(None) and Int
// [Typer] infer: Let(("k", Var(None)), Match(Tuple([Var("j"), Prim(Var("j"), Int(1), Add, kind=None), Prim(Var("j"), Int(2), Add, kind=None), Prim(Var("j"), Int(3), Add, kind=None)]), [{pat: Tuple([Int(1), Int(2), Int(3), Int(5)]), action: Int(1)}, {pat: Tuple([Int(1), Int(2), Int(3), Int(6)]), action: Int(2)}, {pat: Tuple([Int(1), Int(2), Int(3), Int(7)]), action: Int(3)}, {pat: Wildcard, action: Int(4)}]), Let(("m", Var(None)), Match(CtorApp("A", [CtorApp("B", [Int(1), Int(2)]), CtorApp("C", [])]), [{pat: CtorApp("A", [CtorApp("B", [Var("a"), Var("b")]), CtorApp("B", [Var("c"), Var("d")])]), action: Int(1)}, {pat: CtorApp("A", [CtorApp("C", []), CtorApp("B", [Var("a"), Var("b")])]), action: Int(2)}, {pat: CtorApp("A", [CtorApp("B", [Int(1), Int(3)]), CtorApp("C", [])]), action: Int(3)}, {pat: CtorApp("A", [CtorApp("B", [Var("a"), Var("b")]), CtorApp("C", [])]), action: Prim(Var("a"), Var("b"), Add, kind=None)}, {pat: CtorApp("B", [Wildcard, Wildcard]), action: Int(5)}, {pat: CtorApp("C", []), action: Int(6)}]), Let(("_", Var(None)), App(Var("print_int"), targs=None, [Var("i")]), Let(("_", Var(None)), App(Var("print_int"), targs=None, [Var("j")]), Let(("_", Var(None)), App(Var("print_int"), targs=None, [Var("k")]), Let(("_", Var(None)), App(Var("print_int"), targs=None, [Var("m")]), Unit))))))
// [Typer] infer: Match(Tuple([Var("j"), Prim(Var("j"), Int(1), Add, kind=None), Prim(Var("j"), Int(2), Add, kind=None), Prim(Var("j"), Int(3), Add, kind=None)]), [{pat: Tuple([Int(1), Int(2), Int(3), Int(5)]), action: Int(1)}, {pat: Tuple([Int(1), Int(2), Int(3), Int(6)]), action: Int(2)}, {pat: Tuple([Int(1), Int(2), Int(3), Int(7)]), action: Int(3)}, {pat: Wildcard, action: Int(4)}])
// [Typer] infer: Tuple([Var("j"), Prim(Var("j"), Int(1), Add, kind=None), Prim(Var("j"), Int(2), Add, kind=None), Prim(Var("j"), Int(3), Add, kind=None)])
// [Typer] infer: Var("j")
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] infer: Prim(Var("j"), Int(1), Add, kind=None)
// [Typer] infer: Var("j")
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] infer: Int(1)
// [Typer] unify: Int and Int
// [Typer] infer: Prim(Var("j"), Int(2), Add, kind=None)
// [Typer] infer: Var("j")
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] infer: Int(2)
// [Typer] unify: Int and Int
// [Typer] infer: Prim(Var("j"), Int(3), Add, kind=None)
// [Typer] infer: Var("j")
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] infer: Int(3)
// [Typer] unify: Int and Int
// [Typer] unify: Int and Int
// [Typer] unify: Int and Int
// [Typer] unify: Int and Int
// [Typer] unify: Int and Int
// [Typer] infer: Int(1)
// [Typer] unify: Int and Int
// [Typer] unify: Int and Int
// [Typer] unify: Int and Int
// [Typer] unify: Int and Int
// [Typer] infer: Int(2)
// [Typer] unify: Int and Int
// [Typer] unify: Int and Int
// [Typer] unify: Int and Int
// [Typer] unify: Int and Int
// [Typer] infer: Int(3)
// [Typer] infer: Int(4)
// [Typer] unify: Int and Int
// [Typer] unify: Int and Int
// [Typer] unify: Int and Int
// [Typer] unify: Int and Int
// [Typer] unify: Var(None) and Int
// [Typer] union: Var(None) and Int
// [Typer] infer: Let(("m", Var(None)), Match(CtorApp("A", [CtorApp("B", [Int(1), Int(2)]), CtorApp("C", [])]), [{pat: CtorApp("A", [CtorApp("B", [Var("a"), Var("b")]), CtorApp("B", [Var("c"), Var("d")])]), action: Int(1)}, {pat: CtorApp("A", [CtorApp("C", []), CtorApp("B", [Var("a"), Var("b")])]), action: Int(2)}, {pat: CtorApp("A", [CtorApp("B", [Int(1), Int(3)]), CtorApp("C", [])]), action: Int(3)}, {pat: CtorApp("A", [CtorApp("B", [Var("a"), Var("b")]), CtorApp("C", [])]), action: Prim(Var("a"), Var("b"), Add, kind=None)}, {pat: CtorApp("B", [Wildcard, Wildcard]), action: Int(5)}, {pat: CtorApp("C", []), action: Int(6)}]), Let(("_", Var(None)), App(Var("print_int"), targs=None, [Var("i")]), Let(("_", Var(None)), App(Var("print_int"), targs=None, [Var("j")]), Let(("_", Var(None)), App(Var("print_int"), targs=None, [Var("k")]), Let(("_", Var(None)), App(Var("print_int"), targs=None, [Var("m")]), Unit)))))
// [Typer] infer: Match(CtorApp("A", [CtorApp("B", [Int(1), Int(2)]), CtorApp("C", [])]), [{pat: CtorApp("A", [CtorApp("B", [Var("a"), Var("b")]), CtorApp("B", [Var("c"), Var("d")])]), action: Int(1)}, {pat: CtorApp("A", [CtorApp("C", []), CtorApp("B", [Var("a"), Var("b")])]), action: Int(2)}, {pat: CtorApp("A", [CtorApp("B", [Int(1), Int(3)]), CtorApp("C", [])]), action: Int(3)}, {pat: CtorApp("A", [CtorApp("B", [Var("a"), Var("b")]), CtorApp("C", [])]), action: Prim(Var("a"), Var("b"), Add, kind=None)}, {pat: CtorApp("B", [Wildcard, Wildcard]), action: Int(5)}, {pat: CtorApp("C", []), action: Int(6)}])
// [Typer] infer: CtorApp("A", [CtorApp("B", [Int(1), Int(2)]), CtorApp("C", [])])
// [Typer] inst: TypeScheme(([], (Enum X { A(Enum X { A(~0, ~0), B(Int, Int), C() }, ~0), B(Int, Int), C() }, Enum X { A(~0, ~0), B(Int, Int), C() }) -> Enum X { A(~0, ~0), B(Int, Int), C() }))
// [Typer] inst result: (Enum X { A(Enum X { A(~0, ~0), B(Int, Int), C() }, ~0), B(Int, Int), C() }, Enum X { A(~0, ~0), B(Int, Int), C() }) -> Enum X { A(~0, ~0), B(Int, Int), C() }
// [Typer] check: CtorApp("B", [Int(1), Int(2)]) against Enum X { A(~0, ~0), B(Int, Int), C() }
// [Typer] infer: Int(1)
// [Typer] infer: Int(2)
// [Typer] inst: TypeScheme(([], (Int, Int) -> Enum X { A(Enum X { A(~0, ~0), B(Int, Int), C() }, ~0), B(Int, Int), C() }))
// [Typer] inst result: (Int, Int) -> Enum X { A(Enum X { A(~0, ~0), B(Int, Int), C() }, ~0), B(Int, Int), C() }
// [Typer] unify: (Int, Int) -> Enum X { A(Enum X { A(~0, ~0), B(Int, Int), C() }, ~0), B(Int, Int), C() } and (Int, Int) -> Enum X { A(Enum X { A(~0, ~0), B(Int, Int), C() }, ~0), B(Int, Int), C() }
// [Typer] unify: Int and Int
// [Typer] unify: Int and Int
// [Typer] unify: Enum X { A(~0, ~0), B(Int, Int), C() } and Enum X { A(~0, ~0), B(Int, Int), C() }
// [Typer] check: CtorApp("C", []) against Enum X { A(~0, ~0), B(Int, Int), C() }
// [Typer] inst: TypeScheme(([], () -> Enum X { A(Enum X { A(~0, ~0), B(Int, Int), C() }, ~0), B(Int, Int), C() }))
// [Typer] inst result: () -> Enum X { A(Enum X { A(~0, ~0), B(Int, Int), C() }, ~0), B(Int, Int), C() }
// [Typer] unify: () -> Enum X { A(Enum X { A(~0, ~0), B(Int, Int), C() }, ~0), B(Int, Int), C() } and () -> Enum X { A(Enum X { A(~0, ~0), B(Int, Int), C() }, ~0), B(Int, Int), C() }
// [Typer] unify: Enum X { A(~0, ~0), B(Int, Int), C() } and Enum X { A(~0, ~0), B(Int, Int), C() }
// [Typer] inst: TypeScheme(([], (Enum X { A(Enum X { A(~0, ~0), B(Int, Int), C() }, ~0), B(Int, Int), C() }, Enum X { A(~0, ~0), B(Int, Int), C() }) -> Enum X { A(~0, ~0), B(Int, Int), C() }))
// [Typer] inst result: (Enum X { A(Enum X { A(~0, ~0), B(Int, Int), C() }, ~0), B(Int, Int), C() }, Enum X { A(~0, ~0), B(Int, Int), C() }) -> Enum X { A(~0, ~0), B(Int, Int), C() }
// [Typer] unify: Enum X { A(~0, ~0), B(Int, Int), C() } and Enum X { A(~0, ~0), B(Int, Int), C() }
// [Typer] inst: TypeScheme(([], (Int, Int) -> Enum X { A(Enum X { A(~0, ~0), B(Int, Int), C() }, ~0), B(Int, Int), C() }))
// [Typer] inst result: (Int, Int) -> Enum X { A(Enum X { A(~0, ~0), B(Int, Int), C() }, ~0), B(Int, Int), C() }
// [Typer] unify: Enum X { A(~0, ~0), B(Int, Int), C() } and Enum X { A(~0, ~0), B(Int, Int), C() }
// [Typer] inst: TypeScheme(([], (Int, Int) -> Enum X { A(Enum X { A(~0, ~0), B(Int, Int), C() }, ~0), B(Int, Int), C() }))
// [Typer] inst result: (Int, Int) -> Enum X { A(Enum X { A(~0, ~0), B(Int, Int), C() }, ~0), B(Int, Int), C() }
// [Typer] unify: Enum X { A(~0, ~0), B(Int, Int), C() } and Enum X { A(~0, ~0), B(Int, Int), C() }
// [Typer] infer: Int(1)
// [Typer] inst: TypeScheme(([], (Enum X { A(Enum X { A(~0, ~0), B(Int, Int), C() }, ~0), B(Int, Int), C() }, Enum X { A(~0, ~0), B(Int, Int), C() }) -> Enum X { A(~0, ~0), B(Int, Int), C() }))
// [Typer] inst result: (Enum X { A(Enum X { A(~0, ~0), B(Int, Int), C() }, ~0), B(Int, Int), C() }, Enum X { A(~0, ~0), B(Int, Int), C() }) -> Enum X { A(~0, ~0), B(Int, Int), C() }
// [Typer] unify: Enum X { A(~0, ~0), B(Int, Int), C() } and Enum X { A(~0, ~0), B(Int, Int), C() }
// [Typer] inst: TypeScheme(([], () -> Enum X { A(Enum X { A(~0, ~0), B(Int, Int), C() }, ~0), B(Int, Int), C() }))
// [Typer] inst result: () -> Enum X { A(Enum X { A(~0, ~0), B(Int, Int), C() }, ~0), B(Int, Int), C() }
// [Typer] unify: Enum X { A(~0, ~0), B(Int, Int), C() } and Enum X { A(~0, ~0), B(Int, Int), C() }
// [Typer] inst: TypeScheme(([], (Int, Int) -> Enum X { A(Enum X { A(~0, ~0), B(Int, Int), C() }, ~0), B(Int, Int), C() }))
// [Typer] inst result: (Int, Int) -> Enum X { A(Enum X { A(~0, ~0), B(Int, Int), C() }, ~0), B(Int, Int), C() }
// [Typer] unify: Enum X { A(~0, ~0), B(Int, Int), C() } and Enum X { A(~0, ~0), B(Int, Int), C() }
// [Typer] infer: Int(2)
// [Typer] inst: TypeScheme(([], (Enum X { A(Enum X { A(~0, ~0), B(Int, Int), C() }, ~0), B(Int, Int), C() }, Enum X { A(~0, ~0), B(Int, Int), C() }) -> Enum X { A(~0, ~0), B(Int, Int), C() }))
// [Typer] inst result: (Enum X { A(Enum X { A(~0, ~0), B(Int, Int), C() }, ~0), B(Int, Int), C() }, Enum X { A(~0, ~0), B(Int, Int), C() }) -> Enum X { A(~0, ~0), B(Int, Int), C() }
// [Typer] unify: Enum X { A(~0, ~0), B(Int, Int), C() } and Enum X { A(~0, ~0), B(Int, Int), C() }
// [Typer] inst: TypeScheme(([], (Int, Int) -> Enum X { A(Enum X { A(~0, ~0), B(Int, Int), C() }, ~0), B(Int, Int), C() }))
// [Typer] inst result: (Int, Int) -> Enum X { A(Enum X { A(~0, ~0), B(Int, Int), C() }, ~0), B(Int, Int), C() }
// [Typer] unify: Enum X { A(~0, ~0), B(Int, Int), C() } and Enum X { A(~0, ~0), B(Int, Int), C() }
// [Typer] unify: Int and Int
// [Typer] unify: Int and Int
// [Typer] inst: TypeScheme(([], () -> Enum X { A(Enum X { A(~0, ~0), B(Int, Int), C() }, ~0), B(Int, Int), C() }))
// [Typer] inst result: () -> Enum X { A(Enum X { A(~0, ~0), B(Int, Int), C() }, ~0), B(Int, Int), C() }
// [Typer] unify: Enum X { A(~0, ~0), B(Int, Int), C() } and Enum X { A(~0, ~0), B(Int, Int), C() }
// [Typer] infer: Int(3)
// [Typer] inst: TypeScheme(([], (Enum X { A(Enum X { A(~0, ~0), B(Int, Int), C() }, ~0), B(Int, Int), C() }, Enum X { A(~0, ~0), B(Int, Int), C() }) -> Enum X { A(~0, ~0), B(Int, Int), C() }))
// [Typer] inst result: (Enum X { A(Enum X { A(~0, ~0), B(Int, Int), C() }, ~0), B(Int, Int), C() }, Enum X { A(~0, ~0), B(Int, Int), C() }) -> Enum X { A(~0, ~0), B(Int, Int), C() }
// [Typer] unify: Enum X { A(~0, ~0), B(Int, Int), C() } and Enum X { A(~0, ~0), B(Int, Int), C() }
// [Typer] inst: TypeScheme(([], (Int, Int) -> Enum X { A(Enum X { A(~0, ~0), B(Int, Int), C() }, ~0), B(Int, Int), C() }))
// [Typer] inst result: (Int, Int) -> Enum X { A(Enum X { A(~0, ~0), B(Int, Int), C() }, ~0), B(Int, Int), C() }
// [Typer] unify: Enum X { A(~0, ~0), B(Int, Int), C() } and Enum X { A(~0, ~0), B(Int, Int), C() }
// [Typer] inst: TypeScheme(([], () -> Enum X { A(Enum X { A(~0, ~0), B(Int, Int), C() }, ~0), B(Int, Int), C() }))
// [Typer] inst result: () -> Enum X { A(Enum X { A(~0, ~0), B(Int, Int), C() }, ~0), B(Int, Int), C() }
// [Typer] unify: Enum X { A(~0, ~0), B(Int, Int), C() } and Enum X { A(~0, ~0), B(Int, Int), C() }
// [Typer] infer: Prim(Var("a"), Var("b"), Add, kind=None)
// [Typer] infer: Var("a")
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] infer: Var("b")
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] inst: TypeScheme(([], (Int, Int) -> Enum X { A(Enum X { A(~0, ~0), B(Int, Int), C() }, ~0), B(Int, Int), C() }))
// [Typer] inst result: (Int, Int) -> Enum X { A(Enum X { A(~0, ~0), B(Int, Int), C() }, ~0), B(Int, Int), C() }
// [Typer] unify: Enum X { A(~0, ~0), B(Int, Int), C() } and Enum X { A(~0, ~0), B(Int, Int), C() }
// [Typer] infer: Int(5)
// [Typer] inst: TypeScheme(([], () -> Enum X { A(Enum X { A(~0, ~0), B(Int, Int), C() }, ~0), B(Int, Int), C() }))
// [Typer] inst result: () -> Enum X { A(Enum X { A(~0, ~0), B(Int, Int), C() }, ~0), B(Int, Int), C() }
// [Typer] unify: Enum X { A(~0, ~0), B(Int, Int), C() } and Enum X { A(~0, ~0), B(Int, Int), C() }
// [Typer] infer: Int(6)
// [Typer] unify: Int and Int
// [Typer] unify: Int and Int
// [Typer] unify: Int and Int
// [Typer] unify: Int and Int
// [Typer] unify: Int and Int
// [Typer] unify: Int and Int
// [Typer] unify: Var(None) and Int
// [Typer] union: Var(None) and Int
// [Typer] infer: Let(("_", Var(None)), App(Var("print_int"), targs=None, [Var("i")]), Let(("_", Var(None)), App(Var("print_int"), targs=None, [Var("j")]), Let(("_", Var(None)), App(Var("print_int"), targs=None, [Var("k")]), Let(("_", Var(None)), App(Var("print_int"), targs=None, [Var("m")]), Unit))))
// [Typer] infer: App(Var("print_int"), targs=None, [Var("i")])
// [Typer] inst: TypeScheme(([], (Int) -> Unit))
// [Typer] inst result: (Int) -> Unit
// [Typer] check: Var("i") against Int
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] unify: Var(None) and Unit
// [Typer] union: Var(None) and Unit
// [Typer] infer: Let(("_", Var(None)), App(Var("print_int"), targs=None, [Var("j")]), Let(("_", Var(None)), App(Var("print_int"), targs=None, [Var("k")]), Let(("_", Var(None)), App(Var("print_int"), targs=None, [Var("m")]), Unit)))
// [Typer] infer: App(Var("print_int"), targs=None, [Var("j")])
// [Typer] inst: TypeScheme(([], (Int) -> Unit))
// [Typer] inst result: (Int) -> Unit
// [Typer] check: Var("j") against Int
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] unify: Var(None) and Unit
// [Typer] union: Var(None) and Unit
// [Typer] infer: Let(("_", Var(None)), App(Var("print_int"), targs=None, [Var("k")]), Let(("_", Var(None)), App(Var("print_int"), targs=None, [Var("m")]), Unit))
// [Typer] infer: App(Var("print_int"), targs=None, [Var("k")])
// [Typer] inst: TypeScheme(([], (Int) -> Unit))
// [Typer] inst result: (Int) -> Unit
// [Typer] check: Var("k") against Int
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] unify: Var(None) and Unit
// [Typer] union: Var(None) and Unit
// [Typer] infer: Let(("_", Var(None)), App(Var("print_int"), targs=None, [Var("m")]), Unit)
// [Typer] infer: App(Var("print_int"), targs=None, [Var("m")])
// [Typer] inst: TypeScheme(([], (Int) -> Unit))
// [Typer] inst result: (Int) -> Unit
// [Typer] check: Var("m") against Int
// [Typer] inst: TypeScheme(([], Int))
// [Typer] inst result: Int
// [Typer] unify: Int and Int
// [Typer] unify: Var(None) and Unit
// [Typer] union: Var(None) and Unit
// [Typer] infer: Unit
// [Typer] unify: Unit and Var(None)
// [Typer] union: Unit and Var(None)
// [Typer] check: Unit against Unit
// [log::Parser]
// [Parser] flags: ["extension"]
// [record::typer]
enum X = Enum X { A(~0, ~0), B(Int, Int), C() }
let rec main: () -> Unit {
  let i: Int = Match(Tuple([Bool(true), Bool(false)]), [
    Tuple([Bool(true), Wildcard]) =>
      Int(1)
    Tuple([Wildcard, Bool(true)]) =>
      Int(2)
    Wildcard =>
      Int(3)
  ])
  let j: Int = Match(Tuple([LE(Var("i"), Int(1)), LE(Var("i"), Int(2)), LE(Var("i"), Int(3))]), [
    Tuple([Bool(true), Wildcard, Wildcard]) =>
      Int(1)
    Tuple([Wildcard, Bool(true), Wildcard]) =>
      Int(2)
    Tuple([Wildcard, Wildcard, Bool(true)]) =>
      Int(3)
    Wildcard =>
      Int(4)
  ])
  let k: Int = Match(Tuple([Var("j"), Prim(Var("j"), Int(1), Add, kind=Some(Int)), Prim(Var("j"), Int(2), Add, kind=Some(Int)), Prim(Var("j"), Int(3), Add, kind=Some(Int))]), [
    Tuple([Int(1), Int(2), Int(3), Int(5)]) =>
      Int(1)
    Tuple([Int(1), Int(2), Int(3), Int(6)]) =>
      Int(2)
    Tuple([Int(1), Int(2), Int(3), Int(7)]) =>
      Int(3)
    Wildcard =>
      Int(4)
  ])
  let m: Int = Match(CtorApp("A", [CtorApp("B", [Int(1), Int(2)]), CtorApp("C", [])]), [
    CtorApp("A", [CtorApp("B", [Var("a"), Var("b")]), CtorApp("B", [Var("c"), Var("d")])]) =>
      Int(1)
    CtorApp("A", [CtorApp("C", []), CtorApp("B", [Var("a"), Var("b")])]) =>
      Int(2)
    CtorApp("A", [CtorApp("B", [Int(1), Int(3)]), CtorApp("C", [])]) =>
      Int(3)
    CtorApp("A", [CtorApp("B", [Var("a"), Var("b")]), CtorApp("C", [])]) =>
      Var("a") + Var("b")
    CtorApp("B", [Wildcard, Wildcard]) =>
      Int(5)
    CtorApp("C", []) =>
      Int(6)
  ])
  let _: Unit = Apply[](Var("print_int"), [Var("i"), ])
  let _: Unit = Apply[](Var("print_int"), [Var("j"), ])
  let _: Unit = Apply[](Var("print_int"), [Var("k"), ])
  let _: Unit = Apply[](Var("print_int"), [Var("m"), ])
  Unit
}
Unit

// [record::resolved]
enum X = Enum X { A(~0, ~0), B(Int, Int), C() }
let rec main: () -> Var(None) {
  let i: Var(None) = Match(Tuple([Bool(true), Bool(false)]), [
    Tuple([Bool(true), Wildcard]) =>
      Int(1)
    Tuple([Wildcard, Bool(true)]) =>
      Int(2)
    Wildcard =>
      Int(3)
  ])
  let j: Var(None) = Match(Tuple([LE(Var("i"), Int(1)), LE(Var("i"), Int(2)), LE(Var("i"), Int(3))]), [
    Tuple([Bool(true), Wildcard, Wildcard]) =>
      Int(1)
    Tuple([Wildcard, Bool(true), Wildcard]) =>
      Int(2)
    Tuple([Wildcard, Wildcard, Bool(true)]) =>
      Int(3)
    Wildcard =>
      Int(4)
  ])
  let k: Var(None) = Match(Tuple([Var("j"), Prim(Var("j"), Int(1), Add, kind=None), Prim(Var("j"), Int(2), Add, kind=None), Prim(Var("j"), Int(3), Add, kind=None)]), [
    Tuple([Int(1), Int(2), Int(3), Int(5)]) =>
      Int(1)
    Tuple([Int(1), Int(2), Int(3), Int(6)]) =>
      Int(2)
    Tuple([Int(1), Int(2), Int(3), Int(7)]) =>
      Int(3)
    Wildcard =>
      Int(4)
  ])
  let m: Var(None) = Match(CtorApp("A", [CtorApp("B", [Int(1), Int(2)]), CtorApp("C", [])]), [
    CtorApp("A", [CtorApp("B", [Var("a"), Var("b")]), CtorApp("B", [Var("c"), Var("d")])]) =>
      Int(1)
    CtorApp("A", [CtorApp("C", []), CtorApp("B", [Var("a"), Var("b")])]) =>
      Int(2)
    CtorApp("A", [CtorApp("B", [Int(1), Int(3)]), CtorApp("C", [])]) =>
      Int(3)
    CtorApp("A", [CtorApp("B", [Var("a"), Var("b")]), CtorApp("C", [])]) =>
      Var("a") + Var("b")
    CtorApp("B", [Wildcard, Wildcard]) =>
      Int(5)
    CtorApp("C", []) =>
      Int(6)
  ])
  let _: Var(None) = Apply(Var("print_int"), [Var("i"), ])
  let _: Var(None) = Apply(Var("print_int"), [Var("j"), ])
  let _: Var(None) = Apply(Var("print_int"), [Var("k"), ])
  let _: Var(None) = Apply(Var("print_int"), [Var("m"), ])
  Unit
}
Unit

// [record::typer_simplified]
enum X = Enum X { A(~0, ~0), B(Int, Int), C() }
let rec main: () -> Unit {
  let i: Int = Match(Tuple([Bool(true), Bool(false)]), [
    Tuple([Bool(true), Wildcard]) =>
      Int(1)
    Tuple([Wildcard, Bool(true)]) =>
      Int(2)
    Wildcard =>
      Int(3)
  ])
  let j: Int = Match(Tuple([LE(Var("i"), Int(1)), LE(Var("i"), Int(2)), LE(Var("i"), Int(3))]), [
    Tuple([Bool(true), Wildcard, Wildcard]) =>
      Int(1)
    Tuple([Wildcard, Bool(true), Wildcard]) =>
      Int(2)
    Tuple([Wildcard, Wildcard, Bool(true)]) =>
      Int(3)
    Wildcard =>
      Int(4)
  ])
  let k: Int = Match(Tuple([Var("j"), Prim(Var("j"), Int(1), Add, kind=Some(Int)), Prim(Var("j"), Int(2), Add, kind=Some(Int)), Prim(Var("j"), Int(3), Add, kind=Some(Int))]), [
    Tuple([Int(1), Int(2), Int(3), Int(5)]) =>
      Int(1)
    Tuple([Int(1), Int(2), Int(3), Int(6)]) =>
      Int(2)
    Tuple([Int(1), Int(2), Int(3), Int(7)]) =>
      Int(3)
    Wildcard =>
      Int(4)
  ])
  let m: Int = Match(CtorApp("A", [CtorApp("B", [Int(1), Int(2)]), CtorApp("C", [])]), [
    CtorApp("A", [CtorApp("B", [Var("a"), Var("b")]), CtorApp("B", [Var("c"), Var("d")])]) =>
      Int(1)
    CtorApp("A", [CtorApp("C", []), CtorApp("B", [Var("a"), Var("b")])]) =>
      Int(2)
    CtorApp("A", [CtorApp("B", [Int(1), Int(3)]), CtorApp("C", [])]) =>
      Int(3)
    CtorApp("A", [CtorApp("B", [Var("a"), Var("b")]), CtorApp("C", [])]) =>
      Var("a") + Var("b")
    CtorApp("B", [Wildcard, Wildcard]) =>
      Int(5)
    CtorApp("C", []) =>
      Int(6)
  ])
  let _: Unit = Apply[](Var("print_int"), [Var("i"), ])
  let _: Unit = Apply[](Var("print_int"), [Var("j"), ])
  let _: Unit = Apply[](Var("print_int"), [Var("k"), ])
  let _: Unit = Apply[](Var("print_int"), [Var("m"), ])
  Unit
}
Unit

RuntimeError: unreachable
    at wasm://wasm/002c5f1e:wasm-function[3329]:0x465b7
    at wasm://wasm/002c5f1e:wasm-function[4615]:0x9bb01
    at wasm://wasm/002c5f1e:wasm-function[4664]:0x9e09d
error: failed to run


Testing test/test_src/matmul-flat.mbt
58
64
139
154

Testing test/test_src/matmul.mbt
58
64
139
154

Testing test/test_src/min.mbt
0

Testing test/test_src/multiple-init.mbt
3
4

Testing test/test_src/non-tail-if.mbt
-10

Testing test/test_src/non-tail-if2.mbt
80238

Testing test/test_src/print.mbt
123-456789

Testing test/test_src/read.mbt
// [log::Parser]
// [Parser] flags: ["has_read"]
This test file contains read and cannot be tested
RuntimeError: unreachable
    at wasm://wasm/002c5f1e:wasm-function[3350]:0x468a4
    at wasm://wasm/002c5f1e:wasm-function[4664]:0x9e112
error: failed to run


Testing test/test_src/shuffle.mbt
214563

Testing test/test_src/ski.mbt
2

Testing test/test_src/spill.mbt
-431

Testing test/test_src/spill2.mbt
77880

Testing test/test_src/spill3.mbt
1617

Testing test/test_src/split.mbt


Testing test/test_src/string.mbt
1 Hello   A 0 0  

Testing test/test_src/sum-prefix-escape.mbt
4

Testing test/test_src/sum-tail.mbt
50005000

Testing test/test_src/sum.mbt
50005000

Testing test/test_src/typeclass.mbt
1
Hello Moonbit

Testing test/test_src/typeclass2.mbt
1
Hello Moonbit
1
5
5


Testing test/test_src/user_defined_op.mbt
256
64
34


Testing test/longer-cases/bf.mbt
// [log::Parser]
// [Parser] flags: ["has_read"]
This test file contains read and cannot be tested
RuntimeError: unreachable
    at wasm://wasm/002c5f1e:wasm-function[3350]:0x468a4
    at wasm://wasm/002c5f1e:wasm-function[4664]:0x9e112
error: failed to run


Testing test/longer-cases/fannkuch-redux.mbt
862930

Testing test/longer-cases/generic.mbt
12345123456

Testing test/longer-cases/isort.mbt
279 513 1094 1338 2111 3159 3803 5325 5362 6227 6278 7522 7621 7980 7994 8340 8431 8692 8741 9002 9326 9727 9791 10002 10151 12165 12551 13121 13213 13492 13670 14472 16587 17802 19854 20999 21356 21565 21639 22272 22657 22790 23151 24205 24473 24484 25086 27221 27325 28249 28680 28886 28919 29317 32049 32437 32713 34363 34774 34887 35741 36128 36882 38400 38549 39928 40388 40492 42269 42566 43151 44067 44154 44417 44561 45509 45950 46488 46748 46770 46966 47310 47321 47353 47761 48348 49063 50111 52181 53890 54499 59169 60468 60656 60924 61209 61983 62141 64433 65299 

Testing test/longer-cases/iter.mbt
12345

Testing test/longer-cases/julia.mbt
// [log::Parser]
// [Parser] flags: ["has_read"]
This test file contains read and cannot be tested
RuntimeError: unreachable
    at wasm://wasm/002c5f1e:wasm-function[3350]:0x468a4
    at wasm://wasm/002c5f1e:wasm-function[4664]:0x9e112
error: failed to run


Testing test/longer-cases/mem-fib.mbt
// [log::Parser]
// [Parser] flags: ["has_read"]
This test file contains read and cannot be tested
RuntimeError: unreachable
    at wasm://wasm/002c5f1e:wasm-function[3350]:0x468a4
    at wasm://wasm/002c5f1e:wasm-function[4664]:0x9e112
error: failed to run


Testing test/longer-cases/phi.mbt


Testing test/longer-cases/quicksort-std.mbt
// [log::Parser]
// [Parser] flags: ["has_read"]
This test file contains read and cannot be tested
RuntimeError: unreachable
    at wasm://wasm/002c5f1e:wasm-function[3350]:0x468a4
    at wasm://wasm/002c5f1e:wasm-function[4664]:0x9e112
error: failed to run


Testing test/longer-cases/quicksort.mbt
// [log::Parser]
// [Parser] flags: ["has_read"]
This test file contains read and cannot be tested
RuntimeError: unreachable
    at wasm://wasm/002c5f1e:wasm-function[3350]:0x468a4
    at wasm://wasm/002c5f1e:wasm-function[4664]:0x9e112
error: failed to run


Testing test/longer-cases/stream.mbt
503100


