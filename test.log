Testing test/test_src/ack.mbt
# name conventions used in the core ir:
# - functions: f<id>
# - blocks: b<id>
# - instructions: %<id>
# - memory: m<id>
# - free variables: ^<id>
# - function parameters: $f<pid>
# - block parameters: $b<bid>.<pid>
.core
.fn ack #f0 : fn(int32, int32) -> int32
.freevars ()
.entry b0 {
  .bb #b6 (int32) {
    return $b6.0
  }
  .bb #b4 () {
    let %5: int32 = sub($f0, 1)
    let %6: int32 = sub($f1, 1)
    let %7: int32 = call f0($f0, %6)
    let %8: int32 = call f0(%5, %7)
    jump b5(%8)
  }
  .bb #b1 () {
    let %1: int32 = add($f1, 1)
    jump b6(%1)
  }
  .bb #b5 (int32) {
    jump b6($b5.0)
  }
  .bb #b2 () {
    let %2: bool = le($f1, 0)
    br %2 b3() b4()
  }
  .bb #b3 () {
    let %3: int32 = sub($f0, 1)
    let %4: int32 = call f0(%3, 1)
    jump b5(%4)
  }
  .bb #b0 () {
    let %0: bool = le($f0, 0)
    br %0 b1() b2()
  }
}
.fn thunk_start #f2 : fn() -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: unit = call f1()
    return %0
  }
}
.fn main #f1 : fn() -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: int32 = call f0(3, 8)
    let %1: unit = ext_call minimbt_print_int(%0)
    return %1
  }
}
.thunk ::0 start

  .p2align 3
  .globl _start
  .type _start, @function
_start:
_start_b0:
  call thunk_start
  ret

  .p2align 3
  .globl ack
  .type ack, @function
ack:
.ack_b0:
  mv v2, a0
  mv v3, a1
  slt v29, v2, zero
  xori v4, v29, 1
  bne v4, zero, .ack_b1
  j .ack_b2

.ack_b1:
  li v15, 1
  add v13, v3, v15
  mv v14, v13
  j .ack_b6

.ack_b5:
  mv v14, v12
  j .ack_b6

.ack_b2:
  slt v27, v3, zero
  xori v5, v27, 1
  bne v5, zero, .ack_b3
  j .ack_b4

.ack_b6:
  mv a0, v14
  ret

.ack_b4:
  li v25, 1
  sub v6, v2, v25
  li v23, 1
  sub v7, v3, v23
  mv a0, v2
  mv a1, v7
  call ack
  mv v8, a0
  mv a0, v6
  mv a1, v8
  call ack
  mv v9, a0
  mv v12, v9
  j .ack_b5

.ack_b3:
  li v19, 1
  sub v10, v2, v19
  mv a0, v10
  li v17, 1
  mv a1, v17
  call ack
  mv v11, a0
  mv v12, v11
  j .ack_b5

  .p2align 3
  .globl thunk_start
  .type thunk_start, @function
thunk_start:
.thunk_start_b0:
  call main
  mv v2, zero
  mv a0, v2
  ret

  .p2align 3
  .globl main
  .type main, @function
main:
.main_b0:
  li v5, 3
  mv a0, v5
  li v6, 8
  mv a1, v6
  call ack
  mv v2, a0
  mv a0, v2
  call minimbt_print_int
  mv v3, zero
  mv a0, v3
  ret

  .p2align 3
  .globl start
  .type start, @object
start:
  .zero 4



Testing test/test_src/adder.mbt
# name conventions used in the core ir:
# - functions: f<id>
# - blocks: b<id>
# - instructions: %<id>
# - memory: m<id>
# - free variables: ^<id>
# - function parameters: $f<pid>
# - block parameters: $b<bid>.<pid>
.core
.fn main #f2 : fn() -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: closure(int32) -> int32 = call f0(3)
    let %1: int32 = apply %0(7)
    let %2: unit = ext_call minimbt_print_int(%1)
    return %2
  }
}
.fn make_adder #f0 : fn(int32) -> closure(int32) -> int32
.freevars ()
.entry b0 {
  .bb #b0 () {
    let _ = alloc <m0: closure(int32) -> int32 heap(2)> <- [0] = f1, [1] = $f0
    return f0.m0
  }
}
.fn thunk_start #f3 : fn() -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: unit = call f2()
    return %0
  }
}
.fn adder #f1 : closure(int32) -> int32
.freevars (int32)
.entry b0 {
  .bb #b0 () {
    let %0: int32 = add(^1, $f0)
    return %0
  }
}
.thunk ::0 start

  .p2align 3
  .globl adder
  .type adder, @function
adder:
.adder_b0:
  mv v0, s10
  mv v2, a0
  lw v3, 8(v0)
  add v4, v3, v2
  mv a0, v4
  ret

  .p2align 3
  .globl _start
  .type _start, @function
_start:
_start_b0:
  call thunk_start
  ret

  .p2align 3
  .globl thunk_start
  .type thunk_start, @function
thunk_start:
.thunk_start_b0:
  call main
  mv v2, zero
  mv a0, v2
  ret

  .p2align 3
  .globl make_adder
  .type make_adder, @function
make_adder:
.make_adder_b0:
  mv v2, a0
  addi v5, s11, -16
  andi v3, v5, -8
  la v7, adder
  sd v7, 0(v3)
  sd v2, 8(v3)
  mv a0, v3
  ret

  .p2align 3
  .globl main
  .type main, @function
main:
.main_b0:
  li v9, 3
  mv a0, v9
  call make_adder
  mv v2, a0
  mv s10, v2
  ld v6, 0(v2)
  li v7, 7
  mv a0, v7
  jalr v6
  mv v3, a0
  mv a0, v3
  call minimbt_print_int
  mv v4, zero
  mv a0, v4
  ret

  .p2align 3
  .globl start
  .type start, @object
start:
  .zero 4



Testing test/test_src/adder2.mbt
# name conventions used in the core ir:
# - functions: f<id>
# - blocks: b<id>
# - instructions: %<id>
# - memory: m<id>
# - free variables: ^<id>
# - function parameters: $f<pid>
# - block parameters: $b<bid>.<pid>
.core
.fn main #f2 : fn() -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: closure(int32) -> int32 = call f0(2)
    let %1: closure(int32) -> int32 = call f0(3)
    let %2: int32 = apply %0(10)
    let %3: int32 = apply %1(20)
    let %4: int32 = add(%2, %3)
    let %5: unit = ext_call minimbt_print_int(%4)
    return %5
  }
}
.fn make_adder #f0 : fn(int32) -> closure(int32) -> int32
.freevars ()
.entry b0 {
  .bb #b0 () {
    let _ = alloc <m0: closure(int32) -> int32 heap(2)> <- [0] = f1, [1] = $f0
    return f0.m0
  }
}
.fn thunk_start #f3 : fn() -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: unit = call f2()
    return %0
  }
}
.fn adder #f1 : closure(int32) -> int32
.freevars (int32)
.entry b0 {
  .bb #b0 () {
    let %0: int32 = add(^1, $f0)
    return %0
  }
}
.thunk ::0 start

  .p2align 3
  .globl adder
  .type adder, @function
adder:
.adder_b0:
  mv v0, s10
  mv v2, a0
  lw v3, 8(v0)
  add v4, v3, v2
  mv a0, v4
  ret

  .p2align 3
  .globl _start
  .type _start, @function
_start:
_start_b0:
  call thunk_start
  ret

  .p2align 3
  .globl thunk_start
  .type thunk_start, @function
thunk_start:
.thunk_start_b0:
  call main
  mv v2, zero
  mv a0, v2
  ret

  .p2align 3
  .globl make_adder
  .type make_adder, @function
make_adder:
.make_adder_b0:
  mv v2, a0
  addi v5, s11, -16
  andi v3, v5, -8
  la v7, adder
  sd v7, 0(v3)
  sd v2, 8(v3)
  mv a0, v3
  ret

  .p2align 3
  .globl main
  .type main, @function
main:
.main_b0:
  li v18, 2
  mv a0, v18
  call make_adder
  mv v2, a0
  li v16, 3
  mv a0, v16
  call make_adder
  mv v3, a0
  mv s10, v2
  ld v13, 0(v2)
  li v14, 10
  mv a0, v14
  jalr v13
  mv v4, a0
  mv s10, v3
  ld v10, 0(v3)
  li v11, 20
  mv a0, v11
  jalr v10
  mv v5, a0
  add v6, v4, v5
  mv a0, v6
  call minimbt_print_int
  mv v7, zero
  mv a0, v7
  ret

  .p2align 3
  .globl start
  .type start, @object
start:
  .zero 4



Testing test/test_src/bf.mbt
# name conventions used in the core ir:
# - functions: f<id>
# - blocks: b<id>
# - instructions: %<id>
# - memory: m<id>
# - free variables: ^<id>
# - function parameters: $f<pid>
# - block parameters: $b<bid>.<pid>
.core
.fn lp #f2 : closure() -> unit
.freevars (array[int32], array[int32], int32, closure(int32) -> int32, array[int32])
.entry b0 {
  .bb #b0 () {
    let %0: int32 = load int32 offset(^1, 0)
    let %1: int32 = load int32 offset(^2, %0)
    let %2: bool = eq(%1, 0)
    br %2 b1() b2()
  }
  .bb #b1 () {
    jump b3(())
  }
  .bb #b2 () {
    let %3: int32 = add(^3, 1)
    let %4: int32 = apply ^4(%3)
    let _ = store int32 offset(^5, 0) <- %4
    let %6: unit = apply self()
    jump b3(%6)
  }
  .bb #b3 (unit) {
    return $b3.0
  }
}
.fn thunk_start #f4 : fn() -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: unit = call f3()
    return %0
  }
}
.fn aux #f1 : closure(int32) -> int32
.freevars (int32, array[int32], array[int32], array[int32])
.entry b0 {
  .bb #b23 (int32) {
    jump b24($b23.0)
  }
  .bb #b8 () {
    let %22: bool = eq(%1, 4)
    br %22 b9() b10()
  }
  .bb #b9 () {
    let %23: int32 = load int32 offset(^3, 0)
    let %24: int32 = load int32 offset(^3, 0)
    let %25: int32 = load int32 offset(^4, %24)
    let %26: int32 = sub(%25, 1)
    let _ = store int32 offset(^4, %23) <- %26
    let %28: int32 = add($f0, 1)
    let %29: int32 = apply self(%28)
    jump b20(%29)
  }
  .bb #b16 () {
    jump b17($f0)
  }
  .bb #b13 () {
    let _ = alloc <m0: array[int32] heap(1)> <- [..] = $f0
    let _ = alloc <m1: closure() -> unit heap(6)> <- [0] = f2, [1] = ^3, [2] = ^4, [3] = $f0, [4] = self, [5] = f1.m0
    let %39: unit = apply f1.m1()
    let %40: int32 = load int32 offset(f1.m0, 0)
    let %41: int32 = add(%40, 1)
    let %42: int32 = apply self(%41)
    jump b18(%42)
  }
  .bb #b19 (int32) {
    jump b20($b19.0)
  }
  .bb #b15 () {
    jump b17($f0)
  }
  .bb #b1 () {
    jump b24($f0)
  }
  .bb #b11 () {
    let %31: int32 = load int32 offset(^3, 0)
    let %32: int32 = load int32 offset(^4, %31)
    let %33: unit = ext_call minimbt_print_char(%32)
    let %34: int32 = add($f0, 1)
    let %35: int32 = apply self(%34)
    jump b19(%35)
  }
  .bb #b2 () {
    let %1: int32 = load int32 offset(^2, $f0)
    let %2: bool = eq(%1, 1)
    br %2 b3() b4()
  }
  .bb #b18 (int32) {
    jump b19($b18.0)
  }
  .bb #b24 (int32) {
    return $b24.0
  }
  .bb #b21 (int32) {
    jump b22($b21.0)
  }
  .bb #b22 (int32) {
    jump b23($b22.0)
  }
  .bb #b20 (int32) {
    jump b21($b20.0)
  }
  .bb #b6 () {
    let %14: bool = eq(%1, 3)
    br %14 b7() b8()
  }
  .bb #b12 () {
    let %36: bool = eq(%1, 7)
    br %36 b13() b14()
  }
  .bb #b4 () {
    let %8: bool = eq(%1, 2)
    br %8 b5() b6()
  }
  .bb #b17 (int32) {
    jump b18($b17.0)
  }
  .bb #b0 () {
    let %0: bool = le(^1, $f0)
    br %0 b1() b2()
  }
  .bb #b10 () {
    let %30: bool = eq(%1, 5)
    br %30 b11() b12()
  }
  .bb #b5 () {
    let %9: int32 = load int32 offset(^3, 0)
    let %10: int32 = sub(%9, 1)
    let _ = store int32 offset(^3, 0) <- %10
    let %12: int32 = add($f0, 1)
    let %13: int32 = apply self(%12)
    jump b22(%13)
  }
  .bb #b3 () {
    let %3: int32 = load int32 offset(^3, 0)
    let %4: int32 = add(%3, 1)
    let _ = store int32 offset(^3, 0) <- %4
    let %6: int32 = add($f0, 1)
    let %7: int32 = apply self(%6)
    jump b23(%7)
  }
  .bb #b14 () {
    let %43: bool = eq(%1, 8)
    br %43 b15() b16()
  }
  .bb #b7 () {
    let %15: int32 = load int32 offset(^3, 0)
    let %16: int32 = load int32 offset(^3, 0)
    let %17: int32 = load int32 offset(^4, %16)
    let %18: int32 = add(%17, 1)
    let _ = store int32 offset(^4, %15) <- %18
    let %20: int32 = add($f0, 1)
    let %21: int32 = apply self(%20)
    jump b21(%21)
  }
}
.fn bf #f0 : fn(int32, array[int32]) -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let _ = alloc <m0: array[int32] heap(1)> <- [..] = 0
    let _ = alloc <m1: array[int32] heap(1024)> <- [..] = 0
    let _ = alloc <m2: closure(int32) -> int32 heap(5)> <- [0] = f1, [1] = $f0, [2] = $f1, [3] = f0.m0, [4] = f0.m1
    let %3: int32 = apply f0.m2(0)
    return ()
  }
}
.fn main #f3 : fn() -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let _ = alloc <m0: array[int32] heap(23)> <- [..] = 0
    let _ = store int32 offset(f3.m0, 0) <- 3
    let _ = store int32 offset(f3.m0, 1) <- 3
    let _ = store int32 offset(f3.m0, 2) <- 3
    let _ = store int32 offset(f3.m0, 3) <- 3
    let _ = store int32 offset(f3.m0, 4) <- 3
    let _ = store int32 offset(f3.m0, 5) <- 3
    let _ = store int32 offset(f3.m0, 6) <- 3
    let _ = store int32 offset(f3.m0, 7) <- 3
    let _ = store int32 offset(f3.m0, 8) <- 7
    let _ = store int32 offset(f3.m0, 9) <- 1
    let _ = store int32 offset(f3.m0, 10) <- 3
    let _ = store int32 offset(f3.m0, 11) <- 3
    let _ = store int32 offset(f3.m0, 12) <- 3
    let _ = store int32 offset(f3.m0, 13) <- 3
    let _ = store int32 offset(f3.m0, 14) <- 3
    let _ = store int32 offset(f3.m0, 15) <- 3
    let _ = store int32 offset(f3.m0, 16) <- 3
    let _ = store int32 offset(f3.m0, 17) <- 3
    let _ = store int32 offset(f3.m0, 18) <- 2
    let _ = store int32 offset(f3.m0, 19) <- 4
    let _ = store int32 offset(f3.m0, 20) <- 8
    let _ = store int32 offset(f3.m0, 21) <- 1
    let _ = store int32 offset(f3.m0, 22) <- 5
    let %24: unit = call f0(23, f3.m0)
    return %24
  }
}
.thunk ::0 start

  .p2align 3
  .globl _start
  .type _start, @function
_start:
_start_b0:
  call thunk_start
  ret

  .p2align 3
  .globl thunk_start
  .type thunk_start, @function
thunk_start:
.thunk_start_b0:
  call main
  mv v2, zero
  mv a0, v2
  ret

  .p2align 3
  .globl lp
  .type lp, @function
lp:
.lp_b0:
  mv v0, s10
  lw v2, 8(v0)
  lw v3, 16(v0)
  lw v4, 24(v0)
  lw v5, 32(v0)
  lw v6, 40(v0)
  slli v28, zero, 2
  add v29, v2, v28
  lw v7, 0(v29)
  slli v25, v7, 2
  add v26, v3, v25
  lw v8, 0(v26)
  xor v23, v8, zero
  sltiu v9, v23, 1
  bne v9, zero, .lp_b1
  j .lp_b2

.lp_b1:
  mv v14, zero
  j .lp_b3

.lp_b2:
  li v21, 1
  add v10, v4, v21
  mv s10, v5
  ld v19, 0(v5)
  mv a0, v10
  jalr v19
  mv v11, a0
  slli v17, zero, 2
  add v18, v6, v17
  sw v11, 0(v18)
  mv s10, v0
  ld v15, 0(v0)
  jalr v15
  mv v13, zero
  mv v14, v13
  j .lp_b3

.lp_b3:
  mv a0, v14
  ret

  .p2align 3
  .globl aux
  .type aux, @function
aux:
.aux_b0:
  mv v0, s10
  mv v2, a0
  lw v3, 8(v0)
  lw v4, 16(v0)
  lw v5, 24(v0)
  lw v6, 32(v0)
  slt v166, v3, v2
  xori v9, v166, 1
  bne v9, zero, .aux_b1
  j .aux_b2

.aux_b19:
  mv v39, v31
  j .aux_b20

.aux_b1:
  mv v60, v2
  j .aux_b24

.aux_b7:
  slli v97, zero, 2
  add v98, v5, v97
  lw v40, 0(v98)
  slli v94, zero, 2
  add v95, v5, v94
  lw v41, 0(v95)
  slli v91, v41, 2
  add v92, v6, v91
  lw v42, 0(v92)
  li v89, 1
  add v43, v42, v89
  slli v87, v40, 2
  add v88, v6, v87
  sw v43, 0(v88)
  li v85, 1
  add v45, v2, v85
  mv s10, v0
  ld v83, 0(v0)
  mv a0, v45
  jalr v83
  mv v46, a0
  mv v47, v46
  j .aux_b21

.aux_b13:
  addi v140, s11, -4
  andi v7, v140, -8
  sw v2, 0(v7)
  addi v137, s11, -48
  andi v8, v137, -8
  la v139, lp
  sd v139, 0(v8)
  sd v5, 8(v8)
  sd v6, 16(v8)
  sd v2, 24(v8)
  sd v0, 32(v8)
  sd v7, 40(v8)
  mv s10, v8
  ld v135, 0(v8)
  jalr v135
  mv v21, zero
  slli v132, zero, 2
  add v133, v7, v132
  lw v22, 0(v133)
  li v130, 1
  add v23, v22, v130
  mv s10, v0
  ld v128, 0(v0)
  mv a0, v23
  jalr v128
  mv v24, a0
  mv v25, v24
  j .aux_b18

.aux_b22:
  mv v59, v53
  j .aux_b23

.aux_b5:
  slli v80, zero, 2
  add v81, v5, v80
  lw v48, 0(v81)
  li v78, 1
  sub v49, v48, v78
  slli v76, zero, 2
  add v77, v5, v76
  sw v49, 0(v77)
  li v74, 1
  add v51, v2, v74
  mv s10, v0
  ld v72, 0(v0)
  mv a0, v51
  jalr v72
  mv v52, a0
  mv v53, v52
  j .aux_b22

.aux_b4:
  li v157, 2
  xor v158, v10, v157
  sltiu v12, v158, 1
  bne v12, zero, .aux_b5
  j .aux_b6

.aux_b8:
  li v151, 4
  xor v152, v10, v151
  sltiu v14, v152, 1
  bne v14, zero, .aux_b9
  j .aux_b10

.aux_b17:
  mv v25, v18
  j .aux_b18

.aux_b2:
  slli v163, v2, 2
  add v164, v4, v163
  lw v10, 0(v164)
  li v160, 1
  xor v161, v10, v160
  sltiu v11, v161, 1
  bne v11, zero, .aux_b3
  j .aux_b4

.aux_b24:
  mv a0, v60
  ret

.aux_b6:
  li v154, 3
  xor v155, v10, v154
  sltiu v13, v155, 1
  bne v13, zero, .aux_b7
  j .aux_b8

.aux_b20:
  mv v47, v39
  j .aux_b21

.aux_b12:
  li v145, 7
  xor v146, v10, v145
  sltiu v16, v146, 1
  bne v16, zero, .aux_b13
  j .aux_b14

.aux_b23:
  mv v60, v59
  j .aux_b24

.aux_b3:
  slli v69, zero, 2
  add v70, v5, v69
  lw v54, 0(v70)
  li v67, 1
  add v55, v54, v67
  slli v65, zero, 2
  add v66, v5, v65
  sw v55, 0(v66)
  li v63, 1
  add v57, v2, v63
  mv s10, v0
  ld v61, 0(v0)
  mv a0, v57
  jalr v61
  mv v58, a0
  mv v59, v58
  j .aux_b23

.aux_b9:
  slli v114, zero, 2
  add v115, v5, v114
  lw v32, 0(v115)
  slli v111, zero, 2
  add v112, v5, v111
  lw v33, 0(v112)
  slli v108, v33, 2
  add v109, v6, v108
  lw v34, 0(v109)
  li v106, 1
  sub v35, v34, v106
  slli v104, v32, 2
  add v105, v6, v104
  sw v35, 0(v105)
  li v102, 1
  add v37, v2, v102
  mv s10, v0
  ld v100, 0(v0)
  mv a0, v37
  jalr v100
  mv v38, a0
  mv v39, v38
  j .aux_b20

.aux_b16:
  mv v18, v2
  j .aux_b17

.aux_b10:
  li v148, 5
  xor v149, v10, v148
  sltiu v15, v149, 1
  bne v15, zero, .aux_b11
  j .aux_b12

.aux_b11:
  slli v125, zero, 2
  add v126, v5, v125
  lw v26, 0(v126)
  slli v122, v26, 2
  add v123, v6, v122
  lw v27, 0(v123)
  mv a0, v27
  call minimbt_print_char
  mv v28, zero
  li v119, 1
  add v29, v2, v119
  mv s10, v0
  ld v117, 0(v0)
  mv a0, v29
  jalr v117
  mv v30, a0
  mv v31, v30
  j .aux_b19

.aux_b21:
  mv v53, v47
  j .aux_b22

.aux_b18:
  mv v31, v25
  j .aux_b19

.aux_b14:
  li v142, 8
  xor v143, v10, v142
  sltiu v17, v143, 1
  bne v17, zero, .aux_b15
  j .aux_b16

.aux_b15:
  mv v18, v2
  j .aux_b17

  .p2align 3
  .globl bf
  .type bf, @function
bf:
.bf_b0:
  mv v2, a0
  mv v3, a1
  addi v20, s11, -4
  andi v4, v20, -8
  sw zero, 0(v4)
  li v16, 4096
  sub v17, s11, v16
  andi v5, v17, -8
  li v19, 1024
  mv a1, v19
  mv a0, v5
  mv a2, zero
  call _memseti32
  addi v13, s11, -40
  andi v6, v13, -8
  la v15, aux
  sd v15, 0(v6)
  sd v2, 8(v6)
  sd v3, 16(v6)
  sd v4, 24(v6)
  sd v5, 32(v6)
  mv s10, v6
  ld v11, 0(v6)
  mv a0, zero
  jalr v11
  mv v10, a0
  mv a0, zero
  ret

  .p2align 3
  .globl main
  .type main, @function
main:
.main_b0:
  addi v121, s11, -92
  andi v2, v121, -8
  sw zero, 0(v2)
  sw zero, 4(v2)
  sw zero, 8(v2)
  sw zero, 12(v2)
  sw zero, 16(v2)
  sw zero, 20(v2)
  sw zero, 24(v2)
  sw zero, 28(v2)
  sw zero, 32(v2)
  sw zero, 36(v2)
  sw zero, 40(v2)
  sw zero, 44(v2)
  sw zero, 48(v2)
  sw zero, 52(v2)
  sw zero, 56(v2)
  sw zero, 60(v2)
  sw zero, 64(v2)
  sw zero, 68(v2)
  sw zero, 72(v2)
  sw zero, 76(v2)
  sw zero, 80(v2)
  sw zero, 84(v2)
  sw zero, 88(v2)
  li v118, 3
  slli v119, zero, 2
  add v120, v2, v119
  sw v118, 0(v120)
  li v114, 3
  li v115, 1
  slli v116, v115, 2
  add v117, v2, v116
  sw v114, 0(v117)
  li v110, 3
  li v111, 2
  slli v112, v111, 2
  add v113, v2, v112
  sw v110, 0(v113)
  li v106, 3
  li v107, 3
  slli v108, v107, 2
  add v109, v2, v108
  sw v106, 0(v109)
  li v102, 3
  li v103, 4
  slli v104, v103, 2
  add v105, v2, v104
  sw v102, 0(v105)
  li v98, 3
  li v99, 5
  slli v100, v99, 2
  add v101, v2, v100
  sw v98, 0(v101)
  li v94, 3
  li v95, 6
  slli v96, v95, 2
  add v97, v2, v96
  sw v94, 0(v97)
  li v90, 3
  li v91, 7
  slli v92, v91, 2
  add v93, v2, v92
  sw v90, 0(v93)
  li v86, 7
  li v87, 8
  slli v88, v87, 2
  add v89, v2, v88
  sw v86, 0(v89)
  li v82, 1
  li v83, 9
  slli v84, v83, 2
  add v85, v2, v84
  sw v82, 0(v85)
  li v78, 3
  li v79, 10
  slli v80, v79, 2
  add v81, v2, v80
  sw v78, 0(v81)
  li v74, 3
  li v75, 11
  slli v76, v75, 2
  add v77, v2, v76
  sw v74, 0(v77)
  li v70, 3
  li v71, 12
  slli v72, v71, 2
  add v73, v2, v72
  sw v70, 0(v73)
  li v66, 3
  li v67, 13
  slli v68, v67, 2
  add v69, v2, v68
  sw v66, 0(v69)
  li v62, 3
  li v63, 14
  slli v64, v63, 2
  add v65, v2, v64
  sw v62, 0(v65)
  li v58, 3
  li v59, 15
  slli v60, v59, 2
  add v61, v2, v60
  sw v58, 0(v61)
  li v54, 3
  li v55, 16
  slli v56, v55, 2
  add v57, v2, v56
  sw v54, 0(v57)
  li v50, 3
  li v51, 17
  slli v52, v51, 2
  add v53, v2, v52
  sw v50, 0(v53)
  li v46, 2
  li v47, 18
  slli v48, v47, 2
  add v49, v2, v48
  sw v46, 0(v49)
  li v42, 4
  li v43, 19
  slli v44, v43, 2
  add v45, v2, v44
  sw v42, 0(v45)
  li v38, 8
  li v39, 20
  slli v40, v39, 2
  add v41, v2, v40
  sw v38, 0(v41)
  li v34, 1
  li v35, 21
  slli v36, v35, 2
  add v37, v2, v36
  sw v34, 0(v37)
  li v30, 5
  li v31, 22
  slli v32, v31, 2
  add v33, v2, v32
  sw v30, 0(v33)
  li v28, 23
  mv a0, v28
  mv a1, v2
  call bf
  mv v27, zero
  mv a0, v27
  ret

  .p2align 3
  .globl start
  .type start, @object
start:
  .zero 4



Testing test/test_src/cls-bug.mbt
# name conventions used in the core ir:
# - functions: f<id>
# - blocks: b<id>
# - instructions: %<id>
# - memory: m<id>
# - free variables: ^<id>
# - function parameters: $f<pid>
# - block parameters: $b<bid>.<pid>
.core
.fn main #f2 : fn() -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: closure(int32) -> int32 = call f1(456)
    let %1: int32 = apply %0(789)
    let %2: unit = ext_call minimbt_print_int(%1)
    return %2
  }
}
.fn f #f0 : fn(int32) -> int32
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: int32 = add($f0, 123)
    return %0
  }
}
.fn thunk_start #f3 : fn() -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: unit = call f2()
    return %0
  }
}
.fn g #f1 : fn(int32) -> closure(int32) -> int32
.freevars ()
.entry b0 {
  .bb #b0 () {
    let _ = alloc <m0: closure(int32) -> int32 heap(1)> <- [0] = f0
    return f1.m0
  }
}
.thunk ::0 start

  .p2align 3
  .globl _start
  .type _start, @function
_start:
_start_b0:
  call thunk_start
  ret

  .p2align 3
  .globl f
  .type f, @function
f:
.f_b0:
  mv v2, a0
  li v4, 123
  add v3, v2, v4
  mv a0, v3
  ret

  .p2align 3
  .globl thunk_start
  .type thunk_start, @function
thunk_start:
.thunk_start_b0:
  call main
  mv v2, zero
  mv a0, v2
  ret

  .p2align 3
  .globl g
  .type g, @function
g:
.g_b0:
  mv v2, a0
  addi v5, s11, -8
  andi v3, v5, -8
  la v7, f
  sd v7, 0(v3)
  mv a0, v3
  ret

  .p2align 3
  .globl main
  .type main, @function
main:
.main_b0:
  li v9, 456
  mv a0, v9
  call g
  mv v2, a0
  mv s10, v2
  ld v6, 0(v2)
  li v7, 789
  mv a0, v7
  jalr v6
  mv v3, a0
  mv a0, v3
  call minimbt_print_int
  mv v4, zero
  mv a0, v4
  ret

  .p2align 3
  .globl start
  .type start, @object
start:
  .zero 4



Testing test/test_src/cls-bug2.mbt
# name conventions used in the core ir:
# - functions: f<id>
# - blocks: b<id>
# - instructions: %<id>
# - memory: m<id>
# - free variables: ^<id>
# - function parameters: $f<pid>
# - block parameters: $b<bid>.<pid>
.core
.fn f #f0 : fn(int32) -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: bool = le(0, $f0)
    br %0 b1() b2()
  }
  .bb #b1 () {
    let %1: unit = ext_call minimbt_print_int($f0)
    let _ = alloc <m0: closure(int32) -> unit heap(1)> <- [0] = f0
    let _ = alloc <m1: array[closure(int32) -> unit] heap(1)> <- [..] = f0.m0
    let %4: closure(int32) -> unit = load closure(int32) -> unit offset(f0.m1, 0)
    let %5: int32 = sub($f0, 1)
    let %6: unit = apply %4(%5)
    jump b3(%6)
  }
  .bb #b2 () {
    jump b3(())
  }
  .bb #b3 (unit) {
    return $b3.0
  }
}
.fn thunk_start #f2 : fn() -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: unit = call f1()
    return %0
  }
}
.fn main #f1 : fn() -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: unit = call f0(9)
    return %0
  }
}
.thunk ::0 start

  .p2align 3
  .globl _start
  .type _start, @function
_start:
_start_b0:
  call thunk_start
  ret

  .p2align 3
  .globl f
  .type f, @function
f:
.f_b0:
  mv v2, a0
  slt v26, zero, v2
  xori v5, v26, 1
  bne v5, zero, .f_b1
  j .f_b2

.f_b3:
  mv a0, v12
  ret

.f_b1:
  mv a0, v2
  call minimbt_print_int
  mv v6, zero
  addi v22, s11, -8
  andi v3, v22, -8
  la v24, f
  sd v24, 0(v3)
  addi v20, s11, -8
  andi v4, v20, -8
  sd v3, 0(v4)
  slli v17, zero, 3
  add v18, v4, v17
  ld v9, 0(v18)
  li v15, 1
  sub v10, v2, v15
  mv s10, v9
  ld v13, 0(v9)
  mv a0, v10
  jalr v13
  mv v11, zero
  mv v12, v11
  j .f_b3

.f_b2:
  mv v12, zero
  j .f_b3

  .p2align 3
  .globl thunk_start
  .type thunk_start, @function
thunk_start:
.thunk_start_b0:
  call main
  mv v2, zero
  mv a0, v2
  ret

  .p2align 3
  .globl main
  .type main, @function
main:
.main_b0:
  li v3, 9
  mv a0, v3
  call f
  mv v2, zero
  mv a0, v2
  ret

  .p2align 3
  .globl start
  .type start, @object
start:
  .zero 4



Testing test/test_src/cls-rec.mbt
# name conventions used in the core ir:
# - functions: f<id>
# - blocks: b<id>
# - instructions: %<id>
# - memory: m<id>
# - free variables: ^<id>
# - function parameters: $f<pid>
# - block parameters: $b<bid>.<pid>
.core
.fn f #f1 : fn(int32) -> int32
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: bool = eq($f0, 0)
    br %0 b1() b2()
  }
  .bb #b1 () {
    jump b3(0)
  }
  .bb #b2 () {
    let %1: int32 = sub($f0, 1)
    let %2: int32 = call f1(%1)
    let %3: int32 = load_symbol ::0
    let %4: int32 = add(%3, %2)
    jump b3(%4)
  }
  .bb #b3 (int32) {
    return $b3.0
  }
}
.fn thunk_start #f3 : fn() -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: unit = call f2()
    return %0
  }
}
.fn thunk_x.1 #f0 : fn() -> int32
.freevars ()
.entry b0 {
  .bb #b0 () {
    return 10
  }
}
.fn main #f2 : fn() -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: int32 = call f1(12)
    let %1: unit = ext_call minimbt_print_int(%0)
    return %1
  }
}
.thunk ::0 x.1
.thunk ::1 start

  .p2align 3
  .globl _start
  .type _start, @function
_start:
_start_b0:
  call thunk_x.1
  la t6, x.1
  sw a0, 0(t6)
  call thunk_start
  ret

  .p2align 3
  .globl f
  .type f, @function
f:
.f_b0:
  mv v2, a0
  xor v15, v2, zero
  sltiu v3, v15, 1
  bne v3, zero, .f_b1
  j .f_b2

.f_b3:
  mv a0, v8
  ret

.f_b1:
  mv v8, zero
  j .f_b3

.f_b2:
  li v13, 1
  sub v4, v2, v13
  mv a0, v4
  call f
  mv v5, a0
  la v10, x.1
  lw v6, 0(v10)
  add v7, v6, v5
  mv v8, v7
  j .f_b3

  .p2align 3
  .globl thunk_start
  .type thunk_start, @function
thunk_start:
.thunk_start_b0:
  call main
  mv v2, zero
  mv a0, v2
  ret

  .p2align 3
  .globl thunk_x.1
  .type thunk_x.1, @function
thunk_x.1:
.thunk_x.1_b0:
  li v2, 10
  mv a0, v2
  ret

  .p2align 3
  .globl main
  .type main, @function
main:
.main_b0:
  li v5, 12
  mv a0, v5
  call f
  mv v2, a0
  mv a0, v2
  call minimbt_print_int
  mv v3, zero
  mv a0, v3
  ret

  .p2align 3
  .globl x.1
  .type x.1, @object
x.1:
  .zero 4
  .p2align 3
  .globl start
  .type start, @object
start:
  .zero 4



Testing test/test_src/cls-reg-bug.mbt
# name conventions used in the core ir:
# - functions: f<id>
# - blocks: b<id>
# - instructions: %<id>
# - memory: m<id>
# - free variables: ^<id>
# - function parameters: $f<pid>
# - block parameters: $b<bid>.<pid>
.core
.fn g #f1 : closure(int32) -> int32
.freevars (int32, int32, int32, int32, int32, int32, int32, int32, int32, int32)
.entry b0 {
  .bb #b0 () {
    let %0: int32 = add(^1, ^2)
    let %1: int32 = add(%0, ^3)
    let %2: int32 = add(%1, ^4)
    let %3: int32 = add(%2, ^5)
    let %4: int32 = add(%3, ^6)
    let %5: int32 = add(%4, ^7)
    let %6: int32 = add(%5, ^8)
    let %7: int32 = add(%6, ^9)
    let %8: int32 = add(%7, ^10)
    let %9: bool = le($f0, 0)
    br %9 b1() b2()
  }
  .bb #b1 () {
    let %10: int32 = neg($f0)
    let %11: int32 = apply self(%10)
    jump b3(%11)
  }
  .bb #b2 () {
    jump b3(%8)
  }
  .bb #b3 (int32) {
    return $b3.0
  }
}
.fn main #f2 : fn() -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let _ = alloc <m0: (int32, int32, int32, int32, int32, int32, int32, int32, int32, int32) heap(10)> <- [0] = 1, [1] = 2, [2] = 3, [3] = 4, [4] = 5, [5] = 6, [6] = 7, [7] = 8, [8] = 9, [9] = 10
    let %1: int32 = call f0(f2.m0)
    let %2: unit = ext_call minimbt_print_int(%1)
    return ()
  }
}
.fn thunk_start #f3 : fn() -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: unit = call f2()
    return %0
  }
}
.fn h #f0 : fn((int32, int32, int32, int32, int32, int32, int32, int32, int32, int32)) -> int32
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: int32 = load int32 field($f0, 0)
    let %1: int32 = load int32 field($f0, 1)
    let %2: int32 = load int32 field($f0, 2)
    let %3: int32 = load int32 field($f0, 3)
    let %4: int32 = load int32 field($f0, 4)
    let %5: int32 = load int32 field($f0, 5)
    let %6: int32 = load int32 field($f0, 6)
    let %7: int32 = load int32 field($f0, 7)
    let %8: int32 = load int32 field($f0, 8)
    let %9: int32 = load int32 field($f0, 9)
    let _ = alloc <m0: closure(int32) -> int32 heap(11)> <- [0] = f1, [1] = %0, [2] = %1, [3] = %2, [4] = %3, [5] = %4, [6] = %5, [7] = %6, [8] = %7, [9] = %8, [10] = %9
    let %11: int32 = apply f0.m0(1)
    return %11
  }
}
.thunk ::0 start

  .p2align 3
  .globl _start
  .type _start, @function
_start:
_start_b0:
  call thunk_start
  ret

  .p2align 3
  .globl thunk_start
  .type thunk_start, @function
thunk_start:
.thunk_start_b0:
  call main
  mv v2, zero
  mv a0, v2
  ret

  .p2align 3
  .globl g
  .type g, @function
g:
.g_b0:
  mv v0, s10
  mv v2, a0
  lw v3, 8(v0)
  lw v4, 16(v0)
  lw v5, 24(v0)
  lw v6, 32(v0)
  lw v7, 40(v0)
  lw v8, 48(v0)
  lw v9, 56(v0)
  lw v10, 64(v0)
  lw v11, 72(v0)
  lw v12, 80(v0)
  add v13, v3, v4
  add v14, v13, v5
  add v15, v14, v6
  add v16, v15, v7
  add v17, v16, v8
  add v18, v17, v9
  add v19, v18, v10
  add v20, v19, v11
  add v21, v20, v12
  slt v29, v2, zero
  xori v22, v29, 1
  bne v22, zero, .g_b1
  j .g_b2

.g_b3:
  mv a0, v25
  ret

.g_b1:
  neg v23, v2
  mv s10, v0
  ld v26, 0(v0)
  mv a0, v23
  jalr v26
  mv v24, a0
  mv v25, v24
  j .g_b3

.g_b2:
  mv v25, v21
  j .g_b3

  .p2align 3
  .globl h
  .type h, @function
h:
.h_b0:
  mv v2, a0
  lw v4, 0(v2)
  lw v5, 4(v2)
  lw v6, 8(v2)
  lw v7, 12(v2)
  lw v8, 16(v2)
  lw v9, 20(v2)
  lw v10, 24(v2)
  lw v11, 28(v2)
  lw v12, 32(v2)
  lw v13, 36(v2)
  addi v19, s11, -88
  andi v3, v19, -8
  la v21, g
  sd v21, 0(v3)
  sd v4, 8(v3)
  sd v5, 16(v3)
  sd v6, 24(v3)
  sd v7, 32(v3)
  sd v8, 40(v3)
  sd v9, 48(v3)
  sd v10, 56(v3)
  sd v11, 64(v3)
  sd v12, 72(v3)
  sd v13, 80(v3)
  mv s10, v3
  ld v16, 0(v3)
  li v17, 1
  mv a0, v17
  jalr v16
  mv v15, a0
  mv a0, v15
  ret

  .p2align 3
  .globl main
  .type main, @function
main:
.main_b0:
  addi v8, s11, -80
  andi v2, v8, -8
  li v10, 1
  sd v10, 0(v2)
  li v11, 2
  sd v11, 8(v2)
  li v12, 3
  sd v12, 16(v2)
  li v13, 4
  sd v13, 24(v2)
  li v14, 5
  sd v14, 32(v2)
  li v15, 6
  sd v15, 40(v2)
  li v16, 7
  sd v16, 48(v2)
  li v17, 8
  sd v17, 56(v2)
  li v18, 9
  sd v18, 64(v2)
  li v19, 10
  sd v19, 72(v2)
  mv a0, v2
  call h
  mv v4, a0
  mv a0, v4
  call minimbt_print_int
  mv v5, zero
  mv a0, zero
  ret

  .p2align 3
  .globl start
  .type start, @object
start:
  .zero 4



Testing test/test_src/debug.mbt
# name conventions used in the core ir:
# - functions: f<id>
# - blocks: b<id>
# - instructions: %<id>
# - memory: m<id>
# - free variables: ^<id>
# - function parameters: $f<pid>
# - block parameters: $b<bid>.<pid>
.core
.fn f #f1 : fn(int32) -> int32
.freevars ()
.entry b0 {
  .bb #b0 () {
    let _ = alloc <m0: closure(int32) -> int32 heap(2)> <- [0] = f2, [1] = $f0
    let %1: bool = eq(1, 1)
    br %1 b1() b2()
  }
  .bb #b1 () {
    let %2: int32 = call f1(1)
    jump b3(%2)
  }
  .bb #b2 () {
    let %3: int32 = apply f1.m0(2)
    jump b3(%3)
  }
  .bb #b3 (int32) {
    return $b3.0
  }
}
.fn thunk_start #f4 : fn() -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: unit = call f3()
    return %0
  }
}
.fn g #f2 : closure(int32) -> int32
.freevars (int32)
.entry b0 {
  .bb #b0 () {
    return ^1
  }
}
.fn dummy #f0 : fn(int32) -> int32
.freevars ()
.entry b0 {
  .bb #b0 () {
    return $f0
  }
}
.fn main #f3 : fn() -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    return ()
  }
}
.thunk ::0 start

  .p2align 3
  .globl _start
  .type _start, @function
_start:
_start_b0:
  call thunk_start
  ret

  .p2align 3
  .globl f
  .type f, @function
f:
.f_b0:
  mv v2, a0
  addi v18, s11, -16
  andi v3, v18, -8
  la v20, g
  sd v20, 0(v3)
  sd v2, 8(v3)
  li v14, 1
  li v15, 1
  xor v16, v14, v15
  sltiu v5, v16, 1
  bne v5, zero, .f_b1
  j .f_b2

.f_b3:
  mv a0, v8
  ret

.f_b1:
  li v9, 1
  mv a0, v9
  call f
  mv v7, a0
  mv v8, v7
  j .f_b3

.f_b2:
  mv s10, v3
  ld v11, 0(v3)
  li v12, 2
  mv a0, v12
  jalr v11
  mv v6, a0
  mv v8, v6
  j .f_b3

  .p2align 3
  .globl thunk_start
  .type thunk_start, @function
thunk_start:
.thunk_start_b0:
  call main
  mv v2, zero
  mv a0, v2
  ret

  .p2align 3
  .globl g
  .type g, @function
g:
.g_b0:
  mv v0, s10
  mv v2, a0
  lw v3, 8(v0)
  mv a0, v3
  ret

  .p2align 3
  .globl dummy
  .type dummy, @function
dummy:
.dummy_b0:
  mv v2, a0
  mv a0, v2
  ret

  .p2align 3
  .globl main
  .type main, @function
main:
.main_b0:
  mv a0, zero
  ret

  .p2align 3
  .globl start
  .type start, @object
start:
  .zero 4



Testing test/test_src/even-odd.mbt
# name conventions used in the core ir:
# - functions: f<id>
# - blocks: b<id>
# - instructions: %<id>
# - memory: m<id>
# - free variables: ^<id>
# - function parameters: $f<pid>
# - block parameters: $b<bid>.<pid>
.core
.fn even #f2 : fn(int32) -> int32
.freevars ()
.entry b0 {
  .bb #b6 (int32) {
    return $b6.0
  }
  .bb #b4 () {
    let %4: int32 = sub($f0, 1)
    let %5: int32 = apply f2.m0(%4)
    jump b5(%5)
  }
  .bb #b1 () {
    let %2: bool = eq($f0, 0)
    br %2 b3() b4()
  }
  .bb #b5 (int32) {
    jump b6($b5.0)
  }
  .bb #b2 () {
    let %6: int32 = add($f0, 1)
    let %7: int32 = apply f2.m0(%6)
    jump b6(%7)
  }
  .bb #b3 () {
    let %3: int32 = load_symbol ::0
    jump b5(%3)
  }
  .bb #b0 () {
    let _ = alloc <m0: closure(int32) -> int32 heap(1)> <- [0] = f3
    let %1: bool = le(0, $f0)
    br %1 b1() b2()
  }
}
.fn main #f4 : fn() -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: int32 = call f2(789)
    let %1: unit = ext_call minimbt_print_int(%0)
    return %1
  }
}
.fn odd #f3 : closure(int32) -> int32
.freevars ()
.entry b0 {
  .bb #b6 (int32) {
    return $b6.0
  }
  .bb #b4 () {
    let %3: int32 = sub($f0, 1)
    let %4: int32 = call f2(%3)
    jump b5(%4)
  }
  .bb #b1 () {
    let %1: bool = eq($f0, 0)
    br %1 b3() b4()
  }
  .bb #b5 (int32) {
    jump b6($b5.0)
  }
  .bb #b2 () {
    let %5: int32 = add($f0, 1)
    let %6: int32 = call f2(%5)
    jump b6(%6)
  }
  .bb #b3 () {
    let %2: int32 = load_symbol ::1
    jump b5(%2)
  }
  .bb #b0 () {
    let %0: bool = le(0, $f0)
    br %0 b1() b2()
  }
}
.fn thunk_start #f5 : fn() -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: unit = call f4()
    return %0
  }
}
.fn thunk_t.1 #f0 : fn() -> int32
.freevars ()
.entry b0 {
  .bb #b0 () {
    return 123
  }
}
.fn thunk_f.2 #f1 : fn() -> int32
.freevars ()
.entry b0 {
  .bb #b0 () {
    return 456
  }
}
.thunk ::0 t.1
.thunk ::1 f.2
.thunk ::2 start

  .p2align 3
  .globl even
  .type even, @function
even:
.even_b0:
  mv v2, a0
  addi v28, s11, -8
  andi v3, v28, -8
  la v30, odd
  sd v30, 0(v3)
  slt v26, zero, v2
  xori v5, v26, 1
  bne v5, zero, .even_b1
  j .even_b2

.even_b3:
  la v14, t.1
  lw v11, 0(v14)
  mv v12, v11
  j .even_b5

.even_b5:
  mv v13, v12
  j .even_b6

.even_b1:
  xor v20, v2, zero
  sltiu v8, v20, 1
  bne v8, zero, .even_b3
  j .even_b4

.even_b6:
  mv a0, v13
  ret

.even_b4:
  li v18, 1
  sub v9, v2, v18
  mv s10, v3
  ld v16, 0(v3)
  mv a0, v9
  jalr v16
  mv v10, a0
  mv v12, v10
  j .even_b5

.even_b2:
  li v24, 1
  add v6, v2, v24
  mv s10, v3
  ld v22, 0(v3)
  mv a0, v6
  jalr v22
  mv v7, a0
  mv v13, v7
  j .even_b6

  .p2align 3
  .globl main
  .type main, @function
main:
.main_b0:
  li v5, 789
  mv a0, v5
  call even
  mv v2, a0
  mv a0, v2
  call minimbt_print_int
  mv v3, zero
  mv a0, v3
  ret

  .p2align 3
  .globl odd
  .type odd, @function
odd:
.odd_b0:
  mv v2, a0
  slt v22, zero, v2
  xori v3, v22, 1
  bne v3, zero, .odd_b1
  j .odd_b2

.odd_b2:
  li v20, 1
  add v4, v2, v20
  mv a0, v4
  call even
  mv v5, a0
  mv v11, v5
  j .odd_b6

.odd_b1:
  xor v17, v2, zero
  sltiu v6, v17, 1
  bne v6, zero, .odd_b3
  j .odd_b4

.odd_b4:
  li v15, 1
  sub v7, v2, v15
  mv a0, v7
  call even
  mv v8, a0
  mv v10, v8
  j .odd_b5

.odd_b6:
  mv a0, v11
  ret

.odd_b5:
  mv v11, v10
  j .odd_b6

.odd_b3:
  la v12, f.2
  lw v9, 0(v12)
  mv v10, v9
  j .odd_b5

  .p2align 3
  .globl _start
  .type _start, @function
_start:
_start_b0:
  call thunk_t.1
  la t6, t.1
  sw a0, 0(t6)
  call thunk_f.2
  la t6, f.2
  sw a0, 0(t6)
  call thunk_start
  ret

  .p2align 3
  .globl thunk_start
  .type thunk_start, @function
thunk_start:
.thunk_start_b0:
  call main
  mv v2, zero
  mv a0, v2
  ret

  .p2align 3
  .globl thunk_t.1
  .type thunk_t.1, @function
thunk_t.1:
.thunk_t.1_b0:
  li v2, 123
  mv a0, v2
  ret

  .p2align 3
  .globl thunk_f.2
  .type thunk_f.2, @function
thunk_f.2:
.thunk_f.2_b0:
  li v2, 456
  mv a0, v2
  ret

  .p2align 3
  .globl t.1
  .type t.1, @object
t.1:
  .zero 4
  .p2align 3
  .globl f.2
  .type f.2, @object
f.2:
  .zero 4
  .p2align 3
  .globl start
  .type start, @object
start:
  .zero 4



Testing test/test_src/fib.mbt
# name conventions used in the core ir:
# - functions: f<id>
# - blocks: b<id>
# - instructions: %<id>
# - memory: m<id>
# - free variables: ^<id>
# - function parameters: $f<pid>
# - block parameters: $b<bid>.<pid>
.core
.fn fib #f0 : fn(int32) -> int32
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: bool = le($f0, 1)
    br %0 b1() b2()
  }
  .bb #b1 () {
    jump b3($f0)
  }
  .bb #b2 () {
    let %1: int32 = sub($f0, 1)
    let %2: int32 = call f0(%1)
    let %3: int32 = sub($f0, 2)
    let %4: int32 = call f0(%3)
    let %5: int32 = add(%2, %4)
    jump b3(%5)
  }
  .bb #b3 (int32) {
    return $b3.0
  }
}
.fn thunk_start #f2 : fn() -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: unit = call f1()
    return %0
  }
}
.fn main #f1 : fn() -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: int32 = call f0(30)
    let %1: unit = ext_call minimbt_print_int(%0)
    return %1
  }
}
.thunk ::0 start

  .p2align 3
  .globl _start
  .type _start, @function
_start:
_start_b0:
  call thunk_start
  ret

  .p2align 3
  .globl fib
  .type fib, @function
fib:
.fib_b0:
  mv v2, a0
  li v17, 1
  slt v18, v2, v17
  xori v3, v18, 1
  bne v3, zero, .fib_b1
  j .fib_b2

.fib_b3:
  mv a0, v9
  ret

.fib_b2:
  li v15, 1
  sub v4, v2, v15
  mv a0, v4
  call fib
  mv v5, a0
  li v12, 2
  sub v6, v2, v12
  mv a0, v6
  call fib
  mv v7, a0
  add v8, v5, v7
  mv v9, v8
  j .fib_b3

.fib_b1:
  mv v9, v2
  j .fib_b3

  .p2align 3
  .globl thunk_start
  .type thunk_start, @function
thunk_start:
.thunk_start_b0:
  call main
  mv v2, zero
  mv a0, v2
  ret

  .p2align 3
  .globl main
  .type main, @function
main:
.main_b0:
  li v5, 30
  mv a0, v5
  call fib
  mv v2, a0
  mv a0, v2
  call minimbt_print_int
  mv v3, zero
  mv a0, v3
  ret

  .p2align 3
  .globl start
  .type start, @object
start:
  .zero 4



Testing test/test_src/float.mbt
# name conventions used in the core ir:
# - functions: f<id>
# - blocks: b<id>
# - instructions: %<id>
# - memory: m<id>
# - free variables: ^<id>
# - function parameters: $f<pid>
# - block parameters: $b<bid>.<pid>
.core
.fn thunk_start #f1 : fn() -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: unit = call f0()
    return %0
  }
}
.fn main #f0 : fn() -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: double = neg(12.3)
    let %1: double = abs(%0)
    let %2: double = sqrt(%1)
    let %3: double = ext_call minimbt_cos(%2)
    let %4: double = ext_call minimbt_sin(%3)
    let %5: double = add(%4, 4.5)
    let %6: double = mul(6.7, 8.9)
    let %7: double = div(%6, 1.23456789)
    let %8: double = sub(%5, %7)
    let %9: double = conv.i2d(1000000)
    let %10: double = mul(%8, %9)
    let %11: int32 = conv.d2i.rtz(%10)
    let %12: unit = ext_call minimbt_print_int(%11)
    return %12
  }
}
.thunk ::0 start

  .p2align 3
  .globl _start
  .type _start, @function
_start:
_start_b0:
  call thunk_start
  ret

  .p2align 3
  .globl thunk_start
  .type thunk_start, @function
thunk_start:
.thunk_start_b0:
  call main
  mv v2, zero
  mv a0, v2
  ret

  .p2align 3
  .globl main
  .type main, @function
main:
.main_b0:
  li v36, 4623113902481840538
  fmv.d.x fv37, v36
  fneg.d fv2, fv37
  fabs.d fv3, fv2
  fsqrt.d fv4, fv3
  fmv.d fa0, fv4
  call minimbt_cos
  fmv.d fv5, fa0
  fmv.d fa0, fv5
  call minimbt_sin
  fmv.d fv6, fa0
  li v29, 4616752568008179712
  fmv.d.x fv30, v29
  fadd.d fv7, fv6, fv30
  li v24, 4619229547803233485
  fmv.d.x fv25, v24
  li v26, 4621199872640208077
  fmv.d.x fv27, v26
  fmul.d fv8, fv25, fv27
  li v21, 4608238818662014491
  fmv.d.x fv22, v21
  fdiv.d fv9, fv8, fv22
  fsub.d fv10, fv7, fv9
  li v18, 1000000
  fcvt.d.w fv11, v18
  fmul.d fv12, fv10, fv11
  fcvt.w.d v13, fv12, rtz
  mv a0, v13
  call minimbt_print_int
  mv v14, zero
  mv a0, v14
  ret

  .p2align 3
  .globl start
  .type start, @object
start:
  .zero 4



Testing test/test_src/funcomp.mbt
# name conventions used in the core ir:
# - functions: f<id>
# - blocks: b<id>
# - instructions: %<id>
# - memory: m<id>
# - free variables: ^<id>
# - function parameters: $f<pid>
# - block parameters: $b<bid>.<pid>
.core
.fn thunk_start #f6 : fn() -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: unit = call f5()
    return %0
  }
}
.fn compose #f0 : fn(closure(int32) -> int32, closure(int32) -> int32) -> closure(int32) -> int32
.freevars ()
.entry b0 {
  .bb #b0 () {
    let _ = alloc <m0: closure(int32) -> int32 heap(3)> <- [0] = f1, [1] = $f0, [2] = $f1
    return f0.m0
  }
}
.fn dec #f4 : fn(int32) -> int32
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: int32 = sub($f0, 1)
    return %0
  }
}
.fn dbl #f2 : fn(int32) -> int32
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: int32 = add($f0, $f0)
    return %0
  }
}
.fn composed #f1 : closure(int32) -> int32
.freevars (closure(int32) -> int32, closure(int32) -> int32)
.entry b0 {
  .bb #b0 () {
    let %0: int32 = apply ^1($f0)
    let %1: int32 = apply ^2(%0)
    return %1
  }
}
.fn inc #f3 : fn(int32) -> int32
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: int32 = add($f0, 1)
    return %0
  }
}
.fn main #f5 : fn() -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let _ = alloc <m0: closure(int32) -> int32 heap(1)> <- [0] = f2
    let _ = alloc <m1: closure(int32) -> int32 heap(1)> <- [0] = f4
    let %2: closure(int32) -> int32 = call f0(f5.m0, f5.m1)
    let _ = alloc <m2: closure(int32) -> int32 heap(1)> <- [0] = f3
    let %4: closure(int32) -> int32 = call f0(f5.m2, %2)
    let %5: int32 = apply %4(123)
    let %6: unit = ext_call minimbt_print_int(%5)
    return %6
  }
}
.thunk ::0 start

  .p2align 3
  .globl _start
  .type _start, @function
_start:
_start_b0:
  call thunk_start
  ret

  .p2align 3
  .globl thunk_start
  .type thunk_start, @function
thunk_start:
.thunk_start_b0:
  call main
  mv v2, zero
  mv a0, v2
  ret

  .p2align 3
  .globl dec
  .type dec, @function
dec:
.dec_b0:
  mv v2, a0
  li v4, 1
  sub v3, v2, v4
  mv a0, v3
  ret

  .p2align 3
  .globl compose
  .type compose, @function
compose:
.compose_b0:
  mv v2, a0
  mv v3, a1
  addi v6, s11, -24
  andi v4, v6, -8
  la v8, composed
  sd v8, 0(v4)
  sd v2, 8(v4)
  sd v3, 16(v4)
  mv a0, v4
  ret

  .p2align 3
  .globl dbl
  .type dbl, @function
dbl:
.dbl_b0:
  mv v2, a0
  add v3, v2, v2
  mv a0, v3
  ret

  .p2align 3
  .globl composed
  .type composed, @function
composed:
.composed_b0:
  mv v0, s10
  mv v2, a0
  lw v3, 8(v0)
  lw v4, 16(v0)
  mv s10, v3
  ld v9, 0(v3)
  mv a0, v2
  jalr v9
  mv v5, a0
  mv s10, v4
  ld v7, 0(v4)
  mv a0, v5
  jalr v7
  mv v6, a0
  mv a0, v6
  ret

  .p2align 3
  .globl inc
  .type inc, @function
inc:
.inc_b0:
  mv v2, a0
  li v4, 1
  add v3, v2, v4
  mv a0, v3
  ret

  .p2align 3
  .globl main
  .type main, @function
main:
.main_b0:
  addi v24, s11, -8
  andi v2, v24, -8
  la v26, dbl
  sd v26, 0(v2)
  addi v21, s11, -8
  andi v3, v21, -8
  la v23, dec
  sd v23, 0(v3)
  mv a0, v2
  mv a1, v3
  call compose
  mv v7, a0
  addi v17, s11, -8
  andi v4, v17, -8
  la v19, inc
  sd v19, 0(v4)
  mv a0, v4
  mv a1, v7
  call compose
  mv v9, a0
  mv s10, v9
  ld v13, 0(v9)
  li v14, 123
  mv a0, v14
  jalr v13
  mv v10, a0
  mv a0, v10
  call minimbt_print_int
  mv v11, zero
  mv a0, v11
  ret

  .p2align 3
  .globl start
  .type start, @object
start:
  .zero 4



Testing test/test_src/gcd.mbt
# name conventions used in the core ir:
# - functions: f<id>
# - blocks: b<id>
# - instructions: %<id>
# - memory: m<id>
# - free variables: ^<id>
# - function parameters: $f<pid>
# - block parameters: $b<bid>.<pid>
.core
.fn gcd #f0 : fn(int32, int32) -> int32
.freevars ()
.entry b0 {
  .bb #b6 (int32) {
    return $b6.0
  }
  .bb #b4 () {
    let %4: int32 = sub($f0, $f1)
    let %5: int32 = call f0($f1, %4)
    jump b5(%5)
  }
  .bb #b1 () {
    jump b6($f1)
  }
  .bb #b5 (int32) {
    jump b6($b5.0)
  }
  .bb #b2 () {
    let %1: bool = le($f0, $f1)
    br %1 b3() b4()
  }
  .bb #b3 () {
    let %2: int32 = sub($f1, $f0)
    let %3: int32 = call f0($f0, %2)
    jump b5(%3)
  }
  .bb #b0 () {
    let %0: bool = eq($f0, 0)
    br %0 b1() b2()
  }
}
.fn thunk_start #f2 : fn() -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: unit = call f1()
    return %0
  }
}
.fn main #f1 : fn() -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: int32 = call f0(21600, 337500)
    let %1: unit = ext_call minimbt_print_int(%0)
    return %1
  }
}
.thunk ::0 start

  .p2align 3
  .globl _start
  .type _start, @function
_start:
_start_b0:
  call thunk_start
  ret

  .p2align 3
  .globl gcd
  .type gcd, @function
gcd:
.gcd_b0:
  mv v2, a0
  mv v3, a1
  xor v18, v2, zero
  sltiu v4, v18, 1
  bne v4, zero, .gcd_b1
  j .gcd_b2

.gcd_b6:
  mv a0, v11
  ret

.gcd_b1:
  mv v11, v3
  j .gcd_b6

.gcd_b4:
  sub v6, v2, v3
  mv a0, v3
  mv a1, v6
  call gcd
  mv v7, a0
  mv v10, v7
  j .gcd_b5

.gcd_b3:
  sub v8, v3, v2
  mv a0, v2
  mv a1, v8
  call gcd
  mv v9, a0
  mv v10, v9
  j .gcd_b5

.gcd_b2:
  slt v16, v2, v3
  xori v5, v16, 1
  bne v5, zero, .gcd_b3
  j .gcd_b4

.gcd_b5:
  mv v11, v10
  j .gcd_b6

  .p2align 3
  .globl thunk_start
  .type thunk_start, @function
thunk_start:
.thunk_start_b0:
  call main
  mv v2, zero
  mv a0, v2
  ret

  .p2align 3
  .globl main
  .type main, @function
main:
.main_b0:
  li v5, 21600
  mv a0, v5
  li v6, 337500
  mv a1, v6
  call gcd
  mv v2, a0
  mv a0, v2
  call minimbt_print_int
  mv v3, zero
  mv a0, v3
  ret

  .p2align 3
  .globl start
  .type start, @object
start:
  .zero 4



Testing test/test_src/id.mbt
# name conventions used in the core ir:
# - functions: f<id>
# - blocks: b<id>
# - instructions: %<id>
# - memory: m<id>
# - free variables: ^<id>
# - function parameters: $f<pid>
# - block parameters: $b<bid>.<pid>
.core
.fn f #f0 : fn(int32) -> int32
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: int32 = add($f0, 1)
    return %0
  }
}
.fn thunk_start #f2 : fn() -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: unit = call f1()
    return %0
  }
}
.fn main #f1 : fn() -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: int32 = call f0(1000)
    let %1: unit = ext_call minimbt_print_int(%0)
    return %1
  }
}
.thunk ::0 start

  .p2align 3
  .globl _start
  .type _start, @function
_start:
_start_b0:
  call thunk_start
  ret

  .p2align 3
  .globl f
  .type f, @function
f:
.f_b0:
  mv v2, a0
  li v4, 1
  add v3, v2, v4
  mv a0, v3
  ret

  .p2align 3
  .globl thunk_start
  .type thunk_start, @function
thunk_start:
.thunk_start_b0:
  call main
  mv v2, zero
  mv a0, v2
  ret

  .p2align 3
  .globl main
  .type main, @function
main:
.main_b0:
  li v5, 1000
  mv a0, v5
  call f
  mv v2, a0
  mv a0, v2
  call minimbt_print_int
  mv v3, zero
  mv a0, v3
  ret

  .p2align 3
  .globl start
  .type start, @object
start:
  .zero 4



Testing test/test_src/inprod-loop.mbt
# name conventions used in the core ir:
# - functions: f<id>
# - blocks: b<id>
# - instructions: %<id>
# - memory: m<id>
# - free variables: ^<id>
# - function parameters: $f<pid>
# - block parameters: $b<bid>.<pid>
.core
.fn inprod #f0 : fn(array[double], array[double], double, int32) -> double
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: bool = le(0, $f3)
    br %0 b1() b2()
  }
  .bb #b1 () {
    let %1: double = load double offset($f0, $f3)
    let %2: double = load double offset($f1, $f3)
    let %3: double = mul(%1, %2)
    let %4: double = add($f2, %3)
    let %5: int32 = sub($f3, 1)
    let %6: double = call f0($f0, $f1, %4, %5)
    jump b3(%6)
  }
  .bb #b2 () {
    jump b3($f2)
  }
  .bb #b3 (double) {
    return $b3.0
  }
}
.fn thunk_start #f2 : fn() -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: unit = call f1()
    return %0
  }
}
.fn main #f1 : fn() -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let _ = alloc <m0: array[double] heap(3)> <- [..] = 1.23
    let _ = alloc <m1: array[double] heap(3)> <- [..] = 4.56
    let %2: double = call f0(f1.m0, f1.m1, 0, 2)
    let %3: double = mul(1000000, %2)
    let %4: int32 = ext_call minimbt_truncate(%3)
    let %5: unit = ext_call minimbt_print_int(%4)
    return %5
  }
}
.thunk ::0 start

  .p2align 3
  .globl _start
  .type _start, @function
_start:
_start_b0:
  call thunk_start
  ret

  .p2align 3
  .globl inprod
  .type inprod, @function
inprod:
.inprod_b0:
  mv v2, a0
  mv v3, a1
  fmv.d fv4, fa0
  mv v5, a2
  slt v25, zero, v5
  xori v6, v25, 1
  bne v6, zero, .inprod_b1
  j .inprod_b2

.inprod_b2:
  fmv.d fv13, fv4
  j .inprod_b3

.inprod_b1:
  slli v22, v5, 3
  add v23, v2, v22
  fld fv7, 0(v23)
  slli v19, v5, 3
  add v20, v3, v19
  fld fv8, 0(v20)
  fmul.d fv9, fv7, fv8
  fadd.d fv10, fv4, fv9
  li v15, 1
  sub v11, v5, v15
  mv a0, v2
  mv a1, v3
  fmv.d fa0, fv10
  mv a2, v11
  call inprod
  fmv.d fv12, fa0
  fmv.d fv13, fv12
  j .inprod_b3

.inprod_b3:
  mv a0, v13
  ret

  .p2align 3
  .globl thunk_start
  .type thunk_start, @function
thunk_start:
.thunk_start_b0:
  call main
  mv v2, zero
  mv a0, v2
  ret

  .p2align 3
  .globl main
  .type main, @function
main:
.main_b0:
  addi v22, s11, -24
  andi v2, v22, -8
  li v24, 4608218246714312622
  fmv.d.x fv25, v24
  fsd fv25, 0(v2)
  fsd fv25, 8(v2)
  fsd fv25, 16(v2)
  addi v18, s11, -24
  andi v3, v18, -8
  li v20, 4616820122002590269
  fmv.d.x fv21, v20
  fsd fv21, 0(v3)
  fsd fv21, 8(v3)
  fsd fv21, 16(v3)
  mv a0, v2
  mv a1, v3
  fmv.d.x fv15, zero
  fmv.d fa0, fv15
  li v16, 2
  mv a2, v16
  call inprod
  fmv.d fv6, fa0
  li v12, 4696837146684686336
  fmv.d.x fv13, v12
  fmul.d fv7, fv13, fv6
  fmv.d fa0, fv7
  call minimbt_truncate
  mv v8, a0
  mv a0, v8
  call minimbt_print_int
  mv v9, zero
  mv a0, v9
  ret

  .p2align 3
  .globl start
  .type start, @object
start:
  .zero 4



Testing test/test_src/inprod-rec.mbt
# name conventions used in the core ir:
# - functions: f<id>
# - blocks: b<id>
# - instructions: %<id>
# - memory: m<id>
# - free variables: ^<id>
# - function parameters: $f<pid>
# - block parameters: $b<bid>.<pid>
.core
.fn inprod #f0 : fn(array[double], array[double], int32) -> double
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: bool = le(0, $f2)
    br %0 b1() b2()
  }
  .bb #b1 () {
    let %1: double = load double offset($f0, $f2)
    let %2: double = load double offset($f1, $f2)
    let %3: double = mul(%1, %2)
    let %4: int32 = sub($f2, 1)
    let %5: double = call f0($f0, $f1, %4)
    let %6: double = add(%3, %5)
    jump b3(%6)
  }
  .bb #b2 () {
    jump b3(0)
  }
  .bb #b3 (double) {
    return $b3.0
  }
}
.fn thunk_start #f2 : fn() -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: unit = call f1()
    return %0
  }
}
.fn main #f1 : fn() -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let _ = alloc <m0: array[double] heap(3)> <- [..] = 1.23
    let _ = alloc <m1: array[double] heap(3)> <- [..] = 4.56
    let %2: double = call f0(f1.m0, f1.m1, 2)
    let %3: double = mul(1000000, %2)
    let %4: int32 = ext_call minimbt_truncate(%3)
    let %5: unit = ext_call minimbt_print_int(%4)
    return %5
  }
}
.thunk ::0 start

  .p2align 3
  .globl _start
  .type _start, @function
_start:
_start_b0:
  call thunk_start
  ret

  .p2align 3
  .globl inprod
  .type inprod, @function
inprod:
.inprod_b0:
  mv v2, a0
  mv v3, a1
  mv v4, a2
  slt v25, zero, v4
  xori v5, v25, 1
  bne v5, zero, .inprod_b1
  j .inprod_b2

.inprod_b2:
  fmv.d.x fv24, zero
  fmv.d fv12, fv24
  j .inprod_b3

.inprod_b1:
  slli v21, v4, 3
  add v22, v2, v21
  fld fv6, 0(v22)
  slli v18, v4, 3
  add v19, v3, v18
  fld fv7, 0(v19)
  fmul.d fv8, fv6, fv7
  li v15, 1
  sub v9, v4, v15
  mv a0, v2
  mv a1, v3
  mv a2, v9
  call inprod
  fmv.d fv10, fa0
  fadd.d fv11, fv8, fv10
  fmv.d fv12, fv11
  j .inprod_b3

.inprod_b3:
  mv a0, v12
  ret

  .p2align 3
  .globl thunk_start
  .type thunk_start, @function
thunk_start:
.thunk_start_b0:
  call main
  mv v2, zero
  mv a0, v2
  ret

  .p2align 3
  .globl main
  .type main, @function
main:
.main_b0:
  addi v21, s11, -24
  andi v2, v21, -8
  li v23, 4608218246714312622
  fmv.d.x fv24, v23
  fsd fv24, 0(v2)
  fsd fv24, 8(v2)
  fsd fv24, 16(v2)
  addi v17, s11, -24
  andi v3, v17, -8
  li v19, 4616820122002590269
  fmv.d.x fv20, v19
  fsd fv20, 0(v3)
  fsd fv20, 8(v3)
  fsd fv20, 16(v3)
  mv a0, v2
  mv a1, v3
  li v15, 2
  mv a2, v15
  call inprod
  fmv.d fv6, fa0
  li v12, 4696837146684686336
  fmv.d.x fv13, v12
  fmul.d fv7, fv13, fv6
  fmv.d fa0, fv7
  call minimbt_truncate
  mv v8, a0
  mv a0, v8
  call minimbt_print_int
  mv v9, zero
  mv a0, v9
  ret

  .p2align 3
  .globl start
  .type start, @object
start:
  .zero 4



Testing test/test_src/inprod.mbt
# name conventions used in the core ir:
# - functions: f<id>
# - blocks: b<id>
# - instructions: %<id>
# - memory: m<id>
# - free variables: ^<id>
# - function parameters: $f<pid>
# - block parameters: $b<bid>.<pid>
.core
.fn gety #f1 : fn((double, double, double)) -> double
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: double = load double field($f0, 0)
    let %1: double = load double field($f0, 1)
    let %2: double = load double field($f0, 2)
    return %1
  }
}
.fn thunk_start #f5 : fn() -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: unit = call f4()
    return %0
  }
}
.fn getx #f0 : fn((double, double, double)) -> double
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: double = load double field($f0, 0)
    let %1: double = load double field($f0, 1)
    let %2: double = load double field($f0, 2)
    return %0
  }
}
.fn inprod #f3 : fn((double, double, double), (double, double, double)) -> double
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: double = call f0($f0)
    let %1: double = call f0($f1)
    let %2: double = mul(%0, %1)
    let %3: double = call f1($f0)
    let %4: double = call f1($f1)
    let %5: double = mul(%3, %4)
    let %6: double = add(%2, %5)
    let %7: double = call f2($f0)
    let %8: double = call f2($f1)
    let %9: double = mul(%7, %8)
    let %10: double = add(%6, %9)
    return %10
  }
}
.fn getz #f2 : fn((double, double, double)) -> double
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: double = load double field($f0, 0)
    let %1: double = load double field($f0, 1)
    let %2: double = load double field($f0, 2)
    return %2
  }
}
.fn main #f4 : fn() -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let _ = alloc <m0: (double, double, double) heap(3)> <- [0] = 1, [1] = 2, [2] = 3
    let _ = alloc <m1: (double, double, double) heap(3)> <- [0] = 4, [1] = 5, [2] = 6
    let %2: double = call f3(f4.m0, f4.m1)
    let %3: double = mul(1000000, %2)
    let %4: int32 = ext_call minimbt_truncate(%3)
    let %5: unit = ext_call minimbt_print_int(%4)
    return %5
  }
}
.thunk ::0 start

  .p2align 3
  .globl _start
  .type _start, @function
_start:
_start_b0:
  call thunk_start
  ret

  .p2align 3
  .globl gety
  .type gety, @function
gety:
.gety_b0:
  mv v2, a0
  fld fv4, 8(v2)
  mv a0, v4
  ret

  .p2align 3
  .globl thunk_start
  .type thunk_start, @function
thunk_start:
.thunk_start_b0:
  call main
  mv v2, zero
  mv a0, v2
  ret

  .p2align 3
  .globl getx
  .type getx, @function
getx:
.getx_b0:
  mv v2, a0
  fld fv3, 0(v2)
  mv a0, v3
  ret

  .p2align 3
  .globl inprod
  .type inprod, @function
inprod:
.inprod_b0:
  mv v2, a0
  mv v3, a1
  mv a0, v2
  call getx
  fmv.d fv4, fa0
  mv a0, v3
  call getx
  fmv.d fv5, fa0
  fmul.d fv6, fv4, fv5
  mv a0, v2
  call gety
  fmv.d fv7, fa0
  mv a0, v3
  call gety
  fmv.d fv8, fa0
  fmul.d fv9, fv7, fv8
  fadd.d fv10, fv6, fv9
  mv a0, v2
  call getz
  fmv.d fv11, fa0
  mv a0, v3
  call getz
  fmv.d fv12, fa0
  fmul.d fv13, fv11, fv12
  fadd.d fv14, fv10, fv13
  mv a0, v14
  ret

  .p2align 3
  .globl getz
  .type getz, @function
getz:
.getz_b0:
  mv v2, a0
  fld fv5, 16(v2)
  mv a0, v5
  ret

  .p2align 3
  .globl main
  .type main, @function
main:
.main_b0:
  addi v24, s11, -24
  andi v2, v24, -8
  li v26, 4607182418800017408
  fmv.d.x fv27, v26
  fsd fv27, 0(v2)
  li v28, 4611686018427387904
  fmv.d.x fv29, v28
  fsd fv29, 8(v2)
  li v30, 4613937818241073152
  fmv.d.x fv31, v30
  fsd fv31, 16(v2)
  addi v16, s11, -24
  andi v3, v16, -8
  li v18, 4616189618054758400
  fmv.d.x fv19, v18
  fsd fv19, 0(v3)
  li v20, 4617315517961601024
  fmv.d.x fv21, v20
  fsd fv21, 8(v3)
  li v22, 4618441417868443648
  fmv.d.x fv23, v22
  fsd fv23, 16(v3)
  mv a0, v2
  mv a1, v3
  call inprod
  fmv.d fv6, fa0
  li v12, 4696837146684686336
  fmv.d.x fv13, v12
  fmul.d fv7, fv13, fv6
  fmv.d fa0, fv7
  call minimbt_truncate
  mv v8, a0
  mv a0, v8
  call minimbt_print_int
  mv v9, zero
  mv a0, v9
  ret

  .p2align 3
  .globl start
  .type start, @object
start:
  .zero 4



Testing test/test_src/join-reg.mbt
# name conventions used in the core ir:
# - functions: f<id>
# - blocks: b<id>
# - instructions: %<id>
# - memory: m<id>
# - free variables: ^<id>
# - function parameters: $f<pid>
# - block parameters: $b<bid>.<pid>
.core
.fn f #f0 : fn(unit) -> int32
.freevars ()
.entry b0 {
  .bb #b0 () {
    return 123
  }
}
.fn thunk_start #f4 : fn() -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: unit = call f3()
    return %0
  }
}
.fn h #f2 : fn(unit) -> int32
.freevars ()
.entry b0 {
  .bb #b0 () {
    return 789
  }
}
.fn g #f1 : fn(unit) -> int32
.freevars ()
.entry b0 {
  .bb #b0 () {
    return 456
  }
}
.fn main #f3 : fn() -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: int32 = call f0(())
    let %1: int32 = call f1(())
    let %2: int32 = call f2(())
    let %3: bool = eq(%2, 0)
    br %3 b1() b2()
  }
  .bb #b1 () {
    let %4: int32 = sub(%0, %1)
    jump b3(%4)
  }
  .bb #b2 () {
    let %5: int32 = sub(%1, %0)
    let %6: int32 = add(%5, %0)
    let %7: int32 = add(%6, %1)
    jump b3(%7)
  }
  .bb #b3 (int32) {
    let %8: unit = ext_call minimbt_print_int($b3.0)
    return %8
  }
}
.thunk ::0 start

  .p2align 3
  .globl _start
  .type _start, @function
_start:
_start_b0:
  call thunk_start
  ret

  .p2align 3
  .globl f
  .type f, @function
f:
.f_b0:
  mv v2, a0
  li v3, 123
  mv a0, v3
  ret

  .p2align 3
  .globl thunk_start
  .type thunk_start, @function
thunk_start:
.thunk_start_b0:
  call main
  mv v2, zero
  mv a0, v2
  ret

  .p2align 3
  .globl h
  .type h, @function
h:
.h_b0:
  mv v2, a0
  li v3, 789
  mv a0, v3
  ret

  .p2align 3
  .globl g
  .type g, @function
g:
.g_b0:
  mv v2, a0
  li v3, 456
  mv a0, v3
  ret

  .p2align 3
  .globl main
  .type main, @function
main:
.main_b0:
  mv a0, zero
  call f
  mv v2, a0
  mv a0, zero
  call g
  mv v3, a0
  mv a0, zero
  call h
  mv v4, a0
  xor v17, v4, zero
  sltiu v5, v17, 1
  bne v5, zero, .main_b1
  j .main_b2

.main_b3:
  mv a0, v10
  call minimbt_print_int
  mv v11, zero
  mv a0, v11
  ret

.main_b1:
  sub v9, v2, v3
  mv v10, v9
  j .main_b3

.main_b2:
  sub v6, v3, v2
  add v7, v6, v2
  add v8, v7, v3
  mv v10, v8
  j .main_b3

  .p2align 3
  .globl start
  .type start, @object
start:
  .zero 4



Testing test/test_src/join-reg2.mbt
# name conventions used in the core ir:
# - functions: f<id>
# - blocks: b<id>
# - instructions: %<id>
# - memory: m<id>
# - free variables: ^<id>
# - function parameters: $f<pid>
# - block parameters: $b<bid>.<pid>
.core
.fn f #f0 : fn(unit) -> int32
.freevars ()
.entry b0 {
  .bb #b0 () {
    return 123
  }
}
.fn thunk_start #f4 : fn() -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: unit = call f3()
    return %0
  }
}
.fn h #f2 : fn(unit) -> int32
.freevars ()
.entry b0 {
  .bb #b0 () {
    return 789
  }
}
.fn g #f1 : fn(unit) -> int32
.freevars ()
.entry b0 {
  .bb #b0 () {
    return 456
  }
}
.fn main #f3 : fn() -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: int32 = call f0(())
    let %1: bool = le(%0, 0)
    br %1 b1() b2()
  }
  .bb #b1 () {
    let %2: int32 = call f1(())
    let %3: int32 = add(%2, %0)
    jump b3(%3)
  }
  .bb #b2 () {
    let %4: int32 = call f2(())
    let %5: int32 = sub(%4, %0)
    let %6: int32 = add(%5, %0)
    jump b3(%6)
  }
  .bb #b3 (int32) {
    let %7: unit = ext_call minimbt_print_int($b3.0)
    return %7
  }
}
.thunk ::0 start

  .p2align 3
  .globl _start
  .type _start, @function
_start:
_start_b0:
  call thunk_start
  ret

  .p2align 3
  .globl f
  .type f, @function
f:
.f_b0:
  mv v2, a0
  li v3, 123
  mv a0, v3
  ret

  .p2align 3
  .globl thunk_start
  .type thunk_start, @function
thunk_start:
.thunk_start_b0:
  call main
  mv v2, zero
  mv a0, v2
  ret

  .p2align 3
  .globl h
  .type h, @function
h:
.h_b0:
  mv v2, a0
  li v3, 789
  mv a0, v3
  ret

  .p2align 3
  .globl g
  .type g, @function
g:
.g_b0:
  mv v2, a0
  li v3, 456
  mv a0, v3
  ret

  .p2align 3
  .globl main
  .type main, @function
main:
.main_b0:
  mv a0, zero
  call f
  mv v2, a0
  slt v17, v2, zero
  xori v3, v17, 1
  bne v3, zero, .main_b1
  j .main_b2

.main_b3:
  mv a0, v9
  call minimbt_print_int
  mv v10, zero
  mv a0, v10
  ret

.main_b1:
  mv a0, zero
  call g
  mv v7, a0
  add v8, v7, v2
  mv v9, v8
  j .main_b3

.main_b2:
  mv a0, zero
  call h
  mv v4, a0
  sub v5, v4, v2
  add v6, v5, v2
  mv v9, v6
  j .main_b3

  .p2align 3
  .globl start
  .type start, @object
start:
  .zero 4



Testing test/test_src/join-stack.mbt
# name conventions used in the core ir:
# - functions: f<id>
# - blocks: b<id>
# - instructions: %<id>
# - memory: m<id>
# - free variables: ^<id>
# - function parameters: $f<pid>
# - block parameters: $b<bid>.<pid>
.core
.fn f #f0 : fn(unit) -> int32
.freevars ()
.entry b0 {
  .bb #b0 () {
    return 123
  }
}
.fn thunk_start #f4 : fn() -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: unit = call f3()
    return %0
  }
}
.fn h #f2 : fn(unit) -> int32
.freevars ()
.entry b0 {
  .bb #b0 () {
    return 789
  }
}
.fn g #f1 : fn(unit) -> int32
.freevars ()
.entry b0 {
  .bb #b0 () {
    return 456
  }
}
.fn main #f3 : fn() -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: int32 = call f0(())
    let %1: int32 = call f1(())
    let %2: int32 = call f2(())
    let %3: bool = eq(%2, 0)
    br %3 b1() b2()
  }
  .bb #b1 () {
    let %4: int32 = add(%0, 1)
    jump b3(%4)
  }
  .bb #b2 () {
    let %5: int32 = add(%1, 2)
    let %6: int32 = add(%5, %0)
    let %7: int32 = add(%6, %1)
    jump b3(%7)
  }
  .bb #b3 (int32) {
    let %8: unit = ext_call minimbt_print_int($b3.0)
    return %8
  }
}
.thunk ::0 start

  .p2align 3
  .globl _start
  .type _start, @function
_start:
_start_b0:
  call thunk_start
  ret

  .p2align 3
  .globl f
  .type f, @function
f:
.f_b0:
  mv v2, a0
  li v3, 123
  mv a0, v3
  ret

  .p2align 3
  .globl thunk_start
  .type thunk_start, @function
thunk_start:
.thunk_start_b0:
  call main
  mv v2, zero
  mv a0, v2
  ret

  .p2align 3
  .globl h
  .type h, @function
h:
.h_b0:
  mv v2, a0
  li v3, 789
  mv a0, v3
  ret

  .p2align 3
  .globl g
  .type g, @function
g:
.g_b0:
  mv v2, a0
  li v3, 456
  mv a0, v3
  ret

  .p2align 3
  .globl main
  .type main, @function
main:
.main_b0:
  mv a0, zero
  call f
  mv v2, a0
  mv a0, zero
  call g
  mv v3, a0
  mv a0, zero
  call h
  mv v4, a0
  xor v19, v4, zero
  sltiu v5, v19, 1
  bne v5, zero, .main_b1
  j .main_b2

.main_b3:
  mv a0, v10
  call minimbt_print_int
  mv v11, zero
  mv a0, v11
  ret

.main_b1:
  li v13, 1
  add v9, v2, v13
  mv v10, v9
  j .main_b3

.main_b2:
  li v17, 2
  add v6, v3, v17
  add v7, v6, v2
  add v8, v7, v3
  mv v10, v8
  j .main_b3

  .p2align 3
  .globl start
  .type start, @object
start:
  .zero 4



Testing test/test_src/join-stack2.mbt
# name conventions used in the core ir:
# - functions: f<id>
# - blocks: b<id>
# - instructions: %<id>
# - memory: m<id>
# - free variables: ^<id>
# - function parameters: $f<pid>
# - block parameters: $b<bid>.<pid>
.core
.fn main #f2 : fn() -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: int32 = call f0(())
    let %1: bool = le(%0, 0)
    br %1 b1() b2()
  }
  .bb #b1 () {
    let %2: int32 = call f1(())
    let %3: int32 = add(%2, %0)
    jump b3(%3)
  }
  .bb #b2 () {
    let %4: int32 = add(%0, %0)
    jump b3(%4)
  }
  .bb #b3 (int32) {
    let %5: unit = ext_call minimbt_print_int($b3.0)
    return %5
  }
}
.fn f #f0 : fn(unit) -> int32
.freevars ()
.entry b0 {
  .bb #b0 () {
    return 123
  }
}
.fn thunk_start #f3 : fn() -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: unit = call f2()
    return %0
  }
}
.fn g #f1 : fn(unit) -> int32
.freevars ()
.entry b0 {
  .bb #b0 () {
    return 456
  }
}
.thunk ::0 start

  .p2align 3
  .globl _start
  .type _start, @function
_start:
_start_b0:
  call thunk_start
  ret

  .p2align 3
  .globl f
  .type f, @function
f:
.f_b0:
  mv v2, a0
  li v3, 123
  mv a0, v3
  ret

  .p2align 3
  .globl thunk_start
  .type thunk_start, @function
thunk_start:
.thunk_start_b0:
  call main
  mv v2, zero
  mv a0, v2
  ret

  .p2align 3
  .globl g
  .type g, @function
g:
.g_b0:
  mv v2, a0
  li v3, 456
  mv a0, v3
  ret

  .p2align 3
  .globl main
  .type main, @function
main:
.main_b0:
  mv a0, zero
  call f
  mv v2, a0
  slt v13, v2, zero
  xori v3, v13, 1
  bne v3, zero, .main_b1
  j .main_b2

.main_b3:
  mv a0, v7
  call minimbt_print_int
  mv v8, zero
  mv a0, v8
  ret

.main_b1:
  mv a0, zero
  call g
  mv v5, a0
  add v6, v5, v2
  mv v7, v6
  j .main_b3

.main_b2:
  add v4, v2, v2
  mv v7, v4
  j .main_b3

  .p2align 3
  .globl start
  .type start, @object
start:
  .zero 4



Testing test/test_src/join-stack3.mbt
# name conventions used in the core ir:
# - functions: f<id>
# - blocks: b<id>
# - instructions: %<id>
# - memory: m<id>
# - free variables: ^<id>
# - function parameters: $f<pid>
# - block parameters: $b<bid>.<pid>
.core
.fn f #f0 : fn(unit) -> int32
.freevars ()
.entry b0 {
  .bb #b0 () {
    return 123
  }
}
.fn thunk_start #f4 : fn() -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: unit = call f3()
    return %0
  }
}
.fn h #f2 : fn(unit) -> int32
.freevars ()
.entry b0 {
  .bb #b0 () {
    return 789
  }
}
.fn g #f1 : fn(unit) -> int32
.freevars ()
.entry b0 {
  .bb #b0 () {
    return 456
  }
}
.fn main #f3 : fn() -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: int32 = call f0(())
    let %1: bool = le(%0, 0)
    br %1 b1() b2()
  }
  .bb #b1 () {
    let %2: int32 = call f1(())
    jump b3(%2)
  }
  .bb #b2 () {
    let %3: int32 = call f2(())
    jump b3(%3)
  }
  .bb #b3 (int32) {
    let %4: int32 = add($b3.0, %0)
    let %5: unit = ext_call minimbt_print_int(%4)
    return %5
  }
}
.thunk ::0 start

  .p2align 3
  .globl _start
  .type _start, @function
_start:
_start_b0:
  call thunk_start
  ret

  .p2align 3
  .globl f
  .type f, @function
f:
.f_b0:
  mv v2, a0
  li v3, 123
  mv a0, v3
  ret

  .p2align 3
  .globl thunk_start
  .type thunk_start, @function
thunk_start:
.thunk_start_b0:
  call main
  mv v2, zero
  mv a0, v2
  ret

  .p2align 3
  .globl h
  .type h, @function
h:
.h_b0:
  mv v2, a0
  li v3, 789
  mv a0, v3
  ret

  .p2align 3
  .globl g
  .type g, @function
g:
.g_b0:
  mv v2, a0
  li v3, 456
  mv a0, v3
  ret

  .p2align 3
  .globl main
  .type main, @function
main:
.main_b0:
  mv a0, zero
  call f
  mv v2, a0
  slt v13, v2, zero
  xori v3, v13, 1
  bne v3, zero, .main_b1
  j .main_b2

.main_b3:
  add v7, v6, v2
  mv a0, v7
  call minimbt_print_int
  mv v8, zero
  mv a0, v8
  ret

.main_b1:
  mv a0, zero
  call g
  mv v5, a0
  mv v6, v5
  j .main_b3

.main_b2:
  mv a0, zero
  call h
  mv v4, a0
  mv v6, v4
  j .main_b3

  .p2align 3
  .globl start
  .type start, @object
start:
  .zero 4



Testing test/test_src/landins_knot.mbt
# name conventions used in the core ir:
# - functions: f<id>
# - blocks: b<id>
# - instructions: %<id>
# - memory: m<id>
# - free variables: ^<id>
# - function parameters: $f<pid>
# - block parameters: $b<bid>.<pid>
.core
.fn init #f10 : fn() -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: int32 = call f9(10)
    let %1: unit = ext_call minimbt_print_int(%0)
    let %2: int32 = call f9(31)
    let %3: unit = ext_call minimbt_print_int(%2)
    return %3
  }
}
.fn thunk__21 #f7 : fn() -> int32
.freevars ()
.entry b0 {
  .bb #b0 () {
    return 5
  }
}
.fn thunk_factorial.18 #f5 : fn() -> closure(int32) -> int32
.freevars ()
.entry b0 {
  .bb #b0 () {
    let _ = alloc <m0: closure(closure(int32) -> int32) -> closure(int32) -> int32 heap(1)> <- [0] = f3
    let %1: closure(int32) -> int32 = call f1(f5.m0)
    return %1
  }
}
.fn dummy #f0 : fn(int32) -> int32
.freevars ()
.entry b0 {
  .bb #b0 () {
    return $f0
  }
}
.fn landins_kont #f1 : fn(closure(closure(int32) -> int32) -> closure(int32) -> int32) -> closure(int32) -> int32
.freevars ()
.entry b0 {
  .bb #b0 () {
    let _ = alloc <m0: closure(int32) -> int32 heap(1)> <- [0] = f0
    let _ = alloc <m1: array[closure(int32) -> int32] heap(1)> <- [..] = f1.m0
    let _ = alloc <m2: closure(int32) -> int32 heap(2)> <- [0] = f2, [1] = f1.m1
    let %3: closure(int32) -> int32 = apply $f0(f1.m2)
    let _ = store closure(int32) -> int32 offset(f1.m1, 0) <- %3
    return %3
  }
}
.fn thunk_a.22 #f8 : fn() -> int32
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: closure(int32) -> int32 = load_symbol ::0
    let %1: int32 = load_symbol ::1
    let %2: int32 = apply %0(%1)
    return %2
  }
}
.fn thunk_start #f11 : fn() -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: unit = call f10()
    return %0
  }
}
.fn aux #f2 : closure(int32) -> int32
.freevars (array[closure(int32) -> int32])
.entry b0 {
  .bb #b0 () {
    let %0: closure(int32) -> int32 = load closure(int32) -> int32 offset(^1, 0)
    let %1: int32 = apply %0($f0)
    return %1
  }
}
.fn g #f9 : fn(int32) -> int32
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: int32 = load_symbol ::2
    let %1: int32 = add($f0, %0)
    return %1
  }
}
.fn h #f4 : closure(int32) -> int32
.freevars (closure(int32) -> int32)
.entry b0 {
  .bb #b0 () {
    let %0: bool = eq($f0, 0)
    br %0 b1() b2()
  }
  .bb #b1 () {
    jump b3(1)
  }
  .bb #b2 () {
    let %1: int32 = sub($f0, 1)
    let %2: int32 = apply ^1(%1)
    let %3: int32 = mul($f0, %2)
    jump b3(%3)
  }
  .bb #b3 (int32) {
    return $b3.0
  }
}
.thunk ::0 factorial.18
.thunk ::1 _21
.thunk ::2 a.22
.thunk ::3 start

  .p2align 3
  .globl _start
  .type _start, @function
_start:
_start_b0:
  call thunk_factorial.18
  la t6, factorial.18
  sd a0, 0(t6)
  call thunk__21
  la t6, _21
  sw a0, 0(t6)
  call thunk_a.22
  la t6, a.22
  sw a0, 0(t6)
  call thunk_start
  ret

  .p2align 3
  .globl init
  .type init, @function
init:
.init_b0:
  li v10, 10
  mv a0, v10
  call g
  mv v2, a0
  mv a0, v2
  call minimbt_print_int
  mv v3, zero
  li v7, 31
  mv a0, v7
  call g
  mv v4, a0
  mv a0, v4
  call minimbt_print_int
  mv v5, zero
  mv a0, v5
  ret

  .p2align 3
  .globl thunk__21
  .type thunk__21, @function
thunk__21:
.thunk__21_b0:
  li v2, 5
  mv a0, v2
  ret

  .p2align 3
  .globl thunk_factorial.18
  .type thunk_factorial.18, @function
thunk_factorial.18:
.thunk_factorial.18_b0:
  addi v6, s11, -8
  andi v2, v6, -8
  la v8, g
  sd v8, 0(v2)
  mv a0, v2
  call landins_kont
  mv v4, a0
  mv a0, v4
  ret

  .p2align 3
  .globl dummy
  .type dummy, @function
dummy:
.dummy_b0:
  mv v2, a0
  mv a0, v2
  ret

  .p2align 3
  .globl landins_kont
  .type landins_kont, @function
landins_kont:
.landins_kont_b0:
  mv v2, a0
  addi v20, s11, -8
  andi v3, v20, -8
  la v22, dummy
  sd v22, 0(v3)
  addi v18, s11, -8
  andi v4, v18, -8
  sd v3, 0(v4)
  addi v15, s11, -16
  andi v5, v15, -8
  la v17, aux
  sd v17, 0(v5)
  sd v4, 8(v5)
  mv s10, v2
  ld v13, 0(v2)
  mv a0, v5
  jalr v13
  mv v9, a0
  slli v11, zero, 3
  add v12, v4, v11
  sd v9, 0(v12)
  mv a0, v9
  ret

  .p2align 3
  .globl thunk_a.22
  .type thunk_a.22, @function
thunk_a.22:
.thunk_a.22_b0:
  la v9, factorial.18
  ld v2, 0(v9)
  la v7, _21
  lw v3, 0(v7)
  mv s10, v2
  ld v5, 0(v2)
  mv a0, v3
  jalr v5
  mv v4, a0
  mv a0, v4
  ret

  .p2align 3
  .globl thunk_start
  .type thunk_start, @function
thunk_start:
.thunk_start_b0:
  call init
  mv v2, zero
  mv a0, v2
  ret

  .p2align 3
  .globl aux
  .type aux, @function
aux:
.aux_b0:
  mv v0, s10
  mv v2, a0
  lw v3, 8(v0)
  slli v8, zero, 3
  add v9, v3, v8
  ld v4, 0(v9)
  mv s10, v4
  ld v6, 0(v4)
  mv a0, v2
  jalr v6
  mv v5, a0
  mv a0, v5
  ret

  .p2align 3
  .globl g
  .type g, @function
g:
.g_b0:
  mv v2, a0
  addi v5, s11, -16
  andi v3, v5, -8
  la v7, h
  sd v7, 0(v3)
  sd v2, 8(v3)
  mv a0, v3
  ret

  .p2align 3
  .globl h
  .type h, @function
h:
.h_b0:
  mv v0, s10
  mv v2, a0
  lw v3, 8(v0)
  xor v15, v2, zero
  sltiu v4, v15, 1
  bne v4, zero, .h_b1
  j .h_b2

.h_b1:
  li v9, 1
  mv v8, v9
  j .h_b3

.h_b3:
  mv a0, v8
  ret

.h_b2:
  li v13, 1
  sub v5, v2, v13
  mv s10, v3
  ld v11, 0(v3)
  mv a0, v5
  jalr v11
  mv v6, a0
  mulw v7, v2, v6
  mv v8, v7
  j .h_b3

  .p2align 3
  .globl _21
  .type _21, @object
_21:
  .zero 4
  .p2align 3
  .globl a.22
  .type a.22, @object
a.22:
  .zero 4
  .p2align 3
  .globl start
  .type start, @object
start:
  .zero 4
  .p2align 3
  .globl factorial.18
  .type factorial.18, @object
factorial.18:
  .zero 8



Testing test/test_src/matmul-flat.mbt
# name conventions used in the core ir:
# - functions: f<id>
# - blocks: b<id>
# - instructions: %<id>
# - memory: m<id>
# - free variables: ^<id>
# - function parameters: $f<pid>
# - block parameters: $b<bid>.<pid>
.core
.fn loop2 #f1 : fn(int32, int32, int32, array[array[double]], array[array[double]], array[array[double]]) -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: bool = le(0, $f2)
    br %0 b1() b2()
  }
  .bb #b1 () {
    let %1: int32 = sub($f1, 1)
    let %2: unit = call f0($f0, $f2, %1, $f3, $f4, $f5)
    let %3: int32 = sub($f2, 1)
    let %4: unit = call f1($f0, $f1, %3, $f3, $f4, $f5)
    jump b3(%4)
  }
  .bb #b2 () {
    jump b3(())
  }
  .bb #b3 (unit) {
    return $b3.0
  }
}
.fn init_arr #f5 : closure(int32, int32, array[array[double]]) -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: bool = le(0, $f0)
    br %0 b1() b2()
  }
  .bb #b1 () {
    let _ = alloc <m0: array[double] heap($f1)> <- [..] = 0
    let _ = store array[double] offset($f2, $f0) <- f5.m0
    let %3: int32 = sub($f0, 1)
    let %4: unit = apply self(%3, $f1, $f2)
    jump b3(%4)
  }
  .bb #b2 () {
    jump b3(())
  }
  .bb #b3 (unit) {
    return $b3.0
  }
}
.fn thunk_start #f7 : fn() -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: unit = call f4()
    return %0
  }
}
.fn mul #f3 : fn(int32, int32, int32, array[array[double]], array[array[double]], array[array[double]]) -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: int32 = sub($f0, 1)
    let %1: unit = call f2(%0, $f1, $f2, $f3, $f4, $f5)
    return ()
  }
}
.fn loop3 #f0 : fn(int32, int32, int32, array[array[double]], array[array[double]], array[array[double]]) -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: bool = le(0, $f2)
    br %0 b1() b2()
  }
  .bb #b1 () {
    let %1: array[double] = load array[double] offset($f5, $f0)
    let %2: array[double] = load array[double] offset($f5, $f0)
    let %3: double = load double offset(%2, $f1)
    let %4: array[double] = load array[double] offset($f3, $f0)
    let %5: double = load double offset(%4, $f2)
    let %6: array[double] = load array[double] offset($f4, $f2)
    let %7: double = load double offset(%6, $f1)
    let %8: double = mul(%5, %7)
    let %9: double = add(%3, %8)
    let _ = store double offset(%1, $f1) <- %9
    let %11: int32 = sub($f2, 1)
    let %12: unit = call f0($f0, $f1, %11, $f3, $f4, $f5)
    jump b3(%12)
  }
  .bb #b2 () {
    jump b3(())
  }
  .bb #b3 (unit) {
    return $b3.0
  }
}
.fn loop1 #f2 : fn(int32, int32, int32, array[array[double]], array[array[double]], array[array[double]]) -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: bool = le(0, $f0)
    br %0 b1() b2()
  }
  .bb #b1 () {
    let %1: int32 = sub($f2, 1)
    let %2: unit = call f1($f0, $f1, %1, $f3, $f4, $f5)
    let %3: int32 = sub($f0, 1)
    let %4: unit = call f2(%3, $f1, $f2, $f3, $f4, $f5)
    jump b3(%4)
  }
  .bb #b2 () {
    jump b3(())
  }
  .bb #b3 (unit) {
    return $b3.0
  }
}
.fn make_arr #f6 : closure(int32, int32, array[double]) -> array[array[double]]
.freevars (closure(int32, int32, array[array[double]]) -> unit)
.entry b0 {
  .bb #b0 () {
    let _ = alloc <m0: array[array[double]] heap($f0)> <- [..] = $f2
    let %1: int32 = sub($f0, 1)
    let %2: unit = apply ^1(%1, $f1, f6.m0)
    return f6.m0
  }
}
.fn main #f4 : fn() -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let _ = alloc <m0: array[double] heap(0)> <- [..] = 0
    let _ = alloc <m1: closure(int32, int32, array[array[double]]) -> unit heap(1)> <- [0] = f5
    let _ = alloc <m2: closure(int32, int32, array[double]) -> array[array[double]] heap(2)> <- [0] = f6, [1] = f4.m1
    let %3: array[array[double]] = apply f4.m2(2, 3, f4.m0)
    let %4: array[array[double]] = apply f4.m2(3, 2, f4.m0)
    let %5: array[array[double]] = apply f4.m2(2, 2, f4.m0)
    let %6: array[double] = load array[double] offset(%3, 0)
    let _ = store double offset(%6, 0) <- 1
    let %8: array[double] = load array[double] offset(%3, 0)
    let _ = store double offset(%8, 1) <- 2
    let %10: array[double] = load array[double] offset(%3, 0)
    let _ = store double offset(%10, 2) <- 3
    let %12: array[double] = load array[double] offset(%3, 1)
    let _ = store double offset(%12, 0) <- 4
    let %14: array[double] = load array[double] offset(%3, 1)
    let _ = store double offset(%14, 1) <- 5
    let %16: array[double] = load array[double] offset(%3, 1)
    let _ = store double offset(%16, 2) <- 6
    let %18: array[double] = load array[double] offset(%4, 0)
    let _ = store double offset(%18, 0) <- 7
    let %20: array[double] = load array[double] offset(%4, 0)
    let _ = store double offset(%20, 1) <- 8
    let %22: array[double] = load array[double] offset(%4, 1)
    let _ = store double offset(%22, 0) <- 9
    let %24: array[double] = load array[double] offset(%4, 1)
    let _ = store double offset(%24, 1) <- 10
    let %26: array[double] = load array[double] offset(%4, 2)
    let _ = store double offset(%26, 0) <- 11
    let %28: array[double] = load array[double] offset(%4, 2)
    let _ = store double offset(%28, 1) <- 12
    let %30: unit = call f3(2, 3, 2, %3, %4, %5)
    let %31: array[double] = load array[double] offset(%5, 0)
    let %32: double = load double offset(%31, 0)
    let %33: int32 = ext_call minimbt_truncate(%32)
    let %34: unit = ext_call minimbt_print_int(%33)
    let %35: unit = ext_call minimbt_print_endline()
    let %36: array[double] = load array[double] offset(%5, 0)
    let %37: double = load double offset(%36, 1)
    let %38: int32 = ext_call minimbt_truncate(%37)
    let %39: unit = ext_call minimbt_print_int(%38)
    let %40: unit = ext_call minimbt_print_endline()
    let %41: array[double] = load array[double] offset(%5, 1)
    let %42: double = load double offset(%41, 0)
    let %43: int32 = ext_call minimbt_truncate(%42)
    let %44: unit = ext_call minimbt_print_int(%43)
    let %45: unit = ext_call minimbt_print_endline()
    let %46: array[double] = load array[double] offset(%5, 1)
    let %47: double = load double offset(%46, 1)
    let %48: int32 = ext_call minimbt_truncate(%47)
    let %49: unit = ext_call minimbt_print_int(%48)
    return ()
  }
}
.thunk ::0 start

  .p2align 3
  .globl loop2
  .type loop2, @function
loop2:
.loop2_b0:
  mv v2, a0
  mv v3, a1
  mv v4, a2
  mv v5, a3
  mv v6, a4
  mv v7, a5
  slt v20, zero, v4
  xori v8, v20, 1
  bne v8, zero, .loop2_b1
  j .loop2_b2

.loop2_b2:
  mv v13, zero
  j .loop2_b3

.loop2_b3:
  mv a0, v13
  ret

.loop2_b1:
  li v18, 1
  sub v9, v3, v18
  mv a0, v2
  mv a1, v4
  mv a2, v9
  mv a3, v5
  mv a4, v6
  mv a5, v7
  call loop3
  mv v10, zero
  li v15, 1
  sub v11, v4, v15
  mv a0, v2
  mv a1, v3
  mv a2, v11
  mv a3, v5
  mv a4, v6
  mv a5, v7
  call loop2
  mv v12, zero
  mv v13, v12
  j .loop2_b3

  .p2align 3
  .globl _start
  .type _start, @function
_start:
_start_b0:
  call thunk_start
  ret

  .p2align 3
  .globl make_arr
  .type make_arr, @function
make_arr:
.make_arr_b0:
  mv v0, s10
  mv v2, a0
  mv v3, a1
  mv v4, a2
  lw v5, 8(v0)
  slli v14, v2, 3
  sub v15, s11, v14
  andi v6, v15, -8
  mv a1, v2
  mv a0, v6
  mv a2, v4
  call _memseti32
  li v12, 1
  sub v8, v2, v12
  mv s10, v5
  ld v10, 0(v5)
  mv a0, v8
  mv a1, v3
  mv a2, v6
  jalr v10
  mv v9, zero
  mv a0, v6
  ret

  .p2align 3
  .globl main
  .type main, @function
main:
.main_b0:
  addi v214, s11, 0
  andi v2, v214, -8
  fmv.d.x fv216, zero
  addi v211, s11, -8
  andi v3, v211, -8
  la v213, init_arr
  sd v213, 0(v3)
  addi v208, s11, -16
  andi v4, v208, -8
  la v210, make_arr
  sd v210, 0(v4)
  sd v3, 8(v4)
  mv s10, v4
  ld v204, 0(v4)
  li v205, 2
  mv a0, v205
  li v206, 3
  mv a1, v206
  mv a2, v2
  jalr v204
  mv v8, a0
  mv s10, v4
  ld v200, 0(v4)
  li v201, 3
  mv a0, v201
  li v202, 2
  mv a1, v202
  mv a2, v2
  jalr v200
  mv v9, a0
  mv s10, v4
  ld v196, 0(v4)
  li v197, 2
  mv a0, v197
  li v198, 2
  mv a1, v198
  mv a2, v2
  jalr v196
  mv v10, a0
  slli v193, zero, 3
  add v194, v8, v193
  ld v11, 0(v194)
  li v189, 4607182418800017408
  fmv.d.x fv190, v189
  slli v191, zero, 3
  add v192, v11, v191
  fsd fv190, 0(v192)
  slli v186, zero, 3
  add v187, v8, v186
  ld v13, 0(v187)
  li v181, 4611686018427387904
  fmv.d.x fv182, v181
  li v183, 1
  slli v184, v183, 3
  add v185, v13, v184
  fsd fv182, 0(v185)
  slli v178, zero, 3
  add v179, v8, v178
  ld v15, 0(v179)
  li v173, 4613937818241073152
  fmv.d.x fv174, v173
  li v175, 2
  slli v176, v175, 3
  add v177, v15, v176
  fsd fv174, 0(v177)
  li v169, 1
  slli v170, v169, 3
  add v171, v8, v170
  ld v17, 0(v171)
  li v165, 4616189618054758400
  fmv.d.x fv166, v165
  slli v167, zero, 3
  add v168, v17, v167
  fsd fv166, 0(v168)
  li v161, 1
  slli v162, v161, 3
  add v163, v8, v162
  ld v19, 0(v163)
  li v156, 4617315517961601024
  fmv.d.x fv157, v156
  li v158, 1
  slli v159, v158, 3
  add v160, v19, v159
  fsd fv157, 0(v160)
  li v152, 1
  slli v153, v152, 3
  add v154, v8, v153
  ld v21, 0(v154)
  li v147, 4618441417868443648
  fmv.d.x fv148, v147
  li v149, 2
  slli v150, v149, 3
  add v151, v21, v150
  fsd fv148, 0(v151)
  slli v144, zero, 3
  add v145, v9, v144
  ld v23, 0(v145)
  li v140, 4619567317775286272
  fmv.d.x fv141, v140
  slli v142, zero, 3
  add v143, v23, v142
  fsd fv141, 0(v143)
  slli v137, zero, 3
  add v138, v9, v137
  ld v25, 0(v138)
  li v132, 4620693217682128896
  fmv.d.x fv133, v132
  li v134, 1
  slli v135, v134, 3
  add v136, v25, v135
  fsd fv133, 0(v136)
  li v128, 1
  slli v129, v128, 3
  add v130, v9, v129
  ld v27, 0(v130)
  li v124, 4621256167635550208
  fmv.d.x fv125, v124
  slli v126, zero, 3
  add v127, v27, v126
  fsd fv125, 0(v127)
  li v120, 1
  slli v121, v120, 3
  add v122, v9, v121
  ld v29, 0(v122)
  li v115, 4621819117588971520
  fmv.d.x fv116, v115
  li v117, 1
  slli v118, v117, 3
  add v119, v29, v118
  fsd fv116, 0(v119)
  li v111, 2
  slli v112, v111, 3
  add v113, v9, v112
  ld v31, 0(v113)
  li v107, 4622382067542392832
  fmv.d.x fv108, v107
  slli v109, zero, 3
  add v110, v31, v109
  fsd fv108, 0(v110)
  li v103, 2
  slli v104, v103, 3
  add v105, v9, v104
  ld v33, 0(v105)
  li v98, 4622945017495814144
  fmv.d.x fv99, v98
  li v100, 1
  slli v101, v100, 3
  add v102, v33, v101
  fsd fv99, 0(v102)
  li v94, 2
  mv a0, v94
  li v95, 3
  mv a1, v95
  li v96, 2
  mv a2, v96
  mv a3, v8
  mv a4, v9
  mv a5, v10
  call mul
  mv v35, zero
  slli v91, zero, 3
  add v92, v10, v91
  ld v36, 0(v92)
  slli v88, zero, 3
  add v89, v36, v88
  fld fv37, 0(v89)
  fmv.d fa0, fv37
  call minimbt_truncate
  mv v38, a0
  mv a0, v38
  call minimbt_print_int
  mv v39, zero
  call minimbt_print_endline
  mv v40, zero
  slli v82, zero, 3
  add v83, v10, v82
  ld v41, 0(v83)
  li v78, 1
  slli v79, v78, 3
  add v80, v41, v79
  fld fv42, 0(v80)
  fmv.d fa0, fv42
  call minimbt_truncate
  mv v43, a0
  mv a0, v43
  call minimbt_print_int
  mv v44, zero
  call minimbt_print_endline
  mv v45, zero
  li v71, 1
  slli v72, v71, 3
  add v73, v10, v72
  ld v46, 0(v73)
  slli v68, zero, 3
  add v69, v46, v68
  fld fv47, 0(v69)
  fmv.d fa0, fv47
  call minimbt_truncate
  mv v48, a0
  mv a0, v48
  call minimbt_print_int
  mv v49, zero
  call minimbt_print_endline
  mv v50, zero
  li v61, 1
  slli v62, v61, 3
  add v63, v10, v62
  ld v51, 0(v63)
  li v57, 1
  slli v58, v57, 3
  add v59, v51, v58
  fld fv52, 0(v59)
  fmv.d fa0, fv52
  call minimbt_truncate
  mv v53, a0
  mv a0, v53
  call minimbt_print_int
  mv v54, zero
  mv a0, zero
  ret

  .p2align 3
  .globl init_arr
  .type init_arr, @function
init_arr:
.init_arr_b0:
  mv v2, a0
  mv v3, a1
  mv v4, a2
  slt v22, zero, v2
  xori v6, v22, 1
  bne v6, zero, .init_arr_b1
  j .init_arr_b2

.init_arr_b3:
  mv a0, v11
  ret

.init_arr_b2:
  mv v11, zero
  j .init_arr_b3

.init_arr_b1:
  slli v18, v3, 3
  sub v19, s11, v18
  andi v5, v19, -8
  fmv.d.x fv21, zero
  mv a1, v3
  mv a0, v5
  fmv.d fa0, fv21
  call _memsetf64
  slli v16, v2, 3
  add v17, v4, v16
  sd v5, 0(v17)
  li v14, 1
  sub v9, v2, v14
  mv s10, v0
  ld v12, 0(v0)
  mv a0, v9
  mv a1, v3
  mv a2, v4
  jalr v12
  mv v10, zero
  mv v11, v10
  j .init_arr_b3

  .p2align 3
  .globl thunk_start
  .type thunk_start, @function
thunk_start:
.thunk_start_b0:
  call main
  mv v2, zero
  mv a0, v2
  ret

  .p2align 3
  .globl mul
  .type mul, @function
mul:
.mul_b0:
  mv v2, a0
  mv v3, a1
  mv v4, a2
  mv v5, a3
  mv v6, a4
  mv v7, a5
  li v11, 1
  sub v8, v2, v11
  mv a0, v8
  mv a1, v3
  mv a2, v4
  mv a3, v5
  mv a4, v6
  mv a5, v7
  call loop1
  mv v9, zero
  mv a0, zero
  ret

  .p2align 3
  .globl loop3
  .type loop3, @function
loop3:
.loop3_b0:
  mv v2, a0
  mv v3, a1
  mv v4, a2
  mv v5, a3
  mv v6, a4
  mv v7, a5
  slt v50, zero, v4
  xori v8, v50, 1
  bne v8, zero, .loop3_b1
  j .loop3_b2

.loop3_b1:
  slli v47, v2, 3
  add v48, v7, v47
  ld v9, 0(v48)
  slli v44, v2, 3
  add v45, v7, v44
  ld v10, 0(v45)
  slli v41, v3, 3
  add v42, v10, v41
  fld fv11, 0(v42)
  slli v38, v2, 3
  add v39, v5, v38
  ld v12, 0(v39)
  slli v35, v4, 3
  add v36, v12, v35
  fld fv13, 0(v36)
  slli v32, v4, 3
  add v33, v6, v32
  ld v14, 0(v33)
  slli v29, v3, 3
  add v30, v14, v29
  fld fv15, 0(v30)
  fmul.d fv16, fv13, fv15
  fadd.d fv17, fv11, fv16
  slli v25, v3, 3
  add v26, v9, v25
  fsd fv17, 0(v26)
  li v23, 1
  sub v19, v4, v23
  mv a0, v2
  mv a1, v3
  mv a2, v19
  mv a3, v5
  mv a4, v6
  mv a5, v7
  call loop3
  mv v20, zero
  mv v21, v20
  j .loop3_b3

.loop3_b2:
  mv v21, zero
  j .loop3_b3

.loop3_b3:
  mv a0, v21
  ret

  .p2align 3
  .globl loop1
  .type loop1, @function
loop1:
.loop1_b0:
  mv v2, a0
  mv v3, a1
  mv v4, a2
  mv v5, a3
  mv v6, a4
  mv v7, a5
  slt v20, zero, v2
  xori v8, v20, 1
  bne v8, zero, .loop1_b1
  j .loop1_b2

.loop1_b1:
  li v18, 1
  sub v9, v4, v18
  mv a0, v2
  mv a1, v3
  mv a2, v9
  mv a3, v5
  mv a4, v6
  mv a5, v7
  call loop2
  mv v10, zero
  li v15, 1
  sub v11, v2, v15
  mv a0, v11
  mv a1, v3
  mv a2, v4
  mv a3, v5
  mv a4, v6
  mv a5, v7
  call loop1
  mv v12, zero
  mv v13, v12
  j .loop1_b3

.loop1_b2:
  mv v13, zero
  j .loop1_b3

.loop1_b3:
  mv a0, v13
  ret

  .p2align 3
  .globl start
  .type start, @object
start:
  .zero 4



Testing test/test_src/matmul.mbt
# name conventions used in the core ir:
# - functions: f<id>
# - blocks: b<id>
# - instructions: %<id>
# - memory: m<id>
# - free variables: ^<id>
# - function parameters: $f<pid>
# - block parameters: $b<bid>.<pid>
.core
.fn loop2 #f2 : closure(int32) -> unit
.freevars (array[array[double]], int32, array[array[double]], array[array[double]], int32)
.entry b0 {
  .bb #b0 () {
    let %0: bool = le(0, $f0)
    br %0 b1() b2()
  }
  .bb #b1 () {
    let _ = alloc <m0: closure(int32) -> unit heap(6)> <- [0] = f3, [1] = ^1, [2] = ^2, [3] = $f0, [4] = ^3, [5] = ^4
    let %2: int32 = sub(^5, 1)
    let %3: unit = apply f2.m0(%2)
    let %4: int32 = sub($f0, 1)
    let %5: unit = apply self(%4)
    jump b3(%5)
  }
  .bb #b2 () {
    jump b3(())
  }
  .bb #b3 (unit) {
    return $b3.0
  }
}
.fn init_arr #f6 : closure(int32) -> unit
.freevars (int32, array[array[double]])
.entry b0 {
  .bb #b0 () {
    let %0: bool = le(0, $f0)
    br %0 b1() b2()
  }
  .bb #b1 () {
    let _ = alloc <m0: array[double] heap(^1)> <- [..] = 0
    let _ = store array[double] offset(^2, $f0) <- f6.m0
    let %3: int32 = sub($f0, 1)
    let %4: unit = apply self(%3)
    jump b3(%4)
  }
  .bb #b2 () {
    jump b3(())
  }
  .bb #b3 (unit) {
    return $b3.0
  }
}
.fn thunk_start #f7 : fn() -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: unit = call f4()
    return %0
  }
}
.fn loop3 #f3 : closure(int32) -> unit
.freevars (array[array[double]], int32, int32, array[array[double]], array[array[double]])
.entry b0 {
  .bb #b0 () {
    let %0: bool = le(0, $f0)
    br %0 b1() b2()
  }
  .bb #b1 () {
    let %1: array[double] = load array[double] offset(^1, ^2)
    let %2: array[double] = load array[double] offset(^1, ^2)
    let %3: double = load double offset(%2, ^3)
    let %4: array[double] = load array[double] offset(^4, ^2)
    let %5: double = load double offset(%4, $f0)
    let %6: array[double] = load array[double] offset(^5, $f0)
    let %7: double = load double offset(%6, ^3)
    let %8: double = mul(%5, %7)
    let %9: double = add(%3, %8)
    let _ = store double offset(%1, ^3) <- %9
    let %11: int32 = sub($f0, 1)
    let %12: unit = apply self(%11)
    jump b3(%12)
  }
  .bb #b2 () {
    jump b3(())
  }
  .bb #b3 (unit) {
    return $b3.0
  }
}
.fn loop1 #f1 : closure(int32) -> unit
.freevars (array[array[double]], array[array[double]], array[array[double]], int32, int32)
.entry b0 {
  .bb #b0 () {
    let %0: bool = le(0, $f0)
    br %0 b1() b2()
  }
  .bb #b1 () {
    let _ = alloc <m0: closure(int32) -> unit heap(6)> <- [0] = f2, [1] = ^1, [2] = $f0, [3] = ^2, [4] = ^3, [5] = ^4
    let %2: int32 = sub(^5, 1)
    let %3: unit = apply f1.m0(%2)
    let %4: int32 = sub($f0, 1)
    let %5: unit = apply self(%4)
    jump b3(%5)
  }
  .bb #b2 () {
    jump b3(())
  }
  .bb #b3 (unit) {
    return $b3.0
  }
}
.fn matmul #f0 : fn(int32, int32, int32, array[array[double]], array[array[double]], array[array[double]]) -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let _ = alloc <m0: closure(int32) -> unit heap(6)> <- [0] = f1, [1] = $f5, [2] = $f3, [3] = $f4, [4] = $f1, [5] = $f2
    let %1: int32 = sub($f0, 1)
    let %2: unit = apply f0.m0(%1)
    return %2
  }
}
.fn gen_arr #f5 : closure(int32, int32) -> array[array[double]]
.freevars (array[double])
.entry b0 {
  .bb #b0 () {
    let _ = alloc <m0: array[array[double]] heap($f0)> <- [..] = ^1
    let _ = alloc <m1: closure(int32) -> unit heap(3)> <- [0] = f6, [1] = $f1, [2] = f5.m0
    let %2: int32 = sub($f0, 1)
    let %3: unit = apply f5.m1(%2)
    return f5.m0
  }
}
.fn main #f4 : fn() -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let _ = alloc <m0: array[double] heap(0)> <- [..] = 0
    let _ = alloc <m1: closure(int32, int32) -> array[array[double]] heap(2)> <- [0] = f5, [1] = f4.m0
    let %2: array[array[double]] = apply f4.m1(2, 3)
    let %3: array[array[double]] = apply f4.m1(3, 2)
    let %4: array[array[double]] = apply f4.m1(2, 2)
    let %5: array[double] = load array[double] offset(%2, 0)
    let _ = store double offset(%5, 0) <- 1
    let %7: array[double] = load array[double] offset(%2, 0)
    let _ = store double offset(%7, 1) <- 2
    let %9: array[double] = load array[double] offset(%2, 0)
    let _ = store double offset(%9, 2) <- 3
    let %11: array[double] = load array[double] offset(%2, 1)
    let _ = store double offset(%11, 0) <- 4
    let %13: array[double] = load array[double] offset(%2, 1)
    let _ = store double offset(%13, 1) <- 5
    let %15: array[double] = load array[double] offset(%2, 1)
    let _ = store double offset(%15, 2) <- 6
    let %17: array[double] = load array[double] offset(%3, 0)
    let _ = store double offset(%17, 0) <- 7
    let %19: array[double] = load array[double] offset(%3, 0)
    let _ = store double offset(%19, 1) <- 8
    let %21: array[double] = load array[double] offset(%3, 1)
    let _ = store double offset(%21, 0) <- 9
    let %23: array[double] = load array[double] offset(%3, 1)
    let _ = store double offset(%23, 1) <- 10
    let %25: array[double] = load array[double] offset(%3, 2)
    let _ = store double offset(%25, 0) <- 11
    let %27: array[double] = load array[double] offset(%3, 2)
    let _ = store double offset(%27, 1) <- 12
    let %29: unit = call f0(2, 3, 2, %2, %3, %4)
    let %30: array[double] = load array[double] offset(%4, 0)
    let %31: double = load double offset(%30, 0)
    let %32: int32 = ext_call minimbt_truncate(%31)
    let %33: unit = ext_call minimbt_print_int(%32)
    let %34: unit = ext_call minimbt_print_endline()
    let %35: array[double] = load array[double] offset(%4, 0)
    let %36: double = load double offset(%35, 1)
    let %37: int32 = ext_call minimbt_truncate(%36)
    let %38: unit = ext_call minimbt_print_int(%37)
    let %39: unit = ext_call minimbt_print_endline()
    let %40: array[double] = load array[double] offset(%4, 1)
    let %41: double = load double offset(%40, 0)
    let %42: int32 = ext_call minimbt_truncate(%41)
    let %43: unit = ext_call minimbt_print_int(%42)
    let %44: unit = ext_call minimbt_print_endline()
    let %45: array[double] = load array[double] offset(%4, 1)
    let %46: double = load double offset(%45, 1)
    let %47: int32 = ext_call minimbt_truncate(%46)
    let %48: unit = ext_call minimbt_print_int(%47)
    return ()
  }
}
.thunk ::0 start

  .p2align 3
  .globl loop2
  .type loop2, @function
loop2:
.loop2_b0:
  mv v0, s10
  mv v2, a0
  lw v3, 8(v0)
  lw v4, 16(v0)
  lw v5, 24(v0)
  lw v6, 32(v0)
  lw v7, 40(v0)
  slt v27, zero, v2
  xori v9, v27, 1
  bne v9, zero, .loop2_b1
  j .loop2_b2

.loop2_b2:
  mv v15, zero
  j .loop2_b3

.loop2_b3:
  mv a0, v15
  ret

.loop2_b1:
  addi v24, s11, -48
  andi v8, v24, -8
  la v26, loop3
  sd v26, 0(v8)
  sd v3, 8(v8)
  sd v4, 16(v8)
  sd v2, 24(v8)
  sd v5, 32(v8)
  sd v6, 40(v8)
  li v22, 1
  sub v11, v7, v22
  mv s10, v8
  ld v20, 0(v8)
  mv a0, v11
  jalr v20
  mv v12, zero
  li v18, 1
  sub v13, v2, v18
  mv s10, v0
  ld v16, 0(v0)
  mv a0, v13
  jalr v16
  mv v14, zero
  mv v15, v14
  j .loop2_b3

  .p2align 3
  .globl _start
  .type _start, @function
_start:
_start_b0:
  call thunk_start
  ret

  .p2align 3
  .globl matmul
  .type matmul, @function
matmul:
.matmul_b0:
  mv v2, a0
  mv v3, a1
  mv v4, a2
  mv v5, a3
  mv v6, a4
  mv v7, a5
  addi v16, s11, -48
  andi v8, v16, -8
  la v18, loop1
  sd v18, 0(v8)
  sd v7, 8(v8)
  sd v5, 16(v8)
  sd v6, 24(v8)
  sd v3, 32(v8)
  sd v4, 40(v8)
  li v14, 1
  sub v10, v2, v14
  mv s10, v8
  ld v12, 0(v8)
  mv a0, v10
  jalr v12
  mv v11, zero
  mv a0, v11
  ret

  .p2align 3
  .globl gen_arr
  .type gen_arr, @function
gen_arr:
.gen_arr_b0:
  mv v0, s10
  mv v2, a0
  mv v3, a1
  lw v4, 8(v0)
  slli v18, v2, 3
  sub v19, s11, v18
  andi v5, v19, -8
  mv a1, v2
  mv a0, v5
  mv a2, v4
  call _memseti32
  addi v15, s11, -24
  andi v6, v15, -8
  la v17, init_arr
  sd v17, 0(v6)
  sd v3, 8(v6)
  sd v5, 16(v6)
  li v13, 1
  sub v9, v2, v13
  mv s10, v6
  ld v11, 0(v6)
  mv a0, v9
  jalr v11
  mv v10, zero
  mv a0, v5
  ret

  .p2align 3
  .globl main
  .type main, @function
main:
.main_b0:
  addi v209, s11, 0
  andi v2, v209, -8
  fmv.d.x fv211, zero
  addi v206, s11, -16
  andi v3, v206, -8
  la v208, gen_arr
  sd v208, 0(v3)
  sd v2, 8(v3)
  mv s10, v3
  ld v202, 0(v3)
  li v203, 2
  mv a0, v203
  li v204, 3
  mv a1, v204
  jalr v202
  mv v6, a0
  mv s10, v3
  ld v198, 0(v3)
  li v199, 3
  mv a0, v199
  li v200, 2
  mv a1, v200
  jalr v198
  mv v7, a0
  mv s10, v3
  ld v194, 0(v3)
  li v195, 2
  mv a0, v195
  li v196, 2
  mv a1, v196
  jalr v194
  mv v8, a0
  slli v191, zero, 3
  add v192, v6, v191
  ld v9, 0(v192)
  li v187, 4607182418800017408
  fmv.d.x fv188, v187
  slli v189, zero, 3
  add v190, v9, v189
  fsd fv188, 0(v190)
  slli v184, zero, 3
  add v185, v6, v184
  ld v11, 0(v185)
  li v179, 4611686018427387904
  fmv.d.x fv180, v179
  li v181, 1
  slli v182, v181, 3
  add v183, v11, v182
  fsd fv180, 0(v183)
  slli v176, zero, 3
  add v177, v6, v176
  ld v13, 0(v177)
  li v171, 4613937818241073152
  fmv.d.x fv172, v171
  li v173, 2
  slli v174, v173, 3
  add v175, v13, v174
  fsd fv172, 0(v175)
  li v167, 1
  slli v168, v167, 3
  add v169, v6, v168
  ld v15, 0(v169)
  li v163, 4616189618054758400
  fmv.d.x fv164, v163
  slli v165, zero, 3
  add v166, v15, v165
  fsd fv164, 0(v166)
  li v159, 1
  slli v160, v159, 3
  add v161, v6, v160
  ld v17, 0(v161)
  li v154, 4617315517961601024
  fmv.d.x fv155, v154
  li v156, 1
  slli v157, v156, 3
  add v158, v17, v157
  fsd fv155, 0(v158)
  li v150, 1
  slli v151, v150, 3
  add v152, v6, v151
  ld v19, 0(v152)
  li v145, 4618441417868443648
  fmv.d.x fv146, v145
  li v147, 2
  slli v148, v147, 3
  add v149, v19, v148
  fsd fv146, 0(v149)
  slli v142, zero, 3
  add v143, v7, v142
  ld v21, 0(v143)
  li v138, 4619567317775286272
  fmv.d.x fv139, v138
  slli v140, zero, 3
  add v141, v21, v140
  fsd fv139, 0(v141)
  slli v135, zero, 3
  add v136, v7, v135
  ld v23, 0(v136)
  li v130, 4620693217682128896
  fmv.d.x fv131, v130
  li v132, 1
  slli v133, v132, 3
  add v134, v23, v133
  fsd fv131, 0(v134)
  li v126, 1
  slli v127, v126, 3
  add v128, v7, v127
  ld v25, 0(v128)
  li v122, 4621256167635550208
  fmv.d.x fv123, v122
  slli v124, zero, 3
  add v125, v25, v124
  fsd fv123, 0(v125)
  li v118, 1
  slli v119, v118, 3
  add v120, v7, v119
  ld v27, 0(v120)
  li v113, 4621819117588971520
  fmv.d.x fv114, v113
  li v115, 1
  slli v116, v115, 3
  add v117, v27, v116
  fsd fv114, 0(v117)
  li v109, 2
  slli v110, v109, 3
  add v111, v7, v110
  ld v29, 0(v111)
  li v105, 4622382067542392832
  fmv.d.x fv106, v105
  slli v107, zero, 3
  add v108, v29, v107
  fsd fv106, 0(v108)
  li v101, 2
  slli v102, v101, 3
  add v103, v7, v102
  ld v31, 0(v103)
  li v96, 4622945017495814144
  fmv.d.x fv97, v96
  li v98, 1
  slli v99, v98, 3
  add v100, v31, v99
  fsd fv97, 0(v100)
  li v92, 2
  mv a0, v92
  li v93, 3
  mv a1, v93
  li v94, 2
  mv a2, v94
  mv a3, v6
  mv a4, v7
  mv a5, v8
  call matmul
  mv v33, zero
  slli v89, zero, 3
  add v90, v8, v89
  ld v34, 0(v90)
  slli v86, zero, 3
  add v87, v34, v86
  fld fv35, 0(v87)
  fmv.d fa0, fv35
  call minimbt_truncate
  mv v36, a0
  mv a0, v36
  call minimbt_print_int
  mv v37, zero
  call minimbt_print_endline
  mv v38, zero
  slli v80, zero, 3
  add v81, v8, v80
  ld v39, 0(v81)
  li v76, 1
  slli v77, v76, 3
  add v78, v39, v77
  fld fv40, 0(v78)
  fmv.d fa0, fv40
  call minimbt_truncate
  mv v41, a0
  mv a0, v41
  call minimbt_print_int
  mv v42, zero
  call minimbt_print_endline
  mv v43, zero
  li v69, 1
  slli v70, v69, 3
  add v71, v8, v70
  ld v44, 0(v71)
  slli v66, zero, 3
  add v67, v44, v66
  fld fv45, 0(v67)
  fmv.d fa0, fv45
  call minimbt_truncate
  mv v46, a0
  mv a0, v46
  call minimbt_print_int
  mv v47, zero
  call minimbt_print_endline
  mv v48, zero
  li v59, 1
  slli v60, v59, 3
  add v61, v8, v60
  ld v49, 0(v61)
  li v55, 1
  slli v56, v55, 3
  add v57, v49, v56
  fld fv50, 0(v57)
  fmv.d fa0, fv50
  call minimbt_truncate
  mv v51, a0
  mv a0, v51
  call minimbt_print_int
  mv v52, zero
  mv a0, zero
  ret

  .p2align 3
  .globl init_arr
  .type init_arr, @function
init_arr:
.init_arr_b0:
  mv v0, s10
  mv v2, a0
  lw v3, 8(v0)
  lw v4, 16(v0)
  slt v22, zero, v2
  xori v6, v22, 1
  bne v6, zero, .init_arr_b1
  j .init_arr_b2

.init_arr_b3:
  mv a0, v11
  ret

.init_arr_b2:
  mv v11, zero
  j .init_arr_b3

.init_arr_b1:
  slli v18, v3, 3
  sub v19, s11, v18
  andi v5, v19, -8
  fmv.d.x fv21, zero
  mv a1, v3
  mv a0, v5
  fmv.d fa0, fv21
  call _memsetf64
  slli v16, v2, 3
  add v17, v4, v16
  sd v5, 0(v17)
  li v14, 1
  sub v9, v2, v14
  mv s10, v0
  ld v12, 0(v0)
  mv a0, v9
  jalr v12
  mv v10, zero
  mv v11, v10
  j .init_arr_b3

  .p2align 3
  .globl thunk_start
  .type thunk_start, @function
thunk_start:
.thunk_start_b0:
  call main
  mv v2, zero
  mv a0, v2
  ret

  .p2align 3
  .globl loop3
  .type loop3, @function
loop3:
.loop3_b0:
  mv v0, s10
  mv v2, a0
  lw v3, 8(v0)
  lw v4, 16(v0)
  lw v5, 24(v0)
  lw v6, 32(v0)
  lw v7, 40(v0)
  slt v51, zero, v2
  xori v8, v51, 1
  bne v8, zero, .loop3_b1
  j .loop3_b2

.loop3_b1:
  slli v48, v4, 3
  add v49, v3, v48
  ld v9, 0(v49)
  slli v45, v4, 3
  add v46, v3, v45
  ld v10, 0(v46)
  slli v42, v5, 3
  add v43, v10, v42
  fld fv11, 0(v43)
  slli v39, v4, 3
  add v40, v6, v39
  ld v12, 0(v40)
  slli v36, v2, 3
  add v37, v12, v36
  fld fv13, 0(v37)
  slli v33, v2, 3
  add v34, v7, v33
  ld v14, 0(v34)
  slli v30, v5, 3
  add v31, v14, v30
  fld fv15, 0(v31)
  fmul.d fv16, fv13, fv15
  fadd.d fv17, fv11, fv16
  slli v26, v5, 3
  add v27, v9, v26
  fsd fv17, 0(v27)
  li v24, 1
  sub v19, v2, v24
  mv s10, v0
  ld v22, 0(v0)
  mv a0, v19
  jalr v22
  mv v20, zero
  mv v21, v20
  j .loop3_b3

.loop3_b2:
  mv v21, zero
  j .loop3_b3

.loop3_b3:
  mv a0, v21
  ret

  .p2align 3
  .globl loop1
  .type loop1, @function
loop1:
.loop1_b0:
  mv v0, s10
  mv v2, a0
  lw v3, 8(v0)
  lw v4, 16(v0)
  lw v5, 24(v0)
  lw v6, 32(v0)
  lw v7, 40(v0)
  slt v27, zero, v2
  xori v9, v27, 1
  bne v9, zero, .loop1_b1
  j .loop1_b2

.loop1_b1:
  addi v24, s11, -48
  andi v8, v24, -8
  la v26, loop2
  sd v26, 0(v8)
  sd v3, 8(v8)
  sd v2, 16(v8)
  sd v4, 24(v8)
  sd v5, 32(v8)
  sd v6, 40(v8)
  li v22, 1
  sub v11, v7, v22
  mv s10, v8
  ld v20, 0(v8)
  mv a0, v11
  jalr v20
  mv v12, zero
  li v18, 1
  sub v13, v2, v18
  mv s10, v0
  ld v16, 0(v0)
  mv a0, v13
  jalr v16
  mv v14, zero
  mv v15, v14
  j .loop1_b3

.loop1_b2:
  mv v15, zero
  j .loop1_b3

.loop1_b3:
  mv a0, v15
  ret

  .p2align 3
  .globl start
  .type start, @object
start:
  .zero 4



Testing test/test_src/non-tail-if.mbt
# name conventions used in the core ir:
# - functions: f<id>
# - blocks: b<id>
# - instructions: %<id>
# - memory: m<id>
# - free variables: ^<id>
# - function parameters: $f<pid>
# - block parameters: $b<bid>.<pid>
.core
.fn thunk_start #f1 : fn() -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: unit = call f0()
    return %0
  }
}
.fn main #f0 : fn() -> unit
.freevars ()
.entry b0 {
  .bb #b6 (int32) {
    let %6: int32 = add($b3.0, $b6.0)
    let %7: bool = le(0, %1)
    br %7 b7() b8()
  }
  .bb #b4 () {
    jump b6(%1)
  }
  .bb #b8 () {
    jump b9(%0)
  }
  .bb #b9 (int32) {
    let %8: int32 = add(%6, $b9.0)
    let %9: unit = ext_call minimbt_print_int(%8)
    return %9
  }
  .bb #b0 () {
    let %0: int32 = ext_call minimbt_truncate(1.23)
    let %1: int32 = ext_call minimbt_truncate(4.56)
    let %2: double = neg(7.89)
    let %3: int32 = ext_call minimbt_truncate(%2)
    let %4: bool = le(0, %3)
    br %4 b1() b2()
  }
  .bb #b1 () {
    jump b3(%0)
  }
  .bb #b5 () {
    jump b6(%3)
  }
  .bb #b2 () {
    jump b3(%1)
  }
  .bb #b3 (int32) {
    let %5: bool = le(%0, 0)
    br %5 b4() b5()
  }
  .bb #b7 () {
    jump b9(%3)
  }
}
.thunk ::0 start

  .p2align 3
  .globl _start
  .type _start, @function
_start:
_start_b0:
  call thunk_start
  ret

  .p2align 3
  .globl thunk_start
  .type thunk_start, @function
thunk_start:
.thunk_start_b0:
  call main
  mv v2, zero
  mv a0, v2
  ret

  .p2align 3
  .globl main
  .type main, @function
main:
.main_b0:
  li v31, 4608218246714312622
  fmv.d.x fv32, v31
  fmv.d fa0, fv32
  call minimbt_truncate
  mv v2, a0
  li v28, 4616820122002590269
  fmv.d.x fv29, v28
  fmv.d fa0, fv29
  call minimbt_truncate
  mv v3, a0
  li v25, 4620569368692376207
  fmv.d.x fv26, v25
  fneg.d fv4, fv26
  fmv.d fa0, fv4
  call minimbt_truncate
  mv v5, a0
  slt v22, zero, v5
  xori v6, v22, 1
  bne v6, zero, .main_b1
  j .main_b2

.main_b1:
  mv v7, v2
  j .main_b3

.main_b8:
  mv v12, v2
  j .main_b9

.main_b5:
  mv v9, v5
  j .main_b6

.main_b4:
  mv v9, v3
  j .main_b6

.main_b6:
  add v10, v7, v9
  slt v17, zero, v3
  xori v11, v17, 1
  bne v11, zero, .main_b7
  j .main_b8

.main_b9:
  add v13, v10, v12
  mv a0, v13
  call minimbt_print_int
  mv v14, zero
  mv a0, v14
  ret

.main_b2:
  mv v7, v3
  j .main_b3

.main_b7:
  mv v12, v5
  j .main_b9

.main_b3:
  slt v20, v2, zero
  xori v8, v20, 1
  bne v8, zero, .main_b4
  j .main_b5

  .p2align 3
  .globl start
  .type start, @object
start:
  .zero 4



Testing test/test_src/non-tail-if2.mbt
# name conventions used in the core ir:
# - functions: f<id>
# - blocks: b<id>
# - instructions: %<id>
# - memory: m<id>
# - free variables: ^<id>
# - function parameters: $f<pid>
# - block parameters: $b<bid>.<pid>
.core
.fn f #f1 : closure() -> int32
.freevars ()
.entry b0 {
  .bb #b0 () {
    return 12345
  }
}
.fn thunk_start #f2 : fn() -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: unit = call f0()
    return %0
  }
}
.fn main #f0 : fn() -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let _ = alloc <m0: closure() -> int32 heap(1)> <- [0] = f1
    let _ = alloc <m1: array[int32] heap(10)> <- [..] = 3
    let %2: int32 = load int32 offset(f0.m1, 0)
    let %3: bool = eq(%2, 3)
    br %3 b1() b2()
  }
  .bb #b1 () {
    let %4: int32 = apply f0.m0()
    let %5: int32 = load int32 offset(f0.m1, 1)
    let %6: int32 = add(%4, %5)
    let %7: int32 = add(%6, 67890)
    jump b3(%7)
  }
  .bb #b2 () {
    jump b3(7)
  }
  .bb #b3 (int32) {
    let %8: unit = ext_call minimbt_print_int($b3.0)
    return %8
  }
}
.thunk ::0 start

  .p2align 3
  .globl _start
  .type _start, @function
_start:
_start_b0:
  call thunk_start
  ret

  .p2align 3
  .globl f
  .type f, @function
f:
.f_b0:
  li v2, 12345
  mv a0, v2
  ret

  .p2align 3
  .globl thunk_start
  .type thunk_start, @function
thunk_start:
.thunk_start_b0:
  call main
  mv v2, zero
  mv a0, v2
  ret

  .p2align 3
  .globl main
  .type main, @function
main:
.main_b0:
  addi v34, s11, -8
  andi v2, v34, -8
  la v36, f
  sd v36, 0(v2)
  addi v31, s11, -40
  andi v3, v31, -8
  li v33, 3
  sw v33, 0(v3)
  sw v33, 4(v3)
  sw v33, 8(v3)
  sw v33, 12(v3)
  sw v33, 16(v3)
  sw v33, 20(v3)
  sw v33, 24(v3)
  sw v33, 28(v3)
  sw v33, 32(v3)
  sw v33, 36(v3)
  slli v28, zero, 2
  add v29, v3, v28
  lw v6, 0(v29)
  li v25, 3
  xor v26, v6, v25
  sltiu v7, v26, 1
  bne v7, zero, .main_b1
  j .main_b2

.main_b3:
  mv a0, v12
  call minimbt_print_int
  mv v13, zero
  mv a0, v13
  ret

.main_b1:
  mv s10, v2
  ld v22, 0(v2)
  jalr v22
  mv v8, a0
  li v18, 1
  slli v19, v18, 2
  add v20, v3, v19
  lw v9, 0(v20)
  add v10, v8, v9
  li v15, 67890
  add v11, v10, v15
  mv v12, v11
  j .main_b3

.main_b2:
  li v24, 7
  mv v12, v24
  j .main_b3

  .p2align 3
  .globl start
  .type start, @object
start:
  .zero 4



Testing test/test_src/print.mbt
# name conventions used in the core ir:
# - functions: f<id>
# - blocks: b<id>
# - instructions: %<id>
# - memory: m<id>
# - free variables: ^<id>
# - function parameters: $f<pid>
# - block parameters: $b<bid>.<pid>
.core
.fn thunk_start #f1 : fn() -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: unit = call f0()
    return %0
  }
}
.fn main #f0 : fn() -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: unit = ext_call minimbt_print_int(123)
    let %1: int32 = neg(456)
    let %2: unit = ext_call minimbt_print_int(%1)
    let %3: int32 = add(789, 0)
    let %4: unit = ext_call minimbt_print_int(%3)
    return ()
  }
}
.thunk ::0 start

  .p2align 3
  .globl _start
  .type _start, @function
_start:
_start_b0:
  call thunk_start
  ret

  .p2align 3
  .globl thunk_start
  .type thunk_start, @function
thunk_start:
.thunk_start_b0:
  call main
  mv v2, zero
  mv a0, v2
  ret

  .p2align 3
  .globl main
  .type main, @function
main:
.main_b0:
  li v13, 123
  mv a0, v13
  call minimbt_print_int
  mv v2, zero
  li v11, 456
  neg v3, v11
  mv a0, v3
  call minimbt_print_int
  mv v4, zero
  li v8, 789
  add v5, v8, zero
  mv a0, v5
  call minimbt_print_int
  mv v6, zero
  mv a0, zero
  ret

  .p2align 3
  .globl start
  .type start, @object
start:
  .zero 4



Testing test/test_src/shuffle.mbt
# name conventions used in the core ir:
# - functions: f<id>
# - blocks: b<id>
# - instructions: %<id>
# - memory: m<id>
# - free variables: ^<id>
# - function parameters: $f<pid>
# - block parameters: $b<bid>.<pid>
.core
.fn foo #f0 : fn(int32, int32, int32, int32, int32, int32) -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: unit = ext_call minimbt_print_int($f0)
    let %1: unit = ext_call minimbt_print_int($f1)
    let %2: unit = ext_call minimbt_print_int($f2)
    let %3: unit = ext_call minimbt_print_int($f3)
    let %4: unit = ext_call minimbt_print_int($f4)
    let %5: unit = ext_call minimbt_print_int($f5)
    return ()
  }
}
.fn bar #f1 : fn(int32, int32, int32, int32, int32, int32) -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: unit = call f0($f1, $f0, $f3, $f4, $f5, $f2)
    return %0
  }
}
.fn thunk_start #f3 : fn() -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: unit = call f2()
    return %0
  }
}
.fn main #f2 : fn() -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: unit = call f1(1, 2, 3, 4, 5, 6)
    return %0
  }
}
.thunk ::0 start

  .p2align 3
  .globl _start
  .type _start, @function
_start:
_start_b0:
  call thunk_start
  ret

  .p2align 3
  .globl foo
  .type foo, @function
foo:
.foo_b0:
  mv v2, a0
  mv v3, a1
  mv v4, a2
  mv v5, a3
  mv v6, a4
  mv v7, a5
  mv a0, v2
  call minimbt_print_int
  mv v8, zero
  mv a0, v3
  call minimbt_print_int
  mv v9, zero
  mv a0, v4
  call minimbt_print_int
  mv v10, zero
  mv a0, v5
  call minimbt_print_int
  mv v11, zero
  mv a0, v6
  call minimbt_print_int
  mv v12, zero
  mv a0, v7
  call minimbt_print_int
  mv v13, zero
  mv a0, zero
  ret

  .p2align 3
  .globl thunk_start
  .type thunk_start, @function
thunk_start:
.thunk_start_b0:
  call main
  mv v2, zero
  mv a0, v2
  ret

  .p2align 3
  .globl bar
  .type bar, @function
bar:
.bar_b0:
  mv v2, a0
  mv v3, a1
  mv v4, a2
  mv v5, a3
  mv v6, a4
  mv v7, a5
  mv a0, v3
  mv a1, v2
  mv a2, v5
  mv a3, v6
  mv a4, v7
  mv a5, v4
  call foo
  mv v8, zero
  mv a0, v8
  ret

  .p2align 3
  .globl main
  .type main, @function
main:
.main_b0:
  li v3, 1
  mv a0, v3
  li v4, 2
  mv a1, v4
  li v5, 3
  mv a2, v5
  li v6, 4
  mv a3, v6
  li v7, 5
  mv a4, v7
  li v8, 6
  mv a5, v8
  call bar
  mv v2, zero
  mv a0, v2
  ret

  .p2align 3
  .globl start
  .type start, @object
start:
  .zero 4



Testing test/test_src/spill.mbt
# name conventions used in the core ir:
# - functions: f<id>
# - blocks: b<id>
# - instructions: %<id>
# - memory: m<id>
# - free variables: ^<id>
# - function parameters: $f<pid>
# - block parameters: $b<bid>.<pid>
.core
.fn f #f0 : fn(int32, int32, int32, int32) -> int32
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: int32 = add($f0, $f1)
    let %1: int32 = add($f0, $f2)
    let %2: int32 = add($f0, $f3)
    let %3: int32 = add($f1, $f2)
    let %4: int32 = add($f1, $f3)
    let %5: int32 = add($f2, $f3)
    let %6: int32 = add(%0, %1)
    let %7: int32 = add(%0, %2)
    let %8: int32 = add(%0, %3)
    let %9: int32 = add(%0, %4)
    let %10: int32 = add(%0, %5)
    let %11: int32 = add(%1, %2)
    let %12: int32 = add(%1, %3)
    let %13: int32 = add(%1, %4)
    let %14: int32 = add(%1, %5)
    let %15: int32 = add(%2, %3)
    let %16: int32 = add(%2, %4)
    let %17: int32 = add(%2, %5)
    let %18: int32 = add(%3, %4)
    let %19: int32 = add(%3, %5)
    let %20: int32 = add(%4, %5)
    let %21: int32 = add(%6, %7)
    let %22: int32 = add(%6, %8)
    let %23: int32 = add(%6, %9)
    let %24: int32 = add(%6, %10)
    let %25: int32 = add(%6, %11)
    let %26: int32 = add(%6, %12)
    let %27: int32 = add(%6, %13)
    let %28: int32 = add(%6, %14)
    let %29: int32 = add(%6, %15)
    let %30: int32 = add(%6, %16)
    let %31: int32 = add(%6, %17)
    let %32: int32 = add(%6, %18)
    let %33: int32 = add(%6, %19)
    let %34: int32 = add(%6, %20)
    let %35: int32 = add($f0, $f1)
    let %36: int32 = add(%35, $f2)
    let %37: int32 = add(%36, $f3)
    let %38: int32 = add(%37, %0)
    let %39: int32 = add(%38, %1)
    let %40: int32 = add(%39, %2)
    let %41: int32 = add(%40, %3)
    let %42: int32 = add(%41, %4)
    let %43: int32 = add(%42, %5)
    let %44: int32 = add(%43, %6)
    let %45: int32 = add(%44, %7)
    let %46: int32 = add(%45, %8)
    let %47: int32 = add(%46, %9)
    let %48: int32 = add(%47, %10)
    let %49: int32 = add(%48, %11)
    let %50: int32 = add(%49, %12)
    let %51: int32 = add(%50, %13)
    let %52: int32 = add(%51, %14)
    let %53: int32 = add(%52, %15)
    let %54: int32 = add(%53, %16)
    let %55: int32 = add(%54, %17)
    let %56: int32 = add(%55, %18)
    let %57: int32 = add(%56, %19)
    let %58: int32 = add(%57, %20)
    let %59: int32 = add(%58, %21)
    let %60: int32 = add(%59, %22)
    let %61: int32 = add(%60, %23)
    let %62: int32 = add(%61, %24)
    let %63: int32 = add(%62, %25)
    let %64: int32 = add(%63, %26)
    let %65: int32 = add(%64, %27)
    let %66: int32 = add(%65, %28)
    let %67: int32 = add(%66, %29)
    let %68: int32 = add(%67, %30)
    let %69: int32 = add(%68, %31)
    let %70: int32 = add(%69, %32)
    let %71: int32 = add(%70, %33)
    let %72: int32 = add(%71, %34)
    let %73: int32 = neg(%72)
    return %73
  }
}
.fn thunk_start #f2 : fn() -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: unit = call f1()
    return %0
  }
}
.fn main #f1 : fn() -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: int32 = call f0(1, 2, 3, 4)
    let %1: unit = ext_call minimbt_print_int(%0)
    return %1
  }
}
.thunk ::0 start

  .p2align 3
  .globl _start
  .type _start, @function
_start:
_start_b0:
  call thunk_start
  ret

  .p2align 3
  .globl f
  .type f, @function
f:
.f_b0:
  mv v2, a0
  mv v3, a1
  mv v4, a2
  mv v5, a3
  add v6, v2, v3
  add v7, v2, v4
  add v8, v2, v5
  add v9, v3, v4
  add v10, v3, v5
  add v11, v4, v5
  add v12, v6, v7
  add v13, v6, v8
  add v14, v6, v9
  add v15, v6, v10
  add v16, v6, v11
  add v17, v7, v8
  add v18, v7, v9
  add v19, v7, v10
  add v20, v7, v11
  add v21, v8, v9
  add v22, v8, v10
  add v23, v8, v11
  add v24, v9, v10
  add v25, v9, v11
  add v26, v10, v11
  add v27, v12, v13
  add v28, v12, v14
  add v29, v12, v15
  add v30, v12, v16
  add v31, v12, v17
  add v32, v12, v18
  add v33, v12, v19
  add v34, v12, v20
  add v35, v12, v21
  add v36, v12, v22
  add v37, v12, v23
  add v38, v12, v24
  add v39, v12, v25
  add v40, v12, v26
  add v41, v2, v3
  add v42, v41, v4
  add v43, v42, v5
  add v44, v43, v6
  add v45, v44, v7
  add v46, v45, v8
  add v47, v46, v9
  add v48, v47, v10
  add v49, v48, v11
  add v50, v49, v12
  add v51, v50, v13
  add v52, v51, v14
  add v53, v52, v15
  add v54, v53, v16
  add v55, v54, v17
  add v56, v55, v18
  add v57, v56, v19
  add v58, v57, v20
  add v59, v58, v21
  add v60, v59, v22
  add v61, v60, v23
  add v62, v61, v24
  add v63, v62, v25
  add v64, v63, v26
  add v65, v64, v27
  add v66, v65, v28
  add v67, v66, v29
  add v68, v67, v30
  add v69, v68, v31
  add v70, v69, v32
  add v71, v70, v33
  add v72, v71, v34
  add v73, v72, v35
  add v74, v73, v36
  add v75, v74, v37
  add v76, v75, v38
  add v77, v76, v39
  add v78, v77, v40
  neg v79, v78
  mv a0, v79
  ret

  .p2align 3
  .globl thunk_start
  .type thunk_start, @function
thunk_start:
.thunk_start_b0:
  call main
  mv v2, zero
  mv a0, v2
  ret

  .p2align 3
  .globl main
  .type main, @function
main:
.main_b0:
  li v5, 1
  mv a0, v5
  li v6, 2
  mv a1, v6
  li v7, 3
  mv a2, v7
  li v8, 4
  mv a3, v8
  call f
  mv v2, a0
  mv a0, v2
  call minimbt_print_int
  mv v3, zero
  mv a0, v3
  ret

  .p2align 3
  .globl start
  .type start, @object
start:
  .zero 4



Testing test/test_src/spill2.mbt
# name conventions used in the core ir:
# - functions: f<id>
# - blocks: b<id>
# - instructions: %<id>
# - memory: m<id>
# - free variables: ^<id>
# - function parameters: $f<pid>
# - block parameters: $b<bid>.<pid>
.core
.fn main #f2 : fn() -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let _ = alloc <m0: array[int32] heap(10)> <- [..] = 1
    let %1: int32 = call f0()
    let %2: int32 = load int32 offset(f2.m0, 0)
    let %3: int32 = add(%2, %2)
    let %4: int32 = add(%3, %3)
    let %5: int32 = add(%4, %4)
    let %6: int32 = add(%5, %5)
    let %7: int32 = add(%6, %6)
    let %8: int32 = add(%7, %7)
    let %9: int32 = add(%8, %8)
    let %10: int32 = add(%9, %9)
    let %11: int32 = add(%10, %10)
    let %12: int32 = add(%11, %11)
    let %13: int32 = add(%12, %12)
    let %14: int32 = add(%13, %13)
    let %15: int32 = add(%14, %14)
    let %16: int32 = add(%15, %15)
    let %17: int32 = add(%16, %16)
    let %18: int32 = load int32 offset(f2.m0, 1)
    let %19: bool = eq(%18, 0)
    br %19 b1() b2()
  }
  .bb #b1 () {
    let %20: int32 = call f1(67890)
    jump b3(%20)
  }
  .bb #b2 () {
    let %21: int32 = add(%2, %3)
    let %22: int32 = add(%21, %4)
    let %23: int32 = add(%22, %5)
    let %24: int32 = add(%23, %6)
    let %25: int32 = add(%24, %7)
    let %26: int32 = add(%25, %8)
    let %27: int32 = add(%26, %9)
    let %28: int32 = add(%27, %10)
    let %29: int32 = add(%28, %11)
    let %30: int32 = add(%29, %12)
    let %31: int32 = add(%30, %13)
    let %32: int32 = add(%31, %14)
    let %33: int32 = add(%32, %15)
    let %34: int32 = add(%33, %16)
    let %35: int32 = add(%34, %17)
    let %36: int32 = add(%35, %1)
    jump b3(%36)
  }
  .bb #b3 (int32) {
    let %37: unit = ext_call minimbt_print_int($b3.0)
    return %37
  }
}
.fn f #f0 : fn() -> int32
.freevars ()
.entry b0 {
  .bb #b0 () {
    return 12345
  }
}
.fn thunk_start #f3 : fn() -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: unit = call f2()
    return %0
  }
}
.fn g #f1 : fn(int32) -> int32
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: int32 = add($f0, 1)
    return %0
  }
}
.thunk ::0 start

  .p2align 3
  .globl _start
  .type _start, @function
_start:
_start_b0:
  call thunk_start
  ret

  .p2align 3
  .globl f
  .type f, @function
f:
.f_b0:
  li v2, 12345
  mv a0, v2
  ret

  .p2align 3
  .globl thunk_start
  .type thunk_start, @function
thunk_start:
.thunk_start_b0:
  call main
  mv v2, zero
  mv a0, v2
  ret

  .p2align 3
  .globl g
  .type g, @function
g:
.g_b0:
  mv v2, a0
  li v4, 1
  add v3, v2, v4
  mv a0, v3
  ret

  .p2align 3
  .globl main
  .type main, @function
main:
.main_b0:
  addi v86, s11, -40
  andi v2, v86, -8
  li v88, 1
  sw v88, 0(v2)
  sw v88, 4(v2)
  sw v88, 8(v2)
  sw v88, 12(v2)
  sw v88, 16(v2)
  sw v88, 20(v2)
  sw v88, 24(v2)
  sw v88, 28(v2)
  sw v88, 32(v2)
  sw v88, 36(v2)
  call f
  mv v4, a0
  slli v82, zero, 2
  add v83, v2, v82
  lw v5, 0(v83)
  add v6, v5, v5
  add v7, v6, v6
  add v8, v7, v7
  add v9, v8, v8
  add v10, v9, v9
  add v11, v10, v10
  add v12, v11, v11
  add v13, v12, v12
  add v14, v13, v13
  add v15, v14, v14
  add v16, v15, v15
  add v17, v16, v16
  add v18, v17, v17
  add v19, v18, v18
  add v20, v19, v19
  li v63, 1
  slli v64, v63, 2
  add v65, v2, v64
  lw v21, 0(v65)
  xor v61, v21, zero
  sltiu v22, v61, 1
  bne v22, zero, .main_b1
  j .main_b2

.main_b3:
  mv a0, v40
  call minimbt_print_int
  mv v41, zero
  mv a0, v41
  ret

.main_b1:
  li v43, 67890
  mv a0, v43
  call g
  mv v39, a0
  mv v40, v39
  j .main_b3

.main_b2:
  add v23, v5, v6
  add v24, v23, v7
  add v25, v24, v8
  add v26, v25, v9
  add v27, v26, v10
  add v28, v27, v11
  add v29, v28, v12
  add v30, v29, v13
  add v31, v30, v14
  add v32, v31, v15
  add v33, v32, v16
  add v34, v33, v17
  add v35, v34, v18
  add v36, v35, v19
  add v37, v36, v20
  add v38, v37, v4
  mv v40, v38
  j .main_b3

  .p2align 3
  .globl start
  .type start, @object
start:
  .zero 4



Testing test/test_src/spill3.mbt
# name conventions used in the core ir:
# - functions: f<id>
# - blocks: b<id>
# - instructions: %<id>
# - memory: m<id>
# - free variables: ^<id>
# - function parameters: $f<pid>
# - block parameters: $b<bid>.<pid>
.core
.fn f #f0 : fn(int32) -> int32
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: int32 = add($f0, 1)
    let %1: int32 = add(%0, 1)
    let %2: int32 = add(%1, 1)
    let %3: int32 = add(%2, 1)
    let %4: int32 = add(%3, 1)
    let %5: int32 = add(%4, 1)
    let %6: int32 = add(%5, 1)
    let %7: int32 = add(%6, 1)
    let %8: int32 = add(%7, 1)
    let %9: int32 = add(%8, 1)
    let %10: int32 = add(%9, 1)
    let %11: int32 = add(%10, 1)
    let %12: int32 = add(%11, 1)
    let %13: int32 = add(%12, 1)
    let %14: int32 = add(%13, 1)
    let %15: int32 = add(%14, 1)
    let %16: int32 = add(%15, 1)
    let %17: int32 = add(%16, 1)
    let %18: int32 = add(%17, %0)
    let %19: int32 = add(%18, %1)
    let %20: int32 = add(%19, %2)
    let %21: int32 = add(%20, %3)
    let %22: int32 = add(%21, %4)
    let %23: int32 = add(%22, %5)
    let %24: int32 = add(%23, %6)
    let %25: int32 = add(%24, %7)
    let %26: int32 = add(%25, %8)
    let %27: int32 = add(%26, %9)
    let %28: int32 = add(%27, %10)
    let %29: int32 = add(%28, %11)
    let %30: int32 = add(%29, %12)
    let %31: int32 = add(%30, %13)
    let %32: int32 = add(%31, %14)
    let %33: int32 = add(%32, %15)
    let %34: int32 = add(%33, %16)
    let %35: int32 = add(%34, $f0)
    let %36: int32 = add(%0, %1)
    let %37: int32 = add(%36, %2)
    let %38: int32 = add(%37, %3)
    let %39: int32 = add(%38, %4)
    let %40: int32 = add(%39, %5)
    let %41: int32 = add(%40, %6)
    let %42: int32 = add(%41, %7)
    let %43: int32 = add(%42, %8)
    let %44: int32 = add(%43, %9)
    let %45: int32 = add(%44, %10)
    let %46: int32 = add(%45, %11)
    let %47: int32 = add(%46, %12)
    let %48: int32 = add(%47, %13)
    let %49: int32 = add(%48, %14)
    let %50: int32 = add(%49, %15)
    let %51: int32 = add(%50, %16)
    let %52: int32 = add(%51, %17)
    let %53: int32 = add(%52, %18)
    let %54: int32 = add(%53, %19)
    let %55: int32 = add(%54, %20)
    let %56: int32 = add(%55, %21)
    let %57: int32 = add(%56, %22)
    let %58: int32 = add(%57, %23)
    let %59: int32 = add(%58, %24)
    let %60: int32 = add(%59, %25)
    let %61: int32 = add(%60, %26)
    let %62: int32 = add(%61, %27)
    let %63: int32 = add(%62, %28)
    let %64: int32 = add(%63, %29)
    let %65: int32 = add(%64, %30)
    let %66: int32 = add(%65, %31)
    let %67: int32 = add(%66, %32)
    let %68: int32 = add(%67, %33)
    let %69: int32 = add(%68, %34)
    let %70: int32 = add(%69, %35)
    let %71: int32 = add(%70, $f0)
    return %71
  }
}
.fn thunk_start #f2 : fn() -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: unit = call f1()
    return %0
  }
}
.fn main #f1 : fn() -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: int32 = call f0(0)
    let %1: unit = ext_call minimbt_print_int(%0)
    return %1
  }
}
.thunk ::0 start

  .p2align 3
  .globl _start
  .type _start, @function
_start:
_start_b0:
  call thunk_start
  ret

  .p2align 3
  .globl f
  .type f, @function
f:
.f_b0:
  mv v2, a0
  li v163, 1
  add v3, v2, v163
  li v161, 1
  add v4, v3, v161
  li v159, 1
  add v5, v4, v159
  li v157, 1
  add v6, v5, v157
  li v155, 1
  add v7, v6, v155
  li v153, 1
  add v8, v7, v153
  li v151, 1
  add v9, v8, v151
  li v149, 1
  add v10, v9, v149
  li v147, 1
  add v11, v10, v147
  li v145, 1
  add v12, v11, v145
  li v143, 1
  add v13, v12, v143
  li v141, 1
  add v14, v13, v141
  li v139, 1
  add v15, v14, v139
  li v137, 1
  add v16, v15, v137
  li v135, 1
  add v17, v16, v135
  li v133, 1
  add v18, v17, v133
  li v131, 1
  add v19, v18, v131
  li v129, 1
  add v20, v19, v129
  add v21, v20, v3
  add v22, v21, v4
  add v23, v22, v5
  add v24, v23, v6
  add v25, v24, v7
  add v26, v25, v8
  add v27, v26, v9
  add v28, v27, v10
  add v29, v28, v11
  add v30, v29, v12
  add v31, v30, v13
  add v32, v31, v14
  add v33, v32, v15
  add v34, v33, v16
  add v35, v34, v17
  add v36, v35, v18
  add v37, v36, v19
  add v38, v37, v2
  add v39, v3, v4
  add v40, v39, v5
  add v41, v40, v6
  add v42, v41, v7
  add v43, v42, v8
  add v44, v43, v9
  add v45, v44, v10
  add v46, v45, v11
  add v47, v46, v12
  add v48, v47, v13
  add v49, v48, v14
  add v50, v49, v15
  add v51, v50, v16
  add v52, v51, v17
  add v53, v52, v18
  add v54, v53, v19
  add v55, v54, v20
  add v56, v55, v21
  add v57, v56, v22
  add v58, v57, v23
  add v59, v58, v24
  add v60, v59, v25
  add v61, v60, v26
  add v62, v61, v27
  add v63, v62, v28
  add v64, v63, v29
  add v65, v64, v30
  add v66, v65, v31
  add v67, v66, v32
  add v68, v67, v33
  add v69, v68, v34
  add v70, v69, v35
  add v71, v70, v36
  add v72, v71, v37
  add v73, v72, v38
  add v74, v73, v2
  mv a0, v74
  ret

  .p2align 3
  .globl thunk_start
  .type thunk_start, @function
thunk_start:
.thunk_start_b0:
  call main
  mv v2, zero
  mv a0, v2
  ret

  .p2align 3
  .globl main
  .type main, @function
main:
.main_b0:
  mv a0, zero
  call f
  mv v2, a0
  mv a0, v2
  call minimbt_print_int
  mv v3, zero
  mv a0, v3
  ret

  .p2align 3
  .globl start
  .type start, @object
start:
  .zero 4



Testing test/test_src/sum-tail.mbt
# name conventions used in the core ir:
# - functions: f<id>
# - blocks: b<id>
# - instructions: %<id>
# - memory: m<id>
# - free variables: ^<id>
# - function parameters: $f<pid>
# - block parameters: $b<bid>.<pid>
.core
.fn thunk_start #f2 : fn() -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: unit = call f1()
    return %0
  }
}
.fn sum #f0 : fn(int32, int32) -> int32
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: bool = le($f1, 0)
    br %0 b1() b2()
  }
  .bb #b1 () {
    jump b3($f0)
  }
  .bb #b2 () {
    let %1: int32 = add($f0, $f1)
    let %2: int32 = sub($f1, 1)
    let %3: int32 = call f0(%1, %2)
    jump b3(%3)
  }
  .bb #b3 (int32) {
    return $b3.0
  }
}
.fn main #f1 : fn() -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: int32 = call f0(0, 10000)
    let %1: unit = ext_call minimbt_print_int(%0)
    return %1
  }
}
.thunk ::0 start

  .p2align 3
  .globl _start
  .type _start, @function
_start:
_start_b0:
  call thunk_start
  ret

  .p2align 3
  .globl thunk_start
  .type thunk_start, @function
thunk_start:
.thunk_start_b0:
  call main
  mv v2, zero
  mv a0, v2
  ret

  .p2align 3
  .globl sum
  .type sum, @function
sum:
.sum_b0:
  mv v2, a0
  mv v3, a1
  slt v13, v3, zero
  xori v4, v13, 1
  bne v4, zero, .sum_b1
  j .sum_b2

.sum_b1:
  mv v8, v2
  j .sum_b3

.sum_b3:
  mv a0, v8
  ret

.sum_b2:
  add v5, v2, v3
  li v10, 1
  sub v6, v3, v10
  mv a0, v5
  mv a1, v6
  call sum
  mv v7, a0
  mv v8, v7
  j .sum_b3

  .p2align 3
  .globl main
  .type main, @function
main:
.main_b0:
  mv a0, zero
  li v5, 10000
  mv a1, v5
  call sum
  mv v2, a0
  mv a0, v2
  call minimbt_print_int
  mv v3, zero
  mv a0, v3
  ret

  .p2align 3
  .globl start
  .type start, @object
start:
  .zero 4



Testing test/test_src/sum.mbt
# name conventions used in the core ir:
# - functions: f<id>
# - blocks: b<id>
# - instructions: %<id>
# - memory: m<id>
# - free variables: ^<id>
# - function parameters: $f<pid>
# - block parameters: $b<bid>.<pid>
.core
.fn thunk_start #f2 : fn() -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: unit = call f1()
    return %0
  }
}
.fn sum #f0 : fn(int32) -> int32
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: bool = le($f0, 0)
    br %0 b1() b2()
  }
  .bb #b1 () {
    jump b3(0)
  }
  .bb #b2 () {
    let %1: int32 = sub($f0, 1)
    let %2: int32 = call f0(%1)
    let %3: int32 = add(%2, $f0)
    jump b3(%3)
  }
  .bb #b3 (int32) {
    return $b3.0
  }
}
.fn main #f1 : fn() -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: int32 = call f0(10000)
    let %1: unit = ext_call minimbt_print_int(%0)
    return %1
  }
}
.thunk ::0 start

  .p2align 3
  .globl _start
  .type _start, @function
_start:
_start_b0:
  call thunk_start
  ret

  .p2align 3
  .globl thunk_start
  .type thunk_start, @function
thunk_start:
.thunk_start_b0:
  call main
  mv v2, zero
  mv a0, v2
  ret

  .p2align 3
  .globl sum
  .type sum, @function
sum:
.sum_b0:
  mv v2, a0
  slt v12, v2, zero
  xori v3, v12, 1
  bne v3, zero, .sum_b1
  j .sum_b2

.sum_b1:
  mv v7, zero
  j .sum_b3

.sum_b3:
  mv a0, v7
  ret

.sum_b2:
  li v10, 1
  sub v4, v2, v10
  mv a0, v4
  call sum
  mv v5, a0
  add v6, v5, v2
  mv v7, v6
  j .sum_b3

  .p2align 3
  .globl main
  .type main, @function
main:
.main_b0:
  li v5, 10000
  mv a0, v5
  call sum
  mv v2, a0
  mv a0, v2
  call minimbt_print_int
  mv v3, zero
  mv a0, v3
  ret

  .p2align 3
  .globl start
  .type start, @object
start:
  .zero 4



