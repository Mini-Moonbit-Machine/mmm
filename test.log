Testing test/test_src/ack.mbt
# name conventions used in the core ir:
# - functions: f<id>
# - blocks: b<id>
# - instructions: %<id>
# - memory: m<id>
# - free variables: ^<id>
# - function parameters: $f<pid>
# - block parameters: $b<bid>.<pid>
.core
.fn ack #f0 : fn(int32, int32) -> int32
.freevars ()
.entry b0 {
  .bb #b6 (int32) {
    return $b6.0
  }
  .bb #b4 () {
    let %5: int32 = sub($f0, 1)
    let %6: int32 = sub($f1, 1)
    let %7: int32 = call f0($f0, %6)
    let %8: int32 = call f0(%5, %7)
    jump b5(%8)
  }
  .bb #b1 () {
    let %1: int32 = add($f1, 1)
    jump b6(%1)
  }
  .bb #b5 (int32) {
    jump b6($b5.0)
  }
  .bb #b2 () {
    let %2: bool = le($f1, 0)
    br %2 b3() b4()
  }
  .bb #b3 () {
    let %3: int32 = sub($f0, 1)
    let %4: int32 = call f0(%3, 1)
    jump b5(%4)
  }
  .bb #b0 () {
    let %0: bool = le($f0, 0)
    br %0 b1() b2()
  }
}
.fn thunk_start #f2 : fn() -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: unit = call f1()
    return %0
  }
}
.fn main #f1 : fn() -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: int32 = call f0(3, 8)
    let %1: unit = ext_call minimbt_print_int(%0)
    return %1
  }
}
.thunk ::0 start

  .p2align 3
  .globl _start
  .type _start, @function
_start:
; block info: defs: [t1, ft0, ft1, a1, t5, fa1, fa2, ft6, a4, fa6, a6, ft5, ft10, ft7, ft4, ft9, a5, a0, fa4, ft2, a2, a3, ft8, t3, a7, fa7, t0, fa5, fa3, ft3, fa0, t4, t2], uses: [a0], upward_exposed: [], params_defs: []
; live_in: [], live_out: []
; block parameters: []
_start_b0:
  call thunk_start  ; live: [a0]
; control
  ret  ; live: []

  .p2align 3
  .globl ack
  .type ack, @function
ack:
; block info: defs: [v3, v4, v29, v2], uses: [a0, zero, v29, v4, a1, v2], upward_exposed: [a1, a0, zero], params_defs: []
; live_in: [a1, a0, zero], live_out: [v2, zero, v3]
; block parameters: []
.ack_b0:
  mv v2, a0  ; live: [a1, a0, zero, v2]
  mv v3, a1  ; live: [a1, a0, zero, v2]
  slt v29, v2, zero  ; live: [a1, a0, zero, v29]
  xori v4, v29, 1  ; live: [v4, a1, a0, zero]
; control
  bne v4, zero, .ack_b1  ; live: [a1, a0, zero]
  j .ack_b2  ; live: [a1, a0, zero]

; block info: defs: [v14, v15, v13], uses: [v15, v13, v3], upward_exposed: [v3], params_defs: []
; live_in: [v3], live_out: [v14]
; block parameters: []
.ack_b1:
  li v15, 1  ; live: [v15, v3]
  add v13, v3, v15  ; live: [v13, v3]
; control
  mv v14, v13  ; live: [v3]
  j .ack_b6  ; live: [v3]

; block info: defs: [v14], uses: [v12], upward_exposed: [v12], params_defs: [v12]
; live_in: [v12], live_out: [v14]
; block parameters: [v12]
.ack_b5:
; control
  mv v14, v12  ; live: [v12]
  j .ack_b6  ; live: [v12]

; block info: defs: [v5, v27], uses: [v5, zero, v27, v3], upward_exposed: [zero, v3], params_defs: []
; live_in: [v2, zero, v3], live_out: [v3, v2]
; block parameters: []
.ack_b2:
  slt v27, v3, zero  ; live: [v3, zero, v27, v2]
  xori v5, v27, 1  ; live: [v3, v5, zero, v2]
; control
  bne v5, zero, .ack_b3  ; live: [v3, zero, v2]
  j .ack_b4  ; live: [v3, zero, v2]

; block info: defs: [a0], uses: [v14, a0], upward_exposed: [v14], params_defs: [v14]
; live_in: [v14], live_out: []
; block parameters: [v14]
.ack_b6:
; control
  mv a0, v14  ; live: [v14, a0]
  ret  ; live: [v14]

; block info: defs: [v25, t1, v7, ft0, ft1, a1, v12, t5, fa1, fa2, ft6, a4, fa6, v8, a6, ft10, ft5, v6, ft7, ft4, ft9, a5, a0, fa4, ft2, a2, a3, v9, ft8, t3, a7, fa7, t0, fa5, fa3, v23, ft3, fa0, t4, t2], uses: [v2, v25, a0, v23, v7, v8, a1, v6, v9, v3], upward_exposed: [v3, v2], params_defs: []
; live_in: [v2, v3], live_out: [v12]
; block parameters: []
.ack_b4:
  li v25, 1  ; live: [v3, v25, v2]
  sub v6, v2, v25  ; live: [v3, v6, v2]
  li v23, 1  ; live: [v3, v6, v23, v2]
  sub v7, v3, v23  ; live: [v3, v7, v6, v2]
  mv a0, v2  ; live: [v3, v7, v6, a0, v2]
  mv a1, v7  ; live: [v3, v6, a1, a0, v2]
  call ack  ; live: [v3, v6, a0, v2]
  mv v8, a0  ; live: [v3, v8, v6, v2]
  mv a0, v6  ; live: [v3, v8, a0, v2]
  mv a1, v8  ; live: [v3, a1, a0, v2]
  call ack  ; live: [v3, a0, v2]
  mv v9, a0  ; live: [v3, v9, v2]
; control
  mv v12, v9  ; live: [v3, v2]
  j .ack_b5  ; live: [v3, v2]

; block info: defs: [t1, ft0, ft1, a1, v12, t5, fa1, fa2, ft6, a4, fa6, v19, a6, ft5, ft10, ft7, v11, ft4, v10, ft9, a5, a0, fa4, ft2, a2, v17, a3, ft8, a7, t3, fa7, t0, fa5, fa3, ft3, fa0, t4, t2], uses: [v11, v10, a0, v19, v17, a1, v2], upward_exposed: [v2], params_defs: []
; live_in: [v2], live_out: [v12]
; block parameters: []
.ack_b3:
  li v19, 1  ; live: [v19, v2]
  sub v10, v2, v19  ; live: [v10, v2]
  mv a0, v10  ; live: [a0, v2]
  li v17, 1  ; live: [v17, a0, v2]
  mv a1, v17  ; live: [a1, a0, v2]
  call ack  ; live: [a0, v2]
  mv v11, a0  ; live: [v11, v2]
; control
  mv v12, v11  ; live: [v2]
  j .ack_b5  ; live: [v2]

  .p2align 3
  .globl thunk_start
  .type thunk_start, @function
thunk_start:
; block info: defs: [t1, ft0, ft1, a1, t5, fa1, fa2, ft6, a4, fa6, a6, ft5, ft10, ft7, ft4, ft9, a5, a0, fa4, ft2, a2, a3, ft8, t3, a7, fa7, t0, fa5, fa3, ft3, fa0, t4, t2, v2], uses: [zero, a0, v2], upward_exposed: [zero], params_defs: []
; live_in: [zero], live_out: []
; block parameters: []
.thunk_start_b0:
  call main  ; live: [zero]
  mv v2, zero  ; live: [zero, v2]
; control
  mv a0, v2  ; live: [zero, a0]
  ret  ; live: [zero]

  .p2align 3
  .globl main
  .type main, @function
main:
; block info: defs: [v3, t1, ft0, ft1, a1, t5, fa1, fa2, ft6, a4, fa6, a6, ft5, ft10, v6, ft7, ft4, v5, ft9, a5, a0, fa4, ft2, a2, a3, ft8, t3, a7, fa7, t0, fa5, fa3, ft3, fa0, t4, t2, v2], uses: [v3, v5, a0, zero, v6, a1, v2], upward_exposed: [zero], params_defs: []
; live_in: [zero], live_out: []
; block parameters: []
.main_b0:
  li v5, 3  ; live: [v5, zero]
  mv a0, v5  ; live: [zero, a0]
  li v6, 8  ; live: [v6, zero, a0]
  mv a1, v6  ; live: [a1, zero, a0]
  call ack  ; live: [zero, a0]
  mv v2, a0  ; live: [zero, v2]
  mv a0, v2  ; live: [zero, a0]
  call minimbt_print_int  ; live: [zero]
  mv v3, zero  ; live: [zero, v3]
; control
  mv a0, v3  ; live: [zero, a0]
  ret  ; live: [zero]

  .p2align 3
  .globl start
  .type start, @object
start:
  .zero 4



Testing test/test_src/adder.mbt
# name conventions used in the core ir:
# - functions: f<id>
# - blocks: b<id>
# - instructions: %<id>
# - memory: m<id>
# - free variables: ^<id>
# - function parameters: $f<pid>
# - block parameters: $b<bid>.<pid>
.core
.fn main #f2 : fn() -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: closure(int32) -> int32 = call f0(3)
    let %1: int32 = apply %0(7)
    let %2: unit = ext_call minimbt_print_int(%1)
    return %2
  }
}
.fn make_adder #f0 : fn(int32) -> closure(int32) -> int32
.freevars ()
.entry b0 {
  .bb #b0 () {
    let _ = alloc <m0: closure(int32) -> int32 heap(2)> <- [0] = f1, [1] = $f0
    return f0.m0
  }
}
.fn thunk_start #f3 : fn() -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: unit = call f2()
    return %0
  }
}
.fn adder #f1 : closure(int32) -> int32
.freevars (int32)
.entry b0 {
  .bb #b0 () {
    let %0: int32 = add(^1, $f0)
    return %0
  }
}
.thunk ::0 start

  .p2align 3
  .globl adder
  .type adder, @function
adder:
; block info: defs: [v3, v0, v4, a0, v2], uses: [v3, a0, v0, v4, s10, v2], upward_exposed: [s10, a0], params_defs: []
; live_in: [s10, a0], live_out: []
; block parameters: []
.adder_b0:
  mv v0, s10  ; live: [v0, s10, a0]
  mv v2, a0  ; live: [v0, s10, v2]
  lw v3, 8(v0)  ; live: [v2, s10, v3]
  add v4, v3, v2  ; live: [v4, s10]
; control
  mv a0, v4  ; live: [s10, a0]
  ret  ; live: [s10, a0]

  .p2align 3
  .globl _start
  .type _start, @function
_start:
; block info: defs: [t1, ft0, ft1, a1, t5, fa1, fa2, ft6, a4, fa6, a6, ft5, ft10, ft7, ft4, ft9, a5, a0, fa4, ft2, a2, a3, ft8, t3, a7, fa7, t0, fa5, fa3, ft3, fa0, t4, t2], uses: [a0], upward_exposed: [], params_defs: []
; live_in: [], live_out: []
; block parameters: []
_start_b0:
  call thunk_start  ; live: [a0]
; control
  ret  ; live: []

  .p2align 3
  .globl thunk_start
  .type thunk_start, @function
thunk_start:
; block info: defs: [t1, ft0, ft1, a1, t5, fa1, fa2, ft6, a4, fa6, a6, ft5, ft10, ft7, ft4, ft9, a5, a0, fa4, ft2, a2, a3, ft8, t3, a7, fa7, t0, fa5, fa3, ft3, fa0, t4, t2, v2], uses: [zero, a0, v2], upward_exposed: [zero], params_defs: []
; live_in: [zero], live_out: []
; block parameters: []
.thunk_start_b0:
  call main  ; live: [zero]
  mv v2, zero  ; live: [zero, v2]
; control
  mv a0, v2  ; live: [zero, a0]
  ret  ; live: [zero]

  .p2align 3
  .globl make_adder
  .type make_adder, @function
make_adder:
; block info: defs: [v3, v7, v5, a0, v2], uses: [v2, v5, a0, v7, s11, v3], upward_exposed: [s11, a0], params_defs: []
; live_in: [s11, a0], live_out: []
; block parameters: []
.make_adder_b0:
  mv v2, a0  ; live: [s11, v2]
  addi v5, s11, -16  ; live: [v5, s11, v2]
  andi v3, v5, -8  ; live: [v2, s11, v3]
  la v7, adder  ; live: [v2, v7, s11, v3]
  sd v7, 0(v3)  ; live: [v2, s11, v3]
  sd v2, 8(v3)  ; live: [s11, v3]
; control
  mv a0, v3  ; live: [s11, a0]
  ret  ; live: [s11, a0]

  .p2align 3
  .globl main
  .type main, @function
main:
; block info: defs: [v3, t1, v7, ft0, ft1, a1, t5, fa1, fa2, ft6, a4, fa6, a6, ft5, ft10, v4, v6, ft7, ft4, ft9, a5, a0, fa4, ft2, a2, a3, v9, s10, ft8, a7, t3, fa7, t0, fa5, fa3, ft3, fa0, t4, t2, v2], uses: [v2, a0, zero, v7, v4, v9, v3], upward_exposed: [zero], params_defs: []
; live_in: [zero], live_out: []
; block parameters: []
.main_b0:
  li v9, 3  ; live: [zero, v9]
  mv a0, v9  ; live: [zero, a0]
  call make_adder  ; live: [zero, a0]
  mv v2, a0  ; live: [zero, v2]
  mv s10, v2  ; live: [zero, v2]
  ld v6, 0(v2)  ; live: [zero]
  li v7, 7  ; live: [zero, v7]
  mv a0, v7  ; live: [zero, a0]
  jalr v6  ; live: [zero, a0]
  mv v3, a0  ; live: [zero, v3]
  mv a0, v3  ; live: [zero, a0]
  call minimbt_print_int  ; live: [zero]
  mv v4, zero  ; live: [v4, zero]
; control
  mv a0, v4  ; live: [zero, a0]
  ret  ; live: [zero]

  .p2align 3
  .globl start
  .type start, @object
start:
  .zero 4



Testing test/test_src/adder2.mbt
# name conventions used in the core ir:
# - functions: f<id>
# - blocks: b<id>
# - instructions: %<id>
# - memory: m<id>
# - free variables: ^<id>
# - function parameters: $f<pid>
# - block parameters: $b<bid>.<pid>
.core
.fn main #f2 : fn() -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: closure(int32) -> int32 = call f0(2)
    let %1: closure(int32) -> int32 = call f0(3)
    let %2: int32 = apply %0(10)
    let %3: int32 = apply %1(20)
    let %4: int32 = add(%2, %3)
    let %5: unit = ext_call minimbt_print_int(%4)
    return %5
  }
}
.fn make_adder #f0 : fn(int32) -> closure(int32) -> int32
.freevars ()
.entry b0 {
  .bb #b0 () {
    let _ = alloc <m0: closure(int32) -> int32 heap(2)> <- [0] = f1, [1] = $f0
    return f0.m0
  }
}
.fn thunk_start #f3 : fn() -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: unit = call f2()
    return %0
  }
}
.fn adder #f1 : closure(int32) -> int32
.freevars (int32)
.entry b0 {
  .bb #b0 () {
    let %0: int32 = add(^1, $f0)
    return %0
  }
}
.thunk ::0 start

  .p2align 3
  .globl adder
  .type adder, @function
adder:
; block info: defs: [v3, v0, v4, a0, v2], uses: [v3, a0, v0, v4, s10, v2], upward_exposed: [s10, a0], params_defs: []
; live_in: [s10, a0], live_out: []
; block parameters: []
.adder_b0:
  mv v0, s10  ; live: [v0, s10, a0]
  mv v2, a0  ; live: [v0, s10, v2]
  lw v3, 8(v0)  ; live: [v2, s10, v3]
  add v4, v3, v2  ; live: [v4, s10]
; control
  mv a0, v4  ; live: [s10, a0]
  ret  ; live: [s10, a0]

  .p2align 3
  .globl _start
  .type _start, @function
_start:
; block info: defs: [t1, ft0, ft1, a1, t5, fa1, fa2, ft6, a4, fa6, a6, ft5, ft10, ft7, ft4, ft9, a5, a0, fa4, ft2, a2, a3, ft8, t3, a7, fa7, t0, fa5, fa3, ft3, fa0, t4, t2], uses: [a0], upward_exposed: [], params_defs: []
; live_in: [], live_out: []
; block parameters: []
_start_b0:
  call thunk_start  ; live: [a0]
; control
  ret  ; live: []

  .p2align 3
  .globl thunk_start
  .type thunk_start, @function
thunk_start:
; block info: defs: [t1, ft0, ft1, a1, t5, fa1, fa2, ft6, a4, fa6, a6, ft5, ft10, ft7, ft4, ft9, a5, a0, fa4, ft2, a2, a3, ft8, t3, a7, fa7, t0, fa5, fa3, ft3, fa0, t4, t2, v2], uses: [zero, a0, v2], upward_exposed: [zero], params_defs: []
; live_in: [zero], live_out: []
; block parameters: []
.thunk_start_b0:
  call main  ; live: [zero]
  mv v2, zero  ; live: [zero, v2]
; control
  mv a0, v2  ; live: [zero, a0]
  ret  ; live: [zero]

  .p2align 3
  .globl make_adder
  .type make_adder, @function
make_adder:
; block info: defs: [v3, v7, v5, a0, v2], uses: [v2, v5, a0, v7, s11, v3], upward_exposed: [s11, a0], params_defs: []
; live_in: [s11, a0], live_out: []
; block parameters: []
.make_adder_b0:
  mv v2, a0  ; live: [s11, v2]
  addi v5, s11, -16  ; live: [v5, s11, v2]
  andi v3, v5, -8  ; live: [v2, s11, v3]
  la v7, adder  ; live: [v2, v7, s11, v3]
  sd v7, 0(v3)  ; live: [v2, s11, v3]
  sd v2, 8(v3)  ; live: [s11, v3]
; control
  mv a0, v3  ; live: [s11, a0]
  ret  ; live: [s11, a0]

  .p2align 3
  .globl main
  .type main, @function
main:
; block info: defs: [v3, t1, v16, v14, v13, v7, ft0, ft1, a1, t5, fa1, fa2, ft6, a4, fa6, a6, ft5, ft10, v4, v6, ft7, v11, ft4, v5, ft9, v10, a5, fa4, a0, ft2, a2, a3, s10, ft8, t3, a7, fa7, t0, fa5, v18, fa3, ft3, fa0, t4, t2, v2], uses: [v2, v11, v16, v14, v5, v18, a0, zero, v7, v4, v6, v3], upward_exposed: [zero], params_defs: []
; live_in: [zero], live_out: []
; block parameters: []
.main_b0:
  li v18, 2  ; live: [v18, zero]
  mv a0, v18  ; live: [zero, a0]
  call make_adder  ; live: [zero, a0]
  mv v2, a0  ; live: [zero, v2]
  li v16, 3  ; live: [v16, zero, v2]
  mv a0, v16  ; live: [zero, a0, v2]
  call make_adder  ; live: [zero, a0, v2]
  mv v3, a0  ; live: [v2, zero, v3]
  mv s10, v2  ; live: [v2, zero, v3]
  ld v13, 0(v2)  ; live: [zero, v3]
  li v14, 10  ; live: [v14, zero, v3]
  mv a0, v14  ; live: [zero, a0, v3]
  jalr v13  ; live: [zero, a0, v3]
  mv v4, a0  ; live: [v4, zero, v3]
  mv s10, v3  ; live: [v4, zero, v3]
  ld v10, 0(v3)  ; live: [v4, zero]
  li v11, 20  ; live: [v11, v4, zero]
  mv a0, v11  ; live: [v4, zero, a0]
  jalr v10  ; live: [v4, zero, a0]
  mv v5, a0  ; live: [v4, v5, zero]
  add v6, v4, v5  ; live: [v6, zero]
  mv a0, v6  ; live: [zero, a0]
  call minimbt_print_int  ; live: [zero]
  mv v7, zero  ; live: [zero, v7]
; control
  mv a0, v7  ; live: [zero, a0]
  ret  ; live: [zero]

  .p2align 3
  .globl start
  .type start, @object
start:
  .zero 4



Testing test/test_src/bf.mbt
# name conventions used in the core ir:
# - functions: f<id>
# - blocks: b<id>
# - instructions: %<id>
# - memory: m<id>
# - free variables: ^<id>
# - function parameters: $f<pid>
# - block parameters: $b<bid>.<pid>
.core
.fn lp #f2 : closure() -> unit
.freevars (array[int32], array[int32], int32, closure(int32) -> int32, array[int32])
.entry b0 {
  .bb #b0 () {
    let %0: int32 = load int32 offset(^1, 0)
    let %1: int32 = load int32 offset(^2, %0)
    let %2: bool = eq(%1, 0)
    br %2 b1() b2()
  }
  .bb #b1 () {
    jump b3(())
  }
  .bb #b2 () {
    let %3: int32 = add(^3, 1)
    let %4: int32 = apply ^4(%3)
    let _ = store int32 offset(^5, 0) <- %4
    let %6: unit = apply self()
    jump b3(%6)
  }
  .bb #b3 (unit) {
    return $b3.0
  }
}
.fn thunk_start #f4 : fn() -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: unit = call f3()
    return %0
  }
}
.fn aux #f1 : closure(int32) -> int32
.freevars (int32, array[int32], array[int32], array[int32])
.entry b0 {
  .bb #b23 (int32) {
    jump b24($b23.0)
  }
  .bb #b8 () {
    let %22: bool = eq(%1, 4)
    br %22 b9() b10()
  }
  .bb #b9 () {
    let %23: int32 = load int32 offset(^3, 0)
    let %24: int32 = load int32 offset(^3, 0)
    let %25: int32 = load int32 offset(^4, %24)
    let %26: int32 = sub(%25, 1)
    let _ = store int32 offset(^4, %23) <- %26
    let %28: int32 = add($f0, 1)
    let %29: int32 = apply self(%28)
    jump b20(%29)
  }
  .bb #b16 () {
    jump b17($f0)
  }
  .bb #b13 () {
    let _ = alloc <m0: array[int32] heap(1)> <- [..] = $f0
    let _ = alloc <m1: closure() -> unit heap(6)> <- [0] = f2, [1] = ^3, [2] = ^4, [3] = $f0, [4] = self, [5] = f1.m0
    let %39: unit = apply f1.m1()
    let %40: int32 = load int32 offset(f1.m0, 0)
    let %41: int32 = add(%40, 1)
    let %42: int32 = apply self(%41)
    jump b18(%42)
  }
  .bb #b19 (int32) {
    jump b20($b19.0)
  }
  .bb #b15 () {
    jump b17($f0)
  }
  .bb #b1 () {
    jump b24($f0)
  }
  .bb #b11 () {
    let %31: int32 = load int32 offset(^3, 0)
    let %32: int32 = load int32 offset(^4, %31)
    let %33: unit = ext_call minimbt_print_char(%32)
    let %34: int32 = add($f0, 1)
    let %35: int32 = apply self(%34)
    jump b19(%35)
  }
  .bb #b2 () {
    let %1: int32 = load int32 offset(^2, $f0)
    let %2: bool = eq(%1, 1)
    br %2 b3() b4()
  }
  .bb #b18 (int32) {
    jump b19($b18.0)
  }
  .bb #b24 (int32) {
    return $b24.0
  }
  .bb #b21 (int32) {
    jump b22($b21.0)
  }
  .bb #b22 (int32) {
    jump b23($b22.0)
  }
  .bb #b20 (int32) {
    jump b21($b20.0)
  }
  .bb #b6 () {
    let %14: bool = eq(%1, 3)
    br %14 b7() b8()
  }
  .bb #b12 () {
    let %36: bool = eq(%1, 7)
    br %36 b13() b14()
  }
  .bb #b4 () {
    let %8: bool = eq(%1, 2)
    br %8 b5() b6()
  }
  .bb #b17 (int32) {
    jump b18($b17.0)
  }
  .bb #b0 () {
    let %0: bool = le(^1, $f0)
    br %0 b1() b2()
  }
  .bb #b10 () {
    let %30: bool = eq(%1, 5)
    br %30 b11() b12()
  }
  .bb #b5 () {
    let %9: int32 = load int32 offset(^3, 0)
    let %10: int32 = sub(%9, 1)
    let _ = store int32 offset(^3, 0) <- %10
    let %12: int32 = add($f0, 1)
    let %13: int32 = apply self(%12)
    jump b22(%13)
  }
  .bb #b3 () {
    let %3: int32 = load int32 offset(^3, 0)
    let %4: int32 = add(%3, 1)
    let _ = store int32 offset(^3, 0) <- %4
    let %6: int32 = add($f0, 1)
    let %7: int32 = apply self(%6)
    jump b23(%7)
  }
  .bb #b14 () {
    let %43: bool = eq(%1, 8)
    br %43 b15() b16()
  }
  .bb #b7 () {
    let %15: int32 = load int32 offset(^3, 0)
    let %16: int32 = load int32 offset(^3, 0)
    let %17: int32 = load int32 offset(^4, %16)
    let %18: int32 = add(%17, 1)
    let _ = store int32 offset(^4, %15) <- %18
    let %20: int32 = add($f0, 1)
    let %21: int32 = apply self(%20)
    jump b21(%21)
  }
}
.fn bf #f0 : fn(int32, array[int32]) -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let _ = alloc <m0: array[int32] heap(1)> <- [..] = 0
    let _ = alloc <m1: array[int32] heap(1024)> <- [..] = 0
    let _ = alloc <m2: closure(int32) -> int32 heap(5)> <- [0] = f1, [1] = $f0, [2] = $f1, [3] = f0.m0, [4] = f0.m1
    let %3: int32 = apply f0.m2(0)
    return ()
  }
}
.fn main #f3 : fn() -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let _ = alloc <m0: array[int32] heap(23)> <- [..] = 0
    let _ = store int32 offset(f3.m0, 0) <- 3
    let _ = store int32 offset(f3.m0, 1) <- 3
    let _ = store int32 offset(f3.m0, 2) <- 3
    let _ = store int32 offset(f3.m0, 3) <- 3
    let _ = store int32 offset(f3.m0, 4) <- 3
    let _ = store int32 offset(f3.m0, 5) <- 3
    let _ = store int32 offset(f3.m0, 6) <- 3
    let _ = store int32 offset(f3.m0, 7) <- 3
    let _ = store int32 offset(f3.m0, 8) <- 7
    let _ = store int32 offset(f3.m0, 9) <- 1
    let _ = store int32 offset(f3.m0, 10) <- 3
    let _ = store int32 offset(f3.m0, 11) <- 3
    let _ = store int32 offset(f3.m0, 12) <- 3
    let _ = store int32 offset(f3.m0, 13) <- 3
    let _ = store int32 offset(f3.m0, 14) <- 3
    let _ = store int32 offset(f3.m0, 15) <- 3
    let _ = store int32 offset(f3.m0, 16) <- 3
    let _ = store int32 offset(f3.m0, 17) <- 3
    let _ = store int32 offset(f3.m0, 18) <- 2
    let _ = store int32 offset(f3.m0, 19) <- 4
    let _ = store int32 offset(f3.m0, 20) <- 8
    let _ = store int32 offset(f3.m0, 21) <- 1
    let _ = store int32 offset(f3.m0, 22) <- 5
    let %24: unit = call f0(23, f3.m0)
    return %24
  }
}
.thunk ::0 start

  .p2align 3
  .globl _start
  .type _start, @function
_start:
; block info: defs: [t1, ft0, ft1, a1, t5, fa1, fa2, ft6, a4, fa6, a6, ft5, ft10, ft7, ft4, ft9, a5, a0, fa4, ft2, a2, a3, ft8, t3, a7, fa7, t0, fa5, fa3, ft3, fa0, t4, t2], uses: [a0], upward_exposed: [], params_defs: []
; live_in: [], live_out: []
; block parameters: []
_start_b0:
  call thunk_start  ; live: [a0]
; control
  ret  ; live: []

  .p2align 3
  .globl thunk_start
  .type thunk_start, @function
thunk_start:
; block info: defs: [t1, ft0, ft1, a1, t5, fa1, fa2, ft6, a4, fa6, a6, ft5, ft10, ft7, ft4, ft9, a5, a0, fa4, ft2, a2, a3, ft8, t3, a7, fa7, t0, fa5, fa3, ft3, fa0, t4, t2, v2], uses: [zero, a0, v2], upward_exposed: [zero], params_defs: []
; live_in: [zero], live_out: []
; block parameters: []
.thunk_start_b0:
  call main  ; live: [zero]
  mv v2, zero  ; live: [zero, v2]
; control
  mv a0, v2  ; live: [zero, a0]
  ret  ; live: [zero]

  .p2align 3
  .globl lp
  .type lp, @function
lp:
; block info: defs: [v3, v25, v5, v26, v7, v0, v28, v9, v29, v23, v8, v4, v6, v2], uses: [v2, v25, v26, v7, v0, v28, s10, v9, zero, v29, v23, v8, v3], upward_exposed: [s10, zero], params_defs: []
; live_in: [s10, zero], live_out: [v0, v4, v5, v6, zero]
; block parameters: []
.lp_b0:
  mv v0, s10  ; live: [v0, s10, zero]
  lw v2, 8(v0)  ; live: [v0, s10, zero, v2]
  lw v3, 16(v0)  ; live: [v2, v0, s10, zero, v3]
  lw v4, 24(v0)  ; live: [v2, v0, s10, zero, v3]
  lw v5, 32(v0)  ; live: [v2, v0, s10, zero, v3]
  lw v6, 40(v0)  ; live: [v2, s10, zero, v3]
  slli v28, zero, 2  ; live: [v2, v28, s10, zero, v3]
  add v29, v2, v28  ; live: [v3, s10, zero, v29]
  lw v7, 0(v29)  ; live: [v7, s10, zero, v3]
  slli v25, v7, 2  ; live: [v25, s10, zero, v3]
  add v26, v3, v25  ; live: [s10, zero, v26]
  lw v8, 0(v26)  ; live: [s10, zero, v8]
  xor v23, v8, zero  ; live: [s10, zero, v23]
  sltiu v9, v23, 1  ; live: [s10, zero, v9]
; control
  bne v9, zero, .lp_b1  ; live: [s10, zero]
  j .lp_b2  ; live: [s10, zero]

; block info: defs: [v14], uses: [zero], upward_exposed: [zero], params_defs: []
; live_in: [zero], live_out: [v14]
; block parameters: []
.lp_b1:
; control
  mv v14, zero  ; live: [zero]
  j .lp_b3  ; live: [zero]

; block info: defs: [t1, v14, v13, ft0, ft1, a1, t5, fa1, fa2, ft6, a4, fa6, v19, a6, ft5, ft10, ft7, v11, ft4, v21, v10, ft9, a5, a0, fa4, ft2, a2, v17, a3, s10, ft8, t3, a7, fa7, t0, fa5, v18, fa3, ft3, fa0, t4, t2, v15], uses: [v11, v5, v21, v10, v18, zero, a0, v13, v0, v4, v17, v6], upward_exposed: [v0, v4, v5, v6, zero], params_defs: []
; live_in: [v0, v4, v5, v6, zero], live_out: [v14]
; block parameters: []
.lp_b2:
  li v21, 1  ; live: [v5, v21, zero, v0, v4, v6]
  add v10, v4, v21  ; live: [v5, v10, zero, v0, v4, v6]
  mv s10, v5  ; live: [v5, v10, zero, v0, v4, v6]
  ld v19, 0(v5)  ; live: [v5, v10, zero, v0, v4, v6]
  mv a0, v10  ; live: [v5, zero, a0, v0, v4, v6]
  jalr v19  ; live: [v5, zero, a0, v0, v4, v6]
  mv v11, a0  ; live: [v11, v5, zero, v0, v4, v6]
  slli v17, zero, 2  ; live: [v11, v5, zero, v0, v4, v6, v17]
  add v18, v6, v17  ; live: [v11, v5, v18, zero, v0, v4, v6]
  sw v11, 0(v18)  ; live: [v0, v4, v5, v6, zero]
  mv s10, v0  ; live: [v0, v4, v5, v6, zero]
  ld v15, 0(v0)  ; live: [v0, v4, v5, v6, zero]
  jalr v15  ; live: [v0, v4, v5, v6, zero]
  mv v13, zero  ; live: [v0, v4, v5, v6, zero, v13]
; control
  mv v14, v13  ; live: [v0, v4, v5, v6, zero]
  j .lp_b3  ; live: [v0, v4, v5, v6, zero]

; block info: defs: [a0], uses: [v14, a0], upward_exposed: [v14], params_defs: [v14]
; live_in: [v14], live_out: []
; block parameters: [v14]
.lp_b3:
; control
  mv a0, v14  ; live: [v14, a0]
  ret  ; live: [v14]

  .p2align 3
  .globl aux
  .type aux, @function
aux:
; block info: defs: [v2, v5, v0, v166, v4, v6, v9, v3], uses: [v3, a0, zero, v0, v166, s10, v9, v2], upward_exposed: [s10, a0, zero], params_defs: []
; live_in: [s10, a0, zero], live_out: [v0, v4, v5, zero, v2]
; block parameters: []
.aux_b0:
  mv v0, s10  ; live: [a0, zero, v0, s10]
  mv v2, a0  ; live: [a0, zero, v0, s10, v2]
  lw v3, 8(v0)  ; live: [v2, a0, zero, v0, s10, v3]
  lw v4, 16(v0)  ; live: [v2, a0, zero, v0, s10, v3]
  lw v5, 24(v0)  ; live: [v3, v2, v0, s10, a0, zero]
  lw v6, 32(v0)  ; live: [v3, v2, s10, a0, zero]
  slt v166, v3, v2  ; live: [v166, s10, a0, zero]
  xori v9, v166, 1  ; live: [v9, s10, a0, zero]
; control
  bne v9, zero, .aux_b1  ; live: [s10, a0, zero]
  j .aux_b2  ; live: [s10, a0, zero]

; block info: defs: [v39], uses: [v31], upward_exposed: [v31], params_defs: [v31]
; live_in: [v31], live_out: [v39]
; block parameters: [v31]
.aux_b19:
; control
  mv v39, v31  ; live: [v31]
  j .aux_b20  ; live: [v31]

; block info: defs: [v60], uses: [v2], upward_exposed: [v2], params_defs: []
; live_in: [v2], live_out: [v60]
; block parameters: []
.aux_b1:
; control
  mv v60, v2  ; live: [v2]
  j .aux_b24  ; live: [v2]

; block info: defs: [t1, v91, v42, v95, v41, ft0, ft1, a1, t5, fa1, v98, fa2, v97, ft6, a4, fa6, a6, ft10, ft5, v47, v89, ft7, ft4, v87, v46, ft9, a5, fa4, a0, v92, v88, ft2, a2, v43, a3, s10, ft8, t3, a7, fa7, v94, t0, fa5, fa3, ft3, v45, fa0, v85, t4, t2, v83, v40], uses: [v2, v5, v91, v87, v46, a0, v42, v95, v92, v88, v0, v41, v43, v98, v94, zero, v97, v85, v45, v6, v89, v40], upward_exposed: [v0, v5, v6, zero, v2], params_defs: []
; live_in: [v0, v5, v6, zero, v2], live_out: [v47]
; block parameters: []
.aux_b7:
  slli v97, zero, 2  ; live: [v5, zero, v97, v0, v6, v2]
  add v98, v5, v97  ; live: [v98, v5, zero, v0, v6, v2]
  lw v40, 0(v98)  ; live: [v40, v5, zero, v0, v6, v2]
  slli v94, zero, 2  ; live: [v40, v94, v5, zero, v0, v6, v2]
  add v95, v5, v94  ; live: [v40, v5, zero, v0, v95, v6, v2]
  lw v41, 0(v95)  ; live: [v40, v5, zero, v0, v41, v6, v2]
  slli v91, v41, 2  ; live: [v40, v5, v91, zero, v0, v6, v2]
  add v92, v6, v91  ; live: [v40, v5, zero, v0, v92, v6, v2]
  lw v42, 0(v92)  ; live: [v40, v5, zero, v42, v0, v6, v2]
  li v89, 1  ; live: [v40, v5, zero, v42, v0, v6, v89, v2]
  add v43, v42, v89  ; live: [v40, v5, zero, v0, v6, v43, v2]
  slli v87, v40, 2  ; live: [v5, v87, zero, v0, v6, v43, v2]
  add v88, v6, v87  ; live: [v5, zero, v0, v88, v6, v43, v2]
  sw v43, 0(v88)  ; live: [v5, zero, v0, v6, v2]
  li v85, 1  ; live: [v5, zero, v85, v0, v6, v2]
  add v45, v2, v85  ; live: [v5, zero, v45, v0, v6, v2]
  mv s10, v0  ; live: [v5, zero, v45, v0, v6, v2]
  ld v83, 0(v0)  ; live: [v45, v0, v5, v6, zero, v2]
  mv a0, v45  ; live: [v0, v5, v6, zero, a0, v2]
  jalr v83  ; live: [v0, v5, v6, zero, a0, v2]
  mv v46, a0  ; live: [v0, v5, v6, v46, zero, v2]
; control
  mv v47, v46  ; live: [v0, v5, v6, zero, v2]
  j .aux_b21  ; live: [v0, v5, v6, zero, v2]

; block info: defs: [v25, t1, v22, v7, ft0, ft1, a1, t5, fa1, fa2, v130, ft6, fa6, a4, v8, a6, ft5, ft10, v128, v137, ft7, ft4, ft9, v21, a5, fa4, a0, v133, ft2, a2, a3, v24, s10, ft8, t3, a7, fa7, t0, fa5, fa3, ft3, v23, fa0, t4, t2, v140, v139, v135, v132], uses: [v2, v5, a0, v133, v22, v7, v0, s11, v24, v130, zero, v23, v8, v140, v6, v139, v137, v132], upward_exposed: [v5, zero, v0, v6, s11, v2], params_defs: []
; live_in: [v5, zero, v0, v6, s11, v2], live_out: [v25]
; block parameters: []
.aux_b13:
  addi v140, s11, -4  ; live: [v5, zero, v0, v6, v140, s11, v2]
  andi v7, v140, -8  ; live: [v5, zero, v7, v0, v6, s11, v2]
  sw v2, 0(v7)  ; live: [v5, zero, v7, v0, v6, s11, v2]
  addi v137, s11, -48  ; live: [v5, zero, v7, v0, v6, s11, v137, v2]
  andi v8, v137, -8  ; live: [v5, zero, v7, v8, v0, v6, s11, v2]
  la v139, lp  ; live: [v5, zero, v7, v8, v0, v6, s11, v139, v2]
  sd v139, 0(v8)  ; live: [v5, zero, v7, v8, v0, v6, s11, v2]
  sd v5, 8(v8)  ; live: [v5, zero, v7, v8, v0, v6, s11, v2]
  sd v6, 16(v8)  ; live: [v5, zero, v7, v8, v0, v6, s11, v2]
  sd v2, 24(v8)  ; live: [v5, zero, v7, v8, v0, v6, s11, v2]
  sd v0, 32(v8)  ; live: [v5, zero, v7, v8, v0, v6, s11, v2]
  sd v7, 40(v8)  ; live: [v5, zero, v7, v8, v0, v6, s11, v2]
  mv s10, v8  ; live: [v5, zero, v7, v8, v0, v6, s11, v2]
  ld v135, 0(v8)  ; live: [v5, zero, v7, v0, v6, s11, v2]
  jalr v135  ; live: [v5, zero, v7, v0, v6, s11, v2]
  mv v21, zero  ; live: [v5, zero, v7, v0, v6, s11, v2]
  slli v132, zero, 2  ; live: [v132, v5, zero, v7, v0, v6, s11, v2]
  add v133, v7, v132  ; live: [v5, zero, v133, v0, v6, s11, v2]
  lw v22, 0(v133)  ; live: [v5, zero, v22, v0, v6, s11, v2]
  li v130, 1  ; live: [v5, v130, zero, v22, v0, v6, s11, v2]
  add v23, v22, v130  ; live: [v5, zero, v23, v0, v6, s11, v2]
  mv s10, v0  ; live: [v5, zero, v23, v0, v6, s11, v2]
  ld v128, 0(v0)  ; live: [v5, zero, v23, v0, v6, s11, v2]
  mv a0, v23  ; live: [v5, zero, a0, v0, v6, s11, v2]
  jalr v128  ; live: [v5, zero, a0, v0, v6, s11, v2]
  mv v24, a0  ; live: [v5, zero, v0, v6, s11, v24, v2]
; control
  mv v25, v24  ; live: [v0, v5, v6, s11, zero, v2]
  j .aux_b18  ; live: [v0, v5, v6, s11, zero, v2]

; block info: defs: [v59], uses: [v53], upward_exposed: [v53], params_defs: [v53]
; live_in: [v53], live_out: [v59]
; block parameters: [v53]
.aux_b22:
; control
  mv v59, v53  ; live: [v53]
  j .aux_b23  ; live: [v53]

; block info: defs: [t1, ft0, ft1, a1, t5, fa1, v51, fa2, ft6, a4, fa6, a6, v81, ft5, ft10, v74, ft7, ft4, v49, ft9, v53, a5, fa4, a0, v78, ft2, a2, v52, a3, s10, ft8, t3, a7, fa7, v72, t0, fa5, v48, fa3, v77, ft3, fa0, v80, t4, t2, v76], uses: [v76, v5, v49, a0, v78, v0, v52, v51, v48, zero, v77, v80, v81, v74, v2], upward_exposed: [v0, v5, zero, v2], params_defs: []
; live_in: [v0, v5, zero, v2], live_out: [v53]
; block parameters: []
.aux_b5:
  slli v80, zero, 2  ; live: [v0, v80, v5, zero, v2]
  add v81, v5, v80  ; live: [v0, v81, v5, zero, v2]
  lw v48, 0(v81)  ; live: [v0, v5, v48, zero, v2]
  li v78, 1  ; live: [v0, v5, v48, zero, v78, v2]
  sub v49, v48, v78  ; live: [v0, v5, v49, zero, v2]
  slli v76, zero, 2  ; live: [v76, v0, v5, v49, zero, v2]
  add v77, v5, v76  ; live: [v0, v5, v49, zero, v77, v2]
  sw v49, 0(v77)  ; live: [v0, v5, zero, v2]
  li v74, 1  ; live: [v0, v5, v74, zero, v2]
  add v51, v2, v74  ; live: [v51, v0, v5, zero, v2]
  mv s10, v0  ; live: [v51, v0, v5, zero, v2]
  ld v72, 0(v0)  ; live: [v51, v0, v5, zero, v2]
  mv a0, v51  ; live: [v0, v5, zero, a0, v2]
  jalr v72  ; live: [v0, v5, zero, a0, v2]
  mv v52, a0  ; live: [v0, v5, v52, zero, v2]
; control
  mv v53, v52  ; live: [v0, v5, zero, v2]
  j .aux_b22  ; live: [v0, v5, zero, v2]

; block info: defs: [v12, v158, v157], uses: [v10, v12, v158, zero, v157], upward_exposed: [v10, zero], params_defs: []
; live_in: [v5, v10, zero, v0, v6, v2], live_out: [v5, v10, zero, v0, v6, v2]
; block parameters: []
.aux_b4:
  li v157, 2  ; live: [v5, v10, zero, v157, v0, v6, v2]
  xor v158, v10, v157  ; live: [v5, v10, zero, v158, v0, v6, v2]
  sltiu v12, v158, 1  ; live: [v5, v10, zero, v0, v6, v12, v2]
; control
  bne v12, zero, .aux_b5  ; live: [v0, v5, v6, v10, zero, v2]
  j .aux_b6  ; live: [v0, v5, v6, v10, zero, v2]

; block info: defs: [v151, v14, v152], uses: [v151, v14, v10, zero, v152], upward_exposed: [v10, zero], params_defs: []
; live_in: [v5, v10, zero, v0, v6, v2], live_out: [v5, v10, zero, v0, v6, s11, v2]
; block parameters: []
.aux_b8:
  li v151, 4  ; live: [v5, v10, zero, v0, v151, v6, v2]
  xor v152, v10, v151  ; live: [v5, v10, zero, v152, v0, v6, v2]
  sltiu v14, v152, 1  ; live: [v5, v14, v10, zero, v0, v6, v2]
; control
  bne v14, zero, .aux_b9  ; live: [v0, v5, v6, v10, zero, v2]
  j .aux_b10  ; live: [v0, v5, v6, v10, zero, v2]

; block info: defs: [v25], uses: [v18], upward_exposed: [v18], params_defs: [v18]
; live_in: [v18], live_out: [v25]
; block parameters: [v18]
.aux_b17:
; control
  mv v25, v18  ; live: [v18]
  j .aux_b18  ; live: [v18]

; block info: defs: [v164, v11, v10, v161, v160, v163], uses: [v164, v11, v10, v161, zero, v4, v160, v163, v2], upward_exposed: [v4, zero, v2], params_defs: []
; live_in: [v0, v4, v5, zero, v2], live_out: [v5, v10, zero, v0, v6, v2]
; block parameters: []
.aux_b2:
  slli v163, v2, 2  ; live: [v5, zero, v0, v4, v163, v2]
  add v164, v4, v163  ; live: [v164, v5, zero, v0, v4, v2]
  lw v10, 0(v164)  ; live: [v5, v10, zero, v0, v4, v2]
  li v160, 1  ; live: [v5, v10, zero, v0, v4, v160, v2]
  xor v161, v10, v160  ; live: [v5, v161, zero, v0, v4, v2]
  sltiu v11, v161, 1  ; live: [v11, v5, zero, v0, v4, v2]
; control
  bne v11, zero, .aux_b3  ; live: [v0, v4, v5, zero, v2]
  j .aux_b4  ; live: [v0, v4, v5, zero, v2]

; block info: defs: [a0], uses: [a0, v60], upward_exposed: [v60], params_defs: [v60]
; live_in: [v60], live_out: []
; block parameters: [v60]
.aux_b24:
; control
  mv a0, v60  ; live: [a0, v60]
  ret  ; live: [v60]

; block info: defs: [v155, v154, v13], uses: [v155, v10, v154, v13, zero], upward_exposed: [v10, zero], params_defs: []
; live_in: [v5, v10, zero, v0, v6, v2], live_out: [v5, v10, zero, v0, v6, v2]
; block parameters: []
.aux_b6:
  li v154, 3  ; live: [v5, v10, zero, v0, v6, v154, v2]
  xor v155, v10, v154  ; live: [v155, v5, v10, zero, v0, v6, v2]
  sltiu v13, v155, 1  ; live: [v5, v10, zero, v13, v0, v6, v2]
; control
  bne v13, zero, .aux_b7  ; live: [v0, v5, v6, v10, zero, v2]
  j .aux_b8  ; live: [v0, v5, v6, v10, zero, v2]

; block info: defs: [v47], uses: [v39], upward_exposed: [v39], params_defs: [v39]
; live_in: [v39], live_out: [v47]
; block parameters: [v39]
.aux_b20:
; control
  mv v47, v39  ; live: [v39]
  j .aux_b21  ; live: [v39]

; block info: defs: [v16, v146, v145], uses: [v16, v10, v146, v145, zero], upward_exposed: [v10, zero], params_defs: []
; live_in: [v5, v10, zero, v0, v6, s11, v2], live_out: [v5, v10, zero, v0, v6, s11, v2]
; block parameters: []
.aux_b12:
  li v145, 7  ; live: [v5, v10, zero, v0, v6, s11, v145, v2]
  xor v146, v10, v145  ; live: [v5, v10, v146, zero, v0, v6, s11, v2]
  sltiu v16, v146, 1  ; live: [v5, v16, v10, zero, v0, v6, s11, v2]
; control
  bne v16, zero, .aux_b13  ; live: [v5, v10, zero, v0, v6, s11, v2]
  j .aux_b14  ; live: [v5, v10, zero, v0, v6, s11, v2]

; block info: defs: [v60], uses: [v59], upward_exposed: [v59], params_defs: [v59]
; live_in: [v59], live_out: [v60]
; block parameters: [v59]
.aux_b23:
; control
  mv v60, v59  ; live: [v59]
  j .aux_b24  ; live: [v59]

; block info: defs: [t1, v69, v58, v67, ft0, ft1, a1, t5, fa1, v63, fa2, ft6, a4, fa6, a6, ft5, ft10, v59, v57, v54, ft7, v66, ft4, ft9, a5, a0, fa4, ft2, v65, a2, a3, s10, ft8, t3, a7, fa7, t0, fa5, fa3, ft3, fa0, t4, v70, t2, v61, v55], uses: [v66, v5, v69, v58, a0, v67, v0, v65, v63, zero, v70, v57, v54, v55, v2], upward_exposed: [v0, v5, zero, v2], params_defs: []
; live_in: [v0, v5, zero, v2], live_out: [v59]
; block parameters: []
.aux_b3:
  slli v69, zero, 2  ; live: [v0, v5, v69, zero, v2]
  add v70, v5, v69  ; live: [v0, v5, v70, zero, v2]
  lw v54, 0(v70)  ; live: [v0, v5, zero, v54, v2]
  li v67, 1  ; live: [v2, v0, v5, zero, v54, v67]
  add v55, v54, v67  ; live: [v0, v5, zero, v55, v2]
  slli v65, zero, 2  ; live: [v0, v65, v5, zero, v55, v2]
  add v66, v5, v65  ; live: [v0, v66, v5, zero, v55, v2]
  sw v55, 0(v66)  ; live: [v0, v5, zero, v2]
  li v63, 1  ; live: [v0, v63, v5, zero, v2]
  add v57, v2, v63  ; live: [v0, v5, v57, zero, v2]
  mv s10, v0  ; live: [v0, v5, v57, zero, v2]
  ld v61, 0(v0)  ; live: [v0, v5, v57, zero, v2]
  mv a0, v57  ; live: [v0, v5, zero, a0, v2]
  jalr v61  ; live: [v0, v5, zero, a0, v2]
  mv v58, a0  ; live: [v0, v5, v58, zero, v2]
; control
  mv v59, v58  ; live: [v0, v5, zero, v2]
  j .aux_b23  ; live: [v0, v5, zero, v2]

; block info: defs: [t1, v32, ft0, ft1, v108, a1, t5, v33, fa1, v109, v106, v115, fa2, ft6, a4, fa6, v105, a6, ft5, ft10, v102, v34, ft7, ft4, ft9, a5, a0, fa4, ft2, v114, v37, a2, v111, a3, s10, v39, ft8, a7, fa7, t3, t0, v112, fa5, fa3, ft3, v35, fa0, v104, v38, t4, t2, v100], uses: [v5, a0, v0, v114, v32, v37, v111, v108, v33, v115, v109, v106, v112, zero, v35, v104, v105, v38, v6, v102, v34, v2], upward_exposed: [v0, v5, v6, zero, v2], params_defs: []
; live_in: [v0, v5, v6, zero, v2], live_out: [v39]
; block parameters: []
.aux_b9:
  slli v114, zero, 2  ; live: [v5, zero, v0, v114, v6, v2]
  add v115, v5, v114  ; live: [v115, v5, zero, v0, v6, v2]
  lw v32, 0(v115)  ; live: [v5, zero, v0, v32, v6, v2]
  slli v111, zero, 2  ; live: [v5, zero, v0, v32, v6, v111, v2]
  add v112, v5, v111  ; live: [v112, v5, zero, v0, v32, v6, v2]
  lw v33, 0(v112)  ; live: [v5, zero, v0, v32, v6, v33, v2]
  slli v108, v33, 2  ; live: [v5, zero, v0, v32, v6, v108, v2]
  add v109, v6, v108  ; live: [v109, v5, zero, v0, v32, v6, v2]
  lw v34, 0(v109)  ; live: [v5, zero, v0, v32, v6, v34, v2]
  li v106, 1  ; live: [v106, v5, zero, v0, v32, v6, v34, v2]
  sub v35, v34, v106  ; live: [v5, zero, v35, v0, v32, v6, v2]
  slli v104, v32, 2  ; live: [v5, zero, v35, v0, v104, v6, v2]
  add v105, v6, v104  ; live: [v5, zero, v35, v0, v105, v6, v2]
  sw v35, 0(v105)  ; live: [v5, zero, v0, v6, v2]
  li v102, 1  ; live: [v5, zero, v0, v6, v102, v2]
  add v37, v2, v102  ; live: [v5, zero, v0, v37, v6, v2]
  mv s10, v0  ; live: [v5, zero, v0, v37, v6, v2]
  ld v100, 0(v0)  ; live: [v0, v37, v5, v6, zero, v2]
  mv a0, v37  ; live: [v0, v5, v6, zero, a0, v2]
  jalr v100  ; live: [v0, v5, v6, zero, a0, v2]
  mv v38, a0  ; live: [v0, v38, v5, v6, zero, v2]
; control
  mv v39, v38  ; live: [v0, v5, v6, zero, v2]
  j .aux_b20  ; live: [v0, v5, v6, zero, v2]

; block info: defs: [v18], uses: [v2], upward_exposed: [v2], params_defs: []
; live_in: [v2], live_out: [v18]
; block parameters: []
.aux_b16:
; control
  mv v18, v2  ; live: [v2]
  j .aux_b17  ; live: [v2]

; block info: defs: [v15, v149, v148], uses: [v10, v15, v149, zero, v148], upward_exposed: [v10, zero], params_defs: []
; live_in: [v5, v10, zero, v0, v6, s11, v2], live_out: [v5, v10, zero, v0, v6, s11, v2]
; block parameters: []
.aux_b10:
  li v148, 5  ; live: [v5, v10, zero, v148, v0, v6, s11, v2]
  xor v149, v10, v148  ; live: [v5, v10, zero, v0, v6, s11, v149, v2]
  sltiu v15, v149, 1  ; live: [v5, v10, zero, v0, v6, s11, v15, v2]
; control
  bne v15, zero, .aux_b11  ; live: [v5, v10, zero, v0, v6, s11, v2]
  j .aux_b12  ; live: [v5, v10, zero, v0, v6, s11, v2]

; block info: defs: [t1, v26, ft0, ft1, a1, t5, v28, fa1, fa2, v126, ft6, v29, v27, fa6, a4, a6, ft5, ft10, v117, v122, ft7, ft4, ft9, a5, v125, a0, fa4, v123, v119, v30, ft2, a2, a3, v31, s10, ft8, a7, fa7, t3, t0, fa5, fa3, ft3, fa0, t4, t2], uses: [v5, v26, v125, a0, v123, v119, v30, v0, zero, v126, v29, v27, v6, v122, v2], upward_exposed: [v0, v5, v6, zero, v2], params_defs: []
; live_in: [v0, v5, v6, zero, v2], live_out: [v31]
; block parameters: []
.aux_b11:
  slli v125, zero, 2  ; live: [v5, zero, v125, v0, v6, v2]
  add v126, v5, v125  ; live: [v5, zero, v126, v0, v6, v2]
  lw v26, 0(v126)  ; live: [v5, zero, v26, v0, v6, v2]
  slli v122, v26, 2  ; live: [v5, zero, v0, v6, v122, v2]
  add v123, v6, v122  ; live: [v5, zero, v123, v0, v6, v2]
  lw v27, 0(v123)  ; live: [v5, zero, v27, v0, v6, v2]
  mv a0, v27  ; live: [v5, zero, a0, v0, v6, v2]
  call minimbt_print_char  ; live: [v5, zero, v0, v6, v2]
  mv v28, zero  ; live: [v5, zero, v0, v6, v2]
  li v119, 1  ; live: [v5, zero, v119, v0, v6, v2]
  add v29, v2, v119  ; live: [v5, zero, v29, v0, v6, v2]
  mv s10, v0  ; live: [v5, zero, v29, v0, v6, v2]
  ld v117, 0(v0)  ; live: [v0, v5, v6, zero, v29, v2]
  mv a0, v29  ; live: [v0, v5, v6, zero, a0, v2]
  jalr v117  ; live: [v0, v5, v6, zero, a0, v2]
  mv v30, a0  ; live: [v0, v5, v6, zero, v30, v2]
; control
  mv v31, v30  ; live: [v0, v5, v6, zero, v2]
  j .aux_b19  ; live: [v0, v5, v6, zero, v2]

; block info: defs: [v53], uses: [v47], upward_exposed: [v47], params_defs: [v47]
; live_in: [v47], live_out: [v53]
; block parameters: [v47]
.aux_b21:
; control
  mv v53, v47  ; live: [v47]
  j .aux_b22  ; live: [v47]

; block info: defs: [v31], uses: [v25], upward_exposed: [v25], params_defs: [v25]
; live_in: [v25], live_out: [v31]
; block parameters: [v25]
.aux_b18:
; control
  mv v31, v25  ; live: [v25]
  j .aux_b19  ; live: [v25]

; block info: defs: [v17, v142, v143], uses: [v17, v10, v142, v143, zero], upward_exposed: [v10, zero], params_defs: []
; live_in: [v10, zero, v2], live_out: [v2]
; block parameters: []
.aux_b14:
  li v142, 8  ; live: [v10, v142, zero, v2]
  xor v143, v10, v142  ; live: [v10, v143, zero, v2]
  sltiu v17, v143, 1  ; live: [v17, v10, zero, v2]
; control
  bne v17, zero, .aux_b15  ; live: [v10, zero, v2]
  j .aux_b16  ; live: [v10, zero, v2]

; block info: defs: [v18], uses: [v2], upward_exposed: [v2], params_defs: []
; live_in: [v2], live_out: [v18]
; block parameters: []
.aux_b15:
; control
  mv v18, v2  ; live: [v2]
  j .aux_b17  ; live: [v2]

  .p2align 3
  .globl bf
  .type bf, @function
bf:
; block info: defs: [v2, t1, v16, v13, ft0, ft1, a1, t5, fa1, fa2, ft6, v20, a4, fa6, v19, a6, ft5, ft10, v4, v6, ft7, v11, ft4, v5, ft9, v10, a5, fa4, a0, ft2, a2, v17, a3, s10, ft8, t3, a7, fa7, t0, fa5, fa3, ft3, fa0, t4, t2, v15, v3], uses: [v3, v16, v5, a0, v13, a2, a1, v17, s11, zero, v20, v19, v4, v6, v15, v2], upward_exposed: [a1, s11, a0, zero], params_defs: []
; live_in: [a1, s11, a0, zero], live_out: []
; block parameters: []
.bf_b0:
  mv v2, a0  ; live: [zero, a1, s11, v2]
  mv v3, a1  ; live: [v2, zero, s11, v3]
  addi v20, s11, -4  ; live: [v2, zero, v20, s11, v3]
  andi v4, v20, -8  ; live: [v2, zero, v4, s11, v3]
  sw zero, 0(v4)  ; live: [v2, zero, v4, s11, v3]
  li v16, 4096  ; live: [v2, v16, zero, v4, s11, v3]
  sub v17, s11, v16  ; live: [v2, zero, v4, v17, s11, v3]
  andi v5, v17, -8  ; live: [v2, v5, zero, v4, s11, v3]
  li v19, 1024  ; live: [v2, v5, zero, v19, v4, s11, v3]
  mv a1, v19  ; live: [v2, v5, zero, v4, a1, s11, v3]
  mv a0, v5  ; live: [v2, v5, zero, a0, v4, a1, s11, v3]
  mv a2, zero  ; live: [v2, v5, zero, a0, v4, a2, a1, s11, v3]
  call _memseti32  ; live: [v2, v5, zero, v4, s11, v3]
  addi v13, s11, -40  ; live: [v2, v5, zero, v13, v4, s11, v3]
  andi v6, v13, -8  ; live: [v2, v5, zero, v4, v6, s11, v3]
  la v15, aux  ; live: [v2, v5, zero, v4, v6, s11, v15, v3]
  sd v15, 0(v6)  ; live: [v2, v5, zero, v4, v6, s11, v3]
  sd v2, 8(v6)  ; live: [v5, zero, v4, v6, s11, v3]
  sd v3, 16(v6)  ; live: [v4, v6, v5, s11, zero]
  sd v4, 24(v6)  ; live: [v6, v5, s11, zero]
  sd v5, 32(v6)  ; live: [v6, s11, zero]
  mv s10, v6  ; live: [v6, s11, zero]
  ld v11, 0(v6)  ; live: [s11, zero]
  mv a0, zero  ; live: [s11, zero, a0]
  jalr v11  ; live: [a1, s11, zero, a0]
  mv v10, a0  ; live: [a1, s11, zero]
; control
  mv a0, zero  ; live: [a1, s11, a0, zero]
  ret  ; live: [a1, s11, a0, zero]

  .p2align 3
  .globl main
  .type main, @function
main:
; block info: defs: [v58, v91, v79, v67, a1, v44, t5, fa1, v82, v99, fa2, v50, a6, v59, ft10, v117, v102, v62, ft4, ft9, v119, v110, v92, v37, v43, a7, v48, v96, v40, v42, v41, v32, ft0, ft1, v108, v86, v98, v106, v97, v105, v90, v47, v89, v34, v66, v53, v121, v30, v114, v65, a2, ft8, t3, v112, v56, fa5, v77, v85, v84, v80, t4, v76, v2, v95, v28, v64, v33, v60, v51, v73, v63, ft6, a4, fa6, v27, ft5, v54, v116, v87, v49, fa4, ft2, v52, a3, v31, v113, v101, fa7, v75, fa3, v68, ft3, v45, v104, t2, v61, v55, t1, v69, v120, v107, v93, v109, v115, v103, v81, v74, v57, ft7, v71, v46, a5, a0, v78, v36, v88, v111, v39, v118, v94, v72, t0, v35, fa0, v38, v70, v83, v100], uses: [v2, v91, v58, v79, v67, v95, a1, s11, v44, v28, v33, v64, v60, v73, v51, v63, v82, v99, v50, v27, v59, v117, v102, v54, v116, v62, v87, v49, v119, v110, v92, v37, v43, v52, v31, v113, v101, v75, v48, v96, v68, v45, v104, v61, v55, v40, v69, v42, v120, v107, v41, v32, v108, v86, v98, v93, v106, v109, v115, v97, zero, v103, v105, v90, v81, v47, v74, v57, v89, v34, v66, v71, v46, v53, v121, a0, v30, v78, v36, v88, v114, v65, v111, v39, v118, v112, v94, v72, v56, v77, v85, v35, v84, v38, v80, v70, v83, v100, v76], upward_exposed: [s11, zero], params_defs: []
; live_in: [s11, zero], live_out: []
; block parameters: []
.main_b0:
  addi v121, s11, -92  ; live: [s11, v121, zero]
  andi v2, v121, -8  ; live: [s11, zero, v2]
  sw zero, 0(v2)  ; live: [s11, zero, v2]
  sw zero, 4(v2)  ; live: [s11, zero, v2]
  sw zero, 8(v2)  ; live: [s11, zero, v2]
  sw zero, 12(v2)  ; live: [s11, zero, v2]
  sw zero, 16(v2)  ; live: [s11, zero, v2]
  sw zero, 20(v2)  ; live: [s11, zero, v2]
  sw zero, 24(v2)  ; live: [s11, zero, v2]
  sw zero, 28(v2)  ; live: [s11, zero, v2]
  sw zero, 32(v2)  ; live: [s11, zero, v2]
  sw zero, 36(v2)  ; live: [s11, zero, v2]
  sw zero, 40(v2)  ; live: [s11, zero, v2]
  sw zero, 44(v2)  ; live: [s11, zero, v2]
  sw zero, 48(v2)  ; live: [s11, zero, v2]
  sw zero, 52(v2)  ; live: [s11, zero, v2]
  sw zero, 56(v2)  ; live: [s11, zero, v2]
  sw zero, 60(v2)  ; live: [s11, zero, v2]
  sw zero, 64(v2)  ; live: [s11, zero, v2]
  sw zero, 68(v2)  ; live: [s11, zero, v2]
  sw zero, 72(v2)  ; live: [s11, zero, v2]
  sw zero, 76(v2)  ; live: [s11, zero, v2]
  sw zero, 80(v2)  ; live: [s11, zero, v2]
  sw zero, 84(v2)  ; live: [s11, zero, v2]
  sw zero, 88(v2)  ; live: [s11, zero, v2]
  li v118, 3  ; live: [v118, s11, zero, v2]
  slli v119, zero, 2  ; live: [v118, s11, zero, v119, v2]
  add v120, v2, v119  ; live: [v118, s11, zero, v120, v2]
  sw v118, 0(v120)  ; live: [s11, zero, v2]
  li v114, 3  ; live: [v114, s11, zero, v2]
  li v115, 1  ; live: [v115, v114, s11, zero, v2]
  slli v116, v115, 2  ; live: [v116, v114, s11, zero, v2]
  add v117, v2, v116  ; live: [v114, s11, v117, zero, v2]
  sw v114, 0(v117)  ; live: [s11, zero, v2]
  li v110, 3  ; live: [s11, zero, v110, v2]
  li v111, 2  ; live: [v111, s11, zero, v110, v2]
  slli v112, v111, 2  ; live: [v112, s11, zero, v110, v2]
  add v113, v2, v112  ; live: [v2, s11, zero, v113, v110]
  sw v110, 0(v113)  ; live: [s11, zero, v2]
  li v106, 3  ; live: [v106, s11, zero, v2]
  li v107, 3  ; live: [v106, v107, s11, zero, v2]
  slli v108, v107, 2  ; live: [v106, v108, s11, zero, v2]
  add v109, v2, v108  ; live: [v106, v109, s11, zero, v2]
  sw v106, 0(v109)  ; live: [s11, zero, v2]
  li v102, 3  ; live: [s11, v102, zero, v2]
  li v103, 4  ; live: [v103, s11, v102, zero, v2]
  slli v104, v103, 2  ; live: [v104, s11, v102, zero, v2]
  add v105, v2, v104  ; live: [v105, s11, v102, zero, v2]
  sw v102, 0(v105)  ; live: [s11, zero, v2]
  li v98, 3  ; live: [v98, s11, zero, v2]
  li v99, 5  ; live: [v98, s11, v99, zero, v2]
  slli v100, v99, 2  ; live: [v98, s11, zero, v100, v2]
  add v101, v2, v100  ; live: [v98, v101, s11, zero, v2]
  sw v98, 0(v101)  ; live: [s11, zero, v2]
  li v94, 3  ; live: [v94, s11, zero, v2]
  li v95, 6  ; live: [v95, v94, s11, zero, v2]
  slli v96, v95, 2  ; live: [v94, s11, v96, zero, v2]
  add v97, v2, v96  ; live: [v94, s11, zero, v97, v2]
  sw v94, 0(v97)  ; live: [s11, zero, v2]
  li v90, 3  ; live: [v90, s11, zero, v2]
  li v91, 7  ; live: [v90, v91, s11, zero, v2]
  slli v92, v91, 2  ; live: [v92, v90, s11, zero, v2]
  add v93, v2, v92  ; live: [v93, v90, s11, zero, v2]
  sw v90, 0(v93)  ; live: [s11, zero, v2]
  li v86, 7  ; live: [s11, v86, zero, v2]
  li v87, 8  ; live: [v87, s11, v86, zero, v2]
  slli v88, v87, 2  ; live: [v88, s11, v86, zero, v2]
  add v89, v2, v88  ; live: [s11, v86, zero, v89, v2]
  sw v86, 0(v89)  ; live: [s11, zero, v2]
  li v82, 1  ; live: [v82, s11, zero, v2]
  li v83, 9  ; live: [v82, s11, v83, zero, v2]
  slli v84, v83, 2  ; live: [v84, v82, s11, zero, v2]
  add v85, v2, v84  ; live: [v85, v82, s11, zero, v2]
  sw v82, 0(v85)  ; live: [s11, zero, v2]
  li v78, 3  ; live: [s11, zero, v78, v2]
  li v79, 10  ; live: [v2, s11, zero, v79, v78]
  slli v80, v79, 2  ; live: [v80, s11, zero, v78, v2]
  add v81, v2, v80  ; live: [v81, s11, zero, v78, v2]
  sw v78, 0(v81)  ; live: [s11, zero, v2]
  li v74, 3  ; live: [v74, s11, zero, v2]
  li v75, 11  ; live: [v74, s11, v75, zero, v2]
  slli v76, v75, 2  ; live: [v76, v74, s11, zero, v2]
  add v77, v2, v76  ; live: [v74, s11, zero, v77, v2]
  sw v74, 0(v77)  ; live: [s11, zero, v2]
  li v70, 3  ; live: [v70, s11, zero, v2]
  li v71, 12  ; live: [v70, v71, s11, zero, v2]
  slli v72, v71, 2  ; live: [v72, v70, s11, zero, v2]
  add v73, v2, v72  ; live: [v73, v70, s11, zero, v2]
  sw v70, 0(v73)  ; live: [s11, zero, v2]
  li v66, 3  ; live: [v66, s11, zero, v2]
  li v67, 13  ; live: [v66, s11, zero, v67, v2]
  slli v68, v67, 2  ; live: [v66, s11, zero, v68, v2]
  add v69, v2, v68  ; live: [v66, v69, s11, zero, v2]
  sw v66, 0(v69)  ; live: [s11, zero, v2]
  li v62, 3  ; live: [v62, s11, zero, v2]
  li v63, 14  ; live: [v62, v63, s11, zero, v2]
  slli v64, v63, 2  ; live: [v62, s11, zero, v64, v2]
  add v65, v2, v64  ; live: [v62, v65, s11, zero, v2]
  sw v62, 0(v65)  ; live: [s11, zero, v2]
  li v58, 3  ; live: [v58, s11, zero, v2]
  li v59, 15  ; live: [v59, v58, s11, zero, v2]
  slli v60, v59, 2  ; live: [v58, s11, zero, v60, v2]
  add v61, v2, v60  ; live: [v58, s11, v61, zero, v2]
  sw v58, 0(v61)  ; live: [s11, zero, v2]
  li v54, 3  ; live: [s11, zero, v54, v2]
  li v55, 16  ; live: [v2, s11, zero, v54, v55]
  slli v56, v55, 2  ; live: [s11, v56, zero, v54, v2]
  add v57, v2, v56  ; live: [s11, v57, zero, v54, v2]
  sw v54, 0(v57)  ; live: [s11, zero, v2]
  li v50, 3  ; live: [s11, zero, v50, v2]
  li v51, 17  ; live: [v51, s11, zero, v50, v2]
  slli v52, v51, 2  ; live: [s11, v52, zero, v50, v2]
  add v53, v2, v52  ; live: [s11, v53, zero, v50, v2]
  sw v50, 0(v53)  ; live: [s11, zero, v2]
  li v46, 2  ; live: [v46, s11, zero, v2]
  li v47, 18  ; live: [v47, v46, s11, zero, v2]
  slli v48, v47, 2  ; live: [v46, s11, v48, zero, v2]
  add v49, v2, v48  ; live: [v46, s11, v49, zero, v2]
  sw v46, 0(v49)  ; live: [s11, zero, v2]
  li v42, 4  ; live: [s11, zero, v42, v2]
  li v43, 19  ; live: [v43, s11, zero, v42, v2]
  slli v44, v43, 2  ; live: [s11, v44, zero, v42, v2]
  add v45, v2, v44  ; live: [v45, s11, zero, v42, v2]
  sw v42, 0(v45)  ; live: [s11, zero, v2]
  li v38, 8  ; live: [v38, s11, zero, v2]
  li v39, 20  ; live: [v38, s11, zero, v39, v2]
  slli v40, v39, 2  ; live: [v40, v38, s11, zero, v2]
  add v41, v2, v40  ; live: [v38, v41, s11, zero, v2]
  sw v38, 0(v41)  ; live: [s11, zero, v2]
  li v34, 1  ; live: [s11, zero, v34, v2]
  li v35, 21  ; live: [v35, s11, zero, v34, v2]
  slli v36, v35, 2  ; live: [v36, s11, zero, v34, v2]
  add v37, v2, v36  ; live: [v37, s11, zero, v34, v2]
  sw v34, 0(v37)  ; live: [s11, zero, v2]
  li v30, 5  ; live: [s11, zero, v30, v2]
  li v31, 22  ; live: [s11, v31, zero, v30, v2]
  slli v32, v31, 2  ; live: [v32, s11, zero, v30, v2]
  add v33, v2, v32  ; live: [v2, s11, zero, v33, v30]
  sw v30, 0(v33)  ; live: [s11, zero, v2]
  li v28, 23  ; live: [s11, v28, zero, v2]
  mv a0, v28  ; live: [s11, zero, a0, v2]
  mv a1, v2  ; live: [a1, s11, zero, a0]
  call bf  ; live: [s11, zero]
  mv v27, zero  ; live: [s11, zero, v27]
; control
  mv a0, v27  ; live: [s11, zero, a0]
  ret  ; live: [s11, zero]

  .p2align 3
  .globl start
  .type start, @object
start:
  .zero 4



Testing test/test_src/cls-bug.mbt
# name conventions used in the core ir:
# - functions: f<id>
# - blocks: b<id>
# - instructions: %<id>
# - memory: m<id>
# - free variables: ^<id>
# - function parameters: $f<pid>
# - block parameters: $b<bid>.<pid>
.core
.fn main #f2 : fn() -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: closure(int32) -> int32 = call f1(456)
    let %1: int32 = apply %0(789)
    let %2: unit = ext_call minimbt_print_int(%1)
    return %2
  }
}
.fn f #f0 : fn(int32) -> int32
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: int32 = add($f0, 123)
    return %0
  }
}
.fn thunk_start #f3 : fn() -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: unit = call f2()
    return %0
  }
}
.fn g #f1 : fn(int32) -> closure(int32) -> int32
.freevars ()
.entry b0 {
  .bb #b0 () {
    let _ = alloc <m0: closure(int32) -> int32 heap(1)> <- [0] = f0
    return f1.m0
  }
}
.thunk ::0 start

  .p2align 3
  .globl _start
  .type _start, @function
_start:
; block info: defs: [t1, ft0, ft1, a1, t5, fa1, fa2, ft6, a4, fa6, a6, ft5, ft10, ft7, ft4, ft9, a5, a0, fa4, ft2, a2, a3, ft8, t3, a7, fa7, t0, fa5, fa3, ft3, fa0, t4, t2], uses: [a0], upward_exposed: [], params_defs: []
; live_in: [], live_out: []
; block parameters: []
_start_b0:
  call thunk_start  ; live: [a0]
; control
  ret  ; live: []

  .p2align 3
  .globl f
  .type f, @function
f:
; block info: defs: [v3, v4, a0, v2], uses: [v3, v4, a0, v2], upward_exposed: [a0], params_defs: []
; live_in: [a0], live_out: []
; block parameters: []
.f_b0:
  mv v2, a0  ; live: [v2]
  li v4, 123  ; live: [v4, v2]
  add v3, v2, v4  ; live: [v3]
; control
  mv a0, v3  ; live: [a0]
  ret  ; live: [a0]

  .p2align 3
  .globl thunk_start
  .type thunk_start, @function
thunk_start:
; block info: defs: [t1, ft0, ft1, a1, t5, fa1, fa2, ft6, a4, fa6, a6, ft5, ft10, ft7, ft4, ft9, a5, a0, fa4, ft2, a2, a3, ft8, t3, a7, fa7, t0, fa5, fa3, ft3, fa0, t4, t2, v2], uses: [zero, a0, v2], upward_exposed: [zero], params_defs: []
; live_in: [zero], live_out: []
; block parameters: []
.thunk_start_b0:
  call main  ; live: [zero]
  mv v2, zero  ; live: [zero, v2]
; control
  mv a0, v2  ; live: [zero, a0]
  ret  ; live: [zero]

  .p2align 3
  .globl g
  .type g, @function
g:
; block info: defs: [v3, v7, v5, a0, v2], uses: [v3, v5, s11, a0, v7], upward_exposed: [s11, a0], params_defs: []
; live_in: [s11, a0], live_out: []
; block parameters: []
.g_b0:
  mv v2, a0  ; live: [s11]
  addi v5, s11, -8  ; live: [v5, s11]
  andi v3, v5, -8  ; live: [s11, v3]
  la v7, f  ; live: [v7, s11, v3]
  sd v7, 0(v3)  ; live: [s11, v3]
; control
  mv a0, v3  ; live: [s11, a0]
  ret  ; live: [s11, a0]

  .p2align 3
  .globl main
  .type main, @function
main:
; block info: defs: [v3, t1, v7, ft0, ft1, a1, t5, fa1, fa2, ft6, a4, fa6, a6, ft5, ft10, v4, v6, ft7, ft4, ft9, a5, a0, fa4, ft2, a2, a3, v9, s10, ft8, a7, t3, fa7, t0, fa5, fa3, ft3, fa0, t4, t2, v2], uses: [v2, a0, zero, v7, v4, v9, v3], upward_exposed: [zero], params_defs: []
; live_in: [zero], live_out: []
; block parameters: []
.main_b0:
  li v9, 456  ; live: [zero, v9]
  mv a0, v9  ; live: [zero, a0]
  call g  ; live: [zero, a0]
  mv v2, a0  ; live: [zero, v2]
  mv s10, v2  ; live: [zero, v2]
  ld v6, 0(v2)  ; live: [zero]
  li v7, 789  ; live: [zero, v7]
  mv a0, v7  ; live: [zero, a0]
  jalr v6  ; live: [zero, a0]
  mv v3, a0  ; live: [zero, v3]
  mv a0, v3  ; live: [zero, a0]
  call minimbt_print_int  ; live: [zero]
  mv v4, zero  ; live: [v4, zero]
; control
  mv a0, v4  ; live: [zero, a0]
  ret  ; live: [zero]

  .p2align 3
  .globl start
  .type start, @object
start:
  .zero 4



Testing test/test_src/cls-bug2.mbt
# name conventions used in the core ir:
# - functions: f<id>
# - blocks: b<id>
# - instructions: %<id>
# - memory: m<id>
# - free variables: ^<id>
# - function parameters: $f<pid>
# - block parameters: $b<bid>.<pid>
.core
.fn f #f0 : fn(int32) -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: bool = le(0, $f0)
    br %0 b1() b2()
  }
  .bb #b1 () {
    let %1: unit = ext_call minimbt_print_int($f0)
    let _ = alloc <m0: closure(int32) -> unit heap(1)> <- [0] = f0
    let _ = alloc <m1: array[closure(int32) -> unit] heap(1)> <- [..] = f0.m0
    let %4: closure(int32) -> unit = load closure(int32) -> unit offset(f0.m1, 0)
    let %5: int32 = sub($f0, 1)
    let %6: unit = apply %4(%5)
    jump b3(%6)
  }
  .bb #b2 () {
    jump b3(())
  }
  .bb #b3 (unit) {
    return $b3.0
  }
}
.fn thunk_start #f2 : fn() -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: unit = call f1()
    return %0
  }
}
.fn main #f1 : fn() -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: unit = call f0(9)
    return %0
  }
}
.thunk ::0 start

  .p2align 3
  .globl _start
  .type _start, @function
_start:
; block info: defs: [t1, ft0, ft1, a1, t5, fa1, fa2, ft6, a4, fa6, a6, ft5, ft10, ft7, ft4, ft9, a5, a0, fa4, ft2, a2, a3, ft8, t3, a7, fa7, t0, fa5, fa3, ft3, fa0, t4, t2], uses: [a0], upward_exposed: [], params_defs: []
; live_in: [], live_out: []
; block parameters: []
_start_b0:
  call thunk_start  ; live: [a0]
; control
  ret  ; live: []

  .p2align 3
  .globl f
  .type f, @function
f:
; block info: defs: [v5, v26, v2], uses: [v2, v5, a0, zero, v26], upward_exposed: [a0, zero], params_defs: []
; live_in: [s11, a0, zero], live_out: [s11, zero, v2]
; block parameters: []
.f_b0:
  mv v2, a0  ; live: [s11, a0, zero, v2]
  slt v26, zero, v2  ; live: [s11, a0, zero, v26]
  xori v5, v26, 1  ; live: [v5, s11, a0, zero]
; control
  bne v5, zero, .f_b1  ; live: [s11, a0, zero]
  j .f_b2  ; live: [s11, a0, zero]

; block info: defs: [a0], uses: [v12, a0], upward_exposed: [v12], params_defs: [v12]
; live_in: [v12], live_out: []
; block parameters: [v12]
.f_b3:
; control
  mv a0, v12  ; live: [v12, a0]
  ret  ; live: [v12]

; block info: defs: [t1, v13, v22, ft0, ft1, a1, v12, t5, fa1, fa2, ft6, a4, fa6, v20, a6, ft10, ft5, v4, v6, ft7, v11, ft4, ft9, v10, a5, fa4, a0, ft2, a2, v17, a3, v24, v9, s10, ft8, t3, a7, fa7, t0, fa5, v18, fa3, ft3, fa0, t4, t2, v15, v3], uses: [v2, v11, v10, a0, v22, v17, s11, v24, v9, v18, zero, v20, v4, v15, v3], upward_exposed: [s11, zero, v2], params_defs: []
; live_in: [s11, zero, v2], live_out: [v12]
; block parameters: []
.f_b1:
  mv a0, v2  ; live: [s11, zero, a0, v2]
  call minimbt_print_int  ; live: [s11, zero, v2]
  mv v6, zero  ; live: [s11, zero, v2]
  addi v22, s11, -8  ; live: [s11, zero, v22, v2]
  andi v3, v22, -8  ; live: [v3, s11, zero, v2]
  la v24, f  ; live: [v3, s11, v24, zero, v2]
  sd v24, 0(v3)  ; live: [v3, s11, zero, v2]
  addi v20, s11, -8  ; live: [v3, s11, zero, v20, v2]
  andi v4, v20, -8  ; live: [v3, v4, s11, zero, v2]
  sd v3, 0(v4)  ; live: [v4, s11, zero, v2]
  slli v17, zero, 3  ; live: [v4, v17, s11, zero, v2]
  add v18, v4, v17  ; live: [s11, v18, zero, v2]
  ld v9, 0(v18)  ; live: [s11, zero, v9, v2]
  li v15, 1  ; live: [s11, v15, zero, v9, v2]
  sub v10, v2, v15  ; live: [s11, v10, zero, v9, v2]
  mv s10, v9  ; live: [s11, v10, zero, v9, v2]
  ld v13, 0(v9)  ; live: [s11, v10, zero, v2]
  mv a0, v10  ; live: [s11, zero, a0, v2]
  jalr v13  ; live: [s11, zero, v2]
  mv v11, zero  ; live: [v11, s11, zero, v2]
; control
  mv v12, v11  ; live: [s11, zero, v2]
  j .f_b3  ; live: [s11, zero, v2]

; block info: defs: [v12], uses: [zero], upward_exposed: [zero], params_defs: []
; live_in: [zero], live_out: [v12]
; block parameters: []
.f_b2:
; control
  mv v12, zero  ; live: [zero]
  j .f_b3  ; live: [zero]

  .p2align 3
  .globl thunk_start
  .type thunk_start, @function
thunk_start:
; block info: defs: [t1, ft0, ft1, a1, t5, fa1, fa2, ft6, a4, fa6, a6, ft5, ft10, ft7, ft4, ft9, a5, a0, fa4, ft2, a2, a3, ft8, t3, a7, fa7, t0, fa5, fa3, ft3, fa0, t4, t2, v2], uses: [zero, a0, v2], upward_exposed: [zero], params_defs: []
; live_in: [zero], live_out: []
; block parameters: []
.thunk_start_b0:
  call main  ; live: [zero]
  mv v2, zero  ; live: [zero, v2]
; control
  mv a0, v2  ; live: [zero, a0]
  ret  ; live: [zero]

  .p2align 3
  .globl main
  .type main, @function
main:
; block info: defs: [v2, t1, ft0, ft1, a1, t5, fa1, fa2, ft6, a4, fa6, a6, ft5, ft10, ft7, ft4, ft9, a5, a0, fa4, ft2, a2, a3, ft8, t3, a7, fa7, t0, fa5, fa3, ft3, fa0, t4, t2, v3], uses: [v2, a0, zero, v3], upward_exposed: [zero], params_defs: []
; live_in: [zero], live_out: []
; block parameters: []
.main_b0:
  li v3, 9  ; live: [zero, v3]
  mv a0, v3  ; live: [zero, a0]
  call f  ; live: [zero]
  mv v2, zero  ; live: [zero, v2]
; control
  mv a0, v2  ; live: [zero, a0]
  ret  ; live: [zero]

  .p2align 3
  .globl start
  .type start, @object
start:
  .zero 4



Testing test/test_src/cls-rec.mbt
# name conventions used in the core ir:
# - functions: f<id>
# - blocks: b<id>
# - instructions: %<id>
# - memory: m<id>
# - free variables: ^<id>
# - function parameters: $f<pid>
# - block parameters: $b<bid>.<pid>
.core
.fn f #f1 : fn(int32) -> int32
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: bool = eq($f0, 0)
    br %0 b1() b2()
  }
  .bb #b1 () {
    jump b3(0)
  }
  .bb #b2 () {
    let %1: int32 = sub($f0, 1)
    let %2: int32 = call f1(%1)
    let %3: int32 = load_symbol ::0
    let %4: int32 = add(%3, %2)
    jump b3(%4)
  }
  .bb #b3 (int32) {
    return $b3.0
  }
}
.fn thunk_start #f3 : fn() -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: unit = call f2()
    return %0
  }
}
.fn thunk_x.1 #f0 : fn() -> int32
.freevars ()
.entry b0 {
  .bb #b0 () {
    return 10
  }
}
.fn main #f2 : fn() -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: int32 = call f1(12)
    let %1: unit = ext_call minimbt_print_int(%0)
    return %1
  }
}
.thunk ::0 x.1
.thunk ::1 start

  .p2align 3
  .globl _start
  .type _start, @function
_start:
; block info: defs: [t1, ft0, ft1, a1, t5, fa1, fa2, ft6, a4, fa6, t6, a6, ft10, ft5, ft7, ft4, ft9, a5, a0, fa4, ft2, a2, a3, ft8, t3, a7, fa7, t0, fa5, fa3, ft3, fa0, t4, t2], uses: [a0, t6], upward_exposed: [], params_defs: []
; live_in: [], live_out: []
; block parameters: []
_start_b0:
  call thunk_x.1  ; live: [a0]
  la t6, x.1  ; live: [a0, t6]
  sw a0, 0(t6)  ; live: []
  call thunk_start  ; live: [a0]
; control
  ret  ; live: []

  .p2align 3
  .globl f
  .type f, @function
f:
; block info: defs: [v3, v15, v2], uses: [v3, v15, a0, zero, v2], upward_exposed: [a0, zero], params_defs: []
; live_in: [a0, zero], live_out: [zero, v2]
; block parameters: []
.f_b0:
  mv v2, a0  ; live: [a0, zero, v2]
  xor v15, v2, zero  ; live: [v15, a0, zero]
  sltiu v3, v15, 1  ; live: [a0, zero, v3]
; control
  bne v3, zero, .f_b1  ; live: [a0, zero]
  j .f_b2  ; live: [a0, zero]

; block info: defs: [a0], uses: [a0, v8], upward_exposed: [v8], params_defs: [v8]
; live_in: [v8], live_out: []
; block parameters: [v8]
.f_b3:
; control
  mv a0, v8  ; live: [a0, v8]
  ret  ; live: [v8]

; block info: defs: [v8], uses: [zero], upward_exposed: [zero], params_defs: []
; live_in: [zero], live_out: [v8]
; block parameters: []
.f_b1:
; control
  mv v8, zero  ; live: [zero]
  j .f_b3  ; live: [zero]

; block info: defs: [t1, v13, v7, ft0, ft1, a1, t5, fa1, fa2, ft6, a4, fa6, v8, a6, ft5, ft10, v4, v6, ft7, ft4, v5, ft9, v10, a5, fa4, a0, ft2, a2, a3, ft8, t3, a7, fa7, t0, fa5, fa3, ft3, fa0, t4, t2], uses: [v5, v10, v13, a0, v7, v4, v6, v2], upward_exposed: [v2], params_defs: []
; live_in: [v2], live_out: [v8]
; block parameters: []
.f_b2:
  li v13, 1  ; live: [v13, v2]
  sub v4, v2, v13  ; live: [v4, v2]
  mv a0, v4  ; live: [a0, v2]
  call f  ; live: [a0, v2]
  mv v5, a0  ; live: [v5, v2]
  la v10, x.1  ; live: [v5, v10, v2]
  lw v6, 0(v10)  ; live: [v6, v5, v2]
  add v7, v6, v5  ; live: [v7, v2]
; control
  mv v8, v7  ; live: [v2]
  j .f_b3  ; live: [v2]

  .p2align 3
  .globl thunk_start
  .type thunk_start, @function
thunk_start:
; block info: defs: [t1, ft0, ft1, a1, t5, fa1, fa2, ft6, a4, fa6, a6, ft5, ft10, ft7, ft4, ft9, a5, a0, fa4, ft2, a2, a3, ft8, t3, a7, fa7, t0, fa5, fa3, ft3, fa0, t4, t2, v2], uses: [zero, a0, v2], upward_exposed: [zero], params_defs: []
; live_in: [zero], live_out: []
; block parameters: []
.thunk_start_b0:
  call main  ; live: [zero]
  mv v2, zero  ; live: [zero, v2]
; control
  mv a0, v2  ; live: [zero, a0]
  ret  ; live: [zero]

  .p2align 3
  .globl thunk_x.1
  .type thunk_x.1, @function
thunk_x.1:
; block info: defs: [a0, v2], uses: [a0, v2], upward_exposed: [], params_defs: []
; live_in: [], live_out: []
; block parameters: []
.thunk_x.1_b0:
; control
  li v2, 10  ; live: [v2]
  mv a0, v2  ; live: [a0]
  ret  ; live: []

  .p2align 3
  .globl main
  .type main, @function
main:
; block info: defs: [v3, t1, ft0, ft1, a1, t5, fa1, fa2, ft6, a4, fa6, a6, ft5, ft10, ft7, ft4, v5, ft9, a5, a0, fa4, ft2, a2, a3, ft8, t3, a7, fa7, t0, fa5, fa3, ft3, fa0, t4, t2, v2], uses: [v3, v5, a0, zero, v2], upward_exposed: [zero], params_defs: []
; live_in: [zero], live_out: []
; block parameters: []
.main_b0:
  li v5, 12  ; live: [v5, zero]
  mv a0, v5  ; live: [zero, a0]
  call f  ; live: [zero, a0]
  mv v2, a0  ; live: [zero, v2]
  mv a0, v2  ; live: [zero, a0]
  call minimbt_print_int  ; live: [zero]
  mv v3, zero  ; live: [zero, v3]
; control
  mv a0, v3  ; live: [zero, a0]
  ret  ; live: [zero]

  .p2align 3
  .globl x.1
  .type x.1, @object
x.1:
  .zero 4
  .p2align 3
  .globl start
  .type start, @object
start:
  .zero 4



Testing test/test_src/cls-reg-bug.mbt
# name conventions used in the core ir:
# - functions: f<id>
# - blocks: b<id>
# - instructions: %<id>
# - memory: m<id>
# - free variables: ^<id>
# - function parameters: $f<pid>
# - block parameters: $b<bid>.<pid>
.core
.fn g #f1 : closure(int32) -> int32
.freevars (int32, int32, int32, int32, int32, int32, int32, int32, int32, int32)
.entry b0 {
  .bb #b0 () {
    let %0: int32 = add(^1, ^2)
    let %1: int32 = add(%0, ^3)
    let %2: int32 = add(%1, ^4)
    let %3: int32 = add(%2, ^5)
    let %4: int32 = add(%3, ^6)
    let %5: int32 = add(%4, ^7)
    let %6: int32 = add(%5, ^8)
    let %7: int32 = add(%6, ^9)
    let %8: int32 = add(%7, ^10)
    let %9: bool = le($f0, 0)
    br %9 b1() b2()
  }
  .bb #b1 () {
    let %10: int32 = neg($f0)
    let %11: int32 = apply self(%10)
    jump b3(%11)
  }
  .bb #b2 () {
    jump b3(%8)
  }
  .bb #b3 (int32) {
    return $b3.0
  }
}
.fn main #f2 : fn() -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let _ = alloc <m0: (int32, int32, int32, int32, int32, int32, int32, int32, int32, int32) heap(10)> <- [0] = 1, [1] = 2, [2] = 3, [3] = 4, [4] = 5, [5] = 6, [6] = 7, [7] = 8, [8] = 9, [9] = 10
    let %1: int32 = call f0(f2.m0)
    let %2: unit = ext_call minimbt_print_int(%1)
    return ()
  }
}
.fn thunk_start #f3 : fn() -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: unit = call f2()
    return %0
  }
}
.fn h #f0 : fn((int32, int32, int32, int32, int32, int32, int32, int32, int32, int32)) -> int32
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: int32 = load int32 field($f0, 0)
    let %1: int32 = load int32 field($f0, 1)
    let %2: int32 = load int32 field($f0, 2)
    let %3: int32 = load int32 field($f0, 3)
    let %4: int32 = load int32 field($f0, 4)
    let %5: int32 = load int32 field($f0, 5)
    let %6: int32 = load int32 field($f0, 6)
    let %7: int32 = load int32 field($f0, 7)
    let %8: int32 = load int32 field($f0, 8)
    let %9: int32 = load int32 field($f0, 9)
    let _ = alloc <m0: closure(int32) -> int32 heap(11)> <- [0] = f1, [1] = %0, [2] = %1, [3] = %2, [4] = %3, [5] = %4, [6] = %5, [7] = %6, [8] = %7, [9] = %8, [10] = %9
    let %11: int32 = apply f0.m0(1)
    return %11
  }
}
.thunk ::0 start

  .p2align 3
  .globl _start
  .type _start, @function
_start:
; block info: defs: [t1, ft0, ft1, a1, t5, fa1, fa2, ft6, a4, fa6, a6, ft5, ft10, ft7, ft4, ft9, a5, a0, fa4, ft2, a2, a3, ft8, t3, a7, fa7, t0, fa5, fa3, ft3, fa0, t4, t2], uses: [a0], upward_exposed: [], params_defs: []
; live_in: [], live_out: []
; block parameters: []
_start_b0:
  call thunk_start  ; live: [a0]
; control
  ret  ; live: []

  .p2align 3
  .globl thunk_start
  .type thunk_start, @function
thunk_start:
; block info: defs: [t1, ft0, ft1, a1, t5, fa1, fa2, ft6, a4, fa6, a6, ft5, ft10, ft7, ft4, ft9, a5, a0, fa4, ft2, a2, a3, ft8, t3, a7, fa7, t0, fa5, fa3, ft3, fa0, t4, t2, v2], uses: [zero, a0, v2], upward_exposed: [zero], params_defs: []
; live_in: [zero], live_out: []
; block parameters: []
.thunk_start_b0:
  call main  ; live: [zero]
  mv v2, zero  ; live: [zero, v2]
; control
  mv a0, v2  ; live: [zero, a0]
  ret  ; live: [zero]

  .p2align 3
  .globl g
  .type g, @function
g:
; block info: defs: [v3, v11, v5, v14, v16, v10, v21, v13, v22, v7, v0, v17, v12, v9, v18, v29, v20, v8, v19, v4, v6, v15, v2], uses: [v2, v11, v5, v14, v16, v10, v13, a0, v22, v7, v0, v17, v12, s10, v9, v18, zero, v29, v20, v8, v19, v4, v6, v15, v3], upward_exposed: [s10, a0, zero], params_defs: []
; live_in: [s10, a0, zero], live_out: [v0, v21, v2]
; block parameters: []
.g_b0:
  mv v0, s10  ; live: [a0, v0, s10, zero]
  mv v2, a0  ; live: [a0, v0, s10, zero, v2]
  lw v3, 8(v0)  ; live: [v2, a0, v0, s10, zero, v3]
  lw v4, 16(v0)  ; live: [v2, a0, v0, s10, zero, v4, v3]
  lw v5, 24(v0)  ; live: [v2, v5, a0, v0, s10, zero, v4, v3]
  lw v6, 32(v0)  ; live: [v2, v5, a0, v0, s10, zero, v4, v6, v3]
  lw v7, 40(v0)  ; live: [v2, v5, a0, v7, v0, s10, zero, v4, v6, v3]
  lw v8, 48(v0)  ; live: [v2, v5, a0, v7, v0, s10, zero, v8, v4, v6, v3]
  lw v9, 56(v0)  ; live: [v2, v5, a0, v7, v0, s10, v9, zero, v8, v4, v6, v3]
  lw v10, 64(v0)  ; live: [v2, v5, v10, a0, v7, v0, s10, v9, zero, v8, v4, v6, v3]
  lw v11, 72(v0)  ; live: [v2, v11, v5, v10, a0, v7, v0, s10, v9, zero, v8, v4, v6, v3]
  lw v12, 80(v0)  ; live: [v2, v11, v5, v10, a0, v7, v12, s10, v9, zero, v8, v4, v6, v3]
  add v13, v3, v4  ; live: [v11, v5, v10, a0, zero, v13, v7, v8, v6, v12, s10, v9, v2]
  add v14, v13, v5  ; live: [v11, v14, v10, a0, zero, v8, v7, v6, v12, s10, v9, v2]
  add v15, v14, v6  ; live: [v11, v10, a0, zero, v8, v7, v12, v15, s10, v9, v2]
  add v16, v15, v7  ; live: [v11, v16, v10, a0, zero, v8, v12, s10, v9, v2]
  add v17, v16, v8  ; live: [v11, v10, a0, zero, v17, v12, s10, v9, v2]
  add v18, v17, v9  ; live: [v11, v18, v10, a0, zero, v12, s10, v2]
  add v19, v18, v10  ; live: [v11, a0, zero, v19, v12, s10, v2]
  add v20, v19, v11  ; live: [v20, v2, v12, s10, a0, zero]
  add v21, v20, v12  ; live: [v2, s10, a0, zero]
  slt v29, v2, zero  ; live: [v29, s10, a0, zero]
  xori v22, v29, 1  ; live: [v22, s10, a0, zero]
; control
  bne v22, zero, .g_b1  ; live: [s10, a0, zero]
  j .g_b2  ; live: [s10, a0, zero]

; block info: defs: [a0], uses: [v25, a0], upward_exposed: [v25], params_defs: [v25]
; live_in: [v25], live_out: []
; block parameters: [v25]
.g_b3:
; control
  mv a0, v25  ; live: [v25, a0]
  ret  ; live: [v25]

; block info: defs: [v25, t1, v26, ft0, ft1, a1, t5, fa1, fa2, ft6, a4, fa6, a6, ft5, ft10, ft7, ft4, ft9, a5, a0, fa4, ft2, a2, a3, v24, s10, ft8, a7, t3, fa7, t0, fa5, fa3, v23, ft3, fa0, t4, t2], uses: [v0, v24, a0, v23, v2], upward_exposed: [v0, v2], params_defs: []
; live_in: [v0, v2], live_out: [v25]
; block parameters: []
.g_b1:
  neg v23, v2  ; live: [v0, v23, v2]
  mv s10, v0  ; live: [v0, v23, v2]
  ld v26, 0(v0)  ; live: [v0, v23, v2]
  mv a0, v23  ; live: [v0, a0, v2]
  jalr v26  ; live: [v0, a0, v2]
  mv v24, a0  ; live: [v0, v24, v2]
; control
  mv v25, v24  ; live: [v0, v2]
  j .g_b3  ; live: [v0, v2]

; block info: defs: [v25], uses: [v21], upward_exposed: [v21], params_defs: []
; live_in: [v21], live_out: [v25]
; block parameters: []
.g_b2:
; control
  mv v25, v21  ; live: [v21]
  j .g_b3  ; live: [v21]

  .p2align 3
  .globl h
  .type h, @function
h:
; block info: defs: [v3, t1, v16, v13, v7, ft0, ft1, a1, v12, t5, fa1, fa2, ft6, a4, fa6, v8, a6, v19, ft5, ft10, v4, v6, ft7, v11, ft4, v5, v10, v21, ft9, a5, a0, fa4, ft2, a2, v17, a3, v9, s10, ft8, t3, a7, fa7, t0, fa5, fa3, ft3, fa0, t4, t2, v15, v2], uses: [v3, v11, v5, v21, v10, a0, v13, v7, v17, s11, v12, v9, v8, v19, v4, v6, v15, v2], upward_exposed: [s11, a0], params_defs: []
; live_in: [s11, a0], live_out: []
; block parameters: []
.h_b0:
  mv v2, a0  ; live: [s11, v2]
  lw v4, 0(v2)  ; live: [s11, v4, v2]
  lw v5, 4(v2)  ; live: [v5, s11, v4, v2]
  lw v6, 8(v2)  ; live: [v5, s11, v4, v6, v2]
  lw v7, 12(v2)  ; live: [v5, v7, s11, v4, v6, v2]
  lw v8, 16(v2)  ; live: [v5, v7, s11, v8, v4, v6, v2]
  lw v9, 20(v2)  ; live: [v5, v7, s11, v9, v8, v4, v6, v2]
  lw v10, 24(v2)  ; live: [v5, v10, v7, s11, v9, v8, v4, v6, v2]
  lw v11, 28(v2)  ; live: [v11, v5, v10, v7, s11, v9, v8, v4, v6, v2]
  lw v12, 32(v2)  ; live: [v11, v5, v10, v7, s11, v12, v9, v8, v4, v6, v2]
  lw v13, 36(v2)  ; live: [v11, v5, v10, v13, v7, s11, v12, v9, v8, v4, v6]
  addi v19, s11, -88  ; live: [v11, v5, v10, v13, v7, s11, v12, v9, v8, v19, v4, v6]
  andi v3, v19, -8  ; live: [v11, v5, v10, v13, v7, s11, v12, v9, v8, v4, v6, v3]
  la v21, g  ; live: [v11, v5, v10, v21, v13, v7, s11, v12, v9, v8, v4, v6, v3]
  sd v21, 0(v3)  ; live: [v11, v5, v10, v13, v8, v7, v4, v6, s11, v12, v9, v3]
  sd v4, 8(v3)  ; live: [v11, v5, v10, v13, v8, v7, v6, s11, v12, v9, v3]
  sd v5, 16(v3)  ; live: [v11, v10, v13, v8, v7, v6, s11, v12, v9, v3]
  sd v6, 24(v3)  ; live: [v11, v10, v13, v8, v7, s11, v12, v9, v3]
  sd v7, 32(v3)  ; live: [v11, v10, v13, v8, s11, v12, v9, v3]
  sd v8, 40(v3)  ; live: [v11, v10, v13, s11, v12, v9, v3]
  sd v9, 48(v3)  ; live: [v11, v10, v13, s11, v12, v3]
  sd v10, 56(v3)  ; live: [v11, s11, v12, v13, v3]
  sd v11, 64(v3)  ; live: [s11, v12, v13, v3]
  sd v12, 72(v3)  ; live: [s11, v13, v3]
  sd v13, 80(v3)  ; live: [s11, v3]
  mv s10, v3  ; live: [s11, v3]
  ld v16, 0(v3)  ; live: [s11]
  li v17, 1  ; live: [v17, s11]
  mv a0, v17  ; live: [s11, a0]
  jalr v16  ; live: [s11, a0]
  mv v15, a0  ; live: [s11, v15]
; control
  mv a0, v15  ; live: [s11, a0]
  ret  ; live: [s11, a0]

  .p2align 3
  .globl main
  .type main, @function
main:
; block info: defs: [t1, v14, v16, v13, ft0, ft1, a1, v12, t5, fa1, fa2, ft6, a4, fa6, v8, a6, v19, ft10, ft5, v4, ft7, v11, ft4, v5, v10, ft9, a5, a0, fa4, ft2, a2, v17, a3, ft8, t3, a7, fa7, t0, fa5, v18, fa3, ft3, fa0, t4, t2, v15, v2], uses: [v11, v14, v16, v10, v13, a0, v17, s11, v12, v18, zero, v8, v19, v4, v15, v2], upward_exposed: [s11, zero], params_defs: []
; live_in: [s11, zero], live_out: []
; block parameters: []
.main_b0:
  addi v8, s11, -80  ; live: [s11, zero, v8]
  andi v2, v8, -8  ; live: [s11, zero, v2]
  li v10, 1  ; live: [s11, v10, zero, v2]
  sd v10, 0(v2)  ; live: [s11, zero, v2]
  li v11, 2  ; live: [v11, s11, zero, v2]
  sd v11, 8(v2)  ; live: [s11, zero, v2]
  li v12, 3  ; live: [s11, v12, zero, v2]
  sd v12, 16(v2)  ; live: [s11, zero, v2]
  li v13, 4  ; live: [s11, zero, v13, v2]
  sd v13, 24(v2)  ; live: [s11, zero, v2]
  li v14, 5  ; live: [v14, s11, zero, v2]
  sd v14, 32(v2)  ; live: [s11, zero, v2]
  li v15, 6  ; live: [s11, v15, zero, v2]
  sd v15, 40(v2)  ; live: [s11, zero, v2]
  li v16, 7  ; live: [v16, s11, zero, v2]
  sd v16, 48(v2)  ; live: [s11, zero, v2]
  li v17, 8  ; live: [v17, s11, zero, v2]
  sd v17, 56(v2)  ; live: [s11, zero, v2]
  li v18, 9  ; live: [s11, v18, zero, v2]
  sd v18, 64(v2)  ; live: [s11, zero, v2]
  li v19, 10  ; live: [v19, s11, zero, v2]
  sd v19, 72(v2)  ; live: [s11, zero, v2]
  mv a0, v2  ; live: [s11, zero, a0]
  call h  ; live: [s11, zero, a0]
  mv v4, a0  ; live: [v4, s11, zero]
  mv a0, v4  ; live: [s11, zero, a0]
  call minimbt_print_int  ; live: [s11, zero]
  mv v5, zero  ; live: [s11, zero]
; control
  mv a0, zero  ; live: [s11, zero, a0]
  ret  ; live: [s11, zero]

  .p2align 3
  .globl start
  .type start, @object
start:
  .zero 4



Testing test/test_src/debug.mbt
# name conventions used in the core ir:
# - functions: f<id>
# - blocks: b<id>
# - instructions: %<id>
# - memory: m<id>
# - free variables: ^<id>
# - function parameters: $f<pid>
# - block parameters: $b<bid>.<pid>
.core
.fn f #f1 : fn(int32) -> int32
.freevars ()
.entry b0 {
  .bb #b0 () {
    let _ = alloc <m0: closure(int32) -> int32 heap(2)> <- [0] = f2, [1] = $f0
    let %1: bool = eq(1, 1)
    br %1 b1() b2()
  }
  .bb #b1 () {
    let %2: int32 = call f1(1)
    jump b3(%2)
  }
  .bb #b2 () {
    let %3: int32 = apply f1.m0(2)
    jump b3(%3)
  }
  .bb #b3 (int32) {
    return $b3.0
  }
}
.fn thunk_start #f4 : fn() -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: unit = call f3()
    return %0
  }
}
.fn g #f2 : closure(int32) -> int32
.freevars (int32)
.entry b0 {
  .bb #b0 () {
    return ^1
  }
}
.fn dummy #f0 : fn(int32) -> int32
.freevars ()
.entry b0 {
  .bb #b0 () {
    return $f0
  }
}
.fn main #f3 : fn() -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    return ()
  }
}
.thunk ::0 start

  .p2align 3
  .globl _start
  .type _start, @function
_start:
; block info: defs: [t1, ft0, ft1, a1, t5, fa1, fa2, ft6, a4, fa6, a6, ft5, ft10, ft7, ft4, ft9, a5, a0, fa4, ft2, a2, a3, ft8, t3, a7, fa7, t0, fa5, fa3, ft3, fa0, t4, t2], uses: [a0], upward_exposed: [], params_defs: []
; live_in: [], live_out: []
; block parameters: []
_start_b0:
  call thunk_start  ; live: [a0]
; control
  ret  ; live: []

  .p2align 3
  .globl f
  .type f, @function
f:
; block info: defs: [v2, v14, v16, v5, v18, v20, v15, v3], uses: [v3, v14, v16, v5, v18, a0, zero, v20, s11, v15, v2], upward_exposed: [s11, a0, zero], params_defs: []
; live_in: [s11, a0, zero], live_out: [v3]
; block parameters: []
.f_b0:
  mv v2, a0  ; live: [a0, zero, s11, v2]
  addi v18, s11, -16  ; live: [v18, a0, zero, s11, v2]
  andi v3, v18, -8  ; live: [v2, a0, zero, s11, v3]
  la v20, g  ; live: [v2, a0, zero, v20, s11, v3]
  sd v20, 0(v3)  ; live: [v3, s11, a0, zero, v2]
  sd v2, 8(v3)  ; live: [s11, a0, zero]
  li v14, 1  ; live: [v14, s11, a0, zero]
  li v15, 1  ; live: [v14, s11, v15, a0, zero]
  xor v16, v14, v15  ; live: [v16, s11, a0, zero]
  sltiu v5, v16, 1  ; live: [v5, s11, a0, zero]
; control
  bne v5, zero, .f_b1  ; live: [s11, a0, zero]
  j .f_b2  ; live: [s11, a0, zero]

; block info: defs: [a0], uses: [a0, v8], upward_exposed: [v8], params_defs: [v8]
; live_in: [v8], live_out: []
; block parameters: [v8]
.f_b3:
; control
  mv a0, v8  ; live: [a0, v8]
  ret  ; live: [v8]

; block info: defs: [t1, v7, ft0, ft1, a1, t5, fa1, fa2, ft6, a4, fa6, v8, a6, ft10, ft5, ft7, ft4, ft9, a5, a0, fa4, ft2, a2, a3, v9, ft8, a7, t3, fa7, t0, fa5, fa3, ft3, fa0, t4, t2], uses: [v9, a0, v7], upward_exposed: [], params_defs: []
; live_in: [], live_out: [v8]
; block parameters: []
.f_b1:
  li v9, 1  ; live: [v9]
  mv a0, v9  ; live: [a0]
  call f  ; live: [a0]
  mv v7, a0  ; live: [v7]
; control
  mv v8, v7  ; live: []
  j .f_b3  ; live: []

; block info: defs: [t1, ft0, ft1, a1, v12, t5, fa1, fa2, ft6, a4, fa6, v8, a6, ft10, ft5, v6, ft7, v11, ft4, ft9, a5, a0, fa4, ft2, a2, a3, s10, ft8, t3, a7, fa7, t0, fa5, fa3, ft3, fa0, t4, t2], uses: [v6, v12, a0, v3], upward_exposed: [v3], params_defs: []
; live_in: [v3], live_out: [v8]
; block parameters: []
.f_b2:
  mv s10, v3  ; live: [v3]
  ld v11, 0(v3)  ; live: [v3]
  li v12, 2  ; live: [v12, v3]
  mv a0, v12  ; live: [a0, v3]
  jalr v11  ; live: [a0, v3]
  mv v6, a0  ; live: [v6, v3]
; control
  mv v8, v6  ; live: [v3]
  j .f_b3  ; live: [v3]

  .p2align 3
  .globl thunk_start
  .type thunk_start, @function
thunk_start:
; block info: defs: [t1, ft0, ft1, a1, t5, fa1, fa2, ft6, a4, fa6, a6, ft5, ft10, ft7, ft4, ft9, a5, a0, fa4, ft2, a2, a3, ft8, t3, a7, fa7, t0, fa5, fa3, ft3, fa0, t4, t2, v2], uses: [zero, a0, v2], upward_exposed: [zero], params_defs: []
; live_in: [zero], live_out: []
; block parameters: []
.thunk_start_b0:
  call main  ; live: [zero]
  mv v2, zero  ; live: [zero, v2]
; control
  mv a0, v2  ; live: [zero, a0]
  ret  ; live: [zero]

  .p2align 3
  .globl g
  .type g, @function
g:
; block info: defs: [v3, v0, a0, v2], uses: [v0, s10, a0, v3], upward_exposed: [s10, a0], params_defs: []
; live_in: [s10, a0], live_out: []
; block parameters: []
.g_b0:
  mv v0, s10  ; live: [v0, s10, a0]
  mv v2, a0  ; live: [v0, s10]
  lw v3, 8(v0)  ; live: [s10, v3]
; control
  mv a0, v3  ; live: [s10, a0]
  ret  ; live: [s10, a0]

  .p2align 3
  .globl dummy
  .type dummy, @function
dummy:
; block info: defs: [a0, v2], uses: [a0, v2], upward_exposed: [a0], params_defs: []
; live_in: [a0], live_out: []
; block parameters: []
.dummy_b0:
  mv v2, a0  ; live: [v2]
; control
  mv a0, v2  ; live: [a0]
  ret  ; live: [a0]

  .p2align 3
  .globl main
  .type main, @function
main:
; block info: defs: [a0], uses: [zero, a0], upward_exposed: [zero], params_defs: []
; live_in: [zero], live_out: []
; block parameters: []
.main_b0:
; control
  mv a0, zero  ; live: [zero, a0]
  ret  ; live: [zero]

  .p2align 3
  .globl start
  .type start, @object
start:
  .zero 4



Testing test/test_src/even-odd.mbt
# name conventions used in the core ir:
# - functions: f<id>
# - blocks: b<id>
# - instructions: %<id>
# - memory: m<id>
# - free variables: ^<id>
# - function parameters: $f<pid>
# - block parameters: $b<bid>.<pid>
.core
.fn even #f2 : fn(int32) -> int32
.freevars ()
.entry b0 {
  .bb #b6 (int32) {
    return $b6.0
  }
  .bb #b4 () {
    let %4: int32 = sub($f0, 1)
    let %5: int32 = apply f2.m0(%4)
    jump b5(%5)
  }
  .bb #b1 () {
    let %2: bool = eq($f0, 0)
    br %2 b3() b4()
  }
  .bb #b5 (int32) {
    jump b6($b5.0)
  }
  .bb #b2 () {
    let %6: int32 = add($f0, 1)
    let %7: int32 = apply f2.m0(%6)
    jump b6(%7)
  }
  .bb #b3 () {
    let %3: int32 = load_symbol ::0
    jump b5(%3)
  }
  .bb #b0 () {
    let _ = alloc <m0: closure(int32) -> int32 heap(1)> <- [0] = f3
    let %1: bool = le(0, $f0)
    br %1 b1() b2()
  }
}
.fn main #f4 : fn() -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: int32 = call f2(789)
    let %1: unit = ext_call minimbt_print_int(%0)
    return %1
  }
}
.fn odd #f3 : closure(int32) -> int32
.freevars ()
.entry b0 {
  .bb #b6 (int32) {
    return $b6.0
  }
  .bb #b4 () {
    let %3: int32 = sub($f0, 1)
    let %4: int32 = call f2(%3)
    jump b5(%4)
  }
  .bb #b1 () {
    let %1: bool = eq($f0, 0)
    br %1 b3() b4()
  }
  .bb #b5 (int32) {
    jump b6($b5.0)
  }
  .bb #b2 () {
    let %5: int32 = add($f0, 1)
    let %6: int32 = call f2(%5)
    jump b6(%6)
  }
  .bb #b3 () {
    let %2: int32 = load_symbol ::1
    jump b5(%2)
  }
  .bb #b0 () {
    let %0: bool = le(0, $f0)
    br %0 b1() b2()
  }
}
.fn thunk_start #f5 : fn() -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: unit = call f4()
    return %0
  }
}
.fn thunk_t.1 #f0 : fn() -> int32
.freevars ()
.entry b0 {
  .bb #b0 () {
    return 123
  }
}
.fn thunk_f.2 #f1 : fn() -> int32
.freevars ()
.entry b0 {
  .bb #b0 () {
    return 456
  }
}
.thunk ::0 t.1
.thunk ::1 f.2
.thunk ::2 start

  .p2align 3
  .globl even
  .type even, @function
even:
; block info: defs: [v3, v5, v28, v26, v30, v2], uses: [v2, v5, a0, zero, v26, v30, s11, v28, v3], upward_exposed: [s11, a0, zero], params_defs: []
; live_in: [s11, a0, zero], live_out: [v3, zero, v2]
; block parameters: []
.even_b0:
  mv v2, a0  ; live: [s11, a0, zero, v2]
  addi v28, s11, -8  ; live: [s11, v28, a0, zero, v2]
  andi v3, v28, -8  ; live: [v3, s11, a0, zero, v2]
  la v30, odd  ; live: [v2, v3, s11, a0, zero, v30]
  sd v30, 0(v3)  ; live: [s11, a0, zero, v2]
  slt v26, zero, v2  ; live: [s11, a0, zero, v26]
  xori v5, v26, 1  ; live: [v5, s11, a0, zero]
; control
  bne v5, zero, .even_b1  ; live: [s11, a0, zero]
  j .even_b2  ; live: [s11, a0, zero]

; block info: defs: [v11, v14, v12], uses: [v11, v14], upward_exposed: [], params_defs: []
; live_in: [], live_out: [v12]
; block parameters: []
.even_b3:
  la v14, t.1  ; live: [v14]
  lw v11, 0(v14)  ; live: [v11]
; control
  mv v12, v11  ; live: []
  j .even_b5  ; live: []

; block info: defs: [v13], uses: [v12], upward_exposed: [v12], params_defs: [v12]
; live_in: [v12], live_out: [v13]
; block parameters: [v12]
.even_b5:
; control
  mv v13, v12  ; live: [v12]
  j .even_b6  ; live: [v12]

; block info: defs: [v20, v8], uses: [v8, zero, v20, v2], upward_exposed: [zero, v2], params_defs: []
; live_in: [v3, zero, v2], live_out: [v3, v2]
; block parameters: []
.even_b1:
  xor v20, v2, zero  ; live: [v2, zero, v20, v3]
  sltiu v8, v20, 1  ; live: [v2, v8, zero, v3]
; control
  bne v8, zero, .even_b3  ; live: [v2, zero, v3]
  j .even_b4  ; live: [v2, zero, v3]

; block info: defs: [a0], uses: [v13, a0], upward_exposed: [v13], params_defs: [v13]
; live_in: [v13], live_out: []
; block parameters: [v13]
.even_b6:
; control
  mv a0, v13  ; live: [v13, a0]
  ret  ; live: [v13]

; block info: defs: [t1, v16, ft0, ft1, a1, v12, t5, fa1, fa2, ft6, a4, fa6, a6, ft5, ft10, ft7, ft4, ft9, v10, a5, fa4, a0, ft2, a2, a3, s10, v9, ft8, a7, t3, fa7, t0, fa5, v18, fa3, ft3, fa0, t4, t2], uses: [v3, v18, v10, v9, a0, v2], upward_exposed: [v3, v2], params_defs: []
; live_in: [v2, v3], live_out: [v12]
; block parameters: []
.even_b4:
  li v18, 1  ; live: [v3, v18, v2]
  sub v9, v2, v18  ; live: [v3, v9, v2]
  mv s10, v3  ; live: [v3, v9, v2]
  ld v16, 0(v3)  ; live: [v3, v9, v2]
  mv a0, v9  ; live: [v3, a0, v2]
  jalr v16  ; live: [v3, a0, v2]
  mv v10, a0  ; live: [v3, v10, v2]
; control
  mv v12, v10  ; live: [v3, v2]
  j .even_b5  ; live: [v3, v2]

; block info: defs: [t1, v13, v22, v7, ft0, ft1, a1, t5, fa1, fa2, ft6, a4, fa6, a6, ft5, ft10, v6, ft7, ft4, ft9, a5, a0, fa4, ft2, a2, v24, a3, s10, ft8, a7, t3, fa7, t0, fa5, fa3, ft3, fa0, t4, t2], uses: [v3, v7, v6, v24, a0, v2], upward_exposed: [v3, v2], params_defs: []
; live_in: [v2, v3], live_out: [v13]
; block parameters: []
.even_b2:
  li v24, 1  ; live: [v3, v24, v2]
  add v6, v2, v24  ; live: [v3, v6, v2]
  mv s10, v3  ; live: [v3, v6, v2]
  ld v22, 0(v3)  ; live: [v3, v6, v2]
  mv a0, v6  ; live: [v3, a0, v2]
  jalr v22  ; live: [v3, a0, v2]
  mv v7, a0  ; live: [v3, v7, v2]
; control
  mv v13, v7  ; live: [v3, v2]
  j .even_b6  ; live: [v3, v2]

  .p2align 3
  .globl main
  .type main, @function
main:
; block info: defs: [v3, t1, ft0, ft1, a1, t5, fa1, fa2, ft6, a4, fa6, a6, ft5, ft10, ft7, ft4, v5, ft9, a5, a0, fa4, ft2, a2, a3, ft8, t3, a7, fa7, t0, fa5, fa3, ft3, fa0, t4, t2, v2], uses: [v3, v5, a0, zero, v2], upward_exposed: [zero], params_defs: []
; live_in: [zero], live_out: []
; block parameters: []
.main_b0:
  li v5, 789  ; live: [v5, zero]
  mv a0, v5  ; live: [zero, a0]
  call even  ; live: [zero, a0]
  mv v2, a0  ; live: [zero, v2]
  mv a0, v2  ; live: [zero, a0]
  call minimbt_print_int  ; live: [zero]
  mv v3, zero  ; live: [zero, v3]
; control
  mv a0, v3  ; live: [zero, a0]
  ret  ; live: [zero]

  .p2align 3
  .globl odd
  .type odd, @function
odd:
; block info: defs: [v3, v22, v2], uses: [v2, v3, a0, zero, v22], upward_exposed: [a0, zero], params_defs: []
; live_in: [a0, zero], live_out: [zero, v2]
; block parameters: []
.odd_b0:
  mv v2, a0  ; live: [a0, zero, v2]
  slt v22, zero, v2  ; live: [a0, zero, v22]
  xori v3, v22, 1  ; live: [a0, zero, v3]
; control
  bne v3, zero, .odd_b1  ; live: [a0, zero]
  j .odd_b2  ; live: [a0, zero]

; block info: defs: [t1, ft0, ft1, a1, t5, fa1, fa2, ft6, v20, a4, fa6, a6, ft5, ft10, v4, ft7, v11, ft4, v5, ft9, a5, a0, fa4, ft2, a2, a3, ft8, t3, a7, fa7, t0, fa5, fa3, ft3, fa0, t4, t2], uses: [v4, v5, a0, v20, v2], upward_exposed: [v2], params_defs: []
; live_in: [v2], live_out: [v11]
; block parameters: []
.odd_b2:
  li v20, 1  ; live: [v20, v2]
  add v4, v2, v20  ; live: [v4, v2]
  mv a0, v4  ; live: [a0, v2]
  call even  ; live: [a0, v2]
  mv v5, a0  ; live: [v5, v2]
; control
  mv v11, v5  ; live: [v2]
  j .odd_b6  ; live: [v2]

; block info: defs: [v17, v6], uses: [v17, v6, zero, v2], upward_exposed: [zero, v2], params_defs: []
; live_in: [zero, v2], live_out: [v2]
; block parameters: []
.odd_b1:
  xor v17, v2, zero  ; live: [v17, zero, v2]
  sltiu v6, v17, 1  ; live: [v6, zero, v2]
; control
  bne v6, zero, .odd_b3  ; live: [zero, v2]
  j .odd_b4  ; live: [zero, v2]

; block info: defs: [t1, v7, ft0, ft1, a1, t5, fa1, fa2, ft6, a4, fa6, v8, a6, ft10, ft5, ft7, ft4, ft9, v10, a5, fa4, a0, ft2, a2, a3, ft8, t3, a7, fa7, t0, fa5, fa3, ft3, fa0, t4, t2, v15], uses: [v7, v8, v15, a0, v2], upward_exposed: [v2], params_defs: []
; live_in: [v2], live_out: [v10]
; block parameters: []
.odd_b4:
  li v15, 1  ; live: [v15, v2]
  sub v7, v2, v15  ; live: [v7, v2]
  mv a0, v7  ; live: [a0, v2]
  call even  ; live: [a0, v2]
  mv v8, a0  ; live: [v8, v2]
; control
  mv v10, v8  ; live: [v2]
  j .odd_b5  ; live: [v2]

; block info: defs: [a0], uses: [v11, a0], upward_exposed: [v11], params_defs: [v11]
; live_in: [v11], live_out: []
; block parameters: [v11]
.odd_b6:
; control
  mv a0, v11  ; live: [v11, a0]
  ret  ; live: [v11]

; block info: defs: [v11], uses: [v10], upward_exposed: [v10], params_defs: [v10]
; live_in: [v10], live_out: [v11]
; block parameters: [v10]
.odd_b5:
; control
  mv v11, v10  ; live: [v10]
  j .odd_b6  ; live: [v10]

; block info: defs: [v12, v10, v9], uses: [v12, v9], upward_exposed: [], params_defs: []
; live_in: [], live_out: [v10]
; block parameters: []
.odd_b3:
  la v12, f.2  ; live: [v12]
  lw v9, 0(v12)  ; live: [v9]
; control
  mv v10, v9  ; live: []
  j .odd_b5  ; live: []

  .p2align 3
  .globl _start
  .type _start, @function
_start:
; block info: defs: [t1, ft0, ft1, a1, t5, fa1, fa2, ft6, a4, fa6, t6, a6, ft10, ft5, ft7, ft4, ft9, a5, a0, fa4, ft2, a2, a3, ft8, t3, a7, fa7, t0, fa5, fa3, ft3, fa0, t4, t2], uses: [a0, t6], upward_exposed: [], params_defs: []
; live_in: [], live_out: []
; block parameters: []
_start_b0:
  call thunk_t.1  ; live: [a0]
  la t6, t.1  ; live: [a0, t6]
  sw a0, 0(t6)  ; live: []
  call thunk_f.2  ; live: [a0]
  la t6, f.2  ; live: [a0, t6]
  sw a0, 0(t6)  ; live: []
  call thunk_start  ; live: [a0]
; control
  ret  ; live: []

  .p2align 3
  .globl thunk_start
  .type thunk_start, @function
thunk_start:
; block info: defs: [t1, ft0, ft1, a1, t5, fa1, fa2, ft6, a4, fa6, a6, ft5, ft10, ft7, ft4, ft9, a5, a0, fa4, ft2, a2, a3, ft8, t3, a7, fa7, t0, fa5, fa3, ft3, fa0, t4, t2, v2], uses: [zero, a0, v2], upward_exposed: [zero], params_defs: []
; live_in: [zero], live_out: []
; block parameters: []
.thunk_start_b0:
  call main  ; live: [zero]
  mv v2, zero  ; live: [zero, v2]
; control
  mv a0, v2  ; live: [zero, a0]
  ret  ; live: [zero]

  .p2align 3
  .globl thunk_t.1
  .type thunk_t.1, @function
thunk_t.1:
; block info: defs: [a0, v2], uses: [a0, v2], upward_exposed: [], params_defs: []
; live_in: [], live_out: []
; block parameters: []
.thunk_t.1_b0:
; control
  li v2, 123  ; live: [v2]
  mv a0, v2  ; live: [a0]
  ret  ; live: []

  .p2align 3
  .globl thunk_f.2
  .type thunk_f.2, @function
thunk_f.2:
; block info: defs: [a0, v2], uses: [a0, v2], upward_exposed: [], params_defs: []
; live_in: [], live_out: []
; block parameters: []
.thunk_f.2_b0:
; control
  li v2, 456  ; live: [v2]
  mv a0, v2  ; live: [a0]
  ret  ; live: []

  .p2align 3
  .globl t.1
  .type t.1, @object
t.1:
  .zero 4
  .p2align 3
  .globl f.2
  .type f.2, @object
f.2:
  .zero 4
  .p2align 3
  .globl start
  .type start, @object
start:
  .zero 4



Testing test/test_src/fib.mbt
# name conventions used in the core ir:
# - functions: f<id>
# - blocks: b<id>
# - instructions: %<id>
# - memory: m<id>
# - free variables: ^<id>
# - function parameters: $f<pid>
# - block parameters: $b<bid>.<pid>
.core
.fn fib #f0 : fn(int32) -> int32
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: bool = le($f0, 1)
    br %0 b1() b2()
  }
  .bb #b1 () {
    jump b3($f0)
  }
  .bb #b2 () {
    let %1: int32 = sub($f0, 1)
    let %2: int32 = call f0(%1)
    let %3: int32 = sub($f0, 2)
    let %4: int32 = call f0(%3)
    let %5: int32 = add(%2, %4)
    jump b3(%5)
  }
  .bb #b3 (int32) {
    return $b3.0
  }
}
.fn thunk_start #f2 : fn() -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: unit = call f1()
    return %0
  }
}
.fn main #f1 : fn() -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: int32 = call f0(30)
    let %1: unit = ext_call minimbt_print_int(%0)
    return %1
  }
}
.thunk ::0 start

  .p2align 3
  .globl _start
  .type _start, @function
_start:
; block info: defs: [t1, ft0, ft1, a1, t5, fa1, fa2, ft6, a4, fa6, a6, ft5, ft10, ft7, ft4, ft9, a5, a0, fa4, ft2, a2, a3, ft8, t3, a7, fa7, t0, fa5, fa3, ft3, fa0, t4, t2], uses: [a0], upward_exposed: [], params_defs: []
; live_in: [], live_out: []
; block parameters: []
_start_b0:
  call thunk_start  ; live: [a0]
; control
  ret  ; live: []

  .p2align 3
  .globl fib
  .type fib, @function
fib:
; block info: defs: [v3, v17, v18, v2], uses: [v3, v17, v18, a0, zero, v2], upward_exposed: [a0, zero], params_defs: []
; live_in: [a0, zero], live_out: [v2]
; block parameters: []
.fib_b0:
  mv v2, a0  ; live: [a0, zero, v2]
  li v17, 1  ; live: [v17, a0, zero, v2]
  slt v18, v2, v17  ; live: [v18, a0, zero]
  xori v3, v18, 1  ; live: [a0, zero, v3]
; control
  bne v3, zero, .fib_b1  ; live: [a0, zero]
  j .fib_b2  ; live: [a0, zero]

; block info: defs: [a0], uses: [v9, a0], upward_exposed: [v9], params_defs: [v9]
; live_in: [v9], live_out: []
; block parameters: [v9]
.fib_b3:
; control
  mv a0, v9  ; live: [v9, a0]
  ret  ; live: [v9]

; block info: defs: [t1, v7, ft0, ft1, a1, v12, t5, fa1, fa2, ft6, a4, fa6, v8, a6, ft5, ft10, v4, v6, ft7, ft4, v5, ft9, a5, a0, fa4, ft2, a2, a3, v9, ft8, t3, a7, fa7, t0, fa5, fa3, ft3, fa0, t4, t2, v15], uses: [v5, a0, v7, v8, v4, v6, v15, v12, v2], upward_exposed: [v2], params_defs: []
; live_in: [v2], live_out: [v9]
; block parameters: []
.fib_b2:
  li v15, 1  ; live: [v15, v2]
  sub v4, v2, v15  ; live: [v4, v2]
  mv a0, v4  ; live: [a0, v2]
  call fib  ; live: [a0, v2]
  mv v5, a0  ; live: [v5, v2]
  li v12, 2  ; live: [v5, v12, v2]
  sub v6, v2, v12  ; live: [v5, v6, v2]
  mv a0, v6  ; live: [v5, a0, v2]
  call fib  ; live: [v5, a0, v2]
  mv v7, a0  ; live: [v7, v5, v2]
  add v8, v5, v7  ; live: [v8, v2]
; control
  mv v9, v8  ; live: [v2]
  j .fib_b3  ; live: [v2]

; block info: defs: [v9], uses: [v2], upward_exposed: [v2], params_defs: []
; live_in: [v2], live_out: [v9]
; block parameters: []
.fib_b1:
; control
  mv v9, v2  ; live: [v2]
  j .fib_b3  ; live: [v2]

  .p2align 3
  .globl thunk_start
  .type thunk_start, @function
thunk_start:
; block info: defs: [t1, ft0, ft1, a1, t5, fa1, fa2, ft6, a4, fa6, a6, ft5, ft10, ft7, ft4, ft9, a5, a0, fa4, ft2, a2, a3, ft8, t3, a7, fa7, t0, fa5, fa3, ft3, fa0, t4, t2, v2], uses: [zero, a0, v2], upward_exposed: [zero], params_defs: []
; live_in: [zero], live_out: []
; block parameters: []
.thunk_start_b0:
  call main  ; live: [zero]
  mv v2, zero  ; live: [zero, v2]
; control
  mv a0, v2  ; live: [zero, a0]
  ret  ; live: [zero]

  .p2align 3
  .globl main
  .type main, @function
main:
; block info: defs: [v3, t1, ft0, ft1, a1, t5, fa1, fa2, ft6, a4, fa6, a6, ft5, ft10, ft7, ft4, v5, ft9, a5, a0, fa4, ft2, a2, a3, ft8, t3, a7, fa7, t0, fa5, fa3, ft3, fa0, t4, t2, v2], uses: [v3, v5, a0, zero, v2], upward_exposed: [zero], params_defs: []
; live_in: [zero], live_out: []
; block parameters: []
.main_b0:
  li v5, 30  ; live: [v5, zero]
  mv a0, v5  ; live: [zero, a0]
  call fib  ; live: [zero, a0]
  mv v2, a0  ; live: [zero, v2]
  mv a0, v2  ; live: [zero, a0]
  call minimbt_print_int  ; live: [zero]
  mv v3, zero  ; live: [zero, v3]
; control
  mv a0, v3  ; live: [zero, a0]
  ret  ; live: [zero]

  .p2align 3
  .globl start
  .type start, @object
start:
  .zero 4



Testing test/test_src/float.mbt
# name conventions used in the core ir:
# - functions: f<id>
# - blocks: b<id>
# - instructions: %<id>
# - memory: m<id>
# - free variables: ^<id>
# - function parameters: $f<pid>
# - block parameters: $b<bid>.<pid>
.core
.fn thunk_start #f1 : fn() -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: unit = call f0()
    return %0
  }
}
.fn main #f0 : fn() -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: double = neg(12.3)
    let %1: double = abs(%0)
    let %2: double = sqrt(%1)
    let %3: double = ext_call minimbt_cos(%2)
    let %4: double = ext_call minimbt_sin(%3)
    let %5: double = add(%4, 4.5)
    let %6: double = mul(6.7, 8.9)
    let %7: double = div(%6, 1.23456789)
    let %8: double = sub(%5, %7)
    let %9: double = conv.i2d(1000000)
    let %10: double = mul(%8, %9)
    let %11: int32 = conv.d2i.rtz(%10)
    let %12: unit = ext_call minimbt_print_int(%11)
    return %12
  }
}
.thunk ::0 start

  .p2align 3
  .globl _start
  .type _start, @function
_start:
; block info: defs: [t1, ft0, ft1, a1, t5, fa1, fa2, ft6, a4, fa6, a6, ft5, ft10, ft7, ft4, ft9, a5, a0, fa4, ft2, a2, a3, ft8, t3, a7, fa7, t0, fa5, fa3, ft3, fa0, t4, t2], uses: [a0], upward_exposed: [], params_defs: []
; live_in: [], live_out: []
; block parameters: []
_start_b0:
  call thunk_start  ; live: [a0]
; control
  ret  ; live: []

  .p2align 3
  .globl thunk_start
  .type thunk_start, @function
thunk_start:
; block info: defs: [t1, ft0, ft1, a1, t5, fa1, fa2, ft6, a4, fa6, a6, ft5, ft10, ft7, ft4, ft9, a5, a0, fa4, ft2, a2, a3, ft8, t3, a7, fa7, t0, fa5, fa3, ft3, fa0, t4, t2, v2], uses: [zero, a0, v2], upward_exposed: [zero], params_defs: []
; live_in: [zero], live_out: []
; block parameters: []
.thunk_start_b0:
  call main  ; live: [zero]
  mv v2, zero  ; live: [zero, v2]
; control
  mv a0, v2  ; live: [zero, a0]
  ret  ; live: [zero]

  .p2align 3
  .globl main
  .type main, @function
main:
; block info: defs: [fv30, fv12, a1, t5, fa1, fv2, fa2, ft6, fv25, a4, fa6, a6, ft5, ft10, fv27, fv3, fv37, ft4, ft9, fa4, ft2, a3, a7, fa7, fa3, fv11, ft3, t2, fv7, t1, fv10, v14, v26, v13, ft0, ft1, fv5, fv22, v29, ft7, v21, a5, a0, fv8, v36, a2, fv4, v24, fv6, ft8, t3, fv9, t0, fa5, v18, fa0, t4], uses: [fv10, v14, v26, v13, fv30, fv12, fv5, fv22, fv2, v29, fv25, zero, fv27, fv3, fv37, v21, a0, fv8, v36, fv4, v24, fv6, fv9, v18, fv11, fa0, fv7], upward_exposed: [zero], params_defs: []
; live_in: [zero], live_out: []
; block parameters: []
.main_b0:
  li v36, 4623113902481840538  ; live: [zero, v36]
  fmv.d.x fv37, v36  ; live: [fv37, zero]
  fneg.d fv2, fv37  ; live: [fv2, zero]
  fabs.d fv3, fv2  ; live: [zero, fv3]
  fsqrt.d fv4, fv3  ; live: [fv4, zero]
  fmv.d fa0, fv4  ; live: [zero, fa0]
  call minimbt_cos  ; live: [zero, fa0]
  fmv.d fv5, fa0  ; live: [fv5, zero]
  fmv.d fa0, fv5  ; live: [zero, fa0]
  call minimbt_sin  ; live: [zero, fa0]
  fmv.d fv6, fa0  ; live: [fv6, zero]
  li v29, 4616752568008179712  ; live: [fv6, zero, v29]
  fmv.d.x fv30, v29  ; live: [fv6, zero, fv30]
  fadd.d fv7, fv6, fv30  ; live: [zero, fv7]
  li v24, 4619229547803233485  ; live: [v24, zero, fv7]
  fmv.d.x fv25, v24  ; live: [zero, fv25, fv7]
  li v26, 4621199872640208077  ; live: [fv7, zero, fv25, v26]
  fmv.d.x fv27, v26  ; live: [fv27, zero, fv25, fv7]
  fmul.d fv8, fv25, fv27  ; live: [zero, fv7, fv8]
  li v21, 4608238818662014491  ; live: [v21, zero, fv7, fv8]
  fmv.d.x fv22, v21  ; live: [fv22, zero, fv7, fv8]
  fdiv.d fv9, fv8, fv22  ; live: [fv9, zero, fv7]
  fsub.d fv10, fv7, fv9  ; live: [fv10, zero]
  li v18, 1000000  ; live: [fv10, v18, zero]
  fcvt.d.w fv11, v18  ; live: [fv10, zero, fv11]
  fmul.d fv12, fv10, fv11  ; live: [fv12, zero]
  fcvt.w.d v13, fv12, rtz  ; live: [zero, v13]
  mv a0, v13  ; live: [zero, a0]
  call minimbt_print_int  ; live: [zero]
  mv v14, zero  ; live: [v14, zero]
; control
  mv a0, v14  ; live: [zero, a0]
  ret  ; live: [zero]

  .p2align 3
  .globl start
  .type start, @object
start:
  .zero 4



Testing test/test_src/funcomp.mbt
# name conventions used in the core ir:
# - functions: f<id>
# - blocks: b<id>
# - instructions: %<id>
# - memory: m<id>
# - free variables: ^<id>
# - function parameters: $f<pid>
# - block parameters: $b<bid>.<pid>
.core
.fn thunk_start #f6 : fn() -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: unit = call f5()
    return %0
  }
}
.fn compose #f0 : fn(closure(int32) -> int32, closure(int32) -> int32) -> closure(int32) -> int32
.freevars ()
.entry b0 {
  .bb #b0 () {
    let _ = alloc <m0: closure(int32) -> int32 heap(3)> <- [0] = f1, [1] = $f0, [2] = $f1
    return f0.m0
  }
}
.fn dec #f4 : fn(int32) -> int32
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: int32 = sub($f0, 1)
    return %0
  }
}
.fn dbl #f2 : fn(int32) -> int32
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: int32 = add($f0, $f0)
    return %0
  }
}
.fn composed #f1 : closure(int32) -> int32
.freevars (closure(int32) -> int32, closure(int32) -> int32)
.entry b0 {
  .bb #b0 () {
    let %0: int32 = apply ^1($f0)
    let %1: int32 = apply ^2(%0)
    return %1
  }
}
.fn inc #f3 : fn(int32) -> int32
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: int32 = add($f0, 1)
    return %0
  }
}
.fn main #f5 : fn() -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let _ = alloc <m0: closure(int32) -> int32 heap(1)> <- [0] = f2
    let _ = alloc <m1: closure(int32) -> int32 heap(1)> <- [0] = f4
    let %2: closure(int32) -> int32 = call f0(f5.m0, f5.m1)
    let _ = alloc <m2: closure(int32) -> int32 heap(1)> <- [0] = f3
    let %4: closure(int32) -> int32 = call f0(f5.m2, %2)
    let %5: int32 = apply %4(123)
    let %6: unit = ext_call minimbt_print_int(%5)
    return %6
  }
}
.thunk ::0 start

  .p2align 3
  .globl _start
  .type _start, @function
_start:
; block info: defs: [t1, ft0, ft1, a1, t5, fa1, fa2, ft6, a4, fa6, a6, ft5, ft10, ft7, ft4, ft9, a5, a0, fa4, ft2, a2, a3, ft8, t3, a7, fa7, t0, fa5, fa3, ft3, fa0, t4, t2], uses: [a0], upward_exposed: [], params_defs: []
; live_in: [], live_out: []
; block parameters: []
_start_b0:
  call thunk_start  ; live: [a0]
; control
  ret  ; live: []

  .p2align 3
  .globl thunk_start
  .type thunk_start, @function
thunk_start:
; block info: defs: [t1, ft0, ft1, a1, t5, fa1, fa2, ft6, a4, fa6, a6, ft5, ft10, ft7, ft4, ft9, a5, a0, fa4, ft2, a2, a3, ft8, t3, a7, fa7, t0, fa5, fa3, ft3, fa0, t4, t2, v2], uses: [zero, a0, v2], upward_exposed: [zero], params_defs: []
; live_in: [zero], live_out: []
; block parameters: []
.thunk_start_b0:
  call main  ; live: [zero]
  mv v2, zero  ; live: [zero, v2]
; control
  mv a0, v2  ; live: [zero, a0]
  ret  ; live: [zero]

  .p2align 3
  .globl dec
  .type dec, @function
dec:
; block info: defs: [v3, v4, a0, v2], uses: [v3, v4, a0, v2], upward_exposed: [a0], params_defs: []
; live_in: [a0], live_out: []
; block parameters: []
.dec_b0:
  mv v2, a0  ; live: [v2]
  li v4, 1  ; live: [v4, v2]
  sub v3, v2, v4  ; live: [v3]
; control
  mv a0, v3  ; live: [a0]
  ret  ; live: [a0]

  .p2align 3
  .globl compose
  .type compose, @function
compose:
; block info: defs: [v3, v8, v4, v6, a0, v2], uses: [v3, a0, v8, v4, a1, v6, s11, v2], upward_exposed: [a1, s11, a0], params_defs: []
; live_in: [a1, s11, a0], live_out: []
; block parameters: []
.compose_b0:
  mv v2, a0  ; live: [a1, s11, v2]
  mv v3, a1  ; live: [v3, a1, s11, v2]
  addi v6, s11, -24  ; live: [v3, a1, v6, s11, v2]
  andi v4, v6, -8  ; live: [v3, v4, a1, s11, v2]
  la v8, composed  ; live: [v3, v8, v4, a1, s11, v2]
  sd v8, 0(v4)  ; live: [v2, v4, a1, s11, v3]
  sd v2, 8(v4)  ; live: [v4, a1, s11, v3]
  sd v3, 16(v4)  ; live: [v4, a1, s11]
; control
  mv a0, v4  ; live: [a1, s11, a0]
  ret  ; live: [a1, s11, a0]

  .p2align 3
  .globl dbl
  .type dbl, @function
dbl:
; block info: defs: [v3, a0, v2], uses: [v3, a0, v2], upward_exposed: [a0], params_defs: []
; live_in: [a0], live_out: []
; block parameters: []
.dbl_b0:
  mv v2, a0  ; live: [v2]
  add v3, v2, v2  ; live: [v3]
; control
  mv a0, v3  ; live: [a0]
  ret  ; live: [a0]

  .p2align 3
  .globl composed
  .type composed, @function
composed:
; block info: defs: [v2, t1, v7, v0, ft0, ft1, a1, t5, fa1, fa2, ft6, a4, fa6, a6, v4, ft5, ft10, v6, ft7, ft4, v5, ft9, a5, a0, fa4, ft2, a2, a3, v9, s10, ft8, t3, a7, fa7, t0, fa5, fa3, ft3, fa0, t4, t2, v3], uses: [v3, v5, a0, v0, v4, v6, s10, v2], upward_exposed: [s10, a0], params_defs: []
; live_in: [s10, a0], live_out: []
; block parameters: []
.composed_b0:
  mv v0, s10  ; live: [v0, a0]
  mv v2, a0  ; live: [v0, v2]
  lw v3, 8(v0)  ; live: [v3, v0, v2]
  lw v4, 16(v0)  ; live: [v3, v4, v2]
  mv s10, v3  ; live: [v3, v4, v2]
  ld v9, 0(v3)  ; live: [v4, v2]
  mv a0, v2  ; live: [v4, a0]
  jalr v9  ; live: [v4, a0]
  mv v5, a0  ; live: [v4, v5]
  mv s10, v4  ; live: [v4, v5, s10]
  ld v7, 0(v4)  ; live: [v5, s10]
  mv a0, v5  ; live: [s10, a0]
  jalr v7  ; live: [s10, a0]
  mv v6, a0  ; live: [v6, s10]
; control
  mv a0, v6  ; live: [s10, a0]
  ret  ; live: [s10, a0]

  .p2align 3
  .globl inc
  .type inc, @function
inc:
; block info: defs: [v3, v4, a0, v2], uses: [v3, v4, a0, v2], upward_exposed: [a0], params_defs: []
; live_in: [a0], live_out: []
; block parameters: []
.inc_b0:
  mv v2, a0  ; live: [v2]
  li v4, 1  ; live: [v4, v2]
  add v3, v2, v4  ; live: [v3]
; control
  mv a0, v3  ; live: [a0]
  ret  ; live: [a0]

  .p2align 3
  .globl main
  .type main, @function
main:
; block info: defs: [v2, t1, v14, v26, v13, v7, ft0, ft1, a1, t5, fa1, fa2, ft6, a4, fa6, a6, v19, ft10, v4, ft5, ft7, v11, ft4, v21, ft9, v10, a5, fa4, a0, ft2, a2, v17, a3, v24, s10, v9, ft8, a7, fa7, t3, t0, fa5, fa3, ft3, v23, fa0, t4, t2, v3], uses: [v2, v11, v14, v21, v10, v26, a0, v7, v17, a1, s11, v24, v9, zero, v23, v19, v4, v3], upward_exposed: [s11, zero], params_defs: []
; live_in: [s11, zero], live_out: []
; block parameters: []
.main_b0:
  addi v24, s11, -8  ; live: [s11, v24, zero]
  andi v2, v24, -8  ; live: [s11, zero, v2]
  la v26, dbl  ; live: [s11, zero, v26, v2]
  sd v26, 0(v2)  ; live: [s11, zero, v2]
  addi v21, s11, -8  ; live: [s11, v21, zero, v2]
  andi v3, v21, -8  ; live: [v2, s11, zero, v3]
  la v23, dec  ; live: [v2, s11, zero, v23, v3]
  sd v23, 0(v3)  ; live: [v2, s11, zero, v3]
  mv a0, v2  ; live: [s11, zero, a0, v3]
  mv a1, v3  ; live: [a1, s11, zero, a0]
  call compose  ; live: [s11, zero, a0]
  mv v7, a0  ; live: [s11, zero, v7]
  addi v17, s11, -8  ; live: [v17, s11, zero, v7]
  andi v4, v17, -8  ; live: [v4, s11, zero, v7]
  la v19, inc  ; live: [v19, v4, s11, zero, v7]
  sd v19, 0(v4)  ; live: [v4, s11, zero, v7]
  mv a0, v4  ; live: [s11, zero, a0, v7]
  mv a1, v7  ; live: [a1, s11, zero, a0]
  call compose  ; live: [s11, zero, a0]
  mv v9, a0  ; live: [s11, zero, v9]
  mv s10, v9  ; live: [s11, zero, v9]
  ld v13, 0(v9)  ; live: [s11, zero]
  li v14, 123  ; live: [v14, s11, zero]
  mv a0, v14  ; live: [s11, zero, a0]
  jalr v13  ; live: [s11, zero, a0]
  mv v10, a0  ; live: [s11, v10, zero]
  mv a0, v10  ; live: [s11, zero, a0]
  call minimbt_print_int  ; live: [s11, zero]
  mv v11, zero  ; live: [v11, s11, zero]
; control
  mv a0, v11  ; live: [s11, zero, a0]
  ret  ; live: [s11, zero]

  .p2align 3
  .globl start
  .type start, @object
start:
  .zero 4



Testing test/test_src/gcd.mbt
# name conventions used in the core ir:
# - functions: f<id>
# - blocks: b<id>
# - instructions: %<id>
# - memory: m<id>
# - free variables: ^<id>
# - function parameters: $f<pid>
# - block parameters: $b<bid>.<pid>
.core
.fn gcd #f0 : fn(int32, int32) -> int32
.freevars ()
.entry b0 {
  .bb #b6 (int32) {
    return $b6.0
  }
  .bb #b4 () {
    let %4: int32 = sub($f0, $f1)
    let %5: int32 = call f0($f1, %4)
    jump b5(%5)
  }
  .bb #b1 () {
    jump b6($f1)
  }
  .bb #b5 (int32) {
    jump b6($b5.0)
  }
  .bb #b2 () {
    let %1: bool = le($f0, $f1)
    br %1 b3() b4()
  }
  .bb #b3 () {
    let %2: int32 = sub($f1, $f0)
    let %3: int32 = call f0($f0, %2)
    jump b5(%3)
  }
  .bb #b0 () {
    let %0: bool = eq($f0, 0)
    br %0 b1() b2()
  }
}
.fn thunk_start #f2 : fn() -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: unit = call f1()
    return %0
  }
}
.fn main #f1 : fn() -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: int32 = call f0(21600, 337500)
    let %1: unit = ext_call minimbt_print_int(%0)
    return %1
  }
}
.thunk ::0 start

  .p2align 3
  .globl _start
  .type _start, @function
_start:
; block info: defs: [t1, ft0, ft1, a1, t5, fa1, fa2, ft6, a4, fa6, a6, ft5, ft10, ft7, ft4, ft9, a5, a0, fa4, ft2, a2, a3, ft8, t3, a7, fa7, t0, fa5, fa3, ft3, fa0, t4, t2], uses: [a0], upward_exposed: [], params_defs: []
; live_in: [], live_out: []
; block parameters: []
_start_b0:
  call thunk_start  ; live: [a0]
; control
  ret  ; live: []

  .p2align 3
  .globl gcd
  .type gcd, @function
gcd:
; block info: defs: [v3, v4, v18, v2], uses: [v18, a0, zero, v4, a1, v2], upward_exposed: [a1, a0, zero], params_defs: []
; live_in: [a1, a0, zero], live_out: [v2, zero, v3]
; block parameters: []
.gcd_b0:
  mv v2, a0  ; live: [a1, a0, zero, v2]
  mv v3, a1  ; live: [a1, a0, zero, v2]
  xor v18, v2, zero  ; live: [a1, v18, a0, zero]
  sltiu v4, v18, 1  ; live: [v4, a1, a0, zero]
; control
  bne v4, zero, .gcd_b1  ; live: [a1, a0, zero]
  j .gcd_b2  ; live: [a1, a0, zero]

; block info: defs: [a0], uses: [v11, a0], upward_exposed: [v11], params_defs: [v11]
; live_in: [v11], live_out: []
; block parameters: [v11]
.gcd_b6:
; control
  mv a0, v11  ; live: [v11, a0]
  ret  ; live: [v11]

; block info: defs: [v11], uses: [v3], upward_exposed: [v3], params_defs: []
; live_in: [v3], live_out: [v11]
; block parameters: []
.gcd_b1:
; control
  mv v11, v3  ; live: [v3]
  j .gcd_b6  ; live: [v3]

; block info: defs: [t1, v7, ft0, ft1, a1, t5, fa1, fa2, ft6, a4, fa6, a6, ft5, ft10, v6, ft7, ft4, ft9, v10, a5, fa4, a0, ft2, a2, a3, ft8, t3, a7, fa7, t0, fa5, fa3, ft3, fa0, t4, t2], uses: [v3, v7, v6, a1, a0, v2], upward_exposed: [v3, v2], params_defs: []
; live_in: [v2, v3], live_out: [v10]
; block parameters: []
.gcd_b4:
  sub v6, v2, v3  ; live: [v3, v6, v2]
  mv a0, v3  ; live: [v3, v6, a0, v2]
  mv a1, v6  ; live: [v3, a1, a0, v2]
  call gcd  ; live: [v3, a0, v2]
  mv v7, a0  ; live: [v3, v7, v2]
; control
  mv v10, v7  ; live: [v3, v2]
  j .gcd_b5  ; live: [v3, v2]

; block info: defs: [t1, ft0, ft1, a1, t5, fa1, fa2, ft6, a4, fa6, v8, a6, ft10, ft5, ft7, ft4, ft9, v10, a5, fa4, a0, ft2, a2, a3, v9, ft8, t3, a7, fa7, t0, fa5, fa3, ft3, fa0, t4, t2], uses: [v2, v8, a1, a0, v9, v3], upward_exposed: [v2, v3], params_defs: []
; live_in: [v3, v2], live_out: [v10]
; block parameters: []
.gcd_b3:
  sub v8, v3, v2  ; live: [v2, v8, v3]
  mv a0, v2  ; live: [v2, v8, a0, v3]
  mv a1, v8  ; live: [v2, a1, a0, v3]
  call gcd  ; live: [v2, a0, v3]
  mv v9, a0  ; live: [v2, v9, v3]
; control
  mv v10, v9  ; live: [v2, v3]
  j .gcd_b5  ; live: [v2, v3]

; block info: defs: [v16, v5], uses: [v3, v16, v5, zero, v2], upward_exposed: [v3, zero, v2], params_defs: []
; live_in: [v2, zero, v3], live_out: [v2, v3]
; block parameters: []
.gcd_b2:
  slt v16, v2, v3  ; live: [v3, v16, zero, v2]
  xori v5, v16, 1  ; live: [v3, v5, zero, v2]
; control
  bne v5, zero, .gcd_b3  ; live: [v3, zero, v2]
  j .gcd_b4  ; live: [v3, zero, v2]

; block info: defs: [v11], uses: [v10], upward_exposed: [v10], params_defs: [v10]
; live_in: [v10], live_out: [v11]
; block parameters: [v10]
.gcd_b5:
; control
  mv v11, v10  ; live: [v10]
  j .gcd_b6  ; live: [v10]

  .p2align 3
  .globl thunk_start
  .type thunk_start, @function
thunk_start:
; block info: defs: [t1, ft0, ft1, a1, t5, fa1, fa2, ft6, a4, fa6, a6, ft5, ft10, ft7, ft4, ft9, a5, a0, fa4, ft2, a2, a3, ft8, t3, a7, fa7, t0, fa5, fa3, ft3, fa0, t4, t2, v2], uses: [zero, a0, v2], upward_exposed: [zero], params_defs: []
; live_in: [zero], live_out: []
; block parameters: []
.thunk_start_b0:
  call main  ; live: [zero]
  mv v2, zero  ; live: [zero, v2]
; control
  mv a0, v2  ; live: [zero, a0]
  ret  ; live: [zero]

  .p2align 3
  .globl main
  .type main, @function
main:
; block info: defs: [v3, t1, ft0, ft1, a1, t5, fa1, fa2, ft6, a4, fa6, a6, ft5, ft10, v6, ft7, ft4, v5, ft9, a5, a0, fa4, ft2, a2, a3, ft8, t3, a7, fa7, t0, fa5, fa3, ft3, fa0, t4, t2, v2], uses: [v3, v5, a0, zero, v6, a1, v2], upward_exposed: [zero], params_defs: []
; live_in: [zero], live_out: []
; block parameters: []
.main_b0:
  li v5, 21600  ; live: [v5, zero]
  mv a0, v5  ; live: [zero, a0]
  li v6, 337500  ; live: [v6, zero, a0]
  mv a1, v6  ; live: [a1, zero, a0]
  call gcd  ; live: [zero, a0]
  mv v2, a0  ; live: [zero, v2]
  mv a0, v2  ; live: [zero, a0]
  call minimbt_print_int  ; live: [zero]
  mv v3, zero  ; live: [zero, v3]
; control
  mv a0, v3  ; live: [zero, a0]
  ret  ; live: [zero]

  .p2align 3
  .globl start
  .type start, @object
start:
  .zero 4



Testing test/test_src/id.mbt
# name conventions used in the core ir:
# - functions: f<id>
# - blocks: b<id>
# - instructions: %<id>
# - memory: m<id>
# - free variables: ^<id>
# - function parameters: $f<pid>
# - block parameters: $b<bid>.<pid>
.core
.fn f #f0 : fn(int32) -> int32
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: int32 = add($f0, 1)
    return %0
  }
}
.fn thunk_start #f2 : fn() -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: unit = call f1()
    return %0
  }
}
.fn main #f1 : fn() -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: int32 = call f0(1000)
    let %1: unit = ext_call minimbt_print_int(%0)
    return %1
  }
}
.thunk ::0 start

  .p2align 3
  .globl _start
  .type _start, @function
_start:
; block info: defs: [t1, ft0, ft1, a1, t5, fa1, fa2, ft6, a4, fa6, a6, ft5, ft10, ft7, ft4, ft9, a5, a0, fa4, ft2, a2, a3, ft8, t3, a7, fa7, t0, fa5, fa3, ft3, fa0, t4, t2], uses: [a0], upward_exposed: [], params_defs: []
; live_in: [], live_out: []
; block parameters: []
_start_b0:
  call thunk_start  ; live: [a0]
; control
  ret  ; live: []

  .p2align 3
  .globl f
  .type f, @function
f:
; block info: defs: [v3, v4, a0, v2], uses: [v3, v4, a0, v2], upward_exposed: [a0], params_defs: []
; live_in: [a0], live_out: []
; block parameters: []
.f_b0:
  mv v2, a0  ; live: [v2]
  li v4, 1  ; live: [v4, v2]
  add v3, v2, v4  ; live: [v3]
; control
  mv a0, v3  ; live: [a0]
  ret  ; live: [a0]

  .p2align 3
  .globl thunk_start
  .type thunk_start, @function
thunk_start:
; block info: defs: [t1, ft0, ft1, a1, t5, fa1, fa2, ft6, a4, fa6, a6, ft5, ft10, ft7, ft4, ft9, a5, a0, fa4, ft2, a2, a3, ft8, t3, a7, fa7, t0, fa5, fa3, ft3, fa0, t4, t2, v2], uses: [zero, a0, v2], upward_exposed: [zero], params_defs: []
; live_in: [zero], live_out: []
; block parameters: []
.thunk_start_b0:
  call main  ; live: [zero]
  mv v2, zero  ; live: [zero, v2]
; control
  mv a0, v2  ; live: [zero, a0]
  ret  ; live: [zero]

  .p2align 3
  .globl main
  .type main, @function
main:
; block info: defs: [v3, t1, ft0, ft1, a1, t5, fa1, fa2, ft6, a4, fa6, a6, ft5, ft10, ft7, ft4, v5, ft9, a5, a0, fa4, ft2, a2, a3, ft8, t3, a7, fa7, t0, fa5, fa3, ft3, fa0, t4, t2, v2], uses: [v3, v5, a0, zero, v2], upward_exposed: [zero], params_defs: []
; live_in: [zero], live_out: []
; block parameters: []
.main_b0:
  li v5, 1000  ; live: [v5, zero]
  mv a0, v5  ; live: [zero, a0]
  call f  ; live: [zero, a0]
  mv v2, a0  ; live: [zero, v2]
  mv a0, v2  ; live: [zero, a0]
  call minimbt_print_int  ; live: [zero]
  mv v3, zero  ; live: [zero, v3]
; control
  mv a0, v3  ; live: [zero, a0]
  ret  ; live: [zero]

  .p2align 3
  .globl start
  .type start, @object
start:
  .zero 4



Testing test/test_src/inprod-loop.mbt
# name conventions used in the core ir:
# - functions: f<id>
# - blocks: b<id>
# - instructions: %<id>
# - memory: m<id>
# - free variables: ^<id>
# - function parameters: $f<pid>
# - block parameters: $b<bid>.<pid>
.core
.fn inprod #f0 : fn(array[double], array[double], double, int32) -> double
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: bool = le(0, $f3)
    br %0 b1() b2()
  }
  .bb #b1 () {
    let %1: double = load double offset($f0, $f3)
    let %2: double = load double offset($f1, $f3)
    let %3: double = mul(%1, %2)
    let %4: double = add($f2, %3)
    let %5: int32 = sub($f3, 1)
    let %6: double = call f0($f0, $f1, %4, %5)
    jump b3(%6)
  }
  .bb #b2 () {
    jump b3($f2)
  }
  .bb #b3 (double) {
    return $b3.0
  }
}
.fn thunk_start #f2 : fn() -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: unit = call f1()
    return %0
  }
}
.fn main #f1 : fn() -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let _ = alloc <m0: array[double] heap(3)> <- [..] = 1.23
    let _ = alloc <m1: array[double] heap(3)> <- [..] = 4.56
    let %2: double = call f0(f1.m0, f1.m1, 0, 2)
    let %3: double = mul(1000000, %2)
    let %4: int32 = ext_call minimbt_truncate(%3)
    let %5: unit = ext_call minimbt_print_int(%4)
    return %5
  }
}
.thunk ::0 start

  .p2align 3
  .globl _start
  .type _start, @function
_start:
; block info: defs: [t1, ft0, ft1, a1, t5, fa1, fa2, ft6, a4, fa6, a6, ft5, ft10, ft7, ft4, ft9, a5, a0, fa4, ft2, a2, a3, ft8, t3, a7, fa7, t0, fa5, fa3, ft3, fa0, t4, t2], uses: [a0], upward_exposed: [], params_defs: []
; live_in: [], live_out: []
; block parameters: []
_start_b0:
  call thunk_start  ; live: [a0]
; control
  ret  ; live: []

  .p2align 3
  .globl inprod
  .type inprod, @function
inprod:
; block info: defs: [v3, v25, fv4, v5, v6, v2], uses: [v25, v5, a0, zero, fa0, a2, a1, v6], upward_exposed: [a2, a1, a0, zero, fa0], params_defs: []
; live_in: [a2, a1, a0, zero, fa0], live_out: [v3, v5, fv4, v2]
; block parameters: []
.inprod_b0:
  mv v2, a0  ; live: [a0, zero, fa0, a2, a1]
  mv v3, a1  ; live: [a0, zero, fa0, a2, a1]
  fmv.d fv4, fa0  ; live: [a0, zero, fa0, a2, a1]
  mv v5, a2  ; live: [v5, a0, zero, fa0, a2, a1]
  slt v25, zero, v5  ; live: [v25, a0, zero, fa0, a2, a1]
  xori v6, v25, 1  ; live: [a0, zero, fa0, a2, a1, v6]
; control
  bne v6, zero, .inprod_b1  ; live: [a2, a1, a0, zero, fa0]
  j .inprod_b2  ; live: [a2, a1, a0, zero, fa0]

; block info: defs: [fv13], uses: [fv4], upward_exposed: [fv4], params_defs: []
; live_in: [fv4], live_out: [fv13]
; block parameters: []
.inprod_b2:
; control
  fmv.d fv13, fv4  ; live: [fv4]
  j .inprod_b3  ; live: [fv4]

; block info: defs: [fv10, t1, v22, ft0, ft1, fv12, a1, t5, fa1, fa2, ft6, v20, a4, fa6, a6, v19, ft10, ft5, ft7, v11, ft4, ft9, a5, a0, fa4, fv8, ft2, a2, a3, ft8, fv9, t3, a7, fa7, t0, fa5, fa3, ft3, v23, fa0, fv13, t4, t2, v15, fv7], uses: [v2, v11, fv10, v5, a0, v22, fv8, a2, fv12, a1, fv4, fv9, v23, v20, fa0, v19, v15, fv7, v3], upward_exposed: [v3, v5, fv4, v2], params_defs: []
; live_in: [v2, v5, fv4, v3], live_out: [fv13]
; block parameters: []
.inprod_b1:
  slli v22, v5, 3  ; live: [v2, v5, v22, fv4, v3]
  add v23, v2, v22  ; live: [v2, v5, v23, fv4, v3]
  fld fv7, 0(v23)  ; live: [v2, v5, fv4, fv7, v3]
  slli v19, v5, 3  ; live: [v2, v5, v19, fv4, fv7, v3]
  add v20, v3, v19  ; live: [v2, v5, v20, fv4, fv7, v3]
  fld fv8, 0(v20)  ; live: [v2, v5, fv8, fv4, fv7, v3]
  fmul.d fv9, fv7, fv8  ; live: [v2, fv9, v5, fv4, v3]
  fadd.d fv10, fv4, fv9  ; live: [v2, fv10, v5, fv4, v3]
  li v15, 1  ; live: [v2, fv10, v5, fv4, v15, v3]
  sub v11, v5, v15  ; live: [v2, v11, fv10, v5, fv4, v3]
  mv a0, v2  ; live: [v2, v11, fv10, v5, a0, fv4, v3]
  mv a1, v3  ; live: [v2, v11, fv10, v5, a0, fv4, a1, v3]
  fmv.d fa0, fv10  ; live: [v2, v11, v5, a0, fa0, fv4, a1, v3]
  mv a2, v11  ; live: [v2, v5, a0, fa0, a2, fv4, a1, v3]
  call inprod  ; live: [v3, fa0, v5, fv4, v2]
  fmv.d fv12, fa0  ; live: [v3, fv12, v5, fv4, v2]
; control
  fmv.d fv13, fv12  ; live: [v3, v5, fv4, v2]
  j .inprod_b3  ; live: [v3, v5, fv4, v2]

; block info: defs: [fa0], uses: [fa0, fv13], upward_exposed: [fv13], params_defs: [fv13]
; live_in: [fv13], live_out: []
; block parameters: [fv13]
.inprod_b3:
; control
  fmv.d fa0, fv13  ; live: [fa0, fv13]
  ret  ; live: [fv13]

  .p2align 3
  .globl thunk_start
  .type thunk_start, @function
thunk_start:
; block info: defs: [t1, ft0, ft1, a1, t5, fa1, fa2, ft6, a4, fa6, a6, ft5, ft10, ft7, ft4, ft9, a5, a0, fa4, ft2, a2, a3, ft8, t3, a7, fa7, t0, fa5, fa3, ft3, fa0, t4, t2, v2], uses: [zero, a0, v2], upward_exposed: [zero], params_defs: []
; live_in: [zero], live_out: []
; block parameters: []
.thunk_start_b0:
  call main  ; live: [zero]
  mv v2, zero  ; live: [zero, v2]
; control
  mv a0, v2  ; live: [zero, a0]
  ret  ; live: [zero]

  .p2align 3
  .globl main
  .type main, @function
main:
; block info: defs: [v2, t1, v16, v22, ft0, ft1, a1, v12, t5, fv15, fa1, fa2, fv25, ft6, a4, v20, fa6, v8, a6, ft5, ft10, fv21, ft7, ft4, ft9, a5, a0, fa4, ft2, a2, a3, v24, fv6, v9, ft8, t3, a7, fa7, t0, fa5, v18, fa3, ft3, fa0, fv13, t4, t2, fv7, v3], uses: [v2, v3, v16, a0, v22, a2, a1, s11, v24, v12, fv15, fv6, v9, v18, fv25, zero, v20, fa0, fv13, v8, fv21, fv7], upward_exposed: [s11, zero], params_defs: []
; live_in: [s11, zero], live_out: []
; block parameters: []
.main_b0:
  addi v22, s11, -24  ; live: [s11, zero, v22]
  andi v2, v22, -8  ; live: [s11, zero, v2]
  li v24, 4608218246714312622  ; live: [s11, v24, zero, v2]
  fmv.d.x fv25, v24  ; live: [s11, zero, fv25, v2]
  fsd fv25, 0(v2)  ; live: [s11, zero, fv25, v2]
  fsd fv25, 8(v2)  ; live: [s11, zero, fv25, v2]
  fsd fv25, 16(v2)  ; live: [s11, zero, v2]
  addi v18, s11, -24  ; live: [s11, v18, zero, v2]
  andi v3, v18, -8  ; live: [v2, s11, zero, v3]
  li v20, 4616820122002590269  ; live: [v2, s11, zero, v20, v3]
  fmv.d.x fv21, v20  ; live: [v2, s11, zero, fv21, v3]
  fsd fv21, 0(v3)  ; live: [v2, s11, zero, fv21, v3]
  fsd fv21, 8(v3)  ; live: [v2, s11, zero, fv21, v3]
  fsd fv21, 16(v3)  ; live: [v2, s11, zero, v3]
  mv a0, v2  ; live: [s11, zero, a0, v3]
  mv a1, v3  ; live: [a1, s11, zero, a0]
  fmv.d.x fv15, zero  ; live: [a1, s11, fv15, zero, a0]
  fmv.d fa0, fv15  ; live: [a1, s11, zero, a0, fa0]
  li v16, 2  ; live: [a1, v16, s11, zero, a0, fa0]
  mv a2, v16  ; live: [a2, a1, s11, zero, a0, fa0]
  call inprod  ; live: [s11, zero, fa0]
  fmv.d fv6, fa0  ; live: [s11, fv6, zero]
  li v12, 4696837146684686336  ; live: [s11, v12, fv6, zero]
  fmv.d.x fv13, v12  ; live: [s11, fv6, zero, fv13]
  fmul.d fv7, fv13, fv6  ; live: [s11, zero, fv7]
  fmv.d fa0, fv7  ; live: [s11, zero, fa0]
  call minimbt_truncate  ; live: [s11, zero, a0]
  mv v8, a0  ; live: [s11, zero, v8]
  mv a0, v8  ; live: [s11, zero, a0]
  call minimbt_print_int  ; live: [s11, zero]
  mv v9, zero  ; live: [s11, zero, v9]
; control
  mv a0, v9  ; live: [s11, zero, a0]
  ret  ; live: [s11, zero]

  .p2align 3
  .globl start
  .type start, @object
start:
  .zero 4



Testing test/test_src/inprod-rec.mbt
# name conventions used in the core ir:
# - functions: f<id>
# - blocks: b<id>
# - instructions: %<id>
# - memory: m<id>
# - free variables: ^<id>
# - function parameters: $f<pid>
# - block parameters: $b<bid>.<pid>
.core
.fn inprod #f0 : fn(array[double], array[double], int32) -> double
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: bool = le(0, $f2)
    br %0 b1() b2()
  }
  .bb #b1 () {
    let %1: double = load double offset($f0, $f2)
    let %2: double = load double offset($f1, $f2)
    let %3: double = mul(%1, %2)
    let %4: int32 = sub($f2, 1)
    let %5: double = call f0($f0, $f1, %4)
    let %6: double = add(%3, %5)
    jump b3(%6)
  }
  .bb #b2 () {
    jump b3(0)
  }
  .bb #b3 (double) {
    return $b3.0
  }
}
.fn thunk_start #f2 : fn() -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: unit = call f1()
    return %0
  }
}
.fn main #f1 : fn() -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let _ = alloc <m0: array[double] heap(3)> <- [..] = 1.23
    let _ = alloc <m1: array[double] heap(3)> <- [..] = 4.56
    let %2: double = call f0(f1.m0, f1.m1, 2)
    let %3: double = mul(1000000, %2)
    let %4: int32 = ext_call minimbt_truncate(%3)
    let %5: unit = ext_call minimbt_print_int(%4)
    return %5
  }
}
.thunk ::0 start

  .p2align 3
  .globl _start
  .type _start, @function
_start:
; block info: defs: [t1, ft0, ft1, a1, t5, fa1, fa2, ft6, a4, fa6, a6, ft5, ft10, ft7, ft4, ft9, a5, a0, fa4, ft2, a2, a3, ft8, t3, a7, fa7, t0, fa5, fa3, ft3, fa0, t4, t2], uses: [a0], upward_exposed: [], params_defs: []
; live_in: [], live_out: []
; block parameters: []
_start_b0:
  call thunk_start  ; live: [a0]
; control
  ret  ; live: []

  .p2align 3
  .globl inprod
  .type inprod, @function
inprod:
; block info: defs: [v3, v25, v4, v5, v2], uses: [v25, v5, a0, zero, a2, v4, a1], upward_exposed: [a2, a1, a0, zero], params_defs: []
; live_in: [a2, a1, a0, zero], live_out: [v3, v4, zero, v2]
; block parameters: []
.inprod_b0:
  mv v2, a0  ; live: [a2, a1, a0, zero]
  mv v3, a1  ; live: [a2, a1, a0, zero]
  mv v4, a2  ; live: [a2, v4, a1, a0, zero]
  slt v25, zero, v4  ; live: [v25, a2, a1, a0, zero]
  xori v5, v25, 1  ; live: [a2, a1, v5, a0, zero]
; control
  bne v5, zero, .inprod_b1  ; live: [a2, a1, a0, zero]
  j .inprod_b2  ; live: [a2, a1, a0, zero]

; block info: defs: [fv24, fv12], uses: [fv24, zero], upward_exposed: [zero], params_defs: []
; live_in: [zero], live_out: [fv12]
; block parameters: []
.inprod_b2:
; control
  fmv.d.x fv24, zero  ; live: [fv24, zero]
  fmv.d fv12, fv24  ; live: [zero]
  j .inprod_b3  ; live: [zero]

; block info: defs: [t1, fv10, v22, ft0, ft1, fv12, a1, t5, fa1, fa2, ft6, a4, fa6, v19, a6, ft5, ft10, ft7, ft4, v21, ft9, a5, a0, fa4, fv8, ft2, a2, a3, fv6, v9, ft8, a7, t3, fa7, t0, fa5, v18, fa3, fv11, ft3, fa0, t4, t2, v15, fv7], uses: [v3, fv10, v21, a0, v22, fv8, a2, a1, fv6, v9, v18, fv11, fa0, v19, v4, v15, fv7, v2], upward_exposed: [v3, v4, v2], params_defs: []
; live_in: [v2, v4, v3], live_out: [fv12]
; block parameters: []
.inprod_b1:
  slli v21, v4, 3  ; live: [v2, v21, v4, v3]
  add v22, v2, v21  ; live: [v2, v22, v4, v3]
  fld fv6, 0(v22)  ; live: [v2, v4, fv6, v3]
  slli v18, v4, 3  ; live: [v2, v18, v4, fv6, v3]
  add v19, v3, v18  ; live: [v2, v19, v4, fv6, v3]
  fld fv7, 0(v19)  ; live: [v2, v4, fv6, fv7, v3]
  fmul.d fv8, fv6, fv7  ; live: [v2, fv8, v4, v3]
  li v15, 1  ; live: [v2, fv8, v4, v15, v3]
  sub v9, v4, v15  ; live: [v2, fv8, v4, v9, v3]
  mv a0, v2  ; live: [v2, a0, fv8, v4, v9, v3]
  mv a1, v3  ; live: [v2, a0, fv8, v4, a1, v9, v3]
  mv a2, v9  ; live: [v2, a0, fv8, v4, a2, a1, v3]
  call inprod  ; live: [v3, fv8, fa0, v4, v2]
  fmv.d fv10, fa0  ; live: [v3, fv8, v4, fv10, v2]
  fadd.d fv11, fv8, fv10  ; live: [v3, v4, fv11, v2]
; control
  fmv.d fv12, fv11  ; live: [v3, v4, v2]
  j .inprod_b3  ; live: [v3, v4, v2]

; block info: defs: [fa0], uses: [fv12, fa0], upward_exposed: [fv12], params_defs: [fv12]
; live_in: [fv12], live_out: []
; block parameters: [fv12]
.inprod_b3:
; control
  fmv.d fa0, fv12  ; live: [fv12, fa0]
  ret  ; live: [fv12]

  .p2align 3
  .globl thunk_start
  .type thunk_start, @function
thunk_start:
; block info: defs: [t1, ft0, ft1, a1, t5, fa1, fa2, ft6, a4, fa6, a6, ft5, ft10, ft7, ft4, ft9, a5, a0, fa4, ft2, a2, a3, ft8, t3, a7, fa7, t0, fa5, fa3, ft3, fa0, t4, t2, v2], uses: [zero, a0, v2], upward_exposed: [zero], params_defs: []
; live_in: [zero], live_out: []
; block parameters: []
.thunk_start_b0:
  call main  ; live: [zero]
  mv v2, zero  ; live: [zero, v2]
; control
  mv a0, v2  ; live: [zero, a0]
  ret  ; live: [zero]

  .p2align 3
  .globl main
  .type main, @function
main:
; block info: defs: [v2, fv24, t1, fv20, ft0, ft1, a1, v12, t5, fa1, fa2, ft6, a4, fa6, v8, a6, v19, ft10, ft5, ft7, ft4, v21, ft9, a5, a0, fa4, ft2, a2, v17, a3, fv6, v9, ft8, t3, a7, fa7, t0, fa5, fa3, v23, ft3, fa0, fv13, t4, t2, v15, fv7, v3], uses: [v2, fv24, v21, a0, fv20, a2, v17, a1, s11, v12, fv6, v9, zero, v23, fa0, fv13, v8, v19, v15, fv7, v3], upward_exposed: [s11, zero], params_defs: []
; live_in: [s11, zero], live_out: []
; block parameters: []
.main_b0:
  addi v21, s11, -24  ; live: [s11, v21, zero]
  andi v2, v21, -8  ; live: [s11, zero, v2]
  li v23, 4608218246714312622  ; live: [s11, zero, v23, v2]
  fmv.d.x fv24, v23  ; live: [fv24, s11, zero, v2]
  fsd fv24, 0(v2)  ; live: [fv24, s11, zero, v2]
  fsd fv24, 8(v2)  ; live: [fv24, s11, zero, v2]
  fsd fv24, 16(v2)  ; live: [s11, zero, v2]
  addi v17, s11, -24  ; live: [v17, s11, zero, v2]
  andi v3, v17, -8  ; live: [v2, s11, zero, v3]
  li v19, 4616820122002590269  ; live: [v2, v19, s11, zero, v3]
  fmv.d.x fv20, v19  ; live: [v2, fv20, s11, zero, v3]
  fsd fv20, 0(v3)  ; live: [v2, fv20, s11, zero, v3]
  fsd fv20, 8(v3)  ; live: [v2, fv20, s11, zero, v3]
  fsd fv20, 16(v3)  ; live: [v2, s11, zero, v3]
  mv a0, v2  ; live: [s11, zero, a0, v3]
  mv a1, v3  ; live: [a1, s11, zero, a0]
  li v15, 2  ; live: [a1, s11, v15, zero, a0]
  mv a2, v15  ; live: [a2, a1, s11, zero, a0]
  call inprod  ; live: [s11, zero, fa0]
  fmv.d fv6, fa0  ; live: [s11, fv6, zero]
  li v12, 4696837146684686336  ; live: [s11, v12, fv6, zero]
  fmv.d.x fv13, v12  ; live: [s11, fv6, zero, fv13]
  fmul.d fv7, fv13, fv6  ; live: [s11, zero, fv7]
  fmv.d fa0, fv7  ; live: [s11, zero, fa0]
  call minimbt_truncate  ; live: [s11, zero, a0]
  mv v8, a0  ; live: [s11, zero, v8]
  mv a0, v8  ; live: [s11, zero, a0]
  call minimbt_print_int  ; live: [s11, zero]
  mv v9, zero  ; live: [s11, zero, v9]
; control
  mv a0, v9  ; live: [s11, zero, a0]
  ret  ; live: [s11, zero]

  .p2align 3
  .globl start
  .type start, @object
start:
  .zero 4



Testing test/test_src/inprod.mbt
# name conventions used in the core ir:
# - functions: f<id>
# - blocks: b<id>
# - instructions: %<id>
# - memory: m<id>
# - free variables: ^<id>
# - function parameters: $f<pid>
# - block parameters: $b<bid>.<pid>
.core
.fn gety #f1 : fn((double, double, double)) -> double
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: double = load double field($f0, 0)
    let %1: double = load double field($f0, 1)
    let %2: double = load double field($f0, 2)
    return %1
  }
}
.fn thunk_start #f5 : fn() -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: unit = call f4()
    return %0
  }
}
.fn getx #f0 : fn((double, double, double)) -> double
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: double = load double field($f0, 0)
    let %1: double = load double field($f0, 1)
    let %2: double = load double field($f0, 2)
    return %0
  }
}
.fn inprod #f3 : fn((double, double, double), (double, double, double)) -> double
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: double = call f0($f0)
    let %1: double = call f0($f1)
    let %2: double = mul(%0, %1)
    let %3: double = call f1($f0)
    let %4: double = call f1($f1)
    let %5: double = mul(%3, %4)
    let %6: double = add(%2, %5)
    let %7: double = call f2($f0)
    let %8: double = call f2($f1)
    let %9: double = mul(%7, %8)
    let %10: double = add(%6, %9)
    return %10
  }
}
.fn getz #f2 : fn((double, double, double)) -> double
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: double = load double field($f0, 0)
    let %1: double = load double field($f0, 1)
    let %2: double = load double field($f0, 2)
    return %2
  }
}
.fn main #f4 : fn() -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let _ = alloc <m0: (double, double, double) heap(3)> <- [0] = 1, [1] = 2, [2] = 3
    let _ = alloc <m1: (double, double, double) heap(3)> <- [0] = 4, [1] = 5, [2] = 6
    let %2: double = call f3(f4.m0, f4.m1)
    let %3: double = mul(1000000, %2)
    let %4: int32 = ext_call minimbt_truncate(%3)
    let %5: unit = ext_call minimbt_print_int(%4)
    return %5
  }
}
.thunk ::0 start

  .p2align 3
  .globl _start
  .type _start, @function
_start:
; block info: defs: [t1, ft0, ft1, a1, t5, fa1, fa2, ft6, a4, fa6, a6, ft5, ft10, ft7, ft4, ft9, a5, a0, fa4, ft2, a2, a3, ft8, t3, a7, fa7, t0, fa5, fa3, ft3, fa0, t4, t2], uses: [a0], upward_exposed: [], params_defs: []
; live_in: [], live_out: []
; block parameters: []
_start_b0:
  call thunk_start  ; live: [a0]
; control
  ret  ; live: []

  .p2align 3
  .globl gety
  .type gety, @function
gety:
; block info: defs: [fa0, fv4, v2], uses: [fa0, fv4, a0, v2], upward_exposed: [a0], params_defs: []
; live_in: [a0], live_out: []
; block parameters: []
.gety_b0:
  mv v2, a0  ; live: [a0, v2]
  fld fv4, 8(v2)  ; live: [fv4, a0]
; control
  fmv.d fa0, fv4  ; live: [a0, fa0]
  ret  ; live: [a0]

  .p2align 3
  .globl thunk_start
  .type thunk_start, @function
thunk_start:
; block info: defs: [t1, ft0, ft1, a1, t5, fa1, fa2, ft6, a4, fa6, a6, ft5, ft10, ft7, ft4, ft9, a5, a0, fa4, ft2, a2, a3, ft8, t3, a7, fa7, t0, fa5, fa3, ft3, fa0, t4, t2, v2], uses: [zero, a0, v2], upward_exposed: [zero], params_defs: []
; live_in: [zero], live_out: []
; block parameters: []
.thunk_start_b0:
  call main  ; live: [zero]
  mv v2, zero  ; live: [zero, v2]
; control
  mv a0, v2  ; live: [zero, a0]
  ret  ; live: [zero]

  .p2align 3
  .globl getx
  .type getx, @function
getx:
; block info: defs: [fa0, fv3, v2], uses: [fa0, a0, fv3, v2], upward_exposed: [a0], params_defs: []
; live_in: [a0], live_out: []
; block parameters: []
.getx_b0:
  mv v2, a0  ; live: [a0, v2]
  fld fv3, 0(v2)  ; live: [a0, fv3]
; control
  fmv.d fa0, fv3  ; live: [a0, fa0]
  ret  ; live: [a0]

  .p2align 3
  .globl inprod
  .type inprod, @function
inprod:
; block info: defs: [v2, t1, fv10, ft0, ft1, fv12, a1, fv14, t5, fa1, fv5, fa2, ft6, a4, fa6, a6, ft5, ft10, ft7, ft4, ft9, a5, a0, fa4, fv8, ft2, a2, fv4, a3, fv6, ft8, t3, a7, fa7, fv9, t0, fa5, fa3, fv11, ft3, fa0, fv13, t4, t2, fv7, v3], uses: [v3, fv10, a0, fv8, fv12, a1, fv4, fv14, fv6, fv5, fv9, fv11, fa0, fv13, fv7, v2], upward_exposed: [a1, a0], params_defs: []
; live_in: [a1, a0], live_out: []
; block parameters: []
.inprod_b0:
  mv v2, a0  ; live: [a1, v2]
  mv v3, a1  ; live: [v2, v3]
  mv a0, v2  ; live: [v2, a0, v3]
  call getx  ; live: [v2, fa0, v3]
  fmv.d fv4, fa0  ; live: [v2, fv4, v3]
  mv a0, v3  ; live: [v2, fv4, a0, v3]
  call getx  ; live: [v2, fa0, fv4, v3]
  fmv.d fv5, fa0  ; live: [v2, fv5, fv4, v3]
  fmul.d fv6, fv4, fv5  ; live: [v2, fv6, v3]
  mv a0, v2  ; live: [v2, fv6, a0, v3]
  call gety  ; live: [v2, fa0, fv6, v3]
  fmv.d fv7, fa0  ; live: [v2, fv6, fv7, v3]
  mv a0, v3  ; live: [v2, fv6, a0, fv7, v3]
  call gety  ; live: [v2, fa0, fv6, fv7, v3]
  fmv.d fv8, fa0  ; live: [v2, fv8, fv6, fv7, v3]
  fmul.d fv9, fv7, fv8  ; live: [v2, fv9, fv6, v3]
  fadd.d fv10, fv6, fv9  ; live: [v2, fv10, v3]
  mv a0, v2  ; live: [fv10, a0, v3]
  call getz  ; live: [fa0, fv10, v3]
  fmv.d fv11, fa0  ; live: [fv10, fv11, v3]
  mv a0, v3  ; live: [fv10, fv11, a0]
  call getz  ; live: [fv10, a1, a0, fv11, fa0]
  fmv.d fv12, fa0  ; live: [fv10, fv12, a1, a0, fv11]
  fmul.d fv13, fv11, fv12  ; live: [fv10, a1, a0, fv13]
  fadd.d fv14, fv10, fv13  ; live: [a1, fv14, a0]
; control
  fmv.d fa0, fv14  ; live: [a1, a0, fa0]
  ret  ; live: [a1, a0]

  .p2align 3
  .globl getz
  .type getz, @function
getz:
; block info: defs: [fa0, fv5, v2], uses: [fa0, fv5, a0, v2], upward_exposed: [a0], params_defs: []
; live_in: [a0], live_out: []
; block parameters: []
.getz_b0:
  mv v2, a0  ; live: [a0, v2]
  fld fv5, 16(v2)  ; live: [fv5, a0]
; control
  fmv.d fa0, fv5  ; live: [a0, fa0]
  ret  ; live: [a0]

  .p2align 3
  .globl main
  .type main, @function
main:
; block info: defs: [v22, a1, t5, v28, fa1, fa2, ft6, v20, a4, fa6, a6, ft10, ft5, fv27, ft4, ft9, fa4, ft2, a3, a7, fa7, fa3, ft3, fv29, t2, fv7, v3, fv23, t1, v16, v26, fv19, ft0, ft1, v12, v8, fv21, ft7, a5, a0, v30, a2, v24, fv6, v9, ft8, t3, t0, fa5, v18, fv31, fa0, fv13, t4, v2], uses: [v3, fv23, v16, v26, v22, fv19, a1, s11, v12, v28, zero, v20, v8, fv27, fv21, a0, v30, v24, fv6, v9, v18, fv31, fa0, fv13, fv29, fv7, v2], upward_exposed: [s11, zero], params_defs: []
; live_in: [s11, zero], live_out: []
; block parameters: []
.main_b0:
  addi v24, s11, -24  ; live: [s11, v24, zero]
  andi v2, v24, -8  ; live: [s11, zero, v2]
  li v26, 4607182418800017408  ; live: [s11, zero, v26, v2]
  fmv.d.x fv27, v26  ; live: [fv27, s11, zero, v2]
  fsd fv27, 0(v2)  ; live: [s11, zero, v2]
  li v28, 4611686018427387904  ; live: [s11, v28, zero, v2]
  fmv.d.x fv29, v28  ; live: [fv29, s11, zero, v2]
  fsd fv29, 8(v2)  ; live: [s11, zero, v2]
  li v30, 4613937818241073152  ; live: [s11, zero, v30, v2]
  fmv.d.x fv31, v30  ; live: [s11, fv31, zero, v2]
  fsd fv31, 16(v2)  ; live: [s11, zero, v2]
  addi v16, s11, -24  ; live: [v16, s11, zero, v2]
  andi v3, v16, -8  ; live: [v2, s11, zero, v3]
  li v18, 4616189618054758400  ; live: [v2, s11, v18, zero, v3]
  fmv.d.x fv19, v18  ; live: [v2, fv19, s11, zero, v3]
  fsd fv19, 0(v3)  ; live: [v2, s11, zero, v3]
  li v20, 4617315517961601024  ; live: [v2, s11, zero, v20, v3]
  fmv.d.x fv21, v20  ; live: [v2, s11, zero, fv21, v3]
  fsd fv21, 8(v3)  ; live: [v2, s11, zero, v3]
  li v22, 4618441417868443648  ; live: [v2, s11, zero, v22, v3]
  fmv.d.x fv23, v22  ; live: [v2, fv23, s11, zero, v3]
  fsd fv23, 16(v3)  ; live: [v2, s11, zero, v3]
  mv a0, v2  ; live: [s11, zero, a0, v3]
  mv a1, v3  ; live: [a1, s11, zero, a0]
  call inprod  ; live: [s11, zero, fa0]
  fmv.d fv6, fa0  ; live: [s11, fv6, zero]
  li v12, 4696837146684686336  ; live: [s11, v12, fv6, zero]
  fmv.d.x fv13, v12  ; live: [s11, fv6, zero, fv13]
  fmul.d fv7, fv13, fv6  ; live: [s11, zero, fv7]
  fmv.d fa0, fv7  ; live: [s11, zero, fa0]
  call minimbt_truncate  ; live: [s11, zero, a0]
  mv v8, a0  ; live: [s11, zero, v8]
  mv a0, v8  ; live: [s11, zero, a0]
  call minimbt_print_int  ; live: [s11, zero]
  mv v9, zero  ; live: [s11, zero, v9]
; control
  mv a0, v9  ; live: [s11, zero, a0]
  ret  ; live: [s11, zero]

  .p2align 3
  .globl start
  .type start, @object
start:
  .zero 4



Testing test/test_src/join-reg.mbt
# name conventions used in the core ir:
# - functions: f<id>
# - blocks: b<id>
# - instructions: %<id>
# - memory: m<id>
# - free variables: ^<id>
# - function parameters: $f<pid>
# - block parameters: $b<bid>.<pid>
.core
.fn f #f0 : fn(unit) -> int32
.freevars ()
.entry b0 {
  .bb #b0 () {
    return 123
  }
}
.fn thunk_start #f4 : fn() -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: unit = call f3()
    return %0
  }
}
.fn h #f2 : fn(unit) -> int32
.freevars ()
.entry b0 {
  .bb #b0 () {
    return 789
  }
}
.fn g #f1 : fn(unit) -> int32
.freevars ()
.entry b0 {
  .bb #b0 () {
    return 456
  }
}
.fn main #f3 : fn() -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: int32 = call f0(())
    let %1: int32 = call f1(())
    let %2: int32 = call f2(())
    let %3: bool = eq(%2, 0)
    br %3 b1() b2()
  }
  .bb #b1 () {
    let %4: int32 = sub(%0, %1)
    jump b3(%4)
  }
  .bb #b2 () {
    let %5: int32 = sub(%1, %0)
    let %6: int32 = add(%5, %0)
    let %7: int32 = add(%6, %1)
    jump b3(%7)
  }
  .bb #b3 (int32) {
    let %8: unit = ext_call minimbt_print_int($b3.0)
    return %8
  }
}
.thunk ::0 start

  .p2align 3
  .globl _start
  .type _start, @function
_start:
; block info: defs: [t1, ft0, ft1, a1, t5, fa1, fa2, ft6, a4, fa6, a6, ft5, ft10, ft7, ft4, ft9, a5, a0, fa4, ft2, a2, a3, ft8, t3, a7, fa7, t0, fa5, fa3, ft3, fa0, t4, t2], uses: [a0], upward_exposed: [], params_defs: []
; live_in: [], live_out: []
; block parameters: []
_start_b0:
  call thunk_start  ; live: [a0]
; control
  ret  ; live: []

  .p2align 3
  .globl f
  .type f, @function
f:
; block info: defs: [v3, a0, v2], uses: [a0, v3], upward_exposed: [a0], params_defs: []
; live_in: [a0], live_out: []
; block parameters: []
.f_b0:
  mv v2, a0  ; live: []
; control
  li v3, 123  ; live: [v3]
  mv a0, v3  ; live: [a0]
  ret  ; live: [a0]

  .p2align 3
  .globl thunk_start
  .type thunk_start, @function
thunk_start:
; block info: defs: [t1, ft0, ft1, a1, t5, fa1, fa2, ft6, a4, fa6, a6, ft5, ft10, ft7, ft4, ft9, a5, a0, fa4, ft2, a2, a3, ft8, t3, a7, fa7, t0, fa5, fa3, ft3, fa0, t4, t2, v2], uses: [zero, a0, v2], upward_exposed: [zero], params_defs: []
; live_in: [zero], live_out: []
; block parameters: []
.thunk_start_b0:
  call main  ; live: [zero]
  mv v2, zero  ; live: [zero, v2]
; control
  mv a0, v2  ; live: [zero, a0]
  ret  ; live: [zero]

  .p2align 3
  .globl h
  .type h, @function
h:
; block info: defs: [v3, a0, v2], uses: [a0, v3], upward_exposed: [a0], params_defs: []
; live_in: [a0], live_out: []
; block parameters: []
.h_b0:
  mv v2, a0  ; live: []
; control
  li v3, 789  ; live: [v3]
  mv a0, v3  ; live: [a0]
  ret  ; live: [a0]

  .p2align 3
  .globl g
  .type g, @function
g:
; block info: defs: [v3, a0, v2], uses: [a0, v3], upward_exposed: [a0], params_defs: []
; live_in: [a0], live_out: []
; block parameters: []
.g_b0:
  mv v2, a0  ; live: []
; control
  li v3, 456  ; live: [v3]
  mv a0, v3  ; live: [a0]
  ret  ; live: [a0]

  .p2align 3
  .globl main
  .type main, @function
main:
; block info: defs: [v3, t1, ft0, ft1, a1, t5, fa1, fa2, ft6, a4, fa6, a6, ft5, ft10, v4, ft7, ft4, v5, ft9, a5, a0, fa4, ft2, a2, v17, a3, ft8, t3, a7, fa7, t0, fa5, fa3, ft3, fa0, t4, t2, v2], uses: [v4, v17, v5, zero, a0], upward_exposed: [zero], params_defs: []
; live_in: [zero], live_out: [v3, zero, v2]
; block parameters: []
.main_b0:
  mv a0, zero  ; live: [zero, a0]
  call f  ; live: [zero, a0]
  mv v2, a0  ; live: [zero]
  mv a0, zero  ; live: [zero, a0]
  call g  ; live: [zero, a0]
  mv v3, a0  ; live: [zero]
  mv a0, zero  ; live: [zero, a0]
  call h  ; live: [zero, a0]
  mv v4, a0  ; live: [v4, zero]
  xor v17, v4, zero  ; live: [v17, zero]
  sltiu v5, v17, 1  ; live: [v5, zero]
; control
  bne v5, zero, .main_b1  ; live: [zero]
  j .main_b2  ; live: [zero]

; block info: defs: [t1, ft0, ft1, a1, t5, fa1, fa2, ft6, a4, fa6, a6, ft5, ft10, ft7, v11, ft4, ft9, a5, a0, fa4, ft2, a2, a3, ft8, t3, a7, fa7, t0, fa5, fa3, ft3, fa0, t4, t2], uses: [v11, v10, a0, zero], upward_exposed: [v10, zero], params_defs: [v10]
; live_in: [v10, zero], live_out: []
; block parameters: [v10]
.main_b3:
  mv a0, v10  ; live: [v10, zero, a0]
  call minimbt_print_int  ; live: [v10, zero]
  mv v11, zero  ; live: [v11, v10, zero]
; control
  mv a0, v11  ; live: [v10, zero, a0]
  ret  ; live: [v10, zero]

; block info: defs: [v10, v9], uses: [v3, v9, v2], upward_exposed: [v3, v2], params_defs: []
; live_in: [v2, zero, v3], live_out: [v10, zero]
; block parameters: []
.main_b1:
  sub v9, v2, v3  ; live: [v3, zero, v9, v2]
; control
  mv v10, v9  ; live: [v3, zero, v2]
  j .main_b3  ; live: [v3, zero, v2]

; block info: defs: [v8, v6, v10, v7], uses: [v2, v7, v8, v6, v3], upward_exposed: [v2, v3], params_defs: []
; live_in: [v3, zero, v2], live_out: [v10, zero]
; block parameters: []
.main_b2:
  sub v6, v3, v2  ; live: [v2, v6, zero, v3]
  add v7, v6, v2  ; live: [v2, v7, zero, v3]
  add v8, v7, v3  ; live: [v2, v8, zero, v3]
; control
  mv v10, v8  ; live: [v2, zero, v3]
  j .main_b3  ; live: [v2, zero, v3]

  .p2align 3
  .globl start
  .type start, @object
start:
  .zero 4



Testing test/test_src/join-reg2.mbt
# name conventions used in the core ir:
# - functions: f<id>
# - blocks: b<id>
# - instructions: %<id>
# - memory: m<id>
# - free variables: ^<id>
# - function parameters: $f<pid>
# - block parameters: $b<bid>.<pid>
.core
.fn f #f0 : fn(unit) -> int32
.freevars ()
.entry b0 {
  .bb #b0 () {
    return 123
  }
}
.fn thunk_start #f4 : fn() -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: unit = call f3()
    return %0
  }
}
.fn h #f2 : fn(unit) -> int32
.freevars ()
.entry b0 {
  .bb #b0 () {
    return 789
  }
}
.fn g #f1 : fn(unit) -> int32
.freevars ()
.entry b0 {
  .bb #b0 () {
    return 456
  }
}
.fn main #f3 : fn() -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: int32 = call f0(())
    let %1: bool = le(%0, 0)
    br %1 b1() b2()
  }
  .bb #b1 () {
    let %2: int32 = call f1(())
    let %3: int32 = add(%2, %0)
    jump b3(%3)
  }
  .bb #b2 () {
    let %4: int32 = call f2(())
    let %5: int32 = sub(%4, %0)
    let %6: int32 = add(%5, %0)
    jump b3(%6)
  }
  .bb #b3 (int32) {
    let %7: unit = ext_call minimbt_print_int($b3.0)
    return %7
  }
}
.thunk ::0 start

  .p2align 3
  .globl _start
  .type _start, @function
_start:
; block info: defs: [t1, ft0, ft1, a1, t5, fa1, fa2, ft6, a4, fa6, a6, ft5, ft10, ft7, ft4, ft9, a5, a0, fa4, ft2, a2, a3, ft8, t3, a7, fa7, t0, fa5, fa3, ft3, fa0, t4, t2], uses: [a0], upward_exposed: [], params_defs: []
; live_in: [], live_out: []
; block parameters: []
_start_b0:
  call thunk_start  ; live: [a0]
; control
  ret  ; live: []

  .p2align 3
  .globl f
  .type f, @function
f:
; block info: defs: [v3, a0, v2], uses: [a0, v3], upward_exposed: [a0], params_defs: []
; live_in: [a0], live_out: []
; block parameters: []
.f_b0:
  mv v2, a0  ; live: []
; control
  li v3, 123  ; live: [v3]
  mv a0, v3  ; live: [a0]
  ret  ; live: [a0]

  .p2align 3
  .globl thunk_start
  .type thunk_start, @function
thunk_start:
; block info: defs: [t1, ft0, ft1, a1, t5, fa1, fa2, ft6, a4, fa6, a6, ft5, ft10, ft7, ft4, ft9, a5, a0, fa4, ft2, a2, a3, ft8, t3, a7, fa7, t0, fa5, fa3, ft3, fa0, t4, t2, v2], uses: [zero, a0, v2], upward_exposed: [zero], params_defs: []
; live_in: [zero], live_out: []
; block parameters: []
.thunk_start_b0:
  call main  ; live: [zero]
  mv v2, zero  ; live: [zero, v2]
; control
  mv a0, v2  ; live: [zero, a0]
  ret  ; live: [zero]

  .p2align 3
  .globl h
  .type h, @function
h:
; block info: defs: [v3, a0, v2], uses: [a0, v3], upward_exposed: [a0], params_defs: []
; live_in: [a0], live_out: []
; block parameters: []
.h_b0:
  mv v2, a0  ; live: []
; control
  li v3, 789  ; live: [v3]
  mv a0, v3  ; live: [a0]
  ret  ; live: [a0]

  .p2align 3
  .globl g
  .type g, @function
g:
; block info: defs: [v3, a0, v2], uses: [a0, v3], upward_exposed: [a0], params_defs: []
; live_in: [a0], live_out: []
; block parameters: []
.g_b0:
  mv v2, a0  ; live: []
; control
  li v3, 456  ; live: [v3]
  mv a0, v3  ; live: [a0]
  ret  ; live: [a0]

  .p2align 3
  .globl main
  .type main, @function
main:
; block info: defs: [v3, t1, ft0, ft1, a1, t5, fa1, fa2, ft6, a4, fa6, a6, ft5, ft10, ft7, ft4, ft9, a5, a0, fa4, ft2, a2, v17, a3, ft8, t3, a7, fa7, t0, fa5, fa3, ft3, fa0, t4, t2, v2], uses: [v3, v17, zero, a0, v2], upward_exposed: [zero], params_defs: []
; live_in: [zero], live_out: [zero, v2]
; block parameters: []
.main_b0:
  mv a0, zero  ; live: [zero, a0]
  call f  ; live: [zero, a0]
  mv v2, a0  ; live: [zero, v2]
  slt v17, v2, zero  ; live: [v17, zero]
  xori v3, v17, 1  ; live: [zero, v3]
; control
  bne v3, zero, .main_b1  ; live: [zero]
  j .main_b2  ; live: [zero]

; block info: defs: [t1, ft0, ft1, a1, t5, fa1, fa2, ft6, a4, fa6, a6, ft5, ft10, ft7, ft4, ft9, v10, a5, fa4, a0, ft2, a2, a3, ft8, t3, a7, fa7, t0, fa5, fa3, ft3, fa0, t4, t2], uses: [v10, v9, a0, zero], upward_exposed: [v9, zero], params_defs: [v9]
; live_in: [v9, zero], live_out: []
; block parameters: [v9]
.main_b3:
  mv a0, v9  ; live: [v9, zero, a0]
  call minimbt_print_int  ; live: [v9, zero]
  mv v10, zero  ; live: [v10, v9, zero]
; control
  mv a0, v10  ; live: [v9, zero, a0]
  ret  ; live: [v9, zero]

; block info: defs: [t1, v7, ft0, ft1, a1, t5, fa1, fa2, ft6, a4, fa6, v8, a6, ft10, ft5, ft7, ft4, ft9, a5, a0, fa4, ft2, a2, a3, v9, ft8, t3, a7, fa7, t0, fa5, fa3, ft3, fa0, t4, t2], uses: [v2, v8, zero, a0, v7], upward_exposed: [zero, v2], params_defs: []
; live_in: [zero, v2], live_out: [v9, zero]
; block parameters: []
.main_b1:
  mv a0, zero  ; live: [zero, a0, v2]
  call g  ; live: [zero, a0, v2]
  mv v7, a0  ; live: [v7, zero, v2]
  add v8, v7, v2  ; live: [v8, zero, v2]
; control
  mv v9, v8  ; live: [zero, v2]
  j .main_b3  ; live: [zero, v2]

; block info: defs: [t1, ft0, ft1, a1, t5, fa1, fa2, ft6, a4, fa6, a6, ft5, ft10, v4, v6, ft7, ft4, v5, ft9, a5, a0, fa4, ft2, a2, a3, v9, ft8, t3, a7, fa7, t0, fa5, fa3, ft3, fa0, t4, t2], uses: [v4, v5, v6, zero, a0, v2], upward_exposed: [zero, v2], params_defs: []
; live_in: [zero, v2], live_out: [v9, zero]
; block parameters: []
.main_b2:
  mv a0, zero  ; live: [zero, a0, v2]
  call h  ; live: [zero, a0, v2]
  mv v4, a0  ; live: [v4, zero, v2]
  sub v5, v4, v2  ; live: [v5, zero, v2]
  add v6, v5, v2  ; live: [v6, zero, v2]
; control
  mv v9, v6  ; live: [zero, v2]
  j .main_b3  ; live: [zero, v2]

  .p2align 3
  .globl start
  .type start, @object
start:
  .zero 4



Testing test/test_src/join-stack.mbt
# name conventions used in the core ir:
# - functions: f<id>
# - blocks: b<id>
# - instructions: %<id>
# - memory: m<id>
# - free variables: ^<id>
# - function parameters: $f<pid>
# - block parameters: $b<bid>.<pid>
.core
.fn f #f0 : fn(unit) -> int32
.freevars ()
.entry b0 {
  .bb #b0 () {
    return 123
  }
}
.fn thunk_start #f4 : fn() -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: unit = call f3()
    return %0
  }
}
.fn h #f2 : fn(unit) -> int32
.freevars ()
.entry b0 {
  .bb #b0 () {
    return 789
  }
}
.fn g #f1 : fn(unit) -> int32
.freevars ()
.entry b0 {
  .bb #b0 () {
    return 456
  }
}
.fn main #f3 : fn() -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: int32 = call f0(())
    let %1: int32 = call f1(())
    let %2: int32 = call f2(())
    let %3: bool = eq(%2, 0)
    br %3 b1() b2()
  }
  .bb #b1 () {
    let %4: int32 = add(%0, 1)
    jump b3(%4)
  }
  .bb #b2 () {
    let %5: int32 = add(%1, 2)
    let %6: int32 = add(%5, %0)
    let %7: int32 = add(%6, %1)
    jump b3(%7)
  }
  .bb #b3 (int32) {
    let %8: unit = ext_call minimbt_print_int($b3.0)
    return %8
  }
}
.thunk ::0 start

  .p2align 3
  .globl _start
  .type _start, @function
_start:
; block info: defs: [t1, ft0, ft1, a1, t5, fa1, fa2, ft6, a4, fa6, a6, ft5, ft10, ft7, ft4, ft9, a5, a0, fa4, ft2, a2, a3, ft8, t3, a7, fa7, t0, fa5, fa3, ft3, fa0, t4, t2], uses: [a0], upward_exposed: [], params_defs: []
; live_in: [], live_out: []
; block parameters: []
_start_b0:
  call thunk_start  ; live: [a0]
; control
  ret  ; live: []

  .p2align 3
  .globl f
  .type f, @function
f:
; block info: defs: [v3, a0, v2], uses: [a0, v3], upward_exposed: [a0], params_defs: []
; live_in: [a0], live_out: []
; block parameters: []
.f_b0:
  mv v2, a0  ; live: []
; control
  li v3, 123  ; live: [v3]
  mv a0, v3  ; live: [a0]
  ret  ; live: [a0]

  .p2align 3
  .globl thunk_start
  .type thunk_start, @function
thunk_start:
; block info: defs: [t1, ft0, ft1, a1, t5, fa1, fa2, ft6, a4, fa6, a6, ft5, ft10, ft7, ft4, ft9, a5, a0, fa4, ft2, a2, a3, ft8, t3, a7, fa7, t0, fa5, fa3, ft3, fa0, t4, t2, v2], uses: [zero, a0, v2], upward_exposed: [zero], params_defs: []
; live_in: [zero], live_out: []
; block parameters: []
.thunk_start_b0:
  call main  ; live: [zero]
  mv v2, zero  ; live: [zero, v2]
; control
  mv a0, v2  ; live: [zero, a0]
  ret  ; live: [zero]

  .p2align 3
  .globl h
  .type h, @function
h:
; block info: defs: [v3, a0, v2], uses: [a0, v3], upward_exposed: [a0], params_defs: []
; live_in: [a0], live_out: []
; block parameters: []
.h_b0:
  mv v2, a0  ; live: []
; control
  li v3, 789  ; live: [v3]
  mv a0, v3  ; live: [a0]
  ret  ; live: [a0]

  .p2align 3
  .globl g
  .type g, @function
g:
; block info: defs: [v3, a0, v2], uses: [a0, v3], upward_exposed: [a0], params_defs: []
; live_in: [a0], live_out: []
; block parameters: []
.g_b0:
  mv v2, a0  ; live: []
; control
  li v3, 456  ; live: [v3]
  mv a0, v3  ; live: [a0]
  ret  ; live: [a0]

  .p2align 3
  .globl main
  .type main, @function
main:
; block info: defs: [v3, t1, ft0, ft1, a1, t5, fa1, fa2, ft6, a4, fa6, a6, v19, ft10, v4, ft5, ft7, ft4, v5, ft9, a5, a0, fa4, ft2, a2, a3, ft8, t3, a7, fa7, t0, fa5, fa3, ft3, fa0, t4, t2, v2], uses: [v19, v4, v5, zero, a0], upward_exposed: [zero], params_defs: []
; live_in: [zero], live_out: [v3, zero, v2]
; block parameters: []
.main_b0:
  mv a0, zero  ; live: [zero, a0]
  call f  ; live: [zero, a0]
  mv v2, a0  ; live: [zero]
  mv a0, zero  ; live: [zero, a0]
  call g  ; live: [zero, a0]
  mv v3, a0  ; live: [zero]
  mv a0, zero  ; live: [zero, a0]
  call h  ; live: [zero, a0]
  mv v4, a0  ; live: [v4, zero]
  xor v19, v4, zero  ; live: [v19, zero]
  sltiu v5, v19, 1  ; live: [v5, zero]
; control
  bne v5, zero, .main_b1  ; live: [zero]
  j .main_b2  ; live: [zero]

; block info: defs: [t1, ft0, ft1, a1, t5, fa1, fa2, ft6, a4, fa6, a6, ft5, ft10, ft7, v11, ft4, ft9, a5, a0, fa4, ft2, a2, a3, ft8, t3, a7, fa7, t0, fa5, fa3, ft3, fa0, t4, t2], uses: [v11, v10, a0, zero], upward_exposed: [v10, zero], params_defs: [v10]
; live_in: [v10, zero], live_out: []
; block parameters: [v10]
.main_b3:
  mv a0, v10  ; live: [v10, zero, a0]
  call minimbt_print_int  ; live: [v10, zero]
  mv v11, zero  ; live: [v11, v10, zero]
; control
  mv a0, v11  ; live: [v10, zero, a0]
  ret  ; live: [v10, zero]

; block info: defs: [v10, v13, v9], uses: [v13, v9, v2], upward_exposed: [v2], params_defs: []
; live_in: [zero, v2], live_out: [v10, zero]
; block parameters: []
.main_b1:
  li v13, 1  ; live: [zero, v13, v2]
  add v9, v2, v13  ; live: [zero, v9, v2]
; control
  mv v10, v9  ; live: [zero, v2]
  j .main_b3  ; live: [zero, v2]

; block info: defs: [v8, v17, v6, v10, v7], uses: [v2, v7, v8, v6, v17, v3], upward_exposed: [v2, v3], params_defs: []
; live_in: [v3, zero, v2], live_out: [v10, zero]
; block parameters: []
.main_b2:
  li v17, 2  ; live: [v2, v17, zero, v3]
  add v6, v3, v17  ; live: [v2, v6, zero, v3]
  add v7, v6, v2  ; live: [v2, v7, zero, v3]
  add v8, v7, v3  ; live: [v2, v8, zero, v3]
; control
  mv v10, v8  ; live: [v2, zero, v3]
  j .main_b3  ; live: [v2, zero, v3]

  .p2align 3
  .globl start
  .type start, @object
start:
  .zero 4



Testing test/test_src/join-stack2.mbt
# name conventions used in the core ir:
# - functions: f<id>
# - blocks: b<id>
# - instructions: %<id>
# - memory: m<id>
# - free variables: ^<id>
# - function parameters: $f<pid>
# - block parameters: $b<bid>.<pid>
.core
.fn main #f2 : fn() -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: int32 = call f0(())
    let %1: bool = le(%0, 0)
    br %1 b1() b2()
  }
  .bb #b1 () {
    let %2: int32 = call f1(())
    let %3: int32 = add(%2, %0)
    jump b3(%3)
  }
  .bb #b2 () {
    let %4: int32 = add(%0, %0)
    jump b3(%4)
  }
  .bb #b3 (int32) {
    let %5: unit = ext_call minimbt_print_int($b3.0)
    return %5
  }
}
.fn f #f0 : fn(unit) -> int32
.freevars ()
.entry b0 {
  .bb #b0 () {
    return 123
  }
}
.fn thunk_start #f3 : fn() -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: unit = call f2()
    return %0
  }
}
.fn g #f1 : fn(unit) -> int32
.freevars ()
.entry b0 {
  .bb #b0 () {
    return 456
  }
}
.thunk ::0 start

  .p2align 3
  .globl _start
  .type _start, @function
_start:
; block info: defs: [t1, ft0, ft1, a1, t5, fa1, fa2, ft6, a4, fa6, a6, ft5, ft10, ft7, ft4, ft9, a5, a0, fa4, ft2, a2, a3, ft8, t3, a7, fa7, t0, fa5, fa3, ft3, fa0, t4, t2], uses: [a0], upward_exposed: [], params_defs: []
; live_in: [], live_out: []
; block parameters: []
_start_b0:
  call thunk_start  ; live: [a0]
; control
  ret  ; live: []

  .p2align 3
  .globl f
  .type f, @function
f:
; block info: defs: [v3, a0, v2], uses: [a0, v3], upward_exposed: [a0], params_defs: []
; live_in: [a0], live_out: []
; block parameters: []
.f_b0:
  mv v2, a0  ; live: []
; control
  li v3, 123  ; live: [v3]
  mv a0, v3  ; live: [a0]
  ret  ; live: [a0]

  .p2align 3
  .globl thunk_start
  .type thunk_start, @function
thunk_start:
; block info: defs: [t1, ft0, ft1, a1, t5, fa1, fa2, ft6, a4, fa6, a6, ft5, ft10, ft7, ft4, ft9, a5, a0, fa4, ft2, a2, a3, ft8, t3, a7, fa7, t0, fa5, fa3, ft3, fa0, t4, t2, v2], uses: [zero, a0, v2], upward_exposed: [zero], params_defs: []
; live_in: [zero], live_out: []
; block parameters: []
.thunk_start_b0:
  call main  ; live: [zero]
  mv v2, zero  ; live: [zero, v2]
; control
  mv a0, v2  ; live: [zero, a0]
  ret  ; live: [zero]

  .p2align 3
  .globl g
  .type g, @function
g:
; block info: defs: [v3, a0, v2], uses: [a0, v3], upward_exposed: [a0], params_defs: []
; live_in: [a0], live_out: []
; block parameters: []
.g_b0:
  mv v2, a0  ; live: []
; control
  li v3, 456  ; live: [v3]
  mv a0, v3  ; live: [a0]
  ret  ; live: [a0]

  .p2align 3
  .globl main
  .type main, @function
main:
; block info: defs: [v3, t1, v13, ft0, ft1, a1, t5, fa1, fa2, ft6, a4, fa6, a6, ft5, ft10, ft7, ft4, ft9, a5, a0, fa4, ft2, a2, a3, ft8, t3, a7, fa7, t0, fa5, fa3, ft3, fa0, t4, t2, v2], uses: [v2, v3, zero, a0, v13], upward_exposed: [zero], params_defs: []
; live_in: [zero], live_out: [zero, v2]
; block parameters: []
.main_b0:
  mv a0, zero  ; live: [zero, a0]
  call f  ; live: [zero, a0]
  mv v2, a0  ; live: [zero, v2]
  slt v13, v2, zero  ; live: [zero, v13]
  xori v3, v13, 1  ; live: [zero, v3]
; control
  bne v3, zero, .main_b1  ; live: [zero]
  j .main_b2  ; live: [zero]

; block info: defs: [t1, ft0, ft1, a1, t5, fa1, fa2, ft6, a4, fa6, v8, a6, ft10, ft5, ft7, ft4, ft9, a5, a0, fa4, ft2, a2, a3, ft8, t3, a7, fa7, t0, fa5, fa3, ft3, fa0, t4, t2], uses: [v8, a0, zero, v7], upward_exposed: [zero, v7], params_defs: [v7]
; live_in: [zero, v7], live_out: []
; block parameters: [v7]
.main_b3:
  mv a0, v7  ; live: [zero, a0, v7]
  call minimbt_print_int  ; live: [zero, v7]
  mv v8, zero  ; live: [v8, zero, v7]
; control
  mv a0, v8  ; live: [zero, a0, v7]
  ret  ; live: [zero, v7]

; block info: defs: [t1, v7, ft0, ft1, a1, t5, fa1, fa2, ft6, a4, fa6, a6, ft5, ft10, v6, ft7, ft4, v5, ft9, a5, a0, fa4, ft2, a2, a3, ft8, t3, a7, fa7, t0, fa5, fa3, ft3, fa0, t4, t2], uses: [v5, v6, zero, a0, v2], upward_exposed: [zero, v2], params_defs: []
; live_in: [zero, v2], live_out: [zero, v7]
; block parameters: []
.main_b1:
  mv a0, zero  ; live: [zero, a0, v2]
  call g  ; live: [zero, a0, v2]
  mv v5, a0  ; live: [v5, zero, v2]
  add v6, v5, v2  ; live: [v6, zero, v2]
; control
  mv v7, v6  ; live: [zero, v2]
  j .main_b3  ; live: [zero, v2]

; block info: defs: [v4, v7], uses: [v4, v2], upward_exposed: [v2], params_defs: []
; live_in: [zero, v2], live_out: [zero, v7]
; block parameters: []
.main_b2:
  add v4, v2, v2  ; live: [v4, zero, v2]
; control
  mv v7, v4  ; live: [zero, v2]
  j .main_b3  ; live: [zero, v2]

  .p2align 3
  .globl start
  .type start, @object
start:
  .zero 4



Testing test/test_src/join-stack3.mbt
# name conventions used in the core ir:
# - functions: f<id>
# - blocks: b<id>
# - instructions: %<id>
# - memory: m<id>
# - free variables: ^<id>
# - function parameters: $f<pid>
# - block parameters: $b<bid>.<pid>
.core
.fn f #f0 : fn(unit) -> int32
.freevars ()
.entry b0 {
  .bb #b0 () {
    return 123
  }
}
.fn thunk_start #f4 : fn() -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: unit = call f3()
    return %0
  }
}
.fn h #f2 : fn(unit) -> int32
.freevars ()
.entry b0 {
  .bb #b0 () {
    return 789
  }
}
.fn g #f1 : fn(unit) -> int32
.freevars ()
.entry b0 {
  .bb #b0 () {
    return 456
  }
}
.fn main #f3 : fn() -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: int32 = call f0(())
    let %1: bool = le(%0, 0)
    br %1 b1() b2()
  }
  .bb #b1 () {
    let %2: int32 = call f1(())
    jump b3(%2)
  }
  .bb #b2 () {
    let %3: int32 = call f2(())
    jump b3(%3)
  }
  .bb #b3 (int32) {
    let %4: int32 = add($b3.0, %0)
    let %5: unit = ext_call minimbt_print_int(%4)
    return %5
  }
}
.thunk ::0 start

  .p2align 3
  .globl _start
  .type _start, @function
_start:
; block info: defs: [t1, ft0, ft1, a1, t5, fa1, fa2, ft6, a4, fa6, a6, ft5, ft10, ft7, ft4, ft9, a5, a0, fa4, ft2, a2, a3, ft8, t3, a7, fa7, t0, fa5, fa3, ft3, fa0, t4, t2], uses: [a0], upward_exposed: [], params_defs: []
; live_in: [], live_out: []
; block parameters: []
_start_b0:
  call thunk_start  ; live: [a0]
; control
  ret  ; live: []

  .p2align 3
  .globl f
  .type f, @function
f:
; block info: defs: [v3, a0, v2], uses: [a0, v3], upward_exposed: [a0], params_defs: []
; live_in: [a0], live_out: []
; block parameters: []
.f_b0:
  mv v2, a0  ; live: []
; control
  li v3, 123  ; live: [v3]
  mv a0, v3  ; live: [a0]
  ret  ; live: [a0]

  .p2align 3
  .globl thunk_start
  .type thunk_start, @function
thunk_start:
; block info: defs: [t1, ft0, ft1, a1, t5, fa1, fa2, ft6, a4, fa6, a6, ft5, ft10, ft7, ft4, ft9, a5, a0, fa4, ft2, a2, a3, ft8, t3, a7, fa7, t0, fa5, fa3, ft3, fa0, t4, t2, v2], uses: [zero, a0, v2], upward_exposed: [zero], params_defs: []
; live_in: [zero], live_out: []
; block parameters: []
.thunk_start_b0:
  call main  ; live: [zero]
  mv v2, zero  ; live: [zero, v2]
; control
  mv a0, v2  ; live: [zero, a0]
  ret  ; live: [zero]

  .p2align 3
  .globl h
  .type h, @function
h:
; block info: defs: [v3, a0, v2], uses: [a0, v3], upward_exposed: [a0], params_defs: []
; live_in: [a0], live_out: []
; block parameters: []
.h_b0:
  mv v2, a0  ; live: []
; control
  li v3, 789  ; live: [v3]
  mv a0, v3  ; live: [a0]
  ret  ; live: [a0]

  .p2align 3
  .globl g
  .type g, @function
g:
; block info: defs: [v3, a0, v2], uses: [a0, v3], upward_exposed: [a0], params_defs: []
; live_in: [a0], live_out: []
; block parameters: []
.g_b0:
  mv v2, a0  ; live: []
; control
  li v3, 456  ; live: [v3]
  mv a0, v3  ; live: [a0]
  ret  ; live: [a0]

  .p2align 3
  .globl main
  .type main, @function
main:
; block info: defs: [v3, t1, v13, ft0, ft1, a1, t5, fa1, fa2, ft6, a4, fa6, a6, ft5, ft10, ft7, ft4, ft9, a5, a0, fa4, ft2, a2, a3, ft8, t3, a7, fa7, t0, fa5, fa3, ft3, fa0, t4, t2, v2], uses: [v2, v3, zero, a0, v13], upward_exposed: [zero], params_defs: []
; live_in: [zero], live_out: [zero, v2]
; block parameters: []
.main_b0:
  mv a0, zero  ; live: [zero, a0]
  call f  ; live: [zero, a0]
  mv v2, a0  ; live: [zero, v2]
  slt v13, v2, zero  ; live: [zero, v13]
  xori v3, v13, 1  ; live: [zero, v3]
; control
  bne v3, zero, .main_b1  ; live: [zero]
  j .main_b2  ; live: [zero]

; block info: defs: [t1, v7, ft0, ft1, a1, t5, fa1, fa2, ft6, a4, fa6, v8, a6, ft10, ft5, ft7, ft4, ft9, a5, a0, fa4, ft2, a2, a3, ft8, t3, a7, fa7, t0, fa5, fa3, ft3, fa0, t4, t2], uses: [a0, zero, v7, v8, v6, v2], upward_exposed: [v6, zero, v2], params_defs: [v6]
; live_in: [v6, zero, v2], live_out: []
; block parameters: [v6]
.main_b3:
  add v7, v6, v2  ; live: [v7, v6, zero, v2]
  mv a0, v7  ; live: [v6, zero, a0, v2]
  call minimbt_print_int  ; live: [v6, zero, v2]
  mv v8, zero  ; live: [v8, v6, zero, v2]
; control
  mv a0, v8  ; live: [v6, zero, a0, v2]
  ret  ; live: [v6, zero, v2]

; block info: defs: [t1, ft0, ft1, a1, t5, fa1, fa2, ft6, a4, fa6, a6, ft5, ft10, v6, ft7, ft4, v5, ft9, a5, a0, fa4, ft2, a2, a3, ft8, t3, a7, fa7, t0, fa5, fa3, ft3, fa0, t4, t2], uses: [v5, zero, a0], upward_exposed: [zero], params_defs: []
; live_in: [zero, v2], live_out: [v6, zero, v2]
; block parameters: []
.main_b1:
  mv a0, zero  ; live: [zero, a0, v2]
  call g  ; live: [zero, a0, v2]
  mv v5, a0  ; live: [v5, zero, v2]
; control
  mv v6, v5  ; live: [zero, v2]
  j .main_b3  ; live: [zero, v2]

; block info: defs: [t1, ft0, ft1, a1, t5, fa1, fa2, ft6, a4, fa6, a6, ft5, ft10, v4, v6, ft7, ft4, ft9, a5, a0, fa4, ft2, a2, a3, ft8, t3, a7, fa7, t0, fa5, fa3, ft3, fa0, t4, t2], uses: [v4, zero, a0], upward_exposed: [zero], params_defs: []
; live_in: [zero, v2], live_out: [v6, zero, v2]
; block parameters: []
.main_b2:
  mv a0, zero  ; live: [zero, a0, v2]
  call h  ; live: [zero, a0, v2]
  mv v4, a0  ; live: [v4, zero, v2]
; control
  mv v6, v4  ; live: [zero, v2]
  j .main_b3  ; live: [zero, v2]

  .p2align 3
  .globl start
  .type start, @object
start:
  .zero 4



Testing test/test_src/landins_knot.mbt
# name conventions used in the core ir:
# - functions: f<id>
# - blocks: b<id>
# - instructions: %<id>
# - memory: m<id>
# - free variables: ^<id>
# - function parameters: $f<pid>
# - block parameters: $b<bid>.<pid>
.core
.fn init #f10 : fn() -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: int32 = call f9(10)
    let %1: unit = ext_call minimbt_print_int(%0)
    let %2: int32 = call f9(31)
    let %3: unit = ext_call minimbt_print_int(%2)
    return %3
  }
}
.fn thunk__21 #f7 : fn() -> int32
.freevars ()
.entry b0 {
  .bb #b0 () {
    return 5
  }
}
.fn thunk_factorial.18 #f5 : fn() -> closure(int32) -> int32
.freevars ()
.entry b0 {
  .bb #b0 () {
    let _ = alloc <m0: closure(closure(int32) -> int32) -> closure(int32) -> int32 heap(1)> <- [0] = f3
    let %1: closure(int32) -> int32 = call f1(f5.m0)
    return %1
  }
}
.fn dummy #f0 : fn(int32) -> int32
.freevars ()
.entry b0 {
  .bb #b0 () {
    return $f0
  }
}
.fn landins_kont #f1 : fn(closure(closure(int32) -> int32) -> closure(int32) -> int32) -> closure(int32) -> int32
.freevars ()
.entry b0 {
  .bb #b0 () {
    let _ = alloc <m0: closure(int32) -> int32 heap(1)> <- [0] = f0
    let _ = alloc <m1: array[closure(int32) -> int32] heap(1)> <- [..] = f1.m0
    let _ = alloc <m2: closure(int32) -> int32 heap(2)> <- [0] = f2, [1] = f1.m1
    let %3: closure(int32) -> int32 = apply $f0(f1.m2)
    let _ = store closure(int32) -> int32 offset(f1.m1, 0) <- %3
    return %3
  }
}
.fn thunk_a.22 #f8 : fn() -> int32
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: closure(int32) -> int32 = load_symbol ::0
    let %1: int32 = load_symbol ::1
    let %2: int32 = apply %0(%1)
    return %2
  }
}
.fn thunk_start #f11 : fn() -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: unit = call f10()
    return %0
  }
}
.fn aux #f2 : closure(int32) -> int32
.freevars (array[closure(int32) -> int32])
.entry b0 {
  .bb #b0 () {
    let %0: closure(int32) -> int32 = load closure(int32) -> int32 offset(^1, 0)
    let %1: int32 = apply %0($f0)
    return %1
  }
}
.fn g #f9 : fn(int32) -> int32
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: int32 = load_symbol ::2
    let %1: int32 = add($f0, %0)
    return %1
  }
}
.fn h #f4 : closure(int32) -> int32
.freevars (closure(int32) -> int32)
.entry b0 {
  .bb #b0 () {
    let %0: bool = eq($f0, 0)
    br %0 b1() b2()
  }
  .bb #b1 () {
    jump b3(1)
  }
  .bb #b2 () {
    let %1: int32 = sub($f0, 1)
    let %2: int32 = apply ^1(%1)
    let %3: int32 = mul($f0, %2)
    jump b3(%3)
  }
  .bb #b3 (int32) {
    return $b3.0
  }
}
.thunk ::0 factorial.18
.thunk ::1 _21
.thunk ::2 a.22
.thunk ::3 start

  .p2align 3
  .globl _start
  .type _start, @function
_start:
; block info: defs: [t1, ft0, ft1, a1, t5, fa1, fa2, ft6, a4, fa6, t6, a6, ft10, ft5, ft7, ft4, ft9, a5, a0, fa4, ft2, a2, a3, ft8, t3, a7, fa7, t0, fa5, fa3, ft3, fa0, t4, t2], uses: [a0, t6], upward_exposed: [], params_defs: []
; live_in: [], live_out: []
; block parameters: []
_start_b0:
  call thunk_factorial.18  ; live: [a0]
  la t6, factorial.18  ; live: [a0, t6]
  sd a0, 0(t6)  ; live: []
  call thunk__21  ; live: [a0]
  la t6, _21  ; live: [a0, t6]
  sw a0, 0(t6)  ; live: []
  call thunk_a.22  ; live: [a0]
  la t6, a.22  ; live: [a0, t6]
  sw a0, 0(t6)  ; live: []
  call thunk_start  ; live: [a0]
; control
  ret  ; live: []

  .p2align 3
  .globl init
  .type init, @function
init:
; block info: defs: [v3, t1, v7, ft0, ft1, a1, t5, fa1, fa2, ft6, a4, fa6, a6, ft5, ft10, v4, ft7, ft4, v5, v10, ft9, a5, a0, fa4, ft2, a2, a3, ft8, t3, a7, fa7, t0, fa5, fa3, ft3, fa0, t4, t2, v2], uses: [v5, v10, a0, zero, v7, v4, v2], upward_exposed: [zero], params_defs: []
; live_in: [zero], live_out: []
; block parameters: []
.init_b0:
  li v10, 10  ; live: [v10, zero]
  mv a0, v10  ; live: [zero, a0]
  call g  ; live: [zero, a0]
  mv v2, a0  ; live: [zero, v2]
  mv a0, v2  ; live: [zero, a0]
  call minimbt_print_int  ; live: [zero]
  mv v3, zero  ; live: [zero]
  li v7, 31  ; live: [zero, v7]
  mv a0, v7  ; live: [zero, a0]
  call g  ; live: [zero, a0]
  mv v4, a0  ; live: [v4, zero]
  mv a0, v4  ; live: [zero, a0]
  call minimbt_print_int  ; live: [zero]
  mv v5, zero  ; live: [v5, zero]
; control
  mv a0, v5  ; live: [zero, a0]
  ret  ; live: [zero]

  .p2align 3
  .globl thunk__21
  .type thunk__21, @function
thunk__21:
; block info: defs: [a0, v2], uses: [a0, v2], upward_exposed: [], params_defs: []
; live_in: [], live_out: []
; block parameters: []
.thunk__21_b0:
; control
  li v2, 5  ; live: [v2]
  mv a0, v2  ; live: [a0]
  ret  ; live: []

  .p2align 3
  .globl thunk_factorial.18
  .type thunk_factorial.18, @function
thunk_factorial.18:
; block info: defs: [t1, ft0, ft1, a1, t5, fa1, fa2, ft6, a4, fa6, v8, a6, ft10, ft5, v4, v6, ft7, ft4, ft9, a5, a0, fa4, ft2, a2, a3, ft8, t3, a7, fa7, t0, fa5, fa3, ft3, fa0, t4, t2, v2], uses: [a0, v8, v4, v6, s11, v2], upward_exposed: [s11], params_defs: []
; live_in: [s11], live_out: []
; block parameters: []
.thunk_factorial.18_b0:
  addi v6, s11, -8  ; live: [v6, s11]
  andi v2, v6, -8  ; live: [s11, v2]
  la v8, g  ; live: [v8, s11, v2]
  sd v8, 0(v2)  ; live: [s11, v2]
  mv a0, v2  ; live: [s11, a0]
  call landins_kont  ; live: [s11, a0]
  mv v4, a0  ; live: [v4, s11]
; control
  mv a0, v4  ; live: [s11, a0]
  ret  ; live: [s11]

  .p2align 3
  .globl dummy
  .type dummy, @function
dummy:
; block info: defs: [a0, v2], uses: [a0, v2], upward_exposed: [a0], params_defs: []
; live_in: [a0], live_out: []
; block parameters: []
.dummy_b0:
  mv v2, a0  ; live: [v2]
; control
  mv a0, v2  ; live: [a0]
  ret  ; live: [a0]

  .p2align 3
  .globl landins_kont
  .type landins_kont, @function
landins_kont:
; block info: defs: [v2, t1, v13, v22, ft0, ft1, a1, v12, t5, fa1, fa2, ft6, v20, a4, fa6, a6, ft5, ft10, v4, ft7, v11, ft4, v5, ft9, a5, a0, fa4, ft2, a2, v17, a3, s10, v9, ft8, t3, a7, fa7, t0, fa5, v18, fa3, ft3, fa0, t4, t2, v15, v3], uses: [v3, v11, v5, a0, v22, v17, s11, v12, v9, v18, zero, v20, v4, v15, v2], upward_exposed: [s11, a0, zero], params_defs: []
; live_in: [s11, a0, zero], live_out: []
; block parameters: []
.landins_kont_b0:
  mv v2, a0  ; live: [zero, s11, v2]
  addi v20, s11, -8  ; live: [zero, v20, s11, v2]
  andi v3, v20, -8  ; live: [v3, zero, s11, v2]
  la v22, dummy  ; live: [v3, zero, v22, s11, v2]
  sd v22, 0(v3)  ; live: [v3, zero, s11, v2]
  addi v18, s11, -8  ; live: [v3, v18, zero, s11, v2]
  andi v4, v18, -8  ; live: [v3, zero, v4, s11, v2]
  sd v3, 0(v4)  ; live: [zero, v4, s11, v2]
  addi v15, s11, -16  ; live: [zero, v4, s11, v15, v2]
  andi v5, v15, -8  ; live: [v5, zero, v4, s11, v2]
  la v17, aux  ; live: [v5, zero, v4, v17, s11, v2]
  sd v17, 0(v5)  ; live: [v4, v5, s11, zero, v2]
  sd v4, 8(v5)  ; live: [v4, v5, s11, zero, v2]
  mv s10, v2  ; live: [v4, v5, s11, zero, v2]
  ld v13, 0(v2)  ; live: [v4, v5, s11, zero]
  mv a0, v5  ; live: [v4, s11, zero, a0]
  jalr v13  ; live: [v4, s11, zero, a0]
  mv v9, a0  ; live: [v4, s11, zero, v9]
  slli v11, zero, 3  ; live: [v11, v4, s11, zero, v9]
  add v12, v4, v11  ; live: [s11, v12, zero, v9]
  sd v9, 0(v12)  ; live: [s11, zero, v9]
; control
  mv a0, v9  ; live: [s11, a0, zero]
  ret  ; live: [s11, a0, zero]

  .p2align 3
  .globl thunk_a.22
  .type thunk_a.22, @function
thunk_a.22:
; block info: defs: [v2, t1, v7, ft0, ft1, a1, t5, fa1, fa2, ft6, a4, fa6, a6, ft5, ft10, v4, ft7, ft4, v5, ft9, a5, a0, fa4, ft2, a2, a3, v9, s10, ft8, a7, t3, fa7, t0, fa5, fa3, ft3, fa0, t4, t2, v3], uses: [v3, a0, v7, v4, v9, v2], upward_exposed: [], params_defs: []
; live_in: [], live_out: []
; block parameters: []
.thunk_a.22_b0:
  la v9, factorial.18  ; live: [v9]
  ld v2, 0(v9)  ; live: [v2]
  la v7, _21  ; live: [v7, v2]
  lw v3, 0(v7)  ; live: [v2, v3]
  mv s10, v2  ; live: [v2, v3]
  ld v5, 0(v2)  ; live: [v3]
  mv a0, v3  ; live: [a0]
  jalr v5  ; live: [a0]
  mv v4, a0  ; live: [v4]
; control
  mv a0, v4  ; live: [a0]
  ret  ; live: []

  .p2align 3
  .globl thunk_start
  .type thunk_start, @function
thunk_start:
; block info: defs: [t1, ft0, ft1, a1, t5, fa1, fa2, ft6, a4, fa6, a6, ft5, ft10, ft7, ft4, ft9, a5, a0, fa4, ft2, a2, a3, ft8, t3, a7, fa7, t0, fa5, fa3, ft3, fa0, t4, t2, v2], uses: [zero, a0, v2], upward_exposed: [zero], params_defs: []
; live_in: [zero], live_out: []
; block parameters: []
.thunk_start_b0:
  call init  ; live: [zero]
  mv v2, zero  ; live: [zero, v2]
; control
  mv a0, v2  ; live: [zero, a0]
  ret  ; live: [zero]

  .p2align 3
  .globl aux
  .type aux, @function
aux:
; block info: defs: [v2, t1, v0, ft0, ft1, a1, t5, fa1, fa2, ft6, a4, fa6, v8, a6, ft5, ft10, v4, v6, ft7, ft4, v5, ft9, a5, a0, fa4, ft2, a2, a3, s10, v9, ft8, t3, a7, fa7, t0, fa5, fa3, ft3, fa0, t4, t2, v3], uses: [v2, v5, a0, zero, v8, v0, v4, s10, v9, v3], upward_exposed: [s10, a0, zero], params_defs: []
; live_in: [s10, a0, zero], live_out: []
; block parameters: []
.aux_b0:
  mv v0, s10  ; live: [v0, zero, a0]
  mv v2, a0  ; live: [v0, zero, v2]
  lw v3, 8(v0)  ; live: [v3, zero, v2]
  slli v8, zero, 3  ; live: [v3, v8, zero, v2]
  add v9, v3, v8  ; live: [zero, v9, v2]
  ld v4, 0(v9)  ; live: [v4, zero, v2]
  mv s10, v4  ; live: [v4, s10, zero, v2]
  ld v6, 0(v4)  ; live: [s10, zero, v2]
  mv a0, v2  ; live: [s10, zero, a0]
  jalr v6  ; live: [s10, zero, a0]
  mv v5, a0  ; live: [v5, s10, zero]
; control
  mv a0, v5  ; live: [s10, a0, zero]
  ret  ; live: [s10, a0, zero]

  .p2align 3
  .globl g
  .type g, @function
g:
; block info: defs: [v3, v7, v5, a0, v2], uses: [v2, v5, a0, v7, s11, v3], upward_exposed: [s11, a0], params_defs: []
; live_in: [s11, a0], live_out: []
; block parameters: []
.g_b0:
  mv v2, a0  ; live: [s11, v2]
  addi v5, s11, -16  ; live: [v5, s11, v2]
  andi v3, v5, -8  ; live: [v2, s11, v3]
  la v7, h  ; live: [v2, v7, s11, v3]
  sd v7, 0(v3)  ; live: [v2, s11, v3]
  sd v2, 8(v3)  ; live: [s11, v3]
; control
  mv a0, v3  ; live: [s11, a0]
  ret  ; live: [s11, a0]

  .p2align 3
  .globl h
  .type h, @function
h:
; block info: defs: [v3, v0, v4, v15, v2], uses: [a0, zero, v0, v4, v15, s10, v2], upward_exposed: [s10, a0, zero], params_defs: []
; live_in: [s10, a0, zero], live_out: [v3, v2]
; block parameters: []
.h_b0:
  mv v0, s10  ; live: [v0, s10, a0, zero]
  mv v2, a0  ; live: [v2, v0, s10, a0, zero]
  lw v3, 8(v0)  ; live: [v2, s10, a0, zero]
  xor v15, v2, zero  ; live: [v15, s10, a0, zero]
  sltiu v4, v15, 1  ; live: [v4, s10, a0, zero]
; control
  bne v4, zero, .h_b1  ; live: [s10, a0, zero]
  j .h_b2  ; live: [s10, a0, zero]

; block info: defs: [v9, v8], uses: [v9], upward_exposed: [], params_defs: []
; live_in: [], live_out: [v8]
; block parameters: []
.h_b1:
; control
  li v9, 1  ; live: [v9]
  mv v8, v9  ; live: []
  j .h_b3  ; live: []

; block info: defs: [a0], uses: [a0, v8], upward_exposed: [v8], params_defs: [v8]
; live_in: [v8], live_out: []
; block parameters: [v8]
.h_b3:
; control
  mv a0, v8  ; live: [a0, v8]
  ret  ; live: [v8]

; block info: defs: [t1, v13, v7, ft0, ft1, a1, t5, fa1, fa2, ft6, a4, fa6, v8, a6, ft10, ft5, v6, ft7, v11, ft4, v5, ft9, a5, a0, fa4, ft2, a2, a3, s10, ft8, t3, a7, fa7, t0, fa5, fa3, ft3, fa0, t4, t2], uses: [v2, v5, v13, a0, v7, v6, v3], upward_exposed: [v3, v2], params_defs: []
; live_in: [v2, v3], live_out: [v8]
; block parameters: []
.h_b2:
  li v13, 1  ; live: [v3, v13, v2]
  sub v5, v2, v13  ; live: [v3, v5, v2]
  mv s10, v3  ; live: [v3, v5, v2]
  ld v11, 0(v3)  ; live: [v3, v5, v2]
  mv a0, v5  ; live: [v3, a0, v2]
  jalr v11  ; live: [v3, a0, v2]
  mv v6, a0  ; live: [v3, v6, v2]
  mulw v7, v2, v6  ; live: [v3, v7, v2]
; control
  mv v8, v7  ; live: [v3, v2]
  j .h_b3  ; live: [v3, v2]

  .p2align 3
  .globl _21
  .type _21, @object
_21:
  .zero 4
  .p2align 3
  .globl a.22
  .type a.22, @object
a.22:
  .zero 4
  .p2align 3
  .globl start
  .type start, @object
start:
  .zero 4
  .p2align 3
  .globl factorial.18
  .type factorial.18, @object
factorial.18:
  .zero 8



Testing test/test_src/matmul-flat.mbt
# name conventions used in the core ir:
# - functions: f<id>
# - blocks: b<id>
# - instructions: %<id>
# - memory: m<id>
# - free variables: ^<id>
# - function parameters: $f<pid>
# - block parameters: $b<bid>.<pid>
.core
.fn loop2 #f1 : fn(int32, int32, int32, array[array[double]], array[array[double]], array[array[double]]) -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: bool = le(0, $f2)
    br %0 b1() b2()
  }
  .bb #b1 () {
    let %1: int32 = sub($f1, 1)
    let %2: unit = call f0($f0, $f2, %1, $f3, $f4, $f5)
    let %3: int32 = sub($f2, 1)
    let %4: unit = call f1($f0, $f1, %3, $f3, $f4, $f5)
    jump b3(%4)
  }
  .bb #b2 () {
    jump b3(())
  }
  .bb #b3 (unit) {
    return $b3.0
  }
}
.fn init_arr #f5 : closure(int32, int32, array[array[double]]) -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: bool = le(0, $f0)
    br %0 b1() b2()
  }
  .bb #b1 () {
    let _ = alloc <m0: array[double] heap($f1)> <- [..] = 0
    let _ = store array[double] offset($f2, $f0) <- f5.m0
    let %3: int32 = sub($f0, 1)
    let %4: unit = apply self(%3, $f1, $f2)
    jump b3(%4)
  }
  .bb #b2 () {
    jump b3(())
  }
  .bb #b3 (unit) {
    return $b3.0
  }
}
.fn thunk_start #f7 : fn() -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: unit = call f4()
    return %0
  }
}
.fn mul #f3 : fn(int32, int32, int32, array[array[double]], array[array[double]], array[array[double]]) -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: int32 = sub($f0, 1)
    let %1: unit = call f2(%0, $f1, $f2, $f3, $f4, $f5)
    return ()
  }
}
.fn loop3 #f0 : fn(int32, int32, int32, array[array[double]], array[array[double]], array[array[double]]) -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: bool = le(0, $f2)
    br %0 b1() b2()
  }
  .bb #b1 () {
    let %1: array[double] = load array[double] offset($f5, $f0)
    let %2: array[double] = load array[double] offset($f5, $f0)
    let %3: double = load double offset(%2, $f1)
    let %4: array[double] = load array[double] offset($f3, $f0)
    let %5: double = load double offset(%4, $f2)
    let %6: array[double] = load array[double] offset($f4, $f2)
    let %7: double = load double offset(%6, $f1)
    let %8: double = mul(%5, %7)
    let %9: double = add(%3, %8)
    let _ = store double offset(%1, $f1) <- %9
    let %11: int32 = sub($f2, 1)
    let %12: unit = call f0($f0, $f1, %11, $f3, $f4, $f5)
    jump b3(%12)
  }
  .bb #b2 () {
    jump b3(())
  }
  .bb #b3 (unit) {
    return $b3.0
  }
}
.fn loop1 #f2 : fn(int32, int32, int32, array[array[double]], array[array[double]], array[array[double]]) -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: bool = le(0, $f0)
    br %0 b1() b2()
  }
  .bb #b1 () {
    let %1: int32 = sub($f2, 1)
    let %2: unit = call f1($f0, $f1, %1, $f3, $f4, $f5)
    let %3: int32 = sub($f0, 1)
    let %4: unit = call f2(%3, $f1, $f2, $f3, $f4, $f5)
    jump b3(%4)
  }
  .bb #b2 () {
    jump b3(())
  }
  .bb #b3 (unit) {
    return $b3.0
  }
}
.fn make_arr #f6 : closure(int32, int32, array[double]) -> array[array[double]]
.freevars (closure(int32, int32, array[array[double]]) -> unit)
.entry b0 {
  .bb #b0 () {
    let _ = alloc <m0: array[array[double]] heap($f0)> <- [..] = $f2
    let %1: int32 = sub($f0, 1)
    let %2: unit = apply ^1(%1, $f1, f6.m0)
    return f6.m0
  }
}
.fn main #f4 : fn() -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let _ = alloc <m0: array[double] heap(0)> <- [..] = 0
    let _ = alloc <m1: closure(int32, int32, array[array[double]]) -> unit heap(1)> <- [0] = f5
    let _ = alloc <m2: closure(int32, int32, array[double]) -> array[array[double]] heap(2)> <- [0] = f6, [1] = f4.m1
    let %3: array[array[double]] = apply f4.m2(2, 3, f4.m0)
    let %4: array[array[double]] = apply f4.m2(3, 2, f4.m0)
    let %5: array[array[double]] = apply f4.m2(2, 2, f4.m0)
    let %6: array[double] = load array[double] offset(%3, 0)
    let _ = store double offset(%6, 0) <- 1
    let %8: array[double] = load array[double] offset(%3, 0)
    let _ = store double offset(%8, 1) <- 2
    let %10: array[double] = load array[double] offset(%3, 0)
    let _ = store double offset(%10, 2) <- 3
    let %12: array[double] = load array[double] offset(%3, 1)
    let _ = store double offset(%12, 0) <- 4
    let %14: array[double] = load array[double] offset(%3, 1)
    let _ = store double offset(%14, 1) <- 5
    let %16: array[double] = load array[double] offset(%3, 1)
    let _ = store double offset(%16, 2) <- 6
    let %18: array[double] = load array[double] offset(%4, 0)
    let _ = store double offset(%18, 0) <- 7
    let %20: array[double] = load array[double] offset(%4, 0)
    let _ = store double offset(%20, 1) <- 8
    let %22: array[double] = load array[double] offset(%4, 1)
    let _ = store double offset(%22, 0) <- 9
    let %24: array[double] = load array[double] offset(%4, 1)
    let _ = store double offset(%24, 1) <- 10
    let %26: array[double] = load array[double] offset(%4, 2)
    let _ = store double offset(%26, 0) <- 11
    let %28: array[double] = load array[double] offset(%4, 2)
    let _ = store double offset(%28, 1) <- 12
    let %30: unit = call f3(2, 3, 2, %3, %4, %5)
    let %31: array[double] = load array[double] offset(%5, 0)
    let %32: double = load double offset(%31, 0)
    let %33: int32 = ext_call minimbt_truncate(%32)
    let %34: unit = ext_call minimbt_print_int(%33)
    let %35: unit = ext_call minimbt_print_endline()
    let %36: array[double] = load array[double] offset(%5, 0)
    let %37: double = load double offset(%36, 1)
    let %38: int32 = ext_call minimbt_truncate(%37)
    let %39: unit = ext_call minimbt_print_int(%38)
    let %40: unit = ext_call minimbt_print_endline()
    let %41: array[double] = load array[double] offset(%5, 1)
    let %42: double = load double offset(%41, 0)
    let %43: int32 = ext_call minimbt_truncate(%42)
    let %44: unit = ext_call minimbt_print_int(%43)
    let %45: unit = ext_call minimbt_print_endline()
    let %46: array[double] = load array[double] offset(%5, 1)
    let %47: double = load double offset(%46, 1)
    let %48: int32 = ext_call minimbt_truncate(%47)
    let %49: unit = ext_call minimbt_print_int(%48)
    return ()
  }
}
.thunk ::0 start

  .p2align 3
  .globl loop2
  .type loop2, @function
loop2:
; block info: defs: [v2, v5, v20, v7, v8, v4, v6, v3], uses: [a5, a0, zero, a4, v20, v8, v4, a2, a1, a3], upward_exposed: [a5, a0, zero, a4, a2, a1, a3], params_defs: []
; live_in: [a5, a0, zero, a4, a2, a1, a3], live_out: [v3, v5, zero, v7, v4, v6, v2]
; block parameters: []
.loop2_b0:
  mv v2, a0  ; live: [a5, a0, zero, a4, a2, a1, a3]
  mv v3, a1  ; live: [a5, a0, zero, a4, a2, a1, a3]
  mv v4, a2  ; live: [a5, a0, zero, a4, a2, v4, a1, a3]
  mv v5, a3  ; live: [a5, a0, zero, a4, a2, v4, a1, a3]
  mv v6, a4  ; live: [a5, a0, zero, a4, a2, v4, a1, a3]
  mv v7, a5  ; live: [a5, a0, zero, a4, a2, v4, a1, a3]
  slt v20, zero, v4  ; live: [a5, a0, zero, a4, v20, a2, a1, a3]
  xori v8, v20, 1  ; live: [a5, a0, zero, a4, v8, a2, a1, a3]
; control
  bne v8, zero, .loop2_b1  ; live: [a5, a0, zero, a4, a2, a1, a3]
  j .loop2_b2  ; live: [a5, a0, zero, a4, a2, a1, a3]

; block info: defs: [v13], uses: [zero], upward_exposed: [zero], params_defs: []
; live_in: [zero], live_out: [v13]
; block parameters: []
.loop2_b2:
; control
  mv v13, zero  ; live: [zero]
  j .loop2_b3  ; live: [zero]

; block info: defs: [a0], uses: [v13, a0], upward_exposed: [v13], params_defs: [v13]
; live_in: [v13], live_out: []
; block parameters: [v13]
.loop2_b3:
; control
  mv a0, v13  ; live: [v13, a0]
  ret  ; live: [v13]

; block info: defs: [t1, v13, ft0, ft1, a1, v12, t5, fa1, fa2, ft6, a4, fa6, a6, ft5, ft10, ft7, v11, ft4, ft9, v10, a5, fa4, a0, ft2, a2, a3, v9, ft8, a7, t3, fa7, t0, fa5, v18, fa3, ft3, fa0, t4, t2, v15], uses: [v2, v11, v5, a5, a0, v7, a2, a1, a3, v12, v9, v18, zero, a4, v4, v6, v15, v3], upward_exposed: [v3, v5, zero, v7, v4, v6, v2], params_defs: []
; live_in: [v2, v5, zero, v7, v4, v6, v3], live_out: [v13]
; block parameters: []
.loop2_b1:
  li v18, 1  ; live: [v3, v5, v18, zero, v7, v4, v6, v2]
  sub v9, v3, v18  ; live: [v3, v5, zero, v7, v4, v6, v9, v2]
  mv a0, v2  ; live: [v3, v5, zero, a0, v7, v4, v6, v9, v2]
  mv a1, v4  ; live: [v3, v5, zero, a0, v7, v4, a1, v6, v9, v2]
  mv a2, v9  ; live: [v3, v5, zero, a0, v7, v4, a2, a1, v6, v2]
  mv a3, v5  ; live: [v3, v5, zero, a0, v7, v4, a2, a1, v6, a3, v2]
  mv a4, v6  ; live: [v3, v5, zero, a0, a4, v7, v4, a2, a1, v6, a3, v2]
  mv a5, v7  ; live: [v3, v5, a5, zero, a0, a4, v7, v4, a2, a1, v6, a3, v2]
  call loop3  ; live: [v3, v5, zero, v7, v4, v6, v2]
  mv v10, zero  ; live: [v3, v5, zero, v7, v4, v6, v2]
  li v15, 1  ; live: [v3, v5, zero, v7, v4, v6, v15, v2]
  sub v11, v4, v15  ; live: [v3, v11, v5, zero, v7, v4, v6, v2]
  mv a0, v2  ; live: [v3, v11, v5, zero, a0, v7, v4, v6, v2]
  mv a1, v3  ; live: [v3, v11, v5, zero, a0, v7, v4, a1, v6, v2]
  mv a2, v11  ; live: [v3, v5, zero, a0, v7, v4, a2, a1, v6, v2]
  mv a3, v5  ; live: [v3, v5, zero, a0, v7, v4, a2, a1, v6, a3, v2]
  mv a4, v6  ; live: [v3, v5, zero, a0, a4, v7, v4, a2, a1, v6, a3, v2]
  mv a5, v7  ; live: [v3, v5, a5, zero, a0, a4, v7, v4, a2, a1, v6, a3, v2]
  call loop2  ; live: [v3, v5, zero, v7, v4, v6, v2]
  mv v12, zero  ; live: [v3, v5, zero, v7, v4, v6, v12, v2]
; control
  mv v13, v12  ; live: [v3, v5, zero, v7, v4, v6, v2]
  j .loop2_b3  ; live: [v3, v5, zero, v7, v4, v6, v2]

  .p2align 3
  .globl _start
  .type _start, @function
_start:
; block info: defs: [t1, ft0, ft1, a1, t5, fa1, fa2, ft6, a4, fa6, a6, ft5, ft10, ft7, ft4, ft9, a5, a0, fa4, ft2, a2, a3, ft8, t3, a7, fa7, t0, fa5, fa3, ft3, fa0, t4, t2], uses: [a0], upward_exposed: [], params_defs: []
; live_in: [], live_out: []
; block parameters: []
_start_b0:
  call thunk_start  ; live: [a0]
; control
  ret  ; live: []

  .p2align 3
  .globl make_arr
  .type make_arr, @function
make_arr:
; block info: defs: [v2, t1, v14, v0, ft0, ft1, a1, v12, t5, fa1, fa2, ft6, a4, fa6, v8, a6, ft5, ft10, v4, v6, ft7, ft4, v5, ft9, v10, a5, fa4, a0, ft2, a2, a3, s10, v9, ft8, t3, a7, fa7, t0, fa5, fa3, ft3, fa0, t4, t2, v15, v3], uses: [v3, v14, v5, a0, v0, a2, a1, s11, v12, s10, zero, v8, v4, v6, v15, v2], upward_exposed: [a2, a1, s11, s10, a0, zero], params_defs: []
; live_in: [a0, zero, a2, a1, s11, s10], live_out: []
; block parameters: []
.make_arr_b0:
  mv v0, s10  ; live: [zero, a0, v0, a2, a1, s11]
  mv v2, a0  ; live: [zero, v0, a2, a1, s11, v2]
  mv v3, a1  ; live: [v2, zero, v0, a2, s11, v3]
  mv v4, a2  ; live: [v2, zero, v0, v4, s11, v3]
  lw v5, 8(v0)  ; live: [v2, v5, zero, v4, s11, v3]
  slli v14, v2, 3  ; live: [v2, v5, v14, zero, v4, s11, v3]
  sub v15, s11, v14  ; live: [v2, v5, zero, v4, s11, v15, v3]
  andi v6, v15, -8  ; live: [v2, v5, zero, v4, v6, s11, v3]
  mv a1, v2  ; live: [v2, v5, zero, v4, v6, a1, s11, v3]
  mv a0, v6  ; live: [v2, v5, zero, a0, v4, v6, a1, s11, v3]
  mv a2, v4  ; live: [v2, v5, zero, a0, a2, v6, a1, s11, v3]
  call _memseti32  ; live: [v2, v5, zero, v6, s11, v3]
  li v12, 1  ; live: [v2, v5, zero, v6, s11, v12, v3]
  sub v8, v2, v12  ; live: [v5, zero, v8, v6, s11, v3]
  mv s10, v5  ; live: [v5, zero, v8, v6, s11, s10, v3]
  ld v10, 0(v5)  ; live: [zero, v8, v6, s11, s10, v3]
  mv a0, v8  ; live: [zero, a0, v6, s11, s10, v3]
  mv a1, v3  ; live: [zero, a0, v6, a1, s11, s10]
  mv a2, v6  ; live: [zero, a0, a2, v6, a1, s11, s10]
  jalr v10  ; live: [zero, a2, a1, v6, s11, s10]
  mv v9, zero  ; live: [zero, a2, a1, v6, s11, s10]
; control
  mv a0, v6  ; live: [a0, zero, a2, a1, s11, s10]
  ret  ; live: [a2, a1, s11, a0, zero, s10]

  .p2align 3
  .globl main
  .type main, @function
main:
; block info: defs: [v153, v91, v58, fv190, v79, v159, v150, a1, fv47, t5, v44, fa1, v191, v82, fa2, fv174, v169, fv125, v50, v151, a6, ft10, v59, v102, v154, v117, v62, ft4, v10, ft9, v119, v110, v92, v184, fv148, v43, v206, fv182, a7, fv108, v205, v156, v48, v96, fv116, v181, v163, v132, v40, v25, fv52, v194, v179, ft0, ft1, v41, v177, v143, v192, v185, v173, v98, v193, v161, v130, v29, v8, v105, v89, fv216, v21, v121, v53, a2, v198, v160, v9, v145, v186, ft8, t3, v176, v112, fv157, fa5, v23, t4, v80, v15, v135, v2, v95, v200, v33, v73, v51, v168, v63, fv99, ft6, a4, fa6, v27, v183, ft5, v170, v210, v144, v137, v129, v54, fv37, v165, v49, v171, fa4, v208, ft2, v17, a3, v147, v196, v31, v113, v201, v167, fv166, v101, fa7, fv141, fa3, v204, v68, fv42, ft3, v45, v136, v104, v213, v140, t2, v61, v3, t1, v69, v162, v127, v13, v120, v107, v134, v149, fv133, v115, v109, v142, v126, v197, v19, v103, v4, v128, v57, v122, ft7, v11, v71, v46, a5, a0, v158, v211, v78, v36, v88, v111, v202, s10, v214, v187, v138, v39, v118, v175, v94, t0, v72, v124, v178, v35, fa0, v152, v38, v83, v100, v189], uses: [v153, v91, v58, fv190, v79, v159, v150, a1, s11, fv47, v191, v82, fv174, v169, fv125, v151, v59, v154, v117, v102, v62, v10, v119, v110, v92, v184, fv148, v43, v206, fv182, fv108, v205, v156, v48, v96, fv116, v181, v163, v132, v25, fv52, v194, v179, v41, v177, v192, v143, v185, v173, v193, v98, v161, v130, zero, v29, v8, v105, v89, v21, v121, v53, a2, v198, v160, v145, v9, v186, v176, v112, fv157, v23, v80, v15, v135, v2, v95, v33, v73, v51, v168, v63, fv99, v27, a4, v183, v170, v144, v137, v129, v210, v165, fv37, v171, v208, v17, a3, v147, v31, v113, v201, v167, fv166, v101, fv141, v68, fv42, v136, v104, v213, v140, v61, v3, v162, v69, v127, v13, v120, v134, v107, v149, fv133, v115, v109, v142, v126, v197, v19, v103, v4, v128, v57, v122, v11, v71, v46, a5, a0, v158, v211, v78, v36, v88, v111, v202, v214, v138, v187, v118, v175, v94, v72, v124, v178, v152, fa0, v38, v83, v100, v189], upward_exposed: [s11, zero], params_defs: []
; live_in: [s11, zero], live_out: []
; block parameters: []
.main_b0:
  addi v214, s11, 0  ; live: [zero, s11, v214]
  andi v2, v214, -8  ; live: [zero, s11, v2]
  fmv.d.x fv216, zero  ; live: [zero, s11, v2]
  addi v211, s11, -8  ; live: [zero, v211, s11, v2]
  andi v3, v211, -8  ; live: [v3, zero, s11, v2]
  la v213, init_arr  ; live: [v3, zero, v213, s11, v2]
  sd v213, 0(v3)  ; live: [v3, zero, s11, v2]
  addi v208, s11, -16  ; live: [v3, zero, v208, s11, v2]
  andi v4, v208, -8  ; live: [v3, zero, v4, s11, v2]
  la v210, make_arr  ; live: [v3, zero, v4, s11, v210, v2]
  sd v210, 0(v4)  ; live: [v3, zero, v4, s11, v2]
  sd v3, 8(v4)  ; live: [zero, v4, s11, v2]
  mv s10, v4  ; live: [zero, v4, s11, v2]
  ld v204, 0(v4)  ; live: [zero, v4, s11, v2]
  li v205, 2  ; live: [v205, zero, v4, s11, v2]
  mv a0, v205  ; live: [zero, a0, v4, s11, v2]
  li v206, 3  ; live: [zero, a0, v4, s11, v206, v2]
  mv a1, v206  ; live: [zero, a0, v4, a1, s11, v2]
  mv a2, v2  ; live: [zero, a0, v4, a2, a1, s11, v2]
  jalr v204  ; live: [zero, a0, v4, s11, v2]
  mv v8, a0  ; live: [zero, v8, v4, s11, v2]
  mv s10, v4  ; live: [zero, v8, v4, s11, v2]
  ld v200, 0(v4)  ; live: [zero, v8, v4, s11, v2]
  li v201, 3  ; live: [zero, v8, v4, s11, v201, v2]
  mv a0, v201  ; live: [zero, a0, v8, v4, s11, v2]
  li v202, 2  ; live: [zero, a0, v8, v4, s11, v202, v2]
  mv a1, v202  ; live: [zero, a0, v8, v4, a1, s11, v2]
  mv a2, v2  ; live: [zero, a0, v8, v4, a2, a1, s11, v2]
  jalr v200  ; live: [zero, a0, v8, v4, s11, v2]
  mv v9, a0  ; live: [zero, v8, v4, s11, v9, v2]
  mv s10, v4  ; live: [zero, v8, v4, s11, v9, v2]
  ld v196, 0(v4)  ; live: [zero, v8, s11, v9, v2]
  li v197, 2  ; live: [zero, v8, v197, s11, v9, v2]
  mv a0, v197  ; live: [zero, a0, v8, s11, v9, v2]
  li v198, 2  ; live: [zero, a0, v8, v198, s11, v9, v2]
  mv a1, v198  ; live: [zero, a0, v8, a1, s11, v9, v2]
  mv a2, v2  ; live: [zero, a0, v8, a2, a1, s11, v9]
  jalr v196  ; live: [zero, a0, v8, s11, v9]
  mv v10, a0  ; live: [v10, zero, v8, s11, v9]
  slli v193, zero, 3  ; live: [v10, zero, v8, s11, v9, v193]
  add v194, v8, v193  ; live: [v194, v10, zero, v8, s11, v9]
  ld v11, 0(v194)  ; live: [v11, v10, zero, v8, s11, v9]
  li v189, 4607182418800017408  ; live: [v11, v10, zero, v8, s11, v9, v189]
  fmv.d.x fv190, v189  ; live: [v11, v10, fv190, zero, v8, s11, v9]
  slli v191, zero, 3  ; live: [v11, v10, fv190, zero, v8, s11, v9, v191]
  add v192, v11, v191  ; live: [v10, fv190, zero, v8, s11, v192, v9]
  fsd fv190, 0(v192)  ; live: [v10, zero, v8, s11, v9]
  slli v186, zero, 3  ; live: [v10, zero, v8, s11, v9, v186]
  add v187, v8, v186  ; live: [v10, zero, v8, s11, v9, v187]
  ld v13, 0(v187)  ; live: [v10, zero, v13, v8, s11, v9]
  li v181, 4611686018427387904  ; live: [v10, zero, v13, v8, v181, s11, v9]
  fmv.d.x fv182, v181  ; live: [fv182, v10, zero, v13, v8, s11, v9]
  li v183, 1  ; live: [fv182, v10, zero, v13, v8, v183, s11, v9]
  slli v184, v183, 3  ; live: [fv182, v10, zero, v13, v8, v184, s11, v9]
  add v185, v13, v184  ; live: [fv182, v10, zero, v8, s11, v9, v185]
  fsd fv182, 0(v185)  ; live: [v10, zero, v8, s11, v9]
  slli v178, zero, 3  ; live: [v10, zero, v178, v8, s11, v9]
  add v179, v8, v178  ; live: [v10, v179, zero, v8, s11, v9]
  ld v15, 0(v179)  ; live: [v10, zero, v8, s11, v15, v9]
  li v173, 4613937818241073152  ; live: [v10, zero, v8, s11, v15, v9, v173]
  fmv.d.x fv174, v173  ; live: [v10, zero, fv174, v8, s11, v15, v9]
  li v175, 2  ; live: [v175, v10, zero, fv174, v8, s11, v15, v9]
  slli v176, v175, 3  ; live: [v176, v10, zero, fv174, v8, s11, v15, v9]
  add v177, v15, v176  ; live: [v10, zero, fv174, v8, v177, s11, v9]
  fsd fv174, 0(v177)  ; live: [v10, zero, v8, s11, v9]
  li v169, 1  ; live: [v10, zero, v169, v8, s11, v9]
  slli v170, v169, 3  ; live: [v10, zero, v8, v170, s11, v9]
  add v171, v8, v170  ; live: [v10, v171, zero, v8, s11, v9]
  ld v17, 0(v171)  ; live: [v10, zero, v8, v17, s11, v9]
  li v165, 4616189618054758400  ; live: [v165, v10, zero, v8, v17, s11, v9]
  fmv.d.x fv166, v165  ; live: [v10, zero, v8, v17, s11, v9, fv166]
  slli v167, zero, 3  ; live: [v10, zero, v8, v17, s11, v9, v167, fv166]
  add v168, v17, v167  ; live: [v168, v10, zero, v8, s11, v9, fv166]
  fsd fv166, 0(v168)  ; live: [v10, zero, v8, s11, v9]
  li v161, 1  ; live: [v10, v161, zero, v8, s11, v9]
  slli v162, v161, 3  ; live: [v162, v10, zero, v8, s11, v9]
  add v163, v8, v162  ; live: [v10, zero, v8, s11, v9, v163]
  ld v19, 0(v163)  ; live: [v10, zero, v8, v19, s11, v9]
  li v156, 4617315517961601024  ; live: [v10, v156, zero, v8, v19, s11, v9]
  fmv.d.x fv157, v156  ; live: [fv157, v10, zero, v8, v19, s11, v9]
  li v158, 1  ; live: [fv157, v10, zero, v158, v8, v19, s11, v9]
  slli v159, v158, 3  ; live: [fv157, v10, zero, v159, v8, v19, s11, v9]
  add v160, v19, v159  ; live: [fv157, v10, zero, v8, s11, v160, v9]
  fsd fv157, 0(v160)  ; live: [v10, zero, v8, s11, v9]
  li v152, 1  ; live: [v10, zero, v8, v152, s11, v9]
  slli v153, v152, 3  ; live: [v153, v10, zero, v8, s11, v9]
  add v154, v8, v153  ; live: [v10, zero, v8, s11, v154, v9]
  ld v21, 0(v154)  ; live: [v10, v21, zero, v8, s11, v9]
  li v147, 4618441417868443648  ; live: [v10, v21, zero, v8, s11, v147, v9]
  fmv.d.x fv148, v147  ; live: [v10, v21, zero, v8, fv148, s11, v9]
  li v149, 2  ; live: [v10, v21, zero, v8, fv148, s11, v9, v149]
  slli v150, v149, 3  ; live: [v10, v21, zero, v8, v150, fv148, s11, v9]
  add v151, v21, v150  ; live: [v10, zero, v8, v151, fv148, s11, v9]
  fsd fv148, 0(v151)  ; live: [v10, zero, v8, s11, v9]
  slli v144, zero, 3  ; live: [v10, zero, v8, s11, v9, v144]
  add v145, v9, v144  ; live: [v10, zero, v8, s11, v9, v145]
  ld v23, 0(v145)  ; live: [v10, zero, v23, v8, s11, v9]
  li v140, 4619567317775286272  ; live: [v10, zero, v23, v8, v140, s11, v9]
  fmv.d.x fv141, v140  ; live: [fv141, v10, zero, v23, v8, s11, v9]
  slli v142, zero, 3  ; live: [fv141, v10, v142, zero, v23, v8, s11, v9]
  add v143, v23, v142  ; live: [fv141, v10, zero, v8, s11, v143, v9]
  fsd fv141, 0(v143)  ; live: [v10, zero, v8, s11, v9]
  slli v137, zero, 3  ; live: [v10, zero, v8, s11, v9, v137]
  add v138, v9, v137  ; live: [v10, zero, v8, s11, v9, v138]
  ld v25, 0(v138)  ; live: [v25, v10, zero, v8, s11, v9]
  li v132, 4620693217682128896  ; live: [v25, v10, zero, v8, s11, v9, v132]
  fmv.d.x fv133, v132  ; live: [v25, v10, zero, v8, s11, v9, fv133]
  li v134, 1  ; live: [v25, v10, zero, v8, v134, s11, v9, fv133]
  slli v135, v134, 3  ; live: [v25, v10, zero, v8, s11, v9, fv133, v135]
  add v136, v25, v135  ; live: [v10, zero, v8, v136, s11, v9, fv133]
  fsd fv133, 0(v136)  ; live: [v10, zero, v8, s11, v9]
  li v128, 1  ; live: [v10, zero, v8, s11, v128, v9]
  slli v129, v128, 3  ; live: [v10, zero, v8, s11, v9, v129]
  add v130, v9, v129  ; live: [v10, v130, zero, v8, s11, v9]
  ld v27, 0(v130)  ; live: [v10, zero, v27, v8, s11, v9]
  li v124, 4621256167635550208  ; live: [v10, v124, zero, v27, v8, s11, v9]
  fmv.d.x fv125, v124  ; live: [v10, zero, v27, fv125, v8, s11, v9]
  slli v126, zero, 3  ; live: [v10, zero, v126, v27, fv125, v8, s11, v9]
  add v127, v27, v126  ; live: [v10, v127, zero, fv125, v8, s11, v9]
  fsd fv125, 0(v127)  ; live: [v10, zero, v8, s11, v9]
  li v120, 1  ; live: [v10, zero, v120, v8, s11, v9]
  slli v121, v120, 3  ; live: [v10, v121, zero, v8, s11, v9]
  add v122, v9, v121  ; live: [v10, zero, v8, s11, v9, v122]
  ld v29, 0(v122)  ; live: [v10, zero, v29, v8, s11, v9]
  li v115, 4621819117588971520  ; live: [v115, v10, zero, v29, v8, s11, v9]
  fmv.d.x fv116, v115  ; live: [v10, zero, v29, v8, fv116, s11, v9]
  li v117, 1  ; live: [v10, zero, v29, v8, fv116, s11, v117, v9]
  slli v118, v117, 3  ; live: [v118, v10, zero, v29, v8, fv116, s11, v9]
  add v119, v29, v118  ; live: [v10, zero, v119, v8, fv116, s11, v9]
  fsd fv116, 0(v119)  ; live: [v10, zero, v8, s11, v9]
  li v111, 2  ; live: [v10, zero, v8, v111, s11, v9]
  slli v112, v111, 3  ; live: [v112, v10, zero, v8, s11, v9]
  add v113, v9, v112  ; live: [v10, zero, v8, s11, v9, v113]
  ld v31, 0(v113)  ; live: [v10, zero, v8, s11, v31, v9]
  li v107, 4622382067542392832  ; live: [v10, zero, v8, v107, s11, v31, v9]
  fmv.d.x fv108, v107  ; live: [fv108, v10, zero, v8, s11, v31, v9]
  slli v109, zero, 3  ; live: [v109, fv108, v10, zero, v8, s11, v31, v9]
  add v110, v31, v109  ; live: [fv108, v10, zero, v110, v8, s11, v9]
  fsd fv108, 0(v110)  ; live: [v10, zero, v8, s11, v9]
  li v103, 2  ; live: [v10, zero, v8, v103, s11, v9]
  slli v104, v103, 3  ; live: [v10, zero, v8, v104, s11, v9]
  add v105, v9, v104  ; live: [v10, zero, v8, v105, s11, v9]
  ld v33, 0(v105)  ; live: [v10, zero, v8, s11, v9, v33]
  li v98, 4622945017495814144  ; live: [v10, zero, v8, s11, v9, v33, v98]
  fmv.d.x fv99, v98  ; live: [v10, fv99, zero, v8, s11, v9, v33]
  li v100, 1  ; live: [v10, fv99, zero, v8, s11, v9, v33, v100]
  slli v101, v100, 3  ; live: [v10, fv99, zero, v8, s11, v9, v33, v101]
  add v102, v33, v101  ; live: [v10, fv99, zero, v8, s11, v102, v9]
  fsd fv99, 0(v102)  ; live: [v10, zero, v8, s11, v9]
  li v94, 2  ; live: [v94, v10, zero, v8, s11, v9]
  mv a0, v94  ; live: [v10, zero, a0, v8, s11, v9]
  li v95, 3  ; live: [v10, zero, a0, v8, v95, s11, v9]
  mv a1, v95  ; live: [v10, zero, a0, v8, a1, s11, v9]
  li v96, 2  ; live: [v10, v96, zero, a0, v8, a1, s11, v9]
  mv a2, v96  ; live: [v10, zero, a0, v8, a2, a1, s11, v9]
  mv a3, v8  ; live: [v10, zero, a0, a2, a1, s11, a3, v9]
  mv a4, v9  ; live: [v10, zero, a0, a4, a2, a1, s11, a3]
  mv a5, v10  ; live: [v10, a5, zero, a0, a4, a2, a1, s11, a3]
  call mul  ; live: [s11, v10, zero]
  mv v35, zero  ; live: [s11, v10, zero]
  slli v91, zero, 3  ; live: [v91, s11, v10, zero]
  add v92, v10, v91  ; live: [v92, s11, v10, zero]
  ld v36, 0(v92)  ; live: [s11, v10, zero, v36]
  slli v88, zero, 3  ; live: [v88, s11, v10, zero, v36]
  add v89, v36, v88  ; live: [s11, v10, zero, v89]
  fld fv37, 0(v89)  ; live: [fv37, s11, v10, zero]
  fmv.d fa0, fv37  ; live: [s11, v10, zero, fa0]
  call minimbt_truncate  ; live: [s11, v10, zero, a0]
  mv v38, a0  ; live: [v38, s11, v10, zero]
  mv a0, v38  ; live: [s11, v10, zero, a0]
  call minimbt_print_int  ; live: [s11, v10, zero]
  mv v39, zero  ; live: [s11, v10, zero]
  call minimbt_print_endline  ; live: [s11, v10, zero]
  mv v40, zero  ; live: [s11, v10, zero]
  slli v82, zero, 3  ; live: [v82, s11, v10, zero]
  add v83, v10, v82  ; live: [s11, v10, v83, zero]
  ld v41, 0(v83)  ; live: [v41, s11, v10, zero]
  li v78, 1  ; live: [v41, s11, v10, zero, v78]
  slli v79, v78, 3  ; live: [v41, s11, v10, zero, v79]
  add v80, v41, v79  ; live: [v80, s11, v10, zero]
  fld fv42, 0(v80)  ; live: [s11, v10, zero, fv42]
  fmv.d fa0, fv42  ; live: [s11, v10, zero, fa0]
  call minimbt_truncate  ; live: [s11, v10, zero, a0]
  mv v43, a0  ; live: [v43, s11, v10, zero]
  mv a0, v43  ; live: [s11, v10, zero, a0]
  call minimbt_print_int  ; live: [s11, v10, zero]
  mv v44, zero  ; live: [s11, v10, zero]
  call minimbt_print_endline  ; live: [s11, v10, zero]
  mv v45, zero  ; live: [s11, v10, zero]
  li v71, 1  ; live: [v71, s11, v10, zero]
  slli v72, v71, 3  ; live: [v72, s11, v10, zero]
  add v73, v10, v72  ; live: [s11, v10, zero, v73]
  ld v46, 0(v73)  ; live: [v46, s11, v10, zero]
  slli v68, zero, 3  ; live: [v46, s11, v10, zero, v68]
  add v69, v46, v68  ; live: [v69, s11, v10, zero]
  fld fv47, 0(v69)  ; live: [s11, v10, fv47, zero]
  fmv.d fa0, fv47  ; live: [s11, v10, zero, fa0]
  call minimbt_truncate  ; live: [s11, v10, zero, a0]
  mv v48, a0  ; live: [s11, v10, v48, zero]
  mv a0, v48  ; live: [s11, v10, zero, a0]
  call minimbt_print_int  ; live: [s11, v10, zero]
  mv v49, zero  ; live: [s11, v10, zero]
  call minimbt_print_endline  ; live: [s11, v10, zero]
  mv v50, zero  ; live: [s11, v10, zero]
  li v61, 1  ; live: [s11, v10, v61, zero]
  slli v62, v61, 3  ; live: [v62, s11, v10, zero]
  add v63, v10, v62  ; live: [v63, s11, zero]
  ld v51, 0(v63)  ; live: [s11, zero, v51]
  li v57, 1  ; live: [s11, v57, zero, v51]
  slli v58, v57, 3  ; live: [v58, s11, zero, v51]
  add v59, v51, v58  ; live: [v59, s11, zero]
  fld fv52, 0(v59)  ; live: [fv52, s11, zero]
  fmv.d fa0, fv52  ; live: [s11, zero, fa0]
  call minimbt_truncate  ; live: [s11, zero, a0]
  mv v53, a0  ; live: [s11, v53, zero]
  mv a0, v53  ; live: [s11, zero, a0]
  call minimbt_print_int  ; live: [s11, zero]
  mv v54, zero  ; live: [s11, zero]
; control
  mv a0, zero  ; live: [s11, zero, a0]
  ret  ; live: [s11, zero]

  .p2align 3
  .globl init_arr
  .type init_arr, @function
init_arr:
; block info: defs: [v3, v4, v6, v22, v2], uses: [a0, zero, v22, a2, a1, v6, v2], upward_exposed: [a2, a1, a0, zero], params_defs: []
; live_in: [a0, zero, v0, a2, a1, s11], live_out: [v2, zero, v0, v4, s11, v3]
; block parameters: []
.init_arr_b0:
  mv v2, a0  ; live: [a0, zero, v0, a2, a1, s11, v2]
  mv v3, a1  ; live: [a0, zero, v0, a2, a1, s11, v2]
  mv v4, a2  ; live: [a0, zero, v0, a2, a1, s11, v2]
  slt v22, zero, v2  ; live: [a0, zero, v22, v0, a2, a1, s11]
  xori v6, v22, 1  ; live: [a0, zero, v0, a2, a1, v6, s11]
; control
  bne v6, zero, .init_arr_b1  ; live: [v0, a2, a1, s11, a0, zero]
  j .init_arr_b2  ; live: [v0, a2, a1, s11, a0, zero]

; block info: defs: [a0], uses: [v11, a0], upward_exposed: [v11], params_defs: [v11]
; live_in: [v11], live_out: []
; block parameters: [v11]
.init_arr_b3:
; control
  mv a0, v11  ; live: [v11, a0]
  ret  ; live: [v11]

; block info: defs: [v11], uses: [zero], upward_exposed: [zero], params_defs: []
; live_in: [zero], live_out: [v11]
; block parameters: []
.init_arr_b2:
; control
  mv v11, zero  ; live: [zero]
  j .init_arr_b3  ; live: [zero]

; block info: defs: [t1, v16, v14, ft0, ft1, a1, v12, t5, fa1, fa2, ft6, a4, fa6, a6, v19, ft5, ft10, fv21, ft7, v11, ft4, v5, ft9, v10, a5, fa4, a0, ft2, a2, v17, a3, v9, s10, ft8, t3, a7, fa7, t0, fa5, v18, fa3, ft3, fa0, t4, t2], uses: [v3, v5, v16, v14, v10, a0, v0, a2, a1, v17, s11, v9, v18, zero, fa0, v19, v4, fv21, v2], upward_exposed: [v3, zero, v0, v4, s11, v2], params_defs: []
; live_in: [v3, zero, v0, v4, s11, v2], live_out: [v11]
; block parameters: []
.init_arr_b1:
  slli v18, v3, 3  ; live: [v3, v18, zero, v0, v4, s11, v2]
  sub v19, s11, v18  ; live: [v3, zero, v0, v19, v4, s11, v2]
  andi v5, v19, -8  ; live: [v3, v5, zero, v0, v4, s11, v2]
  fmv.d.x fv21, zero  ; live: [v3, v5, zero, v0, v4, s11, fv21, v2]
  mv a1, v3  ; live: [v3, v5, zero, v0, v4, a1, s11, fv21, v2]
  mv a0, v5  ; live: [v3, v5, zero, a0, v0, v4, a1, s11, fv21, v2]
  fmv.d fa0, fv21  ; live: [v3, v5, zero, a0, fa0, v0, v4, a1, s11, v2]
  call _memsetf64  ; live: [v3, v5, zero, v0, v4, s11, v2]
  slli v16, v2, 3  ; live: [v3, v5, v16, zero, v0, v4, s11, v2]
  add v17, v4, v16  ; live: [v3, v5, zero, v0, v4, v17, s11, v2]
  sd v5, 0(v17)  ; live: [v3, zero, v0, v4, s11, v2]
  li v14, 1  ; live: [v3, v14, zero, v0, v4, s11, v2]
  sub v9, v2, v14  ; live: [v3, zero, v0, v4, s11, v9, v2]
  mv s10, v0  ; live: [v3, zero, v0, v4, s11, v9, v2]
  ld v12, 0(v0)  ; live: [v3, zero, v0, v4, s11, v9, v2]
  mv a0, v9  ; live: [v3, zero, a0, v0, v4, s11, v2]
  mv a1, v3  ; live: [v3, zero, a0, v0, v4, a1, s11, v2]
  mv a2, v4  ; live: [v3, zero, a0, v0, v4, a2, a1, s11, v2]
  jalr v12  ; live: [v3, zero, v0, v4, s11, v2]
  mv v10, zero  ; live: [v3, v10, zero, v0, v4, s11, v2]
; control
  mv v11, v10  ; live: [v2, v0, v4, s11, zero, v3]
  j .init_arr_b3  ; live: [v2, v0, v4, s11, zero, v3]

  .p2align 3
  .globl thunk_start
  .type thunk_start, @function
thunk_start:
; block info: defs: [t1, ft0, ft1, a1, t5, fa1, fa2, ft6, a4, fa6, a6, ft5, ft10, ft7, ft4, ft9, a5, a0, fa4, ft2, a2, a3, ft8, t3, a7, fa7, t0, fa5, fa3, ft3, fa0, t4, t2, v2], uses: [zero, a0, v2], upward_exposed: [zero], params_defs: []
; live_in: [zero], live_out: []
; block parameters: []
.thunk_start_b0:
  call main  ; live: [zero]
  mv v2, zero  ; live: [zero, v2]
; control
  mv a0, v2  ; live: [zero, a0]
  ret  ; live: [zero]

  .p2align 3
  .globl mul
  .type mul, @function
mul:
; block info: defs: [v2, t1, v7, ft0, ft1, a1, t5, fa1, fa2, ft6, a4, fa6, v8, a6, ft5, ft10, v4, v6, ft7, v11, ft4, v5, ft9, a5, a0, fa4, ft2, a2, a3, v9, ft8, t3, a7, fa7, t0, fa5, fa3, ft3, fa0, t4, t2, v3], uses: [v2, v11, v5, a5, a0, v7, a2, a1, a3, zero, a4, v8, v4, v6, v3], upward_exposed: [a5, a0, zero, a4, a2, a1, a3], params_defs: []
; live_in: [a5, a0, zero, a4, a2, a1, a3], live_out: []
; block parameters: []
.mul_b0:
  mv v2, a0  ; live: [a5, zero, a4, a2, a1, a3, v2]
  mv v3, a1  ; live: [v2, a5, zero, a4, a2, a3, v3]
  mv v4, a2  ; live: [v2, a5, zero, a4, v4, a3, v3]
  mv v5, a3  ; live: [v2, v5, a5, zero, a4, v4, v3]
  mv v6, a4  ; live: [v2, v5, a5, zero, v4, v6, v3]
  mv v7, a5  ; live: [v2, v5, zero, v7, v4, v6, v3]
  li v11, 1  ; live: [v2, v11, v5, zero, v7, v4, v6, v3]
  sub v8, v2, v11  ; live: [v5, zero, v7, v8, v4, v6, v3]
  mv a0, v8  ; live: [v5, zero, a0, v7, v4, v6, v3]
  mv a1, v3  ; live: [v5, zero, a0, v7, v4, a1, v6]
  mv a2, v4  ; live: [v5, zero, a0, v7, a2, a1, v6]
  mv a3, v5  ; live: [zero, a0, v7, a2, a1, v6, a3]
  mv a4, v6  ; live: [zero, a0, a4, v7, a2, a1, a3]
  mv a5, v7  ; live: [a5, zero, a0, a4, a2, a1, a3]
  call loop1  ; live: [a5, zero, a4, a2, a1, a3]
  mv v9, zero  ; live: [a5, zero, a4, a2, a1, a3]
; control
  mv a0, zero  ; live: [a5, a0, zero, a4, a2, a1, a3]
  ret  ; live: [a5, a0, zero, a4, a2, a1, a3]

  .p2align 3
  .globl loop3
  .type loop3, @function
loop3:
; block info: defs: [v2, v5, v50, v7, v8, v4, v6, v3], uses: [a5, a0, zero, a4, v50, v8, v4, a2, a1, a3], upward_exposed: [a5, a0, zero, a4, a2, a1, a3], params_defs: []
; live_in: [a5, a0, zero, a4, a2, a1, a3], live_out: [v2, v5, zero, v7, v4, v6, v3]
; block parameters: []
.loop3_b0:
  mv v2, a0  ; live: [a5, a0, zero, a4, a2, a1, a3]
  mv v3, a1  ; live: [a5, a0, zero, a4, a2, a1, a3]
  mv v4, a2  ; live: [a5, a0, zero, a4, a2, v4, a1, a3]
  mv v5, a3  ; live: [a5, a0, zero, a4, a2, v4, a1, a3]
  mv v6, a4  ; live: [a5, a0, zero, a4, a2, v4, a1, a3]
  mv v7, a5  ; live: [a5, a0, zero, a4, a2, v4, a1, a3]
  slt v50, zero, v4  ; live: [a5, a0, zero, a4, v50, a2, a1, a3]
  xori v8, v50, 1  ; live: [a5, a0, zero, a4, v8, a2, a1, a3]
; control
  bne v8, zero, .loop3_b1  ; live: [a5, a0, zero, a4, a2, a1, a3]
  j .loop3_b2  ; live: [a5, a0, zero, a4, a2, a1, a3]

; block info: defs: [a1, v44, t5, fv15, v33, fa1, fa2, ft6, a4, fa6, v20, a6, ft10, ft5, ft4, v10, ft9, fa4, ft2, a3, a7, fa7, v48, fa3, fv11, ft3, v45, t2, fv17, v25, t1, v14, v42, v26, v41, v32, ft0, ft1, v12, fv16, v29, v19, v47, ft7, v21, a5, a0, v30, v36, a2, v9, v39, ft8, t3, t0, fa5, v23, fv13, v35, fa0, v38, t4], uses: [v3, v25, v14, v42, v26, v7, v41, v32, a1, v12, fv15, fv16, v44, v33, v29, zero, a4, v20, v19, v47, v4, v6, v5, v10, a5, a0, v30, v36, a2, a3, v9, v39, v48, fv11, v23, v45, v35, fv13, v38, fv17, v2], upward_exposed: [v2, v5, zero, v7, v4, v6, v3], params_defs: []
; live_in: [v3, v5, zero, v7, v4, v6, v2], live_out: [v21]
; block parameters: []
.loop3_b1:
  slli v47, v2, 3  ; live: [v2, v5, zero, v7, v4, v47, v6, v3]
  add v48, v7, v47  ; live: [v2, v5, v48, zero, v7, v4, v6, v3]
  ld v9, 0(v48)  ; live: [v2, v5, zero, v7, v4, v6, v9, v3]
  slli v44, v2, 3  ; live: [v2, v5, zero, v7, v4, v6, v44, v9, v3]
  add v45, v7, v44  ; live: [v2, v5, zero, v7, v45, v4, v6, v9, v3]
  ld v10, 0(v45)  ; live: [v2, v5, v10, zero, v7, v4, v6, v9, v3]
  slli v41, v3, 3  ; live: [v2, v5, v10, zero, v7, v4, v41, v6, v9, v3]
  add v42, v10, v41  ; live: [v2, v5, zero, v42, v7, v4, v6, v9, v3]
  fld fv11, 0(v42)  ; live: [v2, v5, zero, fv11, v7, v4, v6, v9, v3]
  slli v38, v2, 3  ; live: [v2, v5, zero, fv11, v7, v4, v38, v6, v9, v3]
  add v39, v5, v38  ; live: [v2, v5, zero, fv11, v7, v4, v6, v9, v39, v3]
  ld v12, 0(v39)  ; live: [v2, v5, zero, fv11, v7, v4, v6, v12, v9, v3]
  slli v35, v4, 3  ; live: [v2, v5, zero, fv11, v7, v35, v4, v6, v12, v9, v3]
  add v36, v12, v35  ; live: [v2, v5, zero, fv11, v7, v36, v4, v6, v9, v3]
  fld fv13, 0(v36)  ; live: [v2, v5, zero, fv11, v7, fv13, v4, v6, v9, v3]
  slli v32, v4, 3  ; live: [v2, v5, zero, fv11, v7, fv13, v4, v32, v6, v9, v3]
  add v33, v6, v32  ; live: [v2, v5, zero, fv11, v7, fv13, v4, v6, v9, v33, v3]
  ld v14, 0(v33)  ; live: [v2, v5, v14, zero, fv11, v7, fv13, v4, v6, v9, v3]
  slli v29, v3, 3  ; live: [v2, v5, v14, zero, fv11, v29, v7, fv13, v4, v6, v9, v3]
  add v30, v14, v29  ; live: [v2, v5, zero, fv11, v30, fv13, v7, v4, v6, v9, v3]
  fld fv15, 0(v30)  ; live: [v2, v5, zero, fv11, v7, fv13, v4, v6, fv15, v9, v3]
  fmul.d fv16, fv13, fv15  ; live: [v2, v5, zero, fv11, v7, v4, v6, fv16, v9, v3]
  fadd.d fv17, fv11, fv16  ; live: [v2, v5, zero, v7, v4, v6, fv17, v9, v3]
  slli v25, v3, 3  ; live: [v2, v25, v5, zero, v7, v4, v6, fv17, v9, v3]
  add v26, v9, v25  ; live: [v2, v5, zero, v26, v7, v4, v6, fv17, v3]
  fsd fv17, 0(v26)  ; live: [v2, v5, zero, v7, v4, v6, v3]
  li v23, 1  ; live: [v2, v5, zero, v23, v7, v4, v6, v3]
  sub v19, v4, v23  ; live: [v2, v5, zero, v7, v19, v4, v6, v3]
  mv a0, v2  ; live: [v2, v5, zero, a0, v7, v19, v4, v6, v3]
  mv a1, v3  ; live: [v2, v5, zero, a0, v7, v19, v4, a1, v6, v3]
  mv a2, v19  ; live: [v2, v5, zero, a0, v7, v4, a2, a1, v6, v3]
  mv a3, v5  ; live: [v2, v5, zero, a0, v7, v4, a2, a1, v6, a3, v3]
  mv a4, v6  ; live: [v2, v5, zero, a0, a4, v7, v4, a2, a1, v6, a3, v3]
  mv a5, v7  ; live: [v2, v5, a5, zero, a0, a4, v7, v4, a2, a1, v6, a3, v3]
  call loop3  ; live: [v2, v5, zero, v7, v4, v6, v3]
  mv v20, zero  ; live: [v2, v5, zero, v20, v7, v4, v6, v3]
; control
  mv v21, v20  ; live: [v2, v5, zero, v7, v4, v6, v3]
  j .loop3_b3  ; live: [v2, v5, zero, v7, v4, v6, v3]

; block info: defs: [v21], uses: [zero], upward_exposed: [zero], params_defs: []
; live_in: [zero], live_out: [v21]
; block parameters: []
.loop3_b2:
; control
  mv v21, zero  ; live: [zero]
  j .loop3_b3  ; live: [zero]

; block info: defs: [a0], uses: [v21, a0], upward_exposed: [v21], params_defs: [v21]
; live_in: [v21], live_out: []
; block parameters: [v21]
.loop3_b3:
; control
  mv a0, v21  ; live: [v21, a0]
  ret  ; live: [v21]

  .p2align 3
  .globl loop1
  .type loop1, @function
loop1:
; block info: defs: [v2, v5, v20, v7, v8, v4, v6, v3], uses: [a5, a0, zero, a4, v20, v8, a2, a1, a3, v2], upward_exposed: [a5, a0, zero, a4, a2, a1, a3], params_defs: []
; live_in: [a5, a0, zero, a4, a2, a1, a3], live_out: [v2, v5, zero, v7, v4, v6, v3]
; block parameters: []
.loop1_b0:
  mv v2, a0  ; live: [a5, a0, zero, a4, a2, a1, a3, v2]
  mv v3, a1  ; live: [a5, a0, zero, a4, a2, a1, a3, v2]
  mv v4, a2  ; live: [a5, a0, zero, a4, a2, a1, a3, v2]
  mv v5, a3  ; live: [a5, a0, zero, a4, a2, a1, a3, v2]
  mv v6, a4  ; live: [a5, a0, zero, a4, a2, a1, a3, v2]
  mv v7, a5  ; live: [a5, a0, zero, a4, a2, a1, a3, v2]
  slt v20, zero, v2  ; live: [a5, a0, zero, a4, v20, a2, a1, a3]
  xori v8, v20, 1  ; live: [a5, a0, zero, a4, v8, a2, a1, a3]
; control
  bne v8, zero, .loop1_b1  ; live: [a5, a0, zero, a4, a2, a1, a3]
  j .loop1_b2  ; live: [a5, a0, zero, a4, a2, a1, a3]

; block info: defs: [t1, v13, ft0, ft1, a1, v12, t5, fa1, fa2, ft6, a4, fa6, a6, ft5, ft10, ft7, v11, ft4, ft9, v10, a5, fa4, a0, ft2, a2, a3, v9, ft8, a7, t3, fa7, t0, fa5, v18, fa3, ft3, fa0, t4, t2, v15], uses: [v3, v11, v5, a5, a0, v7, a2, a1, a3, v12, v9, v18, zero, a4, v4, v6, v15, v2], upward_exposed: [v2, v5, zero, v7, v4, v6, v3], params_defs: []
; live_in: [v3, v5, zero, v7, v4, v6, v2], live_out: [v13]
; block parameters: []
.loop1_b1:
  li v18, 1  ; live: [v2, v5, v18, zero, v7, v4, v6, v3]
  sub v9, v4, v18  ; live: [v2, v5, zero, v7, v4, v6, v9, v3]
  mv a0, v2  ; live: [v2, v5, zero, a0, v7, v4, v6, v9, v3]
  mv a1, v3  ; live: [v2, v5, zero, a0, v7, v4, a1, v6, v9, v3]
  mv a2, v9  ; live: [v2, v5, zero, a0, v7, v4, a2, a1, v6, v3]
  mv a3, v5  ; live: [v2, v5, zero, a0, v7, v4, a2, a1, v6, a3, v3]
  mv a4, v6  ; live: [v2, v5, zero, a0, a4, v7, v4, a2, a1, v6, a3, v3]
  mv a5, v7  ; live: [v2, v5, a5, zero, a0, a4, v7, v4, a2, a1, v6, a3, v3]
  call loop2  ; live: [v2, v5, zero, v7, v4, v6, v3]
  mv v10, zero  ; live: [v2, v5, zero, v7, v4, v6, v3]
  li v15, 1  ; live: [v2, v5, zero, v7, v4, v6, v15, v3]
  sub v11, v2, v15  ; live: [v2, v11, v5, zero, v7, v4, v6, v3]
  mv a0, v11  ; live: [v2, v5, zero, a0, v7, v4, v6, v3]
  mv a1, v3  ; live: [v2, v5, zero, a0, v7, v4, a1, v6, v3]
  mv a2, v4  ; live: [v2, v5, zero, a0, v7, v4, a2, a1, v6, v3]
  mv a3, v5  ; live: [v2, v5, zero, a0, v7, v4, a2, a1, v6, a3, v3]
  mv a4, v6  ; live: [v2, v5, zero, a0, a4, v7, v4, a2, a1, v6, a3, v3]
  mv a5, v7  ; live: [v2, v5, a5, zero, a0, a4, v7, v4, a2, a1, v6, a3, v3]
  call loop1  ; live: [v2, v5, zero, v7, v4, v6, v3]
  mv v12, zero  ; live: [v2, v5, zero, v7, v4, v6, v12, v3]
; control
  mv v13, v12  ; live: [v2, v5, zero, v7, v4, v6, v3]
  j .loop1_b3  ; live: [v2, v5, zero, v7, v4, v6, v3]

; block info: defs: [v13], uses: [zero], upward_exposed: [zero], params_defs: []
; live_in: [zero], live_out: [v13]
; block parameters: []
.loop1_b2:
; control
  mv v13, zero  ; live: [zero]
  j .loop1_b3  ; live: [zero]

; block info: defs: [a0], uses: [v13, a0], upward_exposed: [v13], params_defs: [v13]
; live_in: [v13], live_out: []
; block parameters: [v13]
.loop1_b3:
; control
  mv a0, v13  ; live: [v13, a0]
  ret  ; live: [v13]

  .p2align 3
  .globl start
  .type start, @object
start:
  .zero 4



Testing test/test_src/matmul.mbt
# name conventions used in the core ir:
# - functions: f<id>
# - blocks: b<id>
# - instructions: %<id>
# - memory: m<id>
# - free variables: ^<id>
# - function parameters: $f<pid>
# - block parameters: $b<bid>.<pid>
.core
.fn loop2 #f2 : closure(int32) -> unit
.freevars (array[array[double]], int32, array[array[double]], array[array[double]], int32)
.entry b0 {
  .bb #b0 () {
    let %0: bool = le(0, $f0)
    br %0 b1() b2()
  }
  .bb #b1 () {
    let _ = alloc <m0: closure(int32) -> unit heap(6)> <- [0] = f3, [1] = ^1, [2] = ^2, [3] = $f0, [4] = ^3, [5] = ^4
    let %2: int32 = sub(^5, 1)
    let %3: unit = apply f2.m0(%2)
    let %4: int32 = sub($f0, 1)
    let %5: unit = apply self(%4)
    jump b3(%5)
  }
  .bb #b2 () {
    jump b3(())
  }
  .bb #b3 (unit) {
    return $b3.0
  }
}
.fn init_arr #f6 : closure(int32) -> unit
.freevars (int32, array[array[double]])
.entry b0 {
  .bb #b0 () {
    let %0: bool = le(0, $f0)
    br %0 b1() b2()
  }
  .bb #b1 () {
    let _ = alloc <m0: array[double] heap(^1)> <- [..] = 0
    let _ = store array[double] offset(^2, $f0) <- f6.m0
    let %3: int32 = sub($f0, 1)
    let %4: unit = apply self(%3)
    jump b3(%4)
  }
  .bb #b2 () {
    jump b3(())
  }
  .bb #b3 (unit) {
    return $b3.0
  }
}
.fn thunk_start #f7 : fn() -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: unit = call f4()
    return %0
  }
}
.fn loop3 #f3 : closure(int32) -> unit
.freevars (array[array[double]], int32, int32, array[array[double]], array[array[double]])
.entry b0 {
  .bb #b0 () {
    let %0: bool = le(0, $f0)
    br %0 b1() b2()
  }
  .bb #b1 () {
    let %1: array[double] = load array[double] offset(^1, ^2)
    let %2: array[double] = load array[double] offset(^1, ^2)
    let %3: double = load double offset(%2, ^3)
    let %4: array[double] = load array[double] offset(^4, ^2)
    let %5: double = load double offset(%4, $f0)
    let %6: array[double] = load array[double] offset(^5, $f0)
    let %7: double = load double offset(%6, ^3)
    let %8: double = mul(%5, %7)
    let %9: double = add(%3, %8)
    let _ = store double offset(%1, ^3) <- %9
    let %11: int32 = sub($f0, 1)
    let %12: unit = apply self(%11)
    jump b3(%12)
  }
  .bb #b2 () {
    jump b3(())
  }
  .bb #b3 (unit) {
    return $b3.0
  }
}
.fn loop1 #f1 : closure(int32) -> unit
.freevars (array[array[double]], array[array[double]], array[array[double]], int32, int32)
.entry b0 {
  .bb #b0 () {
    let %0: bool = le(0, $f0)
    br %0 b1() b2()
  }
  .bb #b1 () {
    let _ = alloc <m0: closure(int32) -> unit heap(6)> <- [0] = f2, [1] = ^1, [2] = $f0, [3] = ^2, [4] = ^3, [5] = ^4
    let %2: int32 = sub(^5, 1)
    let %3: unit = apply f1.m0(%2)
    let %4: int32 = sub($f0, 1)
    let %5: unit = apply self(%4)
    jump b3(%5)
  }
  .bb #b2 () {
    jump b3(())
  }
  .bb #b3 (unit) {
    return $b3.0
  }
}
.fn matmul #f0 : fn(int32, int32, int32, array[array[double]], array[array[double]], array[array[double]]) -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let _ = alloc <m0: closure(int32) -> unit heap(6)> <- [0] = f1, [1] = $f5, [2] = $f3, [3] = $f4, [4] = $f1, [5] = $f2
    let %1: int32 = sub($f0, 1)
    let %2: unit = apply f0.m0(%1)
    return %2
  }
}
.fn gen_arr #f5 : closure(int32, int32) -> array[array[double]]
.freevars (array[double])
.entry b0 {
  .bb #b0 () {
    let _ = alloc <m0: array[array[double]] heap($f0)> <- [..] = ^1
    let _ = alloc <m1: closure(int32) -> unit heap(3)> <- [0] = f6, [1] = $f1, [2] = f5.m0
    let %2: int32 = sub($f0, 1)
    let %3: unit = apply f5.m1(%2)
    return f5.m0
  }
}
.fn main #f4 : fn() -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let _ = alloc <m0: array[double] heap(0)> <- [..] = 0
    let _ = alloc <m1: closure(int32, int32) -> array[array[double]] heap(2)> <- [0] = f5, [1] = f4.m0
    let %2: array[array[double]] = apply f4.m1(2, 3)
    let %3: array[array[double]] = apply f4.m1(3, 2)
    let %4: array[array[double]] = apply f4.m1(2, 2)
    let %5: array[double] = load array[double] offset(%2, 0)
    let _ = store double offset(%5, 0) <- 1
    let %7: array[double] = load array[double] offset(%2, 0)
    let _ = store double offset(%7, 1) <- 2
    let %9: array[double] = load array[double] offset(%2, 0)
    let _ = store double offset(%9, 2) <- 3
    let %11: array[double] = load array[double] offset(%2, 1)
    let _ = store double offset(%11, 0) <- 4
    let %13: array[double] = load array[double] offset(%2, 1)
    let _ = store double offset(%13, 1) <- 5
    let %15: array[double] = load array[double] offset(%2, 1)
    let _ = store double offset(%15, 2) <- 6
    let %17: array[double] = load array[double] offset(%3, 0)
    let _ = store double offset(%17, 0) <- 7
    let %19: array[double] = load array[double] offset(%3, 0)
    let _ = store double offset(%19, 1) <- 8
    let %21: array[double] = load array[double] offset(%3, 1)
    let _ = store double offset(%21, 0) <- 9
    let %23: array[double] = load array[double] offset(%3, 1)
    let _ = store double offset(%23, 1) <- 10
    let %25: array[double] = load array[double] offset(%3, 2)
    let _ = store double offset(%25, 0) <- 11
    let %27: array[double] = load array[double] offset(%3, 2)
    let _ = store double offset(%27, 1) <- 12
    let %29: unit = call f0(2, 3, 2, %2, %3, %4)
    let %30: array[double] = load array[double] offset(%4, 0)
    let %31: double = load double offset(%30, 0)
    let %32: int32 = ext_call minimbt_truncate(%31)
    let %33: unit = ext_call minimbt_print_int(%32)
    let %34: unit = ext_call minimbt_print_endline()
    let %35: array[double] = load array[double] offset(%4, 0)
    let %36: double = load double offset(%35, 1)
    let %37: int32 = ext_call minimbt_truncate(%36)
    let %38: unit = ext_call minimbt_print_int(%37)
    let %39: unit = ext_call minimbt_print_endline()
    let %40: array[double] = load array[double] offset(%4, 1)
    let %41: double = load double offset(%40, 0)
    let %42: int32 = ext_call minimbt_truncate(%41)
    let %43: unit = ext_call minimbt_print_int(%42)
    let %44: unit = ext_call minimbt_print_endline()
    let %45: array[double] = load array[double] offset(%4, 1)
    let %46: double = load double offset(%45, 1)
    let %47: int32 = ext_call minimbt_truncate(%46)
    let %48: unit = ext_call minimbt_print_int(%47)
    return ()
  }
}
.thunk ::0 start

  .p2align 3
  .globl loop2
  .type loop2, @function
loop2:
; block info: defs: [v2, v5, v27, v7, v0, v4, v6, v9, v3], uses: [a0, zero, v27, v0, s10, v9, v2], upward_exposed: [s10, a0, zero], params_defs: []
; live_in: [s11, s10, a0, zero], live_out: [v3, v5, zero, v7, v0, v4, v6, s11, v2]
; block parameters: []
.loop2_b0:
  mv v0, s10  ; live: [a0, zero, v0, s11, s10]
  mv v2, a0  ; live: [a0, zero, v0, s11, s10, v2]
  lw v3, 8(v0)  ; live: [a0, zero, v0, s11, s10, v2]
  lw v4, 16(v0)  ; live: [a0, zero, v0, s11, s10, v2]
  lw v5, 24(v0)  ; live: [a0, zero, v0, s11, s10, v2]
  lw v6, 32(v0)  ; live: [v2, v0, s11, s10, a0, zero]
  lw v7, 40(v0)  ; live: [v2, s11, s10, a0, zero]
  slt v27, zero, v2  ; live: [v27, s11, s10, a0, zero]
  xori v9, v27, 1  ; live: [v9, s11, s10, a0, zero]
; control
  bne v9, zero, .loop2_b1  ; live: [s11, s10, a0, zero]
  j .loop2_b2  ; live: [s11, s10, a0, zero]

; block info: defs: [v15], uses: [zero], upward_exposed: [zero], params_defs: []
; live_in: [zero], live_out: [v15]
; block parameters: []
.loop2_b2:
; control
  mv v15, zero  ; live: [zero]
  j .loop2_b3  ; live: [zero]

; block info: defs: [a0], uses: [v15, a0], upward_exposed: [v15], params_defs: [v15]
; live_in: [v15], live_out: []
; block parameters: [v15]
.loop2_b3:
; control
  mv a0, v15  ; live: [v15, a0]
  ret  ; live: [v15]

; block info: defs: [t1, v16, v14, v26, v13, v22, ft0, ft1, a1, v12, t5, fa1, fa2, ft6, v20, a4, fa6, v8, a6, ft10, ft5, ft7, v11, ft4, ft9, a5, a0, fa4, ft2, a2, v24, a3, s10, ft8, a7, t3, fa7, t0, fa5, v18, fa3, ft3, fa0, t4, t2, v15], uses: [v3, v11, v5, v14, v26, a0, v13, v22, v7, v0, v24, s11, v18, zero, v8, v4, v6, v2], upward_exposed: [v3, v5, zero, v7, v0, v4, v6, s11, v2], params_defs: []
; live_in: [v2, v5, zero, v7, v0, v4, v6, s11, v3], live_out: [v15]
; block parameters: []
.loop2_b1:
  addi v24, s11, -48  ; live: [v3, v5, zero, v7, v0, v4, v6, s11, v24, v2]
  andi v8, v24, -8  ; live: [v3, v5, zero, v7, v8, v0, v4, v6, s11, v2]
  la v26, loop3  ; live: [v3, v5, zero, v26, v7, v8, v0, v4, v6, s11, v2]
  sd v26, 0(v8)  ; live: [v3, v5, zero, v7, v8, v0, v4, v6, s11, v2]
  sd v3, 8(v8)  ; live: [v3, v5, zero, v7, v8, v0, v4, v6, s11, v2]
  sd v4, 16(v8)  ; live: [v3, v5, zero, v7, v8, v0, v4, v6, s11, v2]
  sd v2, 24(v8)  ; live: [v3, v5, zero, v7, v8, v0, v4, v6, s11, v2]
  sd v5, 32(v8)  ; live: [v3, v5, zero, v7, v8, v0, v4, v6, s11, v2]
  sd v6, 40(v8)  ; live: [v3, v5, zero, v7, v8, v0, v4, v6, s11, v2]
  li v22, 1  ; live: [v3, v5, zero, v22, v7, v8, v0, v4, v6, s11, v2]
  sub v11, v7, v22  ; live: [v3, v11, v5, zero, v7, v8, v0, v4, v6, s11, v2]
  mv s10, v8  ; live: [v3, v11, v5, zero, v7, v8, v0, v4, v6, s11, v2]
  ld v20, 0(v8)  ; live: [v3, v11, v5, zero, v7, v0, v4, v6, s11, v2]
  mv a0, v11  ; live: [v3, v5, zero, a0, v7, v0, v4, v6, s11, v2]
  jalr v20  ; live: [v3, v5, zero, v7, v0, v4, v6, s11, v2]
  mv v12, zero  ; live: [v3, v5, zero, v7, v0, v4, v6, s11, v2]
  li v18, 1  ; live: [v3, v5, v18, zero, v7, v0, v4, v6, s11, v2]
  sub v13, v2, v18  ; live: [v3, v5, zero, v13, v7, v0, v4, v6, s11, v2]
  mv s10, v0  ; live: [v3, v5, zero, v13, v7, v0, v4, v6, s11, v2]
  ld v16, 0(v0)  ; live: [v3, v5, zero, v13, v7, v0, v4, v6, s11, v2]
  mv a0, v13  ; live: [v3, v5, zero, a0, v7, v0, v4, v6, s11, v2]
  jalr v16  ; live: [v3, v5, zero, v7, v0, v4, v6, s11, v2]
  mv v14, zero  ; live: [v3, v5, v14, zero, v7, v0, v4, v6, s11, v2]
; control
  mv v15, v14  ; live: [v3, v5, zero, v7, v0, v4, v6, s11, v2]
  j .loop2_b3  ; live: [v3, v5, zero, v7, v0, v4, v6, s11, v2]

  .p2align 3
  .globl _start
  .type _start, @function
_start:
; block info: defs: [t1, ft0, ft1, a1, t5, fa1, fa2, ft6, a4, fa6, a6, ft5, ft10, ft7, ft4, ft9, a5, a0, fa4, ft2, a2, a3, ft8, t3, a7, fa7, t0, fa5, fa3, ft3, fa0, t4, t2], uses: [a0], upward_exposed: [], params_defs: []
; live_in: [], live_out: []
; block parameters: []
_start_b0:
  call thunk_start  ; live: [a0]
; control
  ret  ; live: []

  .p2align 3
  .globl matmul
  .type matmul, @function
matmul:
; block info: defs: [v2, t1, v16, v14, v7, ft0, ft1, a1, v12, t5, fa1, fa2, ft6, a4, fa6, v8, a6, ft5, ft10, v4, v6, ft7, v11, ft4, v5, v10, ft9, a5, a0, fa4, ft2, a2, a3, s10, ft8, t3, a7, fa7, t0, fa5, v18, fa3, ft3, fa0, t4, t2, v3], uses: [v2, v11, v16, v5, v14, v10, a5, a0, v7, a2, a1, a3, s11, v18, zero, a4, v8, v4, v6, v3], upward_exposed: [a5, a0, zero, a4, a2, a1, a3, s11], params_defs: []
; live_in: [a5, a0, zero, a4, a2, a1, a3, s11], live_out: []
; block parameters: []
.matmul_b0:
  mv v2, a0  ; live: [a5, zero, a4, a2, a1, s11, a3, v2]
  mv v3, a1  ; live: [v3, a5, zero, a4, a2, s11, a3, v2]
  mv v4, a2  ; live: [v3, a5, zero, a4, v4, s11, a3, v2]
  mv v5, a3  ; live: [v3, v5, a5, zero, a4, v4, s11, v2]
  mv v6, a4  ; live: [v3, v5, a5, zero, v4, v6, s11, v2]
  mv v7, a5  ; live: [v3, v5, zero, v7, v4, v6, s11, v2]
  addi v16, s11, -48  ; live: [v3, v5, v16, zero, v7, v4, v6, s11, v2]
  andi v8, v16, -8  ; live: [v3, v5, zero, v8, v7, v4, v6, s11, v2]
  la v18, loop1  ; live: [v3, v5, v18, zero, v8, v7, v4, v6, s11, v2]
  sd v18, 0(v8)  ; live: [v3, v5, zero, v8, v7, v4, v6, s11, v2]
  sd v7, 8(v8)  ; live: [v3, v5, zero, v8, v4, v6, s11, v2]
  sd v5, 16(v8)  ; live: [v3, zero, v8, v4, v6, s11, v2]
  sd v6, 24(v8)  ; live: [v3, zero, v8, v4, s11, v2]
  sd v3, 32(v8)  ; live: [zero, v8, v4, s11, v2]
  sd v4, 40(v8)  ; live: [zero, v8, s11, v2]
  li v14, 1  ; live: [v14, zero, v8, s11, v2]
  sub v10, v2, v14  ; live: [v10, zero, v8, s11]
  mv s10, v8  ; live: [v10, zero, v8, s11]
  ld v12, 0(v8)  ; live: [v10, zero, s11]
  mv a0, v10  ; live: [zero, a0, s11]
  jalr v12  ; live: [a5, zero, a4, a2, a1, a3, s11]
  mv v11, zero  ; live: [v11, a5, zero, a4, a2, a1, a3, s11]
; control
  mv a0, v11  ; live: [a5, a0, zero, a4, a2, a1, a3, s11]
  ret  ; live: [a5, a0, zero, a4, a2, a1, a3, s11]

  .p2align 3
  .globl gen_arr
  .type gen_arr, @function
gen_arr:
; block info: defs: [v2, t1, v13, v0, ft0, ft1, a1, t5, fa1, fa2, ft6, a4, fa6, v19, a6, v4, ft5, ft10, v6, ft7, v11, ft4, v5, ft9, v10, a5, fa4, a0, ft2, a2, v17, a3, v9, s10, ft8, t3, a7, fa7, t0, fa5, v18, fa3, ft3, fa0, t4, t2, v15, v3], uses: [v3, v5, a0, v13, v0, a2, a1, v17, s11, s10, v9, v18, zero, v19, v4, v6, v15, v2], upward_exposed: [a1, s11, s10, a0, zero], params_defs: []
; live_in: [a1, s11, s10, a0, zero], live_out: []
; block parameters: []
.gen_arr_b0:
  mv v0, s10  ; live: [zero, a0, v0, a1, s11]
  mv v2, a0  ; live: [zero, v0, a1, s11, v2]
  mv v3, a1  ; live: [v2, zero, v0, s11, v3]
  lw v4, 8(v0)  ; live: [v2, zero, v4, s11, v3]
  slli v18, v2, 3  ; live: [v2, v18, zero, v4, s11, v3]
  sub v19, s11, v18  ; live: [v2, zero, v19, v4, s11, v3]
  andi v5, v19, -8  ; live: [v2, v5, zero, v4, s11, v3]
  mv a1, v2  ; live: [v2, v5, zero, v4, a1, s11, v3]
  mv a0, v5  ; live: [v2, v5, zero, a0, v4, a1, s11, v3]
  mv a2, v4  ; live: [v2, v5, zero, a0, a2, a1, s11, v3]
  call _memseti32  ; live: [v2, v5, zero, s11, v3]
  addi v15, s11, -24  ; live: [v2, v5, zero, s11, v15, v3]
  andi v6, v15, -8  ; live: [v2, v5, zero, v6, s11, v3]
  la v17, init_arr  ; live: [v2, v5, zero, v6, v17, s11, v3]
  sd v17, 0(v6)  ; live: [v2, v5, zero, v6, s11, v3]
  sd v3, 8(v6)  ; live: [v5, v6, s11, zero, v2]
  sd v5, 16(v6)  ; live: [v5, v6, s11, zero, v2]
  li v13, 1  ; live: [v5, v6, s11, zero, v13, v2]
  sub v9, v2, v13  ; live: [v5, v6, s11, zero, v9]
  mv s10, v6  ; live: [v5, v6, s11, s10, zero, v9]
  ld v11, 0(v6)  ; live: [v5, s11, s10, zero, v9]
  mv a0, v9  ; live: [v5, s11, s10, zero, a0]
  jalr v11  ; live: [a1, v5, s11, s10, zero]
  mv v10, zero  ; live: [a1, v5, s11, s10, zero]
; control
  mv a0, v5  ; live: [a1, s11, s10, a0, zero]
  ret  ; live: [a1, s11, s10, a0, zero]

  .p2align 3
  .globl main
  .type main, @function
main:
; block info: defs: [v189, v159, v67, v150, a1, t5, v44, fa1, v191, fa2, v99, v169, a6, v166, v151, ft10, v59, v6, v117, v102, v154, ft4, ft9, v119, v110, v157, v92, v141, v184, v37, v43, v190, v206, a7, fv50, v156, v48, v96, v181, v163, v132, v174, fv164, v25, v194, v179, v42, v7, ft0, ft1, v41, v108, v177, v192, v143, v86, v185, v173, v98, v161, v130, v29, v8, v105, v90, v47, v89, v34, v66, v21, a2, v198, v160, v9, v145, ft8, v176, t3, fa5, v56, v23, v77, v148, t4, v80, v15, v195, fv131, v135, v2, fv114, v76, fv97, fv35, v200, v33, v60, v51, v168, fv172, ft6, fa6, fv188, a4, v27, v183, ft5, v165, v116, v87, v171, v49, fa4, v208, v133, ft2, v17, a3, v52, v147, v31, v196, v113, v167, v101, fa7, v203, v204, fa3, ft3, v136, t2, v140, fv106, v61, v55, v3, t1, v199, v69, v127, v13, v120, v134, v107, v149, fv40, v93, v115, v109, v142, fv139, v126, fv211, v19, v103, fv123, v81, v128, v57, v122, ft7, v11, v71, fv45, v46, a5, fv180, v158, v125, a0, v78, v36, v111, v202, s10, v138, v39, v187, v175, v118, t0, v94, v182, v209, v124, fv146, fv155, fa0, v152, v38, v70, v100], uses: [v159, v67, v150, a1, s11, v44, v191, v99, v169, v151, v166, v59, v6, v117, v102, v154, v119, v110, v157, v92, v184, v141, v206, v190, fv50, v156, v96, v181, v163, v132, fv164, v174, v25, v179, v7, v41, v177, v108, v143, v192, v86, v185, v98, v173, v161, v130, v29, zero, v8, v105, v90, v89, v34, v66, v21, a2, v160, v9, v145, v176, v56, v23, v77, v148, v80, v15, v195, fv131, v135, v2, fv114, v76, fv97, fv35, v200, v60, v51, fv172, v168, fv188, v27, a4, v183, v165, v116, v87, v171, v49, v208, v133, v17, a3, v147, v196, v31, v113, v167, v101, v203, v204, v136, v140, fv106, v61, v55, v3, v199, v69, v127, v13, v120, v134, v107, v149, fv40, v93, v109, v115, v142, fv139, v126, v19, v103, fv123, v81, v128, v57, v122, v11, v71, fv45, v46, a5, fv180, v158, v125, a0, v78, v36, v111, v187, v138, v39, v118, v175, v94, v209, v182, v124, fv146, fv155, fa0, v152, v70, v100, v189], upward_exposed: [s11, zero], params_defs: []
; live_in: [s11, zero], live_out: []
; block parameters: []
.main_b0:
  addi v209, s11, 0  ; live: [v209, zero, s11]
  andi v2, v209, -8  ; live: [zero, s11, v2]
  fmv.d.x fv211, zero  ; live: [zero, s11, v2]
  addi v206, s11, -16  ; live: [zero, s11, v206, v2]
  andi v3, v206, -8  ; live: [v2, zero, s11, v3]
  la v208, gen_arr  ; live: [v2, zero, v208, s11, v3]
  sd v208, 0(v3)  ; live: [v2, zero, s11, v3]
  sd v2, 8(v3)  ; live: [zero, s11, v3]
  mv s10, v3  ; live: [zero, s11, v3]
  ld v202, 0(v3)  ; live: [zero, s11, v3]
  li v203, 2  ; live: [v203, zero, s11, v3]
  mv a0, v203  ; live: [zero, a0, s11, v3]
  li v204, 3  ; live: [v204, zero, a0, s11, v3]
  mv a1, v204  ; live: [zero, a0, a1, s11, v3]
  jalr v202  ; live: [zero, a0, s11, v3]
  mv v6, a0  ; live: [zero, v6, s11, v3]
  mv s10, v3  ; live: [zero, v6, s11, v3]
  ld v198, 0(v3)  ; live: [zero, v6, s11, v3]
  li v199, 3  ; live: [v199, zero, v6, s11, v3]
  mv a0, v199  ; live: [zero, a0, v6, s11, v3]
  li v200, 2  ; live: [zero, a0, v6, s11, v200, v3]
  mv a1, v200  ; live: [zero, a0, v6, a1, s11, v3]
  jalr v198  ; live: [zero, a0, v6, s11, v3]
  mv v7, a0  ; live: [zero, v7, v6, s11, v3]
  mv s10, v3  ; live: [zero, v7, v6, s11, v3]
  ld v194, 0(v3)  ; live: [zero, v7, v6, s11]
  li v195, 2  ; live: [zero, v7, v6, s11, v195]
  mv a0, v195  ; live: [zero, a0, v7, v6, s11]
  li v196, 2  ; live: [zero, a0, v7, v6, s11, v196]
  mv a1, v196  ; live: [zero, a0, v7, v6, a1, s11]
  jalr v194  ; live: [zero, a0, v7, v6, s11]
  mv v8, a0  ; live: [zero, v7, v8, v6, s11]
  slli v191, zero, 3  ; live: [zero, v7, v8, v6, s11, v191]
  add v192, v6, v191  ; live: [zero, v7, v8, v6, s11, v192]
  ld v9, 0(v192)  ; live: [zero, v7, v8, v6, s11, v9]
  li v187, 4607182418800017408  ; live: [zero, v7, v8, v6, s11, v9, v187]
  fmv.d.x fv188, v187  ; live: [zero, fv188, v7, v8, v6, s11, v9]
  slli v189, zero, 3  ; live: [zero, fv188, v7, v8, v6, s11, v9, v189]
  add v190, v9, v189  ; live: [zero, fv188, v7, v8, v6, s11, v190]
  fsd fv188, 0(v190)  ; live: [zero, v7, v8, v6, s11]
  slli v184, zero, 3  ; live: [zero, v7, v8, v184, v6, s11]
  add v185, v6, v184  ; live: [zero, v7, v8, v6, s11, v185]
  ld v11, 0(v185)  ; live: [v11, zero, v7, v8, v6, s11]
  li v179, 4611686018427387904  ; live: [v11, v179, zero, v7, v8, v6, s11]
  fmv.d.x fv180, v179  ; live: [v11, zero, fv180, v7, v8, v6, s11]
  li v181, 1  ; live: [v11, zero, fv180, v7, v8, v6, v181, s11]
  slli v182, v181, 3  ; live: [v11, v182, zero, fv180, v7, v8, v6, s11]
  add v183, v11, v182  ; live: [zero, fv180, v7, v8, v183, v6, s11]
  fsd fv180, 0(v183)  ; live: [zero, v7, v8, v6, s11]
  slli v176, zero, 3  ; live: [v176, zero, v7, v8, v6, s11]
  add v177, v6, v176  ; live: [zero, v7, v8, v6, v177, s11]
  ld v13, 0(v177)  ; live: [zero, v13, v7, v8, v6, s11]
  li v171, 4613937818241073152  ; live: [v171, zero, v13, v7, v8, v6, s11]
  fmv.d.x fv172, v171  ; live: [fv172, zero, v13, v7, v8, v6, s11]
  li v173, 2  ; live: [fv172, zero, v13, v7, v8, v6, s11, v173]
  slli v174, v173, 3  ; live: [fv172, v174, zero, v13, v7, v8, v6, s11]
  add v175, v13, v174  ; live: [fv172, v175, zero, v7, v8, v6, s11]
  fsd fv172, 0(v175)  ; live: [zero, v7, v8, v6, s11]
  li v167, 1  ; live: [zero, v7, v8, v6, s11, v167]
  slli v168, v167, 3  ; live: [v168, zero, v7, v8, v6, s11]
  add v169, v6, v168  ; live: [zero, v169, v7, v8, v6, s11]
  ld v15, 0(v169)  ; live: [zero, v7, v8, v6, s11, v15]
  li v163, 4616189618054758400  ; live: [zero, v7, v8, v6, s11, v15, v163]
  fmv.d.x fv164, v163  ; live: [fv164, zero, v7, v8, v6, s11, v15]
  slli v165, zero, 3  ; live: [fv164, v165, zero, v7, v8, v6, s11, v15]
  add v166, v15, v165  ; live: [fv164, zero, v7, v8, v166, v6, s11]
  fsd fv164, 0(v166)  ; live: [zero, v7, v8, v6, s11]
  li v159, 1  ; live: [zero, v159, v7, v8, v6, s11]
  slli v160, v159, 3  ; live: [zero, v7, v8, v6, s11, v160]
  add v161, v6, v160  ; live: [v161, zero, v7, v8, v6, s11]
  ld v17, 0(v161)  ; live: [zero, v7, v8, v6, v17, s11]
  li v154, 4617315517961601024  ; live: [zero, v7, v8, v6, v17, s11, v154]
  fmv.d.x fv155, v154  ; live: [fv155, zero, v7, v8, v6, v17, s11]
  li v156, 1  ; live: [v156, fv155, zero, v7, v8, v6, v17, s11]
  slli v157, v156, 3  ; live: [fv155, zero, v7, v8, v157, v6, v17, s11]
  add v158, v17, v157  ; live: [fv155, zero, v158, v7, v8, v6, s11]
  fsd fv155, 0(v158)  ; live: [zero, v7, v8, v6, s11]
  li v150, 1  ; live: [zero, v7, v8, v150, v6, s11]
  slli v151, v150, 3  ; live: [zero, v7, v8, v151, v6, s11]
  add v152, v6, v151  ; live: [zero, v7, v8, v152, v6, s11]
  ld v19, 0(v152)  ; live: [zero, v7, v8, v19, v6, s11]
  li v145, 4618441417868443648  ; live: [zero, v7, v8, v19, v6, s11, v145]
  fmv.d.x fv146, v145  ; live: [fv146, zero, v7, v8, v19, v6, s11]
  li v147, 2  ; live: [fv146, zero, v7, v8, v19, v6, s11, v147]
  slli v148, v147, 3  ; live: [fv146, zero, v7, v8, v148, v19, v6, s11]
  add v149, v19, v148  ; live: [fv146, zero, v7, v8, v6, s11, v149]
  fsd fv146, 0(v149)  ; live: [zero, v7, v8, v6, s11]
  slli v142, zero, 3  ; live: [v142, zero, v7, v8, v6, s11]
  add v143, v7, v142  ; live: [zero, v7, v8, v6, s11, v143]
  ld v21, 0(v143)  ; live: [v21, zero, v7, v8, v6, s11]
  li v138, 4619567317775286272  ; live: [v21, zero, v7, v8, v6, s11, v138]
  fmv.d.x fv139, v138  ; live: [fv139, v21, zero, v7, v8, v6, s11]
  slli v140, zero, 3  ; live: [fv139, v21, zero, v7, v8, v6, v140, s11]
  add v141, v21, v140  ; live: [fv139, zero, v7, v8, v141, v6, s11]
  fsd fv139, 0(v141)  ; live: [zero, v7, v8, v6, s11]
  slli v135, zero, 3  ; live: [zero, v7, v8, v6, s11, v135]
  add v136, v7, v135  ; live: [zero, v7, v8, v136, v6, s11]
  ld v23, 0(v136)  ; live: [zero, v23, v7, v8, v6, s11]
  li v130, 4620693217682128896  ; live: [v130, zero, v23, v7, v8, v6, s11]
  fmv.d.x fv131, v130  ; live: [zero, v23, v7, v8, v6, s11, fv131]
  li v132, 1  ; live: [zero, v23, v7, v8, v6, s11, fv131, v132]
  slli v133, v132, 3  ; live: [zero, v23, v133, v7, v8, v6, s11, fv131]
  add v134, v23, v133  ; live: [zero, v8, v7, v134, v6, s11, fv131]
  fsd fv131, 0(v134)  ; live: [zero, v8, v7, v6, s11]
  li v126, 1  ; live: [zero, v126, v8, v7, v6, s11]
  slli v127, v126, 3  ; live: [v127, zero, v8, v7, v6, s11]
  add v128, v7, v127  ; live: [zero, v8, v7, v6, s11, v128]
  ld v25, 0(v128)  ; live: [v25, zero, v8, v7, v6, s11]
  li v122, 4621256167635550208  ; live: [v25, zero, v8, v7, v6, s11, v122]
  fmv.d.x fv123, v122  ; live: [v25, zero, v8, v7, fv123, v6, s11]
  slli v124, zero, 3  ; live: [v25, v124, zero, v8, v7, fv123, v6, s11]
  add v125, v25, v124  ; live: [zero, v125, v8, v7, fv123, v6, s11]
  fsd fv123, 0(v125)  ; live: [zero, v8, v7, v6, s11]
  li v118, 1  ; live: [v118, zero, v8, v7, v6, s11]
  slli v119, v118, 3  ; live: [zero, v119, v8, v7, v6, s11]
  add v120, v7, v119  ; live: [zero, v120, v8, v7, v6, s11]
  ld v27, 0(v120)  ; live: [zero, v27, v8, v7, v6, s11]
  li v113, 4621819117588971520  ; live: [zero, v27, v8, v7, v6, s11, v113]
  fmv.d.x fv114, v113  ; live: [zero, v27, v8, v7, v6, s11, fv114]
  li v115, 1  ; live: [v115, zero, v27, v8, v7, v6, s11, fv114]
  slli v116, v115, 3  ; live: [v116, zero, v27, v8, v7, v6, s11, fv114]
  add v117, v27, v116  ; live: [zero, v8, v7, v6, s11, v117, fv114]
  fsd fv114, 0(v117)  ; live: [zero, v8, v7, v6, s11]
  li v109, 2  ; live: [v109, zero, v8, v7, v6, s11]
  slli v110, v109, 3  ; live: [zero, v110, v8, v7, v6, s11]
  add v111, v7, v110  ; live: [zero, v8, v7, v6, v111, s11]
  ld v29, 0(v111)  ; live: [zero, v29, v8, v7, v6, s11]
  li v105, 4622382067542392832  ; live: [zero, v29, v8, v7, v105, v6, s11]
  fmv.d.x fv106, v105  ; live: [zero, v29, v8, v7, v6, fv106, s11]
  slli v107, zero, 3  ; live: [zero, v29, v8, v7, v107, v6, fv106, s11]
  add v108, v29, v107  ; live: [zero, v8, v7, v6, fv106, v108, s11]
  fsd fv106, 0(v108)  ; live: [zero, v8, v7, v6, s11]
  li v101, 2  ; live: [zero, v8, v7, v6, s11, v101]
  slli v102, v101, 3  ; live: [zero, v8, v7, v6, s11, v102]
  add v103, v7, v102  ; live: [zero, v8, v7, v103, v6, s11]
  ld v31, 0(v103)  ; live: [zero, v8, v7, v6, s11, v31]
  li v96, 4622945017495814144  ; live: [v96, zero, v8, v7, v6, s11, v31]
  fmv.d.x fv97, v96  ; live: [fv97, zero, v8, v7, v6, s11, v31]
  li v98, 1  ; live: [fv97, zero, v8, v7, v6, s11, v31, v98]
  slli v99, v98, 3  ; live: [fv97, v99, zero, v8, v7, v6, s11, v31]
  add v100, v31, v99  ; live: [fv97, zero, v8, v7, v6, s11, v100]
  fsd fv97, 0(v100)  ; live: [zero, v8, v7, v6, s11]
  li v92, 2  ; live: [zero, v8, v7, v92, v6, s11]
  mv a0, v92  ; live: [zero, a0, v8, v7, v6, s11]
  li v93, 3  ; live: [zero, a0, v8, v7, v6, s11, v93]
  mv a1, v93  ; live: [zero, a0, v8, v7, a1, v6, s11]
  li v94, 2  ; live: [v94, zero, a0, v8, v7, a1, v6, s11]
  mv a2, v94  ; live: [zero, a0, v8, v7, a2, a1, v6, s11]
  mv a3, v6  ; live: [zero, a0, v8, v7, a2, a1, s11, a3]
  mv a4, v7  ; live: [zero, a0, a4, v8, a2, a1, s11, a3]
  mv a5, v8  ; live: [a5, zero, a0, a4, v8, a2, a1, s11, a3]
  call matmul  ; live: [s11, zero, v8]
  mv v33, zero  ; live: [s11, zero, v8]
  slli v89, zero, 3  ; live: [s11, zero, v89, v8]
  add v90, v8, v89  ; live: [v90, s11, zero, v8]
  ld v34, 0(v90)  ; live: [s11, zero, v34, v8]
  slli v86, zero, 3  ; live: [s11, v86, zero, v34, v8]
  add v87, v34, v86  ; live: [v87, s11, zero, v8]
  fld fv35, 0(v87)  ; live: [s11, fv35, zero, v8]
  fmv.d fa0, fv35  ; live: [fa0, s11, zero, v8]
  call minimbt_truncate  ; live: [s11, zero, a0, v8]
  mv v36, a0  ; live: [v36, s11, zero, v8]
  mv a0, v36  ; live: [s11, zero, a0, v8]
  call minimbt_print_int  ; live: [s11, zero, v8]
  mv v37, zero  ; live: [s11, zero, v8]
  call minimbt_print_endline  ; live: [s11, zero, v8]
  mv v38, zero  ; live: [s11, zero, v8]
  slli v80, zero, 3  ; live: [v80, s11, zero, v8]
  add v81, v8, v80  ; live: [v81, s11, zero, v8]
  ld v39, 0(v81)  ; live: [s11, zero, v39, v8]
  li v76, 1  ; live: [v76, s11, zero, v39, v8]
  slli v77, v76, 3  ; live: [v8, s11, zero, v39, v77]
  add v78, v39, v77  ; live: [s11, zero, v78, v8]
  fld fv40, 0(v78)  ; live: [s11, zero, fv40, v8]
  fmv.d fa0, fv40  ; live: [fa0, s11, zero, v8]
  call minimbt_truncate  ; live: [s11, zero, a0, v8]
  mv v41, a0  ; live: [v41, s11, zero, v8]
  mv a0, v41  ; live: [s11, zero, a0, v8]
  call minimbt_print_int  ; live: [s11, zero, v8]
  mv v42, zero  ; live: [s11, zero, v8]
  call minimbt_print_endline  ; live: [s11, zero, v8]
  mv v43, zero  ; live: [s11, zero, v8]
  li v69, 1  ; live: [v69, s11, zero, v8]
  slli v70, v69, 3  ; live: [v70, s11, zero, v8]
  add v71, v8, v70  ; live: [v71, s11, zero, v8]
  ld v44, 0(v71)  ; live: [s11, v44, zero, v8]
  slli v66, zero, 3  ; live: [v66, s11, v44, zero, v8]
  add v67, v44, v66  ; live: [s11, zero, v67, v8]
  fld fv45, 0(v67)  ; live: [fv45, s11, zero, v8]
  fmv.d fa0, fv45  ; live: [fa0, s11, zero, v8]
  call minimbt_truncate  ; live: [s11, zero, a0, v8]
  mv v46, a0  ; live: [v46, s11, zero, v8]
  mv a0, v46  ; live: [s11, zero, a0, v8]
  call minimbt_print_int  ; live: [s11, zero, v8]
  mv v47, zero  ; live: [s11, zero, v8]
  call minimbt_print_endline  ; live: [s11, zero, v8]
  mv v48, zero  ; live: [s11, zero, v8]
  li v59, 1  ; live: [v59, s11, zero, v8]
  slli v60, v59, 3  ; live: [s11, zero, v60, v8]
  add v61, v8, v60  ; live: [s11, v61, zero]
  ld v49, 0(v61)  ; live: [s11, v49, zero]
  li v55, 1  ; live: [s11, v49, zero, v55]
  slli v56, v55, 3  ; live: [s11, v49, v56, zero]
  add v57, v49, v56  ; live: [s11, v57, zero]
  fld fv50, 0(v57)  ; live: [fv50, s11, zero]
  fmv.d fa0, fv50  ; live: [s11, zero, fa0]
  call minimbt_truncate  ; live: [s11, zero, a0]
  mv v51, a0  ; live: [s11, zero, v51]
  mv a0, v51  ; live: [s11, zero, a0]
  call minimbt_print_int  ; live: [s11, zero]
  mv v52, zero  ; live: [s11, zero]
; control
  mv a0, zero  ; live: [s11, zero, a0]
  ret  ; live: [s11, zero]

  .p2align 3
  .globl init_arr
  .type init_arr, @function
init_arr:
; block info: defs: [v3, v0, v4, v6, v22, v2], uses: [a0, zero, v22, v0, v6, s10, v2], upward_exposed: [s10, a0, zero], params_defs: []
; live_in: [s11, s10, a0, zero], live_out: [v2, zero, v0, v4, s11, v3]
; block parameters: []
.init_arr_b0:
  mv v0, s10  ; live: [a0, zero, v0, s11, s10]
  mv v2, a0  ; live: [a0, zero, v0, s11, s10, v2]
  lw v3, 8(v0)  ; live: [v2, v0, s11, s10, a0, zero]
  lw v4, 16(v0)  ; live: [v2, s11, s10, a0, zero]
  slt v22, zero, v2  ; live: [v22, s11, s10, a0, zero]
  xori v6, v22, 1  ; live: [v6, s11, s10, a0, zero]
; control
  bne v6, zero, .init_arr_b1  ; live: [s11, s10, a0, zero]
  j .init_arr_b2  ; live: [s11, s10, a0, zero]

; block info: defs: [a0], uses: [v11, a0], upward_exposed: [v11], params_defs: [v11]
; live_in: [v11], live_out: []
; block parameters: [v11]
.init_arr_b3:
; control
  mv a0, v11  ; live: [v11, a0]
  ret  ; live: [v11]

; block info: defs: [v11], uses: [zero], upward_exposed: [zero], params_defs: []
; live_in: [zero], live_out: [v11]
; block parameters: []
.init_arr_b2:
; control
  mv v11, zero  ; live: [zero]
  j .init_arr_b3  ; live: [zero]

; block info: defs: [t1, v16, v14, ft0, ft1, a1, v12, t5, fa1, fa2, ft6, a4, fa6, a6, v19, ft5, ft10, fv21, ft7, v11, ft4, v5, ft9, v10, a5, fa4, a0, ft2, a2, v17, a3, v9, s10, ft8, t3, a7, fa7, t0, fa5, v18, fa3, ft3, fa0, t4, t2], uses: [v3, v5, v16, v14, v10, a0, v0, a1, v17, s11, v9, v18, zero, fa0, v19, v4, fv21, v2], upward_exposed: [v3, zero, v0, v4, s11, v2], params_defs: []
; live_in: [v3, zero, v0, v4, s11, v2], live_out: [v11]
; block parameters: []
.init_arr_b1:
  slli v18, v3, 3  ; live: [v3, v18, zero, v0, v4, s11, v2]
  sub v19, s11, v18  ; live: [v3, zero, v0, v19, v4, s11, v2]
  andi v5, v19, -8  ; live: [v3, v5, zero, v0, v4, s11, v2]
  fmv.d.x fv21, zero  ; live: [v3, v5, zero, v0, v4, s11, fv21, v2]
  mv a1, v3  ; live: [v3, v5, zero, v0, v4, a1, s11, fv21, v2]
  mv a0, v5  ; live: [v3, v5, zero, a0, v0, v4, a1, s11, fv21, v2]
  fmv.d fa0, fv21  ; live: [v3, v5, zero, a0, fa0, v0, v4, a1, s11, v2]
  call _memsetf64  ; live: [v3, v5, zero, v0, v4, s11, v2]
  slli v16, v2, 3  ; live: [v3, v5, v16, zero, v0, v4, s11, v2]
  add v17, v4, v16  ; live: [v3, v5, zero, v0, v4, v17, s11, v2]
  sd v5, 0(v17)  ; live: [v3, zero, v0, v4, s11, v2]
  li v14, 1  ; live: [v3, v14, zero, v0, v4, s11, v2]
  sub v9, v2, v14  ; live: [v3, zero, v0, v4, s11, v9, v2]
  mv s10, v0  ; live: [v3, zero, v0, v4, s11, v9, v2]
  ld v12, 0(v0)  ; live: [v3, zero, v0, v4, s11, v9, v2]
  mv a0, v9  ; live: [v3, zero, a0, v0, v4, s11, v2]
  jalr v12  ; live: [v3, zero, v0, v4, s11, v2]
  mv v10, zero  ; live: [v3, v10, zero, v0, v4, s11, v2]
; control
  mv v11, v10  ; live: [v2, v0, v4, s11, zero, v3]
  j .init_arr_b3  ; live: [v2, v0, v4, s11, zero, v3]

  .p2align 3
  .globl thunk_start
  .type thunk_start, @function
thunk_start:
; block info: defs: [t1, ft0, ft1, a1, t5, fa1, fa2, ft6, a4, fa6, a6, ft5, ft10, ft7, ft4, ft9, a5, a0, fa4, ft2, a2, a3, ft8, t3, a7, fa7, t0, fa5, fa3, ft3, fa0, t4, t2, v2], uses: [zero, a0, v2], upward_exposed: [zero], params_defs: []
; live_in: [zero], live_out: []
; block parameters: []
.thunk_start_b0:
  call main  ; live: [zero]
  mv v2, zero  ; live: [zero, v2]
; control
  mv a0, v2  ; live: [zero, a0]
  ret  ; live: [zero]

  .p2align 3
  .globl loop3
  .type loop3, @function
loop3:
; block info: defs: [v2, v51, v5, v7, v8, v0, v4, v6, v3], uses: [v51, a0, zero, v8, v0, s10, v2], upward_exposed: [s10, a0, zero], params_defs: []
; live_in: [s10, a0, zero], live_out: [v3, v5, zero, v7, v0, v4, v6, v2]
; block parameters: []
.loop3_b0:
  mv v0, s10  ; live: [v0, s10, a0, zero]
  mv v2, a0  ; live: [v2, v0, s10, a0, zero]
  lw v3, 8(v0)  ; live: [v2, v0, s10, a0, zero]
  lw v4, 16(v0)  ; live: [v2, v0, s10, a0, zero]
  lw v5, 24(v0)  ; live: [v2, v0, s10, a0, zero]
  lw v6, 32(v0)  ; live: [v2, v0, s10, a0, zero]
  lw v7, 40(v0)  ; live: [v2, s10, a0, zero]
  slt v51, zero, v2  ; live: [v51, s10, a0, zero]
  xori v8, v51, 1  ; live: [v8, s10, a0, zero]
; control
  bne v8, zero, .loop3_b1  ; live: [s10, a0, zero]
  j .loop3_b2  ; live: [s10, a0, zero]

; block info: defs: [v22, a1, fv15, t5, v33, fa1, fa2, ft6, v27, a4, fa6, v20, a6, ft5, ft10, ft4, v10, v49, ft9, fa4, ft2, v37, v43, a3, v31, a7, fa7, v48, fa3, fv11, ft3, v45, t2, fv17, v40, t1, v14, v42, v26, ft0, ft1, v12, fv16, v19, v34, ft7, v46, v21, a5, a0, v30, v36, a2, v24, s10, v9, v39, ft8, t3, t0, fa5, fv13, fa0, t4], uses: [v2, v40, v14, v42, v26, v7, v0, v12, fv15, fv16, v33, zero, v27, v20, v19, v4, v6, v34, v46, v5, v10, v49, a0, v30, v36, v37, v43, v24, v31, v9, v39, v48, fv11, v45, fv13, fv17, v3], upward_exposed: [v3, v5, zero, v7, v0, v4, v6, v2], params_defs: []
; live_in: [v2, v5, zero, v7, v0, v4, v6, v3], live_out: [v21]
; block parameters: []
.loop3_b1:
  slli v48, v4, 3  ; live: [v3, v5, v48, zero, v7, v0, v4, v6, v2]
  add v49, v3, v48  ; live: [v3, v5, v49, zero, v7, v0, v4, v6, v2]
  ld v9, 0(v49)  ; live: [v3, v5, zero, v7, v0, v4, v6, v9, v2]
  slli v45, v4, 3  ; live: [v3, v5, zero, v7, v45, v0, v4, v6, v9, v2]
  add v46, v3, v45  ; live: [v3, v5, v46, zero, v7, v0, v4, v6, v9, v2]
  ld v10, 0(v46)  ; live: [v3, v5, v10, zero, v7, v0, v4, v6, v9, v2]
  slli v42, v5, 3  ; live: [v3, v5, v10, zero, v42, v7, v0, v4, v6, v9, v2]
  add v43, v10, v42  ; live: [v3, v5, zero, v7, v0, v4, v6, v43, v9, v2]
  fld fv11, 0(v43)  ; live: [v3, v5, zero, fv11, v7, v0, v4, v6, v9, v2]
  slli v39, v4, 3  ; live: [v3, v5, zero, fv11, v7, v0, v4, v6, v9, v39, v2]
  add v40, v6, v39  ; live: [v3, v40, v5, zero, fv11, v7, v0, v4, v6, v9, v2]
  ld v12, 0(v40)  ; live: [v3, v5, zero, fv11, v7, v0, v4, v6, v12, v9, v2]
  slli v36, v2, 3  ; live: [v3, v5, zero, fv11, v7, v36, v0, v4, v6, v12, v9, v2]
  add v37, v12, v36  ; live: [v3, v5, zero, fv11, v7, v0, v4, v37, v6, v9, v2]
  fld fv13, 0(v37)  ; live: [v3, v5, zero, fv11, fv13, v7, v0, v4, v6, v9, v2]
  slli v33, v2, 3  ; live: [v3, v5, zero, fv11, fv13, v7, v0, v4, v6, v9, v33, v2]
  add v34, v7, v33  ; live: [v3, v5, zero, fv11, fv13, v7, v0, v4, v6, v9, v34, v2]
  ld v14, 0(v34)  ; live: [v3, v5, v14, zero, fv11, fv13, v7, v0, v4, v6, v9, v2]
  slli v30, v5, 3  ; live: [v3, v5, v14, zero, fv11, v30, fv13, v7, v0, v4, v6, v9, v2]
  add v31, v14, v30  ; live: [v3, v5, zero, fv11, v7, fv13, v0, v4, v6, v31, v9, v2]
  fld fv15, 0(v31)  ; live: [v3, v5, zero, fv11, v7, fv13, v0, v4, v6, fv15, v9, v2]
  fmul.d fv16, fv13, fv15  ; live: [v3, v5, zero, fv11, v7, v0, v4, v6, fv16, v9, v2]
  fadd.d fv17, fv11, fv16  ; live: [v3, v5, zero, v7, v0, v4, v6, fv17, v9, v2]
  slli v26, v5, 3  ; live: [v3, v5, zero, v26, v7, v0, v4, v6, fv17, v9, v2]
  add v27, v9, v26  ; live: [v3, v5, zero, v27, v7, v0, v4, v6, fv17, v2]
  fsd fv17, 0(v27)  ; live: [v3, v5, zero, v7, v0, v4, v6, v2]
  li v24, 1  ; live: [v3, v5, zero, v7, v0, v4, v6, v24, v2]
  sub v19, v2, v24  ; live: [v3, v5, zero, v7, v0, v19, v4, v6, v2]
  mv s10, v0  ; live: [v3, v5, zero, v7, v0, v19, v4, v6, v2]
  ld v22, 0(v0)  ; live: [v3, v5, zero, v7, v0, v19, v4, v6, v2]
  mv a0, v19  ; live: [v3, v5, zero, a0, v7, v0, v4, v6, v2]
  jalr v22  ; live: [v3, v5, zero, v7, v0, v4, v6, v2]
  mv v20, zero  ; live: [v3, v5, zero, v20, v7, v0, v4, v6, v2]
; control
  mv v21, v20  ; live: [v3, v5, zero, v7, v0, v4, v6, v2]
  j .loop3_b3  ; live: [v3, v5, zero, v7, v0, v4, v6, v2]

; block info: defs: [v21], uses: [zero], upward_exposed: [zero], params_defs: []
; live_in: [zero], live_out: [v21]
; block parameters: []
.loop3_b2:
; control
  mv v21, zero  ; live: [zero]
  j .loop3_b3  ; live: [zero]

; block info: defs: [a0], uses: [v21, a0], upward_exposed: [v21], params_defs: [v21]
; live_in: [v21], live_out: []
; block parameters: [v21]
.loop3_b3:
; control
  mv a0, v21  ; live: [v21, a0]
  ret  ; live: [v21]

  .p2align 3
  .globl loop1
  .type loop1, @function
loop1:
; block info: defs: [v2, v5, v27, v7, v0, v4, v6, v9, v3], uses: [a0, zero, v27, v0, s10, v9, v2], upward_exposed: [s10, a0, zero], params_defs: []
; live_in: [s11, s10, a0, zero], live_out: [v3, v5, zero, v7, v0, v4, v6, s11, v2]
; block parameters: []
.loop1_b0:
  mv v0, s10  ; live: [a0, zero, v0, s11, s10]
  mv v2, a0  ; live: [a0, zero, v0, s11, s10, v2]
  lw v3, 8(v0)  ; live: [a0, zero, v0, s11, s10, v2]
  lw v4, 16(v0)  ; live: [a0, zero, v0, s11, s10, v2]
  lw v5, 24(v0)  ; live: [a0, zero, v0, s11, s10, v2]
  lw v6, 32(v0)  ; live: [v2, v0, s11, s10, a0, zero]
  lw v7, 40(v0)  ; live: [v2, s11, s10, a0, zero]
  slt v27, zero, v2  ; live: [v27, s11, s10, a0, zero]
  xori v9, v27, 1  ; live: [v9, s11, s10, a0, zero]
; control
  bne v9, zero, .loop1_b1  ; live: [s11, s10, a0, zero]
  j .loop1_b2  ; live: [s11, s10, a0, zero]

; block info: defs: [t1, v16, v14, v26, v13, v22, ft0, ft1, a1, v12, t5, fa1, fa2, ft6, v20, a4, fa6, v8, a6, ft10, ft5, ft7, v11, ft4, ft9, a5, a0, fa4, ft2, a2, v24, a3, s10, ft8, a7, t3, fa7, t0, fa5, v18, fa3, ft3, fa0, t4, t2, v15], uses: [v3, v11, v5, v14, v26, a0, v13, v22, v7, v0, v24, s11, v18, zero, v8, v4, v6, v2], upward_exposed: [v3, v5, zero, v7, v0, v4, v6, s11, v2], params_defs: []
; live_in: [v2, v5, zero, v7, v0, v4, v6, s11, v3], live_out: [v15]
; block parameters: []
.loop1_b1:
  addi v24, s11, -48  ; live: [v3, v5, zero, v7, v0, v4, v6, s11, v24, v2]
  andi v8, v24, -8  ; live: [v3, v5, zero, v7, v8, v0, v4, v6, s11, v2]
  la v26, loop2  ; live: [v3, v5, zero, v26, v7, v8, v0, v4, v6, s11, v2]
  sd v26, 0(v8)  ; live: [v3, v5, zero, v7, v8, v0, v4, v6, s11, v2]
  sd v3, 8(v8)  ; live: [v3, v5, zero, v7, v8, v0, v4, v6, s11, v2]
  sd v2, 16(v8)  ; live: [v3, v5, zero, v7, v8, v0, v4, v6, s11, v2]
  sd v4, 24(v8)  ; live: [v3, v5, zero, v7, v8, v0, v4, v6, s11, v2]
  sd v5, 32(v8)  ; live: [v3, v5, zero, v7, v8, v0, v4, v6, s11, v2]
  sd v6, 40(v8)  ; live: [v3, v5, zero, v7, v8, v0, v4, v6, s11, v2]
  li v22, 1  ; live: [v3, v5, zero, v22, v7, v8, v0, v4, v6, s11, v2]
  sub v11, v7, v22  ; live: [v3, v11, v5, zero, v7, v8, v0, v4, v6, s11, v2]
  mv s10, v8  ; live: [v3, v11, v5, zero, v7, v8, v0, v4, v6, s11, v2]
  ld v20, 0(v8)  ; live: [v3, v11, v5, zero, v7, v0, v4, v6, s11, v2]
  mv a0, v11  ; live: [v3, v5, zero, a0, v7, v0, v4, v6, s11, v2]
  jalr v20  ; live: [v3, v5, zero, v7, v0, v4, v6, s11, v2]
  mv v12, zero  ; live: [v3, v5, zero, v7, v0, v4, v6, s11, v2]
  li v18, 1  ; live: [v3, v5, v18, zero, v7, v0, v4, v6, s11, v2]
  sub v13, v2, v18  ; live: [v3, v5, zero, v13, v7, v0, v4, v6, s11, v2]
  mv s10, v0  ; live: [v3, v5, zero, v13, v7, v0, v4, v6, s11, v2]
  ld v16, 0(v0)  ; live: [v3, v5, zero, v13, v7, v0, v4, v6, s11, v2]
  mv a0, v13  ; live: [v3, v5, zero, a0, v7, v0, v4, v6, s11, v2]
  jalr v16  ; live: [v3, v5, zero, v7, v0, v4, v6, s11, v2]
  mv v14, zero  ; live: [v3, v5, v14, zero, v7, v0, v4, v6, s11, v2]
; control
  mv v15, v14  ; live: [v3, v5, zero, v7, v0, v4, v6, s11, v2]
  j .loop1_b3  ; live: [v3, v5, zero, v7, v0, v4, v6, s11, v2]

; block info: defs: [v15], uses: [zero], upward_exposed: [zero], params_defs: []
; live_in: [zero], live_out: [v15]
; block parameters: []
.loop1_b2:
; control
  mv v15, zero  ; live: [zero]
  j .loop1_b3  ; live: [zero]

; block info: defs: [a0], uses: [v15, a0], upward_exposed: [v15], params_defs: [v15]
; live_in: [v15], live_out: []
; block parameters: [v15]
.loop1_b3:
; control
  mv a0, v15  ; live: [v15, a0]
  ret  ; live: [v15]

  .p2align 3
  .globl start
  .type start, @object
start:
  .zero 4



Testing test/test_src/non-tail-if.mbt
# name conventions used in the core ir:
# - functions: f<id>
# - blocks: b<id>
# - instructions: %<id>
# - memory: m<id>
# - free variables: ^<id>
# - function parameters: $f<pid>
# - block parameters: $b<bid>.<pid>
.core
.fn thunk_start #f1 : fn() -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: unit = call f0()
    return %0
  }
}
.fn main #f0 : fn() -> unit
.freevars ()
.entry b0 {
  .bb #b6 (int32) {
    let %6: int32 = add($b3.0, $b6.0)
    let %7: bool = le(0, %1)
    br %7 b7() b8()
  }
  .bb #b4 () {
    jump b6(%1)
  }
  .bb #b8 () {
    jump b9(%0)
  }
  .bb #b9 (int32) {
    let %8: int32 = add(%6, $b9.0)
    let %9: unit = ext_call minimbt_print_int(%8)
    return %9
  }
  .bb #b0 () {
    let %0: int32 = ext_call minimbt_truncate(1.23)
    let %1: int32 = ext_call minimbt_truncate(4.56)
    let %2: double = neg(7.89)
    let %3: int32 = ext_call minimbt_truncate(%2)
    let %4: bool = le(0, %3)
    br %4 b1() b2()
  }
  .bb #b1 () {
    jump b3(%0)
  }
  .bb #b5 () {
    jump b6(%3)
  }
  .bb #b2 () {
    jump b3(%1)
  }
  .bb #b3 (int32) {
    let %5: bool = le(%0, 0)
    br %5 b4() b5()
  }
  .bb #b7 () {
    jump b9(%3)
  }
}
.thunk ::0 start

  .p2align 3
  .globl _start
  .type _start, @function
_start:
; block info: defs: [t1, ft0, ft1, a1, t5, fa1, fa2, ft6, a4, fa6, a6, ft5, ft10, ft7, ft4, ft9, a5, a0, fa4, ft2, a2, a3, ft8, t3, a7, fa7, t0, fa5, fa3, ft3, fa0, t4, t2], uses: [a0], upward_exposed: [], params_defs: []
; live_in: [], live_out: []
; block parameters: []
_start_b0:
  call thunk_start  ; live: [a0]
; control
  ret  ; live: []

  .p2align 3
  .globl thunk_start
  .type thunk_start, @function
thunk_start:
; block info: defs: [t1, ft0, ft1, a1, t5, fa1, fa2, ft6, a4, fa6, a6, ft5, ft10, ft7, ft4, ft9, a5, a0, fa4, ft2, a2, a3, ft8, t3, a7, fa7, t0, fa5, fa3, ft3, fa0, t4, t2, v2], uses: [zero, a0, v2], upward_exposed: [zero], params_defs: []
; live_in: [zero], live_out: []
; block parameters: []
.thunk_start_b0:
  call main  ; live: [zero]
  mv v2, zero  ; live: [zero, v2]
; control
  mv a0, v2  ; live: [zero, a0]
  ret  ; live: [zero]

  .p2align 3
  .globl main
  .type main, @function
main:
; block info: defs: [v3, v25, t1, v22, ft0, ft1, a1, t5, v28, fa1, fa2, ft6, a4, fa6, a6, ft5, ft10, v6, ft7, ft4, v5, fv32, ft9, a5, a0, fa4, ft2, a2, fv4, a3, v31, fv26, ft8, a7, t3, fa7, t0, fa5, fa3, ft3, fa0, fv29, t4, t2, v2], uses: [v25, v5, fv32, a0, v22, fv4, v31, v28, fv26, zero, fa0, fv29, v6], upward_exposed: [zero], params_defs: []
; live_in: [zero], live_out: [v3, v5, zero, v2]
; block parameters: []
.main_b0:
  li v31, 4608218246714312622  ; live: [v31, zero]
  fmv.d.x fv32, v31  ; live: [fv32, zero]
  fmv.d fa0, fv32  ; live: [zero, fa0]
  call minimbt_truncate  ; live: [zero, a0]
  mv v2, a0  ; live: [zero]
  li v28, 4616820122002590269  ; live: [v28, zero]
  fmv.d.x fv29, v28  ; live: [fv29, zero]
  fmv.d fa0, fv29  ; live: [zero, fa0]
  call minimbt_truncate  ; live: [zero, a0]
  mv v3, a0  ; live: [zero]
  li v25, 4620569368692376207  ; live: [v25, zero]
  fmv.d.x fv26, v25  ; live: [zero, fv26]
  fneg.d fv4, fv26  ; live: [fv4, zero]
  fmv.d fa0, fv4  ; live: [zero, fa0]
  call minimbt_truncate  ; live: [zero, a0]
  mv v5, a0  ; live: [v5, zero]
  slt v22, zero, v5  ; live: [zero, v22]
  xori v6, v22, 1  ; live: [v6, zero]
; control
  bne v6, zero, .main_b1  ; live: [zero]
  j .main_b2  ; live: [zero]

; block info: defs: [v7], uses: [v2], upward_exposed: [v2], params_defs: []
; live_in: [v3, v5, zero, v2], live_out: [v7, v3, v5, zero, v2]
; block parameters: []
.main_b1:
; control
  mv v7, v2  ; live: [v2, v5, zero, v3]
  j .main_b3  ; live: [v2, v5, zero, v3]

; block info: defs: [v12], uses: [v2], upward_exposed: [v2], params_defs: []
; live_in: [v10, zero, v2], live_out: [v12, v10, zero]
; block parameters: []
.main_b8:
; control
  mv v12, v2  ; live: [v10, zero, v2]
  j .main_b9  ; live: [v10, zero, v2]

; block info: defs: [v9], uses: [v5], upward_exposed: [v5], params_defs: []
; live_in: [v7, v2, v5, zero, v3], live_out: [v2, v5, zero, v7, v9, v3]
; block parameters: []
.main_b5:
; control
  mv v9, v5  ; live: [v2, v3, v5, zero, v7]
  j .main_b6  ; live: [v2, v3, v5, zero, v7]

; block info: defs: [v9], uses: [v3], upward_exposed: [v3], params_defs: []
; live_in: [v7, v2, v5, zero, v3], live_out: [v2, v5, zero, v7, v9, v3]
; block parameters: []
.main_b4:
; control
  mv v9, v3  ; live: [v2, v3, v5, zero, v7]
  j .main_b6  ; live: [v2, v3, v5, zero, v7]

; block info: defs: [v11, v17, v10], uses: [v11, zero, v7, v17, v9, v3], upward_exposed: [v3, v9, zero, v7], params_defs: [v9]
; live_in: [v3, v5, zero, v7, v9, v2], live_out: [v5, v10, zero, v2]
; block parameters: [v9]
.main_b6:
  add v10, v7, v9  ; live: [v3, v5, zero, v7, v9, v2]
  slt v17, zero, v3  ; live: [v3, v5, zero, v7, v17, v9, v2]
  xori v11, v17, 1  ; live: [v3, v11, v5, zero, v7, v9, v2]
; control
  bne v11, zero, .main_b7  ; live: [v7, v2, v5, zero, v9, v3]
  j .main_b8  ; live: [v7, v2, v5, zero, v9, v3]

; block info: defs: [t1, v14, v13, ft0, ft1, a1, t5, fa1, fa2, ft6, a4, fa6, a6, ft5, ft10, ft7, ft4, ft9, a5, a0, fa4, ft2, a2, a3, ft8, t3, a7, fa7, t0, fa5, fa3, ft3, fa0, t4, t2], uses: [v14, v10, v13, a0, zero, v12], upward_exposed: [v10, v12, zero], params_defs: [v12]
; live_in: [v12, v10, zero], live_out: []
; block parameters: [v12]
.main_b9:
  add v13, v10, v12  ; live: [v12, v10, zero, v13]
  mv a0, v13  ; live: [v12, v10, zero, a0]
  call minimbt_print_int  ; live: [v12, v10, zero]
  mv v14, zero  ; live: [v14, v12, v10, zero]
; control
  mv a0, v14  ; live: [v12, v10, zero, a0]
  ret  ; live: [v12, v10, zero]

; block info: defs: [v7], uses: [v3], upward_exposed: [v3], params_defs: []
; live_in: [v2, v5, zero, v3], live_out: [v7, v3, v5, zero, v2]
; block parameters: []
.main_b2:
; control
  mv v7, v3  ; live: [v3, v5, zero, v2]
  j .main_b3  ; live: [v3, v5, zero, v2]

; block info: defs: [v12], uses: [v5], upward_exposed: [v5], params_defs: []
; live_in: [v5, v10, zero], live_out: [v12, v10, zero]
; block parameters: []
.main_b7:
; control
  mv v12, v5  ; live: [v5, v10, zero]
  j .main_b9  ; live: [v5, v10, zero]

; block info: defs: [v20, v8], uses: [v8, zero, v20, v2], upward_exposed: [zero, v2], params_defs: [v7]
; live_in: [v2, v3, v5, zero, v7], live_out: [v7, v2, v5, zero, v3]
; block parameters: [v7]
.main_b3:
  slt v20, v2, zero  ; live: [v2, v5, zero, v20, v7, v3]
  xori v8, v20, 1  ; live: [v2, v5, zero, v7, v8, v3]
; control
  bne v8, zero, .main_b4  ; live: [v3, v7, v5, zero, v2]
  j .main_b5  ; live: [v3, v7, v5, zero, v2]

  .p2align 3
  .globl start
  .type start, @object
start:
  .zero 4



Testing test/test_src/non-tail-if2.mbt
# name conventions used in the core ir:
# - functions: f<id>
# - blocks: b<id>
# - instructions: %<id>
# - memory: m<id>
# - free variables: ^<id>
# - function parameters: $f<pid>
# - block parameters: $b<bid>.<pid>
.core
.fn f #f1 : closure() -> int32
.freevars ()
.entry b0 {
  .bb #b0 () {
    return 12345
  }
}
.fn thunk_start #f2 : fn() -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: unit = call f0()
    return %0
  }
}
.fn main #f0 : fn() -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let _ = alloc <m0: closure() -> int32 heap(1)> <- [0] = f1
    let _ = alloc <m1: array[int32] heap(10)> <- [..] = 3
    let %2: int32 = load int32 offset(f0.m1, 0)
    let %3: bool = eq(%2, 3)
    br %3 b1() b2()
  }
  .bb #b1 () {
    let %4: int32 = apply f0.m0()
    let %5: int32 = load int32 offset(f0.m1, 1)
    let %6: int32 = add(%4, %5)
    let %7: int32 = add(%6, 67890)
    jump b3(%7)
  }
  .bb #b2 () {
    jump b3(7)
  }
  .bb #b3 (int32) {
    let %8: unit = ext_call minimbt_print_int($b3.0)
    return %8
  }
}
.thunk ::0 start

  .p2align 3
  .globl _start
  .type _start, @function
_start:
; block info: defs: [t1, ft0, ft1, a1, t5, fa1, fa2, ft6, a4, fa6, a6, ft5, ft10, ft7, ft4, ft9, a5, a0, fa4, ft2, a2, a3, ft8, t3, a7, fa7, t0, fa5, fa3, ft3, fa0, t4, t2], uses: [a0], upward_exposed: [], params_defs: []
; live_in: [], live_out: []
; block parameters: []
_start_b0:
  call thunk_start  ; live: [a0]
; control
  ret  ; live: []

  .p2align 3
  .globl f
  .type f, @function
f:
; block info: defs: [a0, v2], uses: [a0, v2], upward_exposed: [], params_defs: []
; live_in: [], live_out: []
; block parameters: []
.f_b0:
; control
  li v2, 12345  ; live: [v2]
  mv a0, v2  ; live: [a0]
  ret  ; live: []

  .p2align 3
  .globl thunk_start
  .type thunk_start, @function
thunk_start:
; block info: defs: [t1, ft0, ft1, a1, t5, fa1, fa2, ft6, a4, fa6, a6, ft5, ft10, ft7, ft4, ft9, a5, a0, fa4, ft2, a2, a3, ft8, t3, a7, fa7, t0, fa5, fa3, ft3, fa0, t4, t2, v2], uses: [zero, a0, v2], upward_exposed: [zero], params_defs: []
; live_in: [zero], live_out: []
; block parameters: []
.thunk_start_b0:
  call main  ; live: [zero]
  mv v2, zero  ; live: [zero, v2]
; control
  mv a0, v2  ; live: [zero, a0]
  ret  ; live: [zero]

  .p2align 3
  .globl main
  .type main, @function
main:
; block info: defs: [v2, v3, v25, v29, v26, v36, v7, v6, v31, v28, v33, v34], uses: [v2, v25, v26, v36, v7, s11, v31, v28, v33, zero, v29, v6, v34, v3], upward_exposed: [s11, zero], params_defs: []
; live_in: [s11, zero], live_out: [v3, zero, v2]
; block parameters: []
.main_b0:
  addi v34, s11, -8  ; live: [s11, zero, v34]
  andi v2, v34, -8  ; live: [s11, zero, v2]
  la v36, f  ; live: [v2, s11, zero, v36]
  sd v36, 0(v2)  ; live: [s11, zero]
  addi v31, s11, -40  ; live: [s11, v31, zero]
  andi v3, v31, -8  ; live: [s11, zero, v3]
  li v33, 3  ; live: [s11, zero, v33, v3]
  sw v33, 0(v3)  ; live: [s11, zero, v33, v3]
  sw v33, 4(v3)  ; live: [s11, zero, v33, v3]
  sw v33, 8(v3)  ; live: [s11, zero, v33, v3]
  sw v33, 12(v3)  ; live: [s11, zero, v33, v3]
  sw v33, 16(v3)  ; live: [s11, zero, v33, v3]
  sw v33, 20(v3)  ; live: [s11, zero, v33, v3]
  sw v33, 24(v3)  ; live: [s11, zero, v33, v3]
  sw v33, 28(v3)  ; live: [s11, zero, v33, v3]
  sw v33, 32(v3)  ; live: [s11, zero, v33, v3]
  sw v33, 36(v3)  ; live: [s11, zero, v3]
  slli v28, zero, 2  ; live: [s11, v28, zero, v3]
  add v29, v3, v28  ; live: [s11, zero, v29]
  lw v6, 0(v29)  ; live: [v6, s11, zero]
  li v25, 3  ; live: [v25, v6, s11, zero]
  xor v26, v6, v25  ; live: [s11, zero, v26]
  sltiu v7, v26, 1  ; live: [s11, zero, v7]
; control
  bne v7, zero, .main_b1  ; live: [s11, zero]
  j .main_b2  ; live: [s11, zero]

; block info: defs: [t1, v13, ft0, ft1, a1, t5, fa1, fa2, ft6, a4, fa6, a6, ft5, ft10, ft7, ft4, ft9, a5, a0, fa4, ft2, a2, a3, ft8, t3, a7, fa7, t0, fa5, fa3, ft3, fa0, t4, t2], uses: [v12, a0, zero, v13], upward_exposed: [v12, zero], params_defs: [v12]
; live_in: [v12, zero], live_out: []
; block parameters: [v12]
.main_b3:
  mv a0, v12  ; live: [v12, zero, a0]
  call minimbt_print_int  ; live: [v12, zero]
  mv v13, zero  ; live: [v12, zero, v13]
; control
  mv a0, v13  ; live: [v12, zero, a0]
  ret  ; live: [v12, zero]

; block info: defs: [t1, v22, ft0, ft1, a1, v12, t5, fa1, fa2, ft6, a4, fa6, v20, v8, v19, a6, ft10, ft5, ft7, v11, ft4, ft9, v10, a5, fa4, a0, ft2, a2, a3, s10, v9, ft8, a7, t3, fa7, t0, fa5, v18, fa3, ft3, fa0, t4, t2, v15], uses: [v2, v11, v18, v10, a0, v20, v8, v19, v15, v9, v3], upward_exposed: [v3, v2], params_defs: []
; live_in: [v2, zero, v3], live_out: [v12, zero]
; block parameters: []
.main_b1:
  mv s10, v2  ; live: [v3, zero, v2]
  ld v22, 0(v2)  ; live: [v3, zero, v2]
  jalr v22  ; live: [v3, zero, a0, v2]
  mv v8, a0  ; live: [v3, v8, zero, v2]
  li v18, 1  ; live: [v3, v8, v18, zero, v2]
  slli v19, v18, 2  ; live: [v3, v8, v19, zero, v2]
  add v20, v3, v19  ; live: [v3, v8, zero, v20, v2]
  lw v9, 0(v20)  ; live: [v3, v8, zero, v9, v2]
  add v10, v8, v9  ; live: [v3, v10, zero, v2]
  li v15, 67890  ; live: [v3, v10, v15, zero, v2]
  add v11, v10, v15  ; live: [v3, v11, zero, v2]
; control
  mv v12, v11  ; live: [v3, zero, v2]
  j .main_b3  ; live: [v3, zero, v2]

; block info: defs: [v24, v12], uses: [v24], upward_exposed: [], params_defs: []
; live_in: [zero], live_out: [v12, zero]
; block parameters: []
.main_b2:
; control
  li v24, 7  ; live: [v24, zero]
  mv v12, v24  ; live: [zero]
  j .main_b3  ; live: [zero]

  .p2align 3
  .globl start
  .type start, @object
start:
  .zero 4



Testing test/test_src/print.mbt
# name conventions used in the core ir:
# - functions: f<id>
# - blocks: b<id>
# - instructions: %<id>
# - memory: m<id>
# - free variables: ^<id>
# - function parameters: $f<pid>
# - block parameters: $b<bid>.<pid>
.core
.fn thunk_start #f1 : fn() -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: unit = call f0()
    return %0
  }
}
.fn main #f0 : fn() -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: unit = ext_call minimbt_print_int(123)
    let %1: int32 = neg(456)
    let %2: unit = ext_call minimbt_print_int(%1)
    let %3: int32 = add(789, 0)
    let %4: unit = ext_call minimbt_print_int(%3)
    return ()
  }
}
.thunk ::0 start

  .p2align 3
  .globl _start
  .type _start, @function
_start:
; block info: defs: [t1, ft0, ft1, a1, t5, fa1, fa2, ft6, a4, fa6, a6, ft5, ft10, ft7, ft4, ft9, a5, a0, fa4, ft2, a2, a3, ft8, t3, a7, fa7, t0, fa5, fa3, ft3, fa0, t4, t2], uses: [a0], upward_exposed: [], params_defs: []
; live_in: [], live_out: []
; block parameters: []
_start_b0:
  call thunk_start  ; live: [a0]
; control
  ret  ; live: []

  .p2align 3
  .globl thunk_start
  .type thunk_start, @function
thunk_start:
; block info: defs: [t1, ft0, ft1, a1, t5, fa1, fa2, ft6, a4, fa6, a6, ft5, ft10, ft7, ft4, ft9, a5, a0, fa4, ft2, a2, a3, ft8, t3, a7, fa7, t0, fa5, fa3, ft3, fa0, t4, t2, v2], uses: [zero, a0, v2], upward_exposed: [zero], params_defs: []
; live_in: [zero], live_out: []
; block parameters: []
.thunk_start_b0:
  call main  ; live: [zero]
  mv v2, zero  ; live: [zero, v2]
; control
  mv a0, v2  ; live: [zero, a0]
  ret  ; live: [zero]

  .p2align 3
  .globl main
  .type main, @function
main:
; block info: defs: [v3, t1, v13, ft0, ft1, a1, t5, fa1, fa2, ft6, a4, fa6, v8, a6, ft10, v4, ft5, v6, ft7, v11, ft4, v5, ft9, a5, a0, fa4, ft2, a2, a3, ft8, t3, a7, fa7, t0, fa5, fa3, ft3, fa0, t4, t2, v2], uses: [v11, v5, v13, a0, zero, v8, v3], upward_exposed: [zero], params_defs: []
; live_in: [zero], live_out: []
; block parameters: []
.main_b0:
  li v13, 123  ; live: [zero, v13]
  mv a0, v13  ; live: [zero, a0]
  call minimbt_print_int  ; live: [zero]
  mv v2, zero  ; live: [zero]
  li v11, 456  ; live: [v11, zero]
  neg v3, v11  ; live: [zero, v3]
  mv a0, v3  ; live: [zero, a0]
  call minimbt_print_int  ; live: [zero]
  mv v4, zero  ; live: [zero]
  li v8, 789  ; live: [zero, v8]
  add v5, v8, zero  ; live: [v5, zero]
  mv a0, v5  ; live: [zero, a0]
  call minimbt_print_int  ; live: [zero]
  mv v6, zero  ; live: [zero]
; control
  mv a0, zero  ; live: [zero, a0]
  ret  ; live: [zero]

  .p2align 3
  .globl start
  .type start, @object
start:
  .zero 4



Testing test/test_src/shuffle.mbt
# name conventions used in the core ir:
# - functions: f<id>
# - blocks: b<id>
# - instructions: %<id>
# - memory: m<id>
# - free variables: ^<id>
# - function parameters: $f<pid>
# - block parameters: $b<bid>.<pid>
.core
.fn foo #f0 : fn(int32, int32, int32, int32, int32, int32) -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: unit = ext_call minimbt_print_int($f0)
    let %1: unit = ext_call minimbt_print_int($f1)
    let %2: unit = ext_call minimbt_print_int($f2)
    let %3: unit = ext_call minimbt_print_int($f3)
    let %4: unit = ext_call minimbt_print_int($f4)
    let %5: unit = ext_call minimbt_print_int($f5)
    return ()
  }
}
.fn bar #f1 : fn(int32, int32, int32, int32, int32, int32) -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: unit = call f0($f1, $f0, $f3, $f4, $f5, $f2)
    return %0
  }
}
.fn thunk_start #f3 : fn() -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: unit = call f2()
    return %0
  }
}
.fn main #f2 : fn() -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: unit = call f1(1, 2, 3, 4, 5, 6)
    return %0
  }
}
.thunk ::0 start

  .p2align 3
  .globl _start
  .type _start, @function
_start:
; block info: defs: [t1, ft0, ft1, a1, t5, fa1, fa2, ft6, a4, fa6, a6, ft5, ft10, ft7, ft4, ft9, a5, a0, fa4, ft2, a2, a3, ft8, t3, a7, fa7, t0, fa5, fa3, ft3, fa0, t4, t2], uses: [a0], upward_exposed: [], params_defs: []
; live_in: [], live_out: []
; block parameters: []
_start_b0:
  call thunk_start  ; live: [a0]
; control
  ret  ; live: []

  .p2align 3
  .globl foo
  .type foo, @function
foo:
; block info: defs: [v2, t1, v13, v7, ft0, ft1, a1, v12, t5, fa1, fa2, ft6, a4, fa6, v8, a6, ft5, ft10, v4, v6, ft7, v11, ft4, v5, ft9, v10, a5, fa4, a0, ft2, a2, a3, v9, ft8, t3, a7, fa7, t0, fa5, fa3, ft3, fa0, t4, t2, v3], uses: [v2, v5, a5, a0, v7, a2, a1, a3, zero, a4, v4, v6, v3], upward_exposed: [a5, a0, zero, a4, a2, a1, a3], params_defs: []
; live_in: [a5, a0, zero, a4, a2, a1, a3], live_out: []
; block parameters: []
.foo_b0:
  mv v2, a0  ; live: [a5, zero, a4, a2, a1, a3, v2]
  mv v3, a1  ; live: [v2, a5, zero, a4, a2, a3, v3]
  mv v4, a2  ; live: [v2, a5, zero, a4, v4, a3, v3]
  mv v5, a3  ; live: [v2, v5, a5, zero, a4, v4, v3]
  mv v6, a4  ; live: [v2, v5, a5, zero, v4, v6, v3]
  mv v7, a5  ; live: [v2, v5, zero, v7, v4, v6, v3]
  mv a0, v2  ; live: [v5, zero, a0, v7, v4, v6, v3]
  call minimbt_print_int  ; live: [v5, zero, v7, v4, v6, v3]
  mv v8, zero  ; live: [v5, zero, v7, v4, v6, v3]
  mv a0, v3  ; live: [v5, zero, a0, v7, v4, v6]
  call minimbt_print_int  ; live: [v5, zero, v7, v4, v6]
  mv v9, zero  ; live: [v5, zero, v7, v4, v6]
  mv a0, v4  ; live: [v5, zero, a0, v7, v6]
  call minimbt_print_int  ; live: [v5, zero, v7, v6]
  mv v10, zero  ; live: [v5, zero, v7, v6]
  mv a0, v5  ; live: [zero, a0, v7, v6]
  call minimbt_print_int  ; live: [zero, v7, v6]
  mv v11, zero  ; live: [zero, v7, v6]
  mv a0, v6  ; live: [zero, a0, v7]
  call minimbt_print_int  ; live: [zero, v7]
  mv v12, zero  ; live: [zero, v7]
  mv a0, v7  ; live: [zero, a0]
  call minimbt_print_int  ; live: [a5, zero, a4, a2, a1, a3]
  mv v13, zero  ; live: [a5, zero, a4, a2, a1, a3]
; control
  mv a0, zero  ; live: [a5, a0, zero, a4, a2, a1, a3]
  ret  ; live: [a5, a0, zero, a4, a2, a1, a3]

  .p2align 3
  .globl thunk_start
  .type thunk_start, @function
thunk_start:
; block info: defs: [t1, ft0, ft1, a1, t5, fa1, fa2, ft6, a4, fa6, a6, ft5, ft10, ft7, ft4, ft9, a5, a0, fa4, ft2, a2, a3, ft8, t3, a7, fa7, t0, fa5, fa3, ft3, fa0, t4, t2, v2], uses: [zero, a0, v2], upward_exposed: [zero], params_defs: []
; live_in: [zero], live_out: []
; block parameters: []
.thunk_start_b0:
  call main  ; live: [zero]
  mv v2, zero  ; live: [zero, v2]
; control
  mv a0, v2  ; live: [zero, a0]
  ret  ; live: [zero]

  .p2align 3
  .globl bar
  .type bar, @function
bar:
; block info: defs: [v2, t1, v7, ft0, ft1, a1, t5, fa1, fa2, ft6, a4, fa6, v8, a6, ft5, ft10, v4, v6, ft7, ft4, v5, ft9, a5, a0, fa4, ft2, a2, a3, ft8, t3, a7, fa7, t0, fa5, fa3, ft3, fa0, t4, t2, v3], uses: [v3, v5, a5, a0, v7, a2, a1, a3, zero, a4, v8, v4, v6, v2], upward_exposed: [a5, a0, zero, a4, a2, a1, a3], params_defs: []
; live_in: [a5, a0, zero, a4, a2, a1, a3], live_out: []
; block parameters: []
.bar_b0:
  mv v2, a0  ; live: [a5, zero, a4, a2, a1, a3, v2]
  mv v3, a1  ; live: [v3, a5, zero, a4, a2, a3, v2]
  mv v4, a2  ; live: [v3, a5, zero, a4, v4, a3, v2]
  mv v5, a3  ; live: [v3, v5, a5, zero, a4, v4, v2]
  mv v6, a4  ; live: [v3, v5, a5, zero, v4, v6, v2]
  mv v7, a5  ; live: [v3, v5, zero, v7, v4, v6, v2]
  mv a0, v3  ; live: [v5, zero, a0, v7, v4, v6, v2]
  mv a1, v2  ; live: [v5, zero, a0, v7, v4, a1, v6]
  mv a2, v5  ; live: [zero, a0, v7, a2, v4, a1, v6]
  mv a3, v6  ; live: [zero, a0, v7, a2, v4, a1, a3]
  mv a4, v7  ; live: [zero, a0, a4, a2, v4, a1, a3]
  mv a5, v4  ; live: [a5, zero, a0, a4, a2, a1, a3]
  call foo  ; live: [a5, zero, a4, a2, a1, a3]
  mv v8, zero  ; live: [a5, zero, a4, v8, a2, a1, a3]
; control
  mv a0, v8  ; live: [a5, a0, zero, a4, a2, a1, a3]
  ret  ; live: [a5, a0, zero, a4, a2, a1, a3]

  .p2align 3
  .globl main
  .type main, @function
main:
; block info: defs: [v2, t1, v7, ft0, ft1, a1, t5, fa1, fa2, ft6, a4, fa6, v8, a6, ft5, ft10, v4, v6, ft7, ft4, v5, ft9, a5, a0, fa4, ft2, a2, a3, ft8, t3, a7, fa7, t0, fa5, fa3, ft3, fa0, t4, t2, v3], uses: [v2, v5, a5, a0, v7, a2, a1, a3, zero, a4, v8, v4, v6, v3], upward_exposed: [zero], params_defs: []
; live_in: [zero], live_out: []
; block parameters: []
.main_b0:
  li v3, 1  ; live: [zero, v3]
  mv a0, v3  ; live: [zero, a0]
  li v4, 2  ; live: [zero, a0, v4]
  mv a1, v4  ; live: [zero, a0, a1]
  li v5, 3  ; live: [v5, zero, a0, a1]
  mv a2, v5  ; live: [zero, a0, a2, a1]
  li v6, 4  ; live: [zero, a0, a2, a1, v6]
  mv a3, v6  ; live: [zero, a0, a2, a1, a3]
  li v7, 5  ; live: [zero, a0, v7, a2, a1, a3]
  mv a4, v7  ; live: [zero, a0, a4, a2, a1, a3]
  li v8, 6  ; live: [zero, a0, a4, v8, a2, a1, a3]
  mv a5, v8  ; live: [a5, zero, a0, a4, a2, a1, a3]
  call bar  ; live: [zero]
  mv v2, zero  ; live: [zero, v2]
; control
  mv a0, v2  ; live: [zero, a0]
  ret  ; live: [zero]

  .p2align 3
  .globl start
  .type start, @object
start:
  .zero 4



Testing test/test_src/spill.mbt
# name conventions used in the core ir:
# - functions: f<id>
# - blocks: b<id>
# - instructions: %<id>
# - memory: m<id>
# - free variables: ^<id>
# - function parameters: $f<pid>
# - block parameters: $b<bid>.<pid>
.core
.fn f #f0 : fn(int32, int32, int32, int32) -> int32
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: int32 = add($f0, $f1)
    let %1: int32 = add($f0, $f2)
    let %2: int32 = add($f0, $f3)
    let %3: int32 = add($f1, $f2)
    let %4: int32 = add($f1, $f3)
    let %5: int32 = add($f2, $f3)
    let %6: int32 = add(%0, %1)
    let %7: int32 = add(%0, %2)
    let %8: int32 = add(%0, %3)
    let %9: int32 = add(%0, %4)
    let %10: int32 = add(%0, %5)
    let %11: int32 = add(%1, %2)
    let %12: int32 = add(%1, %3)
    let %13: int32 = add(%1, %4)
    let %14: int32 = add(%1, %5)
    let %15: int32 = add(%2, %3)
    let %16: int32 = add(%2, %4)
    let %17: int32 = add(%2, %5)
    let %18: int32 = add(%3, %4)
    let %19: int32 = add(%3, %5)
    let %20: int32 = add(%4, %5)
    let %21: int32 = add(%6, %7)
    let %22: int32 = add(%6, %8)
    let %23: int32 = add(%6, %9)
    let %24: int32 = add(%6, %10)
    let %25: int32 = add(%6, %11)
    let %26: int32 = add(%6, %12)
    let %27: int32 = add(%6, %13)
    let %28: int32 = add(%6, %14)
    let %29: int32 = add(%6, %15)
    let %30: int32 = add(%6, %16)
    let %31: int32 = add(%6, %17)
    let %32: int32 = add(%6, %18)
    let %33: int32 = add(%6, %19)
    let %34: int32 = add(%6, %20)
    let %35: int32 = add($f0, $f1)
    let %36: int32 = add(%35, $f2)
    let %37: int32 = add(%36, $f3)
    let %38: int32 = add(%37, %0)
    let %39: int32 = add(%38, %1)
    let %40: int32 = add(%39, %2)
    let %41: int32 = add(%40, %3)
    let %42: int32 = add(%41, %4)
    let %43: int32 = add(%42, %5)
    let %44: int32 = add(%43, %6)
    let %45: int32 = add(%44, %7)
    let %46: int32 = add(%45, %8)
    let %47: int32 = add(%46, %9)
    let %48: int32 = add(%47, %10)
    let %49: int32 = add(%48, %11)
    let %50: int32 = add(%49, %12)
    let %51: int32 = add(%50, %13)
    let %52: int32 = add(%51, %14)
    let %53: int32 = add(%52, %15)
    let %54: int32 = add(%53, %16)
    let %55: int32 = add(%54, %17)
    let %56: int32 = add(%55, %18)
    let %57: int32 = add(%56, %19)
    let %58: int32 = add(%57, %20)
    let %59: int32 = add(%58, %21)
    let %60: int32 = add(%59, %22)
    let %61: int32 = add(%60, %23)
    let %62: int32 = add(%61, %24)
    let %63: int32 = add(%62, %25)
    let %64: int32 = add(%63, %26)
    let %65: int32 = add(%64, %27)
    let %66: int32 = add(%65, %28)
    let %67: int32 = add(%66, %29)
    let %68: int32 = add(%67, %30)
    let %69: int32 = add(%68, %31)
    let %70: int32 = add(%69, %32)
    let %71: int32 = add(%70, %33)
    let %72: int32 = add(%71, %34)
    let %73: int32 = neg(%72)
    return %73
  }
}
.fn thunk_start #f2 : fn() -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: unit = call f1()
    return %0
  }
}
.fn main #f1 : fn() -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: int32 = call f0(1, 2, 3, 4)
    let %1: unit = ext_call minimbt_print_int(%0)
    return %1
  }
}
.thunk ::0 start

  .p2align 3
  .globl _start
  .type _start, @function
_start:
; block info: defs: [t1, ft0, ft1, a1, t5, fa1, fa2, ft6, a4, fa6, a6, ft5, ft10, ft7, ft4, ft9, a5, a0, fa4, ft2, a2, a3, ft8, t3, a7, fa7, t0, fa5, fa3, ft3, fa0, t4, t2], uses: [a0], upward_exposed: [], params_defs: []
; live_in: [], live_out: []
; block parameters: []
_start_b0:
  call thunk_start  ; live: [a0]
; control
  ret  ; live: []

  .p2align 3
  .globl f
  .type f, @function
f:
; block info: defs: [v76, v58, v79, v22, v67, v28, v44, v33, v64, v60, v51, v73, v63, v20, v27, v50, v59, v6, v54, v62, v5, v10, v49, v37, v43, v17, v52, v31, v48, v75, v68, v45, v61, v55, v40, v3, v25, v16, v14, v69, v13, v26, v42, v7, v41, v32, v12, v29, v8, v19, v47, v4, v74, v57, v34, v11, v66, v46, v71, v53, v21, a0, v78, v30, v36, v65, v24, v9, v39, v72, v18, v56, v23, v77, v35, v38, v70, v15, v2], uses: [v76, v58, v79, v22, v67, a1, v44, v28, v64, v33, v60, v51, v73, v63, v20, v50, v27, v59, v6, v54, v62, v5, v10, v49, v37, v17, v43, a3, v52, v31, v48, v75, v68, v45, v61, v55, v3, v40, v25, v14, v16, v69, v13, v26, v42, v7, v41, v32, v12, v29, v8, v19, v47, v4, v74, v57, v34, v11, v66, v46, v71, v53, v21, a0, v30, v78, v36, v65, a2, v24, v9, v39, v72, v18, v56, v23, v77, v35, v38, v70, v15, v2], upward_exposed: [a2, a1, a3, a0], params_defs: []
; live_in: [a2, a1, a3, a0], live_out: []
; block parameters: []
.f_b0:
  mv v2, a0  ; live: [a1, a2, a3, v2]
  mv v3, a1  ; live: [v3, a1, a2, a3, v2]
  mv v4, a2  ; live: [v3, a1, v4, a2, a3, v2]
  mv v5, a3  ; live: [v3, a1, v4, v5, a2, a3, v2]
  add v6, v2, v3  ; live: [v3, a1, v4, v6, v5, a2, a3, v2]
  add v7, v2, v4  ; live: [v3, v7, a1, v4, v6, v5, a2, a3, v2]
  add v8, v2, v5  ; live: [v3, v7, a1, v8, v4, v6, v5, a2, a3, v2]
  add v9, v3, v4  ; live: [v3, v7, a1, v8, v4, v6, v5, a2, a3, v9, v2]
  add v10, v3, v5  ; live: [v3, v7, a1, v8, v4, v6, v5, v10, a2, a3, v9, v2]
  add v11, v4, v5  ; live: [v3, v7, a1, v8, v4, v6, v11, v5, v10, a2, a3, v9, v2]
  add v12, v6, v7  ; live: [v3, v7, a1, v12, v8, v4, v6, v11, v5, v10, a2, a3, v9, v2]
  add v13, v6, v8  ; live: [v3, v13, v7, a1, v12, v8, v4, v6, v11, v5, v10, a2, a3, v9, v2]
  add v14, v6, v9  ; live: [v3, v14, v13, v7, a1, v12, v8, v4, v6, v11, v5, v10, a2, a3, v9, v2]
  add v15, v6, v10  ; live: [v3, v14, v13, v7, a1, v12, v8, v4, v6, v11, v5, v10, a2, a3, v9, v15, v2]
  add v16, v6, v11  ; live: [v3, v14, v16, v13, v7, a1, v12, v8, v4, v6, v11, v5, v10, a2, a3, v9, v15, v2]
  add v17, v7, v8  ; live: [v3, v14, v16, v13, v7, a1, v12, v8, v4, v6, v11, v5, v10, a2, v17, a3, v9, v15, v2]
  add v18, v7, v9  ; live: [v3, v14, v16, v13, v7, a1, v12, v8, v4, v6, v11, v5, v10, a2, v17, a3, v9, v18, v15, v2]
  add v19, v7, v10  ; live: [v3, v14, v16, v13, v7, a1, v12, v8, v19, v4, v6, v11, v5, v10, a2, v17, a3, v9, v18, v15, v2]
  add v20, v7, v11  ; live: [v3, v14, v16, v13, v7, a1, v12, v20, v8, v19, v4, v6, v11, v5, v10, a2, v17, a3, v9, v18, v15, v2]
  add v21, v8, v9  ; live: [v3, v14, v16, v13, v7, a1, v12, v20, v8, v19, v4, v6, v11, v5, v21, v10, a2, v17, a3, v9, v18, v15, v2]
  add v22, v8, v10  ; live: [v3, v14, v16, v13, v22, v7, a1, v12, v20, v8, v19, v4, v6, v11, v5, v21, v10, a2, v17, a3, v9, v18, v15, v2]
  add v23, v8, v11  ; live: [v3, v14, v16, v13, v22, v7, a1, v12, v20, v8, v19, v4, v6, v11, v5, v21, v10, a2, v17, a3, v9, v18, v23, v15, v2]
  add v24, v9, v10  ; live: [v3, v14, v16, v13, v22, v7, a1, v12, v20, v8, v19, v4, v6, v11, v5, v21, v10, a2, v17, a3, v24, v9, v18, v23, v15, v2]
  add v25, v9, v11  ; live: [v3, v25, v14, v16, v13, v22, v7, a1, v12, v20, v8, v19, v4, v6, v11, v5, v21, v10, a2, v17, a3, v24, v9, v18, v23, v15, v2]
  add v26, v10, v11  ; live: [v3, v25, v14, v16, v26, v13, v22, v7, a1, v12, v20, v8, v19, v4, v6, v11, v5, v21, v10, a2, v17, a3, v24, v9, v18, v23, v15, v2]
  add v27, v12, v13  ; live: [v3, v25, v14, v16, v26, v13, v22, v7, a1, v12, v27, v20, v8, v19, v4, v6, v11, v5, v21, v10, a2, v17, a3, v24, v9, v18, v23, v15, v2]
  add v28, v12, v14  ; live: [v3, v25, v14, v16, v26, v13, v22, v7, a1, v12, v28, v27, v20, v8, v19, v4, v6, v11, v5, v21, v10, a2, v17, a3, v24, v9, v18, v23, v15, v2]
  add v29, v12, v15  ; live: [v3, v25, v14, v16, v26, v13, v22, v7, a1, v12, v28, v29, v27, v20, v8, v19, v4, v6, v11, v5, v21, v10, a2, v17, a3, v24, v9, v18, v23, v15, v2]
  add v30, v12, v16  ; live: [v3, v25, v14, v16, v26, v13, v22, v7, a1, v12, v28, v29, v27, v20, v8, v19, v4, v6, v11, v5, v21, v10, v30, a2, v17, a3, v24, v9, v18, v23, v15, v2]
  add v31, v12, v17  ; live: [v3, v25, v14, v16, v26, v13, v22, v7, a1, v12, v28, v29, v27, v20, v8, v19, v4, v6, v11, v5, v21, v10, v30, a2, v17, a3, v24, v31, v9, v18, v23, v15, v2]
  add v32, v12, v18  ; live: [v3, v25, v14, v16, v26, v13, v22, v7, v32, a1, v12, v28, v29, v27, v20, v8, v19, v4, v6, v11, v5, v21, v10, v30, a2, v17, a3, v24, v31, v9, v18, v23, v15, v2]
  add v33, v12, v19  ; live: [v3, v25, v14, v16, v26, v13, v22, v7, v32, a1, v12, v28, v33, v29, v27, v20, v8, v19, v4, v6, v11, v5, v21, v10, v30, a2, v17, a3, v24, v31, v9, v18, v23, v15, v2]
  add v34, v12, v20  ; live: [v3, v25, v14, v16, v26, v13, v22, v7, v32, a1, v12, v28, v33, v29, v27, v20, v8, v19, v4, v6, v34, v11, v5, v21, v10, v30, a2, v17, a3, v24, v31, v9, v18, v23, v15, v2]
  add v35, v12, v21  ; live: [v3, v25, v14, v16, v26, v13, v22, v7, v32, a1, v12, v28, v33, v29, v27, v20, v8, v19, v4, v6, v34, v11, v5, v21, v10, v30, a2, v17, a3, v24, v31, v9, v18, v23, v35, v15, v2]
  add v36, v12, v22  ; live: [v3, v25, v14, v16, v26, v13, v22, v7, v32, a1, v12, v28, v33, v29, v27, v20, v8, v19, v4, v6, v34, v11, v5, v21, v10, v30, v36, a2, v17, a3, v24, v31, v9, v18, v23, v35, v15, v2]
  add v37, v12, v23  ; live: [v3, v25, v14, v16, v26, v13, v22, v7, v32, a1, v12, v28, v33, v29, v27, v20, v8, v19, v4, v6, v34, v11, v5, v21, v10, v30, v36, a2, v37, v17, a3, v24, v31, v9, v18, v23, v35, v15, v2]
  add v38, v12, v24  ; live: [v3, v25, v14, v16, v26, v13, v22, v7, v32, a1, v12, v28, v33, v29, v27, v20, v8, v19, v4, v6, v34, v11, v5, v21, v10, v30, v36, a2, v37, v17, a3, v24, v31, v9, v18, v23, v35, v38, v15, v2]
  add v39, v12, v25  ; live: [v3, v25, v14, v16, v26, v13, v22, v7, v32, a1, v12, v28, v33, v29, v27, v20, v8, v19, v4, v6, v34, v11, v5, v21, v10, v30, v36, a2, v37, v17, a3, v24, v31, v9, v39, v18, v23, v35, v38, v15, v2]
  add v40, v12, v26  ; live: [v2, v3, v25, v14, v16, v26, v13, v22, v7, v32, a1, v12, v28, v33, v29, v27, v20, v8, v19, v4, v6, v34, v11, v5, v21, v10, v30, v36, a2, v37, v17, a3, v24, v31, v9, v39, v18, v23, v35, v38, v15, v40]
  add v41, v2, v3  ; live: [v25, v16, v14, v26, v13, v22, v7, v32, v41, a1, v12, v28, v33, v29, v27, v20, v8, v19, v4, v6, v34, v11, v5, v21, v10, v30, v36, a2, v37, v17, a3, v24, v31, v9, v39, v18, v23, v35, v38, v15, v40]
  add v42, v41, v4  ; live: [v25, v16, v14, v26, v13, v42, v22, v7, v32, a1, v12, v28, v33, v29, v27, v20, v8, v19, v6, v34, v11, v5, v21, v10, v30, v36, a2, v37, v17, a3, v24, v31, v9, v39, v18, v23, v35, v38, v15, v40]
  add v43, v42, v5  ; live: [v25, v16, v14, v26, v13, v22, v7, v32, a1, v12, v28, v33, v29, v27, v20, v8, v19, v6, v34, v11, v21, v10, v30, v36, a2, v37, v17, v43, a3, v24, v31, v9, v39, v18, v23, v35, v38, v15, v40]
  add v44, v43, v6  ; live: [v25, v16, v14, v26, v13, v22, v7, v32, a1, v12, v28, v44, v33, v29, v27, v20, v8, v19, v34, v11, v21, v10, v30, v36, a2, v37, v17, v24, a3, v31, v9, v39, v18, v23, v35, v38, v15, v40]
  add v45, v44, v7  ; live: [v25, v16, v14, v26, v13, v22, v32, a1, v12, v28, v33, v29, v27, v20, v8, v19, v34, v11, v21, v10, v30, v36, a2, v37, v17, v24, a3, v31, v9, v39, v18, v23, v35, v45, v38, v15, v40]
  add v46, v45, v8  ; live: [v25, v16, v14, v26, v13, v22, v32, a1, v12, v28, v33, v29, v27, v20, v19, v34, v11, v46, v21, v10, v30, v36, a2, v37, v17, v24, a3, v31, v9, v39, v18, v23, v35, v38, v15, v40]
  add v47, v46, v9  ; live: [v25, v16, v14, v26, v13, v22, v32, a1, v12, v28, v33, v29, v27, v20, v19, v47, v34, v11, v21, v10, v30, v36, a2, v37, v17, v24, a3, v31, v39, v18, v23, v35, v38, v15, v40]
  add v48, v47, v10  ; live: [v25, v16, v14, v26, v13, v22, v32, a1, v12, v28, v33, v29, v27, v20, v19, v34, v11, v21, v30, v36, a2, v37, v17, v24, a3, v31, v39, v18, v48, v23, v35, v38, v15, v40]
  add v49, v48, v11  ; live: [v25, v16, v14, v26, v13, v22, v32, a1, v12, v28, v33, v29, v27, v20, v19, v34, v21, v49, v30, v36, a2, v37, v17, v24, a3, v31, v39, v18, v23, v35, v38, v15, v40]
  add v50, v49, v12  ; live: [v25, v16, v14, v26, v13, v22, v32, a1, v28, v33, v29, v27, v20, v50, v19, v34, v21, v30, v36, a2, v37, v17, v24, a3, v31, v39, v18, v23, v35, v38, v15, v40]
  add v51, v50, v13  ; live: [v25, v16, v14, v26, v22, v32, a1, v28, v33, v51, v29, v27, v20, v19, v34, v21, v30, v36, a2, v37, v17, v24, a3, v31, v39, v18, v23, v35, v38, v15, v40]
  add v52, v51, v14  ; live: [v25, v16, v26, v22, v32, a1, v28, v33, v29, v27, v20, v19, v34, v21, v30, v36, a2, v37, v17, v24, a3, v52, v31, v39, v18, v23, v35, v38, v15, v40]
  add v53, v52, v15  ; live: [v25, v16, v26, v22, v32, a1, v28, v33, v29, v27, v20, v19, v34, v21, v53, v30, v36, a2, v37, v17, v24, a3, v31, v39, v18, v23, v35, v38, v40]
  add v54, v53, v16  ; live: [v25, v26, v22, v32, a1, v28, v33, v29, v27, v20, v19, v34, v54, v21, v30, v36, a2, v37, v17, v24, a3, v31, v39, v18, v23, v35, v38, v40]
  add v55, v54, v17  ; live: [v25, v26, v22, v32, a1, v28, v33, v29, v27, v20, v19, v34, v21, v30, v36, a2, v37, a3, v24, v31, v39, v18, v23, v35, v38, v55, v40]
  add v56, v55, v18  ; live: [v25, v21, v26, v30, v22, v36, a2, v37, v32, a1, a3, v24, v28, v31, v33, v39, v56, v29, v27, v23, v20, v35, v19, v38, v34, v40]
  add v57, v56, v19  ; live: [v25, v21, v26, v30, v22, v36, a2, v37, v32, a1, a3, v24, v28, v31, v33, v39, v29, v27, v23, v20, v35, v38, v57, v34, v40]
  add v58, v57, v20  ; live: [v25, v58, v21, v26, v30, v22, v36, a2, v37, v32, a1, a3, v24, v28, v31, v33, v39, v29, v27, v23, v35, v38, v34, v40]
  add v59, v58, v21  ; live: [v25, v26, v30, v22, v36, a2, v37, v32, a1, a3, v24, v28, v31, v33, v39, v29, v27, v23, v35, v38, v59, v34, v40]
  add v60, v59, v22  ; live: [v25, v26, v30, v36, a2, v37, v32, a1, a3, v24, v28, v31, v33, v39, v60, v29, v27, v23, v35, v38, v34, v40]
  add v61, v60, v23  ; live: [v25, v26, v30, v36, a2, v37, v32, a1, a3, v24, v28, v31, v33, v39, v29, v27, v35, v38, v61, v34, v40]
  add v62, v61, v24  ; live: [v62, v25, v26, v30, v36, a2, v37, v32, a1, a3, v31, v28, v33, v39, v29, v27, v35, v38, v34, v40]
  add v63, v62, v25  ; live: [v26, v30, v36, a2, v37, v32, a1, a3, v31, v28, v33, v39, v63, v29, v27, v35, v38, v34, v40]
  add v64, v63, v26  ; live: [v30, v36, a2, v37, v32, a1, a3, v31, v28, v33, v64, v39, v29, v27, v35, v38, v34, v40]
  add v65, v64, v27  ; live: [v30, v36, a2, v37, v32, v65, a1, a3, v31, v28, v33, v39, v29, v35, v38, v34, v40]
  add v66, v65, v28  ; live: [v66, v30, v36, a2, v37, v32, a1, a3, v31, v33, v39, v29, v35, v38, v34, v40]
  add v67, v66, v29  ; live: [v67, v30, v36, a2, v37, v32, a1, a3, v31, v33, v39, v35, v38, v34, v40]
  add v68, v67, v30  ; live: [v36, a2, v37, v32, a1, a3, v31, v33, v39, v68, v35, v38, v34, v40]
  add v69, v68, v31  ; live: [v34, v39, v40, v69, v36, v35, a2, v38, v37, v32, a1, a3, v33]
  add v70, v69, v32  ; live: [v33, v39, v40, v36, v35, a2, v38, v37, a1, v70, a3, v34]
  add v71, v70, v33  ; live: [v40, v71, v36, v35, a2, v38, v37, a1, a3, v34, v39]
  add v72, v71, v34  ; live: [v72, v36, v35, a2, v38, v37, a1, a3, v39, v40]
  add v73, v72, v35  ; live: [v73, v36, a2, v38, v37, a1, a3, v39, v40]
  add v74, v73, v36  ; live: [v40, a2, v38, v37, v74, a1, a3, v39]
  add v75, v74, v37  ; live: [v75, a2, v38, a1, a3, v39, v40]
  add v76, v75, v38  ; live: [v76, a2, a1, a3, v39, v40]
  add v77, v76, v39  ; live: [a2, a1, a3, v77, v40]
  add v78, v77, v40  ; live: [a2, a1, a3, v78]
  neg v79, v78  ; live: [a2, a1, a3, v79]
; control
  mv a0, v79  ; live: [a2, a1, a3, a0]
  ret  ; live: [a2, a1, a3, a0]

  .p2align 3
  .globl thunk_start
  .type thunk_start, @function
thunk_start:
; block info: defs: [t1, ft0, ft1, a1, t5, fa1, fa2, ft6, a4, fa6, a6, ft5, ft10, ft7, ft4, ft9, a5, a0, fa4, ft2, a2, a3, ft8, t3, a7, fa7, t0, fa5, fa3, ft3, fa0, t4, t2, v2], uses: [zero, a0, v2], upward_exposed: [zero], params_defs: []
; live_in: [zero], live_out: []
; block parameters: []
.thunk_start_b0:
  call main  ; live: [zero]
  mv v2, zero  ; live: [zero, v2]
; control
  mv a0, v2  ; live: [zero, a0]
  ret  ; live: [zero]

  .p2align 3
  .globl main
  .type main, @function
main:
; block info: defs: [v3, t1, v7, ft0, ft1, a1, t5, fa1, fa2, ft6, a4, fa6, v8, a6, ft10, ft5, v6, ft7, ft4, v5, ft9, a5, a0, fa4, ft2, a2, a3, ft8, t3, a7, fa7, t0, fa5, fa3, ft3, fa0, t4, t2, v2], uses: [v3, v5, a0, zero, v8, v7, a2, v6, a1, a3, v2], upward_exposed: [zero], params_defs: []
; live_in: [zero], live_out: []
; block parameters: []
.main_b0:
  li v5, 1  ; live: [v5, zero]
  mv a0, v5  ; live: [zero, a0]
  li v6, 2  ; live: [v6, zero, a0]
  mv a1, v6  ; live: [a1, zero, a0]
  li v7, 3  ; live: [a1, zero, a0, v7]
  mv a2, v7  ; live: [a2, a1, zero, a0]
  li v8, 4  ; live: [a2, a1, zero, a0, v8]
  mv a3, v8  ; live: [a2, a1, a3, zero, a0]
  call f  ; live: [zero, a0]
  mv v2, a0  ; live: [zero, v2]
  mv a0, v2  ; live: [zero, a0]
  call minimbt_print_int  ; live: [zero]
  mv v3, zero  ; live: [zero, v3]
; control
  mv a0, v3  ; live: [zero, a0]
  ret  ; live: [zero]

  .p2align 3
  .globl start
  .type start, @object
start:
  .zero 4



Testing test/test_src/spill2.mbt
# name conventions used in the core ir:
# - functions: f<id>
# - blocks: b<id>
# - instructions: %<id>
# - memory: m<id>
# - free variables: ^<id>
# - function parameters: $f<pid>
# - block parameters: $b<bid>.<pid>
.core
.fn main #f2 : fn() -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let _ = alloc <m0: array[int32] heap(10)> <- [..] = 1
    let %1: int32 = call f0()
    let %2: int32 = load int32 offset(f2.m0, 0)
    let %3: int32 = add(%2, %2)
    let %4: int32 = add(%3, %3)
    let %5: int32 = add(%4, %4)
    let %6: int32 = add(%5, %5)
    let %7: int32 = add(%6, %6)
    let %8: int32 = add(%7, %7)
    let %9: int32 = add(%8, %8)
    let %10: int32 = add(%9, %9)
    let %11: int32 = add(%10, %10)
    let %12: int32 = add(%11, %11)
    let %13: int32 = add(%12, %12)
    let %14: int32 = add(%13, %13)
    let %15: int32 = add(%14, %14)
    let %16: int32 = add(%15, %15)
    let %17: int32 = add(%16, %16)
    let %18: int32 = load int32 offset(f2.m0, 1)
    let %19: bool = eq(%18, 0)
    br %19 b1() b2()
  }
  .bb #b1 () {
    let %20: int32 = call f1(67890)
    jump b3(%20)
  }
  .bb #b2 () {
    let %21: int32 = add(%2, %3)
    let %22: int32 = add(%21, %4)
    let %23: int32 = add(%22, %5)
    let %24: int32 = add(%23, %6)
    let %25: int32 = add(%24, %7)
    let %26: int32 = add(%25, %8)
    let %27: int32 = add(%26, %9)
    let %28: int32 = add(%27, %10)
    let %29: int32 = add(%28, %11)
    let %30: int32 = add(%29, %12)
    let %31: int32 = add(%30, %13)
    let %32: int32 = add(%31, %14)
    let %33: int32 = add(%32, %15)
    let %34: int32 = add(%33, %16)
    let %35: int32 = add(%34, %17)
    let %36: int32 = add(%35, %1)
    jump b3(%36)
  }
  .bb #b3 (int32) {
    let %37: unit = ext_call minimbt_print_int($b3.0)
    return %37
  }
}
.fn f #f0 : fn() -> int32
.freevars ()
.entry b0 {
  .bb #b0 () {
    return 12345
  }
}
.fn thunk_start #f3 : fn() -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: unit = call f2()
    return %0
  }
}
.fn g #f1 : fn(int32) -> int32
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: int32 = add($f0, 1)
    return %0
  }
}
.thunk ::0 start

  .p2align 3
  .globl _start
  .type _start, @function
_start:
; block info: defs: [t1, ft0, ft1, a1, t5, fa1, fa2, ft6, a4, fa6, a6, ft5, ft10, ft7, ft4, ft9, a5, a0, fa4, ft2, a2, a3, ft8, t3, a7, fa7, t0, fa5, fa3, ft3, fa0, t4, t2], uses: [a0], upward_exposed: [], params_defs: []
; live_in: [], live_out: []
; block parameters: []
_start_b0:
  call thunk_start  ; live: [a0]
; control
  ret  ; live: []

  .p2align 3
  .globl f
  .type f, @function
f:
; block info: defs: [a0, v2], uses: [a0, v2], upward_exposed: [], params_defs: []
; live_in: [], live_out: []
; block parameters: []
.f_b0:
; control
  li v2, 12345  ; live: [v2]
  mv a0, v2  ; live: [a0]
  ret  ; live: []

  .p2align 3
  .globl thunk_start
  .type thunk_start, @function
thunk_start:
; block info: defs: [t1, ft0, ft1, a1, t5, fa1, fa2, ft6, a4, fa6, a6, ft5, ft10, ft7, ft4, ft9, a5, a0, fa4, ft2, a2, a3, ft8, t3, a7, fa7, t0, fa5, fa3, ft3, fa0, t4, t2, v2], uses: [zero, a0, v2], upward_exposed: [zero], params_defs: []
; live_in: [zero], live_out: []
; block parameters: []
.thunk_start_b0:
  call main  ; live: [zero]
  mv v2, zero  ; live: [zero, v2]
; control
  mv a0, v2  ; live: [zero, a0]
  ret  ; live: [zero]

  .p2align 3
  .globl g
  .type g, @function
g:
; block info: defs: [v3, v4, a0, v2], uses: [v3, v4, a0, v2], upward_exposed: [a0], params_defs: []
; live_in: [a0], live_out: []
; block parameters: []
.g_b0:
  mv v2, a0  ; live: [v2]
  li v4, 1  ; live: [v4, v2]
  add v3, v2, v4  ; live: [v3]
; control
  mv a0, v3  ; live: [a0]
  ret  ; live: [a0]

  .p2align 3
  .globl main
  .type main, @function
main:
; block info: defs: [v22, a1, t5, fa1, v64, v63, v82, fa2, ft6, a4, fa6, v20, a6, ft5, ft10, v6, ft4, v5, ft9, v10, fa4, ft2, v17, a3, a7, fa7, fa3, ft3, t2, v61, t1, v14, v16, v13, v7, ft0, ft1, v12, v86, v8, v19, v4, ft7, v11, v21, a5, a0, v88, a2, v65, v9, ft8, t3, t0, fa5, v18, fa0, t4, v83, v15, v2], uses: [v14, v16, v13, v22, v7, v12, s11, v86, v64, v63, v82, zero, v8, v19, v6, v11, v5, v10, v21, a0, v88, v65, v17, v9, v18, v83, v15, v61, v2], upward_exposed: [s11, zero], params_defs: []
; live_in: [s11, zero], live_out: [v11, v5, v14, v16, v10, v13, v7, v17, v12, v9, v18, zero, v20, v8, v19, v4, v6, v15]
; block parameters: []
.main_b0:
  addi v86, s11, -40  ; live: [s11, v86, zero]
  andi v2, v86, -8  ; live: [s11, zero, v2]
  li v88, 1  ; live: [v88, s11, zero, v2]
  sw v88, 0(v2)  ; live: [v88, s11, zero, v2]
  sw v88, 4(v2)  ; live: [v88, s11, zero, v2]
  sw v88, 8(v2)  ; live: [v88, s11, zero, v2]
  sw v88, 12(v2)  ; live: [v88, s11, zero, v2]
  sw v88, 16(v2)  ; live: [v88, s11, zero, v2]
  sw v88, 20(v2)  ; live: [v88, s11, zero, v2]
  sw v88, 24(v2)  ; live: [v88, s11, zero, v2]
  sw v88, 28(v2)  ; live: [v88, s11, zero, v2]
  sw v88, 32(v2)  ; live: [v88, s11, zero, v2]
  sw v88, 36(v2)  ; live: [s11, zero, v2]
  call f  ; live: [s11, zero, a0, v2]
  mv v4, a0  ; live: [s11, zero, v2]
  slli v82, zero, 2  ; live: [v82, s11, zero, v2]
  add v83, v2, v82  ; live: [s11, v83, zero, v2]
  lw v5, 0(v83)  ; live: [v5, s11, zero, v2]
  add v6, v5, v5  ; live: [v6, s11, zero, v2]
  add v7, v6, v6  ; live: [v7, s11, zero, v2]
  add v8, v7, v7  ; live: [v8, s11, zero, v2]
  add v9, v8, v8  ; live: [s11, zero, v9, v2]
  add v10, v9, v9  ; live: [s11, v10, zero, v2]
  add v11, v10, v10  ; live: [v11, s11, zero, v2]
  add v12, v11, v11  ; live: [s11, v12, zero, v2]
  add v13, v12, v12  ; live: [s11, zero, v13, v2]
  add v14, v13, v13  ; live: [v14, s11, zero, v2]
  add v15, v14, v14  ; live: [s11, v15, zero, v2]
  add v16, v15, v15  ; live: [v16, s11, zero, v2]
  add v17, v16, v16  ; live: [v17, s11, zero, v2]
  add v18, v17, v17  ; live: [s11, v18, zero, v2]
  add v19, v18, v18  ; live: [v19, s11, zero, v2]
  add v20, v19, v19  ; live: [s11, zero, v2]
  li v63, 1  ; live: [v63, s11, zero, v2]
  slli v64, v63, 2  ; live: [s11, zero, v64, v2]
  add v65, v2, v64  ; live: [v65, s11, zero]
  lw v21, 0(v65)  ; live: [s11, v21, zero]
  xor v61, v21, zero  ; live: [s11, v61, zero]
  sltiu v22, v61, 1  ; live: [s11, zero, v22]
; control
  bne v22, zero, .main_b1  ; live: [s11, zero]
  j .main_b2  ; live: [s11, zero]

; block info: defs: [t1, ft0, ft1, v41, a1, t5, fa1, fa2, ft6, a4, fa6, a6, ft5, ft10, ft7, ft4, ft9, a5, a0, fa4, ft2, a2, a3, ft8, t3, a7, fa7, t0, fa5, fa3, ft3, fa0, t4, t2], uses: [v41, a0, zero, v40], upward_exposed: [zero, v40], params_defs: [v40]
; live_in: [zero, v40], live_out: []
; block parameters: [v40]
.main_b3:
  mv a0, v40  ; live: [zero, a0, v40]
  call minimbt_print_int  ; live: [zero, v40]
  mv v41, zero  ; live: [v41, zero, v40]
; control
  mv a0, v41  ; live: [zero, a0, v40]
  ret  ; live: [zero, v40]

; block info: defs: [t1, ft0, ft1, a1, t5, fa1, fa2, ft6, a4, fa6, a6, ft5, ft10, ft7, ft4, ft9, a5, a0, fa4, ft2, a2, v43, a3, v39, ft8, a7, t3, fa7, t0, fa5, fa3, ft3, fa0, t4, t2, v40], uses: [v43, a0, v39], upward_exposed: [], params_defs: []
; live_in: [zero], live_out: [zero, v40]
; block parameters: []
.main_b1:
  li v43, 67890  ; live: [v43, zero]
  mv a0, v43  ; live: [zero, a0]
  call g  ; live: [zero, a0]
  mv v39, a0  ; live: [zero, v39]
; control
  mv v40, v39  ; live: [zero]
  j .main_b3  ; live: [zero]

; block info: defs: [v25, v26, v30, v36, v32, v37, v24, v31, v28, v33, v29, v27, v23, v35, v38, v34, v40], uses: [v25, v14, v16, v13, v26, v7, v32, v12, v28, v33, v29, v27, v20, v8, v19, v4, v6, v34, v11, v5, v10, v30, v36, v37, v17, v24, v31, v9, v18, v23, v35, v38, v15], upward_exposed: [v11, v5, v14, v16, v10, v13, v7, v17, v12, v9, v18, v20, v8, v19, v4, v6, v15], params_defs: []
; live_in: [v11, v5, v14, v16, v10, v13, v7, v17, v12, v9, v18, zero, v20, v8, v19, v4, v6, v15], live_out: [zero, v40]
; block parameters: []
.main_b2:
  add v23, v5, v6  ; live: [v11, v5, v14, v16, v10, v13, v7, v17, v12, v9, v18, zero, v20, v23, v8, v19, v4, v6, v15]
  add v24, v23, v7  ; live: [v11, v5, v14, v16, v10, v13, v7, v17, v12, v24, v9, v18, zero, v20, v8, v19, v4, v6, v15]
  add v25, v24, v8  ; live: [v11, v25, v5, v14, v16, v10, v13, v7, v17, v12, v9, v18, zero, v20, v8, v19, v4, v6, v15]
  add v26, v25, v9  ; live: [v11, v5, v14, v16, v10, v13, v26, v7, v17, v12, v9, v18, zero, v20, v8, v19, v4, v6, v15]
  add v27, v26, v10  ; live: [v11, v5, v14, v16, v10, v13, v7, v17, v12, v9, v18, zero, v20, v27, v8, v19, v4, v6, v15]
  add v28, v27, v11  ; live: [v11, v5, v14, v16, v10, v13, v7, v17, v12, v28, v9, v18, zero, v20, v8, v19, v4, v6, v15]
  add v29, v28, v12  ; live: [v11, v5, v14, v16, v10, v13, v7, v17, v12, v9, v18, zero, v29, v20, v8, v19, v4, v6, v15]
  add v30, v29, v13  ; live: [v11, v5, v14, v16, v10, v13, v30, v7, v17, v12, v9, v18, zero, v20, v8, v19, v4, v6, v15]
  add v31, v30, v14  ; live: [v11, v5, v14, v16, v10, v13, v7, v17, v12, v31, v9, v18, zero, v20, v8, v19, v4, v6, v15]
  add v32, v31, v15  ; live: [v11, v5, v14, v16, v10, v13, v7, v32, v17, v12, v9, v18, zero, v20, v8, v19, v4, v6, v15]
  add v33, v32, v16  ; live: [v11, v5, v14, v16, v10, v13, v7, v17, v12, v9, v33, v18, zero, v20, v8, v19, v4, v6, v15]
  add v34, v33, v17  ; live: [v11, v5, v14, v16, v10, v13, v7, v17, v12, v9, v18, zero, v20, v8, v19, v4, v6, v15, v34]
  add v35, v34, v18  ; live: [v11, v5, v14, v16, v10, v13, v7, v17, v12, v9, v18, zero, v20, v8, v35, v19, v4, v6, v15]
  add v36, v35, v19  ; live: [v11, v5, v14, v16, v10, v13, v7, v36, v17, v12, v9, v18, zero, v20, v8, v19, v4, v6, v15]
  add v37, v36, v20  ; live: [v11, v5, v14, v16, v10, v13, v7, v37, v17, v12, v9, v18, zero, v20, v8, v19, v4, v6, v15]
  add v38, v37, v4  ; live: [v11, v5, v14, v16, v10, v13, v7, v17, v12, v9, v18, zero, v20, v8, v19, v4, v38, v6, v15]
; control
  mv v40, v38  ; live: [v11, v5, v14, v16, v10, v13, v7, v17, v12, v9, v18, zero, v20, v8, v19, v4, v6, v15]
  j .main_b3  ; live: [v11, v5, v14, v16, v10, v13, v7, v17, v12, v9, v18, zero, v20, v8, v19, v4, v6, v15]

  .p2align 3
  .globl start
  .type start, @object
start:
  .zero 4



Testing test/test_src/spill3.mbt
# name conventions used in the core ir:
# - functions: f<id>
# - blocks: b<id>
# - instructions: %<id>
# - memory: m<id>
# - free variables: ^<id>
# - function parameters: $f<pid>
# - block parameters: $b<bid>.<pid>
.core
.fn f #f0 : fn(int32) -> int32
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: int32 = add($f0, 1)
    let %1: int32 = add(%0, 1)
    let %2: int32 = add(%1, 1)
    let %3: int32 = add(%2, 1)
    let %4: int32 = add(%3, 1)
    let %5: int32 = add(%4, 1)
    let %6: int32 = add(%5, 1)
    let %7: int32 = add(%6, 1)
    let %8: int32 = add(%7, 1)
    let %9: int32 = add(%8, 1)
    let %10: int32 = add(%9, 1)
    let %11: int32 = add(%10, 1)
    let %12: int32 = add(%11, 1)
    let %13: int32 = add(%12, 1)
    let %14: int32 = add(%13, 1)
    let %15: int32 = add(%14, 1)
    let %16: int32 = add(%15, 1)
    let %17: int32 = add(%16, 1)
    let %18: int32 = add(%17, %0)
    let %19: int32 = add(%18, %1)
    let %20: int32 = add(%19, %2)
    let %21: int32 = add(%20, %3)
    let %22: int32 = add(%21, %4)
    let %23: int32 = add(%22, %5)
    let %24: int32 = add(%23, %6)
    let %25: int32 = add(%24, %7)
    let %26: int32 = add(%25, %8)
    let %27: int32 = add(%26, %9)
    let %28: int32 = add(%27, %10)
    let %29: int32 = add(%28, %11)
    let %30: int32 = add(%29, %12)
    let %31: int32 = add(%30, %13)
    let %32: int32 = add(%31, %14)
    let %33: int32 = add(%32, %15)
    let %34: int32 = add(%33, %16)
    let %35: int32 = add(%34, $f0)
    let %36: int32 = add(%0, %1)
    let %37: int32 = add(%36, %2)
    let %38: int32 = add(%37, %3)
    let %39: int32 = add(%38, %4)
    let %40: int32 = add(%39, %5)
    let %41: int32 = add(%40, %6)
    let %42: int32 = add(%41, %7)
    let %43: int32 = add(%42, %8)
    let %44: int32 = add(%43, %9)
    let %45: int32 = add(%44, %10)
    let %46: int32 = add(%45, %11)
    let %47: int32 = add(%46, %12)
    let %48: int32 = add(%47, %13)
    let %49: int32 = add(%48, %14)
    let %50: int32 = add(%49, %15)
    let %51: int32 = add(%50, %16)
    let %52: int32 = add(%51, %17)
    let %53: int32 = add(%52, %18)
    let %54: int32 = add(%53, %19)
    let %55: int32 = add(%54, %20)
    let %56: int32 = add(%55, %21)
    let %57: int32 = add(%56, %22)
    let %58: int32 = add(%57, %23)
    let %59: int32 = add(%58, %24)
    let %60: int32 = add(%59, %25)
    let %61: int32 = add(%60, %26)
    let %62: int32 = add(%61, %27)
    let %63: int32 = add(%62, %28)
    let %64: int32 = add(%63, %29)
    let %65: int32 = add(%64, %30)
    let %66: int32 = add(%65, %31)
    let %67: int32 = add(%66, %32)
    let %68: int32 = add(%67, %33)
    let %69: int32 = add(%68, %34)
    let %70: int32 = add(%69, %35)
    let %71: int32 = add(%70, $f0)
    return %71
  }
}
.fn thunk_start #f2 : fn() -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: unit = call f1()
    return %0
  }
}
.fn main #f1 : fn() -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: int32 = call f0(0)
    let %1: unit = ext_call minimbt_print_int(%0)
    return %1
  }
}
.thunk ::0 start

  .p2align 3
  .globl _start
  .type _start, @function
_start:
; block info: defs: [t1, ft0, ft1, a1, t5, fa1, fa2, ft6, a4, fa6, a6, ft5, ft10, ft7, ft4, ft9, a5, a0, fa4, ft2, a2, a3, ft8, t3, a7, fa7, t0, fa5, fa3, ft3, fa0, t4, t2], uses: [a0], upward_exposed: [], params_defs: []
; live_in: [], live_out: []
; block parameters: []
_start_b0:
  call thunk_start  ; live: [a0]
; control
  ret  ; live: []

  .p2align 3
  .globl f
  .type f, @function
f:
; block info: defs: [v153, v58, v159, v22, v67, v28, v44, v33, v64, v60, v51, v73, v63, v20, v27, v50, v151, v59, v6, v137, v129, v54, v62, v5, v10, v49, v133, v157, v141, v37, v17, v43, v52, v147, v31, v48, v68, v45, v61, v55, v163, v3, v40, v25, v14, v16, v69, v13, v26, v42, v7, v32, v41, v12, v143, v149, v161, v29, v8, v19, v4, v47, v74, v57, v34, v155, v11, v66, v46, v71, v21, v53, a0, v30, v36, v65, v24, v9, v145, v39, v72, v18, v56, v23, v35, v38, v70, v15, v139, v131, v135, v2], uses: [v153, v58, v159, v22, v67, v28, v44, v33, v64, v60, v51, v73, v63, v20, v27, v50, v151, v59, v6, v137, v129, v54, v62, v5, v10, v49, v133, v157, v141, v37, v17, v43, v52, v147, v31, v48, v68, v45, v61, v55, v163, v3, v40, v25, v14, v16, v69, v13, v26, v42, v7, v32, v41, v143, v12, v149, v161, v29, v8, v19, v4, v47, v74, v57, v34, v155, v11, v66, v46, v71, v21, v53, a0, v30, v36, v65, v24, v145, v9, v39, v72, v18, v56, v23, v35, v38, v70, v15, v139, v131, v135, v2], upward_exposed: [a0], params_defs: []
; live_in: [a0], live_out: []
; block parameters: []
.f_b0:
  mv v2, a0  ; live: [v2]
  li v163, 1  ; live: [v163, v2]
  add v3, v2, v163  ; live: [v3, v2]
  li v161, 1  ; live: [v3, v161, v2]
  add v4, v3, v161  ; live: [v3, v4, v2]
  li v159, 1  ; live: [v3, v159, v4, v2]
  add v5, v4, v159  ; live: [v3, v4, v5, v2]
  li v157, 1  ; live: [v3, v4, v5, v157, v2]
  add v6, v5, v157  ; live: [v3, v4, v6, v5, v2]
  li v155, 1  ; live: [v3, v4, v6, v155, v5, v2]
  add v7, v6, v155  ; live: [v3, v7, v4, v6, v5, v2]
  li v153, 1  ; live: [v3, v153, v7, v4, v6, v5, v2]
  add v8, v7, v153  ; live: [v3, v7, v8, v4, v6, v5, v2]
  li v151, 1  ; live: [v3, v7, v8, v151, v4, v6, v5, v2]
  add v9, v8, v151  ; live: [v3, v7, v8, v4, v6, v5, v9, v2]
  li v149, 1  ; live: [v3, v7, v149, v8, v4, v6, v5, v9, v2]
  add v10, v9, v149  ; live: [v3, v7, v8, v4, v6, v5, v10, v9, v2]
  li v147, 1  ; live: [v3, v7, v8, v4, v6, v5, v10, v147, v9, v2]
  add v11, v10, v147  ; live: [v3, v7, v8, v4, v6, v11, v5, v10, v9, v2]
  li v145, 1  ; live: [v3, v7, v8, v4, v6, v11, v5, v10, v9, v145, v2]
  add v12, v11, v145  ; live: [v3, v7, v12, v8, v4, v6, v11, v5, v10, v9, v2]
  li v143, 1  ; live: [v3, v7, v12, v143, v8, v4, v6, v11, v5, v10, v9, v2]
  add v13, v12, v143  ; live: [v3, v13, v7, v12, v8, v4, v6, v11, v5, v10, v9, v2]
  li v141, 1  ; live: [v3, v13, v7, v12, v8, v4, v6, v11, v5, v10, v141, v9, v2]
  add v14, v13, v141  ; live: [v3, v14, v13, v7, v12, v8, v4, v6, v11, v5, v10, v9, v2]
  li v139, 1  ; live: [v3, v14, v13, v7, v12, v8, v4, v6, v11, v5, v10, v9, v139, v2]
  add v15, v14, v139  ; live: [v3, v14, v13, v7, v12, v8, v4, v6, v11, v5, v10, v9, v15, v2]
  li v137, 1  ; live: [v3, v14, v13, v7, v12, v8, v4, v6, v137, v11, v5, v10, v9, v15, v2]
  add v16, v15, v137  ; live: [v3, v16, v14, v13, v7, v12, v8, v4, v6, v11, v5, v10, v9, v15, v2]
  li v135, 1  ; live: [v3, v16, v14, v13, v7, v12, v8, v4, v6, v11, v5, v10, v9, v15, v135, v2]
  add v17, v16, v135  ; live: [v3, v16, v14, v13, v7, v12, v8, v4, v6, v11, v5, v10, v17, v9, v15, v2]
  li v133, 1  ; live: [v3, v16, v14, v13, v7, v12, v8, v4, v6, v11, v5, v10, v133, v17, v9, v15, v2]
  add v18, v17, v133  ; live: [v3, v16, v14, v13, v7, v12, v8, v4, v6, v11, v5, v10, v17, v9, v18, v15, v2]
  li v131, 1  ; live: [v3, v16, v14, v13, v7, v12, v8, v4, v6, v11, v5, v10, v17, v9, v18, v15, v131, v2]
  add v19, v18, v131  ; live: [v3, v16, v14, v13, v7, v12, v8, v19, v4, v6, v11, v5, v10, v17, v9, v18, v15, v2]
  li v129, 1  ; live: [v3, v16, v14, v13, v7, v12, v8, v19, v4, v6, v129, v11, v5, v10, v17, v9, v18, v15, v2]
  add v20, v19, v129  ; live: [v3, v16, v14, v13, v7, v12, v20, v8, v19, v4, v6, v11, v5, v10, v17, v9, v18, v15, v2]
  add v21, v20, v3  ; live: [v3, v16, v14, v13, v7, v12, v20, v8, v19, v4, v6, v11, v5, v21, v10, v17, v9, v18, v15, v2]
  add v22, v21, v4  ; live: [v3, v16, v14, v13, v22, v7, v12, v20, v8, v19, v4, v6, v11, v5, v21, v10, v17, v9, v18, v15, v2]
  add v23, v22, v5  ; live: [v3, v16, v14, v13, v22, v7, v12, v20, v8, v19, v4, v6, v11, v5, v21, v10, v17, v9, v18, v23, v15, v2]
  add v24, v23, v6  ; live: [v3, v16, v14, v13, v22, v7, v12, v20, v8, v19, v4, v6, v11, v5, v21, v10, v17, v24, v9, v18, v23, v15, v2]
  add v25, v24, v7  ; live: [v3, v25, v16, v14, v13, v22, v7, v12, v20, v8, v19, v4, v6, v11, v5, v21, v10, v17, v24, v9, v18, v23, v15, v2]
  add v26, v25, v8  ; live: [v3, v25, v16, v14, v26, v13, v22, v7, v12, v20, v8, v19, v4, v6, v11, v5, v21, v10, v17, v24, v9, v18, v23, v15, v2]
  add v27, v26, v9  ; live: [v3, v25, v16, v14, v26, v13, v22, v7, v12, v27, v20, v8, v19, v4, v6, v11, v5, v21, v10, v17, v24, v9, v18, v23, v15, v2]
  add v28, v27, v10  ; live: [v3, v25, v16, v14, v26, v13, v22, v7, v12, v28, v27, v20, v8, v19, v4, v6, v11, v5, v21, v10, v17, v24, v9, v18, v23, v15, v2]
  add v29, v28, v11  ; live: [v3, v25, v16, v14, v26, v13, v22, v7, v12, v28, v29, v27, v20, v8, v19, v4, v6, v11, v5, v21, v10, v17, v24, v9, v18, v23, v15, v2]
  add v30, v29, v12  ; live: [v3, v25, v16, v14, v26, v13, v22, v7, v12, v28, v29, v27, v20, v8, v19, v4, v6, v11, v5, v21, v10, v30, v17, v24, v9, v18, v23, v15, v2]
  add v31, v30, v13  ; live: [v3, v25, v16, v14, v26, v13, v22, v7, v12, v28, v29, v27, v20, v8, v19, v4, v6, v11, v5, v21, v10, v30, v17, v24, v31, v9, v18, v23, v15, v2]
  add v32, v31, v14  ; live: [v3, v25, v16, v14, v26, v13, v22, v7, v32, v12, v28, v29, v27, v20, v8, v19, v4, v6, v11, v5, v21, v10, v30, v17, v24, v31, v9, v18, v23, v15, v2]
  add v33, v32, v15  ; live: [v3, v25, v16, v14, v26, v13, v22, v7, v32, v12, v28, v33, v29, v27, v20, v8, v19, v4, v6, v11, v5, v21, v10, v30, v17, v24, v31, v9, v18, v23, v15, v2]
  add v34, v33, v16  ; live: [v3, v25, v16, v14, v26, v13, v22, v7, v32, v12, v28, v33, v29, v27, v20, v8, v19, v4, v6, v34, v11, v5, v21, v10, v30, v17, v24, v31, v9, v18, v23, v15, v2]
  add v35, v34, v17  ; live: [v3, v25, v16, v14, v26, v13, v22, v7, v32, v12, v28, v33, v29, v27, v20, v8, v19, v4, v6, v34, v11, v5, v21, v10, v30, v17, v24, v31, v9, v18, v23, v35, v15, v2]
  add v36, v35, v18  ; live: [v3, v25, v16, v14, v26, v13, v22, v7, v32, v12, v28, v33, v29, v27, v20, v8, v19, v4, v6, v34, v11, v5, v21, v10, v30, v36, v17, v24, v31, v9, v18, v23, v35, v15, v2]
  add v37, v36, v19  ; live: [v3, v25, v16, v14, v26, v13, v22, v7, v32, v12, v28, v33, v29, v27, v20, v8, v19, v4, v6, v34, v11, v5, v21, v10, v30, v36, v37, v17, v24, v31, v9, v18, v23, v35, v15, v2]
  add v38, v37, v2  ; live: [v3, v25, v16, v14, v26, v13, v22, v7, v32, v12, v28, v33, v29, v27, v20, v8, v19, v4, v6, v34, v11, v5, v21, v10, v30, v36, v37, v17, v24, v31, v9, v18, v23, v35, v38, v15, v2]
  add v39, v3, v4  ; live: [v25, v16, v14, v26, v13, v22, v7, v32, v12, v28, v33, v29, v27, v20, v8, v19, v6, v34, v11, v5, v21, v10, v30, v36, v37, v17, v24, v31, v9, v39, v18, v23, v35, v38, v15, v2]
  add v40, v39, v5  ; live: [v40, v25, v16, v14, v26, v13, v22, v7, v32, v12, v28, v33, v29, v27, v20, v8, v19, v6, v34, v11, v21, v10, v30, v36, v37, v17, v24, v31, v9, v18, v23, v35, v38, v15, v2]
  add v41, v40, v6  ; live: [v25, v16, v14, v26, v13, v22, v7, v32, v41, v12, v28, v33, v29, v27, v20, v8, v19, v34, v11, v21, v10, v30, v36, v37, v17, v24, v31, v9, v18, v23, v35, v38, v15, v2]
  add v42, v41, v7  ; live: [v25, v16, v14, v26, v13, v42, v22, v32, v12, v28, v33, v29, v27, v20, v8, v19, v34, v11, v21, v10, v30, v36, v37, v17, v24, v31, v9, v18, v23, v35, v38, v15, v2]
  add v43, v42, v8  ; live: [v25, v16, v14, v26, v13, v22, v32, v12, v28, v33, v29, v27, v20, v19, v34, v11, v21, v10, v30, v36, v37, v17, v43, v24, v31, v9, v18, v23, v35, v38, v15, v2]
  add v44, v43, v9  ; live: [v25, v16, v14, v26, v13, v22, v32, v12, v28, v44, v33, v29, v27, v20, v19, v34, v11, v21, v10, v30, v36, v37, v17, v24, v31, v18, v23, v35, v38, v15, v2]
  add v45, v44, v10  ; live: [v25, v16, v14, v26, v13, v22, v32, v12, v28, v33, v29, v27, v20, v19, v34, v11, v21, v30, v36, v37, v17, v24, v31, v18, v23, v35, v45, v38, v15, v2]
  add v46, v45, v11  ; live: [v25, v16, v14, v26, v13, v22, v32, v12, v28, v33, v29, v27, v20, v19, v34, v46, v21, v30, v36, v37, v17, v24, v31, v18, v23, v35, v38, v15, v2]
  add v47, v46, v12  ; live: [v25, v16, v14, v26, v13, v22, v32, v28, v33, v29, v27, v20, v19, v47, v34, v21, v30, v36, v37, v17, v24, v31, v18, v23, v35, v38, v15, v2]
  add v48, v47, v13  ; live: [v25, v16, v14, v26, v22, v32, v28, v33, v29, v27, v20, v19, v34, v21, v30, v36, v37, v17, v24, v31, v18, v48, v23, v35, v38, v15, v2]
  add v49, v48, v14  ; live: [v25, v16, v21, v49, v26, v30, v22, v36, v37, v32, v17, v24, v28, v31, v33, v18, v29, v27, v23, v20, v35, v19, v38, v15, v34, v2]
  add v50, v49, v15  ; live: [v25, v16, v21, v26, v30, v22, v36, v37, v32, v17, v24, v28, v31, v33, v18, v29, v27, v23, v20, v50, v35, v19, v38, v34, v2]
  add v51, v50, v16  ; live: [v25, v21, v26, v30, v22, v36, v37, v32, v17, v24, v28, v31, v33, v51, v18, v29, v27, v23, v20, v35, v19, v38, v34, v2]
  add v52, v51, v17  ; live: [v25, v21, v26, v30, v22, v36, v37, v32, v24, v52, v31, v28, v33, v18, v29, v27, v23, v20, v35, v19, v38, v34, v2]
  add v53, v52, v18  ; live: [v25, v21, v53, v26, v30, v22, v36, v37, v32, v24, v28, v31, v33, v29, v27, v23, v20, v35, v19, v38, v34, v2]
  add v54, v53, v19  ; live: [v25, v21, v26, v30, v22, v36, v37, v32, v24, v28, v31, v33, v29, v27, v23, v20, v35, v38, v34, v54, v2]
  add v55, v54, v20  ; live: [v25, v21, v26, v30, v22, v36, v37, v32, v24, v28, v31, v33, v29, v27, v23, v35, v38, v34, v55, v2]
  add v56, v55, v21  ; live: [v25, v26, v30, v22, v36, v37, v32, v24, v28, v31, v33, v56, v29, v27, v23, v35, v38, v34, v2]
  add v57, v56, v22  ; live: [v25, v26, v30, v36, v37, v32, v24, v28, v31, v33, v29, v27, v23, v35, v38, v57, v34, v2]
  add v58, v57, v23  ; live: [v25, v58, v26, v30, v36, v37, v32, v24, v28, v31, v33, v29, v27, v35, v38, v34, v2]
  add v59, v58, v24  ; live: [v25, v26, v30, v36, v37, v32, v28, v31, v33, v29, v27, v35, v38, v59, v34, v2]
  add v60, v59, v25  ; live: [v26, v30, v36, v37, v32, v28, v31, v33, v60, v29, v27, v35, v38, v34, v2]
  add v61, v60, v26  ; live: [v30, v36, v37, v32, v28, v31, v33, v29, v27, v35, v38, v61, v34, v2]
  add v62, v61, v27  ; live: [v2, v62, v29, v30, v36, v35, v37, v38, v32, v31, v28, v34, v33]
  add v63, v62, v28  ; live: [v63, v29, v30, v36, v35, v37, v38, v32, v31, v33, v34, v2]
  add v64, v63, v29  ; live: [v2, v30, v36, v35, v37, v38, v32, v31, v33, v34, v64]
  add v65, v64, v30  ; live: [v2, v36, v35, v37, v38, v32, v65, v31, v33, v34]
  add v66, v65, v31  ; live: [v66, v36, v35, v37, v38, v32, v34, v33, v2]
  add v67, v66, v32  ; live: [v67, v36, v35, v37, v38, v34, v33, v2]
  add v68, v67, v33  ; live: [v68, v36, v35, v37, v38, v34, v2]
  add v69, v68, v34  ; live: [v36, v35, v37, v38, v69, v2]
  add v70, v69, v35  ; live: [v36, v38, v37, v70, v2]
  add v71, v70, v36  ; live: [v38, v37, v71, v2]
  add v72, v71, v37  ; live: [v72, v38, v2]
  add v73, v72, v38  ; live: [v2, v73]
  add v74, v73, v2  ; live: [v74]
; control
  mv a0, v74  ; live: [a0]
  ret  ; live: [a0]

  .p2align 3
  .globl thunk_start
  .type thunk_start, @function
thunk_start:
; block info: defs: [t1, ft0, ft1, a1, t5, fa1, fa2, ft6, a4, fa6, a6, ft5, ft10, ft7, ft4, ft9, a5, a0, fa4, ft2, a2, a3, ft8, t3, a7, fa7, t0, fa5, fa3, ft3, fa0, t4, t2, v2], uses: [zero, a0, v2], upward_exposed: [zero], params_defs: []
; live_in: [zero], live_out: []
; block parameters: []
.thunk_start_b0:
  call main  ; live: [zero]
  mv v2, zero  ; live: [zero, v2]
; control
  mv a0, v2  ; live: [zero, a0]
  ret  ; live: [zero]

  .p2align 3
  .globl main
  .type main, @function
main:
; block info: defs: [v3, t1, ft0, ft1, a1, t5, fa1, fa2, ft6, a4, fa6, a6, ft5, ft10, ft7, ft4, ft9, a5, a0, fa4, ft2, a2, a3, ft8, t3, a7, fa7, t0, fa5, fa3, ft3, fa0, t4, t2, v2], uses: [v3, zero, a0, v2], upward_exposed: [zero], params_defs: []
; live_in: [zero], live_out: []
; block parameters: []
.main_b0:
  mv a0, zero  ; live: [zero, a0]
  call f  ; live: [zero, a0]
  mv v2, a0  ; live: [zero, v2]
  mv a0, v2  ; live: [zero, a0]
  call minimbt_print_int  ; live: [zero]
  mv v3, zero  ; live: [zero, v3]
; control
  mv a0, v3  ; live: [zero, a0]
  ret  ; live: [zero]

  .p2align 3
  .globl start
  .type start, @object
start:
  .zero 4



Testing test/test_src/sum-tail.mbt
# name conventions used in the core ir:
# - functions: f<id>
# - blocks: b<id>
# - instructions: %<id>
# - memory: m<id>
# - free variables: ^<id>
# - function parameters: $f<pid>
# - block parameters: $b<bid>.<pid>
.core
.fn thunk_start #f2 : fn() -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: unit = call f1()
    return %0
  }
}
.fn sum #f0 : fn(int32, int32) -> int32
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: bool = le($f1, 0)
    br %0 b1() b2()
  }
  .bb #b1 () {
    jump b3($f0)
  }
  .bb #b2 () {
    let %1: int32 = add($f0, $f1)
    let %2: int32 = sub($f1, 1)
    let %3: int32 = call f0(%1, %2)
    jump b3(%3)
  }
  .bb #b3 (int32) {
    return $b3.0
  }
}
.fn main #f1 : fn() -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: int32 = call f0(0, 10000)
    let %1: unit = ext_call minimbt_print_int(%0)
    return %1
  }
}
.thunk ::0 start

  .p2align 3
  .globl _start
  .type _start, @function
_start:
; block info: defs: [t1, ft0, ft1, a1, t5, fa1, fa2, ft6, a4, fa6, a6, ft5, ft10, ft7, ft4, ft9, a5, a0, fa4, ft2, a2, a3, ft8, t3, a7, fa7, t0, fa5, fa3, ft3, fa0, t4, t2], uses: [a0], upward_exposed: [], params_defs: []
; live_in: [], live_out: []
; block parameters: []
_start_b0:
  call thunk_start  ; live: [a0]
; control
  ret  ; live: []

  .p2align 3
  .globl thunk_start
  .type thunk_start, @function
thunk_start:
; block info: defs: [t1, ft0, ft1, a1, t5, fa1, fa2, ft6, a4, fa6, a6, ft5, ft10, ft7, ft4, ft9, a5, a0, fa4, ft2, a2, a3, ft8, t3, a7, fa7, t0, fa5, fa3, ft3, fa0, t4, t2, v2], uses: [zero, a0, v2], upward_exposed: [zero], params_defs: []
; live_in: [zero], live_out: []
; block parameters: []
.thunk_start_b0:
  call main  ; live: [zero]
  mv v2, zero  ; live: [zero, v2]
; control
  mv a0, v2  ; live: [zero, a0]
  ret  ; live: [zero]

  .p2align 3
  .globl sum
  .type sum, @function
sum:
; block info: defs: [v3, v4, v13, v2], uses: [a0, zero, v13, v4, a1, v3], upward_exposed: [a1, a0, zero], params_defs: []
; live_in: [a1, a0, zero], live_out: [v3, v2]
; block parameters: []
.sum_b0:
  mv v2, a0  ; live: [a1, a0, zero]
  mv v3, a1  ; live: [a1, a0, zero, v3]
  slt v13, v3, zero  ; live: [a1, a0, zero, v13]
  xori v4, v13, 1  ; live: [v4, a1, a0, zero]
; control
  bne v4, zero, .sum_b1  ; live: [a1, a0, zero]
  j .sum_b2  ; live: [a1, a0, zero]

; block info: defs: [v8], uses: [v2], upward_exposed: [v2], params_defs: []
; live_in: [v2], live_out: [v8]
; block parameters: []
.sum_b1:
; control
  mv v8, v2  ; live: [v2]
  j .sum_b3  ; live: [v2]

; block info: defs: [a0], uses: [a0, v8], upward_exposed: [v8], params_defs: [v8]
; live_in: [v8], live_out: []
; block parameters: [v8]
.sum_b3:
; control
  mv a0, v8  ; live: [a0, v8]
  ret  ; live: [v8]

; block info: defs: [t1, v7, ft0, ft1, a1, t5, fa1, fa2, ft6, a4, fa6, v8, a6, ft10, ft5, v6, ft7, ft4, v5, v10, ft9, a5, a0, fa4, ft2, a2, a3, ft8, t3, a7, fa7, t0, fa5, fa3, ft3, fa0, t4, t2], uses: [v2, v5, v10, a0, v7, v6, a1, v3], upward_exposed: [v3, v2], params_defs: []
; live_in: [v2, v3], live_out: [v8]
; block parameters: []
.sum_b2:
  add v5, v2, v3  ; live: [v3, v5, v2]
  li v10, 1  ; live: [v3, v5, v10, v2]
  sub v6, v3, v10  ; live: [v3, v6, v5, v2]
  mv a0, v5  ; live: [v3, v6, a0, v2]
  mv a1, v6  ; live: [v3, a1, a0, v2]
  call sum  ; live: [v3, a0, v2]
  mv v7, a0  ; live: [v3, v7, v2]
; control
  mv v8, v7  ; live: [v3, v2]
  j .sum_b3  ; live: [v3, v2]

  .p2align 3
  .globl main
  .type main, @function
main:
; block info: defs: [v3, t1, ft0, ft1, a1, t5, fa1, fa2, ft6, a4, fa6, a6, ft5, ft10, ft7, ft4, v5, ft9, a5, a0, fa4, ft2, a2, a3, ft8, t3, a7, fa7, t0, fa5, fa3, ft3, fa0, t4, t2, v2], uses: [v2, v5, zero, a0, a1, v3], upward_exposed: [zero], params_defs: []
; live_in: [zero], live_out: []
; block parameters: []
.main_b0:
  mv a0, zero  ; live: [zero, a0]
  li v5, 10000  ; live: [v5, zero, a0]
  mv a1, v5  ; live: [a1, zero, a0]
  call sum  ; live: [zero, a0]
  mv v2, a0  ; live: [zero, v2]
  mv a0, v2  ; live: [zero, a0]
  call minimbt_print_int  ; live: [zero]
  mv v3, zero  ; live: [zero, v3]
; control
  mv a0, v3  ; live: [zero, a0]
  ret  ; live: [zero]

  .p2align 3
  .globl start
  .type start, @object
start:
  .zero 4



Testing test/test_src/sum.mbt
# name conventions used in the core ir:
# - functions: f<id>
# - blocks: b<id>
# - instructions: %<id>
# - memory: m<id>
# - free variables: ^<id>
# - function parameters: $f<pid>
# - block parameters: $b<bid>.<pid>
.core
.fn thunk_start #f2 : fn() -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: unit = call f1()
    return %0
  }
}
.fn sum #f0 : fn(int32) -> int32
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: bool = le($f0, 0)
    br %0 b1() b2()
  }
  .bb #b1 () {
    jump b3(0)
  }
  .bb #b2 () {
    let %1: int32 = sub($f0, 1)
    let %2: int32 = call f0(%1)
    let %3: int32 = add(%2, $f0)
    jump b3(%3)
  }
  .bb #b3 (int32) {
    return $b3.0
  }
}
.fn main #f1 : fn() -> unit
.freevars ()
.entry b0 {
  .bb #b0 () {
    let %0: int32 = call f0(10000)
    let %1: unit = ext_call minimbt_print_int(%0)
    return %1
  }
}
.thunk ::0 start

  .p2align 3
  .globl _start
  .type _start, @function
_start:
; block info: defs: [t1, ft0, ft1, a1, t5, fa1, fa2, ft6, a4, fa6, a6, ft5, ft10, ft7, ft4, ft9, a5, a0, fa4, ft2, a2, a3, ft8, t3, a7, fa7, t0, fa5, fa3, ft3, fa0, t4, t2], uses: [a0], upward_exposed: [], params_defs: []
; live_in: [], live_out: []
; block parameters: []
_start_b0:
  call thunk_start  ; live: [a0]
; control
  ret  ; live: []

  .p2align 3
  .globl thunk_start
  .type thunk_start, @function
thunk_start:
; block info: defs: [t1, ft0, ft1, a1, t5, fa1, fa2, ft6, a4, fa6, a6, ft5, ft10, ft7, ft4, ft9, a5, a0, fa4, ft2, a2, a3, ft8, t3, a7, fa7, t0, fa5, fa3, ft3, fa0, t4, t2, v2], uses: [zero, a0, v2], upward_exposed: [zero], params_defs: []
; live_in: [zero], live_out: []
; block parameters: []
.thunk_start_b0:
  call main  ; live: [zero]
  mv v2, zero  ; live: [zero, v2]
; control
  mv a0, v2  ; live: [zero, a0]
  ret  ; live: [zero]

  .p2align 3
  .globl sum
  .type sum, @function
sum:
; block info: defs: [v3, v12, v2], uses: [v3, v12, a0, zero, v2], upward_exposed: [a0, zero], params_defs: []
; live_in: [a0, zero], live_out: [zero, v2]
; block parameters: []
.sum_b0:
  mv v2, a0  ; live: [a0, zero, v2]
  slt v12, v2, zero  ; live: [v12, a0, zero]
  xori v3, v12, 1  ; live: [a0, zero, v3]
; control
  bne v3, zero, .sum_b1  ; live: [a0, zero]
  j .sum_b2  ; live: [a0, zero]

; block info: defs: [v7], uses: [zero], upward_exposed: [zero], params_defs: []
; live_in: [zero], live_out: [v7]
; block parameters: []
.sum_b1:
; control
  mv v7, zero  ; live: [zero]
  j .sum_b3  ; live: [zero]

; block info: defs: [a0], uses: [a0, v7], upward_exposed: [v7], params_defs: [v7]
; live_in: [v7], live_out: []
; block parameters: [v7]
.sum_b3:
; control
  mv a0, v7  ; live: [a0, v7]
  ret  ; live: [v7]

; block info: defs: [t1, v7, ft0, ft1, a1, t5, fa1, fa2, ft6, a4, fa6, a6, v4, ft5, ft10, v6, ft7, ft4, v5, v10, ft9, a5, a0, fa4, ft2, a2, a3, ft8, t3, a7, fa7, t0, fa5, fa3, ft3, fa0, t4, t2], uses: [v4, v5, v6, v10, a0, v2], upward_exposed: [v2], params_defs: []
; live_in: [v2], live_out: [v7]
; block parameters: []
.sum_b2:
  li v10, 1  ; live: [v10, v2]
  sub v4, v2, v10  ; live: [v4, v2]
  mv a0, v4  ; live: [a0, v2]
  call sum  ; live: [a0, v2]
  mv v5, a0  ; live: [v5, v2]
  add v6, v5, v2  ; live: [v6, v2]
; control
  mv v7, v6  ; live: [v2]
  j .sum_b3  ; live: [v2]

  .p2align 3
  .globl main
  .type main, @function
main:
; block info: defs: [v3, t1, ft0, ft1, a1, t5, fa1, fa2, ft6, a4, fa6, a6, ft5, ft10, ft7, ft4, v5, ft9, a5, a0, fa4, ft2, a2, a3, ft8, t3, a7, fa7, t0, fa5, fa3, ft3, fa0, t4, t2, v2], uses: [v3, v5, a0, zero, v2], upward_exposed: [zero], params_defs: []
; live_in: [zero], live_out: []
; block parameters: []
.main_b0:
  li v5, 10000  ; live: [v5, zero]
  mv a0, v5  ; live: [zero, a0]
  call sum  ; live: [zero, a0]
  mv v2, a0  ; live: [zero, v2]
  mv a0, v2  ; live: [zero, a0]
  call minimbt_print_int  ; live: [zero]
  mv v3, zero  ; live: [zero, v3]
; control
  mv a0, v3  ; live: [zero, a0]
  ret  ; live: [zero]

  .p2align 3
  .globl start
  .type start, @object
start:
  .zero 4



