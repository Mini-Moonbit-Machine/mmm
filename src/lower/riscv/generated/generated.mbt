// GENERATED BY ISLE. DO NOT EDIT!
//
// Generated automatically from the instruction-selection DSL code in:
// - src/core/prelude.isle
// - src/core/core.isle
// - src/riscv/riscv.isle
// - src/lower/riscv/lower.isle

/// Context during lowering: an implementation of this trait
/// must be provided with all external constructors and extractors.
pub trait Context {
  ref_fn(Self, @core.FnRef) -> @core.Fn
  ref_block(Self, @core.BlockRef) -> @core.Block
  ref_insn(Self, @core.InsnRef) -> @core.Insn
  ref_mem(Self, @core.MemRef) -> @core.Mem
  ref_free_v(Self, @core.FnFreeVarRef) -> UInt
  i64_sext_u64(Self, @core.Type, UInt64) -> Int64
  i32_as_u64(Self, Int) -> UInt64
  i64_as_u64(Self, Int64) -> UInt64
  f64_as_u64(Self, Double) -> UInt64
  arg2(Self, @core.Values) -> (@core.Value, @core.Value)?
  arg1(Self, @core.Values) -> @core.Value?
  next_virtual_xreg(Self) -> @riscv.Reg
  next_virtual_freg(Self) -> @riscv.FReg
  emit_risc_v(Self, @riscv.RvAsm) -> Unit
  xreg_new(Self, @riscv.AnyReg) -> @riscv.Reg
  freg_new(Self, @riscv.AnyReg) -> @riscv.FReg
  xreg_to_reg(Self, @riscv.Reg) -> @riscv.AnyReg
  freg_to_reg(Self, @riscv.FReg) -> @riscv.AnyReg
  put_in_reg(Self, @core.Value) -> @riscv.AnyReg
  is_zero_reg(Self, @riscv.Reg) -> Unit?
  zero_reg(Self) -> @riscv.Reg
  is_closure_reg(Self, @riscv.Reg) -> Unit?
  closure_reg(Self) -> @riscv.Reg
  i64_generate_imm(Self, Int64) -> (@riscv.Imm20, @riscv.Imm12)?
  i32_generate_imm(Self, Int) -> (@riscv.Imm20, @riscv.Imm12)?
  imm20_is_zero(Self, @riscv.Imm20) -> Unit?
  imm12_is_zero(Self, @riscv.Imm12) -> Unit?
  imm20_to_i32(Self, @riscv.Imm20) -> Int
  imm12_to_i32(Self, @riscv.Imm12) -> Int
  imm32_to_string(Self, Int) -> String
  imm64_to_string(Self, Int64) -> String
  lower_call(Self, @core.Type, @core.Fn, @core.Values) -> @riscv.AnyReg
  lower_ext_call(Self, @core.Type, String, @core.Values) -> @riscv.AnyReg
  lower_apply(Self, @core.Type, @core.Value, @core.Values) -> @riscv.AnyReg
  imm12_from_val(Self, @core.Value) -> @riscv.Imm12?
}

struct Returns[T, C] {
  data : Array[T?]
  next : (C) -> T?
}

fn default_next[T, C : Context](_ctx : C) -> T? {
  None
}

fn Returns::new[T, C : Context]() -> Returns[T, C] {
  { data: [], next: default_next }
}

fn Returns::push[T, C : Context](self : Returns[T, C], value : T?) -> Unit {
  self.data.push(value)
}

fn Returns::length[T, C : Context](self : Returns[T, C]) -> Int {
  self.data.length()
}

let _MAX_ISLE_RETURNS = 64

// Generated as internal constructor for term ty_unit.
pub fn constructor_ty_unit[C : Context](ctx : C) -> @core.Type {
  // Rule at src/core/core.isle line 48.
  return @core.Type::Unit
}

// Generated as internal constructor for term ty_bool.
pub fn constructor_ty_bool[C : Context](ctx : C) -> @core.Type {
  // Rule at src/core/core.isle line 52.
  return @core.Type::Bool
}

// Generated as internal constructor for term ty_int32.
pub fn constructor_ty_int32[C : Context](ctx : C) -> @core.Type {
  // Rule at src/core/core.isle line 56.
  return @core.Type::Int32
}

// Generated as internal constructor for term ty_int64.
pub fn constructor_ty_int64[C : Context](ctx : C) -> @core.Type {
  // Rule at src/core/core.isle line 60.
  return @core.Type::Int64
}

// Generated as internal constructor for term ty_double.
pub fn constructor_ty_double[C : Context](ctx : C) -> @core.Type {
  // Rule at src/core/core.isle line 64.
  return @core.Type::Double
}

// Generated as internal constructor for term ty_closure_fn.
pub fn constructor_ty_closure_fn[C : Context](
  ctx : C,
  arg0 : @core.Types,
  arg1 : @core.Type
) -> @core.Type {
  let v2 = @core.Type::ClosureFn(params=arg0, ty=arg1)
  // Rule at src/core/core.isle line 68.
  return v2
}

// Generated as internal constructor for term ty_direct_fn.
pub fn constructor_ty_direct_fn[C : Context](
  ctx : C,
  arg0 : @core.Types,
  arg1 : @core.Type
) -> @core.Type {
  let v2 = @core.Type::DirectFn(params=arg0, ty=arg1)
  // Rule at src/core/core.isle line 72.
  return v2
}

// Generated as internal constructor for term ty_tuple.
pub fn constructor_ty_tuple[C : Context](
  ctx : C,
  arg0 : @core.Types
) -> @core.Type {
  let v1 = @core.Type::Tuple(fields=arg0)
  // Rule at src/core/core.isle line 76.
  return v1
}

// Generated as internal constructor for term ty_array.
pub fn constructor_ty_array[C : Context](
  ctx : C,
  arg0 : @core.Type
) -> @core.Type {
  let v1 = @core.Type::Array(elem=arg0)
  // Rule at src/core/core.isle line 80.
  return v1
}

// Generated as internal constructor for term put_in_xreg.
pub fn constructor_put_in_xreg[C : Context](
  ctx : C,
  arg0 : @core.Value
) -> @riscv.Reg {
  let v1 = C::put_in_reg(ctx, arg0)
  let v2 = C::xreg_new(ctx, v1)
  // Rule at src/riscv/riscv.isle line 113.
  return v2
}

// Generated as internal constructor for term put_in_freg.
pub fn constructor_put_in_freg[C : Context](
  ctx : C,
  arg0 : @core.Value
) -> @riscv.FReg {
  let v1 = C::put_in_reg(ctx, arg0)
  let v2 = C::freg_new(ctx, v1)
  // Rule at src/riscv/riscv.isle line 117.
  return v2
}

// Generated as internal constructor for term rv_add.
pub fn constructor_rv_add[C : Context](
  ctx : C,
  arg0 : @riscv.Reg,
  arg1 : @riscv.Reg
) -> @riscv.Reg {
  let v2 = C::next_virtual_xreg(ctx)
  let v3 = @riscv.RvAsm::Add(rd=v2, rs1=arg0, rs2=arg1)
  let v4 = C::emit_risc_v(ctx, v3)
  // Rule at src/riscv/riscv.isle line 121.
  return v2
}

// Generated as internal constructor for term rv_sub.
pub fn constructor_rv_sub[C : Context](
  ctx : C,
  arg0 : @riscv.Reg,
  arg1 : @riscv.Reg
) -> @riscv.Reg {
  let v2 = C::next_virtual_xreg(ctx)
  let v3 = @riscv.RvAsm::Sub(rd=v2, rs1=arg0, rs2=arg1)
  let v4 = C::emit_risc_v(ctx, v3)
  // Rule at src/riscv/riscv.isle line 127.
  return v2
}

// Generated as internal constructor for term rv_xor.
pub fn constructor_rv_xor[C : Context](
  ctx : C,
  arg0 : @riscv.Reg,
  arg1 : @riscv.Reg
) -> @riscv.Reg {
  let v2 = C::next_virtual_xreg(ctx)
  let v3 = @riscv.RvAsm::Xor(rd=v2, rs1=arg0, rs2=arg1)
  let v4 = C::emit_risc_v(ctx, v3)
  // Rule at src/riscv/riscv.isle line 133.
  return v2
}

// Generated as internal constructor for term rv_or.
pub fn constructor_rv_or[C : Context](
  ctx : C,
  arg0 : @riscv.Reg,
  arg1 : @riscv.Reg
) -> @riscv.Reg {
  let v2 = C::next_virtual_xreg(ctx)
  let v3 = @riscv.RvAsm::Or(rd=v2, rs1=arg0, rs2=arg1)
  let v4 = C::emit_risc_v(ctx, v3)
  // Rule at src/riscv/riscv.isle line 139.
  return v2
}

// Generated as internal constructor for term rv_and.
pub fn constructor_rv_and[C : Context](
  ctx : C,
  arg0 : @riscv.Reg,
  arg1 : @riscv.Reg
) -> @riscv.Reg {
  let v2 = C::next_virtual_xreg(ctx)
  let v3 = @riscv.RvAsm::And(rd=v2, rs1=arg0, rs2=arg1)
  let v4 = C::emit_risc_v(ctx, v3)
  // Rule at src/riscv/riscv.isle line 145.
  return v2
}

// Generated as internal constructor for term rv_sll.
pub fn constructor_rv_sll[C : Context](
  ctx : C,
  arg0 : @riscv.Reg,
  arg1 : @riscv.Reg
) -> @riscv.Reg {
  let v2 = C::next_virtual_xreg(ctx)
  let v3 = @riscv.RvAsm::Sll(rd=v2, rs1=arg0, rs2=arg1)
  let v4 = C::emit_risc_v(ctx, v3)
  // Rule at src/riscv/riscv.isle line 151.
  return v2
}

// Generated as internal constructor for term rv_srl.
pub fn constructor_rv_srl[C : Context](
  ctx : C,
  arg0 : @riscv.Reg,
  arg1 : @riscv.Reg
) -> @riscv.Reg {
  let v2 = C::next_virtual_xreg(ctx)
  let v3 = @riscv.RvAsm::Srl(rd=v2, rs1=arg0, rs2=arg1)
  let v4 = C::emit_risc_v(ctx, v3)
  // Rule at src/riscv/riscv.isle line 157.
  return v2
}

// Generated as internal constructor for term rv_sra.
pub fn constructor_rv_sra[C : Context](
  ctx : C,
  arg0 : @riscv.Reg,
  arg1 : @riscv.Reg
) -> @riscv.Reg {
  let v2 = C::next_virtual_xreg(ctx)
  let v3 = @riscv.RvAsm::Sra(rd=v2, rs1=arg0, rs2=arg1)
  let v4 = C::emit_risc_v(ctx, v3)
  // Rule at src/riscv/riscv.isle line 163.
  return v2
}

// Generated as internal constructor for term rv_slt.
pub fn constructor_rv_slt[C : Context](
  ctx : C,
  arg0 : @riscv.Reg,
  arg1 : @riscv.Reg
) -> @riscv.Reg {
  let v2 = C::next_virtual_xreg(ctx)
  let v3 = @riscv.RvAsm::Slt(rd=v2, rs1=arg0, rs2=arg1)
  let v4 = C::emit_risc_v(ctx, v3)
  // Rule at src/riscv/riscv.isle line 169.
  return v2
}

// Generated as internal constructor for term rv_sltu.
pub fn constructor_rv_sltu[C : Context](
  ctx : C,
  arg0 : @riscv.Reg,
  arg1 : @riscv.Reg
) -> @riscv.Reg {
  let v2 = C::next_virtual_xreg(ctx)
  let v3 = @riscv.RvAsm::Sltu(rd=v2, rs1=arg0, rs2=arg1)
  let v4 = C::emit_risc_v(ctx, v3)
  // Rule at src/riscv/riscv.isle line 175.
  return v2
}

// Generated as internal constructor for term rv_addi.
pub fn constructor_rv_addi[C : Context](
  ctx : C,
  arg0 : @riscv.Reg,
  arg1 : Int
) -> @riscv.Reg {
  let v2 = C::next_virtual_xreg(ctx)
  let v3 = @riscv.RvAsm::Addi(rd=v2, rs1=arg0, imm=arg1)
  let v4 = C::emit_risc_v(ctx, v3)
  // Rule at src/riscv/riscv.isle line 181.
  return v2
}

// Generated as internal constructor for term rv_xori.
pub fn constructor_rv_xori[C : Context](
  ctx : C,
  arg0 : @riscv.Reg,
  arg1 : Int
) -> @riscv.Reg {
  let v2 = C::next_virtual_xreg(ctx)
  let v3 = @riscv.RvAsm::Xori(rd=v2, rs1=arg0, imm=arg1)
  let v4 = C::emit_risc_v(ctx, v3)
  // Rule at src/riscv/riscv.isle line 187.
  return v2
}

// Generated as internal constructor for term rv_ori.
pub fn constructor_rv_ori[C : Context](
  ctx : C,
  arg0 : @riscv.Reg,
  arg1 : Int
) -> @riscv.Reg {
  let v2 = C::next_virtual_xreg(ctx)
  let v3 = @riscv.RvAsm::Ori(rd=v2, rs1=arg0, imm=arg1)
  let v4 = C::emit_risc_v(ctx, v3)
  // Rule at src/riscv/riscv.isle line 193.
  return v2
}

// Generated as internal constructor for term rv_andi.
pub fn constructor_rv_andi[C : Context](
  ctx : C,
  arg0 : @riscv.Reg,
  arg1 : Int
) -> @riscv.Reg {
  let v2 = C::next_virtual_xreg(ctx)
  let v3 = @riscv.RvAsm::Andi(rd=v2, rs1=arg0, imm=arg1)
  let v4 = C::emit_risc_v(ctx, v3)
  // Rule at src/riscv/riscv.isle line 199.
  return v2
}

// Generated as internal constructor for term rv_slli.
pub fn constructor_rv_slli[C : Context](
  ctx : C,
  arg0 : @riscv.Reg,
  arg1 : Int
) -> @riscv.Reg {
  let v2 = C::next_virtual_xreg(ctx)
  let v3 = @riscv.RvAsm::Slli(rd=v2, rs1=arg0, imm=arg1)
  let v4 = C::emit_risc_v(ctx, v3)
  // Rule at src/riscv/riscv.isle line 205.
  return v2
}

// Generated as internal constructor for term rv_srli.
pub fn constructor_rv_srli[C : Context](
  ctx : C,
  arg0 : @riscv.Reg,
  arg1 : Int
) -> @riscv.Reg {
  let v2 = C::next_virtual_xreg(ctx)
  let v3 = @riscv.RvAsm::Srli(rd=v2, rs1=arg0, imm=arg1)
  let v4 = C::emit_risc_v(ctx, v3)
  // Rule at src/riscv/riscv.isle line 211.
  return v2
}

// Generated as internal constructor for term rv_srai.
pub fn constructor_rv_srai[C : Context](
  ctx : C,
  arg0 : @riscv.Reg,
  arg1 : Int
) -> @riscv.Reg {
  let v2 = C::next_virtual_xreg(ctx)
  let v3 = @riscv.RvAsm::Srai(rd=v2, rs1=arg0, imm=arg1)
  let v4 = C::emit_risc_v(ctx, v3)
  // Rule at src/riscv/riscv.isle line 217.
  return v2
}

// Generated as internal constructor for term rv_slti.
pub fn constructor_rv_slti[C : Context](
  ctx : C,
  arg0 : @riscv.Reg,
  arg1 : Int
) -> @riscv.Reg {
  let v2 = C::next_virtual_xreg(ctx)
  let v3 = @riscv.RvAsm::Slti(rd=v2, rs1=arg0, imm=arg1)
  let v4 = C::emit_risc_v(ctx, v3)
  // Rule at src/riscv/riscv.isle line 223.
  return v2
}

// Generated as internal constructor for term rv_sltiu.
pub fn constructor_rv_sltiu[C : Context](
  ctx : C,
  arg0 : @riscv.Reg,
  arg1 : Int
) -> @riscv.Reg {
  let v2 = C::next_virtual_xreg(ctx)
  let v3 = @riscv.RvAsm::Sltiu(rd=v2, rs1=arg0, imm=arg1)
  let v4 = C::emit_risc_v(ctx, v3)
  // Rule at src/riscv/riscv.isle line 229.
  return v2
}

// Generated as internal constructor for term rv_lb.
pub fn constructor_rv_lb[C : Context](
  ctx : C,
  arg0 : @riscv.MemAccess[@riscv.Reg, Int]
) -> @riscv.Reg {
  let v1 = C::next_virtual_xreg(ctx)
  let v2 = @riscv.RvAsm::Lb(rd=v1, mem=arg0)
  let v3 = C::emit_risc_v(ctx, v2)
  // Rule at src/riscv/riscv.isle line 235.
  return v1
}

// Generated as internal constructor for term rv_lh.
pub fn constructor_rv_lh[C : Context](
  ctx : C,
  arg0 : @riscv.MemAccess[@riscv.Reg, Int]
) -> @riscv.Reg {
  let v1 = C::next_virtual_xreg(ctx)
  let v2 = @riscv.RvAsm::Lh(rd=v1, mem=arg0)
  let v3 = C::emit_risc_v(ctx, v2)
  // Rule at src/riscv/riscv.isle line 241.
  return v1
}

// Generated as internal constructor for term rv_lw.
pub fn constructor_rv_lw[C : Context](
  ctx : C,
  arg0 : @riscv.MemAccess[@riscv.Reg, Int]
) -> @riscv.Reg {
  let v1 = C::next_virtual_xreg(ctx)
  let v2 = @riscv.RvAsm::Lw(rd=v1, mem=arg0)
  let v3 = C::emit_risc_v(ctx, v2)
  // Rule at src/riscv/riscv.isle line 247.
  return v1
}

// Generated as internal constructor for term rv_ld.
pub fn constructor_rv_ld[C : Context](
  ctx : C,
  arg0 : @riscv.MemAccess[@riscv.Reg, Int]
) -> @riscv.Reg {
  let v1 = C::next_virtual_xreg(ctx)
  let v2 = @riscv.RvAsm::Ld(rd=v1, mem=arg0)
  let v3 = C::emit_risc_v(ctx, v2)
  // Rule at src/riscv/riscv.isle line 253.
  return v1
}

// Generated as internal constructor for term rv_mul.
pub fn constructor_rv_mul[C : Context](
  ctx : C,
  arg0 : @riscv.Reg,
  arg1 : @riscv.Reg
) -> @riscv.Reg {
  let v2 = C::next_virtual_xreg(ctx)
  let v3 = @riscv.RvAsm::Mul(rd=v2, rs1=arg0, rs2=arg1)
  let v4 = C::emit_risc_v(ctx, v3)
  // Rule at src/riscv/riscv.isle line 259.
  return v2
}

// Generated as internal constructor for term rv_mulw.
pub fn constructor_rv_mulw[C : Context](
  ctx : C,
  arg0 : @riscv.Reg,
  arg1 : @riscv.Reg
) -> @riscv.Reg {
  let v2 = C::next_virtual_xreg(ctx)
  let v3 = @riscv.RvAsm::Mulw(rd=v2, rs1=arg0, rs2=arg1)
  let v4 = C::emit_risc_v(ctx, v3)
  // Rule at src/riscv/riscv.isle line 265.
  return v2
}

// Generated as internal constructor for term rv_mulh.
pub fn constructor_rv_mulh[C : Context](
  ctx : C,
  arg0 : @riscv.Reg,
  arg1 : @riscv.Reg
) -> @riscv.Reg {
  let v2 = C::next_virtual_xreg(ctx)
  let v3 = @riscv.RvAsm::Mulh(rd=v2, rs1=arg0, rs2=arg1)
  let v4 = C::emit_risc_v(ctx, v3)
  // Rule at src/riscv/riscv.isle line 271.
  return v2
}

// Generated as internal constructor for term rv_mulhsu.
pub fn constructor_rv_mulhsu[C : Context](
  ctx : C,
  arg0 : @riscv.Reg,
  arg1 : @riscv.Reg
) -> @riscv.Reg {
  let v2 = C::next_virtual_xreg(ctx)
  let v3 = @riscv.RvAsm::Mulhsu(rd=v2, rs1=arg0, rs2=arg1)
  let v4 = C::emit_risc_v(ctx, v3)
  // Rule at src/riscv/riscv.isle line 277.
  return v2
}

// Generated as internal constructor for term rv_mulhu.
pub fn constructor_rv_mulhu[C : Context](
  ctx : C,
  arg0 : @riscv.Reg,
  arg1 : @riscv.Reg
) -> @riscv.Reg {
  let v2 = C::next_virtual_xreg(ctx)
  let v3 = @riscv.RvAsm::Mulhu(rd=v2, rs1=arg0, rs2=arg1)
  let v4 = C::emit_risc_v(ctx, v3)
  // Rule at src/riscv/riscv.isle line 283.
  return v2
}

// Generated as internal constructor for term rv_div.
pub fn constructor_rv_div[C : Context](
  ctx : C,
  arg0 : @riscv.Reg,
  arg1 : @riscv.Reg
) -> @riscv.Reg {
  let v2 = C::next_virtual_xreg(ctx)
  let v3 = @riscv.RvAsm::Div(rd=v2, rs1=arg0, rs2=arg1)
  let v4 = C::emit_risc_v(ctx, v3)
  // Rule at src/riscv/riscv.isle line 289.
  return v2
}

// Generated as internal constructor for term rv_divw.
pub fn constructor_rv_divw[C : Context](
  ctx : C,
  arg0 : @riscv.Reg,
  arg1 : @riscv.Reg
) -> @riscv.Reg {
  let v2 = C::next_virtual_xreg(ctx)
  let v3 = @riscv.RvAsm::Divw(rd=v2, rs1=arg0, rs2=arg1)
  let v4 = C::emit_risc_v(ctx, v3)
  // Rule at src/riscv/riscv.isle line 295.
  return v2
}

// Generated as internal constructor for term rv_divu.
pub fn constructor_rv_divu[C : Context](
  ctx : C,
  arg0 : @riscv.Reg,
  arg1 : @riscv.Reg
) -> @riscv.Reg {
  let v2 = C::next_virtual_xreg(ctx)
  let v3 = @riscv.RvAsm::Divu(rd=v2, rs1=arg0, rs2=arg1)
  let v4 = C::emit_risc_v(ctx, v3)
  // Rule at src/riscv/riscv.isle line 301.
  return v2
}

// Generated as internal constructor for term rv_rem.
pub fn constructor_rv_rem[C : Context](
  ctx : C,
  arg0 : @riscv.Reg,
  arg1 : @riscv.Reg
) -> @riscv.Reg {
  let v2 = C::next_virtual_xreg(ctx)
  let v3 = @riscv.RvAsm::Rem(rd=v2, rs1=arg0, rs2=arg1)
  let v4 = C::emit_risc_v(ctx, v3)
  // Rule at src/riscv/riscv.isle line 307.
  return v2
}

// Generated as internal constructor for term rv_remu.
pub fn constructor_rv_remu[C : Context](
  ctx : C,
  arg0 : @riscv.Reg,
  arg1 : @riscv.Reg
) -> @riscv.Reg {
  let v2 = C::next_virtual_xreg(ctx)
  let v3 = @riscv.RvAsm::Remu(rd=v2, rs1=arg0, rs2=arg1)
  let v4 = C::emit_risc_v(ctx, v3)
  // Rule at src/riscv/riscv.isle line 313.
  return v2
}

// Generated as internal constructor for term rv_fadd_d.
pub fn constructor_rv_fadd_d[C : Context](
  ctx : C,
  arg0 : @riscv.FReg,
  arg1 : @riscv.FReg
) -> @riscv.FReg {
  let v2 = C::next_virtual_freg(ctx)
  let v3 = @riscv.RvAsm::FaddD(rd=v2, rs1=arg0, rs2=arg1)
  let v4 = C::emit_risc_v(ctx, v3)
  // Rule at src/riscv/riscv.isle line 319.
  return v2
}

// Generated as internal constructor for term rv_fsub_d.
pub fn constructor_rv_fsub_d[C : Context](
  ctx : C,
  arg0 : @riscv.FReg,
  arg1 : @riscv.FReg
) -> @riscv.FReg {
  let v2 = C::next_virtual_freg(ctx)
  let v3 = @riscv.RvAsm::FsubD(rd=v2, rs1=arg0, rs2=arg1)
  let v4 = C::emit_risc_v(ctx, v3)
  // Rule at src/riscv/riscv.isle line 325.
  return v2
}

// Generated as internal constructor for term rv_fmul_d.
pub fn constructor_rv_fmul_d[C : Context](
  ctx : C,
  arg0 : @riscv.FReg,
  arg1 : @riscv.FReg
) -> @riscv.FReg {
  let v2 = C::next_virtual_freg(ctx)
  let v3 = @riscv.RvAsm::FmulD(rd=v2, rs1=arg0, rs2=arg1)
  let v4 = C::emit_risc_v(ctx, v3)
  // Rule at src/riscv/riscv.isle line 331.
  return v2
}

// Generated as internal constructor for term rv_fdiv_d.
pub fn constructor_rv_fdiv_d[C : Context](
  ctx : C,
  arg0 : @riscv.FReg,
  arg1 : @riscv.FReg
) -> @riscv.FReg {
  let v2 = C::next_virtual_freg(ctx)
  let v3 = @riscv.RvAsm::FdivD(rd=v2, rs1=arg0, rs2=arg1)
  let v4 = C::emit_risc_v(ctx, v3)
  // Rule at src/riscv/riscv.isle line 337.
  return v2
}

// Generated as internal constructor for term rv_fld.
pub fn constructor_rv_fld[C : Context](
  ctx : C,
  arg0 : @riscv.MemAccess[@riscv.Reg, Int]
) -> @riscv.FReg {
  let v1 = C::next_virtual_freg(ctx)
  let v2 = @riscv.RvAsm::Fld(rd=v1, mem=arg0)
  let v3 = C::emit_risc_v(ctx, v2)
  // Rule at src/riscv/riscv.isle line 343.
  return v1
}

// Generated as internal constructor for term rv_f_mv_dx.
pub fn constructor_rv_f_mv_dx[C : Context](
  ctx : C,
  arg0 : @riscv.Reg
) -> @riscv.FReg {
  let v1 = C::next_virtual_freg(ctx)
  let v2 = @riscv.RvAsm::FmvDX(rd=v1, rs=arg0)
  let v3 = C::emit_risc_v(ctx, v2)
  // Rule at src/riscv/riscv.isle line 349.
  return v1
}

// Generated as internal constructor for term rv_la.
pub fn constructor_rv_la[C : Context](
  ctx : C,
  arg0 : @riscv.Label
) -> @riscv.Reg {
  let v1 = C::next_virtual_xreg(ctx)
  let v2 = @riscv.RvAsm::La(rd=v1, l=arg0)
  let v3 = C::emit_risc_v(ctx, v2)
  // Rule at src/riscv/riscv.isle line 355.
  return v1
}

// Generated as internal constructor for term rv_li.
pub fn constructor_rv_li[C : Context](ctx : C, arg0 : String) -> @riscv.Reg {
  let v1 = C::next_virtual_xreg(ctx)
  let v2 = @riscv.RvAsm::Li(rd=v1, i=arg0)
  let v3 = C::emit_risc_v(ctx, v2)
  // Rule at src/riscv/riscv.isle line 361.
  return v1
}

// Generated as internal constructor for term rv_neg.
pub fn constructor_rv_neg[C : Context](
  ctx : C,
  arg0 : @riscv.Reg
) -> @riscv.Reg {
  let v1 = C::next_virtual_xreg(ctx)
  let v2 = @riscv.RvAsm::Neg(rd=v1, rs=arg0)
  let v3 = C::emit_risc_v(ctx, v2)
  // Rule at src/riscv/riscv.isle line 367.
  return v1
}

// Generated as internal constructor for term rv_fneg_d.
pub fn constructor_rv_fneg_d[C : Context](
  ctx : C,
  arg0 : @riscv.FReg
) -> @riscv.FReg {
  let v1 = C::next_virtual_freg(ctx)
  let v2 = @riscv.RvAsm::FnegD(rd=v1, rs=arg0)
  let v3 = C::emit_risc_v(ctx, v2)
  // Rule at src/riscv/riscv.isle line 373.
  return v1
}

// Generated as internal constructor for term rv_mv.
pub fn constructor_rv_mv[C : Context](ctx : C, arg0 : @riscv.Reg) -> @riscv.Reg {
  let v1 = C::next_virtual_xreg(ctx)
  let v2 = @riscv.RvAsm::Mv(rd=v1, rs=arg0)
  let v3 = C::emit_risc_v(ctx, v2)
  // Rule at src/riscv/riscv.isle line 379.
  return v1
}

// Generated as internal constructor for term imm.
pub fn constructor_imm[C : Context](
  ctx : C,
  arg0 : @core.Type,
  arg1 : UInt64
) -> @riscv.AnyReg {
  match arg0 {
    @core.Type::Int32 => {
      let v10 = constructor_ty_int32(ctx)
      let v11 = C::i64_sext_u64(ctx, v10, arg1)
      let v12 = C::imm64_to_string(ctx, v11)
      let v13 = constructor_rv_li(ctx, v12)
      let v14 = C::xreg_to_reg(ctx, v13)
      // Rule at src/lower/riscv/lower.isle line 11.
      return v14
    }
    @core.Type::Int64 => {
      let v5 = constructor_ty_int64(ctx)
      let v15 = C::i64_sext_u64(ctx, v5, arg1)
      let v16 = C::imm64_to_string(ctx, v15)
      let v17 = constructor_rv_li(ctx, v16)
      let v18 = C::xreg_to_reg(ctx, v17)
      // Rule at src/lower/riscv/lower.isle line 15.
      return v18
    }
    @core.Type::Double => {
      match arg1 {
        0x0 => {
          let v2 = C::zero_reg(ctx)
          let v3 = constructor_rv_f_mv_dx(ctx, v2)
          let v4 = C::freg_to_reg(ctx, v3)
          // Rule at src/lower/riscv/lower.isle line 4.
          return v4
        }
        _ => ()
      }
      let v5 = constructor_ty_int64(ctx)
      let v6 = constructor_imm(ctx, v5, arg1)
      let v7 = C::xreg_new(ctx, v6)
      let v8 = constructor_rv_f_mv_dx(ctx, v7)
      let v9 = C::freg_to_reg(ctx, v8)
      // Rule at src/lower/riscv/lower.isle line 7.
      return v9
    }
    _ => ()
  }
  abort(
    "no rule matched for term imm at src/lower/riscv/lower.isle line 2; should it be partial?",
  )
}

// Generated as internal constructor for term lower_value.
pub fn constructor_lower_value[C : Context](
  ctx : C,
  arg0 : @core.Value
) -> @riscv.AnyReg? {
  match arg0 {
    @core.Value::Double(val=v11) => {
      let v12 = constructor_ty_double(ctx)
      let v13 = C::f64_as_u64(ctx, v11)
      let v14 = constructor_imm(ctx, v12, v13)
      let v15 = Some(v14)
      // Rule at src/lower/riscv/lower.isle line 36.
      return v15
    }
    @core.Value::Int32(val=v1) => {
      let v2 = constructor_ty_int32(ctx)
      let v3 = C::i32_as_u64(ctx, v1)
      let v4 = constructor_imm(ctx, v2, v3)
      let v5 = Some(v4)
      // Rule at src/lower/riscv/lower.isle line 30.
      return v5
    }
    @core.Value::Int64(val=v6) => {
      let v7 = constructor_ty_int64(ctx)
      let v8 = C::i64_as_u64(ctx, v6)
      let v9 = constructor_imm(ctx, v7, v8)
      let v10 = Some(v9)
      // Rule at src/lower/riscv/lower.isle line 33.
      return v10
    }
    @core.Value::Self(fref=v16) => {
      let v17 = C::closure_reg(ctx)
      let v18 = C::xreg_to_reg(ctx, v17)
      let v19 = Some(v18)
      // Rule at src/lower/riscv/lower.isle line 39.
      return v19
    }
    _ => ()
  }
  let v20 = C::put_in_reg(ctx, arg0)
  let v21 = Some(v20)
  // Rule at src/lower/riscv/lower.isle line 42.
  return v21
}

// Generated as internal constructor for term lower.
pub fn constructor_lower[C : Context](
  ctx : C,
  arg0 : @core.Insn
) -> @riscv.AnyReg? {
  match arg0 {
    @core.Insn::Op(ty=v1, op=v2, args=v3) =>
      match v1 {
        @core.Type::Int32 =>
          match v2 {
            @core.Op::Add => {
              let v4 = C::arg2(ctx, v3)
              match v4 {
                Some(v5) => {
                  let v8 = constructor_put_in_xreg(ctx, v5.0)
                  let v9 = constructor_put_in_xreg(ctx, v5.1)
                  let v10 = constructor_rv_add(ctx, v8, v9)
                  let v11 = C::xreg_to_reg(ctx, v10)
                  let v12 = Some(v11)
                  // Rule at src/lower/riscv/lower.isle line 53.
                  return v12
                }
                _ => ()
              }
            }
            @core.Op::Sub => {
              let v4 = C::arg2(ctx, v3)
              match v4 {
                Some(v5) => {
                  let v8 = constructor_put_in_xreg(ctx, v5.0)
                  let v13 = constructor_put_in_xreg(ctx, v5.0)
                  let v14 = constructor_rv_sub(ctx, v8, v13)
                  let v15 = C::xreg_to_reg(ctx, v14)
                  let v16 = Some(v15)
                  // Rule at src/lower/riscv/lower.isle line 59.
                  return v16
                }
                _ => ()
              }
            }
            @core.Op::Mul => {
              let v4 = C::arg2(ctx, v3)
              match v4 {
                Some(v5) => {
                  let v8 = constructor_put_in_xreg(ctx, v5.0)
                  let v9 = constructor_put_in_xreg(ctx, v5.1)
                  let v17 = constructor_rv_mulw(ctx, v8, v9)
                  let v18 = C::xreg_to_reg(ctx, v17)
                  let v19 = Some(v18)
                  // Rule at src/lower/riscv/lower.isle line 65.
                  return v19
                }
                _ => ()
              }
            }
            @core.Op::Div => {
              let v4 = C::arg2(ctx, v3)
              match v4 {
                Some(v5) => {
                  let v8 = constructor_put_in_xreg(ctx, v5.0)
                  let v9 = constructor_put_in_xreg(ctx, v5.1)
                  let v20 = constructor_rv_divw(ctx, v8, v9)
                  let v21 = C::xreg_to_reg(ctx, v20)
                  let v22 = Some(v21)
                  // Rule at src/lower/riscv/lower.isle line 71.
                  return v22
                }
                _ => ()
              }
            }
            @core.Op::Neg => {
              let v23 = C::arg1(ctx, v3)
              match v23 {
                Some(v24) => {
                  let v25 = constructor_put_in_xreg(ctx, v24)
                  let v26 = constructor_rv_neg(ctx, v25)
                  let v27 = C::xreg_to_reg(ctx, v26)
                  let v28 = Some(v27)
                  // Rule at src/lower/riscv/lower.isle line 77.
                  return v28
                }
                _ => ()
              }
            }
            @core.Op::Lnot => {
              let v23 = C::arg1(ctx, v3)
              match v23 {
                Some(v24) => {
                  let v25 = constructor_put_in_xreg(ctx, v24)
                  let v30 = constructor_rv_sltiu(ctx, v25, 0x1)
                  let v31 = C::xreg_to_reg(ctx, v30)
                  let v32 = Some(v31)
                  // Rule at src/lower/riscv/lower.isle line 83.
                  return v32
                }
                _ => ()
              }
            }
            @core.Op::Eq => {
              let v4 = C::arg2(ctx, v3)
              match v4 {
                Some(v5) => {
                  let v8 = constructor_put_in_xreg(ctx, v5.0)
                  let v9 = constructor_put_in_xreg(ctx, v5.1)
                  let v33 = constructor_rv_xor(ctx, v8, v9)
                  let v34 = constructor_rv_sltiu(ctx, v33, 0x1)
                  let v35 = C::xreg_to_reg(ctx, v34)
                  let v36 = Some(v35)
                  // Rule at src/lower/riscv/lower.isle line 89.
                  return v36
                }
                _ => ()
              }
            }
            @core.Op::Le => {
              let v4 = C::arg2(ctx, v3)
              match v4 {
                Some(v5) => {
                  let v8 = constructor_put_in_xreg(ctx, v5.0)
                  let v9 = constructor_put_in_xreg(ctx, v5.1)
                  let v37 = constructor_rv_sltu(ctx, v8, v9)
                  let v38 = constructor_rv_xori(ctx, v37, 0x1)
                  let v39 = C::xreg_to_reg(ctx, v38)
                  let v40 = Some(v39)
                  // Rule at src/lower/riscv/lower.isle line 96.
                  return v40
                }
                _ => ()
              }
            }
            _ => ()
          }
        @core.Type::Double =>
          match v2 {
            @core.Op::Add => {
              let v4 = C::arg2(ctx, v3)
              match v4 {
                Some(v5) => {
                  let v41 = constructor_put_in_freg(ctx, v5.0)
                  let v42 = constructor_put_in_freg(ctx, v5.1)
                  let v43 = constructor_rv_fadd_d(ctx, v41, v42)
                  let v44 = C::freg_to_reg(ctx, v43)
                  let v45 = Some(v44)
                  // Rule at src/lower/riscv/lower.isle line 103.
                  return v45
                }
                _ => ()
              }
            }
            @core.Op::Sub => {
              let v4 = C::arg2(ctx, v3)
              match v4 {
                Some(v5) => {
                  let v41 = constructor_put_in_freg(ctx, v5.0)
                  let v42 = constructor_put_in_freg(ctx, v5.1)
                  let v46 = constructor_rv_fsub_d(ctx, v41, v42)
                  let v47 = C::freg_to_reg(ctx, v46)
                  let v48 = Some(v47)
                  // Rule at src/lower/riscv/lower.isle line 109.
                  return v48
                }
                _ => ()
              }
            }
            @core.Op::Mul => {
              let v4 = C::arg2(ctx, v3)
              match v4 {
                Some(v5) => {
                  let v41 = constructor_put_in_freg(ctx, v5.0)
                  let v42 = constructor_put_in_freg(ctx, v5.1)
                  let v49 = constructor_rv_fmul_d(ctx, v41, v42)
                  let v50 = C::freg_to_reg(ctx, v49)
                  let v51 = Some(v50)
                  // Rule at src/lower/riscv/lower.isle line 115.
                  return v51
                }
                _ => ()
              }
            }
            @core.Op::Div => {
              let v4 = C::arg2(ctx, v3)
              match v4 {
                Some(v5) => {
                  let v41 = constructor_put_in_freg(ctx, v5.0)
                  let v42 = constructor_put_in_freg(ctx, v5.1)
                  let v52 = constructor_rv_fdiv_d(ctx, v41, v42)
                  let v53 = C::freg_to_reg(ctx, v52)
                  let v54 = Some(v53)
                  // Rule at src/lower/riscv/lower.isle line 121.
                  return v54
                }
                _ => ()
              }
            }
            @core.Op::Neg => {
              let v23 = C::arg1(ctx, v3)
              match v23 {
                Some(v24) => {
                  let v55 = constructor_put_in_freg(ctx, v24)
                  let v56 = constructor_rv_fneg_d(ctx, v55)
                  let v57 = C::freg_to_reg(ctx, v56)
                  let v58 = Some(v57)
                  // Rule at src/lower/riscv/lower.isle line 127.
                  return v58
                }
                _ => ()
              }
            }
            _ => ()
          }
        _ => ()
      }
    @core.Insn::Call(ty=v64, f=v65, args=v66) => {
      let v67 = C::ref_fn(ctx, v65)
      let v68 = C::lower_call(ctx, v64, v67, v66)
      let v69 = Some(v68)
      // Rule at src/lower/riscv/lower.isle line 135.
      return v69
    }
    @core.Insn::Apply(ty=v70, f=v71, args=v72) => {
      let v73 = C::lower_apply(ctx, v70, v71, v72)
      let v74 = Some(v73)
      // Rule at src/lower/riscv/lower.isle line 138.
      return v74
    }
    @core.Insn::ExtCall(ty=v59, ext_f=v60, args=v61) => {
      let v62 = C::lower_ext_call(ctx, v59, v60, v61)
      let v63 = Some(v62)
      // Rule at src/lower/riscv/lower.isle line 132.
      return v63
    }
    _ => ()
  }
  None
}
