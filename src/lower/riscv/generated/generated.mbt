// GENERATED BY ISLE. DO NOT EDIT!
//
// Generated automatically from the instruction-selection DSL code in:
// - src/core/prelude.isle
// - src/core/core.isle
// - src/riscv/riscv.isle
// - src/lower/riscv/lower.isle

/// Context during lowering: an implementation of this trait
/// must be provided with all external constructors and extractors.
pub trait Context {
  ref_fn(Self, @core.FnRef) -> @core.Fn
  ref_block(Self, @core.BlockRef) -> @core.Block
  ref_insn(Self, @core.InsnRef) -> @core.Insn
  ref_mem(Self, @core.MemRef) -> @core.Mem
  ref_free_v(Self, @core.FnFreeVarRef) -> UInt
  ref_symbol(Self, @core.SymbolRef) -> @core.Symbol
  i64_sext_u64(Self, @core.Type, UInt64) -> Int64
  i32_as_u64(Self, Int) -> UInt64
  i64_as_u64(Self, Int64) -> UInt64
  f64_as_u64(Self, Double) -> UInt64
  values_to_args(Self, @core.Values) -> Args?
  next_virtual_xreg(Self) -> @riscv.Reg
  next_virtual_freg(Self) -> @riscv.FReg
  emit_risc_v(Self, @riscv.RvAsm) -> Unit
  xreg_new(Self, @riscv.AnyReg) -> @riscv.Reg
  freg_new(Self, @riscv.AnyReg) -> @riscv.FReg
  xreg_to_reg(Self, @riscv.Reg) -> @riscv.AnyReg
  freg_to_reg(Self, @riscv.FReg) -> @riscv.AnyReg
  is_zero_reg(Self, @riscv.Reg) -> Unit?
  zero_reg(Self) -> @riscv.Reg
  is_closure_reg(Self, @riscv.Reg) -> Unit?
  closure_reg(Self) -> @riscv.Reg
  is_return_reg(Self, @riscv.Reg) -> Unit?
  return_reg(Self) -> @riscv.Reg
  is_float_return_reg(Self, @riscv.FReg) -> Unit?
  float_return_reg(Self) -> @riscv.FReg
  i64_generate_imm(Self, Int64) -> (@riscv.Imm20, @riscv.Imm12)?
  i32_generate_imm(Self, Int) -> (@riscv.Imm20, @riscv.Imm12)?
  imm20_is_zero(Self, @riscv.Imm20) -> Unit?
  imm12_is_zero(Self, @riscv.Imm12) -> Unit?
  imm20_to_i32(Self, @riscv.Imm20) -> Int
  imm12_to_i32(Self, @riscv.Imm12) -> Int
  imm32_to_string(Self, Int) -> String
  imm64_to_string(Self, Int64) -> String
  mark_maybe_aliased(Self, @riscv.AnyReg) -> @riscv.AnyReg
  put_in_reg(Self, @core.Value) -> @riscv.AnyReg
  block_label(Self, @core.BlockRef) -> @riscv.Label
  imm12_from_val(Self, @core.Value) -> @riscv.Imm12?
  has_type(Self, @core.Value) -> (@core.Value, @core.Type)
  emit_block_parameters(Self, @core.BlockRef, @core.Values) -> Unit
  emit_fake_epilogue(Self) -> Unit
  lower_load_fn(Self, @core.FnRef) -> @riscv.AnyReg
  lower_call(Self, @core.Type, @core.Fn, @core.Values) -> @riscv.AnyReg
  lower_ext_call(Self, @core.Type, String, @core.Values) -> @riscv.AnyReg
  lower_apply(Self, @core.Type, @core.Value, @core.Values) -> @riscv.AnyReg
  lower_load_symbol(Self, @core.Type, @core.SymbolRef) -> @riscv.AnyReg
  lower_store(Self, @core.Type, @core.Address, @core.Value) -> @riscv.AnyReg
  lower_load(Self, @core.Type, @core.Address) -> @riscv.AnyReg
  lower_alloc(Self, @core.Type, @core.MemRef, @core.Fills) -> @riscv.AnyReg
}

struct Returns[T, C] {
  data : Array[T?]
  next : (C) -> T?
}

fn default_next[T, C : Context](_ctx : C) -> T? {
  None
}

fn Returns::new[T, C : Context]() -> Returns[T, C] {
  { data: [], next: default_next }
}

fn Returns::push[T, C : Context](self : Returns[T, C], value : T?) -> Unit {
  self.data.push(value)
}

fn Returns::length[T, C : Context](self : Returns[T, C]) -> Int {
  self.data.length()
}

let _MAX_ISLE_RETURNS = 64

/// Internal type Args: defined at src/core/core.isle line 328.
pub enum Args {
  Args2(~arg1 : @core.Value, ~arg2 : @core.Value)
  Args1(~arg1 : @core.Value)
  Args0
} derive(Eq, Show)

// Generated as internal constructor for term ty_unit.
pub fn constructor_ty_unit[C : Context](ctx : C) -> @core.Type {
  // Rule at src/core/core.isle line 52.
  return @core.Type::Unit
}

// Generated as internal constructor for term ty_bool.
pub fn constructor_ty_bool[C : Context](ctx : C) -> @core.Type {
  // Rule at src/core/core.isle line 56.
  return @core.Type::Bool
}

// Generated as internal constructor for term ty_int32.
pub fn constructor_ty_int32[C : Context](ctx : C) -> @core.Type {
  // Rule at src/core/core.isle line 60.
  return @core.Type::Int32
}

// Generated as internal constructor for term ty_int64.
pub fn constructor_ty_int64[C : Context](ctx : C) -> @core.Type {
  // Rule at src/core/core.isle line 64.
  return @core.Type::Int64
}

// Generated as internal constructor for term ty_double.
pub fn constructor_ty_double[C : Context](ctx : C) -> @core.Type {
  // Rule at src/core/core.isle line 68.
  return @core.Type::Double
}

// Generated as internal constructor for term ty_closure_fn.
pub fn constructor_ty_closure_fn[C : Context](
  ctx : C,
  arg0 : @core.Types,
  arg1 : @core.Type
) -> @core.Type {
  let v2 = @core.Type::ClosureFn(params=arg0, ty=arg1)
  // Rule at src/core/core.isle line 72.
  return v2
}

// Generated as internal constructor for term ty_direct_fn.
pub fn constructor_ty_direct_fn[C : Context](
  ctx : C,
  arg0 : @core.Types,
  arg1 : @core.Type
) -> @core.Type {
  let v2 = @core.Type::DirectFn(params=arg0, ty=arg1)
  // Rule at src/core/core.isle line 76.
  return v2
}

// Generated as internal constructor for term ty_tuple.
pub fn constructor_ty_tuple[C : Context](
  ctx : C,
  arg0 : @core.Types
) -> @core.Type {
  let v1 = @core.Type::Tuple(fields=arg0)
  // Rule at src/core/core.isle line 80.
  return v1
}

// Generated as internal constructor for term ty_array.
pub fn constructor_ty_array[C : Context](
  ctx : C,
  arg0 : @core.Type
) -> @core.Type {
  let v1 = @core.Type::Array(elem=arg0)
  // Rule at src/core/core.isle line 84.
  return v1
}

// Generated as internal constructor for term round_rne.
pub fn constructor_round_rne[C : Context](ctx : C) -> @core.RoundMode {
  // Rule at src/core/core.isle line 147.
  return @core.RoundMode::Rne
}

// Generated as internal constructor for term round_rtz.
pub fn constructor_round_rtz[C : Context](ctx : C) -> @core.RoundMode {
  // Rule at src/core/core.isle line 151.
  return @core.RoundMode::Rtz
}

// Generated as internal constructor for term round_rdn.
pub fn constructor_round_rdn[C : Context](ctx : C) -> @core.RoundMode {
  // Rule at src/core/core.isle line 155.
  return @core.RoundMode::Rdn
}

// Generated as internal constructor for term round_rup.
pub fn constructor_round_rup[C : Context](ctx : C) -> @core.RoundMode {
  // Rule at src/core/core.isle line 159.
  return @core.RoundMode::Rup
}

// Generated as internal constructor for term arg2.
pub fn constructor_arg2[C : Context](
  ctx : C,
  arg0 : @core.Value,
  arg1 : @core.Value
) -> Args {
  let v2 = Args::Args2(arg1=arg0, arg2=arg1)
  // Rule at src/core/core.isle line 335.
  return v2
}

// Generated as internal constructor for term arg1.
pub fn constructor_arg1[C : Context](ctx : C, arg0 : @core.Value) -> Args {
  let v1 = Args::Args1(arg1=arg0)
  // Rule at src/core/core.isle line 339.
  return v1
}

// Generated as internal constructor for term arg0.
pub fn constructor_arg0[C : Context](ctx : C) -> Args {
  // Rule at src/core/core.isle line 343.
  return Args::Args0
}

// Generated as internal constructor for term rv_add.
pub fn constructor_rv_add[C : Context](
  ctx : C,
  arg0 : @riscv.Reg,
  arg1 : @riscv.Reg
) -> @riscv.Reg {
  let v2 = C::next_virtual_xreg(ctx)
  let v3 = @riscv.RvAsm::Add(rd=v2, rs1=arg0, rs2=arg1)
  let v4 = C::emit_risc_v(ctx, v3)
  // Rule at src/riscv/riscv.isle line 119.
  return v2
}

// Generated as internal constructor for term rv_sub.
pub fn constructor_rv_sub[C : Context](
  ctx : C,
  arg0 : @riscv.Reg,
  arg1 : @riscv.Reg
) -> @riscv.Reg {
  let v2 = C::next_virtual_xreg(ctx)
  let v3 = @riscv.RvAsm::Sub(rd=v2, rs1=arg0, rs2=arg1)
  let v4 = C::emit_risc_v(ctx, v3)
  // Rule at src/riscv/riscv.isle line 125.
  return v2
}

// Generated as internal constructor for term rv_xor.
pub fn constructor_rv_xor[C : Context](
  ctx : C,
  arg0 : @riscv.Reg,
  arg1 : @riscv.Reg
) -> @riscv.Reg {
  let v2 = C::next_virtual_xreg(ctx)
  let v3 = @riscv.RvAsm::Xor(rd=v2, rs1=arg0, rs2=arg1)
  let v4 = C::emit_risc_v(ctx, v3)
  // Rule at src/riscv/riscv.isle line 131.
  return v2
}

// Generated as internal constructor for term rv_or.
pub fn constructor_rv_or[C : Context](
  ctx : C,
  arg0 : @riscv.Reg,
  arg1 : @riscv.Reg
) -> @riscv.Reg {
  let v2 = C::next_virtual_xreg(ctx)
  let v3 = @riscv.RvAsm::Or(rd=v2, rs1=arg0, rs2=arg1)
  let v4 = C::emit_risc_v(ctx, v3)
  // Rule at src/riscv/riscv.isle line 137.
  return v2
}

// Generated as internal constructor for term rv_and.
pub fn constructor_rv_and[C : Context](
  ctx : C,
  arg0 : @riscv.Reg,
  arg1 : @riscv.Reg
) -> @riscv.Reg {
  let v2 = C::next_virtual_xreg(ctx)
  let v3 = @riscv.RvAsm::And(rd=v2, rs1=arg0, rs2=arg1)
  let v4 = C::emit_risc_v(ctx, v3)
  // Rule at src/riscv/riscv.isle line 143.
  return v2
}

// Generated as internal constructor for term rv_sll.
pub fn constructor_rv_sll[C : Context](
  ctx : C,
  arg0 : @riscv.Reg,
  arg1 : @riscv.Reg
) -> @riscv.Reg {
  let v2 = C::next_virtual_xreg(ctx)
  let v3 = @riscv.RvAsm::Sll(rd=v2, rs1=arg0, rs2=arg1)
  let v4 = C::emit_risc_v(ctx, v3)
  // Rule at src/riscv/riscv.isle line 149.
  return v2
}

// Generated as internal constructor for term rv_srl.
pub fn constructor_rv_srl[C : Context](
  ctx : C,
  arg0 : @riscv.Reg,
  arg1 : @riscv.Reg
) -> @riscv.Reg {
  let v2 = C::next_virtual_xreg(ctx)
  let v3 = @riscv.RvAsm::Srl(rd=v2, rs1=arg0, rs2=arg1)
  let v4 = C::emit_risc_v(ctx, v3)
  // Rule at src/riscv/riscv.isle line 155.
  return v2
}

// Generated as internal constructor for term rv_sra.
pub fn constructor_rv_sra[C : Context](
  ctx : C,
  arg0 : @riscv.Reg,
  arg1 : @riscv.Reg
) -> @riscv.Reg {
  let v2 = C::next_virtual_xreg(ctx)
  let v3 = @riscv.RvAsm::Sra(rd=v2, rs1=arg0, rs2=arg1)
  let v4 = C::emit_risc_v(ctx, v3)
  // Rule at src/riscv/riscv.isle line 161.
  return v2
}

// Generated as internal constructor for term rv_slt.
pub fn constructor_rv_slt[C : Context](
  ctx : C,
  arg0 : @riscv.Reg,
  arg1 : @riscv.Reg
) -> @riscv.Reg {
  let v2 = C::next_virtual_xreg(ctx)
  let v3 = @riscv.RvAsm::Slt(rd=v2, rs1=arg0, rs2=arg1)
  let v4 = C::emit_risc_v(ctx, v3)
  // Rule at src/riscv/riscv.isle line 167.
  return v2
}

// Generated as internal constructor for term rv_sltu.
pub fn constructor_rv_sltu[C : Context](
  ctx : C,
  arg0 : @riscv.Reg,
  arg1 : @riscv.Reg
) -> @riscv.Reg {
  let v2 = C::next_virtual_xreg(ctx)
  let v3 = @riscv.RvAsm::Sltu(rd=v2, rs1=arg0, rs2=arg1)
  let v4 = C::emit_risc_v(ctx, v3)
  // Rule at src/riscv/riscv.isle line 173.
  return v2
}

// Generated as internal constructor for term rv_addi.
pub fn constructor_rv_addi[C : Context](
  ctx : C,
  arg0 : @riscv.Reg,
  arg1 : Int
) -> @riscv.Reg {
  let v2 = C::next_virtual_xreg(ctx)
  let v3 = @riscv.RvAsm::Addi(rd=v2, rs1=arg0, imm=arg1)
  let v4 = C::emit_risc_v(ctx, v3)
  // Rule at src/riscv/riscv.isle line 179.
  return v2
}

// Generated as internal constructor for term rv_xori.
pub fn constructor_rv_xori[C : Context](
  ctx : C,
  arg0 : @riscv.Reg,
  arg1 : Int
) -> @riscv.Reg {
  let v2 = C::next_virtual_xreg(ctx)
  let v3 = @riscv.RvAsm::Xori(rd=v2, rs1=arg0, imm=arg1)
  let v4 = C::emit_risc_v(ctx, v3)
  // Rule at src/riscv/riscv.isle line 185.
  return v2
}

// Generated as internal constructor for term rv_ori.
pub fn constructor_rv_ori[C : Context](
  ctx : C,
  arg0 : @riscv.Reg,
  arg1 : Int
) -> @riscv.Reg {
  let v2 = C::next_virtual_xreg(ctx)
  let v3 = @riscv.RvAsm::Ori(rd=v2, rs1=arg0, imm=arg1)
  let v4 = C::emit_risc_v(ctx, v3)
  // Rule at src/riscv/riscv.isle line 191.
  return v2
}

// Generated as internal constructor for term rv_andi.
pub fn constructor_rv_andi[C : Context](
  ctx : C,
  arg0 : @riscv.Reg,
  arg1 : Int
) -> @riscv.Reg {
  let v2 = C::next_virtual_xreg(ctx)
  let v3 = @riscv.RvAsm::Andi(rd=v2, rs1=arg0, imm=arg1)
  let v4 = C::emit_risc_v(ctx, v3)
  // Rule at src/riscv/riscv.isle line 197.
  return v2
}

// Generated as internal constructor for term rv_slli.
pub fn constructor_rv_slli[C : Context](
  ctx : C,
  arg0 : @riscv.Reg,
  arg1 : Int
) -> @riscv.Reg {
  let v2 = C::next_virtual_xreg(ctx)
  let v3 = @riscv.RvAsm::Slli(rd=v2, rs1=arg0, imm=arg1)
  let v4 = C::emit_risc_v(ctx, v3)
  // Rule at src/riscv/riscv.isle line 203.
  return v2
}

// Generated as internal constructor for term rv_srli.
pub fn constructor_rv_srli[C : Context](
  ctx : C,
  arg0 : @riscv.Reg,
  arg1 : Int
) -> @riscv.Reg {
  let v2 = C::next_virtual_xreg(ctx)
  let v3 = @riscv.RvAsm::Srli(rd=v2, rs1=arg0, imm=arg1)
  let v4 = C::emit_risc_v(ctx, v3)
  // Rule at src/riscv/riscv.isle line 209.
  return v2
}

// Generated as internal constructor for term rv_srai.
pub fn constructor_rv_srai[C : Context](
  ctx : C,
  arg0 : @riscv.Reg,
  arg1 : Int
) -> @riscv.Reg {
  let v2 = C::next_virtual_xreg(ctx)
  let v3 = @riscv.RvAsm::Srai(rd=v2, rs1=arg0, imm=arg1)
  let v4 = C::emit_risc_v(ctx, v3)
  // Rule at src/riscv/riscv.isle line 215.
  return v2
}

// Generated as internal constructor for term rv_slti.
pub fn constructor_rv_slti[C : Context](
  ctx : C,
  arg0 : @riscv.Reg,
  arg1 : Int
) -> @riscv.Reg {
  let v2 = C::next_virtual_xreg(ctx)
  let v3 = @riscv.RvAsm::Slti(rd=v2, rs1=arg0, imm=arg1)
  let v4 = C::emit_risc_v(ctx, v3)
  // Rule at src/riscv/riscv.isle line 221.
  return v2
}

// Generated as internal constructor for term rv_sltiu.
pub fn constructor_rv_sltiu[C : Context](
  ctx : C,
  arg0 : @riscv.Reg,
  arg1 : Int
) -> @riscv.Reg {
  let v2 = C::next_virtual_xreg(ctx)
  let v3 = @riscv.RvAsm::Sltiu(rd=v2, rs1=arg0, imm=arg1)
  let v4 = C::emit_risc_v(ctx, v3)
  // Rule at src/riscv/riscv.isle line 227.
  return v2
}

// Generated as internal constructor for term rv_lb.
pub fn constructor_rv_lb[C : Context](
  ctx : C,
  arg0 : @riscv.MemAccess[@riscv.Reg, @riscv.Imm12]
) -> @riscv.Reg {
  let v1 = C::next_virtual_xreg(ctx)
  let v2 = @riscv.RvAsm::Lb(rd=v1, mem=arg0)
  let v3 = C::emit_risc_v(ctx, v2)
  // Rule at src/riscv/riscv.isle line 233.
  return v1
}

// Generated as internal constructor for term rv_lh.
pub fn constructor_rv_lh[C : Context](
  ctx : C,
  arg0 : @riscv.MemAccess[@riscv.Reg, @riscv.Imm12]
) -> @riscv.Reg {
  let v1 = C::next_virtual_xreg(ctx)
  let v2 = @riscv.RvAsm::Lh(rd=v1, mem=arg0)
  let v3 = C::emit_risc_v(ctx, v2)
  // Rule at src/riscv/riscv.isle line 239.
  return v1
}

// Generated as internal constructor for term rv_lw.
pub fn constructor_rv_lw[C : Context](
  ctx : C,
  arg0 : @riscv.MemAccess[@riscv.Reg, @riscv.Imm12]
) -> @riscv.Reg {
  let v1 = C::next_virtual_xreg(ctx)
  let v2 = @riscv.RvAsm::Lw(rd=v1, mem=arg0)
  let v3 = C::emit_risc_v(ctx, v2)
  // Rule at src/riscv/riscv.isle line 245.
  return v1
}

// Generated as internal constructor for term rv_ld.
pub fn constructor_rv_ld[C : Context](
  ctx : C,
  arg0 : @riscv.MemAccess[@riscv.Reg, @riscv.Imm12]
) -> @riscv.Reg {
  let v1 = C::next_virtual_xreg(ctx)
  let v2 = @riscv.RvAsm::Ld(rd=v1, mem=arg0)
  let v3 = C::emit_risc_v(ctx, v2)
  // Rule at src/riscv/riscv.isle line 251.
  return v1
}

// Generated as internal constructor for term rv_lbu.
pub fn constructor_rv_lbu[C : Context](
  ctx : C,
  arg0 : @riscv.MemAccess[@riscv.Reg, @riscv.Imm12]
) -> @riscv.Reg {
  let v1 = C::next_virtual_xreg(ctx)
  let v2 = @riscv.RvAsm::Lbu(rd=v1, mem=arg0)
  let v3 = C::emit_risc_v(ctx, v2)
  // Rule at src/riscv/riscv.isle line 257.
  return v1
}

// Generated as internal constructor for term rv_lhu.
pub fn constructor_rv_lhu[C : Context](
  ctx : C,
  arg0 : @riscv.MemAccess[@riscv.Reg, @riscv.Imm12]
) -> @riscv.Reg {
  let v1 = C::next_virtual_xreg(ctx)
  let v2 = @riscv.RvAsm::Lhu(rd=v1, mem=arg0)
  let v3 = C::emit_risc_v(ctx, v2)
  // Rule at src/riscv/riscv.isle line 263.
  return v1
}

// Generated as internal constructor for term rv_lwu.
pub fn constructor_rv_lwu[C : Context](
  ctx : C,
  arg0 : @riscv.MemAccess[@riscv.Reg, @riscv.Imm12]
) -> @riscv.Reg {
  let v1 = C::next_virtual_xreg(ctx)
  let v2 = @riscv.RvAsm::Lwu(rd=v1, mem=arg0)
  let v3 = C::emit_risc_v(ctx, v2)
  // Rule at src/riscv/riscv.isle line 269.
  return v1
}

// Generated as internal constructor for term rv_sb.
pub fn constructor_rv_sb[C : Context](
  ctx : C,
  arg0 : @riscv.Reg,
  arg1 : @riscv.MemAccess[@riscv.Reg, @riscv.Imm12]
) -> Unit {
  let v2 = @riscv.RvAsm::Sb(rs=arg0, mem=arg1)
  let v3 = C::emit_risc_v(ctx, v2)
  // Rule at src/riscv/riscv.isle line 275.
  return v3
}

// Generated as internal constructor for term rv_sh.
pub fn constructor_rv_sh[C : Context](
  ctx : C,
  arg0 : @riscv.Reg,
  arg1 : @riscv.MemAccess[@riscv.Reg, @riscv.Imm12]
) -> Unit {
  let v2 = @riscv.RvAsm::Sh(rs=arg0, mem=arg1)
  let v3 = C::emit_risc_v(ctx, v2)
  // Rule at src/riscv/riscv.isle line 278.
  return v3
}

// Generated as internal constructor for term rv_sw.
pub fn constructor_rv_sw[C : Context](
  ctx : C,
  arg0 : @riscv.Reg,
  arg1 : @riscv.MemAccess[@riscv.Reg, @riscv.Imm12]
) -> Unit {
  let v2 = @riscv.RvAsm::Sw(rs=arg0, mem=arg1)
  let v3 = C::emit_risc_v(ctx, v2)
  // Rule at src/riscv/riscv.isle line 281.
  return v3
}

// Generated as internal constructor for term rv_sd.
pub fn constructor_rv_sd[C : Context](
  ctx : C,
  arg0 : @riscv.Reg,
  arg1 : @riscv.MemAccess[@riscv.Reg, @riscv.Imm12]
) -> Unit {
  let v2 = @riscv.RvAsm::Sd(rs=arg0, mem=arg1)
  let v3 = C::emit_risc_v(ctx, v2)
  // Rule at src/riscv/riscv.isle line 284.
  return v3
}

// Generated as internal constructor for term rv_beq.
pub fn constructor_rv_beq[C : Context](
  ctx : C,
  arg0 : @riscv.Reg,
  arg1 : @riscv.Reg,
  arg2 : @riscv.Label
) -> Unit {
  let v3 = @riscv.RvAsm::Beq(rs1=arg0, rs2=arg1, target=arg2)
  let v4 = C::emit_risc_v(ctx, v3)
  // Rule at src/riscv/riscv.isle line 287.
  return v4
}

// Generated as internal constructor for term rv_bne.
pub fn constructor_rv_bne[C : Context](
  ctx : C,
  arg0 : @riscv.Reg,
  arg1 : @riscv.Reg,
  arg2 : @riscv.Label
) -> Unit {
  let v3 = @riscv.RvAsm::Bne(rs1=arg0, rs2=arg1, target=arg2)
  let v4 = C::emit_risc_v(ctx, v3)
  // Rule at src/riscv/riscv.isle line 290.
  return v4
}

// Generated as internal constructor for term rv_blt.
pub fn constructor_rv_blt[C : Context](
  ctx : C,
  arg0 : @riscv.Reg,
  arg1 : @riscv.Reg,
  arg2 : @riscv.Label
) -> Unit {
  let v3 = @riscv.RvAsm::Blt(rs1=arg0, rs2=arg1, target=arg2)
  let v4 = C::emit_risc_v(ctx, v3)
  // Rule at src/riscv/riscv.isle line 293.
  return v4
}

// Generated as internal constructor for term rv_bge.
pub fn constructor_rv_bge[C : Context](
  ctx : C,
  arg0 : @riscv.Reg,
  arg1 : @riscv.Reg,
  arg2 : @riscv.Label
) -> Unit {
  let v3 = @riscv.RvAsm::Bge(rs1=arg0, rs2=arg1, target=arg2)
  let v4 = C::emit_risc_v(ctx, v3)
  // Rule at src/riscv/riscv.isle line 296.
  return v4
}

// Generated as internal constructor for term rv_ble.
pub fn constructor_rv_ble[C : Context](
  ctx : C,
  arg0 : @riscv.Reg,
  arg1 : @riscv.Reg,
  arg2 : @riscv.Label
) -> Unit {
  let v3 = @riscv.RvAsm::Ble(rs1=arg0, rs2=arg1, target=arg2)
  let v4 = C::emit_risc_v(ctx, v3)
  // Rule at src/riscv/riscv.isle line 299.
  return v4
}

// Generated as internal constructor for term rv_bgt.
pub fn constructor_rv_bgt[C : Context](
  ctx : C,
  arg0 : @riscv.Reg,
  arg1 : @riscv.Reg,
  arg2 : @riscv.Label
) -> Unit {
  let v3 = @riscv.RvAsm::Bgt(rs1=arg0, rs2=arg1, target=arg2)
  let v4 = C::emit_risc_v(ctx, v3)
  // Rule at src/riscv/riscv.isle line 302.
  return v4
}

// Generated as internal constructor for term rv_bltu.
pub fn constructor_rv_bltu[C : Context](
  ctx : C,
  arg0 : @riscv.Reg,
  arg1 : @riscv.Reg,
  arg2 : @riscv.Label
) -> Unit {
  let v3 = @riscv.RvAsm::Bltu(rs1=arg0, rs2=arg1, target=arg2)
  let v4 = C::emit_risc_v(ctx, v3)
  // Rule at src/riscv/riscv.isle line 305.
  return v4
}

// Generated as internal constructor for term rv_bgeu.
pub fn constructor_rv_bgeu[C : Context](
  ctx : C,
  arg0 : @riscv.Reg,
  arg1 : @riscv.Reg,
  arg2 : @riscv.Label
) -> Unit {
  let v3 = @riscv.RvAsm::Bgeu(rs1=arg0, rs2=arg1, target=arg2)
  let v4 = C::emit_risc_v(ctx, v3)
  // Rule at src/riscv/riscv.isle line 308.
  return v4
}

// Generated as internal constructor for term rv_bnez.
pub fn constructor_rv_bnez[C : Context](
  ctx : C,
  arg0 : @riscv.Reg,
  arg1 : @riscv.Label
) -> Unit {
  let v2 = C::zero_reg(ctx)
  let v3 = @riscv.RvAsm::Bne(rs1=arg0, rs2=v2, target=arg1)
  let v4 = C::emit_risc_v(ctx, v3)
  // Rule at src/riscv/riscv.isle line 311.
  return v4
}

// Generated as internal constructor for term rv_beqz.
pub fn constructor_rv_beqz[C : Context](
  ctx : C,
  arg0 : @riscv.Reg,
  arg1 : @riscv.Label
) -> Unit {
  let v2 = C::zero_reg(ctx)
  let v3 = @riscv.RvAsm::Beq(rs1=arg0, rs2=v2, target=arg1)
  let v4 = C::emit_risc_v(ctx, v3)
  // Rule at src/riscv/riscv.isle line 314.
  return v4
}

// Generated as internal constructor for term rv_mul.
pub fn constructor_rv_mul[C : Context](
  ctx : C,
  arg0 : @riscv.Reg,
  arg1 : @riscv.Reg
) -> @riscv.Reg {
  let v2 = C::next_virtual_xreg(ctx)
  let v3 = @riscv.RvAsm::Mul(rd=v2, rs1=arg0, rs2=arg1)
  let v4 = C::emit_risc_v(ctx, v3)
  // Rule at src/riscv/riscv.isle line 317.
  return v2
}

// Generated as internal constructor for term rv_mulw.
pub fn constructor_rv_mulw[C : Context](
  ctx : C,
  arg0 : @riscv.Reg,
  arg1 : @riscv.Reg
) -> @riscv.Reg {
  let v2 = C::next_virtual_xreg(ctx)
  let v3 = @riscv.RvAsm::Mulw(rd=v2, rs1=arg0, rs2=arg1)
  let v4 = C::emit_risc_v(ctx, v3)
  // Rule at src/riscv/riscv.isle line 323.
  return v2
}

// Generated as internal constructor for term rv_mulh.
pub fn constructor_rv_mulh[C : Context](
  ctx : C,
  arg0 : @riscv.Reg,
  arg1 : @riscv.Reg
) -> @riscv.Reg {
  let v2 = C::next_virtual_xreg(ctx)
  let v3 = @riscv.RvAsm::Mulh(rd=v2, rs1=arg0, rs2=arg1)
  let v4 = C::emit_risc_v(ctx, v3)
  // Rule at src/riscv/riscv.isle line 329.
  return v2
}

// Generated as internal constructor for term rv_mulhsu.
pub fn constructor_rv_mulhsu[C : Context](
  ctx : C,
  arg0 : @riscv.Reg,
  arg1 : @riscv.Reg
) -> @riscv.Reg {
  let v2 = C::next_virtual_xreg(ctx)
  let v3 = @riscv.RvAsm::Mulhsu(rd=v2, rs1=arg0, rs2=arg1)
  let v4 = C::emit_risc_v(ctx, v3)
  // Rule at src/riscv/riscv.isle line 335.
  return v2
}

// Generated as internal constructor for term rv_mulhu.
pub fn constructor_rv_mulhu[C : Context](
  ctx : C,
  arg0 : @riscv.Reg,
  arg1 : @riscv.Reg
) -> @riscv.Reg {
  let v2 = C::next_virtual_xreg(ctx)
  let v3 = @riscv.RvAsm::Mulhu(rd=v2, rs1=arg0, rs2=arg1)
  let v4 = C::emit_risc_v(ctx, v3)
  // Rule at src/riscv/riscv.isle line 341.
  return v2
}

// Generated as internal constructor for term rv_div.
pub fn constructor_rv_div[C : Context](
  ctx : C,
  arg0 : @riscv.Reg,
  arg1 : @riscv.Reg
) -> @riscv.Reg {
  let v2 = C::next_virtual_xreg(ctx)
  let v3 = @riscv.RvAsm::Div(rd=v2, rs1=arg0, rs2=arg1)
  let v4 = C::emit_risc_v(ctx, v3)
  // Rule at src/riscv/riscv.isle line 347.
  return v2
}

// Generated as internal constructor for term rv_divw.
pub fn constructor_rv_divw[C : Context](
  ctx : C,
  arg0 : @riscv.Reg,
  arg1 : @riscv.Reg
) -> @riscv.Reg {
  let v2 = C::next_virtual_xreg(ctx)
  let v3 = @riscv.RvAsm::Divw(rd=v2, rs1=arg0, rs2=arg1)
  let v4 = C::emit_risc_v(ctx, v3)
  // Rule at src/riscv/riscv.isle line 353.
  return v2
}

// Generated as internal constructor for term rv_divu.
pub fn constructor_rv_divu[C : Context](
  ctx : C,
  arg0 : @riscv.Reg,
  arg1 : @riscv.Reg
) -> @riscv.Reg {
  let v2 = C::next_virtual_xreg(ctx)
  let v3 = @riscv.RvAsm::Divu(rd=v2, rs1=arg0, rs2=arg1)
  let v4 = C::emit_risc_v(ctx, v3)
  // Rule at src/riscv/riscv.isle line 359.
  return v2
}

// Generated as internal constructor for term rv_rem.
pub fn constructor_rv_rem[C : Context](
  ctx : C,
  arg0 : @riscv.Reg,
  arg1 : @riscv.Reg
) -> @riscv.Reg {
  let v2 = C::next_virtual_xreg(ctx)
  let v3 = @riscv.RvAsm::Rem(rd=v2, rs1=arg0, rs2=arg1)
  let v4 = C::emit_risc_v(ctx, v3)
  // Rule at src/riscv/riscv.isle line 365.
  return v2
}

// Generated as internal constructor for term rv_remw.
pub fn constructor_rv_remw[C : Context](
  ctx : C,
  arg0 : @riscv.Reg,
  arg1 : @riscv.Reg
) -> @riscv.Reg {
  let v2 = C::next_virtual_xreg(ctx)
  let v3 = @riscv.RvAsm::Remw(rd=v2, rs1=arg0, rs2=arg1)
  let v4 = C::emit_risc_v(ctx, v3)
  // Rule at src/riscv/riscv.isle line 371.
  return v2
}

// Generated as internal constructor for term rv_remu.
pub fn constructor_rv_remu[C : Context](
  ctx : C,
  arg0 : @riscv.Reg,
  arg1 : @riscv.Reg
) -> @riscv.Reg {
  let v2 = C::next_virtual_xreg(ctx)
  let v3 = @riscv.RvAsm::Remu(rd=v2, rs1=arg0, rs2=arg1)
  let v4 = C::emit_risc_v(ctx, v3)
  // Rule at src/riscv/riscv.isle line 377.
  return v2
}

// Generated as internal constructor for term rv_fadd_d.
pub fn constructor_rv_fadd_d[C : Context](
  ctx : C,
  arg0 : @riscv.FReg,
  arg1 : @riscv.FReg
) -> @riscv.FReg {
  let v2 = C::next_virtual_freg(ctx)
  let v3 = @riscv.RvAsm::FaddD(rd=v2, rs1=arg0, rs2=arg1)
  let v4 = C::emit_risc_v(ctx, v3)
  // Rule at src/riscv/riscv.isle line 383.
  return v2
}

// Generated as internal constructor for term rv_fsub_d.
pub fn constructor_rv_fsub_d[C : Context](
  ctx : C,
  arg0 : @riscv.FReg,
  arg1 : @riscv.FReg
) -> @riscv.FReg {
  let v2 = C::next_virtual_freg(ctx)
  let v3 = @riscv.RvAsm::FsubD(rd=v2, rs1=arg0, rs2=arg1)
  let v4 = C::emit_risc_v(ctx, v3)
  // Rule at src/riscv/riscv.isle line 389.
  return v2
}

// Generated as internal constructor for term rv_fmul_d.
pub fn constructor_rv_fmul_d[C : Context](
  ctx : C,
  arg0 : @riscv.FReg,
  arg1 : @riscv.FReg
) -> @riscv.FReg {
  let v2 = C::next_virtual_freg(ctx)
  let v3 = @riscv.RvAsm::FmulD(rd=v2, rs1=arg0, rs2=arg1)
  let v4 = C::emit_risc_v(ctx, v3)
  // Rule at src/riscv/riscv.isle line 395.
  return v2
}

// Generated as internal constructor for term rv_fdiv_d.
pub fn constructor_rv_fdiv_d[C : Context](
  ctx : C,
  arg0 : @riscv.FReg,
  arg1 : @riscv.FReg
) -> @riscv.FReg {
  let v2 = C::next_virtual_freg(ctx)
  let v3 = @riscv.RvAsm::FdivD(rd=v2, rs1=arg0, rs2=arg1)
  let v4 = C::emit_risc_v(ctx, v3)
  // Rule at src/riscv/riscv.isle line 401.
  return v2
}

// Generated as internal constructor for term rv_fld.
pub fn constructor_rv_fld[C : Context](
  ctx : C,
  arg0 : @riscv.MemAccess[@riscv.Reg, @riscv.Imm12]
) -> @riscv.FReg {
  let v1 = C::next_virtual_freg(ctx)
  let v2 = @riscv.RvAsm::Fld(rd=v1, mem=arg0)
  let v3 = C::emit_risc_v(ctx, v2)
  // Rule at src/riscv/riscv.isle line 407.
  return v1
}

// Generated as internal constructor for term rv_fsd.
pub fn constructor_rv_fsd[C : Context](
  ctx : C,
  arg0 : @riscv.FReg,
  arg1 : @riscv.MemAccess[@riscv.Reg, @riscv.Imm12]
) -> Unit {
  let v2 = @riscv.RvAsm::Fsd(rs=arg0, mem=arg1)
  let v3 = C::emit_risc_v(ctx, v2)
  // Rule at src/riscv/riscv.isle line 413.
  return v3
}

// Generated as internal constructor for term rv_fmv_dx.
pub fn constructor_rv_fmv_dx[C : Context](
  ctx : C,
  arg0 : @riscv.Reg
) -> @riscv.FReg {
  let v1 = C::next_virtual_freg(ctx)
  let v2 = @riscv.RvAsm::FmvDX(rd=v1, rs=arg0)
  let v3 = C::emit_risc_v(ctx, v2)
  // Rule at src/riscv/riscv.isle line 416.
  return v1
}

// Generated as internal constructor for term rv_fcvt_w_d.
pub fn constructor_rv_fcvt_w_d[C : Context](
  ctx : C,
  arg0 : @riscv.FReg,
  arg1 : @core.RoundMode
) -> @riscv.Reg {
  let v2 = C::next_virtual_xreg(ctx)
  let v3 = @riscv.RvAsm::FcvtWD(rd=v2, rs=arg0, rm=arg1)
  let v4 = C::emit_risc_v(ctx, v3)
  // Rule at src/riscv/riscv.isle line 422.
  return v2
}

// Generated as internal constructor for term rv_fcvt_d_w.
pub fn constructor_rv_fcvt_d_w[C : Context](
  ctx : C,
  arg0 : @riscv.Reg
) -> @riscv.FReg {
  let v1 = C::next_virtual_freg(ctx)
  let v2 = @riscv.RvAsm::FcvtDW(rd=v1, rs=arg0)
  let v3 = C::emit_risc_v(ctx, v2)
  // Rule at src/riscv/riscv.isle line 428.
  return v1
}

// Generated as internal constructor for term rv_fabs_d.
pub fn constructor_rv_fabs_d[C : Context](
  ctx : C,
  arg0 : @riscv.FReg
) -> @riscv.FReg {
  let v1 = C::next_virtual_freg(ctx)
  let v2 = @riscv.RvAsm::FabsD(rd=v1, rs=arg0)
  let v3 = C::emit_risc_v(ctx, v2)
  // Rule at src/riscv/riscv.isle line 434.
  return v1
}

// Generated as internal constructor for term rv_fsqrt_d.
pub fn constructor_rv_fsqrt_d[C : Context](
  ctx : C,
  arg0 : @riscv.FReg
) -> @riscv.FReg {
  let v1 = C::next_virtual_freg(ctx)
  let v2 = @riscv.RvAsm::FsqrtD(rd=v1, rs=arg0)
  let v3 = C::emit_risc_v(ctx, v2)
  // Rule at src/riscv/riscv.isle line 440.
  return v1
}

// Generated as internal constructor for term rv_la.
pub fn constructor_rv_la[C : Context](
  ctx : C,
  arg0 : @riscv.Label
) -> @riscv.Reg {
  let v1 = C::next_virtual_xreg(ctx)
  let v2 = @riscv.RvAsm::La(rd=v1, l=arg0)
  let v3 = C::emit_risc_v(ctx, v2)
  // Rule at src/riscv/riscv.isle line 446.
  return v1
}

// Generated as internal constructor for term rv_li.
pub fn constructor_rv_li[C : Context](ctx : C, arg0 : String) -> @riscv.Reg {
  let v1 = C::next_virtual_xreg(ctx)
  let v2 = @riscv.RvAsm::Li(rd=v1, i=arg0)
  let v3 = C::emit_risc_v(ctx, v2)
  // Rule at src/riscv/riscv.isle line 452.
  return v1
}

// Generated as internal constructor for term rv_neg.
pub fn constructor_rv_neg[C : Context](
  ctx : C,
  arg0 : @riscv.Reg
) -> @riscv.Reg {
  let v1 = C::next_virtual_xreg(ctx)
  let v2 = @riscv.RvAsm::Neg(rd=v1, rs=arg0)
  let v3 = C::emit_risc_v(ctx, v2)
  // Rule at src/riscv/riscv.isle line 458.
  return v1
}

// Generated as internal constructor for term rv_fneg_d.
pub fn constructor_rv_fneg_d[C : Context](
  ctx : C,
  arg0 : @riscv.FReg
) -> @riscv.FReg {
  let v1 = C::next_virtual_freg(ctx)
  let v2 = @riscv.RvAsm::FnegD(rd=v1, rs=arg0)
  let v3 = C::emit_risc_v(ctx, v2)
  // Rule at src/riscv/riscv.isle line 464.
  return v1
}

// Generated as internal constructor for term rv_mv.
pub fn constructor_rv_mv[C : Context](ctx : C, arg0 : @riscv.Reg) -> @riscv.Reg {
  let v1 = C::next_virtual_xreg(ctx)
  let v2 = @riscv.RvAsm::Mv(rd=v1, rs=arg0)
  let v3 = C::emit_risc_v(ctx, v2)
  // Rule at src/riscv/riscv.isle line 470.
  return v1
}

// Generated as internal constructor for term rv_fmv_d.
pub fn constructor_rv_fmv_d[C : Context](
  ctx : C,
  arg0 : @riscv.FReg
) -> @riscv.FReg {
  let v1 = C::next_virtual_freg(ctx)
  let v2 = @riscv.RvAsm::FmvD(rd=v1, rs=arg0)
  let v3 = C::emit_risc_v(ctx, v2)
  // Rule at src/riscv/riscv.isle line 476.
  return v1
}

// Generated as internal constructor for term rv_mv_to.
pub fn constructor_rv_mv_to[C : Context](
  ctx : C,
  arg0 : @riscv.Reg,
  arg1 : @riscv.Reg
) -> Unit {
  let v2 = @riscv.RvAsm::Mv(rd=arg0, rs=arg1)
  let v3 = C::emit_risc_v(ctx, v2)
  // Rule at src/riscv/riscv.isle line 482.
  return v3
}

// Generated as internal constructor for term rv_fmv_to.
pub fn constructor_rv_fmv_to[C : Context](
  ctx : C,
  arg0 : @riscv.FReg,
  arg1 : @riscv.FReg
) -> Unit {
  let v2 = @riscv.RvAsm::FmvD(rd=arg0, rs=arg1)
  let v3 = C::emit_risc_v(ctx, v2)
  // Rule at src/riscv/riscv.isle line 485.
  return v3
}

// Generated as internal constructor for term rv_j.
pub fn constructor_rv_j[C : Context](ctx : C, arg0 : @riscv.Label) -> Unit {
  let v1 = @riscv.RvAsm::J(target=arg0)
  let v2 = C::emit_risc_v(ctx, v1)
  // Rule at src/riscv/riscv.isle line 488.
  return v2
}

// Generated as internal constructor for term rv_jalr.
pub fn constructor_rv_jalr[C : Context](
  ctx : C,
  arg0 : @riscv.Reg,
  arg1 : Int,
  arg2 : Int
) -> Unit {
  let v3 = @riscv.RvAsm::Jalr(target=arg0, num_xregs=arg1, num_fregs=arg2)
  let v4 = C::emit_risc_v(ctx, v3)
  // Rule at src/riscv/riscv.isle line 491.
  return v4
}

// Generated as internal constructor for term rv_jr.
pub fn constructor_rv_jr[C : Context](ctx : C, arg0 : @riscv.Reg) -> Unit {
  let v1 = @riscv.RvAsm::Jr(target=arg0)
  let v2 = C::emit_risc_v(ctx, v1)
  // Rule at src/riscv/riscv.isle line 494.
  return v2
}

// Generated as internal constructor for term rv_call.
pub fn constructor_rv_call[C : Context](
  ctx : C,
  arg0 : @riscv.Label,
  arg1 : Int,
  arg2 : Int
) -> Unit {
  let v3 = @riscv.RvAsm::Call(target=arg0, num_xregs=arg1, num_fregs=arg2)
  let v4 = C::emit_risc_v(ctx, v3)
  // Rule at src/riscv/riscv.isle line 497.
  return v4
}

// Generated as internal constructor for term rv_xret.
pub fn constructor_rv_xret[C : Context](ctx : C) -> Unit {
  let v1 = C::emit_risc_v(ctx, @riscv.RvAsm::XRet)
  // Rule at src/riscv/riscv.isle line 500.
  return v1
}

// Generated as internal constructor for term rv_fret.
pub fn constructor_rv_fret[C : Context](ctx : C) -> Unit {
  let v1 = C::emit_risc_v(ctx, @riscv.RvAsm::FRet)
  // Rule at src/riscv/riscv.isle line 503.
  return v1
}

// Generated as internal constructor for term rv_save_ctx1.
pub fn constructor_rv_save_ctx1[C : Context](ctx : C) -> Unit {
  let v1 = C::emit_risc_v(ctx, @riscv.RvAsm::SaveCtx1)
  // Rule at src/riscv/riscv.isle line 506.
  return v1
}

// Generated as internal constructor for term rv_restore_ctx1.
pub fn constructor_rv_restore_ctx1[C : Context](ctx : C) -> Unit {
  let v1 = C::emit_risc_v(ctx, @riscv.RvAsm::RestoreCtx1)
  // Rule at src/riscv/riscv.isle line 509.
  return v1
}

// Generated as internal constructor for term rv_save_ctx2.
pub fn constructor_rv_save_ctx2[C : Context](ctx : C) -> Unit {
  let v1 = C::emit_risc_v(ctx, @riscv.RvAsm::SaveCtx2)
  // Rule at src/riscv/riscv.isle line 512.
  return v1
}

// Generated as internal constructor for term rv_restore_ctx2.
pub fn constructor_rv_restore_ctx2[C : Context](ctx : C) -> Unit {
  let v1 = C::emit_risc_v(ctx, @riscv.RvAsm::RestoreCtx2)
  // Rule at src/riscv/riscv.isle line 515.
  return v1
}

// Generated as internal constructor for term lower_imm.
pub fn constructor_lower_imm[C : Context](
  ctx : C,
  arg0 : @core.Type,
  arg1 : UInt64
) -> @riscv.AnyReg {
  match arg0 {
    @core.Type::Int32 => {
      match arg1 {
        0x0 => {
          let v2 = C::zero_reg(ctx)
          let v10 = C::xreg_to_reg(ctx, v2)
          // Rule at src/lower/riscv/lower.isle line 11.
          return v10
        }
        _ => ()
      }
      let v11 = constructor_ty_int32(ctx)
      let v12 = C::i64_sext_u64(ctx, v11, arg1)
      let v13 = C::imm64_to_string(ctx, v12)
      let v14 = constructor_rv_li(ctx, v13)
      let v15 = C::xreg_to_reg(ctx, v14)
      // Rule at src/lower/riscv/lower.isle line 17.
      return v15
    }
    @core.Type::Int64 => {
      match arg1 {
        0x0 => {
          let v2 = C::zero_reg(ctx)
          let v10 = C::xreg_to_reg(ctx, v2)
          // Rule at src/lower/riscv/lower.isle line 14.
          return v10
        }
        _ => ()
      }
      let v5 = constructor_ty_int64(ctx)
      let v16 = C::i64_sext_u64(ctx, v5, arg1)
      let v17 = C::imm64_to_string(ctx, v16)
      let v18 = constructor_rv_li(ctx, v17)
      let v19 = C::xreg_to_reg(ctx, v18)
      // Rule at src/lower/riscv/lower.isle line 21.
      return v19
    }
    @core.Type::Double => {
      match arg1 {
        0x0 => {
          let v2 = C::zero_reg(ctx)
          let v3 = constructor_rv_fmv_dx(ctx, v2)
          let v4 = C::freg_to_reg(ctx, v3)
          // Rule at src/lower/riscv/lower.isle line 4.
          return v4
        }
        _ => ()
      }
      let v5 = constructor_ty_int64(ctx)
      let v6 = constructor_lower_imm(ctx, v5, arg1)
      let v7 = C::xreg_new(ctx, v6)
      let v8 = constructor_rv_fmv_dx(ctx, v7)
      let v9 = C::freg_to_reg(ctx, v8)
      // Rule at src/lower/riscv/lower.isle line 7.
      return v9
    }
    _ => ()
  }
  abort(
    "no rule matched for term lower_imm at src/lower/riscv/lower.isle line 2; should it be partial?",
  )
}

// Generated as internal constructor for term lower_value.
pub fn constructor_lower_value[C : Context](
  ctx : C,
  arg0 : @core.Value
) -> @riscv.AnyReg {
  match arg0 {
    @core.Value::Unit => {
      let v1 = constructor_ty_int32(ctx)
      let v3 = constructor_lower_imm(ctx, v1, 0x0)
      // Rule at src/lower/riscv/lower.isle line 46.
      return v3
    }
    @core.Value::Bool(val=v4) =>
      match v4 {
        true => {
          let v1 = constructor_ty_int32(ctx)
          let v6 = constructor_lower_imm(ctx, v1, 0x1)
          // Rule at src/lower/riscv/lower.isle line 49.
          return v6
        }
        false => {
          let v1 = constructor_ty_int32(ctx)
          let v3 = constructor_lower_imm(ctx, v1, 0x0)
          // Rule at src/lower/riscv/lower.isle line 52.
          return v3
        }
        _ => ()
      }
    @core.Value::Double(val=v14) => {
      let v15 = constructor_ty_double(ctx)
      let v16 = C::f64_as_u64(ctx, v14)
      let v17 = constructor_lower_imm(ctx, v15, v16)
      // Rule at src/lower/riscv/lower.isle line 61.
      return v17
    }
    @core.Value::Int32(val=v7) => {
      let v1 = constructor_ty_int32(ctx)
      let v8 = C::i32_as_u64(ctx, v7)
      let v9 = constructor_lower_imm(ctx, v1, v8)
      // Rule at src/lower/riscv/lower.isle line 55.
      return v9
    }
    @core.Value::Int64(val=v10) => {
      let v11 = constructor_ty_int64(ctx)
      let v12 = C::i64_as_u64(ctx, v10)
      let v13 = constructor_lower_imm(ctx, v11, v12)
      // Rule at src/lower/riscv/lower.isle line 58.
      return v13
    }
    @core.Value::Fn(fref=v18) => {
      let v19 = C::lower_load_fn(ctx, v18)
      // Rule at src/lower/riscv/lower.isle line 64.
      return v19
    }
    @core.Value::Self(fref=v20) => {
      let v21 = C::closure_reg(ctx)
      let v22 = C::xreg_to_reg(ctx, v21)
      // Rule at src/lower/riscv/lower.isle line 67.
      return v22
    }
    _ => ()
  }
  let v23 = C::put_in_reg(ctx, arg0)
  // Rule at src/lower/riscv/lower.isle line 70.
  return v23
}

// Generated as internal constructor for term lower_x_value.
pub fn constructor_lower_x_value[C : Context](
  ctx : C,
  arg0 : @core.Value
) -> @riscv.Reg {
  let v1 = constructor_lower_value(ctx, arg0)
  let v2 = C::xreg_new(ctx, v1)
  // Rule at src/lower/riscv/lower.isle line 29.
  return v2
}

// Generated as internal constructor for term lower_f_value.
pub fn constructor_lower_f_value[C : Context](
  ctx : C,
  arg0 : @core.Value
) -> @riscv.FReg {
  let v1 = constructor_lower_value(ctx, arg0)
  let v2 = C::freg_new(ctx, v1)
  // Rule at src/lower/riscv/lower.isle line 33.
  return v2
}

// Generated as internal constructor for term lower_control.
pub fn constructor_lower_control[C : Context](
  ctx : C,
  arg0 : @core.Control
) -> Unit? {
  match arg0 {
    @core.Control::Jump(target=v1, args=v2) => {
      let v3 = C::emit_block_parameters(ctx, v1, v2)
      let v4 = C::block_label(ctx, v1)
      let v5 = constructor_rv_j(ctx, v4)
      let v6 = Some(v5)
      // Rule at src/lower/riscv/lower.isle line 86.
      return v6
    }
    @core.Control::Return(args=v7) => {
      let v8 = C::values_to_args(ctx, v7)
      match v8 {
        Some(v9) =>
          match v9 {
            Args::Args1(arg1=v15) => {
              let v16 = C::has_type(ctx, v15)
              match v16.1 {
                @core.Type::Double => {
                  let v19 = constructor_lower_value(ctx, v16.0)
                  let v20 = C::freg_new(ctx, v19)
                  let v21 = C::float_return_reg(ctx)
                  let v22 = constructor_rv_fmv_to(ctx, v21, v20)
                  let v23 = C::emit_fake_epilogue(ctx)
                  let v24 = constructor_rv_fret(ctx)
                  let v25 = Some(v24)
                  // Rule at src/lower/riscv/lower.isle line 97.
                  return v25
                }
                _ => ()
              }
              let v26 = constructor_lower_value(ctx, v15)
              let v27 = C::xreg_new(ctx, v26)
              let v28 = C::return_reg(ctx)
              let v29 = constructor_rv_mv_to(ctx, v28, v27)
              let v23 = C::emit_fake_epilogue(ctx)
              let v30 = constructor_rv_xret(ctx)
              let v31 = Some(v30)
              // Rule at src/lower/riscv/lower.isle line 103.
              return v31
            }
            Args::Args0 => {
              let v10 = C::return_reg(ctx)
              let v11 = C::zero_reg(ctx)
              let v12 = constructor_rv_mv_to(ctx, v10, v11)
              let v13 = constructor_rv_xret(ctx)
              let v14 = Some(v13)
              // Rule at src/lower/riscv/lower.isle line 90.
              return v14
            }
            _ => ()
          }
        _ => ()
      }
    }
    @core.Control::Branch(cond=v32, t=v33, t_args=v34, f=v35, f_args=v36) => {
      let v37 = constructor_lower_value(ctx, v32)
      let v38 = C::xreg_new(ctx, v37)
      let v39 = C::emit_block_parameters(ctx, v33, v34)
      let v40 = C::block_label(ctx, v33)
      let v41 = constructor_rv_bnez(ctx, v38, v40)
      let v42 = C::emit_block_parameters(ctx, v35, v36)
      let v43 = C::block_label(ctx, v35)
      let v44 = constructor_rv_j(ctx, v43)
      let v45 = Some(v44)
      // Rule at src/lower/riscv/lower.isle line 109.
      return v45
    }
    _ => ()
  }
  None
}

// Generated as internal constructor for term lower.
pub fn constructor_lower[C : Context](
  ctx : C,
  arg0 : @core.Insn
) -> @riscv.AnyReg? {
  match arg0 {
    @core.Insn::Op(ty=v1, op=v2, args=v3) =>
      match v1 {
        @core.Type::Bool =>
          match v2 {
            @core.Op::Lnot => {
              let v4 = C::values_to_args(ctx, v3)
              match v4 {
                Some(v5) =>
                  match v5 {
                    Args::Args1(arg1=v28) => {
                      let v29 = constructor_lower_value(ctx, v28)
                      let v30 = C::xreg_new(ctx, v29)
                      let v36 = constructor_rv_sltiu(ctx, v30, 0x1)
                      let v37 = C::xreg_to_reg(ctx, v36)
                      let v38 = C::mark_maybe_aliased(ctx, v37)
                      let v39 = Some(v38)
                      // Rule at src/lower/riscv/lower.isle line 152.
                      return v39
                    }
                    _ => ()
                  }
                _ => ()
              }
            }
            @core.Op::Eq => {
              let v4 = C::values_to_args(ctx, v3)
              match v4 {
                Some(v5) =>
                  match v5 {
                    Args::Args2(arg1=v6, arg2=v7) => {
                      let v40 = C::has_type(ctx, v6)
                      let v43 = C::has_type(ctx, v7)
                      if v40.1 == v43.1 {
                        let v46 = constructor_lower_value(ctx, v40.0)
                        let v47 = C::xreg_new(ctx, v46)
                        let v48 = constructor_lower_value(ctx, v43.0)
                        let v49 = C::xreg_new(ctx, v48)
                        let v50 = constructor_rv_xor(ctx, v47, v49)
                        let v51 = constructor_rv_sltiu(ctx, v50, 0x1)
                        let v52 = C::xreg_to_reg(ctx, v51)
                        let v53 = C::mark_maybe_aliased(ctx, v52)
                        let v54 = Some(v53)
                        // Rule at src/lower/riscv/lower.isle line 158.
                        return v54
                      }
                    }
                    _ => ()
                  }
                _ => ()
              }
            }
            @core.Op::Le => {
              let v4 = C::values_to_args(ctx, v3)
              match v4 {
                Some(v5) =>
                  match v5 {
                    Args::Args2(arg1=v6, arg2=v7) => {
                      let v40 = C::has_type(ctx, v6)
                      let v43 = C::has_type(ctx, v7)
                      if v40.1 == v43.1 {
                        let v55 = constructor_lower_value(ctx, v43.0)
                        let v56 = C::xreg_new(ctx, v55)
                        let v57 = constructor_lower_value(ctx, v40.0)
                        let v58 = C::xreg_new(ctx, v57)
                        let v59 = constructor_rv_slt(ctx, v56, v58)
                        let v60 = constructor_rv_xori(ctx, v59, 0x1)
                        let v61 = C::xreg_to_reg(ctx, v60)
                        let v62 = C::mark_maybe_aliased(ctx, v61)
                        let v63 = Some(v62)
                        // Rule at src/lower/riscv/lower.isle line 165.
                        return v63
                      }
                    }
                    _ => ()
                  }
                _ => ()
              }
            }
            _ => ()
          }
        @core.Type::Int32 =>
          match v2 {
            @core.Op::Add => {
              let v4 = C::values_to_args(ctx, v3)
              match v4 {
                Some(v5) =>
                  match v5 {
                    Args::Args2(arg1=v6, arg2=v7) => {
                      let v8 = constructor_lower_value(ctx, v6)
                      let v9 = C::xreg_new(ctx, v8)
                      let v10 = constructor_lower_value(ctx, v7)
                      let v11 = C::xreg_new(ctx, v10)
                      let v12 = constructor_rv_add(ctx, v9, v11)
                      let v13 = C::xreg_to_reg(ctx, v12)
                      let v14 = C::mark_maybe_aliased(ctx, v13)
                      let v15 = Some(v14)
                      // Rule at src/lower/riscv/lower.isle line 123.
                      return v15
                    }
                    _ => ()
                  }
                _ => ()
              }
            }
            @core.Op::Sub => {
              let v4 = C::values_to_args(ctx, v3)
              match v4 {
                Some(v5) =>
                  match v5 {
                    Args::Args2(arg1=v6, arg2=v7) => {
                      let v8 = constructor_lower_value(ctx, v6)
                      let v9 = C::xreg_new(ctx, v8)
                      let v10 = constructor_lower_value(ctx, v7)
                      let v11 = C::xreg_new(ctx, v10)
                      let v16 = constructor_rv_sub(ctx, v9, v11)
                      let v17 = C::xreg_to_reg(ctx, v16)
                      let v18 = C::mark_maybe_aliased(ctx, v17)
                      let v19 = Some(v18)
                      // Rule at src/lower/riscv/lower.isle line 128.
                      return v19
                    }
                    _ => ()
                  }
                _ => ()
              }
            }
            @core.Op::Mul => {
              let v4 = C::values_to_args(ctx, v3)
              match v4 {
                Some(v5) =>
                  match v5 {
                    Args::Args2(arg1=v6, arg2=v7) => {
                      let v8 = constructor_lower_value(ctx, v6)
                      let v9 = C::xreg_new(ctx, v8)
                      let v10 = constructor_lower_value(ctx, v7)
                      let v11 = C::xreg_new(ctx, v10)
                      let v20 = constructor_rv_mulw(ctx, v9, v11)
                      let v21 = C::xreg_to_reg(ctx, v20)
                      let v22 = C::mark_maybe_aliased(ctx, v21)
                      let v23 = Some(v22)
                      // Rule at src/lower/riscv/lower.isle line 134.
                      return v23
                    }
                    _ => ()
                  }
                _ => ()
              }
            }
            @core.Op::Div => {
              let v4 = C::values_to_args(ctx, v3)
              match v4 {
                Some(v5) =>
                  match v5 {
                    Args::Args2(arg1=v6, arg2=v7) => {
                      let v8 = constructor_lower_value(ctx, v6)
                      let v9 = C::xreg_new(ctx, v8)
                      let v10 = constructor_lower_value(ctx, v7)
                      let v11 = C::xreg_new(ctx, v10)
                      let v24 = constructor_rv_divw(ctx, v9, v11)
                      let v25 = C::xreg_to_reg(ctx, v24)
                      let v26 = C::mark_maybe_aliased(ctx, v25)
                      let v27 = Some(v26)
                      // Rule at src/lower/riscv/lower.isle line 140.
                      return v27
                    }
                    _ => ()
                  }
                _ => ()
              }
            }
            @core.Op::Neg => {
              let v4 = C::values_to_args(ctx, v3)
              match v4 {
                Some(v5) =>
                  match v5 {
                    Args::Args1(arg1=v28) => {
                      let v29 = constructor_lower_value(ctx, v28)
                      let v30 = C::xreg_new(ctx, v29)
                      let v31 = constructor_rv_neg(ctx, v30)
                      let v32 = C::xreg_to_reg(ctx, v31)
                      let v33 = C::mark_maybe_aliased(ctx, v32)
                      let v34 = Some(v33)
                      // Rule at src/lower/riscv/lower.isle line 146.
                      return v34
                    }
                    _ => ()
                  }
                _ => ()
              }
            }
            @core.Op::D2I(rm=v99) => {
              let v4 = C::values_to_args(ctx, v3)
              match v4 {
                Some(v5) =>
                  match v5 {
                    Args::Args1(arg1=v28) => {
                      let v29 = constructor_lower_value(ctx, v28)
                      let v82 = C::freg_new(ctx, v29)
                      let v100 = constructor_rv_fcvt_w_d(ctx, v82, v99)
                      let v101 = C::xreg_to_reg(ctx, v100)
                      let v102 = C::mark_maybe_aliased(ctx, v101)
                      let v103 = Some(v102)
                      // Rule at src/lower/riscv/lower.isle line 214.
                      return v103
                    }
                    _ => ()
                  }
                _ => ()
              }
            }
            _ => ()
          }
        @core.Type::Double =>
          match v2 {
            @core.Op::Add => {
              let v4 = C::values_to_args(ctx, v3)
              match v4 {
                Some(v5) =>
                  match v5 {
                    Args::Args2(arg1=v6, arg2=v7) => {
                      let v8 = constructor_lower_value(ctx, v6)
                      let v64 = C::freg_new(ctx, v8)
                      let v10 = constructor_lower_value(ctx, v7)
                      let v65 = C::freg_new(ctx, v10)
                      let v66 = constructor_rv_fadd_d(ctx, v64, v65)
                      let v67 = C::freg_to_reg(ctx, v66)
                      let v68 = C::mark_maybe_aliased(ctx, v67)
                      let v69 = Some(v68)
                      // Rule at src/lower/riscv/lower.isle line 172.
                      return v69
                    }
                    _ => ()
                  }
                _ => ()
              }
            }
            @core.Op::Sub => {
              let v4 = C::values_to_args(ctx, v3)
              match v4 {
                Some(v5) =>
                  match v5 {
                    Args::Args2(arg1=v6, arg2=v7) => {
                      let v8 = constructor_lower_value(ctx, v6)
                      let v64 = C::freg_new(ctx, v8)
                      let v10 = constructor_lower_value(ctx, v7)
                      let v65 = C::freg_new(ctx, v10)
                      let v70 = constructor_rv_fsub_d(ctx, v64, v65)
                      let v71 = C::freg_to_reg(ctx, v70)
                      let v72 = C::mark_maybe_aliased(ctx, v71)
                      let v73 = Some(v72)
                      // Rule at src/lower/riscv/lower.isle line 178.
                      return v73
                    }
                    _ => ()
                  }
                _ => ()
              }
            }
            @core.Op::Mul => {
              let v4 = C::values_to_args(ctx, v3)
              match v4 {
                Some(v5) =>
                  match v5 {
                    Args::Args2(arg1=v6, arg2=v7) => {
                      let v8 = constructor_lower_value(ctx, v6)
                      let v64 = C::freg_new(ctx, v8)
                      let v10 = constructor_lower_value(ctx, v7)
                      let v65 = C::freg_new(ctx, v10)
                      let v74 = constructor_rv_fmul_d(ctx, v64, v65)
                      let v75 = C::freg_to_reg(ctx, v74)
                      let v76 = C::mark_maybe_aliased(ctx, v75)
                      let v77 = Some(v76)
                      // Rule at src/lower/riscv/lower.isle line 184.
                      return v77
                    }
                    _ => ()
                  }
                _ => ()
              }
            }
            @core.Op::Div => {
              let v4 = C::values_to_args(ctx, v3)
              match v4 {
                Some(v5) =>
                  match v5 {
                    Args::Args2(arg1=v6, arg2=v7) => {
                      let v8 = constructor_lower_value(ctx, v6)
                      let v64 = C::freg_new(ctx, v8)
                      let v10 = constructor_lower_value(ctx, v7)
                      let v65 = C::freg_new(ctx, v10)
                      let v78 = constructor_rv_fdiv_d(ctx, v64, v65)
                      let v79 = C::freg_to_reg(ctx, v78)
                      let v80 = C::mark_maybe_aliased(ctx, v79)
                      let v81 = Some(v80)
                      // Rule at src/lower/riscv/lower.isle line 190.
                      return v81
                    }
                    _ => ()
                  }
                _ => ()
              }
            }
            @core.Op::Neg => {
              let v4 = C::values_to_args(ctx, v3)
              match v4 {
                Some(v5) =>
                  match v5 {
                    Args::Args1(arg1=v28) => {
                      let v29 = constructor_lower_value(ctx, v28)
                      let v82 = C::freg_new(ctx, v29)
                      let v83 = constructor_rv_fneg_d(ctx, v82)
                      let v84 = C::freg_to_reg(ctx, v83)
                      let v85 = C::mark_maybe_aliased(ctx, v84)
                      let v86 = Some(v85)
                      // Rule at src/lower/riscv/lower.isle line 196.
                      return v86
                    }
                    _ => ()
                  }
                _ => ()
              }
            }
            @core.Op::I2D => {
              let v4 = C::values_to_args(ctx, v3)
              match v4 {
                Some(v5) =>
                  match v5 {
                    Args::Args1(arg1=v28) => {
                      let v29 = constructor_lower_value(ctx, v28)
                      let v30 = C::xreg_new(ctx, v29)
                      let v95 = constructor_rv_fcvt_d_w(ctx, v30)
                      let v96 = C::freg_to_reg(ctx, v95)
                      let v97 = C::mark_maybe_aliased(ctx, v96)
                      let v98 = Some(v97)
                      // Rule at src/lower/riscv/lower.isle line 211.
                      return v98
                    }
                    _ => ()
                  }
                _ => ()
              }
            }
            @core.Op::Abs => {
              let v4 = C::values_to_args(ctx, v3)
              match v4 {
                Some(v5) =>
                  match v5 {
                    Args::Args1(arg1=v28) => {
                      let v29 = constructor_lower_value(ctx, v28)
                      let v82 = C::freg_new(ctx, v29)
                      let v87 = constructor_rv_fabs_d(ctx, v82)
                      let v88 = C::freg_to_reg(ctx, v87)
                      let v89 = C::mark_maybe_aliased(ctx, v88)
                      let v90 = Some(v89)
                      // Rule at src/lower/riscv/lower.isle line 201.
                      return v90
                    }
                    _ => ()
                  }
                _ => ()
              }
            }
            @core.Op::Sqrt => {
              let v4 = C::values_to_args(ctx, v3)
              match v4 {
                Some(v5) =>
                  match v5 {
                    Args::Args1(arg1=v28) => {
                      let v29 = constructor_lower_value(ctx, v28)
                      let v82 = C::freg_new(ctx, v29)
                      let v91 = constructor_rv_fsqrt_d(ctx, v82)
                      let v92 = C::freg_to_reg(ctx, v91)
                      let v93 = C::mark_maybe_aliased(ctx, v92)
                      let v94 = Some(v93)
                      // Rule at src/lower/riscv/lower.isle line 206.
                      return v94
                    }
                    _ => ()
                  }
                _ => ()
              }
            }
            _ => ()
          }
        _ => ()
      }
    @core.Insn::Call(ty=v110, f=v111, args=v112) => {
      let v113 = C::ref_fn(ctx, v111)
      let v114 = C::lower_call(ctx, v110, v113, v112)
      let v115 = C::mark_maybe_aliased(ctx, v114)
      let v116 = Some(v115)
      // Rule at src/lower/riscv/lower.isle line 246.
      return v116
    }
    @core.Insn::Apply(ty=v117, f=v118, args=v119) => {
      let v120 = C::lower_apply(ctx, v117, v118, v119)
      let v121 = C::mark_maybe_aliased(ctx, v120)
      let v122 = Some(v121)
      // Rule at src/lower/riscv/lower.isle line 249.
      return v122
    }
    @core.Insn::ExtCall(ty=v104, ext_f=v105, args=v106) => {
      let v107 = C::lower_ext_call(ctx, v104, v105, v106)
      let v108 = C::mark_maybe_aliased(ctx, v107)
      let v109 = Some(v108)
      // Rule at src/lower/riscv/lower.isle line 243.
      return v109
    }
    @core.Insn::LoadSymbol(ty=v123, sref=v124) => {
      let v125 = C::lower_load_symbol(ctx, v123, v124)
      let v126 = C::mark_maybe_aliased(ctx, v125)
      let v127 = Some(v126)
      // Rule at src/lower/riscv/lower.isle line 252.
      return v127
    }
    @core.Insn::Alloc(ty=v139, mref=v140, fills=v141) => {
      let v142 = C::lower_alloc(ctx, v139, v140, v141)
      let v143 = C::mark_maybe_aliased(ctx, v142)
      let v144 = Some(v143)
      // Rule at src/lower/riscv/lower.isle line 261.
      return v144
    }
    @core.Insn::Store(ty=v128, ma=v129, val=v130) => {
      let v131 = C::lower_store(ctx, v128, v129, v130)
      let v132 = C::mark_maybe_aliased(ctx, v131)
      let v133 = Some(v132)
      // Rule at src/lower/riscv/lower.isle line 255.
      return v133
    }
    @core.Insn::Load(ty=v134, ma=v135) => {
      let v136 = C::lower_load(ctx, v134, v135)
      let v137 = C::mark_maybe_aliased(ctx, v136)
      let v138 = Some(v137)
      // Rule at src/lower/riscv/lower.isle line 258.
      return v138
    }
    _ => ()
  }
  None
}
