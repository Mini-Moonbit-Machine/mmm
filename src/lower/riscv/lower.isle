;;;; Rules for immediate values

(decl imm (Type UInt64) AnyReg)

(rule 1 (imm (ty_double) 0)
  (rv_f_mv_dx (zero_reg)))

(rule (imm (ty_double) c)
  (let ((c1 AnyReg (imm (ty_int64) c)))
    (rv_f_mv_dx c1)))

(rule (imm (ty_int32) c)
  (let ((i32_imm Int64 (i64_sext_u64 (ty_int32) c)))
    (rv_li i32_imm)))

(rule (imm (ty_int64) c)
  (let ((i64_imm Int64 (i64_sext_u64 (ty_int64) c)))
    (rv_li i64_imm)))

(decl partial lower_value (Value) AnyReg)

(decl lower_call (Type Fn Values) AnyReg)
(extern constructor lower_call lower_call)

(decl lower_ext_call (Type String Values) AnyReg)
(extern constructor lower_ext_call lower_ext_call)

(decl lower_apply (Type Value Values) AnyReg)
(extern constructor lower_apply lower_apply)

(rule (lower_value (val_int32 c))
  (imm (ty_int32) (i32_as_u64 c)))

(rule (lower_value (val_int64 c))
  (imm (ty_int64) (i64_as_u64 c)))

(rule (lower_value (val_double c))
  (imm (ty_double) (f64_as_u64 c)))

(rule (lower_value (val_self _))
  (closure_reg))

(rule -1 (lower_value val)
  (put_in_reg val))

(decl imm12_from_val (Imm12) Value)
(extern extractor imm12_from_val imm12_from_val)

(decl partial lower (Insn) AnyReg)

;;;; Rules for i32 additions
;;;; Notice: the official template uses 64b instructions for 32b operations

(rule (lower (insn_op (ty_int32) (op_add) (arg2 a b)))
  (rv_add a b))


;;;; Rules for i32 subtractions

(rule (lower (insn_op (ty_int32) (op_sub) (arg2 a b)))
  (rv_sub a a))


;;;; Rules for i32 multiplications

(rule (lower (insn_op (ty_int32) (op_mul) (arg2 a b)))
  (rv_mulw a b))


;;;; Rules for i32 divisions

(rule (lower (insn_op (ty_int32) (op_div) (arg2 a b)))
  (rv_divw a b))


;;;; Rules for i32 negations

(rule (lower (insn_op (ty_int32) (op_neg) (arg1 a)))
  (rv_neg a))


;;;; Rules for i32 logical not

(rule (lower (insn_op (ty_int32) (op_lnot) (arg1 a)))
  (rv_sltiu a 1))


;;;; Rules for i32 equalities

(rule (lower (insn_op (ty_int32) (op_eq) (arg2 a b)))
  (let ((r XReg (rv_xor a b)))
    (rv_sltiu r 1)))


;;;; Rules for i32 less than or equal

(rule (lower (insn_op (ty_int32) (op_le) (arg2 a b)))
  (let ((r XReg (rv_sltu a b)))
    (rv_xori r 1)))


;;;; Rules for f64 additions

(rule (lower (insn_op (ty_double) (op_add) (arg2 a b)))
  (rv_fadd_d a b))


;;;; Rules for f64 subtractions

(rule (lower (insn_op (ty_double) (op_sub) (arg2 a b)))
  (rv_fsub_d a b))


;;;; Rules for f64 multiplications

(rule (lower (insn_op (ty_double) (op_mul) (arg2 a b)))
  (rv_fmul_d a b))


;;;; Rules for f64 divisions

(rule (lower (insn_op (ty_double) (op_div) (arg2 a b)))
  (rv_fdiv_d a b))


;;;; Rules for f64 negations

(rule (lower (insn_op (ty_double) (op_neg) (arg1 a)))
  (rv_fneg_d a))

;;;; Rules for external calls, calls and applications

(rule (lower (insn_ext_call ty f args))
  (lower_ext_call ty f args))

(rule (lower (insn_call ty (ref_fn f) args))
  (lower_call ty f args))

(rule (lower (insn_apply ty f args))
  (lower_apply ty f args))
