package moonbitlang/minimbt/knf

alias @moonbitlang/core/hashset as @hashset
alias @moonbitlang/core/immut/hashmap as @hashmap
alias @moonbitlang/minimbt as @minimbt

// Values
fn knf_fdef_free_vars(FuncDef) -> @hashset.T[@minimbt.Name]

fn knf_free_vars(Knf) -> @hashset.T[@minimbt.Name]

fn knf_max_counter(Knf) -> Int

// Types and methods
type Binding

pub struct FreeSetClosure {
  pub ctx : Map[@minimbt.Name, @hashset.T[@minimbt.Name]]
  pub changed : Bool
}
impl FreeSetClosure {
  compute(Self, Knf) -> (@hashset.T[@minimbt.Name], Map[@minimbt.Name, @hashset.T[@minimbt.Name]])
  knf_fdef_free_vars_closure(Self, FuncDef) -> @hashset.T[@minimbt.Name]
  knf_free_vars_closure(Self, Knf) -> @hashset.T[@minimbt.Name]
  new() -> Self
}

pub struct FuncDef {
  pub name : @minimbt.Name
  pub ty : @minimbt.Type
  pub args : Array[(@minimbt.Name, @minimbt.Type)]
  pub body : Knf
}
impl FuncDef {
  from_json(Json) -> Self!
  op_equal(Self, Self) -> Bool
  to_json(Self) -> Json
  to_string(Self) -> String
}

pub enum Knf {
  Unit
  Int(Int)
  Double(Double)
  Neg(@minimbt.Name)
  Add(@minimbt.Name, @minimbt.Name)
  Sub(@minimbt.Name, @minimbt.Name)
  Mul(@minimbt.Name, @minimbt.Name)
  Div(@minimbt.Name, @minimbt.Name)
  FNeg(@minimbt.Name)
  FAdd(@minimbt.Name, @minimbt.Name)
  FSub(@minimbt.Name, @minimbt.Name)
  FMul(@minimbt.Name, @minimbt.Name)
  FDiv(@minimbt.Name, @minimbt.Name)
  IfEq(@minimbt.Name, @minimbt.Name, Knf, Knf)
  IfLe(@minimbt.Name, @minimbt.Name, Knf, Knf)
  Let((@minimbt.Name, @minimbt.Type), Knf, Knf)
  Var(@minimbt.Name)
  LetRec(FuncDef, Knf)
  Apply(@minimbt.Name, Array[@minimbt.Name])
  Tuple(Array[@minimbt.Name])
  LetTuple(Array[(@minimbt.Name, @minimbt.Type)], @minimbt.Name, Knf)
  Get(@minimbt.Name, @minimbt.Name)
  Put(@minimbt.Name, @minimbt.Name, @minimbt.Name)
  ExternalArray(@minimbt.Name)
  ExternalFunctionApplication(String, Array[@minimbt.Name])
}
impl Knf {
  from_json(Json) -> Self!
  op_equal(Self, Self) -> Bool
  to_json(Self) -> Json
  to_pretty_print(Self) -> PrettyKnf
  to_string(Self) -> String
}

type KnfEnv
impl KnfEnv {
  init_counter_from_existing(Self, Knf) -> Unit
  new(@hashmap.T[String, @minimbt.Type]) -> Self
  syntax_preprocess(Self, @minimbt.Syntax, Bool, Bool) -> @minimbt.Syntax
  to_knf(Self, @minimbt.Syntax) -> Knf!Failure
}

pub struct LambdaLiftEnv {
  pub name_ctx : @hashmap.T[@minimbt.Name, (@minimbt.Name, Array[@minimbt.Name], Array[@minimbt.Name], @minimbt.Type)]
  pub type_ctx : @hashmap.T[@minimbt.Name, @minimbt.Type]
  pub free_set_closure : Map[@minimbt.Name, @hashset.T[@minimbt.Name]]
  pub top_bindings : Array[Binding]
  pub top_names : @hashset.T[@minimbt.Name]
  pub lifted_counter : UInt
  pub closure_counter : UInt
}
impl LambdaLiftEnv {
  eta_expand(Self, @minimbt.Name) -> (Array[Binding], @minimbt.Name, Self)
  go(Self, Knf) -> Knf
  new() -> Self
}

type PrettyKnf

// Type aliases
pub typealias LocalEnv = @hashmap.T[String, @minimbt.Type]

pub typealias Name = @minimbt.Name

pub typealias NameEnv = @hashmap.T[String, @minimbt.Name]

pub typealias Type = @minimbt.Type

// Traits

// Extension Methods
impl Show for FuncDef

impl Show for Knf

impl Show for PrettyKnf

